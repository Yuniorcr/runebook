<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b69aab99f02e831fdaf85f1e3ecb658a4bca7288" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;configure_requires&lt;/code&gt; field of your</source>
          <target state="translated">이것은 귀하 의 &lt;code&gt;configure_requires&lt;/code&gt; 필드로 이동합니다</target>
        </trans-unit>
        <trans-unit id="044f8f7fc28b6f913f2eb7261e1be2cd16a84799" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;requires&lt;/code&gt; field of your</source>
          <target state="translated">이것은 당신 의 &lt;code&gt;requires&lt;/code&gt; 필드로 이동합니다</target>
        </trans-unit>
        <trans-unit id="7b80864e93830ef0ed83edd0adbf1c600a67743b" translate="yes" xml:space="preserve">
          <source>This will hold all the output of a command. It needs to be a reference to a scalar. Note that this will hold both the STDOUT and STDERR messages, and you have no way of telling which is which. If you require this distinction, run the &lt;code&gt;run&lt;/code&gt; command in list context and inspect the individual buffers.</source>
          <target state="translated">이것은 명령의 모든 출력을 보유합니다. 스칼라에 대한 참조 여야합니다. STDOUT 및 STDERR 메시지를 모두 보유하며 어떤 메시지인지를 알 수있는 방법이 없습니다. 이 구별이 필요한 경우 list 컨텍스트에서 &lt;code&gt;run&lt;/code&gt; 명령을 실행 하고 개별 버퍼를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="02c623985a1a7dc417e0a406fc6886bed2478d0f" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt; , you'll get the following error:</source>
          <target state="translated">이것은 실제로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 만들지 만 &lt;code&gt;key&lt;/code&gt; 값을 수정하려고하면 하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32d093230d8afd4dfa30e5b675bc05f84dd94d65" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;undef&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt;, you'll get the following error:</source>
          <target state="translated">이것은 실제로 &lt;code&gt;undef&lt;/code&gt; 값을 만들 것이지만 &lt;code&gt;key&lt;/code&gt; 값을 수정하려고 하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c59ff5ece51fef3713b13fdc203a334520a2680" translate="yes" xml:space="preserve">
          <source>This will indeed remove all references to destroyed objects, but the remaining references to objects will be strong, causing the remaining objects to never be destroyed because there is now always a strong reference to them in the @object array.</source>
          <target state="translated">이렇게하면 실제로 파괴 된 오브젝트에 대한 모든 참조가 제거되지만, 오브젝트에 대한 나머지 참조는 강력 해 지므로 @object 배열에는 항상 오브젝트에 대한 강한 참조가 있기 때문에 나머지 오브젝트는 절대로 파괴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="502a4e7b5c19c4f943e0927f97d4e589d92242b6" translate="yes" xml:space="preserve">
          <source>This will install Perl, including</source>
          <target state="translated">이것은 다음을 포함하여 Perl을 설치합니다</target>
        </trans-unit>
        <trans-unit id="5360f0733d6fa5a59167722a15beb5e5d0628299" translate="yes" xml:space="preserve">
          <source>This will install all files in the module under your home directory, with man pages and libraries going into an appropriate place (usually ~/man and ~/lib). How the exact location is determined is complicated and depends on how your Perl was configured. INSTALL_BASE works more like what other build systems call &quot;prefix&quot; than PREFIX and we recommend you use that instead.</source>
          <target state="translated">그러면 맨 페이지와 라이브러리가 적절한 위치 (보통 ~ / man 및 ~ / lib)로 이동하여 모듈의 모든 파일이 홈 디렉토리 아래에 설치됩니다. 정확한 위치를 결정하는 방법은 복잡하며 Perl의 구성 방법에 따라 다릅니다. INSTALL_BASE는 PREFIX가 아닌 다른 빌드 시스템이 &quot;접두사&quot;라고 부르는 것과 더 유사하므로 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c93de459956112e67c32897f139a786020e9ae92" translate="yes" xml:space="preserve">
          <source>This will install the module's architecture-independent files into ~/lib, the architecture-dependent files into ~/lib/$archname.</source>
          <target state="translated">그러면 모듈의 아키텍처 독립적 파일은 ~ / lib에 설치되고 아키텍처 종속 파일은 ~ / lib / $ archname에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="037930b84c250a860d75497404c0fa5cd777c91f" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; . MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="translated">&lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; 가 호출됩니다 . MyExpirePolicy :: TIEHASH는 캐시를 설정하기 위해 적절한 작업을 수행해야하며 캐시 객체를 호출자에게 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5a59c7a890c0f22a657cb40bc1da8408c4952ff" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt;. MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="translated">그러면 &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; 가 호출됩니다 . MyExpirePolicy :: TIEHASH는 캐시를 설정하는 데 적절한 작업을 수행해야하며 캐시 개체를 호출자에게 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b7f85cc213a9528b5fae8654b1de379039b58cd" translate="yes" xml:space="preserve">
          <source>This will invoke the Perl script</source>
          <target state="translated">이것은 Perl 스크립트를 호출합니다</target>
        </trans-unit>
        <trans-unit id="2d3ad41335ec2699e64793b18bdc830c93f34fd9" translate="yes" xml:space="preserve">
          <source>This will issue a warning from the file and line number of the context.</source>
          <target state="translated">그러면 컨텍스트의 파일 및 줄 번호에서 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d7846c6fc3f33f521fafde1ba9db4c27782855d" translate="yes" xml:space="preserve">
          <source>This will likely require many formatters to have tables mapping from treatable Unicode codepoints (such as the &quot;\xE9&quot; for the e-acute character) to the escape sequences or codes necessary for conveying such sequences in the target output format. A converter to *roff would, for example know that &quot;\xE9&quot; (whether conveyed literally, or via a E&amp;lt;...&amp;gt; sequence) is to be conveyed as &quot;e\\*'&quot;. Similarly, a program rendering Pod in a Mac OS application window, would presumably need to know that &quot;\xE9&quot; maps to codepoint 142 in MacRoman encoding that (at time of writing) is native for Mac OS. Such Unicode2whatever mappings are presumably already widely available for common output formats. (Such mappings may be incomplete! Implementers are not expected to bend over backwards in an attempt to render Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any of the other weird things that Unicode can encode.) And if a Pod document uses a character not found in such a mapping, the formatter should consider it an unrenderable character.</source>
          <target state="translated">이를 위해서는 많은 포맷터가 처리 가능한 유니 코드 코드 포인트 (예 : e-acute 문자의 경우 &quot;\ xE9&quot;)에서 이스케이프 시퀀스 또는 이러한 시퀀스를 대상 출력 형식으로 전달하는 데 필요한 코드로 테이블을 매핑해야합니다. 예를 들어 * roff 로의 변환기는 &quot;\ xE9&quot;(문자 그대로 전달하든 E &amp;lt;...&amp;gt; 시퀀스를 통해 전달되는지)가 &quot;e \\ * '&quot;로 전달되어야 함을 알고 있습니다. 마찬가지로, Mac OS 응용 프로그램 윈도우에서 포드를 렌더링하는 프로그램은 아마도 &quot;\ xE9&quot;가 MacRoman 인코딩에서 코드 포인트 142 (매핑 시점)가 Mac OS에 고유하다는 것을 코드 포인트 142에 매핑한다는 것을 알아야합니다. 이러한 유니 코드 2 매핑은 아마도 일반적인 출력 형식에 이미 널리 사용 가능할 것입니다. (이러한 매핑은 불완전 할 수 있습니다!구현 자들은 체로키 음절, 에트루리아 룬 문자, 비잔틴 음악 기호 또는 유니 코드가 인코딩 할 수있는 다른 이상한 것들을 렌더링하려는 시도에서 뒤로 구부러지지 않을 것으로 예상됩니다.) 그리고 포드 문서가 그러한 매핑에서 찾을 수없는 문자를 사용하는 경우 포맷터는 렌더링 할 수없는 문자로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9af5931254814b66f0bff8fcce1663d48d23196" translate="yes" xml:space="preserve">
          <source>This will load the core of the Getopt::Long module and prepare your program for using it. Most of the actual Getopt::Long code is not loaded until you really call one of its functions.</source>
          <target state="translated">Getopt :: Long 모듈의 핵심을로드하고 프로그램을 사용할 수 있도록 준비합니다. 실제 Getopt :: Long 코드의 대부분은 실제로 함수 중 하나를 호출 할 때까지로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84613dc13583c880545edeaa7309fbaf7d904405" translate="yes" xml:space="preserve">
          <source>This will load the necessary things (like BigInt) when they are needed, and automatically.</source>
          <target state="translated">필요한 경우 자동으로 필요한 항목 (BigInt 등)을로드합니다.</target>
        </trans-unit>
        <trans-unit id="7a6931f78851cb973cc9d65880d16fc9ed754cce" translate="yes" xml:space="preserve">
          <source>This will make a shallow clone of the facet. You may specify fields to override as arguments.</source>
          <target state="translated">이렇게하면 패싯의 얕은 복제본이 만들어집니다. 인수로 재정의 할 필드를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8f3b44f04663247b0f9e8a7dffb832852e0f5e" translate="yes" xml:space="preserve">
          <source>This will match all non-Unicode code points, since every one of them is not in Kana. You can use intersection to exclude these, if desired, as this modified example shows:</source>
          <target state="translated">이 코드는 모두 유니 코드가 아닌 코드 포인트와 일치합니다. 하나는 모두 Kana에 없기 때문입니다. 이 수정 된 예에서 볼 수 있듯이 교차점을 사용하여 원하는 경우 이들을 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="944f02167d664ef9e70480a5d72868212b398166" translate="yes" xml:space="preserve">
          <source>This will match all the digit characters that are in the Thai script.</source>
          <target state="translated">태국어 스크립트에있는 모든 숫자 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="99b2cac7ea367f44702a2a2abb89101d039ec9d6" translate="yes" xml:space="preserve">
          <source>This will normally hide the current context for the top hub. If you need to hide the context for a different hub you can pass in the optional &lt;code&gt;$hid&lt;/code&gt; parameter.</source>
          <target state="translated">일반적으로 상위 허브의 현재 컨텍스트를 숨 깁니다. 다른 허브에 대한 컨텍스트를 숨겨야하는 경우 선택적 &lt;code&gt;$hid&lt;/code&gt; 매개 변수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6273e23b6c541cdfeea4c27da4fef2152f6377e8" translate="yes" xml:space="preserve">
          <source>This will only show up under use strict (another good reason to run under use strict).</source>
          <target state="translated">이것은 엄격하게 사용하는 경우에만 표시됩니다 (사용이 엄격한 상태에서 실행해야하는 또 다른 이유).</target>
        </trans-unit>
        <trans-unit id="c65fa159bab1e30bba712c2c1e9c30d9ac5133d7" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="translated">이 규칙은 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 로 최적화 되므로 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 는 고려되지 않습니다 (규칙에서 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 에서 스마트 매치를 사용한다고 말하더라도 ). 이와 같은 대체의 경우 배열 참조가 작동합니다. 이는 스마트 매칭을 요구하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="33deb2e289bee882cbf3028d1fec9799baf70dd3" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt;). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="translated">이렇게하면 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 로 최적화 되므로 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 는 고려되지 않습니다 (규칙에서 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 에 대한 스마트 매치를 사용하도록 명시되어 있음에도 불구하고 ). 이와 같은 대체의 경우 배열 참조가 작동합니다. 이는 스마트 매칭을 시작하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4c8134855a16c717eaa6422187d170260e57cb1b" translate="yes" xml:space="preserve">
          <source>This will output only the &lt;code&gt;=head2 Algorithm&lt;/code&gt; heading and content within the &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; section. The regexp binding is stronger than the section separator, such that e.g.:</source>
          <target state="translated">이렇게하면 &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; 섹션 내의 &lt;code&gt;=head2 Algorithm&lt;/code&gt; 제목 및 콘텐츠 만 출력됩니다 . 정규 표현식 바인딩은 섹션 구분 기호보다 강력합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a53b7fc46cab28aa51967ea901426700557399bc" translate="yes" xml:space="preserve">
          <source>This will pop a hub from the stack, if the hub at the top of the stack does not match the hub you expect (passed in as an argument) it will throw an exception.</source>
          <target state="translated">이것은 스택에서 허브를 팝하고, 스택의 맨 위에있는 허브가 예상 한 허브와 일치하지 않는 경우 (인수로 전달됨) 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8cbe9fcb0b43d3c677dc5305458ee2e62e4a31f" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutine whose names are in the list, allowing you to use them without parentheses even before they're declared.</source>
          <target state="translated">이름이 목록에있는 모든 서브 루틴을 미리 선언하여 선언하기 전에 괄호없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c5fdfb9dbf5dd576a4fe59626b53e05f4e7d63" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutines whose names are in the list, allowing you to use them without parentheses (as list operators) even before they're declared.</source>
          <target state="translated">이렇게하면 이름이 목록에있는 모든 서브 루틴이 미리 선언되어 선언되기 전에 괄호없이 (목록 연산자로) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0485931e797f0d3157ea50aac95b26b852bb2c34" translate="yes" xml:space="preserve">
          <source>This will predeclare all the variables whose names are in the list, allowing you to use them under &quot;use strict&quot;, and disabling any typo warnings.</source>
          <target state="translated">이름이 목록에있는 모든 변수를 미리 선언하여 &quot;엄격한 사용&quot;하에서 오타 경고를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="translated">이것은 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="0c513de1733ecd2b8ffce2a2e048c7fdbe91583f" translate="yes" xml:space="preserve">
          <source>This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the result).</source>
          <target state="translated">이것은 -2가 아닌 -3을 인쇄합니다 (-5를 2로 나누고 결과를 자르는 것처럼).</target>
        </trans-unit>
        <trans-unit id="e88a5abf01aa2eb9eaafc62c5178572c3f0dcb93" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt; 섹션의 카테고리 별 Perl 함수 와 같이 Perl의 기능을 그룹화 된 목록으로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="e41583327bc9cc32aaa0b02aa5d9186e43155f80" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;&quot;Perl Functions by Category&quot; in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt; 섹션의 &quot;카테고리 별 Perl 함수&quot; 와 같이 Perl 함수 의 그룹화 된 목록을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="06f3c28ca20ac2a91e7b3a25f9cd8948580e5a8c" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt; . This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="translated">&lt;code&gt;$Config{static_ext}&lt;/code&gt; 에 있는 &lt;code&gt;libperl&lt;/code&gt; 및 확장과 연결하기위한 인수를 인쇄 합니다 . 여기에는 &lt;code&gt;$Config{libs}&lt;/code&gt; 에있는 라이브러리와 &lt;code&gt;@INC&lt;/code&gt; 또는 &lt;b&gt;-I&lt;/b&gt; 옵션으로 지정된 경로 를 검색하여 찾은 각 확장에 대한 첫 번째 ModuleName.a 라이브러리가 포함됩니다 . 또한 ModuleName.a가 발견되면 추가 링커 인수가&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e1a6cfe75b96e0fdc730bad6aa31b403693c30dc" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt;. This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="translated">그러면 &lt;code&gt;$Config{static_ext}&lt;/code&gt; 에 있는 &lt;code&gt;libperl&lt;/code&gt; 및 확장과 연결하기위한 인수가 인쇄됩니다 . 여기에는 &lt;code&gt;$Config{libs}&lt;/code&gt; 에있는 라이브러리와 &lt;code&gt;@INC&lt;/code&gt; 또는 &lt;b&gt;-I&lt;/b&gt; 옵션으로 지정된 경로 를 검색하여 찾은 각 확장에 대한 첫 번째 ModuleName.a 라이브러리가 포함됩니다 . 또한 ModuleName.a가 발견되면 추가 링커 인수가&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f60443610a43a49d5ead9ee72728dd61dc61c29" translate="yes" xml:space="preserve">
          <source>This will print only the content of &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; and the &lt;code&gt;=head2 Introduction&lt;/code&gt; sections, but no other &lt;code&gt;=head2&lt;/code&gt;, and no other &lt;code&gt;=head1&lt;/code&gt; either.</source>
          <target state="translated">이렇게하면 &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; 및 &lt;code&gt;=head2 Introduction&lt;/code&gt; 섹션 의 내용 만 인쇄 되고 다른 &lt;code&gt;=head2&lt;/code&gt; 및 다른 &lt;code&gt;=head1&lt;/code&gt; 도 인쇄 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="672df04456226246b8abe50d62f0bbee0ad0889a" translate="yes" xml:space="preserve">
          <source>This will print out</source>
          <target state="translated">인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="0a53fd47cfa0cb2aa29facae441d5e18a6061c7b" translate="yes" xml:space="preserve">
          <source>This will print out a warning about overwriting Mytest2, but that's okay. Our files are stored in Mytest2/mylib, and will be untouched.</source>
          <target state="translated">Mytest2 덮어 쓰기에 대한 경고가 표시되지만 괜찮습니다. 우리의 파일은 Mytest2 / mylib에 저장되며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bed74d2734f7ca79e0f367ce5a29d3b84e44af2" translate="yes" xml:space="preserve">
          <source>This will print...</source>
          <target state="translated">이것은 인쇄됩니다 ...</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="899924678036d32490097cf13a3010a6c2e916cc" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot;</source>
          <target state="translated">&quot; &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="40197f89d9552ed2ed618b0a94d0da9bdd7f768c" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt;&quot;</source>
          <target state="translated">이렇게하면 &quot; &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="65d8f131a0962cd0151f9af4c7b366b97852fe0c" translate="yes" xml:space="preserve">
          <source>This will push the new hub onto the stack.</source>
          <target state="translated">그러면 새 허브가 스택으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e190e6e848eda316c1f8903ac738aaf6f899b4" translate="yes" xml:space="preserve">
          <source>This will put modules into</source>
          <target state="translated">이것은 모듈을 넣을 것입니다</target>
        </trans-unit>
        <trans-unit id="7f52025f3fd591756e387158d1cd6ccc53bfb3a5" translate="yes" xml:space="preserve">
          <source>This will quote $text so it is interpreted literally in the shell.</source>
          <target state="translated">이것은 $ text를 인용하여 문자 그대로 쉘에서 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="41f7aa0266df2687cdc027e0895ee05c3a8cf995" translate="yes" xml:space="preserve">
          <source>This will release the context. This runs cleanup tasks, and several important hooks. It will also restore &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created.</source>
          <target state="translated">그러면 컨텍스트가 해제됩니다. 이것은 정리 작업과 몇 가지 중요한 후크를 실행합니다. 또한 &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$?&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 는 컨텍스트가 생성되었을 때의 모습으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cec316130454262fb9a931304c0dde874c470f8c" translate="yes" xml:space="preserve">
          <source>This will remove the value of a specified meta &lt;code&gt;$key&lt;/code&gt;. The old &lt;code&gt;$val&lt;/code&gt; will be returned.</source>
          <target state="translated">이것은 지정된 meta &lt;code&gt;$key&lt;/code&gt; 값을 제거합니다 . 이전 &lt;code&gt;$val&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="07824cc0b4d23c3d3bb1cfda8a48de7d53df4bf2" translate="yes" xml:space="preserve">
          <source>This will reset the state of the incremental parser and will remove the parsed text from the input buffer so far. This is useful after &lt;code&gt;incr_parse&lt;/code&gt; died, in which case the input buffer and incremental parser state is left unchanged, to skip the text parsed so far and to reset the parse state.</source>
          <target state="translated">이렇게하면 증분 파서의 상태가 재설정되고 지금까지 입력 버퍼에서 구문 분석 된 텍스트가 제거됩니다. 이는 &lt;code&gt;incr_parse&lt;/code&gt; 가 종료 된 후 입력 버퍼 및 증분 파서 상태가 변경되지 않은 경우 지금까지 구문 분석 된 텍스트를 건너 뛰고 구문 분석 상태를 재설정하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f61ad8e0b3eb41c5891bbe5a0d386a76431ba8" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;undef&lt;/code&gt; if the relationship cannot be checked, which happens if either event has an incomplete or missing trace. This will return &lt;code&gt;0&lt;/code&gt; if the traces are complete, but do not match. &lt;code&gt;1&lt;/code&gt; will be returned if there is a match.</source>
          <target state="translated">관계를 확인할 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 반환 됩니다. 이벤트에 추적이 불완전하거나 누락 된 경우 발생합니다. 추적이 완료되었지만 일치하지 않으면 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다. 일치하는 경우 &lt;code&gt;1&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd2b879f129714bea8a682b5294c7417238be95" translate="yes" xml:space="preserve">
          <source>This will return a hashref of facet data. Each facet hash will be a shallow copy of the original.</source>
          <target state="translated">패싯 데이터의 해시 참조를 반환합니다. 각 패싯 해시는 원본의 얕은 사본이됩니다.</target>
        </trans-unit>
        <trans-unit id="f59d5228b102dd5cbad2d2e6da168ec6245e7a05" translate="yes" xml:space="preserve">
          <source>This will return a shallow clone of the context. The shallow clone is safe to store for later.</source>
          <target state="translated">컨텍스트의 얕은 복제본을 반환합니다. 얕은 클론은 나중에 보관해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="fe211d3e5a7b27ac06f1bfed9d79529a0b4e0811" translate="yes" xml:space="preserve">
          <source>This will return all the hubs in the stack as a list.</source>
          <target state="translated">그러면 스택의 모든 허브가 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fa038bab0a35a1278c1028a76b1b599ab2f3c7" translate="yes" xml:space="preserve">
          <source>This will return the</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="3012b886e66f0d66b1233e77e03322a89d9ca8d0" translate="yes" xml:space="preserve">
          <source>This will return the 'about' facet hashref.</source>
          <target state="translated">이것은 'about'패싯 해시 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d3892ab0e68676392aba5a3deb55d6e5f3a7a00" translate="yes" xml:space="preserve">
          <source>This will return the 'trace' facet, normally blessed (but this is not enforced when the trace is set using &lt;code&gt;set_trace()&lt;/code&gt;.</source>
          <target state="translated">이것은 일반적으로 축복받은 '추적'패싯을 반환합니다 (그러나 추적이 &lt;code&gt;set_trace()&lt;/code&gt; 사용하여 설정되면 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c947246a8100b62a64074ea3ea27340d97e5c57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance the context used to find the current hub.</source>
          <target state="translated">그러면 현재 허브를 찾는 데 사용 된 컨텍스트 인 &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2 :: API :: Stack&lt;/a&gt; 인스턴스 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="071d70de3cfed7ceb62bef529de3f7a12de2cf57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt; instance used by the context.</source>
          <target state="translated">그러면 컨텍스트에서 사용 하는 &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2 :: EventFacet :: Trace&lt;/a&gt; 인스턴스 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1e2a334411bcce7d3ed6759e85d7774c7db84a" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance the context recognizes as the current one to which all events should be sent.</source>
          <target state="translated">그러면 컨텍스트가 모든 이벤트를 보내야하는 현재 인스턴스로 인식 하는 &lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt; 인스턴스 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2912d0daea2e211af97d7e1a3ea98a0298d18c0b" translate="yes" xml:space="preserve">
          <source>This will return the filename based on the template but will not open this file. Cannot be used in conjunction with UNLINK set to true. Default is to always open the file to protect from possible race conditions. A warning is issued if warnings are turned on. Consider using the tmpnam() and mktemp() functions described elsewhere in this document if opening the file is not required.</source>
          <target state="translated">템플릿에 따라 파일 이름이 반환되지만이 파일은 열리지 않습니다. UNLINK를 true로 설정하면 사용할 수 없습니다. 기본값은 가능한 경쟁 조건으로부터 보호하기 위해 항상 파일을 여는 것입니다. 경고가 설정되면 경고가 발행됩니다. 파일을 열 필요가없는 경우이 문서의 다른 곳에 설명 된 tmpnam () 및 mktemp () 함수 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5166921abcf19f440f3497ae7dcd12be03f7bc28" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="translated">그러면 전역 &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2 :: API :: Stack&lt;/a&gt; 인스턴스 가 반환됩니다 . 아직 초기화되지 않은 경우 지금 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="a995f385670c66d0da520343be6badafb9165a59" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::IPC::Driver&quot;&gt;Test2::IPC::Driver&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="translated">그러면 전역 &lt;a href=&quot;Test2::IPC::Driver&quot;&gt;Test2 :: IPC :: Driver&lt;/a&gt; 인스턴스 가 반환됩니다 . 아직 초기화되지 않은 경우 지금 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d642486b0fdba840f586862b0632bdfe7b784cf3" translate="yes" xml:space="preserve">
          <source>This will return the global formatter class. This is not an instance. By default the formatter is set to &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt;.</source>
          <target state="translated">이것은 전역 포맷터 클래스를 반환합니다. 이것은 인스턴스가 아닙니다. 기본적으로 포맷터는 &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2 :: Formatter :: TAP로&lt;/a&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a43701025bcaaa97f4c20a7fae8b7f58307dc924" translate="yes" xml:space="preserve">
          <source>This will return the id of the current thread when threads are enabled, otherwise it returns 0.</source>
          <target state="translated">스레드가 활성화되면 현재 스레드의 ID를 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a95636615c967951a75f0745e419202e8c181663" translate="yes" xml:space="preserve">
          <source>This will return the key for the facet in the facet data hash.</source>
          <target state="translated">패싯 데이터 해시의 패싯 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d82f0a6881fcf3d362a2caae5716b353b8c09bb4" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will create it.</source>
          <target state="translated">스택에서 최상위 허브를 반환합니다. 아직 상단 허브가 없으면 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d0e21b9306afe027cffc8be7eb5a1ef6fdaafd" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will return undef.</source>
          <target state="translated">스택에서 최상위 허브를 반환합니다. 아직 상단 허브가 없으면 undef가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="626d4c923543f739ced5a5a4133e42da29976f88" translate="yes" xml:space="preserve">
          <source>This will return true if testing is complete and no other events should be sent. This is useful in things like warning handlers where you might want to turn warnings into events, but need them to start acting like normal warnings when testing is done.</source>
          <target state="translated">테스트가 완료되고 다른 이벤트를 보내지 않아야하는 경우 true를 반환합니다. 이는 경고를 이벤트로 바꾸고 싶지만 테스트가 완료 될 때 정상적인 경고처럼 작동하기 시작해야하는 경고 핸들러와 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dc9e1cf54480f23b5df8c08401a8eff218ed9c89" translate="yes" xml:space="preserve">
          <source>This will return true if the facet should be in a list instead of a single item.</source>
          <target state="translated">패싯이 단일 항목이 아닌 목록에 있어야하는 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="058b4ba4b9036eb7bc1ad3260ce86f253167e2de" translate="yes" xml:space="preserve">
          <source>This will return true if the stack and IPC instances have already been initialized. It will return false if they have not. Init happens as late as possible. It happens as soon as a tool requests the IPC instance, the formatter, or the stack.</source>
          <target state="translated">스택 및 IPC 인스턴스가 이미 초기화 된 경우 true를 반환합니다. 그렇지 않은 경우 false를 반환합니다. 초기화는 가능한 한 늦게 발생합니다. 도구가 IPC 인스턴스, 포맷터 또는 스택을 요청하자마자 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afb834590329aede62a7b1a0c021d221b2c6d004" translate="yes" xml:space="preserve">
          <source>This will run Configure and keep a record:</source>
          <target state="translated">그러면 Configure 및 record 기록이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="af9c0543615ac7cf90353b4a24138697b5df455b" translate="yes" xml:space="preserve">
          <source>This will run the provided codeblock with the args in &lt;code&gt;@args&lt;/code&gt;. This codeblock will be run as a subtest. A subtest is an isolated test state that is condensed into a single &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event, which contains all events generated inside the subtest.</source>
          <target state="translated">이렇게하면 &lt;code&gt;@args&lt;/code&gt; 의 인수를 사용하여 제공된 코드 블록이 실행됩니다 . 이 코드 블록은 하위 테스트로 실행됩니다. 하위 테스트는 하위 테스트 내에서 생성 된 모든 이벤트를 포함 하는 단일 &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2 :: Event :: Subtest&lt;/a&gt; 이벤트 로 압축 된 격리 된 테스트 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="3ec88525a1d6ccafa3d30457de14d7bad4de11c0" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; , or failing that, &lt;code&gt;MyPlugin&lt;/code&gt; . If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="translated">이 명명 된 모듈을 검색합니다 &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; , 또는 실패, &lt;code&gt;MyPlugin&lt;/code&gt; . 플러그인을 찾을 수없는 경우, &lt;code&gt;prove&lt;/code&gt; 불평 및 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5e687f1f0bf9f59f044484eb486936cdf9e849ac" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt;, or failing that, &lt;code&gt;MyPlugin&lt;/code&gt;. If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="translated">그러면 &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; 이라는 모듈을 검색 하거나 실패하면 &lt;code&gt;MyPlugin&lt;/code&gt; 입니다. 플러그인을 찾을 수없는 경우, &lt;code&gt;prove&lt;/code&gt; 가 불만을 제기하고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f30c710e3d8112c1044077c8cf0f284dc043fe97" translate="yes" xml:space="preserve">
          <source>This will send and return an &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; event. You may optionally provide a &lt;code&gt;$name&lt;/code&gt; for the assertion.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2 :: Event :: Pass&lt;/a&gt; 이벤트 를 보내고 반환합니다 . 선택적으로 어설 션에 대해 &lt;code&gt;$name&lt;/code&gt; 을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6032dd11dd54e4e97302369ddf59357d7575753c" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created. There is no localization or anything done here, calling this method will actually set these vars.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 가 설정됩니다 ! , &lt;code&gt;$?&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 는 컨텍스트가 생성되었을 때의 모습으로 변경됩니다. 여기에서는 현지화 또는 수행 된 작업이 없습니다.이 메서드를 호출하면 실제로 이러한 변수가 설정됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="53857214badcaa71270373a4350b085fd3be23d6" translate="yes" xml:space="preserve">
          <source>This will set the value, but it will also warn you that the method is deprecated.</source>
          <target state="translated">이렇게하면 값이 설정되지만 메서드가 더 이상 사용되지 않는다는 경고도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9f2435be0f1ad6eda0969960399156643c76c7a4" translate="yes" xml:space="preserve">
          <source>This will silence warnings from this module, as shown above.</source>
          <target state="translated">이렇게하면 위에 표시된대로이 모듈의 경고가 음소거됩니다.</target>
        </trans-unit>
        <trans-unit id="ca31d9fb831c9a9410b0952a2719e1cdb223f34f" translate="yes" xml:space="preserve">
          <source>This will simply return the boolean value of the loaded flag. If Test2 has finished loading this will be true, otherwise false. Loading is considered complete the first time a tool requests a context.</source>
          <target state="translated">이것은 단순히로드 된 플래그의 부울 값을 반환합니다. Test2가로드를 완료하면 true가되고 그렇지 않으면 false가됩니다. 도구가 컨텍스트를 처음 요청할 때로드가 완료된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="74d8c906bb8ef849bacade7aef9b4a5b44d353f1" translate="yes" xml:space="preserve">
          <source>This will still print 10, not 20. Remember that local() affects package variables, which are all &quot;global&quot; to the package.</source>
          <target state="translated">이것은 여전히 ​​20이 아닌 10을 인쇄합니다. local ()은 패키지 변수에 영향을 미치며 패키지 변수는 모두 패키지에 &quot;전역&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2a6fcacb9fbe4a51fd646facf84bbf9e55589d63" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeletable for some reason (protected, not there, and so on).</source>
          <target state="translated">어떤 이유로 파일을 삭제할 수없는 경우 (보호됨, 거기에 없음 등) 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="feff36db777feae7b7039051928fb49050eaab4e" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeleteable for some reason (protected, not there, and so on).</source>
          <target state="translated">어떤 이유로 파일을 삭제할 수없는 경우 (보호되거나없는 등) 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7ffb822c298702a56540cec9f5d17292e8f99429" translate="yes" xml:space="preserve">
          <source>This will throw an exception reporting to the file and line number of the context. This will also release the context for you.</source>
          <target state="translated">그러면 컨텍스트의 파일 및 줄 번호에보고되는 예외가 발생합니다. 이것은 또한 당신을 위해 컨텍스트를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d039d7ba20b83e75e45e1330e7ddf21cf6828e15" translate="yes" xml:space="preserve">
          <source>This will try to load a module &lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt; and use it as an &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; subclass. If that fails, it'll try loading &lt;code&gt;Excommunicated&lt;/code&gt; as a module, if that fails, it'll try to read a file called</source>
          <target state="translated">&lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt; 모듈을로드하고 이를 &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 하위 클래스 로 사용 하려고 시도합니다 . 실패하면 &lt;code&gt;Excommunicated&lt;/code&gt; 를 모듈로 로드 하고 실패하면 다음과 같은 파일을 읽으려고합니다.</target>
        </trans-unit>
        <trans-unit id="1bd914f7804d4417b7bb5813b67988d44deeaf55" translate="yes" xml:space="preserve">
          <source>This will try to read &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; from the &lt;code&gt;@INC&lt;/code&gt; path. This file should return a list in plain perl:</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 경로 에서 &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; 을 읽으려고 합니다. 이 파일은 일반 펄로리스트를 반환해야합니다 :</target>
        </trans-unit>
        <trans-unit id="77f2b91fc53461e4232392b6bf05a6cab13fc62c" translate="yes" xml:space="preserve">
          <source>This will turn off result long-term storage. Calling this method will make &lt;code&gt;details&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; useless. You may want to use this if you are running enough tests to fill up all available memory.</source>
          <target state="translated">결과 장기 저장이 해제됩니다. 이 메서드를 호출하면 &lt;code&gt;details&lt;/code&gt; 와 &lt;code&gt;summary&lt;/code&gt; 쓸모 없게됩니다. 사용 가능한 모든 메모리를 채우기에 충분한 테스트를 실행하는 경우이 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ef65510ce174baa0db67a974cf806364df6c54" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt; s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="translated">이하려고 차단 된 임의의 스레드 차단을 해제합니다 &lt;code&gt;down&lt;/code&gt; 경우 세마포어 &lt;code&gt;up&lt;/code&gt; 하는 금액 위의 세마포어의 카운트 제기 &lt;code&gt;down&lt;/code&gt; 하여 감소하려고합니다. 예를 들어, 세 개의 스레드가 세마포어를 하나씩 &lt;code&gt;down&lt;/code&gt; 려고 시도 하고 다른 스레드 가 세마포어를 두 번 &lt;code&gt;up&lt;/code&gt; 차단 된 스레드 중 두 개 (결정되지 않은 두 개)가 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="2291862c9d641fb23bcd9328e8bf9135209ce8c7" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt;s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="translated">이하려고 차단 된 임의의 스레드 차단을 해제합니다 &lt;code&gt;down&lt;/code&gt; 경우 세마포어 &lt;code&gt;up&lt;/code&gt; 하는 금액 위의 세마포어의 카운트 제기 &lt;code&gt;down&lt;/code&gt; 하여 감소하려고합니다. 예를 들어, 3 개의 스레드가 하나의 세마포어 를 &lt;code&gt;down&lt;/code&gt; 시키려고 차단 되고 다른 스레드 가 2 개의 세마포어를 &lt;code&gt;up&lt;/code&gt; 으로하면 차단 된 스레드 중 2 개 (두 개는 미정)가 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="6f351c4b6aca96e53a16da8efca1e61fe6247c18" translate="yes" xml:space="preserve">
          <source>This will use miniperl to complete the rest of the build.</source>
          <target state="translated">miniperl을 사용하여 나머지 빌드를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="c16d64a3c76763b9210f27c1d7475ba78b790318" translate="yes" xml:space="preserve">
          <source>This will wait for the corresponding thread to complete its execution. When the thread finishes, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; will return the return value(s) of the entry point function.</source>
          <target state="translated">해당 스레드가 실행을 완료 할 때까지 기다립니다. 스레드가 완료되면 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 은 진입 점 함수의 반환 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2af730ddaf4e289f57edfe5d0943ccf22cf812f6" translate="yes" xml:space="preserve">
          <source>This won't expand &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or &lt;code&gt;&quot;\t&quot;&lt;/code&gt; or any other special escapes.</source>
          <target state="translated">이 확장되지 않습니다 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 또는 기타 특수 이스케이프는 .</target>
        </trans-unit>
        <trans-unit id="f64d878770a911b3e3aee44ed6986ddc7e345565" translate="yes" xml:space="preserve">
          <source>This work is published from Taiwan.</source>
          <target state="translated">이 작품은 대만에서 출간되었습니다.</target>
        </trans-unit>
        <trans-unit id="d34159428b026fd2a257dac5cc4d16c93aa663f8" translate="yes" xml:space="preserve">
          <source>This workaround is unnecessary since Unicode 6.3.0.</source>
          <target state="translated">이 해결 방법은 유니 코드 6.3.0부터 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c1458dfe63303a12ab8e9dcbe389526ca2f043c" translate="yes" xml:space="preserve">
          <source>This works</source>
          <target state="translated">이 작동합니다</target>
        </trans-unit>
        <trans-unit id="881dcb6cd52e1e6c1fe3d0de8f69b6f16afcd3ed" translate="yes" xml:space="preserve">
          <source>This works because field hashes respond to keys that are not references like a normal hash would and use the string offered as the hash key. Thus, if a method is called as a class method, the field hash is presented with the class name instead of an object and blithely uses it as a key. Since the keys of real objects are decimal numbers, there is no conflict and the slot in the field hash can be used like any other. The &lt;code&gt;id()&lt;/code&gt; function behaves correspondingly with respect to non-reference arguments.</source>
          <target state="translated">이것은 필드 해시가 일반 해시처럼 참조가 아닌 키에 응답하고 해시 키로 제공된 문자열을 사용하기 때문에 작동합니다. 따라서 메소드가 클래스 메소드로 호출되면 필드 해시에는 객체 대신 클래스 이름이 표시되고 키로 사용됩니다. 실제 객체의 키는 십진수이기 때문에 충돌이 없으며 필드 해시의 슬롯을 다른 것과 같이 사용할 수 있습니다. 그만큼 &lt;code&gt;id()&lt;/code&gt; 함수가 아닌 기준 인자에 대하여 대응 동작.</target>
        </trans-unit>
        <trans-unit id="37aaa803ee7c99ec4174d78cf82dc91b9204b890" translate="yes" xml:space="preserve">
          <source>This works by doing overriding methods on the singleton, and directly accessing hash values on the singleton. A new version has been released that uses the Test2 API to accomplish the same result in a saner way.</source>
          <target state="translated">이것은 싱글 톤에서 메서드를 재정의하고 싱글 톤의 해시 값에 직접 액세스하여 작동합니다. Test2 API를 사용하여 동일한 결과를 더 건전한 방식으로 달성하는 새 버전이 출시되었습니다.</target>
        </trans-unit>
        <trans-unit id="f0fd9a4f981e792862c2c1c34299d3c036119504" translate="yes" xml:space="preserve">
          <source>This works by invoking the &lt;code&gt;FREEZE&lt;/code&gt; method on the object, with the first argument being the object to serialise, and the second argument being the constant string &lt;code&gt;JSON&lt;/code&gt; to distinguish it from other serialisers.</source>
          <target state="translated">이것은 객체 에서 &lt;code&gt;FREEZE&lt;/code&gt; 메서드를 호출하여 작동 합니다. 첫 번째 인수는 직렬화 할 객체이고 두 번째 인수는 다른 직렬화 기와 구별하기 위해 상수 문자열 &lt;code&gt;JSON&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ee37bc8498bec33db688cccd48192a7818024c7e" translate="yes" xml:space="preserve">
          <source>This works even if the package variable has not been used before, as package variables spring into existence when first used.</source>
          <target state="translated">패키지 변수가 처음 사용되었을 때 존재하기 때문에 패키지 변수가 이전에 사용되지 않은 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2dd7e5f2596a2fbf8c9fd904eb776f4f1a29ce3e" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; . This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="translated">이것은 &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; 호출과 정확히 동일합니다. . 동적 코드 작성에 매우 유용합니다. 예를 들어, 매개 변수로 호출 할 메소드 이름을 다른 메소드에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16f7da148af11cbf671d895e51f5a7793076850" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt;. This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="translated">이것은 &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; 호출하는 것과 똑같이 작동합니다 . 이것은 동적 코드를 작성하는 데 매우 유용 할 수 있습니다. 예를 들어, 매개 변수로 호출 할 메서드 이름을 다른 메서드에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5594cfec5e61454de66a12e73e2e1b179cf923ba" translate="yes" xml:space="preserve">
          <source>This works if the dereference produces a string</source>
          <target state="translated">역 참조가 문자열을 생성하는 경우 작동합니다.</target>
        </trans-unit>
        <trans-unit id="38266e487c0f4fb0b669611ed55fd5e57c3bf09c" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;/bin/tar&lt;/code&gt;'s &lt;code&gt;-h&lt;/code&gt; option.</source>
          <target state="translated">이것은 &lt;code&gt;/bin/tar&lt;/code&gt; 의 &lt;code&gt;-h&lt;/code&gt; 옵션 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f4db4f1dcef0abf193caecabc91b1d8ec192b619" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;new_from_file&lt;/code&gt;, except that a handle can be provided as the first argument.</source>
          <target state="translated">핸들이 첫 번째 인수로 제공 될 수 있다는 점을 제외하면 &lt;code&gt;new_from_file&lt;/code&gt; 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="219577552fb5335aa48c2b04bb85269685e4f05b" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;parse_file&lt;/code&gt; except that it reads the Pod content not from a file, but from a string that you have already in memory.</source>
          <target state="translated">이것은 파일에서가 아니라 이미 메모리에있는 문자열에서 Pod 컨텐츠를 읽는다는 점을 제외하면 &lt;code&gt;parse_file&lt;/code&gt; 과 동일하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="97ee63f99fe6452186fce78a0713bcb1bd8591fa" translate="yes" xml:space="preserve">
          <source>This works just like patching anything else, with one extra consideration.</source>
          <target state="translated">이것은 한 가지 추가 고려 사항으로 다른 것을 패치하는 것과 똑같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="038f2b08f3729bf9e55b6c7536286beb304119b2" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="translated">이것은 더 읽기 쉽고 목록 컨텍스트에서 안전하게 호출 할 수 있지만 여전히 한 줄만 반환한다는 점을 제외하면 &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop의 &quot;I / O 연산자&quot;에&lt;/a&gt; 설명 된 &amp;lt;$ fh&amp;gt;처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e00aef65607bdbfd4bbca8fcf5fc5917d56249a8" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="translated">이것은 더 읽기 쉽고 목록 컨텍스트에서 안전하게 호출 할 수 있지만 여전히 한 줄만 반환한다는 점을 제외하고 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자에&lt;/a&gt; 설명 된 &amp;lt;$ fh&amp;gt;와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="dcebba3c0143d6834639907ecbbcce5227295c40" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">이것은리스트 컨텍스트에서 호출 될 때 &amp;lt;$ fh&amp;gt;와 같이 작동하여 파일에서 더 읽기 쉬운 것을 제외하고 파일의 나머지 행을 모두 읽습니다. 또한 실수로 스칼라 컨텍스트에서 호출 된 경우 croak ()됩니다.</target>
        </trans-unit>
        <trans-unit id="7450c62face5ca7b9e02c283184e4738197040fb" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional +within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to +emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; .</source>
          <target state="translated">이것은 더 읽기 쉽고 목록 컨텍스트에서 안전하게 호출 할 수 있지만 여전히 한 줄만 반환한다는 점을 제외하고 &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자에&lt;/a&gt; 설명 된 &amp;lt;$ io&amp;gt;처럼 작동 합니다. 그러나 &lt;code&gt;while&lt;/code&gt; 또는 C 스타일 &lt;code&gt;for&lt;/code&gt; 루프 내에서 조건부로 사용되는 경우 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; 하여 &amp;lt;$ io&amp;gt;의 기능을 + 에뮬레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3495f3db5c4d1d0c89019c28aef54ca3210b08f0" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;defined($_ = $io-&amp;gt;getline)&lt;/code&gt;.</source>
          <target state="translated">이것은 더 읽기 쉽고 목록 컨텍스트에서 안전하게 호출 할 수 있지만 여전히 한 줄만 반환한다는 점을 제외하면 &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop의 &quot;I / O 연산자&quot;에&lt;/a&gt; 설명 된 &amp;lt;$ io&amp;gt;처럼 작동 합니다. 그러나 &lt;code&gt;while&lt;/code&gt; 또는 C 스타일 &lt;code&gt;for&lt;/code&gt; 루프 내에서 조건부로 사용되는 경우 &lt;code&gt;defined($_ = $io-&amp;gt;getline)&lt;/code&gt; 으로 &amp;lt;$ io&amp;gt;의 기능을 에뮬레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8787e54def79a3f32ab71769162cbf50a0d2256" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">이것은 더 읽기 쉬운 것을 제외하고 파일의 나머지 행을 모두 읽기 위해 목록 컨텍스트에서 호출 될 때 &amp;lt;$ io&amp;gt;처럼 작동합니다. 또한 실수로 스칼라 컨텍스트에서 호출 된 경우 croak ()됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc655ffdbbb7b5de088685237be5925d7bbe434" translate="yes" xml:space="preserve">
          <source>This works like &lt;code&gt;implicate_supers&lt;/code&gt; except that the implicated forms are added to the end of the return list.</source>
          <target state="translated">이것은 &lt;code&gt;implicate_supers&lt;/code&gt; 처럼 작동합니다 연루 형태 반환 목록의 끝에 추가된다는 점을 제외하고.</target>
        </trans-unit>
        <trans-unit id="86cdc5ca018e3bf7bd5f95614dd661c8b598198f" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 AUTHOR\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Author\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">이것은 &quot;= head1 AUTHOR \ n \ nParagraph ... \ n&quot;섹션의 내용을 반환한다는 점을 제외하고는 get_title과 비슷하게 작동합니다. 섹션이 너무 길지 않다고 가정합니다. &quot;= head1 Author \ n \ nParagraph \ n&quot;섹션을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="64a77cc5fc2dfee3e1cafa417d88e53b294176fe" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 DESCRIPTION\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Description\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">이것은 &quot;= head1 DESCRIPTION \ n \ nParagraph ... \ n&quot;섹션의 내용을 반환한다는 점을 제외하고 get_title과 유사하게 작동합니다. 섹션이 너무 길지 않다고 가정합니다. &quot;= head1 Description \ n \ nParagraph \ n&quot;섹션을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 를 전달하십시오. 옵션을 .</target>
        </trans-unit>
        <trans-unit id="26df8521ce0593af395e7709eafe289696c2f1f5" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt; !! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">&quot;= head1 VERSION \ n \ n [BIG BLOCK] \ n&quot;블록의 내용을 반환한다는 점을 제외하면 get_title과 유사하게 작동합니다. 이것은 모듈의 &lt;code&gt;$VERSION&lt;/code&gt; 반환하지 않습니다 ! &quot;= head1 Version \ n \ n [BIG BLOCK] \ n&quot;섹션을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a823c0684b5208934f648973411ba95381fb432" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt;!! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">&quot;= head1 VERSION \ n \ n [BIG BLOCK] \ n&quot;블록의 내용을 반환한다는 점을 제외하면 get_title과 유사합니다. 이것은 모듈의 &lt;code&gt;$VERSION&lt;/code&gt; !! &quot;= head1 버전 \ n \ n [BIG BLOCK] \ n&quot;섹션을 인식하려면 &lt;code&gt;nocase&lt;/code&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5587967553798e28442ad51621f624abf3a3ff5" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;decode&lt;/code&gt; method, but instead of raising an exception when there is trailing garbage after the first JSON object, it will silently stop parsing there and return the number of characters consumed so far.</source>
          <target state="translated">이것은 &lt;code&gt;decode&lt;/code&gt; 메소드 처럼 작동 하지만 첫 번째 JSON 객체 뒤에 가비지가 뒤 따르는 경우 예외를 발생시키는 대신 조용히 거기에서 파싱을 중지하고 지금까지 소비 된 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0009c0f22b1f9b3091524f0133e652a04ae0337e" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt; , which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt; .</source>
          <target state="translated">등이 작품 &lt;code&gt;strict_type&lt;/code&gt; 의 옵션은 당신을 전달할 수 있습니다 &lt;code&gt;check&lt;/code&gt; 을 켜 것이다, &lt;code&gt;strict_type&lt;/code&gt; 에 대한 모든 호출에 대해 전역 &lt;code&gt;check&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58a60db99fd5287a02afd89bdfd44fadadefdf30" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt;, which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt;.</source>
          <target state="translated">등이 작품 &lt;code&gt;strict_type&lt;/code&gt; 의 옵션은 당신을 전달할 수 있습니다 &lt;code&gt;check&lt;/code&gt; 을 켜 것이다, &lt;code&gt;strict_type&lt;/code&gt; 에 대한 모든 호출에 대해 전역 &lt;code&gt;check&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="362f494acfae36c73643784bd959c4c06fb6c5c4" translate="yes" xml:space="preserve">
          <source>This works most like other language's behavior when you specify a prefix. We recommend this method.</source>
          <target state="translated">이것은 접두사를 지정할 때 다른 언어의 동작과 가장 유사합니다. 이 방법을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="915aba858aed251bdf66e2831b7666e6978faed3" translate="yes" xml:space="preserve">
          <source>This works only on 5.10+</source>
          <target state="translated">이것은 5.10 이상에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="55b95f28c493942c265a9070f59ae310c120e01c" translate="yes" xml:space="preserve">
          <source>This works under Unix and Windows, and the current version doesn't look half as bad under Windows as it used to. Some of the gui elements still don't 'feel' quite right, though. The interface is very natural and 'perlish', making it easy to use in small scripts that just need a simple gui. It hasn't been updated in a while.</source>
          <target state="translated">이것은 Unix와 Windows에서 작동하며 현재 버전은 Windows에서 사용했던 것보다 절반 정도 나쁘지 않습니다. gui 요소 중 일부는 여전히 정확하지 않습니다. 이 인터페이스는 매우 자연스럽고 'Perlish'이므로 간단한 GUI가 필요한 작은 스크립트에서 쉽게 사용할 수 있습니다. 한동안 업데이트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="455be4bb715491d8c40b42c1f8dcc680c608eb5f" translate="yes" xml:space="preserve">
          <source>This works well, and means that XS authors can gleefully write:</source>
          <target state="translated">이것은 잘 작동하며 XS 작성자가 즐겁게 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b707b9d283df75f490a344769164044f8e4c5af9" translate="yes" xml:space="preserve">
          <source>This works with leading special strings, dynamically determined:</source>
          <target state="translated">이것은 동적으로 결정되는 주요 특수 문자열과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff04426d22726a3d4a81073dac982b940cab46f5" translate="yes" xml:space="preserve">
          <source>This would install the complete distribution file (say BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would like to install version 1.23_90, you need to know where the distribution file resides on CPAN relative to the authors/id/ directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz; so you would have to say</source>
          <target state="translated">그러면 모든 배포 자료와 함께 완전한 배포 파일 (예 : BAR / Foo-1.23.tar.gz)이 설치됩니다. 그러나 버전 1.23_90을 설치하려면, authors / id / 디렉토리와 관련하여 CPAN에서 분배 파일이있는 위치를 알아야합니다. 작성자가 BAR 인 경우 BAR / Foo-1.23_90.tar.gz 일 수 있습니다. 그래서 당신은 말할 것</target>
        </trans-unit>
        <trans-unit id="56ee25d704c11c02d7362a5e6635fcc0e634817b" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt; , nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt; .</source>
          <target state="translated">이렇게하면 &lt;code&gt;My::Carping::Package&lt;/code&gt; 또는 &lt;code&gt;My::Friendly::Caller&lt;/code&gt; 아닌 호출자가 &lt;code&gt;Carp&lt;/code&gt; 보고하여 잉어 가 오류를보고하게됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="019ec406a64daebd498d30d29f05ac3a5a5def69" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt;, nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 &lt;code&gt;Carp&lt;/code&gt; 가 &lt;code&gt;My::Carping::Package&lt;/code&gt; 또는 &lt;code&gt;My::Friendly::Caller&lt;/code&gt; 아닌 호출자로부터 오류가 발생한 것으로보고합니다 .</target>
        </trans-unit>
        <trans-unit id="891cab2fd452efda8a6a8bb2376fc567d9984ca2" translate="yes" xml:space="preserve">
          <source>This would match a line of the form:</source>
          <target state="translated">다음과 같은 형식의 행과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bd1a277e3dce80fb2a8014b20af5fd4775d02c21" translate="yes" xml:space="preserve">
          <source>This would produce.</source>
          <target state="translated">이것은 생산할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3b8e94b68c600a8d4a422c5367048147e22fdaf" translate="yes" xml:space="preserve">
          <source>This would signal to the parser that paragraphs in this begin...end region are subject to normal handling as ordinary/verbatim paragraphs (while still tagged as meant only for processors that understand the &quot;biblio&quot; identifier). The same effect could be had with:</source>
          <target state="translated">이것은이 시작 ... 종료 영역의 단락이 일반 / 언어 적 단락 (일반적으로 &quot;biblio&quot;식별자를 이해하는 프로세서에 대해서만 의미가있는 태그)으로 취급된다는 것을 파서에 알립니다. 동일한 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15fd697862c8639869e1e78b476a5aeed8efb2ef" translate="yes" xml:space="preserve">
          <source>This would start</source>
          <target state="translated">이것은 시작할 것이다</target>
        </trans-unit>
        <trans-unit id="00bebdd1c33f014f6c6f83be97cd8f7afa9c4c0a" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of Perl core the wrapping does not take place. Note, however, that intermixing the _r-forms (as Perl compiled for multithreaded operation will do) and the _r-less forms is neither well-defined (inconsistent results, data corruption, or even crashes become more likely), nor is it very portable.</source>
          <target state="translated">이 랩핑은 Perl 코어 소스 (PERL_CORE가 정의 됨) 또는 Perl 코어 확장 (PERL_EXT가 정의 됨)을 컴파일 할 때 항상 발생합니다. Perl 코어 외부에서 XS 코드를 컴파일 할 때는 줄 바꿈이 수행되지 않습니다. 그러나 _r-forms (멀티 스레드 작업을 위해 컴파일 된 Perl처럼)과 _r-less 형식의 혼합은 잘 정의되지 않았으며 (일관되지 않은 결과, 데이터 손상 또는 충돌 가능성이 높음) 가지고 다닐 수 있는.</target>
        </trans-unit>
        <trans-unit id="d0e68ab8f02ae3faa0396a3a11b0f81dcf6b0685" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of the Perl core, the wrapping does not take place before Perl 5.28. Starting in that release you can</source>
          <target state="translated">이 래핑은 Perl 코어 소스 (PERL_CORE가 정의 됨) 또는 Perl 코어 확장 (PERL_EXT가 정의 됨)을 컴파일 할 때 항상 발생합니다. Perl 코어 외부에서 XS 코드를 컴파일 할 때 Perl 5.28 이전에는 래핑이 수행되지 않습니다. 해당 릴리스부터 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14e5fcab8c4178b44f80118d0d0e8c790e5ed2e6" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt; .</source>
          <target state="translated">이 폭이 0 인 어설 션은 내장 된 Perl 코드를 실행합니다. 항상 성공하고 반환 값은 &lt;code&gt;$^R&lt;/code&gt; 로 설정됩니다. .</target>
        </trans-unit>
        <trans-unit id="037ab5d7d658f9f73dced777295d92918612ab07" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt;.</source>
          <target state="translated">이 제로 너비 어설 션은 포함 된 모든 Perl 코드를 실행합니다. 항상 성공하고 반환 값은 &lt;code&gt;$^R&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3986864eb1cd79d2d3acbfd270bc8eeed78bdddc" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the</source>
          <target state="translated">이 0 너비 패턴은 패턴의 특정 부분이 성공적으로 일치했을 때 문자열에 도달 한 지점을 표시하는 데 사용할 수 있습니다. 이 마크에는 이름이 주어질 수 있습니다. 이후 &lt;code&gt;(*SKIP)&lt;/code&gt; 패턴은 실패시 역 추적되는 경우 해당 지점으로 건너 뜁니다. 모든 &lt;code&gt;(*MARK)&lt;/code&gt; 패턴이 허용되며</target>
        </trans-unit>
        <trans-unit id="018c0e68c94f9f979bcddcd227e8ad92dfe5e9c0" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the NAME portion may be duplicated.</source>
          <target state="translated">이 폭이 0 인 패턴을 사용하면 패턴의 특정 부분이 성공적으로 일치했을 때 문자열에 도달 한 지점을 표시 할 수 있습니다. 이 마크에는 이름이 주어질 수 있습니다. 그런 다음 이후 &lt;code&gt;(*SKIP)&lt;/code&gt; 패턴은 실패시 역 추적되는 경우 해당 지점으로 건너 뜁니다. 임의 개수의 &lt;code&gt;(*MARK)&lt;/code&gt; 패턴이 허용되며 NAME 부분은 복제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e845add8e49d7a0ebfe26e6329051032e10440f" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt; , except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="translated">이 폭이 0 인 패턴은 &lt;code&gt;(*PRUNE)&lt;/code&gt; 과 유사하지만 , 실패시 일치하는 모든 텍스트가 &lt;code&gt;(*SKIP)&lt;/code&gt; 을 나타내는 것을 의미한다는 점을 제외하고 실행되는 패턴에 는 실행할 수 없음을</target>
        </trans-unit>
        <trans-unit id="51e4c7fda54787bcde2f76a35e31d235c61d7234" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt;, except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="translated">이 제로 너비 패턴은 &lt;code&gt;(*PRUNE)&lt;/code&gt; 와 유사하지만 실패시 실행되는 &lt;code&gt;(*SKIP)&lt;/code&gt; 패턴으로 이어지는 일치 된 텍스트가</target>
        </trans-unit>
        <trans-unit id="f14d48589d384cf0a42c2d25bee216599d01f868" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;/&lt;i&gt;A&lt;/i&gt; (*PRUNE) &lt;i&gt;B&lt;/i&gt;/&lt;/code&gt;, where</source>
          <target state="translated">이 0 너비 패턴은 실패시 역 추적 될 때 현재 지점에서 역 추적 트리를 정리합니다. 패턴 &lt;code&gt;/&lt;i&gt;A&lt;/i&gt; (*PRUNE) &lt;i&gt;B&lt;/i&gt;/&lt;/code&gt; 고려하십시오. 여기서</target>
        </trans-unit>
        <trans-unit id="8c4b9623686b3758cfd382a28c93e0707ac9367e" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;A (*PRUNE) B&lt;/code&gt;, where A and B are complex patterns. Until the &lt;code&gt;(*PRUNE)&lt;/code&gt; verb is reached, A may backtrack as necessary to match. Once it is reached, matching continues in B, which may also backtrack as necessary; however, should B not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.</source>
          <target state="translated">이 폭이 0 인 패턴은 실패시 역 추적 될 때 현재 지점에서 역 추적 트리를 제거합니다. 패턴 &lt;code&gt;A (*PRUNE) B&lt;/code&gt; 고려하십시오. 여기서 A 및 B는 복잡한 패턴입니다. &lt;code&gt;(*PRUNE)&lt;/code&gt; 까지 동사에 도달 A는 일치시키기 위해 필요에 따라 역 추적 할 수 있습니다. 도달하면 B에서 일치가 계속되며 필요한 경우 역 추적 할 수도 있습니다. 그러나 B가 일치하지 않으면 더 이상 역 추적이 발생하지 않으며 현재 시작 위치에서 패턴이 완전히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6ab6320cf6b57ad1eb41183660b9a012d0721d64" translate="yes" xml:space="preserve">
          <source>Thomas Dorner</source>
          <target state="translated">토마스 도너</target>
        </trans-unit>
        <trans-unit id="81e4e8d1869fa873203b699ef2f7c28f0d0f204c" translate="yes" xml:space="preserve">
          <source>Those can be rather inefficient though. If they aren't fast enough for you, you might just read chunks of data and count the number of newlines:</source>
          <target state="translated">그러나 비효율적 일 수 있습니다. 그들이 당신을 위해 충분히 빠르지 않은 경우, 당신은 단지 데이터 덩어리를 읽고 줄 바꿈 수를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd34bde8d27f4db80e364187fff01e57e24dcf5" translate="yes" xml:space="preserve">
          <source>Those debugging perl with the DDD frontend over gdb may find the following useful:</source>
          <target state="translated">gdb를 통한 DDD 프론트 엔드를 사용한 디버깅 perl은 다음과 같은 유용한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8de155d193899f771792e739cfd779f42445bfd" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt; , but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; , which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; . It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">낙담 한 양식은 다음에 대한 입력으로 허용됩니다. &lt;code&gt;prop_aliases&lt;/code&gt; 에 대한 되지만 목록에는 리턴되지 않습니다. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; 및 &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; 는 &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; 에 대한 오래된 동의어 이며 새 코드에서 사용해서는 안됩니다. 둘 다 &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; 반환 합니다. 따라서이 기능을 사용하면 낙담 된 형태를 취하고 적절한 대안을 찾을 수 있습니다. 단일 형식의 블록 속성과 동일합니다. &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 로 시작하는 양식 만 권장하지 않습니다. 권장하지 않는 양식을 &lt;code&gt;prop_aliases&lt;/code&gt; 에 전달 하면 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 로 시작하는 해당 양식이 다시 표시됩니다. . 그렇지 않으면 새로운 스타일의 블록 이름처럼 보일 것입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;구식과 새로운 스타일의 블록 이름 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e7315b6f7527f6cad5c0696c36731171292e6d3" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt;, but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt;, which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt;. Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt;. It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="translated">권장 되지 않는 형식은 &lt;code&gt;prop_aliases&lt;/code&gt; 에 대한 입력으로 허용 되지만 목록에 반환되지 않습니다. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; 및 &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; 는 &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; 의 오래된 동의어 이며 새 코드에서 사용해서는 안됩니다. 둘 다 &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; 반환 합니다. 따라서이 기능을 사용하면 낙담 한 형태를 취하고 수용 가능한 대안을 찾을 수 있습니다. 단일 양식 Block 속성 등가도 마찬가지입니다. &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 로 시작하는 양식 만 권장되지 않습니다. &lt;code&gt;prop_aliases&lt;/code&gt; 에 권장되지 않는 양식 을 전달 하면 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 로 시작하는 동등한 양식이 반환됩니다.. 그렇지 않으면 새로운 스타일의 블록 이름처럼 보일 것입니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;이전 스타일과 새로운 스타일의 블록 이름&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3da17d9bf3cc6c170baa5678aa93a096d0f37e23" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">이러한 예제는 또한 &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 모듈을 대신 하여 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 을 사용해서는 안된다는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="6da32d7b6dfc1f76299003b85142b3301014ca18" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">이 예제들은 또한 &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 모듈 대신 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용해서는 안된다는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a75c1c6107c9c80616709d9370ed7d64d72897ff" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">이 예제들은 또한 &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; 모듈 대신 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용해서는 안된다는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1b7bc94e0db621087dac583856d0104fb7d8c89b" translate="yes" xml:space="preserve">
          <source>Those letters could all be Latin (as in the example just above), or they could be all Cyrillic (except for the dot), or they could be a mixture of the two. In the case of an internet address the &lt;code&gt;.com&lt;/code&gt; would be in Latin, And any Cyrillic ones would cause it to be a mixture, not a script run. Someone clicking on such a link would not be directed to the real Paypal website, but an attacker would craft a look-alike one to attempt to gather sensitive information from the person.</source>
          <target state="translated">이러한 문자는 모두 라틴어 (위의 예에서와 같이)이거나 모두 키릴 문자 (점 제외)이거나 둘의 혼합 일 수 있습니다. 인터넷 주소의 경우 &lt;code&gt;.com&lt;/code&gt; 은 라틴어이고 키릴 문자는 스크립트 실행이 아닌 혼합이됩니다. 그러한 링크를 클릭하는 사람은 실제 Paypal 웹 사이트로 연결되지 않지만 공격자는 그 사람으로부터 민감한 정보를 수집하기 위해 닮은 웹 사이트를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="09bb82492fe1deca424636c6f8f129828507429d" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; documentation for more details.</source>
          <target state="translated">기본 MM_Unix 메서드를 재정의하는 메서드는 &quot;(override)&quot;로 표시되고 MM_VMS에 고유 한 메서드는 &quot;(specific)&quot;으로 표시됩니다. 재정의 된 메서드의 경우이 메서드가 MM_Unix 메서드를 재정의하는 이유에 대한 설명으로 문서가 제한됩니다. 자세한 내용은 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="956b46dcd2869bcc1ce846f30fe79b6d32253a71" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix documentation for more details.</source>
          <target state="translated">기본 MM_Unix 메소드를 대체하는 메소드는 &quot;(재정의)&quot;로 표시되는 반면 MM_VMS에 고유 한 메소드는 &quot;(특정)&quot;으로 표시됩니다. 재정의 된 메서드의 경우 설명서는이 메서드가 MM_Unix 메서드를 재정의하는 이유에 대한 설명으로 제한됩니다. 자세한 내용은 ExtUtils :: MM_Unix 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="89694826230f33ec41f3391ad1e9d0ae75075e89" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt; ) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[\da-z]&lt;/code&gt; 와 같이 괄호로 묶은 문자 클래스 내에서 사용할 수 &lt;code&gt;Not in [].&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed08d333f4d7b0ebed9f1e47a113b306b6da0b17" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt;) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="translated">대괄호 문자 클래스 (예 : &lt;code&gt;[\da-z]&lt;/code&gt; ) 내에서 사용할 수없는 문자 &lt;code&gt;Not in [].&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c59400870fdcf39cd37f7130db3cbffeeca3151" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;../man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;../man&quot;&gt;Pod :: Man에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7014dea585b921e6969f68f00359599742e4a3" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e2b5b8ade9f04ee810e0602b2c63da979876bd5" translate="yes" xml:space="preserve">
          <source>Though ISO-8859 does have ISO-8859-5, the KOI8 series is far more popular in the Net. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; comes with the following KOI charsets. For gory details, see &lt;a href=&quot;http://czyborra.com/charsets/cyrillic.html&quot;&gt;http://czyborra.com/charsets/cyrillic.html&lt;/a&gt;</source>
          <target state="translated">ISO-8859에는 ISO-8859-5가 있지만 KOI8 시리즈는 인터넷에서 훨씬 더 인기가 있습니다. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 는 다음 KOI 문자 세트와 함께 제공됩니다. 자세한 내용은 &lt;a href=&quot;http://czyborra.com/charsets/cyrillic.html&quot;&gt;http://czyborra.com/charsets/cyrillic.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2d164817730248c36fd41c3d7e8fb0afe7ee263" translate="yes" xml:space="preserve">
          <source>Though Jungshik Shin has reported that Mozilla supports this encoding, it was too late before 5.8.0 for us to add it. In the future, it may be available via a separate module. See &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; and &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; if you are interested in helping us.</source>
          <target state="translated">신정식이 Mozilla가이 인코딩을 지원한다고보고했지만 5.8.0 이전에 추가하기에는 너무 늦었습니다. 앞으로는 별도의 모듈을 통해 사용할 수 있습니다. 참조 &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; 및 &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; 당신이 경우 우리를 돕는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d24de1d761cc58def056c26e4fb86b5492f71e" translate="yes" xml:space="preserve">
          <source>Though a much better way is to use the &lt;a href=&quot;Test2::Plugin::UTF8&quot;&gt;Test2::Plugin::UTF8&lt;/a&gt; plugin, which is part of &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">훨씬 더 좋은 방법은 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite의&lt;/a&gt; 일부인 &lt;a href=&quot;Test2::Plugin::UTF8&quot;&gt;Test2 :: Plugin :: UTF8&lt;/a&gt; 플러그인을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b8a06e11acd02f600ac3a6ff09284942503ee656" translate="yes" xml:space="preserve">
          <source>Though forcing an argument into a particular form does not change the stored number, Perl remembers the result of such conversions. In particular, though the first such conversion may be time-consuming, repeated operations will not need to redo the conversion.</source>
          <target state="translated">인수를 특정 형식으로 강요하더라도 저장된 숫자는 변경되지 않지만 Perl은 이러한 변환 결과를 기억합니다. 특히, 최초의 이러한 변환은 시간 소모적 일 수 있지만, 반복 된 동작은 변환을 다시 실행할 필요가 없을 것이다.</target>
        </trans-unit>
        <trans-unit id="f3be83a9aceb8b170431d7d56170a63bf06c2048" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt; , or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="translated">같은 많은 (GCC 경고의 불일치 및 적용 범위 문제에 대해 설명 할 수 있지만 &lt;code&gt;-Wall&lt;/code&gt; 이 적용되지 않는 &quot;모든 경고&quot;, 또는 일반적인 이동성 문제를 의미하지 &lt;code&gt;-Wall&lt;/code&gt; , 또는 &lt;code&gt;-ansi&lt;/code&gt; 와 &lt;code&gt;-pedantic&lt;/code&gt; 모두있는 잘못 정의 모음 gcc는 여전히 코딩 코를 깨끗하게 유지하는 데 유용한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="4faaa6fa5354d5373d44ec1d57892b26bbdbc5ff" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt;, or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="translated">같은 많은 (GCC 경고의 불일치 및 적용 범위 문제에 대해 설명 할 수 있지만 &lt;code&gt;-Wall&lt;/code&gt; 이 적용되지 않는 &quot;모든 경고&quot;, 또는 일반적인 이동성 문제를 의미하지 &lt;code&gt;-Wall&lt;/code&gt; , 또는 &lt;code&gt;-ansi&lt;/code&gt; 와 &lt;code&gt;-pedantic&lt;/code&gt; 모두있는 잘못 정의 모음 경고 등), gcc는 코딩 코를 깨끗하게 유지하는 데 여전히 유용한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="419ade92c2c3a75f745587c25bed6b20ff3a2dd8" translate="yes" xml:space="preserve">
          <source>Though this module can be used without any &lt;code&gt;table&lt;/code&gt; file, to use this module easily, it is recommended to install a table file in the UCA format, by copying it under the directory &amp;lt;a place in @INC&amp;gt;/Unicode/Collate.</source>
          <target state="translated">이 모듈은 &lt;code&gt;table&lt;/code&gt; 파일 없이 사용할 수 있지만이 모듈을 쉽게 사용하려면 &amp;lt;INC의 위치&amp;gt; / Unicode / Collate 디렉토리 아래에 파일을 복사하여 UCA 형식으로 테이블 파일을 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="998ceaaad06364c8b6eb7bb906fdf278086c1d9b" translate="yes" xml:space="preserve">
          <source>Thread # terminated abnormally: ...</source>
          <target state="translated">스레드 번호가 비정상적으로 종료 됨 : ...</target>
        </trans-unit>
        <trans-unit id="0d8bdcbf638d7eb68b070735be885cf9e96d329d" translate="yes" xml:space="preserve">
          <source>Thread - Manipulate threads in Perl (for old code only)</source>
          <target state="translated">스레드-Perl에서 스레드 조작 (이전 코드에만 해당)</target>
        </trans-unit>
        <trans-unit id="c918ac60574a68bba66c3da27f233195a15f2b9b" translate="yes" xml:space="preserve">
          <source>Thread Basics</source>
          <target state="translated">스레드 기본</target>
        </trans-unit>
        <trans-unit id="a78e21be0817d13d864f0b6be8854cdfa543bd85" translate="yes" xml:space="preserve">
          <source>Thread ID of this instance.</source>
          <target state="translated">이 인스턴스의 스레드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="ebe1f739c1cdedc327a9eae1c397ab14c9d64437" translate="yes" xml:space="preserve">
          <source>Thread IDs</source>
          <target state="translated">스레드 ID</target>
        </trans-unit>
        <trans-unit id="898f39e0ee67463e37091c0ab76e5df497814e8b" translate="yes" xml:space="preserve">
          <source>Thread Pitfalls: Races</source>
          <target state="translated">함정 함정 : 인종</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="d3dbf16992ead48a52867791a62d8b164c67fd1f" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_attr_setstacksize(</source>
          <target state="translated">스레드 생성 실패 : pthread_attr_setstacksize (</target>
        </trans-unit>
        <trans-unit id="bfe544dd150b465313579f9a917937793103ac16" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_create returned #</source>
          <target state="translated">스레드 생성 실패 : pthread_create가 #을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="c4066c9a805adec4e9141cb77efe0020bace9560" translate="yes" xml:space="preserve">
          <source>Thread objects also have an overloaded &lt;code&gt;==&lt;/code&gt; comparison so that you can do comparison on them as you would with normal objects.</source>
          <target state="translated">스레드 객체에는 오버로드 된 &lt;code&gt;==&lt;/code&gt; 비교 기능이 있으므로 일반 객체와 마찬가지로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">스레드 안전성</target>
        </trans-unit>
        <trans-unit id="549ccddc66fc92574e2a5d76a4615e0548e5e609" translate="yes" xml:space="preserve">
          <source>Thread support is a Perl compile-time option. It's something that's turned on or off when Perl is built at your site, rather than when your programs are compiled. If your Perl wasn't compiled with thread support enabled, then any attempt to use threads will fail.</source>
          <target state="translated">스레드 지원은 Perl 컴파일 타임 옵션입니다. 프로그램이 컴파일되는 것이 아니라 사이트에서 Perl을 빌드 할 때 켜거나 끄는 것입니다. 스레드 지원이 활성화 된 상태에서 Perl이 컴파일되지 않은 경우 스레드 사용 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="46bddf5c24ca2d6a4d9042e8357ff7786b5311d0" translate="yes" xml:space="preserve">
          <source>Thread support is not tested in this version of the djgpp perl.</source>
          <target state="translated">이 버전의 djgpp perl에서는 스레드 지원이 테스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c46da741d2999f303803e3f917e3740fdda50340" translate="yes" xml:space="preserve">
          <source>Thread support is not very reliable before 5.10.1, but that's because threads are not very reliable before 5.10.1.</source>
          <target state="translated">스레드 지원은 5.10.1 이전에는 매우 안정적이지 않지만 5.10.1 이전에는 스레드가 매우 안정적이지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="11feb4cfa0751bbfde7a5acce22a835701e10a09" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;list</source>
          <target state="translated">Thread-&amp;gt;list</target>
        </trans-unit>
        <trans-unit id="c33ecb12695532db82054d26a0b666a4c71b167c" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;self</source>
          <target state="translated">Thread-&amp;gt;self</target>
        </trans-unit>
        <trans-unit id="8fed753691ece692a240fff0998afe0f2ace9f0d" translate="yes" xml:space="preserve">
          <source>Thread-Safe Modules</source>
          <target state="translated">스레드 안전 모듈</target>
        </trans-unit>
        <trans-unit id="7481655dbaa92f6baf98738070e27520e97d079c" translate="yes" xml:space="preserve">
          <source>Thread-Safety of System Libraries</source>
          <target state="translated">시스템 라이브러리의 스레드 안전성</target>
        </trans-unit>
        <trans-unit id="932b17e3a913e7164b20d08cedb16d8eee3d76fc" translate="yes" xml:space="preserve">
          <source>Thread-aware system interfaces</source>
          <target state="translated">스레드 인식 시스템 인터페이스</target>
        </trans-unit>
        <trans-unit id="3f487c5ede1faaacb7af8d62cbc07904f78f97b1" translate="yes" xml:space="preserve">
          <source>Thread-safe modules</source>
          <target state="translated">스레드로부터 안전한 모듈</target>
        </trans-unit>
        <trans-unit id="8d5d3327153c08a2630824ad42fbb1c6c94a74e6" translate="yes" xml:space="preserve">
          <source>Thread-safe operations are supported in Windows starting in Visual Studio 2005, and in systems compatible with POSIX 2008. Some platforms claim to support POSIX 2008, but have buggy implementations, so that the hints files for compiling to run on them turn off attempting to use thread-safety. &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; will be 0 on them.</source>
          <target state="translated">스레드로부터 안전한 작업은 Visual Studio 2005부터 Windows 및 POSIX 2008과 호환되는 시스템에서 지원됩니다. 일부 플랫폼은 POSIX 2008을 지원한다고 주장하지만 버그가있는 구현이 있으므로 컴파일을위한 힌트 파일이 스레드 안전성을 사용하십시오. &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; 는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="a04c2c8f868b7f546d5c03554daa6de042ed3f5f" translate="yes" xml:space="preserve">
          <source>Thread-safe queues</source>
          <target state="translated">스레드 안전 큐</target>
        </trans-unit>
        <trans-unit id="6ec24d7d376e4c8018f31c516a824eaf616af734" translate="yes" xml:space="preserve">
          <source>Thread-safe semaphores</source>
          <target state="translated">스레드 안전 세마포어</target>
        </trans-unit>
        <trans-unit id="1a5d305757aae906720c104f8cc9b46cfea47a9a" translate="yes" xml:space="preserve">
          <source>Thread-safety of extensions</source>
          <target state="translated">확장의 스레드 안전성</target>
        </trans-unit>
        <trans-unit id="396f10461adcaf1d700d25868c55c05cc6b1f668" translate="yes" xml:space="preserve">
          <source>Thread::Queue</source>
          <target state="translated">Thread::Queue</target>
        </trans-unit>
        <trans-unit id="a99444903cfd04a299ea92dd5417034d9b8ba995" translate="yes" xml:space="preserve">
          <source>Thread::Queue - Thread-safe queues</source>
          <target state="translated">Thread :: Queue-스레드 안전 큐</target>
        </trans-unit>
        <trans-unit id="762634ef60addc5dc2601bb4e594eccb63b09b78" translate="yes" xml:space="preserve">
          <source>Thread::Queue Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http://www.cpanforum.com/dist/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">글타래 (쓰레드) :: 큐 토론 포럼 : &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http://www.cpanforum.com/dist/Thread-Queue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e095a6673757f69a6701a64b890923c021a33f37" translate="yes" xml:space="preserve">
          <source>Thread::Queue on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Queue&quot;&gt;https://metacpan.org/release/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">MetaCPAN의 스레드 :: Queue : &lt;a href=&quot;https://metacpan.org/release/Thread-Queue&quot;&gt;https://metacpan.org/release/Thread-Queue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0074185a9ba92a372e711b37e0503d776af40535" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore</source>
          <target state="translated">Thread::Semaphore</target>
        </trans-unit>
        <trans-unit id="5153c71809c73fa56e9f450e40e65e39c3a75a98" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore - Thread-safe semaphores</source>
          <target state="translated">글타래 (쓰레드) :: Semaphore-Thread-safe semaphores</target>
        </trans-unit>
        <trans-unit id="b671103ebdb4e0b4d2ecc230ad75192d06191f6c" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http://www.cpanforum.com/dist/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">CPAN의 주제 :: 세마포어 토론 포럼 : &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http://www.cpanforum.com/dist/Thread-Semaphore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78e4d100100edaa775feea0a8c72907079d2f6c0" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Semaphore&quot;&gt;https://metacpan.org/release/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">MetaCPAN의 스레드 :: Semaphore : &lt;a href=&quot;https://metacpan.org/release/Thread-Semaphore&quot;&gt;https://metacpan.org/release/Thread-Semaphore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a01c8841eeee1a585b966adef58341ccb26f6e3f" translate="yes" xml:space="preserve">
          <source>Threaded Perl</source>
          <target state="translated">스레드 펄</target>
        </trans-unit>
        <trans-unit id="b3c18742ec345b212b0e3561e0712bc0736d2fd7" translate="yes" xml:space="preserve">
          <source>Threaded Perl &amp;lt; 5L</source>
          <target state="translated">스레드 펄 &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="896b80373adefd94b0d4d1ca953da0068f3de675" translate="yes" xml:space="preserve">
          <source>Threaded Perl on HP-UX</source>
          <target state="translated">HP-UX의 스레드 펄</target>
        </trans-unit>
        <trans-unit id="278ce1d68672d63d7d64a6301d587c6d418cdd49" translate="yes" xml:space="preserve">
          <source>Threaded Perl on Tru64</source>
          <target state="translated">Tru64의 스레드 펄</target>
        </trans-unit>
        <trans-unit id="3e5a5f323fc4b225e8b871ec76ea2983f10ebd12" translate="yes" xml:space="preserve">
          <source>Threaded Program Models</source>
          <target state="translated">스레드 프로그램 모델</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="6596a15b769c831a3f0b4a20d6206e9aaff0ff18" translate="yes" xml:space="preserve">
          <source>Threads And Data</source>
          <target state="translated">스레드와 데이터</target>
        </trans-unit>
        <trans-unit id="ce6a15cf18170dad63898b28647ad599c148d2e2" translate="yes" xml:space="preserve">
          <source>Threads and PERL_NO_GET_CONTEXT</source>
          <target state="translated">스레드와 PERL_NO_GET_CONTEXT</target>
        </trans-unit>
        <trans-unit id="f29a9672c8b3e91f034cbb02629e17bf739af74a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; context. This method will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the thread terminates</source>
          <target state="translated">스레드는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 컨텍스트 에서 실행됩니다 . 스레드가 종료되면 이 메소드는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4f937508b206813fc7fc617e2e68bc09cd2fe07a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;eval&lt;/code&gt; context. This method will return &lt;code&gt;undef&lt;/code&gt; if the thread terminates</source>
          <target state="translated">스레드는 &lt;code&gt;eval&lt;/code&gt; 컨텍스트 에서 실행됩니다 . 이 메서드는 스레드가 종료되면 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b839f3a9a828ffa9cf5380fd081f2abe973e818b" translate="yes" xml:space="preserve">
          <source>Threads created after the stack size is set will then either call &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt;</source>
          <target state="translated">스택 크기가 설정된 후 생성 된 스레드는 &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="94467b457a28016ce826b824829b4d6d15c2d05d" translate="yes" xml:space="preserve">
          <source>Threads in perl on Solaris.</source>
          <target state="translated">Solaris에서 펄의 스레드.</target>
        </trans-unit>
        <trans-unit id="9bf016cf50be3949ad3553a7f6154f5ec7b5a4bd" translate="yes" xml:space="preserve">
          <source>Threads seem to work OK, though at the moment not all tests pass when threads are used in combination with 64-bit configurations.</source>
          <target state="translated">스레드가 제대로 작동하는 것처럼 보이지만 현재 스레드가 64 비트 구성과 함께 사용될 때 모든 테스트가 통과되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4cfcad8da4f4097a771977a006ace86ca57e64ee" translate="yes" xml:space="preserve">
          <source>Three additional functions allow access to this statistic from Perl. First, use &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; to get the information contained in the output of mstat() into %hash. The field of this hash are</source>
          <target state="translated">Perl에서이 통계에 액세스 할 수있는 세 가지 추가 기능이 있습니다. 먼저 &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; 를 사용하여 mstat () 의 출력에 포함 된 정보를 % hash 로 가져옵니다. 이 해시의 필드는</target>
        </trans-unit>
        <trans-unit id="26e5837be2de4b1aebd256f3b85dedb9966c5789" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문에 지정된 모든 서브 루틴에 세 개의 인수가 전달됩니다 (예외-특히 &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eda363e39741d5cd78c03eff4a6d63f761929ec3" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;use overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;use overload&lt;/code&gt; 지시문에 지정된 모든 서브 루틴에 세 개의 인수가 전달됩니다 (예외 있음-특히 &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3cd6b1128d59a894465f4f165820b4021adc3e92" translate="yes" xml:space="preserve">
          <source>Three basic types of firewalls</source>
          <target state="translated">세 가지 기본 유형의 방화벽</target>
        </trans-unit>
        <trans-unit id="0cfd5fb11aff1629d8a4d5d5d19e3a7e21cf359a" translate="yes" xml:space="preserve">
          <source>Three callback methods must be supplied by a class extending &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; to receive the corresponding event:</source>
          <target state="translated">해당 이벤트를 수신하려면 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 을 확장하는 클래스에서 세 가지 콜백 메소드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4ffe47253803edde038382d85662a60a52eedba" translate="yes" xml:space="preserve">
          <source>Three examples illustrate locale-dependent tainting. The first program, which ignores its locale, won't run: a value taken directly from the command line may not be used to name an output file when taint checks are enabled.</source>
          <target state="translated">3 가지 예는 로케일에 따른 오염을 설명합니다. 로케일을 무시하는 첫 번째 프로그램은 실행되지 않습니다. 오염 검사가 활성화 된 경우 명령 행에서 직접 가져온 값을 사용하여 출력 파일의 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6141ac98876a4853f17c73073300c31f8ef5f853" translate="yes" xml:space="preserve">
          <source>Three kinds of values are supported: integer numbers, floating point numbers, and strings.</source>
          <target state="translated">정수, 부동 소수점 숫자 및 문자열의 세 가지 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1e762c22c180faab240d71e43cfef464b083afa9" translate="yes" xml:space="preserve">
          <source>Three techniques can make regular expressions maintainable and understandable.</source>
          <target state="translated">세 가지 기술로 정규식을 유지 관리하고 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e024ca38a0a0e2a4280224604ff002f7a982d0a" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">&lt;code&gt;ignoreChar&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; 일치하는 모든 문자 는 무시됩니다. &lt;code&gt;ignoreName&lt;/code&gt; 을 통해 ( &lt;code&gt;table&lt;/code&gt; 파일에 주석으로 제공된) 이름이 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; 과 일치 하는 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6982b043a594faf7eee60f7d8781076841a7bed8" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$ignoreChar/&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$ignoreName/&lt;/code&gt; will be ignored.</source>
          <target state="translated">&lt;code&gt;ignoreChar&lt;/code&gt; 를 통해 &lt;code&gt;qr/$ignoreChar/&lt;/code&gt; 일치하는 모든 문자 는 무시됩니다. &lt;code&gt;ignoreName&lt;/code&gt; 을 통해 이름 ( &lt;code&gt;table&lt;/code&gt; 파일에 주석으로 &lt;code&gt;qr/$ignoreName/&lt;/code&gt; )이 qr / $ ignoreName / 과 일치하는 모든 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2656f0fc85c8406c01f3e25365ba08b9847d1444" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt; , ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="translated">&lt;code&gt;overrideCJK&lt;/code&gt; 를 통해 CJK 통합 표의 문자 (확장자 포함)의 순서 를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4812f3fb25100135533513adb0cedc6268f243c" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt;, ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="translated">&lt;code&gt;overrideCJK&lt;/code&gt; 를 통해 CJK 통합 표의 문자 (확장자 포함)의 순서 를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d41b6131470dc9be4067c613ceb5bce948ecfe0f" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;code&gt;undefChar&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; 일치하는 문자 는 정의되지 않습니다. &lt;code&gt;undefName&lt;/code&gt; 을 통해 이름 ( &lt;code&gt;table&lt;/code&gt; 파일에 주석으로 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; )이 qr / $ undefName / 과 일치 하는 문자는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06a20d5faae40c1690e4ca328ce25858d383557b" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$undefChar/&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$undefName/&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;code&gt;undefChar&lt;/code&gt; 를 통해 &lt;code&gt;qr/$undefChar/&lt;/code&gt; 일치하는 모든 문자 는 정의되지 않습니다. &lt;code&gt;undefName&lt;/code&gt; 을 통해 이름 ( &lt;code&gt;table&lt;/code&gt; 파일에 주석으로 &lt;code&gt;qr/$undefName/&lt;/code&gt; )이 qr / $ undefName / 과 일치하는 모든 문자는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d077a4a651b19b1e4364e9f887336a0ac7a1fd1b" translate="yes" xml:space="preserve">
          <source>Throughout Perl's documentation, you'll find numerous examples intended to help explain the discussed features. Please keep in mind that many of them are code fragments rather than complete programs.</source>
          <target state="translated">Perl의 문서 전체에서 논의 된 기능을 설명하는 데 도움이되는 수많은 예제가 있습니다. 이들 중 다수는 완전한 프로그램이 아니라 코드 조각이라는 점을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="c8b395c4fc736d7a1ffa585c8b907d633728a128" translate="yes" xml:space="preserve">
          <source>Throughout the previous section all the examples have used the syntax:</source>
          <target state="translated">이전 섹션에서 모든 예제는 다음 구문을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="04ea385bf46d02438c73b811e0575313e27e41c8" translate="yes" xml:space="preserve">
          <source>Throughout this document a variety of interfaces to the rpcb_gettime() XSUB will be explored. The XSUBs will take their parameters in different orders or will take different numbers of parameters. In each case the XSUB is an abstraction between Perl and the real C rpcb_gettime() function, and the XSUB must always ensure that the real rpcb_gettime() function is called with the correct parameters. This abstraction will allow the programmer to create a more Perl-like interface to the C function.</source>
          <target state="translated">이 문서 전체에서 rpcb_gettime () XSUB에 대한 다양한 인터페이스를 살펴 봅니다. XSUB는 매개 변수를 다른 순서로 사용하거나 다른 수의 매개 변수를 사용합니다. 각 경우에 XSUB는 Perl과 실제 C rpcb_gettime () 함수 사이의 추상화이며 XSUB는 항상 실제 rpcb_gettime () 함수가 올바른 매개 변수로 호출되는지 확인해야합니다. 이 추상화는 프로그래머가 C 함수에 대한보다 Perl과 유사한 인터페이스를 만들 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="b15b9c197ac6c931d6850ebe19f2134cab6a760f" translate="yes" xml:space="preserve">
          <source>Throughout this document you'll see references to other parts of the Perl documentation. You can read that documentation using the &lt;code&gt;perldoc&lt;/code&gt; command or whatever method you're using to read this document.</source>
          <target state="translated">이 문서 전체에서 Perl 문서의 다른 부분에 대한 참조를 볼 수 있습니다. &lt;code&gt;perldoc&lt;/code&gt; 명령 또는이 문서를 읽는 데 사용하는 방법을 사용하여 해당 문서를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d384b2c788b5330a252672c9c0d9ed4dcefe6cd2" translate="yes" xml:space="preserve">
          <source>Throughout this document, &quot;Pod&quot; has been the preferred spelling for the name of the documentation format. One may also use &quot;POD&quot; or &quot;pod&quot;. For the documentation that is (typically) in the Pod format, you may use &quot;pod&quot;, or &quot;Pod&quot;, or &quot;POD&quot;. Understanding these distinctions is useful; but obsessing over how to spell them, usually is not.</source>
          <target state="translated">이 문서 전체에서 &quot;포드&quot;는 문서 형식의 이름에 가장 적합한 철자입니다. &quot;POD&quot;또는 &quot;pod&quot;를 사용할 수도 있습니다. 일반적으로 Pod 형식 인 설명서의 경우 &quot;pod&quot;또는 &quot;Pod&quot;또는 &quot;POD&quot;를 사용할 수 있습니다. 이러한 차이점을 이해하는 것이 유용합니다. 그러나 철자를 쓰는 방법에 집착하는 것은 보통 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a4f24f440cbc4008a46d5ea71d57cb32fa115ff" translate="yes" xml:space="preserve">
          <source>Throw in some dubious extra macros for Makefile args.</source>
          <target state="translated">Makefile 인수에 대해 모호한 추가 매크로를 던져보십시오.</target>
        </trans-unit>
        <trans-unit id="76751470c1dde2f50d7d809c9a5f8b163f6ce43e" translate="yes" xml:space="preserve">
          <source>Throws an error if any of the signals supplied cannot be added to the set.</source>
          <target state="translated">제공된 신호를 세트에 추가 할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47b73cafd4faf1fefd5169b12127f2bdff667740" translate="yes" xml:space="preserve">
          <source>Throws an exception telling you the attribute is read-only. This is exported to override any active setters for the attribute in a parent class.</source>
          <target state="translated">속성이 읽기 전용임을 알리는 예외가 발생합니다. 부모 클래스의 속성에 대한 활성 setter를 재정의하기 위해 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="d1f7b26cf9b0b9d2fcaec187b02a47e2ac8cf9d0" translate="yes" xml:space="preserve">
          <source>Thus Perl allows such constructs, by</source>
          <target state="translated">따라서 Perl은 다음과 같은 구성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ab203f90d156d52e2f73ed76c1de89f7fea26e7e" translate="yes" xml:space="preserve">
          <source>Thus Perl returns true on success and false on failure, yet you can still easily determine the actual value returned by the operating system:</source>
          <target state="translated">따라서 Perl은 성공하면 true를, 실패하면 false를 반환하지만 여전히 운영 체제에서 반환 한 실제 값을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e6804dcc6b004791c6943dada1f9eeda86eed7" translate="yes" xml:space="preserve">
          <source>Thus means that you need to get some copy of a</source>
          <target state="translated">따라서 일부 사본을 받아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cced270ffb5295be4933e701f4fb59adf650f013" translate="yes" xml:space="preserve">
          <source>Thus the following lines are equivalent:</source>
          <target state="translated">따라서 다음 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2e4d332fae9a917754e083395b2e8d74491bb6fd" translate="yes" xml:space="preserve">
          <source>Thus the pattern &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; can be thought of as the following chart:</source>
          <target state="translated">따라서 &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; 은 다음 차트로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f633037050d154781c387ade59e7e2912691ab20" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; . Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt; . In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="translated">따라서 경고는 이전 Perls보다 훨씬 적은 경우에 대해 결과가 논쟁의 여지가있을 때만 발생합니다. Perl에 의해 만들어진 최적화 (또는 가능성이 높지 않은)로 경고를 건너 뛰는 일이 없기 때문에 Perl의 초기 접근 방식의 두 가지 문제를 모두 해결합니다. 이 변경의 영향을 가장 많이받는 속성은 &lt;code&gt;\p{Unassigned}&lt;/code&gt; 이며 이는 &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; 의 짧은 형식입니다 . v5.20부터는 비 유니 코드 코드 포인트가 모두 &lt;code&gt;Unassigned&lt;/code&gt; 것으로 간주됩니다 . 이전 릴리스에서는 결과가 정의되지 않은 것으로 간주되어 일치가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="61e13a16949757dfa1e1583008faeb5e63993d67" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt;. Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt;. In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="translated">따라서 경고는 이전 Perls보다 훨씬 적은 경우에 발생하며 결과가 논쟁의 여지가있을 때만 발생합니다. Perl에 의해 수행 된 최적화 (또는 수행 될 가능성이있는) 중 어떤 것도 경고를 건너 뛰도록 만들지 않았으므로 Perl의 이전 접근 방식의 두 문제를 모두 해결합니다. 이 변화에 의해 영향을 가장 많이 사용되는 속성이다 &lt;code&gt;\p{Unassigned}&lt;/code&gt; 하는 짧은 형태 &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; . v5.20부터 모든 비 유니 코드 코드 포인트는 &lt;code&gt;Unassigned&lt;/code&gt; 것으로 간주됩니다 . 이전 릴리스에서는 결과가 정의되지 않은 것으로 간주 되었기 때문에 일치가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="198082eebbb223fde4a47c55ef1e44319568487c" translate="yes" xml:space="preserve">
          <source>Thus you can say</source>
          <target state="translated">따라서 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="61d7278739eb25e7e5958e1c5b254402dd825eb3" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0],
$+[0] - $-[0]&lt;/code&gt; . Similarly, $</source>
          <target state="translated">따라서, 일치에 대해 후 &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 일치 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0], $+[0] - $-[0]&lt;/code&gt; . 마찬가지로 $</target>
        </trans-unit>
        <trans-unit id="41169299ed066a28115e5870cc4da4575fd56075" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;substr $_, $-[0], $+[0] - $-[0]&lt;/code&gt;. Similarly, $</source>
          <target state="translated">따라서, 일치에 대해 후 &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 일치 &lt;code&gt;substr $_, $-[0], $+[0] - $-[0]&lt;/code&gt; . 마찬가지로 $</target>
        </trans-unit>
        <trans-unit id="c9649f9466e2d92d8678d66258528b39110e1a08" translate="yes" xml:space="preserve">
          <source>Thus, techniques are of interest that store object data</source>
          <target state="translated">따라서 객체 데이터를 저장하는 기술에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="69514cb2285daf6fa2a75d85f6f93569b1ec1fbe" translate="yes" xml:space="preserve">
          <source>Thus, the following code:</source>
          <target state="translated">따라서 다음 코드는</target>
        </trans-unit>
        <trans-unit id="fdfd242e087e9b16796271aa3a036f7d0bbc20a8" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; , if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt; . NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="translated">따라서 SV가 마법적이고 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; 유형 인 것으로 판별 되면, get 조작이 수행되는 경우 루틴 &lt;code&gt;magic_get&lt;/code&gt; 이 호출됩니다. 다양한 마법 유형에 대한 모든 다양한 루틴은 &lt;code&gt;magic_&lt;/code&gt; 로 시작합니다 . 참고 : 매직 루틴은 Perl API의 일부로 간주되지 않으며 Perl 라이브러리에서 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0549c98abe5f2c41103ad967e9de7400fdf53796" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt;, if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt;. NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="translated">따라서 SV가 마법적이고 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; 유형으로 결정 되면 get 작업이 수행되고 있으면 &lt;code&gt;magic_get&lt;/code&gt; 루틴 이 호출됩니다. 다양한 마법 유형에 대한 모든 다양한 루틴은 &lt;code&gt;magic_&lt;/code&gt; 로 시작합니다 . 참고 : 매직 루틴은 Perl API의 일부로 간주되지 않으며 Perl 라이브러리에서 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="792b045fd76c8a8e326c6a926aab95f7dc272599" translate="yes" xml:space="preserve">
          <source>Tidies a pod file. It's a good idea to run this on a pod file you've patched.</source>
          <target state="translated">포드 파일을 정리합니다. 패치 한 포드 파일에서이를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b6cf02234ec17d26dce972804e5d1459de07ad2c" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a &lt;code&gt;@_&lt;/code&gt;; mark temporaries as such. &lt;code&gt;type&lt;/code&gt; indicates the kind of subroutine:</source>
          <target state="translated">패드가 속한 코드의 컴파일이 끝날 때 패드를 정리합니다. 여기서 수행되는 작업은 다음과 같습니다. anonsub 프로토 타입의 패드에서 대부분의 항목을 제거합니다. 그것에게 &lt;code&gt;@_&lt;/code&gt; 를 줘 ; 임시로 표시하십시오. &lt;code&gt;type&lt;/code&gt; 은 서브 루틴의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="296860fe60dd454f0fedbc6ccca9835dfde819d9" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a @_; mark temporaries as such.</source>
          <target state="translated">해당 코드가 컴파일 될 때 패드를 정리하십시오. 여기서 수행되는 작업은 다음과 같습니다. anonsub 프로토 타입의 패드에서 대부분의 물건을 제거합니다. 그것을 _; 임시로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="7d075f169d648523eaa03bb2a98984e48aa65769" translate="yes" xml:space="preserve">
          <source>Tie</source>
          <target state="translated">Tie</target>
        </trans-unit>
        <trans-unit id="5e1d6d92861c9421bba19d24d93aa2e9bfe58ad7" translate="yes" xml:space="preserve">
          <source>Tie large variables to disk</source>
          <target state="translated">큰 변수를 디스크에 연결</target>
        </trans-unit>
        <trans-unit id="0bb65db42104858e7d9b646133b08eaaeba3381c" translate="yes" xml:space="preserve">
          <source>Tie::Array</source>
          <target state="translated">Tie::Array</target>
        </trans-unit>
        <trans-unit id="75e3c18c1d17d4f15800c858036a1510e1e1f0e6" translate="yes" xml:space="preserve">
          <source>Tie::Array - base class for tied arrays</source>
          <target state="translated">Tie :: Array-묶인 배열의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="3315a464fcfacdc6f9533f0ecfd375368fedb11d" translate="yes" xml:space="preserve">
          <source>Tie::File</source>
          <target state="translated">Tie::File</target>
        </trans-unit>
        <trans-unit id="a8bb1e5ad4fcbd12edf8be28ae56bee14e6f545c" translate="yes" xml:space="preserve">
          <source>Tie::File - Access the lines of a disk file via a Perl array</source>
          <target state="translated">Tie :: File-Perl 배열을 통해 디스크 파일의 행에 액세스</target>
        </trans-unit>
        <trans-unit id="dc17380e1c5c0cb9aaf50a1f92e76e8ea993f448" translate="yes" xml:space="preserve">
          <source>Tie::File calls &lt;code&gt;binmode&lt;/code&gt; on filehandles that it opens internally, but not on filehandles passed in by the user. For consistency, especially if using the tied files cross-platform, you may wish to call &lt;code&gt;binmode&lt;/code&gt; on the filehandle prior to tying the file.</source>
          <target state="translated">Tie :: File은 내부적으로 열리는 파일 핸들에서 &lt;code&gt;binmode&lt;/code&gt; 를 호출 하지만 사용자가 전달한 파일 핸들에서는 호출 하지 않습니다. 일관성을 위해, 특히 플랫폼 간 연결 파일을 사용하는 경우 파일 을 연결하기 전에 파일 핸들에서 &lt;code&gt;binmode&lt;/code&gt; 를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6319e96a453cce98221083d4f3fd8db235526699" translate="yes" xml:space="preserve">
          <source>Tie::Handle</source>
          <target state="translated">Tie::Handle</target>
        </trans-unit>
        <trans-unit id="0a548ea9945566563847425cd86bcbb7a0d010cc" translate="yes" xml:space="preserve">
          <source>Tie::Handle - base class definitions for tied handles</source>
          <target state="translated">Tie :: Handle-연결 핸들에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="cd52c37918e2c0b25f36b5f416810f9f4f61d1e1" translate="yes" xml:space="preserve">
          <source>Tie::Hash</source>
          <target state="translated">Tie::Hash</target>
        </trans-unit>
        <trans-unit id="b1f9afc2a333da12fb6b6ad2b6d5e266f06e1fc4" translate="yes" xml:space="preserve">
          <source>Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes</source>
          <target state="translated">Tie :: Hash, Tie :: StdHash, Tie :: ExtraHash-묶인 해시의 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="c8d3a75ba1b0a3910318dc42acaa46468a63fedd" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture</source>
          <target state="translated">Tie::Hash::NamedCapture</target>
        </trans-unit>
        <trans-unit id="fe35d5fd9c32e90217b32911caa7181fd20d6a89" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture - Named regexp capture buffers</source>
          <target state="translated">Tie :: Hash :: NamedCapture-명명 된 정규식 캡처 버퍼</target>
        </trans-unit>
        <trans-unit id="703b368dc238bcde88f5095c837de68b527d723e" translate="yes" xml:space="preserve">
          <source>Tie::Memoize</source>
          <target state="translated">Tie::Memoize</target>
        </trans-unit>
        <trans-unit id="7b3289a8b6604631463790d9f588d4dd69111f3a" translate="yes" xml:space="preserve">
          <source>Tie::Memoize - add data to hash when needed</source>
          <target state="translated">넥타이 :: 메모-필요할 때 해시에 데이터 추가</target>
        </trans-unit>
        <trans-unit id="aeeb15286d4bc809144814ad40c79ee05c416c3a" translate="yes" xml:space="preserve">
          <source>Tie::RefHash</source>
          <target state="translated">Tie::RefHash</target>
        </trans-unit>
        <trans-unit id="4bb364c89cbd37ee3daa5c39771c2605b0633761" translate="yes" xml:space="preserve">
          <source>Tie::RefHash - use references as hash keys</source>
          <target state="translated">Tie :: RefHash-참조를 해시 키로 사용</target>
        </trans-unit>
        <trans-unit id="fb9e6a1ad57553eb30c0b9f049adcbf5c6d8c3ed" translate="yes" xml:space="preserve">
          <source>Tie::Scalar</source>
          <target state="translated">Tie::Scalar</target>
        </trans-unit>
        <trans-unit id="14241eaa440004f0f7b17e76185eebd008e2584c" translate="yes" xml:space="preserve">
          <source>Tie::Scalar vs Tie::StdScalar</source>
          <target state="translated">타이 :: 스칼라 vs 타이 :: 스칼라</target>
        </trans-unit>
        <trans-unit id="9c8072ce734013166993c6f0143dd7123d88fcc5" translate="yes" xml:space="preserve">
          <source>Tie::Scalar, Tie::StdScalar - base class definitions for tied scalars</source>
          <target state="translated">Tie :: Scalar, Tie :: StdScalar-연결된 스칼라에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="24703e371c3e7f945d3b78d21edd36185f76ca6e" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle</source>
          <target state="translated">Tie::StdHandle</target>
        </trans-unit>
        <trans-unit id="a6e6391cf784418a4b559abce054165c18d48250" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle - base class definitions for tied handles</source>
          <target state="translated">Tie :: StdHandle-연결 핸들에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="2f3439068e890141de6922d6924a5c42144d9aab" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash</source>
          <target state="translated">Tie::SubstrHash</target>
        </trans-unit>
        <trans-unit id="6980b3892c06ab7d2c795b8a0449ed68a3aed6bd" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash - Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">Tie :: SubstrHash-고정 테이블 크기, 고정 키 길이 해싱</target>
        </trans-unit>
        <trans-unit id="464ee826aae53453c130a0c1497f3c4ca331982d" translate="yes" xml:space="preserve">
          <source>Tied access to ndbm files</source>
          <target state="translated">ndbm 파일에 대한 연결 액세스</target>
        </trans-unit>
        <trans-unit id="8a33955c62ec97774e8693644b322775bd7663ae" translate="yes" xml:space="preserve">
          <source>Tied access to odbm files</source>
          <target state="translated">odbm 파일에 대한 액세스 권한</target>
        </trans-unit>
        <trans-unit id="1588828c9e5b2bd88f7d08cd7f3e57f7ec8ffbf5" translate="yes" xml:space="preserve">
          <source>Tied access to sdbm files</source>
          <target state="translated">sdbm 파일에 대한 액세스 권한</target>
        </trans-unit>
        <trans-unit id="1720e98baff7940aea5456c5ab89cbd8f4faa4be" translate="yes" xml:space="preserve">
          <source>Tied filehandles are still incomplete. sysopen(), truncate(), flock(), fcntl(), stat() and -X can't currently be trapped.</source>
          <target state="translated">묶인 파일 핸들이 여전히 불완전합니다. sysopen (), truncate (), flock (), fcntl (), stat () 및 -X는 현재 트랩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b7baf020a5c394ffec94a6c51412ee34b96cd55" translate="yes" xml:space="preserve">
          <source>Tied hash interface</source>
          <target state="translated">묶인 해시 인터페이스</target>
        </trans-unit>
        <trans-unit id="45a90cde1e783db9283275e5312c014bb1cb705f" translate="yes" xml:space="preserve">
          <source>Tied hash/array slices cause multiple FETCH/STORE pairs, there are no tie methods for slice operations.</source>
          <target state="translated">묶인 해시 / 배열 슬라이스는 여러 FETCH / STORE 쌍을 발생 시키며 슬라이스 연산을위한 타이 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="44a21f1b3d2e469d8d4dbb6af794f7ad93c019a6" translate="yes" xml:space="preserve">
          <source>Tied hashes and arrays are magical beasts of the &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; magic type.</source>
          <target state="translated">묶인 해시와 배열은 &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; 마술 유형 의 마술 짐승입니다 .</target>
        </trans-unit>
        <trans-unit id="83884faf685c9098ec150488288e4d48b3ce8cb8" translate="yes" xml:space="preserve">
          <source>Tied hashes may have a different ordering behaviour to perl's hash implementation.</source>
          <target state="translated">묶인 해시는 펄의 해시 구현과 다른 순서 동작을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d1d3d65efd2c22754237fd41c0e585f040ec15" translate="yes" xml:space="preserve">
          <source>Tied hashes may have their own ordering and algorithmic complexity attacks.</source>
          <target state="translated">묶음 해시는 고유 한 순서와 알고리즘 복잡성 공격을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b5ed066516a43ed14f22509aac06d08e585ed9" translate="yes" xml:space="preserve">
          <source>Ties are handled by choosing the first handler.</source>
          <target state="translated">첫 번째 핸들러를 선택하여 타이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="64d5dd10fdcd493eede6caa7c5fa5f02730895e8" translate="yes" xml:space="preserve">
          <source>Tim Bunce and Charles Bailey. Currently maintained by David Landgren &amp;lt;</source>
          <target state="translated">팀 번스와 찰스 베일리 현재 David Landgren &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3ddc0a76c09f699fa94ee0a72995b7039d633486" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 11 August 1994.</source>
          <target state="translated">1994 년 8 월 11 일 Tim Bunce.</target>
        </trans-unit>
        <trans-unit id="8cf374401e16921c8b9927b27c7d0a5e707f664a" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 2nd June 1995.</source>
          <target state="translated">1995 년 6 월 2 일 Tim Bunce.</target>
        </trans-unit>
        <trans-unit id="3175b9a598f6f77b48765e43cfb7cd7d7b509655" translate="yes" xml:space="preserve">
          <source>Tim Jenness</source>
          <target state="translated">팀 젠 네스</target>
        </trans-unit>
        <trans-unit id="99e549517dd29d09a287dd50b24a5bc08370dba4" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;</source>
          <target state="translated">Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba097d23c99b23a50efd8f2fea03c845fd6c6c33" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt; provided &lt;code&gt;pod_where&lt;/code&gt; and &lt;code&gt;contains_pod&lt;/code&gt; .</source>
          <target state="translated">Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;는 &lt;code&gt;pod_where&lt;/code&gt; 및 &lt;code&gt;contains_pod&lt;/code&gt; 를 제공 했습니다 .</target>
        </trans-unit>
        <trans-unit id="b514fb185ee4318cecaed2812ba7869208c66528" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;tjenness@cpan.org&amp;gt;</source>
          <target state="translated">Tim Jenness &amp;lt;tjenness@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1869a3cb31c7d1aee298b5966f09e01ff91380af" translate="yes" xml:space="preserve">
          <source>Tim Jenness, &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;, Christian Soeller, &amp;lt;csoelle@mph.auckland.ac.nz&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt.compulink.co.uk&amp;gt;, Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;</source>
          <target state="translated">Tim Jenness, &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;, Christian Soeller, &amp;lt;csoelle@mph.auckland.ac.nz&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt.compulink.co.uk&amp;gt;, Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="93e2988b00d7b32dc16eda9dda1443c70d8e538b" translate="yes" xml:space="preserve">
          <source>Tim.Bunce (at) ig.co.uk</source>
          <target state="translated">Tim.Bunce (at) ig.co.uk</target>
        </trans-unit>
        <trans-unit id="d077aa36842cc868f42990d7049841ea88af7d34" translate="yes" xml:space="preserve">
          <source>Tim.Bunce@ig.co.uk</source>
          <target state="translated">Tim.Bunce@ig.co.uk</target>
        </trans-unit>
        <trans-unit id="e4179a3f25309044bcb58d588fe8e8bd90fd67c9" translate="yes" xml:space="preserve">
          <source>Time COUNT iterations of CODE. CODE may be a string to eval or a code reference; either way the CODE will run in the caller's package. Results will be printed to STDOUT as TITLE followed by the times. TITLE defaults to &quot;timethis COUNT&quot; if none is provided. STYLE determines the format of the output, as described for timestr() below.</source>
          <target state="translated">CODE의 COUNT 번 반복 CODE는 평가할 문자열이거나 코드 참조 일 수 있습니다. 어느 쪽이든 코드가 호출자의 패키지에서 실행될 것입니다. 결과는 TITLE로 STDOUT에 인쇄 된 후 시간이 인쇄됩니다. 제공되지 않은 경우 TITLE의 기본값은 &quot;timethis COUNT&quot;입니다. STYLE은 아래 timestr ()에 설명 된대로 출력 형식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3b32a6d9639a8d4119ec2ee525234d95d8857ca9" translate="yes" xml:space="preserve">
          <source>Time and Date</source>
          <target state="translated">시간과 날짜</target>
        </trans-unit>
        <trans-unit id="ba899f435a04612971ed3cd90f1a2814efd01889" translate="yes" xml:space="preserve">
          <source>Time and daytime network client interface</source>
          <target state="translated">시간 및 주간 네트워크 클라이언트 인터페이스</target>
        </trans-unit>
        <trans-unit id="91258f8a07507a00e4da6f106ca4198c6edce78f" translate="yes" xml:space="preserve">
          <source>Time-related functions</source>
          <target state="translated">시간 관련 기능</target>
        </trans-unit>
        <trans-unit id="ac91bba7fcbd91c8d367a4f56e1aba373023bebd" translate="yes" xml:space="preserve">
          <source>Time::HiRes</source>
          <target state="translated">Time::HiRes</target>
        </trans-unit>
        <trans-unit id="e7a9e6eb81fae6fdb1dc6f6133fdfcde6d6d2e8f" translate="yes" xml:space="preserve">
          <source>Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">시간 :: 고해상도-고해상도 알람, 절전, gettimeofday, 간격 타이머</target>
        </trans-unit>
        <trans-unit id="94df31ba192f82c8d905bfd5f68e42a860c364a4" translate="yes" xml:space="preserve">
          <source>Time::Local</source>
          <target state="translated">Time::Local</target>
        </trans-unit>
        <trans-unit id="f389186d9b9640e798d2c3270420ee058c982a8f" translate="yes" xml:space="preserve">
          <source>Time::Local - Efficiently compute time from local and GMT time</source>
          <target state="translated">시간 :: 현지-현지 및 GMT 시간에서 효율적으로 시간 계산</target>
        </trans-unit>
        <trans-unit id="068e2f4f422dc17d00b1dbbf4d66d078ee8c1c17" translate="yes" xml:space="preserve">
          <source>Time::Local - efficiently compute time from local and GMT time</source>
          <target state="translated">Time :: Local-로컬 및 GMT 시간에서 시간을 효율적으로 계산</target>
        </trans-unit>
        <trans-unit id="0a2a9a0e5d10ea8cd730c55ab8fbc21a6da6bc46" translate="yes" xml:space="preserve">
          <source>Time::Piece</source>
          <target state="translated">Time::Piece</target>
        </trans-unit>
        <trans-unit id="3b1c89f6e740fb1373ec42ee463919eaf109abbc" translate="yes" xml:space="preserve">
          <source>Time::Piece - Object Oriented time objects</source>
          <target state="translated">Time :: Piece-객체 지향 시간 객체</target>
        </trans-unit>
        <trans-unit id="ac2e609ce173a3276a7464b9debe21218246f96d" translate="yes" xml:space="preserve">
          <source>Time::Piece has a built-in strptime() function (from FreeBSD), allowing you incredibly flexible date parsing routines. For example:</source>
          <target state="translated">Time :: Piece에는 내장 strptime () 함수 (FreeBSD에서 제공)가있어 매우 유연한 날짜 구문 분석 루틴을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fb89f7a383c83046c2d6e7aeb455a015e9f82bc" translate="yes" xml:space="preserve">
          <source>Time::Piece::strptime by default can only parse American English date names. Meanwhile, Time::Piece-&amp;gt;strftime() will return date names that use the current configured system locale. This means dates returned by strftime might not be able to be parsed by strptime. This is the default behavior and can be overridden by calling Time::Piece-&amp;gt;use_locale(). This builds a list of the current locale's day and month names which strptime will use to parse with. Note this is a global override and will affect all Time::Piece instances.</source>
          <target state="translated">Time :: Piece :: strptime은 기본적으로 미국 영어 날짜 이름 만 구문 분석 할 수 있습니다. 한편, Time :: Piece-&amp;gt; strftime ()은 현재 구성된 시스템 로케일을 사용하는 날짜 이름을 반환합니다. 이것은 strftime에 의해 반환 된 날짜가 strptime에 의해 구문 분석되지 않을 수 있음을 의미합니다. 이것은 기본 동작이며 Time :: Piece-&amp;gt; use_locale ()을 호출하여 재정의 할 수 있습니다. 이것은 strptime이 구문 분석에 사용할 현재 로케일의 일 및 월 이름 목록을 작성합니다. 이것은 전역 재정의이며 모든 Time :: Piece 인스턴스에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="d40344d994e23d7372c530bbf0bbd03eeb00a6dc" translate="yes" xml:space="preserve">
          <source>Time::Seconds</source>
          <target state="translated">Time::Seconds</target>
        </trans-unit>
        <trans-unit id="39f6129fd39e3df4fcacf60c5d99f5c6192c805d" translate="yes" xml:space="preserve">
          <source>Time::Seconds - a simple API to convert seconds to other date values</source>
          <target state="translated">Time :: Seconds-초를 다른 날짜 값으로 변환하는 간단한 API</target>
        </trans-unit>
        <trans-unit id="cbf1ec1195a651fc24927b61f20ae1c2b1743372" translate="yes" xml:space="preserve">
          <source>Time::Seconds also exports the following constants:</source>
          <target state="translated">Time :: Seconds는 다음 상수도 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="16d75647463ccb98ccc9ac22ce0d58439164ffe1" translate="yes" xml:space="preserve">
          <source>Time::gmtime</source>
          <target state="translated">Time::gmtime</target>
        </trans-unit>
        <trans-unit id="ca443191990262bcf077810f460d0cd5da0a2497" translate="yes" xml:space="preserve">
          <source>Time::gmtime - by-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Time :: gmtime-Perl의 내장 gmtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="1e32398fc4863ae4d240a706fe6661194fea16dc" translate="yes" xml:space="preserve">
          <source>Time::localtime</source>
          <target state="translated">Time::localtime</target>
        </trans-unit>
        <trans-unit id="1c04f7003a511410fc2dc340400d8f81416e8250" translate="yes" xml:space="preserve">
          <source>Time::localtime - by-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Time :: localtime-Perl의 내장 localtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="de41baa484e46c7cf981eab70afe99b8805cc8b2" translate="yes" xml:space="preserve">
          <source>Time::tm</source>
          <target state="translated">Time::tm</target>
        </trans-unit>
        <trans-unit id="21f72c1b3c5d75c7e3444254a7622f9392f93a3d" translate="yes" xml:space="preserve">
          <source>Time::tm - internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time :: tm-Time :: gmtime 및 Time :: localtime에서 사용하는 내부 객체</target>
        </trans-unit>
        <trans-unit id="e368ab9a5fbb03e74a7f8b310c3fe08ae2271a05" translate="yes" xml:space="preserve">
          <source>TimeOut</source>
          <target state="translated">TimeOut</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="bf885321e4853536c53ad9a2c9930e27e148e561" translate="yes" xml:space="preserve">
          <source>Timeout =&amp;gt; NUM</source>
          <target state="translated">시간 초과 =&amp;gt; NUM</target>
        </trans-unit>
        <trans-unit id="c46821e5334d7cbbbeb412cbbc4fae07b635b35c" translate="yes" xml:space="preserve">
          <source>Timeout I/O.</source>
          <target state="translated">시간 초과 I / O.</target>
        </trans-unit>
        <trans-unit id="ca2b6328d392947cda8eed37cd6fd0fce114f5ab" translate="yes" xml:space="preserve">
          <source>Timeout for inactivity during {Makefile,Build}.PL?</source>
          <target state="translated">{Makefile, Build} .PL 동안 비활성 시간 초과?</target>
        </trans-unit>
        <trans-unit id="6202f67c7c444f6f4c73b3c31ad99a53b9159e1b" translate="yes" xml:space="preserve">
          <source>Timeout for parsing module versions?</source>
          <target state="translated">모듈 버전 구문 분석에 대한 시간 초과?</target>
        </trans-unit>
        <trans-unit id="7b97ea2213b8941cebfb4eaa8bbbb9bd0bba9f0a" translate="yes" xml:space="preserve">
          <source>Tiny set of tools for unfortunate souls who cannot use</source>
          <target state="translated">사용할 수없는 불행한 영혼을위한 작은 도구 세트</target>
        </trans-unit>
        <trans-unit id="eb3cc8be33f220718da61643e6e0bc1c501663fd" translate="yes" xml:space="preserve">
          <source>Tips and Techniques</source>
          <target state="translated">팁과 기법</target>
        </trans-unit>
        <trans-unit id="092da30065f07adb4a08c52dc1aaf646aa06aee4" translate="yes" xml:space="preserve">
          <source>Tips and Tricks</source>
          <target state="translated">팁과 요령</target>
        </trans-unit>
        <trans-unit id="f7fb128ab2b2b606667607db6ec0f87259f7a1e5" translate="yes" xml:space="preserve">
          <source>Titlecase</source>
          <target state="translated">Titlecase</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="767ea1b5d1e2d80e5699c6649ded795c6b5cad19" translate="yes" xml:space="preserve">
          <source>To (en|de)code encodings marked by &lt;code&gt;(**)&lt;/code&gt;, you need &lt;code&gt;Encode::HanExtra&lt;/code&gt;, available from CPAN.</source>
          <target state="translated">&lt;code&gt;(**)&lt;/code&gt; 로 표시된 인코딩을 (en | de) 코딩 하려면 CPAN에서 제공하는 &lt;code&gt;Encode::HanExtra&lt;/code&gt; 가 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="75e9f1113dd228531b5734915ff74dd66ea601f0" translate="yes" xml:space="preserve">
          <source>To (re)open &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; as an in-memory file, close it first:</source>
          <target state="translated">&lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 을 메모리 내 파일로 (다시) 열려면 먼저 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="7a790472031c710be009a7b4a42a45592085ee5d" translate="yes" xml:space="preserve">
          <source>To OO or not to OO?</source>
          <target state="translated">OO로 또는 OO로?</target>
        </trans-unit>
        <trans-unit id="2e5fb83e42913577879316262366950ec7aec439" translate="yes" xml:space="preserve">
          <source>To access servers outside these type of firewalls with perl, you need Net::FTP.</source>
          <target state="translated">perl을 사용하여 이러한 유형의 방화벽 외부의 서버에 액세스하려면 Net :: FTP가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9715ff5bc3ceda6802c5265803ef21d4705c83eb" translate="yes" xml:space="preserve">
          <source>To access servers outside these types of firewalls with perl (even for ftp), you need LWP or HTTP::Tiny.</source>
          <target state="translated">ftp를 사용하여 이러한 유형의 방화벽 외부의 서버에 액세스하려면 LWP 또는 HTTP :: Tiny가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="75353a5a7f7320bec3542821474a8dbab7c8c12c" translate="yes" xml:space="preserve">
          <source>To access the actual value that an SV points to, you can use the macros:</source>
          <target state="translated">SV가 가리키는 실제 값에 액세스하기 위해 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18ca46dd427588f094e1ba9ca5a38e797fcd2ac7" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">코어 재정의없이이 기능에 액세스하려면 빈 가져 오기 목록 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 전달한 다음 정규화 된 이름으로 함수 기능에 액세스하십시오. 반면, 내장 기능은 여전히 &lt;code&gt;CORE::&lt;/code&gt; 유사 패키지 를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dca3331d12806630976595e1bbb7790e715a99c2" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">코어 재정의없이이 기능에 액세스하려면 빈 가져 오기 목록 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 전달한 다음 정규화 된 이름으로 함수 기능에 액세스하십시오. 내장 기능은 항상 &lt;code&gt;CORE::&lt;/code&gt; pseudo-package 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00d7f9df22362a2f3c85b921564fc19258d8388c" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">핵심 재정의없이이 기능에 액세스하려면 빈 가져 오기 목록 &lt;code&gt;use&lt;/code&gt; 전달한 다음 정규화 된 이름으로 함수 함수에 액세스합니다. 반면에 내장 기능은 &lt;code&gt;CORE::&lt;/code&gt; 의사 패키지 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8104695610bb754f8e946466b35dfbf1827c0fd9" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">핵심 재정의없이이 기능에 액세스하려면 빈 가져 오기 목록 &lt;code&gt;use&lt;/code&gt; 전달한 다음 정규화 된 이름으로 함수 함수에 액세스합니다. 내장 기능은 항상 &lt;code&gt;CORE::&lt;/code&gt; pseudo-package 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce78b43e2a908e0a4f8a1b6833f38009e23883a3" translate="yes" xml:space="preserve">
          <source>To accomplish this behaviour, simply specify an array reference as the destination for the option:</source>
          <target state="translated">이 동작을 수행하려면 배열 참조를 옵션의 대상으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f61067f007c7ba160effec3a91d355b4f290080e" translate="yes" xml:space="preserve">
          <source>To actually alter the visible command line, you can assign to the variable $0 as documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. This won't work on all operating systems, though. Daemon programs like sendmail place their state there, as in:</source>
          <target state="translated">보이는 명령 행을 실제로 변경하려면 &lt;a href=&quot;perlvar&quot;&gt;perlvar에&lt;/a&gt; 설명 된대로 $ 0 변수를 지정할 수 있습니다 . 그러나 모든 운영 체제에서 작동하지는 않습니다. sendmail과 같은 데몬 프로그램은 다음과 같이 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e6257d01bcff432617bc3aaafa5362a537c023ed" translate="yes" xml:space="preserve">
          <source>To actually do the magic method call, we have to call a subroutine in Perl space: &lt;code&gt;call_method&lt;/code&gt; takes care of that, and it's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. We call the &lt;code&gt;PUSH&lt;/code&gt; method in scalar context, and we're going to discard its return value. The call_method() function removes the top element of the mark stack, so there is nothing for the caller to clean up.</source>
          <target state="translated">실제로 매직 메소드 호출을 수행하려면 Perl 공간에서 서브 루틴을 호출해야합니다. &lt;code&gt;call_method&lt;/code&gt; 가이 를 처리하고 &lt;a href=&quot;perlcall&quot;&gt;perlcall에&lt;/a&gt; 설명되어 있습니다 . 우리 는 스칼라 문맥에서 &lt;code&gt;PUSH&lt;/code&gt; 메소드를 호출하고 그 반환 값을 버릴 것입니다. call_method () 함수는 마크 스택의 맨 위 요소를 제거하므로 호출자가 정리할 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6122d22a4decb5ce34478a60d87283b09ca23b69" translate="yes" xml:space="preserve">
          <source>To actually run a script set-id, if you don't have the safe version of set-id scripts, you'll need to put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">실제로 set-id 스크립트를 실행하려면 안전한 버전의 set-id 스크립트가없는 경우 스크립트 주위에 C 래퍼를 넣어야합니다. AC 래퍼는 Perl 프로그램을 호출하는 것 외에는 아무것도하지 않는 컴파일 된 프로그램입니다. 컴파일 된 프로그램은 set-id 스크립트를 괴롭히는 커널 버그의 영향을받지 않습니다. 다음은 C로 작성된 간단한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="2c5d4ebd8ab0875fd7f6df0d61ffd7b676158145" translate="yes" xml:space="preserve">
          <source>To add a new alias to a given encoding, use:</source>
          <target state="translated">주어진 인코딩에 새 별칭을 추가하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="504c5fdbd3b3208314b10451eb998ac1dfbb6a34" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">특정 줄 앞에 줄을 추가하려면 Perl이 &lt;code&gt;$_&lt;/code&gt; 인쇄하기 전에 줄을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="664ca3b18fd212ce34e3ecc1b835f5946d711935" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt;:</source>
          <target state="translated">특정 행 앞에 행을 추가하려면 Perl이 &lt;code&gt;$_&lt;/code&gt; 인쇄하기 전에 행 (또는 행!)을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41c5424e693984510192a96a5bd33b04a6c7bcb7" translate="yes" xml:space="preserve">
          <source>To add one to something automatically, hence the name of the &lt;code&gt;++&lt;/code&gt; operator. To instead subtract one from something automatically is known as an &amp;ldquo;autodecrement&amp;rdquo;.</source>
          <target state="translated">자동으로 무언가를 추가하려면 &lt;code&gt;++&lt;/code&gt; 연산자 의 이름입니다 . 대신 자동으로 무언가에서 하나를 빼는 것을 &quot;자동 감소&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="62767b0d851017800baeabeacc96e05ce69f9c80" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; variant of the interactive client above.</source>
          <target state="translated">사용자 편의성을 높이기 위해 서버는 사용자에게 명령을 요구합니다. 대부분의 서버는이 작업을 수행하지 않습니다. 줄 바꿈이없는 프롬프트 때문에 위의 대화식 클라이언트 의 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 변형 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2982163185a13aaba90c2350554d80613d204e6d" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;sysread&lt;/code&gt; variant of the interactive client above.</source>
          <target state="translated">사용자 편의성을 높이기 위해 서버는 사용자에게 명령을 입력하라는 메시지를 표시합니다. 대부분의 서버는이 작업을 수행하지 않습니다. 줄 바꿈이없는 프롬프트 때문에 위의 대화 형 클라이언트 의 &lt;code&gt;sysread&lt;/code&gt; 변형 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c2508ff4f655eadc6c615c0836ceada22445901" translate="yes" xml:space="preserve">
          <source>To address these deficiencies, the concept of locales was invented (formally the ISO C, XPG4, POSIX 1.c &quot;locale system&quot;). And applications were and are being written that use the locale mechanism. The process of making such an application take account of its users' preferences in these kinds of matters is called &lt;b&gt;internationalization&lt;/b&gt; (often abbreviated as &lt;b&gt;i18n&lt;/b&gt;); telling such an application about a particular set of preferences is known as &lt;b&gt;localization&lt;/b&gt; (&lt;b&gt;l10n&lt;/b&gt;).</source>
          <target state="translated">이러한 결함을 해결하기 위해 로케일 개념이 개발되었습니다 (공식적으로 ISO C, XPG4, POSIX 1.c &quot;로케일 시스템&quot;). 그리고 로케일 메커니즘을 사용하는 응용 프로그램이 작성되고 작성되었습니다. 이러한 응용 프로그램이 이러한 종류의 문제에서 사용자의 선호도를 고려하도록하는 프로세스를 &lt;b&gt;국제화&lt;/b&gt; (종종 &lt;b&gt;i18n&lt;/b&gt; 이라고 함)라고합니다 . 이러한 애플리케이션에 특정 선호도 세트를 알리는 것을 &lt;b&gt;현지화&lt;/b&gt; ( &lt;b&gt;l10n&lt;/b&gt; )라고한다.</target>
        </trans-unit>
        <trans-unit id="38480288701c4661e4a26dcbd6037e4ac31c3101" translate="yes" xml:space="preserve">
          <source>To aid debugging, the source file</source>
          <target state="translated">소스 파일 디버깅을 돕기 위해</target>
        </trans-unit>
        <trans-unit id="b056ef758d989b19b1755b858981a3d1c4ee3ad4" translate="yes" xml:space="preserve">
          <source>To alleviate the second problem (partially) it is advised to write your scripts like this:</source>
          <target state="translated">두 번째 문제를 부분적으로 완화하려면 다음과 같이 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="033bf41b49c5ad8519d831cfcfc92f95acf893c1" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt; . The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="translated">프로그램이 스위치처럼 보이지만 그렇지 않은 인수를 처리 할 수 ​​있도록하기 위해 두 함수 모두 인수 &lt;code&gt;--&lt;/code&gt; 를 볼 때 스위치 처리를 중지 합니다. 은 &lt;code&gt;--&lt;/code&gt; @ARGV에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="26d2f668076a8bd4840d99c6ca84eae07eb71067" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt;. The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="translated">프로그램이 스위치처럼 보이지만 그렇지 않은 인수를 처리 할 수 ​​있도록 두 함수 모두 &lt;code&gt;--&lt;/code&gt; 인수가 표시 될 때 스위치 처리를 중지 합니다. 은 &lt;code&gt;--&lt;/code&gt; @ARGV에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2288a81816c59a1de87c3ad78e6617983dda9fd7" translate="yes" xml:space="preserve">
          <source>To allow the XSUB for rpcb_gettime() to have a default host value the parameters to the XSUB could be rearranged. The XSUB will then call the real rpcb_gettime() function with the parameters in the correct order. This XSUB can be called from Perl with either of the following statements:</source>
          <target state="translated">rpcb_gettime ()에 대한 XSUB가 기본 호스트 값을 갖도록하기 위해 XSUB에 대한 매개 변수를 재 배열 할 수 있습니다. 그러면 XSUB는 정확한 순서로 매개 변수와 함께 실제 rpcb_gettime () 함수를 호출합니다. 이 XSUB는 다음 명령문 중 하나를 사용하여 Perl에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bdd80dbd948c58cb0887db4e2666aa7ba8a1b77" translate="yes" xml:space="preserve">
          <source>To ask for the next layer down use PerlIONext(PerlIO *f).</source>
          <target state="translated">다음 레이어 다운을 요청하려면 PerlIONext (PerlIO * f)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">특정의 지정하려면 &lt;b&gt;네트워크 주소를&lt;/b&gt; A와 &lt;b&gt;소켓&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">&lt;code&gt;test_test&lt;/code&gt; 를 돕기 위해 디버그 정보의 배경색을 지정하여 다양한 유형의 출력을 명확하게 할 수 있습니다. 디버그 출력의 배경은 녹색과 빨간색으로 표시됩니다. 녹색 부분은 실행 된 출력과 실제 출력간에 동일한 텍스트를 나타내고 빨간색은 어떤 부분이 다른지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">RFC 1950 또는 RFC 1952 데이터 스트림 (예 : gzip)을 자동 감지하고 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="da07f070c84b91e83551c266e4da3f67a05bb198" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt;.</source>
          <target state="translated">RFC 1950 또는 RFC 1952 데이터 스트림 (예 : gzip)을 자동 감지하고 압축 을 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; &lt;code&gt;WindowBits&lt;/code&gt; 를 WANT_GZIP_OR_ZLIB로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">모호성을 피하기 위해 서명이 활성화되면 프로토 타입에 대한 특수 구문이 비활성화됩니다. 괄호로 묶은 그룹이 프로토 타입인지 서명인지를 추측하려는 시도는 없습니다. 이러한 상황에서 서브 루틴에 프로토 타입을 제공하려면 &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype 속성을&lt;/a&gt; 사용하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">이전 버전의 Perl을 실행하는 코드 사용자가 신비한 실패로 혼동하지 않도록 코드의 작동을 알리기 위해 이러한 종류의 파일을 파일 맨 위에 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">신비한 구문 오류로 이전 버전의 Perl을 실행하는 코드 사용자를 혼동하지 않으려면 코드 상단에 이런 종류의 것을 넣어 코드가 작동한다는 신호를 보내십시오</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">신비한 구문 오류로 코드 사용자를 혼동하지 않으려면 스크립트 맨 위에 다음과 같이 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SaveSub2&lt;/code&gt; 가 호출 될 때마다 새 SV가 작성되지 않도록하기 위해이 함수는 먼저 이전에 호출되었는지 확인합니다. 그렇지 않으면 할당되는 새로운 SV에 대한 다음 공간 펄 서브 루틴을 참조 &lt;code&gt;name&lt;/code&gt; 변수에 복사 &lt;code&gt;keepSub&lt;/code&gt; 사용 번의 작업 &lt;code&gt;newSVsv&lt;/code&gt; 를 . 그런 다음 &lt;code&gt;SaveSub2&lt;/code&gt; 가 호출 될 때마다 기존 SV 인 &lt;code&gt;keepSub&lt;/code&gt; 가 &lt;code&gt;SvSetSV&lt;/code&gt; 를 사용하여 새 값으로 겹쳐 씁니다 .</target>
        </trans-unit>
        <trans-unit id="bb5249a309596988b57e0fd6c4b6cf1306fbd076" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt;. Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt;, is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SaveSub2&lt;/code&gt; 가 호출 될 때마다 새 SV가 생성되는 것을 방지하기 위해 함수는 먼저 호출 된 적이 있는지 확인합니다. 그렇지 않으면 할당되는 새로운 SV에 대한 다음 공간 펄 서브 루틴을 참조 &lt;code&gt;name&lt;/code&gt; 변수에 복사 &lt;code&gt;keepSub&lt;/code&gt; 사용 번의 작업 &lt;code&gt;newSVsv&lt;/code&gt; 를 . 때마다 그 후 &lt;code&gt;SaveSub2&lt;/code&gt; 이 라고하며, 기존의 SV, &lt;code&gt;keepSub&lt;/code&gt; 을 사용하여 새 값으로 덮어 &lt;code&gt;SvSetSV&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">메모리 누수를 방지하기 위해 @INC의 모든 후행 중복 항목이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">객체의 기본 표현에 의존하지 않기 위해 스마트 매치의 오른쪽 피연산자가 &lt;code&gt;~~&lt;/code&gt; 을 오버로드하지 않는 객체 인 경우 &quot; 오버로드되지 않은 객체의 스마트 매칭 &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &quot; 예외 가 발생합니다 . 그 이유는 무엇인가가 물체에 있는지 여부를 확인하기 위해 사업을 파고 들지 않기 때문입니다. 이들은 &lt;code&gt;~~&lt;/code&gt; 과부하가 없는 객체에서 모두 불법입니다 .</target>
        </trans-unit>
        <trans-unit id="c22d05674967c3bc15cf7ec7d92f09d20cda4ca5" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt;, it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt;&quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">객체의 기본 표현에 의존하지 않기 위해 smartmatch의 오른쪽 피연산자가 &lt;code&gt;~~&lt;/code&gt; 오버로드하지 않는 객체 인 경우 &quot; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &quot; 예외 가 발생합니다 . 그 이유는 무언가가 물건에 &quot;안&quot;되어 있는지 알아보기 위해 파고 드는 사업이 없기 때문입니다. &lt;code&gt;~~&lt;/code&gt; 오버로드가 없는 객체에서는 모두 불법입니다 .</target>
        </trans-unit>
        <trans-unit id="55a1998bc2a5a4986f2bb06eff8015bbc211cdc8" translate="yes" xml:space="preserve">
          <source>To avoid slab fragmentation, freed ops are marked as freed and attached to the slab's freed chain (an idea stolen from DBM::Deep). Those freed ops are reused when possible. Not reusing freed ops would be simpler, but it would result in significantly higher memory usage for programs with large &lt;code&gt;if (DEBUG) {...}&lt;/code&gt; blocks.</source>
          <target state="translated">슬래브 조각화를 방지하기 위해 해제 된 작업은 해제 된 것으로 표시되고 슬래브의 해제 된 체인에 연결됩니다 (DBM :: Deep에서 훔친 아이디어). 해제 된 작업은 가능한 경우 재사용됩니다. 해제 된 작업을 재사용하지 않는 것이 더 간단하지만 &lt;code&gt;if (DEBUG) {...}&lt;/code&gt; 블록 이 큰 프로그램의 경우 메모리 사용량이 상당히 높아집니다 .</target>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">잘못 조정될 가능성을 피하기 위해 Perl은 이제 파일을 잠 그거나 잠금 해제하기 전에 FILEHANDLE을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="3c85a34364c95e0f00f8b4537e9fe9720d82fa1b" translate="yes" xml:space="preserve">
          <source>To avoid this blocking behaviour, the caller should pass in the result of such a lookup using the &lt;code&gt;PeerAddrInfo&lt;/code&gt; or &lt;code&gt;LocalAddrInfo&lt;/code&gt; arguments. This can be achieved by using &lt;a href=&quot;Net::LibAsyncNS&quot;&gt;Net::LibAsyncNS&lt;/a&gt;, or the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function can be called in a child process.</source>
          <target state="translated">이러한 차단 동작을 방지하려면 호출자가 &lt;code&gt;PeerAddrInfo&lt;/code&gt; 또는 &lt;code&gt;LocalAddrInfo&lt;/code&gt; 인수를 사용하여 이러한 조회 결과를 전달해야합니다 . 이는 &lt;a href=&quot;Net::LibAsyncNS&quot;&gt;Net :: LibAsyncNS&lt;/a&gt; 를 사용하여 수행 하거나 &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 함수를 자식 프로세스에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">이 문제를 피하려면 추가 괄호를 넣거나 매우 낮은 우선 순위 &lt;code&gt;or&lt;/code&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">이 문제를 피하기 위해 수정 가능한 문자열에서 추출하는 동안 here 문서가 발생하면 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 문자열을 동등한 Perl 조각으로 자동 재 배열합니다.</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">이 경고를 피하고 단일 스트림에서 다른 출력 인코딩을 피하려면 항상 PerlIO 레이어와 같은 인코딩을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">이력서 및 관련 패드가 해제 될 때마다이를 방지하기 위해, 어떤 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드의 항목을 명시 적으로 패드에서 제거하는 경우 익명 서브는 여전히 긍정적 인 지적-, 다음 자녀의 것을의 refcount가 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 가 포인트로 설정 조부모에게. 이는 하나 이상의 활성 참조 (예 : 위의 &lt;code&gt;$a&lt;/code&gt; )를 가진 비 폐쇄 아논 프로토 타입의 경우에만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">이를 방지하려면 WriteMakefile () 인수에 버전 번호를 추가하여 버전 번호가 포함 된 모듈을 변경할 때마다 Makefile을 강제로 다시 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">다시 시작해야 할 때 낭비되는 작업을 피하기 위해 크기 조정 단계가 취소됩니다. &lt;code&gt;regatom()&lt;/code&gt; 즉시 NULL을 반환하고 플래그 &lt;code&gt;RESTART_UTF8&lt;/code&gt; 을 설정합니다 . 이 조치는 매크로 &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 을 사용하여 캡슐화됩니다 .이 재시작 요청은 패턴이 유니 코드를 포함하는 것으로 표시하고 사이징 패스를 다시 시작하는 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 에서 호출 될 때까지 유사한 방식으로 호출 체인으로 전파됩니다 . 그것은 런타임 코드 블록 내에서 구조 유니 코드 표현을 필요로 판명 할 수있다.,에 의해 신호되는 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 로 돌아 거짓을 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">스택에서 반환 된 두 매개 변수에 액세스 할 수 있도록</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">발표 될.</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">발표 될. 또는 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">.Net 정규식과 호환되도록 &lt;code&gt;\g{name}&lt;/code&gt; 을 &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 으로 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f26c77c319cb6291a616300d3aa5bcb9b742805" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">.Net 정규식과 호환되기 위해 &lt;code&gt;\g{name}&lt;/code&gt; 은 &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 로 작성 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cda9b7c28c9197f9e2d7b4ff8ca73ca58bad94f4" translate="yes" xml:space="preserve">
          <source>To be even more flexible, use &lt;code&gt;done_testing&lt;/code&gt;. This means we're just running some tests, don't know how many. [6]</source>
          <target state="translated">더 유연하게하려면 &lt;code&gt;done_testing&lt;/code&gt; 을 사용 하세요 . 이것은 우리가 단지 몇 가지 테스트를 실행하고 있다는 것을 의미합니다. 얼마나 많은지 모릅니다. [6]</target>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">Exporter 및 MakeMaker 모듈과 완벽하게 호환되도록하려면 모듈의 버전 번호를 $ VERSION이라는 내 패키지가 아닌 변수에 저장해야합니다. 소수점 이하 두 자릿수 이상의 양의 부동 소수점 숫자 여야합니다 (예 : &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). &quot;1.3.2&quot;스타일 버전을 사용하지 마십시오. 자세한 내용은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aca5a42cae80e068514dd5dee0bc31352df05942" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt;). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">Exporter 및 MakeMaker 모듈과 완전히 호환 되려면 $ VERSION이라는 비 my 패키지 변수에 모듈의 버전 번호를 저장해야합니다. 소수점 이하 두 자리 이상이있는 양의 부동 소수점 숫자 여야합니다 (예 : &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). &quot;1.3.2&quot;스타일 버전을 사용하지 마십시오. 자세한 내용은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">더 정확하게 말하면, 정규식 프로그램은 그래프의 인코딩이라고 말할 것입니다. 그래프의 각 노드는 리터럴 문자열 또는 분기와 같은 원래 정규식 패턴의 일부에 해당하며 일치시킬 다음 구성 요소를 나타내는 노드에 대한 포인터를 갖습니다. &quot;node&quot;와 &quot;opcode&quot;는 이미 perl 소스에서 다른 의미를 갖기 때문에 정규식 프로그램 &quot;regops&quot;에서 노드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">pedantic하기 위해 비교는 실제로 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; 이지만 부동 소수점 표현식을 사용하는 경우에만 문제가됩니다. 암시 적으로 &lt;code&gt;$.&lt;/code&gt; 사용할 때 . 이전 단락에서 설명했듯이 비교는 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; 이며 $ 일 때만 발생 &lt;code&gt;$.&lt;/code&gt; 이 부동 소수점 값으로 설정되어 있고 파일에서 읽지 않습니다. 또한 &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 또는 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 는 각 피연산자가 정수 표현을 사용하여 평가되므로 스칼라 컨텍스트에서 원하는 것을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a2cc51866f8f7fa513bdcb0e655d22cd247b768" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;int(EXPR) == int(EXPR)&lt;/code&gt;, but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;int(EXPR) == int($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">현명하게 비교하면 실제로는 &lt;code&gt;int(EXPR) == int(EXPR)&lt;/code&gt; 이지만 부동 소수점 표현식을 사용하는 경우에만 문제가됩니다. 암시 적으로 &lt;code&gt;$.&lt;/code&gt; 사용할 때 . 이전 단락에서 설명한대로 비교는 &lt;code&gt;int(EXPR) == int($.)&lt;/code&gt; 이며 &lt;code&gt;$.&lt;/code&gt; 부동 소수점 값으로 설정되고 파일에서 읽지 않습니다. 또한 &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 또는 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 는 각 피연산자가 정수 표현을 사용하여 평가되기 때문에 스칼라 컨텍스트에서 원하는 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">자신을 감싸는 다른 함수에 정중하려면 일반적으로 상수를 설정하는 대신 &lt;code&gt;$Level&lt;/code&gt; 을 늘리려 고합니다.</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">이식 가능한 모듈 이름의 각 구성 요소는 11 자로 제한되어야합니다. MS-DOS에서 사용될 수 있으면 처음 8 자에서 고유한지 확인하십시오. 중첩 모듈을 사용하면이 작업이 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="82fd649ae548631dbfdff32da1fa30eb76335c87" translate="yes" xml:space="preserve">
          <source>To be safe, we should have anchored the above example, to prevent matches for something like &lt;code&gt;Hebrew_Braille&lt;/code&gt;, but there aren't any script names like that, so far. A warning is issued if none of the legal values for a property are matched by your pattern. It's likely that a future release will raise a warning if your pattern ends up causing every possible code point to match.</source>
          <target state="translated">안전을 위해, 우리는 &lt;code&gt;Hebrew_Braille&lt;/code&gt; 과 같은 것에 대한 일치를 방지하기 위해 위의 예를 고정해야 했지만, 지금까지 그런 스크립트 이름은 없습니다. 패턴과 일치하는 속성의 합법적 인 값이 없으면 경고가 발생합니다. 패턴이 모든 가능한 코드 포인트가 일치하도록하는 경우 향후 릴리스에서 경고가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">독서를 시작하려면 다음과 같이 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">기존 Perl 버그 및 패치를 찾아 보려면 웹 인터페이스 ( &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/)를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">비 XS 모듈을 구축하기 위해 perl 모듈과 함께 배포 된 표준 모듈 구축 지침을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">XS 모듈을 빌드하려면 perl 모듈 * PLUS *와 함께 배포 된 표준 모듈 빌드 명령어를 사용하여 DJGPP &quot;정적 링크&quot;빌드 환경과 관련된 세 가지 추가 명령어를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">표준 확장 이외의 확장을 구축하려면 Windows Perl과 함께 NetWare Perl을 Windows에 설치해야합니다. Windows 용 Perl은 CPAN 사이트에서 다운로드하여 소스를 사용하여 빌드하거나 바이너리를 ActiveState 사이트에서 직접 다운로드 할 수 있습니다. 호출하여 설치 가능</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">Stratus V 시리즈 플랫폼의 소스 코드에서 perl을 빌드하려면 OpenVOS 릴리스 17.1.0 이상, GNU 도구 릴리스 3.5 이상 및 C / POSIX 런타임 라이브러리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8374368118e0a9e9250156402520f453adca786" translate="yes" xml:space="preserve">
          <source>To build perl under AmigaOS from the patched sources you will need to have a recent version of the SDK. Version 53.29 is recommended, earlier versions will probably work too.</source>
          <target state="translated">패치 된 소스에서 AmigaOS에서 perl을 빌드하려면 최신 버전의 SDK가 필요합니다. 버전 53.29가 권장되며 이전 버전도 작동 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">AddressSanitizer를 사용하여 perl을 빌드하려면 Configure 호출이 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">n 비트 메시지의 요약을 계산하려면</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">런던 (51.3N 0.5W)과 도쿄 (35.7N 139.8E) 사이의 거리를 킬로미터로 계산하려면 :</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">배열의 각 요소에 대해 함수를 호출하고 결과를 수집하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">배열의 각 요소에서 함수를 호출하지만 결과를 무시하려면</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">(작은) 범위의 각 정수에서 함수를 호출하려면 다음 &lt;b&gt;을&lt;/b&gt; 사용할 &lt;b&gt;수&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">개별 Perl 서브 루틴을 호출하기 위해 &lt;b&gt;perlcall에&lt;/b&gt; 문서화 된 &lt;a href=&quot;perlcall&quot;&gt;call_ &lt;/a&gt;&lt;b&gt;*&lt;/b&gt; 함수를 사용할 수 있습니다 . 이 예에서는 &lt;code&gt;call_argv&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="7b0356115da72e97143cd3fb75c87b7ab25d47c5" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt;.</source>
          <target state="translated">개별 Perl 서브 루틴을 호출하려면 &lt;b&gt;perlcall에&lt;/b&gt; 문서화 된 &lt;a href=&quot;perlcall&quot;&gt;call_ &lt;/a&gt;&lt;b&gt;*&lt;/b&gt; 함수를 사용할 수 있습니다 . 이 예에서는 &lt;code&gt;call_argv&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">서브 루틴을 호출하려면</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">명령의 STDERR을 캡처하고 STDOUT을 삭제하려면 (순서는 중요합니다) :</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">명령의 STDERR을 캡처하고 해당 STDOUT을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">명령의 STDOUT을 캡처하고 해당 STDERR을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">프로그램의 STDERR을 캡처하고 STDOUT을 자체 STDERR로 보내려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">프로그램의 STDERR을 캡처하고 STDOUT을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">프로그램의 STDOUT을 캡처하고 STDERR을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">이런 종류의 문제를 잡기 위해, 우리는 엄격하게 모듈을 잡아 당기고 'use strict; 스크립트의 첫 줄 뒤에.</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">전체 텍스트 줄을 가운데에 맞추려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">기존 줄을 변경하려면 코드를 삽입하여 &lt;code&gt;while&lt;/code&gt; 루프 내부의 줄을 수정하십시오 . 이 경우 코드는 소문자 &quot;perl&quot;버전을 모두 찾아 대문자를 찾습니다. 모든 라인에서 발생하므로 모든 라인에서 그렇게해야합니다!</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">이러한 요소 중 하나를 변경하려면 다음과 같이 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">특정 행만 입력 행 번호 &lt;code&gt;$.&lt;/code&gt; 유용합니다. 먼저 변경하고자하는 줄을 읽고 인쇄하십시오. 그런 다음 변경하려는 한 줄을 읽고 변경 한 후 인쇄하십시오. 그런 다음 나머지 줄을 읽고 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8261e5499a7ae4c48592a1983635f3df7192d7cc" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt;, is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">특정 라인 만 변경하려면 입력 라인 번호 &lt;code&gt;$.&lt;/code&gt; , 유용합니다. 먼저 변경하려는 행까지 읽고 인쇄하십시오. 다음으로 변경하려는 한 줄을 읽고 변경 한 다음 인쇄합니다. 그 후 나머지 줄을 읽고 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">다섯 번째 줄만 변경하려면 &lt;code&gt;$.&lt;/code&gt; 검사하는 테스트를 추가 할 수 있습니다 . , 입력 라인 번호를 입력 한 다음 테스트를 통과 한 경우에만 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="833e5f56fff3dfac3d9eb1d5cb139919fbf68571" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt;, the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">다섯 번째 줄만 변경하려면 &lt;code&gt;$.&lt;/code&gt; 검사하는 테스트를 추가 할 수 있습니다 . , 입력 라인 번호를 입력 한 다음 테스트를 통과 할 때만 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">문자열의 일부를 변경하려면 대체 문자열 인 선택적 네 번째 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">구성을 변경하려면 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;-d&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">의 값을 변경하려면</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">특정 클래스에서 파생 된 객체가 있는지 확인하려면 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">PerlIO *가 유효한지 확인하려면 PerlIOValid (PerlIO * f)를 사용하십시오. (이 모든 것은 실제로 포인터가 NULL이 아니며 그 뒤에 포인터가 NULL이 아닌지 확인하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">이를 피하기 위해 Perl은 두 가지 핵을 사용합니다. 그들은 반대</target>
        </trans-unit>
        <trans-unit id="fc16356cccf83cfc4cbdd42d7b6c6a4bf9f4c7cd" translate="yes" xml:space="preserve">
          <source>To clean up after compilation you can use either of</source>
          <target state="translated">컴파일 후 정리하려면 다음 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">화면을 지우려면 터미널에 화면을 지우도록 지시하는 특수 순서를 인쇄하면됩니다. 해당 시퀀스가 ​​있으면 화면을 지우고 싶을 때 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="aeb7d489151127988ed87013a2d0db094b3d4f08" translate="yes" xml:space="preserve">
          <source>To commit to a maintenance version of perl, you need to create a local tracking branch:</source>
          <target state="translated">perl의 유지 관리 버전을 적용하려면 로컬 추적 분기를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c45964cfffa3b2dbc072504434f04f57c4932a60" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;&lt;code&gt;foldEQ_utf8()&lt;/code&gt;&lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">두 문자열을 대소 문자를 구분하지 않고 비교하려면 &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt; &lt;code&gt;foldEQ_utf8()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 ( 문자열이 동일한 UTF-8ness를 가질 필요는 없음).</target>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">대소 문자를 구분하지 않고 두 문자열을 비교하려면 &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8 ()을&lt;/a&gt; 사용 하십시오 ( 문자열의 UTF-8이 같을 필요는 없음).</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">스레드로 Perl을 컴파일하려면 Configure의 인수에 -Dusethreads를 추가하십시오. -D_POSIX_C_SOURCE = 199506L 컴파일러 플래그가 플래그 목록에 자동으로 추가되는지 확인하십시오. 또한 Perl을 링크 할 라이브러리 목록에서 -lpthread가 -lc 앞에 나열되어 있는지 확인하십시오. 구성 중에 HP-UX에 제공되는 힌트는이 작업을 올바르게 수행하기 위해 매우 노력합니다.</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">최신 Sun 컴파일러를 사용하여 UltraSparc에서 64 비트 응용 프로그램을 컴파일하려면 &quot;-xarch = v9&quot;플래그를 사용해야합니다. getconf (1)이이를 알려줄 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="aafe5bf2c4343a0e3d4371c91d0581b8bfb71744" translate="yes" xml:space="preserve">
          <source>To compile the demonstration application PerlApp you need first to install the Perl headers under the SDK.</source>
          <target state="translated">데모 애플리케이션 PerlApp을 컴파일하려면 먼저 SDK 아래에 Perl 헤더를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 8과 15 사이의 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf7349fcec84071676b172827e1a49b634a1fdb7" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">RFC 1951 데이터 스트림을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3745f78ab286dd7d4193d09748c3eef61c61724d" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt;.</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">연결하기</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">구성하려면</target>
        </trans-unit>
        <trans-unit id="27b8a31fcae13694057ef8e5270215d578e3caf3" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">하나의 파일 핸들을 여러 출력 파일 핸들에 연결하려면 &lt;a href=&quot;IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt; 또는 &lt;a href=&quot;Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">하나의 파일 핸들을 여러 출력 파일 핸들에 연결하기 위해 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">메모리를 절약하려면 컴파일러 모듈을 링크 목록 또는 단계 lib가 아닌 LPA / ELPA (Link Pack Area)에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">초기 CPAN 셸 시작 속도를 상당히 높이기 위해 Storable을 사용하여 메타 데이터 캐시를 생성 할 수 있습니다. 저장 가능을 사용할 수없는 경우 일반 색인 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">저자에게 연락하려면 다음 &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt; 로 이메일을 보내십시오 : mjd-perl-tiefile+@plover.com</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">표시 할 텍스트를 제어하려면 다음과 같이 &quot; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7f787791e1e7cbfd6f94bf52b9685495ede53680" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;config#perlpath&quot;&gt;&lt;code&gt;$Config{perlpath}&lt;/code&gt;&lt;/a&gt; to a file pathname, say:</source>
          <target state="translated">&lt;a href=&quot;config#perlpath&quot;&gt; &lt;code&gt;$Config{perlpath}&lt;/code&gt; &lt;/a&gt; 를 파일 경로 이름으로 변환하려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="c07c15697f1959a79e3e58a6af11dd7e45671417" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;perlvar#%24%5EX&quot;&gt;&lt;code&gt;$^X&lt;/code&gt;&lt;/a&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">다양한 운영 체제 가능성의 요구 사항을 고려하여 &lt;a href=&quot;perlvar#%24%5EX&quot;&gt; &lt;code&gt;$^X&lt;/code&gt; &lt;/a&gt; 를 파일 경로 이름으로 변환하려면 다음 과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">&lt;code&gt;$Config{perlpath}&lt;/code&gt; 를 파일 경로 이름으로 변환하려면 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">다양한 운영 체제 요구 사항을 고려하여 &lt;code&gt;$^X&lt;/code&gt; 를 파일 경로 이름으로 변환하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">8 진수를 변환하려면 from_oct ();</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">EBCDIC 037에서 ASCII로 변환하려면 tr /// 인수의 순서를 반대로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">새 스타일에서 이전 스타일로 변환하려면 다음 레시피를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="b7383321848919d955ca5bfae7880346b845b2ba" translate="yes" xml:space="preserve">
          <source>To convert strings that might start with any of &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0x&lt;/code&gt;, or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;. To present something as hex, look into &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작할 수있는 문자열을 변환하려면 &lt;a href=&quot;#oct-EXPR&quot;&gt; &lt;code&gt;oct&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 에 존재 진수로 뭔가보고 &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; 와&lt;/a&gt; , 및 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">모든 .c 파일을 백업 디렉토리로 복사하려면</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">배열을 복사하려면</target>
        </trans-unit>
        <trans-unit id="49c50a429b3a772bc583381f94d7fd07c2224e83" translate="yes" xml:space="preserve">
          <source>To correctly maintain reference counts, it is essential to keep track of what references the XS code is manipulating. The programmer should always know where a reference has come from and who owns it, and be aware of any creation or destruction of references, and any transfers of ownership. Because ownership isn't represented explicitly in the xV data structures, only the reference count need be actually maintained by the code, and that means that this understanding of ownership is not actually evident in the code. For example, transferring ownership of a reference from one owner to another doesn't change the reference count at all, so may be achieved with no actual code. (The transferring code doesn't touch the referenced object, but does need to ensure that the former owner knows that it no longer owns the reference, and that the new owner knows that it now does.)</source>
          <target state="translated">참조 횟수를 올바르게 유지하려면 XS 코드가 조작하는 참조를 추적하는 것이 중요합니다. 프로그래머는 항상 참조의 출처와 소유자를 알고 있어야하며 참조의 생성 또는 파괴, 소유권 이전에 대해 알고 있어야합니다. 소유권은 xV 데이터 구조에서 명시 적으로 표현되지 않기 때문에 코드에서 실제로 참조 횟수 만 유지하면되며 이는 소유권에 대한 이해가 실제로 코드에서 분명하지 않다는 것을 의미합니다. 예를 들어 참조의 소유권을 한 소유자에서 다른 소유자로 이전해도 참조 횟수가 전혀 변경되지 않으므로 실제 코드 없이도 달성 할 수 있습니다. (전송 코드는 참조 된 객체를 건드리지 않지만 이전 소유자가 더 이상 참조를 소유하지 않음을 알고 있는지 확인해야합니다.새 소유자는 지금 알고 있다는 것을 알고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">이러한 경우를 다루기 위해 다음을 통해 메소드를 다시 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">리터럴로 유니 코드 문자를 만들려면 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\N{...}&lt;/code&gt; 표기법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">POD 문서를 다른 형식으로 변환하기위한 POD 필터를 만들려면 일반적으로 다음 방법에 대한 기본 클래스 구현 만 재정의하는 &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 하위 클래스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">Perl의 인터페이스로 XS를 사용하는 C와는 달리 Perl에서 PerlIO 계층을 구현하는 Perl 모듈을 작성하려면 다음 서브 루틴 중 일부를 제공해야합니다. 이러한 Perl 모듈을 PerlIO :: via :: 네임 스페이스에 작성하여 CPAN에 쉽게 위치하고 PerlIO :: via 모듈 자체의 기본 네임 스페이스 기능을 사용할 수 있도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">최소한 자신의 아이디어를 얻을 때까지 부모 프로세스와 동일한 자식 &lt;b&gt;프로세스&lt;/b&gt; 를 만듭니다 . 메모리가 보호 된 스레드</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">복소수를 만들려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">핸들러를 작성하려면 원하는 속성과 이름이 같은 서브 루틴으로 정의하고 속성 &lt;code&gt;:ATTR&lt;/code&gt; 을 사용하여 서브 루틴 자체를 선언하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be1f84ddb058aa59042284e3c774355eb9bd0e7" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt;. For example:</source>
          <target state="translated">핸들러를 생성하려면 원하는 속성과 이름이 같은 서브 루틴으로 정의하고 &lt;code&gt;:ATTR&lt;/code&gt; 속성을 사용하여 서브 루틴 자체를 선언합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8c75fd66b25e79071f909e18cf1703b677444d" translate="yes" xml:space="preserve">
          <source>To create a mortal reference, use the functions:</source>
          <target state="translated">필사 참조를 생성하려면 다음 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">필사자 변수를 만들려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">명명 된 파이프를 만들려면 &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">Perl 스크립트에서 액세스 할 수있는 undef 값으로 새 Perl 변수를 작성하려면 변수 유형에 따라 다음 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">새로운 구획을 만들려면</target>
        </trans-unit>
        <trans-unit id="5e69f259d43b2f65fc36274b2ebe4426a448a0c1" translate="yes" xml:space="preserve">
          <source>To create a patch file for all your local changes:</source>
          <target state="translated">모든 로컬 변경 사항에 대한 패치 파일을 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">참조를 작성하려면 다음 기능 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">참조를 만들기 위해 &lt;code&gt;newRV&lt;/code&gt; 함수를 사용합니다 . 이 경우 AV * 또는 HV *를 캐스팅하여 SV *를 입력 할 수 있습니다 (및 기타 여러 유형). 이를 통해 동일한 함수를 사용하여 배열, 해시 및 스칼라를 참조 할 수 있습니다. 반대로 &lt;code&gt;SvRV&lt;/code&gt; 함수는 항상 SV *를 반환합니다. SV *는 스칼라가 아닌 다른 유형 인 경우 적절한 유형으로 캐스트해야 할 수도 있습니다 ( &lt;code&gt;SvTYPE&lt;/code&gt; 으로 확인 ).</target>
        </trans-unit>
        <trans-unit id="76c3711b1f4442657fc38b46f51a53e19c63e499" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV_inc&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt;).</source>
          <target state="translated">참조를 생성하기 위해 &lt;code&gt;newRV_inc&lt;/code&gt; 함수를 사용합니다 . 이 경우 AV * 또는 HV *를 SV *를 입력 할 수 있습니다 (및 기타 여러 유형). 이를 통해 동일한 함수로 배열, 해시 및 스칼라에 대한 참조를 가져올 수 있습니다. 반대로 &lt;code&gt;SvRV&lt;/code&gt; 함수는 항상 SV *를 반환하며, 스칼라가 아닌 경우 적절한 유형으로 캐스트해야 할 수 있습니다 ( &lt;code&gt;SvTYPE&lt;/code&gt; 으로 확인 ).</target>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">공유 라이브러리를 작성하려면 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha.txt&lt;/code&gt; 및 &lt;code&gt;beta.txt&lt;/code&gt; 파일의 압축 된 내용을 포함 하는 zip 파일 &lt;code&gt;output.zip&lt;/code&gt; 을 만들려면</target>
        </trans-unit>
        <trans-unit id="4b6ff2c8131533c1aec284cd279aab620b4a7896" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt;, that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha.txt&lt;/code&gt; 및 &lt;code&gt;beta.txt&lt;/code&gt; 파일의 압축 내용을 포함 하는 zip 파일 &lt;code&gt;output.zip&lt;/code&gt; 을 생성하려면</target>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">HV를 작성하려면 다음 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">RFC 1950 데이터 스트림을 작성하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 작성하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="04500f8f7e1689707f89183f5977f70d07b39e1b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">RFC 1951 데이터 스트림을 생성하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">자신 만의 결과 유형을 만들려면 다음 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">&lt;b&gt;참조&lt;/b&gt; 의 메모리 할당을 해제합니다 (먼저 &lt;code&gt;DESTROY&lt;/code&gt; 메소드가있는 경우 해당 메소드를 트리거 ).</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">파일 전용 변수를 선언하기 위해 여전히 어휘 변수를 사용합니다. 파일도 범위이므로 파일에 정의 된 어휘 변수를 다른 파일에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">여러 부모를 선언하려면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하기 위해 여러 클래스 이름을 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bb1aac304b6e2bad9b2c8e30ae0f6a69783e20b" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;use parent&lt;/code&gt;:</source>
          <target state="translated">여러 부모를 선언하려면 &lt;code&gt;use parent&lt;/code&gt; 를 사용 하기 위해 여러 클래스 이름을 전달하기 만하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">서브 루틴을 선언하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">문자열을 디코딩하려면 &lt;code&gt;uri_unescape&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">새로운 인코딩을 정의하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">런타임시 익명 서브 루틴을 정의하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">자신의 변수를 정의하려면 해시에 변수를 추가하거나 필요한 경우 기존 값을 변경하십시오. 레벨과 형식은 스칼라에 대한 참조로 전달되지만 변경되거나 사용될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">필터 패스를 삭제하려면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13cdb92e706e9bc2ee9e805b13be6097ddaf3e74" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;undef&lt;/code&gt; to it.</source>
          <target state="translated">필터를 삭제하려면 &lt;code&gt;undef&lt;/code&gt; 를 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="c6700a8c11e3d4c6c50392505cb5fdaeda8fab3d" translate="yes" xml:space="preserve">
          <source>To delete a partition, zero out all fields except for &lt;code&gt;$bToRewrite&lt;/code&gt; which should be set to &lt;code&gt;1&lt;/code&gt;. To add a partition, increment &lt;code&gt;$cPartitions&lt;/code&gt; and add the information for the new partition into the arrays, making sure that you insert &lt;code&gt;1&lt;/code&gt; into @bToRewrite.</source>
          <target state="translated">파티션을 삭제하려면 &lt;code&gt;1&lt;/code&gt; 로 설정해야하는 &lt;code&gt;$bToRewrite&lt;/code&gt; 를 제외한 모든 필드를 제로화하십시오 . 파티션을 추가하려면 &lt;code&gt;$cPartitions&lt;/code&gt; 새 파티션에 대한 정보를 배열에 추가하여 @bToRewrite에 &lt;code&gt;1&lt;/code&gt; 을 삽입해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">줄을 삭제하려면 원하는 줄만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">런타임 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 기능이 perl에 컴파일되었는지 판별하려면 $ Config {usesitecustomize} 값을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e519c90ecace9cdd9ef4f4b53067e00b66728320" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt;.</source>
          <target state="translated">런타임에이 기능이 펄에서 컴파일되었는지 확인하려면 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 값을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ac9c1626cb28585a5803d5d3d2ce1edde74347f" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">모듈이 Perl 버전과 함께 제공되었는지 확인하려면 &lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList&lt;/a&gt; 모듈을 설치하고 사용할 수 있습니다 . 각 Perl 릴리스에 포함 된 모듈 (버전 포함)에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">모듈이 Perl 버전과 함께 제공되었는지 확인하려면 &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; 모듈을 설치하고 사용할 수 있습니다 . 여기에는 각 Perl 릴리스에 포함 된 모듈 (버전과 함께)에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">문자열이 유니 코드인지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">SV가 참조인지 확인하기 위해 다음 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">ASCII 또는 EBCDIC에서 실행 중인지 판별하기 위해 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 사용하여 하나 이상의 문자 값을 테스트 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4d19f268a46b2039ad626d07491613ba196e3ba" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;ord()&lt;/code&gt; or &lt;code&gt;chr()&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">ASCII 또는 EBCDIC에서 실행 중인지 확인하려면 &lt;code&gt;ord()&lt;/code&gt; 또는 &lt;code&gt;chr()&lt;/code&gt; 의 반환 값을 사용하여 하나 이상의 문자 값을 테스트 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">perl이 EBCDIC 코드 페이지에서 빌드되었는지 여부를 판별하려면 다음과 같이 구성 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 를 볼 수 있도록 특정 경고가 할당 된 카테고리를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="a93e35e1721136bbf3e35a386749266ad37800e0" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 죽으려면 &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt; 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 죽기 위해 &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1dfd486790a39158f4a7ca56ddcfea76a7b570b2" translate="yes" xml:space="preserve">
          <source>To disable blessing objects while thawing/retrieving remove the flag &lt;code&gt;BLESS_OK&lt;/code&gt; = 2 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="translated">해동 / 검색하는 동안 축복 객체를 비활성화하려면 &lt;code&gt;$Storable::flags&lt;/code&gt; 에서 &lt;code&gt;BLESS_OK&lt;/code&gt; = 2 플래그를 제거 하거나 thaw / retrieve의 두 번째 인수를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">프로토 타입을 비활성화하려면 :</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">범위 지정을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="49438a7c7aac56a61be90484df5f68db7923a254" translate="yes" xml:space="preserve">
          <source>To disable the feature and, if applicable, re-enable any warnings, use:</source>
          <target state="translated">기능을 비활성화하고 해당하는 경우 경고를 다시 활성화하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">이 검사를 비활성화하려면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff637f529a61890918adfda94de235cbe32273b" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 검사를 비활성화하려면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">이 기본 안전 모드를 사용하지 않으려면이 값을 0보다 높은 값으로 설정하십시오. 1 레벨에서는 모든 종류의 경고 (종종 성가시다) 또는 예외 (종종 귀중한 것)를 수신하면 역 추적을받습니다. 불행하게도, 디버거는 치명적인 예외를 치명적이지 않은 예외와 구별 할 수 없습니다. 경우 &lt;code&gt;dieLevel&lt;/code&gt; 는 ,도 1 다음 치명적이지 않은 예외도 추적하고 무례 그들이에서 온 경우 변경 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; 문자열이나 어떤 종류에서 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 당신이 부하를 시도하고 모듈 내에서. &lt;code&gt;dieLevel&lt;/code&gt; 인 경우2는 디버거가 어디에서 왔는지 상관하지 않습니다. 예외 처리기를 제거하고 추적을 인쇄 한 다음 자체 예외로 모든 예외를 수정합니다. 이것은 아마도 일부 추적 목적에 유용 할 수 있지만 예외 처리를 심각하게 취하는 프로그램을 절망적으로 파괴하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4293ab3018dc6b8d0d5076e39654c8c02af5e2" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;eval'ed&lt;/code&gt; strings or from any kind of &lt;code&gt;eval&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">이 기본 안전 모드를 비활성화하려면이 값을 0보다 높은 값으로 설정하십시오. 레벨 1에서 모든 종류의 경고 (종종 성가신) 또는 예외 (종종 가치가 있음)를 수신하면 역 추적을 받게됩니다. 불행히도 디버거는 치명적이지 않은 예외와 치명적인 예외를 식별 할 수 없습니다. 경우 &lt;code&gt;dieLevel&lt;/code&gt; 는 ,도 1 다음 치명적이지 않은 예외도 추적하고 무례 그들이에서 온 경우 변경 &lt;code&gt;eval'ed&lt;/code&gt; 문자열이나 어떤 종류에서 &lt;code&gt;eval&lt;/code&gt; 당신이 부하를 시도하고 모듈 내에서. 만약 &lt;code&gt;dieLevel&lt;/code&gt; 디버거는 그것이 어디에서 왔는지 상관하지 않습니다. 예외 처리기를 사용하고 추적을 인쇄 한 다음 자체 장식으로 모든 예외를 수정합니다. 이것은 일부 추적 목적에 유용 할 수 있지만 예외 처리를 심각하게 받아들이는 모든 프로그램을 절망적으로 파괴하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="775ac8e4b166c7efdd67d5a474126369cafcedff" translate="yes" xml:space="preserve">
          <source>To disable tieing data while thawing/retrieving remove the flag &lt;code&gt;TIE_OK&lt;/code&gt; = 4 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="translated">해동 / 검색하는 동안 데이터 연결을 비활성화하려면 &lt;code&gt;$Storable::flags&lt;/code&gt; 에서 &lt;code&gt;TIE_OK&lt;/code&gt; = 4 플래그를 제거 하거나 thaw / retrieve의 두 번째 인수를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">버전 확인을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">예를 들어 &lt;code&gt;LWP&lt;/code&gt; 및 &lt;code&gt;Net::FTP&lt;/code&gt; 사용을 허용하지 않으려면 $ File :: Fetch :: BLACKLIST를 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8c3ea5cb60afc12efc66dbc5590a051167db7a27" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt;, you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">예를 들어 &lt;code&gt;LWP&lt;/code&gt; 및 &lt;code&gt;Net::FTP&lt;/code&gt; 사용을 허용하지 않으려면 $ File :: Fetch :: BLACKLIST를 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">참조가 참조하는 유형의 값을 찾으려면 다음 매크로를 사용하여 리턴 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">libnet 구성을 표시하고 변경하려면 libnetcfg 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">결과를 표시하려면</target>
        </trans-unit>
        <trans-unit id="2ac49a31f43cbe10ed9c501335f1421ecc6af0bb" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">올바르게 수행하려면 시간 대신 달력과 함께 작동하므로 &lt;code&gt;Date&lt;/code&gt; 모듈 중 하나를 사용할 수 있습니다 . &lt;a href=&quot;datetime&quot;&gt;날짜 시간&lt;/a&gt; 모듈은 일광 절약 시간 변경에도 불구하고, 간단하게, 당신에게 하루 중 같은 시간 전에 만 일을 제공 :</target>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">올바르게하려면 &lt;code&gt;Date&lt;/code&gt; 대신 달력 대신 사용할 수있는 날짜 모듈 중 하나를 사용할 수 있습니다 . &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;날짜 시간&lt;/a&gt; 모듈은 일광 절약 시간 변경에도 불구하고, 간단하게, 당신에게 하루 중 같은 시간 전에 만 일을 제공 :</target>
        </trans-unit>
        <trans-unit id="9370a32c5a26795ae66ed04fd1bbf4641dcb50f3" translate="yes" xml:space="preserve">
          <source>To do so, PerlIO always calls (de|en)code methods with CHECK set to 1. This ensures that the method stops at the right place when it encounters partial character. The following is what happens when PerlIO and Encode tries to encode (from utf8) more than 1024 bytes and the buffer boundary happens to be in the middle of a character.</source>
          <target state="translated">이를 위해 PerlIO는 항상 CHECK가 1로 설정된 코드 메서드를 호출 (de | en)합니다. 이렇게하면 부분 문자가 발견 될 때 메서드가 올바른 위치에서 중지됩니다. 다음은 PerlIO 및 Encode가 1024 바이트 이상 인코딩 (utf8에서)을 시도하고 버퍼 경계가 문자 중간에있을 때 발생하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="e288609d3f494ae8be47d7fabedf138f3b357269" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">이식 가능한 Perl에서 &lt;code&gt;cp -R&lt;/code&gt; (즉, 전체 디렉토리 트리를 재귀 적으로 복사)에 해당하는 작업을 수행하려면 직접 작성하거나 &lt;a href=&quot;File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt; 와 같은 좋은 CPAN 모듈을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">휴대용 Perl에서 &lt;code&gt;cp -R&lt;/code&gt; 과 동등한 작업을 수행하려면 (즉, 전체 디렉토리 트리를 재귀 적으로 복사), 직접 작성하거나 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt; 와 같은 훌륭한 CPAN 모듈을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">이렇게하려면 텍스트를 파싱하여 프로그램을 만들어야합니다. 그런 다음 일치하는 문자열에서 포인트를 찾으려면 프로그램을 실행해야합니다. 그리고 우리는 모든 일을 효율적으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">이렇게하려면 넥타이에서 반환 된 객체의 사본을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">이렇게하려면 XSUB를 다음과 같이 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">이렇게하려면 redispatch를 다음과 같이 간단하게 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c76098aac2b117e4e74346d50713bf96ac98a839" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;TAP::Formatter&quot;&gt;TAP :: Formatter를&lt;/a&gt; 확장 하거나 직접 작성할 수 있습니다. 포맷터를 작성하는 것은 작성하는 것보다 약간 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="bab21cf4aaf0dd1470c7bbbf3e1fd1618a699e4e" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 확장 하거나 직접 작성할 수 있습니다. 매우 간단한 API이며 &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;에&lt;/a&gt; 대한 &lt;code&gt;sources&lt;/code&gt; 매개 변수를 사용하여로드 및 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter를&lt;/a&gt; 확장 하거나 직접 작성할 수 있습니다. 쓰기 포맷터는 쓰기보다 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 확장 하거나 직접 작성할 수 있습니다. 꽤 간단한 API이며, &lt;code&gt;sources&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; 로로드 및 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">이렇게하려면 입력 스트림에서 각 단어를 구문 분석해야합니다. 우리는 이전 질문에서 주어진 단어의 공백이 아닌 덩어리 아이디어보다는 단어의 알파벳, 하이픈 또는 아포스트로피를 의미한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6deb2232b7d100aa506f8d7a9be0b44c33bb7cba" translate="yes" xml:space="preserve">
          <source>To do this, you need to inform &lt;code&gt;WriteMakeFile()&lt;/code&gt; in your</source>
          <target state="translated">이렇게하려면 &lt;code&gt;WriteMakeFile()&lt;/code&gt; 에 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">제대로 된 것을하려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="da74a36079576adc88b6c00e82f57a05912e49d0" translate="yes" xml:space="preserve">
          <source>To do your own error handling, call this function with the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag to suppress any warnings, and then examine the &lt;code&gt;*errors&lt;/code&gt; return.</source>
          <target state="translated">사용자 고유의 오류 처리를 수행하려면 &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 플래그 와 함께이 함수를 호출 하여 경고를 억제 한 다음 &lt;code&gt;*errors&lt;/code&gt; 리턴 을 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">ASCII 문자로만 작업하고 있음을 강조하기 위해 ASCII 열의 각 매크로에 &lt;code&gt;_A&lt;/code&gt; 를 추가 할 수 있습니다 ( &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="a0a83e62e85a9a106da5ff1e3e3b0371178b7026" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt;, &lt;code&gt;isDIGIT_A&lt;/code&gt;, and so on.</source>
          <target state="translated">ASCII 문자로만 작업하고 있음을 강조하기 위해 ASCII 열의 각 매크로에 &lt;code&gt;_A&lt;/code&gt; 를 추가 할 수 있습니다 ( &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="7d42b2af4b68e58610fc5bf7b2aa1e720d762bd6" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">명령 줄에서 색상을 지정하려면 다음과 같이 &lt;a href=&quot;Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt; 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">명령 행에서 색상을 표시하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt; 모듈을 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c570da316518400b84383905afc3b038138342e" translate="yes" xml:space="preserve">
          <source>To enable multiline matching one should use the &lt;code&gt;/m&lt;/code&gt; regexp modifier (possibly in combination with &lt;code&gt;/s&lt;/code&gt;). This can be set on a per match bases, or can be enabled per lexical scope (including a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;.</source>
          <target state="translated">여러 줄 일치를 활성화하려면 &lt;code&gt;/m&lt;/code&gt; regexp 수정자를 사용해야합니다 ( &lt;code&gt;/s&lt;/code&gt; 와 함께 사용할 수 있음 ). 이는 일치 기준으로 설정하거나 &lt;code&gt;use re '/m'&lt;/code&gt; 을 사용 하여 어휘 범위 (전체 파일 포함)별로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">프로토 타입을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">범위 지정을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="767b2e0f754eeebe201f5f18e618f6b053217aac" translate="yes" xml:space="preserve">
          <source>To enable this seamless support, you should &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;use 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">이 원활한 지원을 활성화하려면 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; ( &lt;code&gt;use 5.012&lt;/code&gt; 이상 을 사용하는 경우 자동으로 선택됨)을 사용해야 합니다. &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 . (5.14는 또한 유니 코드 표준에서 벗어난 여러 가지 버그를 수정합니다.)</target>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">버전 확인을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="a7615d4326dc246eeb4adafc5aa5d8082bb1cd6e" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">문자열을 직접 인코딩하려면 &lt;a href=&quot;URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt; 모듈을 사용하십시오 . &lt;code&gt;uri_escape&lt;/code&gt; 의 기능은 이스케이프 문자열을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">문자열을 직접 인코딩하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt; 모듈을 사용하십시오 . &lt;code&gt;uri_escape&lt;/code&gt; 의 기능은 이스케이프 문자열을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">Pod 블록을 끝내려면 빈 줄을 사용한 다음 &quot;= cut&quot;으로 시작하는 줄과 그 뒤에 빈 줄을 사용하십시오. 이를 통해 Perl (및 포드 포맷터)은 이것이 Perl 코드가 재개되는 위치임을 알 수 있습니다. &quot;= 컷&quot;앞의 빈 줄은 기술적으로 필요하지 않지만 많은 구형 포드 프로세서에는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">그러나이 특별한 경우에 스칼라 컨텍스트를 적용하려면 괄호를 생략하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">Perl 프로그램이 새로 설치된 모듈을 볼 수있게하려면 &lt;code&gt;PERL5LIB&lt;/code&gt; 환경 변수를</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">의 특별한 의미를 피하기 위해 &lt;code&gt;.&lt;/code&gt; , 우리는 &lt;code&gt;\Q&lt;/code&gt; 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="23c0119f090722ce349ecc5009302976b6a64631" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt;:</source>
          <target state="translated">의 특별한 의미를 벗어나려면 &lt;code&gt;.&lt;/code&gt; , 우리는 &lt;code&gt;\Q&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">STDERR을 캡처하기 위해 명령의 STDOUT 및 STDERR을 교환하지만 기존 STDERR을 나오도록 STDOUT을 그대로 두려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">STDERR을 캡처하기 위해 명령의 STDOUT 및 STDERR을 교환하지만 기존 STDERR을 나오도록 STDOUT을 그대로 두려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">다양한 구현을 수행하기 위해 &lt;a href=&quot;#Example-2&quot;&gt;아래&lt;/a&gt; 스크립트 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">각각에 대해 자세히 설명하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">&quot;FATAL&quot;경고를 명시 적으로 끄려면 관련된 경고를 비활성화하면됩니다. 예를 들어 위의 예에서 &quot;void&quot;경고를 비활성화하려면 다음 중 하나를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">쉼표로 구분 된 숫자 목록을 추출하려면</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">BS2000 POSIX에서 ASCII tar 아카이브를 추출하려면 ASCII 파일 시스템이 필요합니다 (우리는 마운트 포인트 / usr / local / ascii를 사용했습니다). 이제 I / O 변환없이 ASCII 파일 시스템에서 아카이브를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="25ec0794844bd37f005928c43a00d6da3d3e457e" translate="yes" xml:space="preserve">
          <source>To find how (UCS-2|UTF-(16|32))(LE|BE)? differ from one another, see &lt;a href=&quot;Encode::Unicode&quot;&gt;Encode::Unicode&lt;/a&gt;.</source>
          <target state="translated">(UCS-2 | UTF- (16 | 32)) (LE | BE) 방법을 찾으려면? 서로 다릅니다 . &lt;a href=&quot;Encode::Unicode&quot;&gt;Encode :: Unicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법을 자세히 알아 보려면 &lt;a href=&quot;../encode&quot;&gt;인코딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ee7c07a6985c2bc43ddeeba4f6a14f8a3da6596" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;encode&quot;&gt;Encode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">알아 내다</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법을 자세히 알아 보려면 &lt;a href=&quot;../encode&quot;&gt;인코딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2adbea2c685a6abde137a3a64635b621e1971a84" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법을 자세히 알아 보려면 &lt;a href=&quot;encode&quot;&gt;Encode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f73fb3d1fc5746c2536b396c0845c316c4d80215" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">이 패키지에서 지원하는 인코딩을 자세히 알아 보려면 &lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">이 패키지에서 지원되는 인코딩을 자세히 확인하려면 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">모듈의 소스 코드가있는 곳을 찾으려면</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">주어진 문자열이 0이 아닌 유효한 숫자인지 확인하려면 숫자 0과 어휘 &quot;0&quot;에 대해 테스트하는 것으로 충분합니다 (경고가 켜져 있으면 소음이 발생하지만). 숫자가 아닌 문자열은 &lt;b&gt;awk&lt;/b&gt; 에서와 같이 0으로 계산되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">Perl이 지원하는 문자 인코딩을 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e6f34bd3a736ed4112e8f178b09aac2a9e39ab4" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">두 개의 단일 문자 사이에서 무언가를 찾기 위해 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 와 같은 패턴 은 $ 1의 중간 비트를 가져옵니다. 여러 항목의 경우 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 와 같은 것이 필요합니다. 중첩 된 패턴 및 / 또는 균형 잡힌 식에 대해서는 &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;(? PARNO)&lt;/a&gt; 구조 (perl 5.10부터 사용 가능 )를 참조하십시오 . CPAN 모듈 &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 은 이러한 정규식을 작성하는 데 도움이 될 수 있습니다 (특히 &lt;a href=&quot;Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt; 및 &lt;a href=&quot;Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">두 개의 단일 문자 사이에서 무언가를 찾으려면 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 와 같은 패턴 은 $ 1의 중간 비트를 가져옵니다. 여러 개의 경우에는 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 와 같은 것이 필요합니다. 중첩 된 패턴 및 / 또는 균형 잡힌 표현에 대해서는 소위 &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; 구문 (perl 5.10부터 사용 가능 )을 참조하십시오 . CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 은 이러한 정규 표현식을 작성하는 데 도움이 될 수 있습니다 (특히 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="462c225b3ec5f7ec0eb1907b83b31298442e3ef8" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">조건을 만족하는 첫 번째 배열 요소를 찾으려면 Perl 5.8과 함께 제공되는 &lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt; 모듈 에서 &lt;code&gt;first()&lt;/code&gt; 함수를 사용할 수 있습니다 . 이 예제는 &quot;Perl&quot;을 포함하는 첫 번째 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">조건을 만족하는 첫 번째 배열 요소를 찾으려면 Perl 5.8과 함께 제공되는 &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; 모듈 에서 &lt;code&gt;first()&lt;/code&gt; 함수를 사용할 수 있습니다 . 이 예에서는 &quot;Perl&quot;이 포함 된 첫 번째 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">현재있는 패키지를 찾으려면 &lt;a href=&quot;perldata&quot;&gt;perldata에&lt;/a&gt; 설명 된대로 특수 리터럴 &lt;code&gt;__PACKAGE__&lt;/code&gt; 를 사용하십시오 . 특수 리터럴 만 별도의 토큰으로 사용할 수 있으므로 변수를 사용하는 것처럼 문자열로 보간 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f89e6a14f2ee6c8a6aa9c17296db02bef0f9a5ee" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt;, as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">현재있는 패키지를 찾으려면 &lt;a href=&quot;perldata&quot;&gt;perldata에&lt;/a&gt; 문서화 된 특수 리터럴 &lt;code&gt;__PACKAGE__&lt;/code&gt; 를 사용하십시오 . 특수 리터럴은 별도의 토큰으로 만 사용할 수 있으므로 변수로 할 수있는 것처럼 문자열로 보간 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">같은 단일 형태의 동의어 찾으려면 &lt;code&gt;\p{Any}&lt;/code&gt; 를 사용 &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()&lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="eb89d412def16cc37609c904cc14b810aa0fb5df" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt;, use &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt; instead.</source>
          <target state="translated">같은 단일 형태의 동의어 찾으려면 &lt;code&gt;\p{Any}&lt;/code&gt; 사용 &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases ()&quot;&lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">현지 Perl Mongers (또는 일반적으로 약어 인 PM) 그룹을 찾으려면 국제 Perl Mongers 디렉토리 ( &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt; )를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">디버거를 시작하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">그대로 적용하여 수정하십시오. 해커 영역에서, 버그를 수정하거나 이전 버전을 업그레이드 할 때 &lt;b&gt;패치&lt;/b&gt; (1) 프로그램 에 의해 적용될 수있는 두 버전의 프로그램 간의 차이점 목록 .</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">이 문제를 해결하기 위해 일부 사람들은 Unicode, Inc.를 구성하고 생각할 수있는 모든 문자 등을 포함하는 새로운 문자 집합을 만들었습니다. 이러한 문자를 나타내는 여러 가지 방법이 있으며 Perl에서 사용하는 방법을 UTF-8이라고합니다. UTF-8은 가변 바이트 수를 사용하여 문자를 나타냅니다. &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 에서 유니 코드 및 Perl의 유니 코드 모델에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">ASCII / 비 ASCII 일치 ( &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; &quot;k&quot;)를 금지하려면 &quot;a&quot;를 두 번 지정하십시오 (예 : &lt;code&gt;/aai&lt;/code&gt; 또는 &lt;code&gt;/aia&lt;/code&gt; ) . ( &quot;a&quot;의 첫 번째 발생은 &lt;code&gt;\d&lt;/code&gt; 등을 제한하고 두 번째 발생은 &lt;code&gt;/i&lt;/code&gt; 제한을 추가합니다 .) 그러나 ASCII 범위 밖의 코드 포인트는 &lt;code&gt;/i&lt;/code&gt; 일치에 유니 코드 규칙을 사용 하므로 수정자는 실제로 사물을 ASCII로 제한하지는 않습니다. ASCII와 비 ASCII의 혼합을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="7747b215397466c348d54e9b8de2e0e6dbbf3fa6" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt;), specify the &lt;code&gt;&quot;a&quot;&lt;/code&gt; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt;. (The first occurrence of &lt;code&gt;&quot;a&quot;&lt;/code&gt; restricts the &lt;code&gt;\d&lt;/code&gt;,</source>
          <target state="translated">ASCII / 비 ASCII 일치를 금지하려면 (예 : &quot;k&quot;와 &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ) &lt;code&gt;&quot;a&quot;&lt;/code&gt; 를 두 번 지정하십시오 ( 예 : &lt;code&gt;/aai&lt;/code&gt; 또는 &lt;code&gt;/aia&lt;/code&gt; ) . ( &lt;code&gt;&quot;a&quot;&lt;/code&gt; 의 첫 번째 항목은 &lt;code&gt;\d&lt;/code&gt; 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="ce87ca60a35ae769cbfeb60038a35828e8b052b1" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; to uncompress all the bzip2 data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="translated">&lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 가 모든 bzip2 데이터 스트림의 압축을 풀 도록 강제하려면 아래와 같이 &lt;code&gt;MultiStream&lt;/code&gt; 옵션을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d738795a19cd0b9eeeb60570db56c2f44fad5488" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; to uncompress all the gzip data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="translated">&lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 을 강제로 모든 gzip 데이터 스트림의 압축을 풀 려면 아래와 같이 &lt;code&gt;MultiStream&lt;/code&gt; 옵션을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">서브 루틴 호출로 해석하려면 서브 루틴 이름 앞에 앰퍼샌드를 넣거나 패키지로 이름을 한정하십시오. 또는 서브 루틴을 가져올 수도 있고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 가져온 것처럼 가장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2cf84ed24d58ace958b85882dc11163745c65be" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;use subs&lt;/code&gt; pragma).</source>
          <target state="translated">서브 루틴 호출로 해석을 강제하려면 서브 루틴 이름 앞에 앰퍼샌드를 넣거나 패키지로 이름을 한정하십시오. 또는 서브 루틴을 임포트 할 수 있습니다 (또는 &lt;code&gt;use subs&lt;/code&gt; pragma를 사용 하여 임포트 한 척 ).</target>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">여러 데이터 값을 SV에 적용하려면 두 가지 작업을 수행해야합니다. &lt;code&gt;sv_set*v&lt;/code&gt; 루틴을 사용하여 추가 스칼라 유형을 추가 한 다음 Perl이 둘 이상의 데이터 유형을 포함하도록 믿도록 플래그를 설정하십시오. 플래그를 설정하는 네 가지 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b603c7813804b39f069cc444400779dd5f80774c" translate="yes" xml:space="preserve">
          <source>To force unicode semantics in code portable to perl 5.8 and 5.10, call &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; unconditionally.</source>
          <target state="translated">perl 5.8 및 5.10으로 이식 가능한 코드의 유니 코드 의미 체계를 강제하려면 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 무조건 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">생성 한 SV를 해제하려면 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 호출 하십시오 . 일반적으로이 호출은 필요하지 않습니다 ( &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;참조 횟수 및 사망률 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3e7390df1746c54f2c60ceb3e38eab54ee218d5" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt;. Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;).</source>
          <target state="translated">생성 한 SV를 해제하려면 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 호출 하십시오 . 일반적으로이 호출은 필요하지 않습니다 ( &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;참조 횟수 및 사망률&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">다른 모듈에서 내 보낸 심볼에 액세스합니다. Camel 27 장 &quot;기능&quot;에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff21df3d4f7e1323bcb14d219834d5b523bb12a8" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;use&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">다른 모듈에서 내 보낸 기호에 액세스하기 위해. Camel 27 장, &quot;기능&quot;의 &lt;code&gt;use&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f02cb11f0716e30aa4d5cf8185ab8c7897bdf67" translate="yes" xml:space="preserve">
          <source>To generate accessors you list them when using the module:</source>
          <target state="translated">접근자를 생성하려면 모듈을 사용할 때 나열합니다.</target>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">스텁 만 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">Math :: BigFloat를 얻으려면 연산을 수동으로 호출하거나 피연산자가 이미 올바른 유형이거나 Math :: BigFloat-&amp;gt; new ()를 통해 해당 유형으로 캐스트되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">이진 스트림을 얻으려면 다른 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">사용 가능한 동기화 지점의 전체 목록을 얻으려면</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">두 값 사이의 난수를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 내장을 사용하여 0과 1 사이의 난수를 얻을 수 있습니다. 거기에서 원하는 범위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="07bedc590c0c2707d4838577cb4e73d5ee21573c" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;rand()&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">두 값 사이의 난수를 얻으려면 내장 &lt;code&gt;rand()&lt;/code&gt; 사용하여 0과 1 사이의 난수를 얻을 수 있습니다. 거기에서 원하는 범위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">현장에서 실제 또는 캐럿을 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">오류 로그에서 모든 출력을 얻고 유용한 운영 체제 버퍼링을 통해 메시지를 놓치지 않으려면 스크립트 시작시 다음과 같은 행을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">얻을 &lt;code&gt;HMQ&lt;/code&gt; 를 상기 확장 불러야 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 이 호출이 수행 된 후, C.에서 &lt;code&gt;hmq&lt;/code&gt; 은 으로 액세스 될 수있다 &lt;code&gt;Perl_hmq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eacbf75f11af85a991f44461b926b7c934f62f4" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt;, the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt;.</source>
          <target state="translated">얻을 &lt;code&gt;HMQ&lt;/code&gt; 를 상기 확장 불러야 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 이 호출이 수행 된 후, C.에서 &lt;code&gt;hmq&lt;/code&gt; 은 으로 액세스 될 수있다 &lt;code&gt;Perl_hmq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">버퍼링되지 않은 스트림을 얻으 려면 공개 호출에서 버퍼되지 않은 레이어 (예 &lt;code&gt;:unix&lt;/code&gt; )를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e43bb9c5d530c176cdc88e98a6d34bb2bcea788a" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt;) in the open call:</source>
          <target state="translated">버퍼링되지 않은 스트림을 얻으 려면 오픈 호출에서 버퍼링되지 않은 레이어 (예 &lt;code&gt;:unix&lt;/code&gt; )를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">오류를 해결하려면 다음과 같이 &lt;code&gt;DB_File&lt;/code&gt; 이라는 단어를 작은 따옴표 나 큰 따옴표로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">보안 문제를 해결하기 위해 변수 이름을 평가하는 대신 해시에서 값을 가져올 수도 있습니다. 단일 &lt;code&gt;/e&lt;/code&gt; 를 사용 하여 해시를 검사하여 값이 존재하는지 확인하고 존재하지 않는 경우 누락 된 값을 마커로 바꿀 수 있습니다.이 경우 &lt;code&gt;???&lt;/code&gt; 내가 뭔가를 놓쳤다는 것을 알리기 위해 :</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">이러한 문제를 해결하려면 SV의 전체 사본을 가져와야합니다. 아래 코드는 &lt;code&gt;SaveSub2&lt;/code&gt; 가 수정 되었음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f3981d8032c1c97862aa0ee6d17a5d52da82d00a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;File::Glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">이 문제를 해결하려면 Perl v5.6.0 이상으로 업그레이드하거나 readdir () 및 패턴으로 직접 glob을 수행하거나 globbing을 수행하기 위해 쉘을 사용하지 않는 &lt;a href=&quot;File::Glob&quot;&gt;File :: Glob&lt;/a&gt; 과 같은 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">이 문제를 해결하려면 Perl v5.6.0 이상으로 업그레이드하거나 readdir () 및 패턴을 사용하여 &lt;a href=&quot;file/glob&quot;&gt;글로브를 수행&lt;/a&gt; 하거나 File :: Glob 과 같은 모듈을 사용하여 글로브를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">이 문제를 해결하려면 출력 파일 핸들 (이 경우 &lt;code&gt;STDOUT&lt;/code&gt; ) 을 버퍼링 해제해야합니다 . 특수 변수 &lt;code&gt;$|&lt;/code&gt; 설정할 수 있습니다 진정한 가치 (니모닉 : 파일 핸들을 &quot;파이핑 핫&quot;으로 만들기) :</target>
        </trans-unit>
        <trans-unit id="5f530554d003756c8f58481299f2771b8fc63a8d" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt;. You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">이 문제를 해결하려면 출력 파일 핸들 (이 경우 &lt;code&gt;STDOUT&lt;/code&gt; )의 버퍼링을 해제해야합니다 . 특수 변수 &lt;code&gt;$|&lt;/code&gt; 설정할 수 있습니다. 진정한 값으로 (니모닉 : 파일 핸들을 &quot;파이핑 핫&quot;으로 만들기) :</target>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">해시 요소를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">HP-UX 전체의 최신 펄 저장소를 얻으려면 H.Merijn 브랜드 사이트 ( &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl)를&lt;/a&gt; 방문 하십시오 . 사용 가능한 버전이 사용자의 요구에 맞는지 확인하기 위해 메모를주의해서 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">더 나은 테스트 보고서를 얻으려면 전화</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 에서 색인 항목을 얻으려면 다음과 같이 F 레지스터를 켜십시오.</target>
        </trans-unit>
        <trans-unit id="4794a765fde524229c427466a3a2da3c2272b297" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt;, turn on the F register, as in:</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 에서 인덱스 항목을 얻으려면 다음과 같이 F 레지스터를 켭니다.</target>
        </trans-unit>
        <trans-unit id="c89e5c359123efe3e2b8df35515e166a3190f60d" translate="yes" xml:space="preserve">
          <source>To get more perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">HP-UX의 전체 범위에 대한 더 많은 perl 저장소를 얻으려면 H.Merijn Brand 사이트 ( &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl)를&lt;/a&gt; 방문 하십시오 . 참고 사항을주의 깊게 읽고 사용 가능한 버전이 필요에 맞는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">배열에서 여러 값을 가져 오려면</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">플랫폼 독립적 인 제어를 얻으려면 &lt;code&gt;\N{...}&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b8ad9382504b98c42922faf4d1b352db68cbdde" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt;.</source>
          <target state="translated">플랫폼 독립적 인 컨트롤을 얻으려면 &lt;code&gt;\N{...}&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">흥미로운 통계를 얻으려면 &lt;code&gt;randomize_urllist&lt;/code&gt; 를 설정 하는 것이 좋습니다 . 이것은 URL 선택에 어느 정도의 무작위성을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">다소 비슷하지만 로케일에 따른 날짜 문자열을 얻으려면 로케일 환경 변수를 적절하게 설정하고 ( &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) 다음과 같이 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">다소 비슷하지만 로케일에 따른 날짜 문자열을 얻으려면 로케일 환경 변수를 적절하게 설정하고 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) 다음과 같이 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">두 시그마를 포함하여 25 개의 전통적인 소문자 그리스 문자를 얻으려면 대신 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">HAB를 얻으려면 확장은 C에서 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 을 호출해야합니다 .이 호출이 수행 된 후 &lt;code&gt;hab&lt;/code&gt; 는 &lt;code&gt;Perl_hab&lt;/code&gt; 로 액세스 될 수 있습니다 . HAB를 사용한 후에는 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4090f094b0b5e7e1c333253056aa1e10c2b3006" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt;. There is no need to release the HAB after it is used.</source>
          <target state="translated">HAB를 얻으려면 확장은 C에서 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 을 호출해야합니다 .이 호출이 수행 된 후 &lt;code&gt;hab&lt;/code&gt; 에 &lt;code&gt;Perl_hab&lt;/code&gt; 로 액세스 할 수 있습니다 . 사용 후 HAB를 해제 할 필요가 없습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">IP 주소를 얻기 위해 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; 내장 기능을 사용하여 이름을 숫자로 바꿀 수 있습니다. 이 숫자를 대부분의 사람들이 기대하는 점으로 구분 된 8 진수 형식 (abcd)으로 바꾸려면 &lt;a href=&quot;socket&quot;&gt;소켓&lt;/a&gt; 모듈 의 &lt;code&gt;inet_ntoa&lt;/code&gt; 함수를 사용하십시오 ( perl과 함께 제공됨).</target>
        </trans-unit>
        <trans-unit id="6f5ae18e2f134e19fbd9a1950117e9b15bbc93df" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;gethostbyname&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">IP 주소를 얻으려면 &lt;code&gt;gethostbyname&lt;/code&gt; 내장 함수를 사용하여 이름을 숫자로 바꿀 수 있습니다. 이 숫자를 대부분의 사람들이 기대하는 점으로 구분 된 옥텟 형식 (abcd)으로 바꾸려면 펄과 함께 제공되는 &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; 모듈 의 &lt;code&gt;inet_ntoa&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a2fdb082ba52bcf7b3e152cd572fe7df01166a8" translate="yes" xml:space="preserve">
          <source>To get the actual events you need to get them from the parent event directly</source>
          <target state="translated">실제 이벤트를 얻으려면 부모 이벤트에서 직접 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">날짜에 상관없이 날짜 를 얻으려면 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 의 &lt;code&gt;mktime&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 인수에 대한 시간을 초 단위로 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="75db1fc5bb4504ae3cfd425396fb9b0ab5948972" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">날짜에 대한 일을 얻으려면 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 의 &lt;code&gt;mktime&lt;/code&gt; 을 사용 하여 &lt;code&gt;localtime&lt;/code&gt; 인수에 대한 시간을 epoch 초 단위로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">연도의 마지막 두 자리 (예 : 2001 년 &quot;01&quot;)를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="65e2eefe742ea63873b699fb966b09a893a8daaa" translate="yes" xml:space="preserve">
          <source>To get the most performance benefit I want to have the test scripts that take the longest to run start first - otherwise I'll be waiting for the one test that takes nearly a minute to complete after all the others are done. I can use the --state switch to run the tests in slowest to fastest order:</source>
          <target state="translated">성능상의 이점을 극대화하려면 실행하는 데 가장 오래 걸리는 테스트 스크립트를 먼저 시작하고 싶습니다. 그렇지 않으면 다른 모든 작업이 완료된 후 거의 1 분 정도 걸리는 하나의 테스트를 기다릴 것입니다. --state 스위치를 사용하여 가장 느린 순서에서 가장 빠른 순서로 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">스크립트가 제대로 작동하고 경고를 끄려면 연결된 개체에 대한 유효한 참조가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">특정 패키지에 대한 숨김 포인터를 얻으려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2990698bc29bbd13b737294b202675b151d03401" translate="yes" xml:space="preserve">
          <source>To get the version number from a Perl module, consumers should use the &lt;code&gt;MM-&amp;gt;parse_version($file)&lt;/code&gt; method provided by &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Metadata&quot;&gt;Module::Metadata&lt;/a&gt;. For example, for the module given by &lt;code&gt;$mod&lt;/code&gt;, the version may be retrieved in one of the following ways:</source>
          <target state="translated">Perl 모듈에서 버전 번호를 얻으려면 소비자는 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 또는 &lt;a href=&quot;Module::Metadata&quot;&gt;Module :: Metadata에서&lt;/a&gt; 제공 하는 &lt;code&gt;MM-&amp;gt;parse_version($file)&lt;/code&gt; 메서드를 사용해야합니다 . 예를 들어, &lt;code&gt;$mod&lt;/code&gt; 에서 제공하는 모듈 의 경우 다음 방법 중 하나로 버전을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">GBARR / Scalar-List-Utils-1.18.tar.gz는 고대 perls와 호환되며 File :: Temp는 전제 조건으로 나열되어 있지만 CPAN이없는 경우 합리적인 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">valgrind를 구하고 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">모든 키를 살펴 보려면 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 기능을 사용하십시오 . 그러면 해시의 모든 키가 추출되어 목록으로 다시 나타납니다. 그런 다음 처리중인 특정 키를 통해 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb8b0be0f6dbf55ac7483ea415db4f8150fbafd" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;keys&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">모든 키를 통과하려면 &lt;code&gt;keys&lt;/code&gt; 기능을 사용하십시오 . 이렇게하면 해시의 모든 키가 추출되어 목록으로 다시 제공됩니다. 그런 다음 처리중인 특정 키를 통해 값을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">Perl 내장을 해킹하려면 다음 사항을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf182f7a67e6a5ec57b171f14e7d3fa5c6ddc216" translate="yes" xml:space="preserve">
          <source>To handle this situation, Perl uses</source>
          <target state="translated">이 상황을 처리하기 위해 Perl은</target>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">이 상황을 처리하기 위해 PPCODE 지시문이 사용되며 매크로를 사용하여 스택이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">모든 것을 홈 디렉토리에 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">&lt;code&gt;File::GlobMapper&lt;/code&gt; 가 수행 하는 작업을 설명하기 위해 현재 디렉토리에서 &lt;code&gt;.tar.gz&lt;/code&gt; 로 끝나는 모든 파일의 이름 을 &lt;code&gt;.tgz&lt;/code&gt; 로 바꾸려면 어떤 코드를 작성해야하는지 고려하십시오 . 이 파일이 현재 디렉토리에 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">Perl 소스 필터를 작성하는 방법을 이해하려면 연구 할 예제가 필요합니다. 다음은 rot13 디코딩을 수행하는 완전한 소스 필터입니다. (Rot13은 유즈넷 게시물에서 불쾌한 게시물의 내용을 숨기기 위해 사용되는 매우 간단한 암호화 체계입니다. 모든 문자를 13 자리 앞으로 이동하여 A가 N, B가 O, Z가 M이되도록합니다.)</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">이것이 왜 실제 문제가 될 수 있는지 이해하려면 먼저 모든 C 환경에서 콜백을 설정하는 방법을 고려하십시오. 일반적으로 C API는 콜백을 등록하는 기능을 제공합니다. 이것은 매개 변수 중 하나로 함수에 대한 포인터를 기대합니다. 다음은 치명적 오류가 발생할 때 호출되도록 C 함수를 등록 하는 가상 함수 &lt;code&gt;register_fatal&lt;/code&gt; 에 대한 호출입니다.</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">레거시 프로그램을보다 현대적인 Perl 로 변환 할 수 있도록 &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; 유틸리티를 사용하면 구식 Perl 4 라이브러리를 새로운 스타일의 Perl5 모듈로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">정의되지 않은 것을 파악할 수 있도록 perl은 정의되지 않은 변수의 이름 (있는 경우)을 알려줍니다. 어떤 경우에는이를 수행 할 수 없으므로 정의되지 않은 값을 사용한 조작도 알려줍니다. 그러나 perl이 프로그램을 최적화하고 경고에 표시된 조작이 문자 그대로 프로그램에 표시되지 않을 수도 있습니다. 예를 들어, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 는 일반적으로 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; 으로 최적화됩니다 . $ foo 이며 경고 가없는 경우에도 &lt;code&gt;concatenation (.)&lt;/code&gt; 연산자를 나타 &lt;code&gt;.&lt;/code&gt; 당신의 프로그램에서.</target>
        </trans-unit>
        <trans-unit id="a5f43865bbac7f1f33a9c88f0ac1c82c9566920f" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt;, and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">정의되지 않은 것이 무엇인지 알아 내기 위해 perl은 정의되지 않은 변수 (있는 경우)의 이름을 알려줍니다. 어떤 경우에는이를 수행 할 수 없으므로 정의되지 않은 값을 사용한 작업도 알려줍니다. 그러나 perl은 프로그램을 최적화하고 경고에 표시된 작업이 반드시 프로그램에 문자 그대로 나타나지는 않을 수 있습니다. 예를 들어, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 는 일반적으로 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; 로 최적화됩니다 . $ foo 이고 경고는 &lt;code&gt;concatenation (.)&lt;/code&gt; 연산자를 참조합니다 &lt;code&gt;.&lt;/code&gt; 프로그램에서.</target>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">후드 아래의 거친 가장자리를 숨기려면 &lt;code&gt;symbolic&lt;/code&gt; 패키지에 tie () d 인터페이스를 제공하십시오 . 메소드 추가</target>
        </trans-unit>
        <trans-unit id="58c28f318aa4f864e9846446b68afedbfe1de577" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt;. Add methods</source>
          <target state="translated">후드 아래의 거친 가장자리를 숨기려면 패키지 &lt;code&gt;symbolic&lt;/code&gt; 에 tie () d 인터페이스를 제공하십시오 . 방법 추가</target>
        </trans-unit>
        <trans-unit id="4b357009cc7277d51ef692d8123b4f3841c85837" translate="yes" xml:space="preserve">
          <source>To illustrate how to use &lt;code&gt;InputLength&lt;/code&gt; here is a script that walks a zip file and prints out how many lines are in each compressed file (if you intend write code to walking through a zip file for real see &lt;a href=&quot;IO::Uncompress::Unzip#Walking-through-a-zip-file&quot;&gt;&quot;Walking through a zip file&quot; in IO::Uncompress::Unzip&lt;/a&gt; ). Also, although this example uses the zlib-based compression, the technique can be used by the other &lt;code&gt;IO::Uncompress::*&lt;/code&gt; modules.</source>
          <target state="translated">&lt;code&gt;InputLength&lt;/code&gt; 를 사용하는 방법을 설명하기 위해 여기에 zip 파일을 살펴보고 각 압축 파일에있는 줄 수를 인쇄하는 스크립트가 있습니다 (실제로 zip 파일을 살펴 보는 코드를 작성하려는 경우 &lt;a href=&quot;IO::Uncompress::Unzip#Walking-through-a-zip-file&quot;&gt;IO의 &quot;ZIP 파일&lt;/a&gt; 살펴보기 &quot; 참조). :: Uncompress :: Unzip ). 또한이 예제에서는 zlib 기반 압축을 사용하지만이 기술은 다른 &lt;code&gt;IO::Uncompress::*&lt;/code&gt; 모듈에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">이러한 변수 간의 차이점을 설명하려면 작은 따옴표로 묶인 문자열을 사용하는 다음 Perl 표현식을 고려하십시오. 이 명령문을 실행 한 후 perl은 네 가지 특수 오류 변수를 모두 설정했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">이 기능을 설명하기 위해 문자열에 회문이 포함 된 경우 일치하는 패턴을 디자인합니다. (이것은 공백, 문장 부호 및 대소 문자를 무시하면서 앞뒤로 같은 단어를 읽는 단어 또는 문장입니다. 우리는 빈 문자열이나 단어 문자가 하나만 포함 된 문자열이 회문임을 관찰하여 시작합니다. 그렇지 않으면 단어 문자는 앞면과 끝에서 동일하며 다른 회문이 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">비트 문자열의 압축 풀기를 설명하기 위해 간단한 상태 레지스터를 분해합니다 ( &quot;-&quot;는 &quot;예약 된&quot;비트를 나타냄).</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">설명하기 위해</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">복사 생성자를 구현하려면 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 를 추가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 라인과 코드를 사용하십시오 (이 코드는 뮤 테이터가 한 단계 깊게 만 변경하므로 재귀 복사는 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="1ef1c60a444763ee513ae1faa2574b43d63f6e12" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;use overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">복사 생성자를 구현하려면 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 를 추가 &lt;code&gt;use overload&lt;/code&gt; 라인과 코드 를 사용 합니다 (이 코드는 뮤 테이터가 한 수준 만 변경한다고 가정하므로 재귀 복사가 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">대부분의 산술 연산을 구현하는 것은 쉽습니다. 작업 테이블을 사용하고 % subr을 채우는 코드를</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">서브 루틴을 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">무언가의 가치를 1 씩 증가 시키십시오 (또는 지정된 경우 다른 수만큼).</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">모듈보다는 명령 줄 도구를 사용함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">파일에 이미 한 줄을 추가하려면 &lt;code&gt;-n&lt;/code&gt; 스위치를 사용하십시오 . 루프가 끝날 때 &lt;code&gt;$_&lt;/code&gt; 를 인쇄하지 않는다는 점을 제외하고는 &lt;code&gt;-p&lt;/code&gt; 와 같습니다 . 따라서 직접해야합니다. 이 경우 &lt;code&gt;$_&lt;/code&gt; 먼저 인쇄 한 다음 추가 할 줄을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">NetWare Perl을 NetWare 서버에 설치하려면 먼저 NetWare 서버의 Sys 볼륨을</target>
        </trans-unit>
        <trans-unit id="ee9638bdc9d8a0c759ba97d86bfdc7724a758ac8" translate="yes" xml:space="preserve">
          <source>To install a callback I pass the name of the callback and a subroutine reference to TAP::Harness or TAP::Parser's callback method:</source>
          <target state="translated">콜백을 설치하려면 콜백 이름과 TAP :: Harness 또는 TAP :: Parser의 콜백 메서드에 대한 서브 루틴 참조를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e3c3d18a60e95dd185226e349523858601f99df9" translate="yes" xml:space="preserve">
          <source>To install the Perl headers and the class CPerlBase documentation so that you no more need the Perl sources around to compile Perl applications using the SDK:</source>
          <target state="translated">SDK를 사용하여 Perl 애플리케이션을 컴파일하기 위해 Perl 소스가 더 이상 필요하지 않도록 Perl 헤더 및 클래스 CPerlBase 문서를 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">배열의 인덱스를 반복하려면 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; 값을 반복 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="bb6bf360110a80a4c3eb61df0aff99d211da1c11" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;foreach my $i (0 .. $#array) {}&lt;/code&gt;. &lt;code&gt;foreach my $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">배열의 인덱스를 반복하려면 &lt;code&gt;foreach my $i (0 .. $#array) {}&lt;/code&gt; . &lt;code&gt;foreach my $v (@array) {}&lt;/code&gt; 는 값을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 관련 공지 사항에 대한 메일 링리스트에 참여하려면 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 빈 메시지를 보내 십시오 . 이 메일 링리스트는 공지 사항만을위한 것이며, 트래픽이 매우 적습니다 (연간 두 메시지 미만).</target>
        </trans-unit>
        <trans-unit id="45a6289801496005295f094536fc8ecc4c1c8e83" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;. This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 관련 공지 메일 링리스트에 가입하려면 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 빈 메시지를 보내 십시오 . 이 메일 링리스트는 공지 용으로 만 사용되며 트래픽이 매우 적습니다 (연간 2 개 미만의 메시지).</target>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 에 대한 공지를 위해 트래픽이 매우 적은 메일 링리스트에 참여하려면 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 빈 메모를 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="ed725c5a7b13b5f14db9ddb8b3bae580a82d496b" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 에 대한 공지 사항에 대한 트래픽이 매우 적은 메일 링리스트에 가입하려면 빈 메모를 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="23905cfc18d99e713280156ef1eb62fd65833ce9" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memEQ()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memNE()&lt;/code&gt;&lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">같음 / &lt;a href=&quot;perlapi#memEQ&quot;&gt; &lt;code&gt;memEQ()&lt;/code&gt; &lt;/a&gt; 않음에 대해 두 문자열을 비교하려면 일반적인 경우와 같이 memEQ () 및 &lt;a href=&quot;perlapi#memEQ&quot;&gt; &lt;code&gt;memNE()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다. 단 , 문자열은 UTF-8로 인코딩되거나 UTF-8로 인코딩되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">동일성 / 비 균등성을 위해 두 문자열을 비교하려면 문자열이 UTF-8이거나 UTF-8로 인코딩되지 않아야한다는 점을 제외하고 평소 와 &lt;a href=&quot;perlapi#memEQ&quot;&gt;같이 &lt;/a&gt;&lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ ()&lt;/a&gt; 및 memNE () 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">우리의 네임 스페이스 좋은 오염되지 않은, 편집가 .pm 파일을 유지하고 변수를 변경하려면 &lt;code&gt;@EXPORT&lt;/code&gt; 에 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 을 . 마지막으로 .xs 파일에서 #include 행을 편집하여 다음을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="66c523aae45e20a099aa6d752ca36a4c5fad3933" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">우리의 네임 스페이스 좋은 오염되지 않은, 편집가 .pm 파일을 유지하고 변수를 변경하려면 &lt;code&gt;@EXPORT&lt;/code&gt; 에 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 을 . 마지막으로 .xs 파일에서 #include 행을 편집하여 다음과 같이 읽습니다.</target>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 다운로드 한 모듈을 설치하는 방법을 배우려면 &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall을&lt;/a&gt; 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">특정 모듈을 사용하는 방법을 배우려면 &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 사용 &lt;i&gt;하십시오&lt;/i&gt; . 일반적으로 &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 을 사용&lt;i&gt;&lt;/i&gt; 하면 내 보낸 함수 또는 모듈에 대한 OO 인터페이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">자세히 알아 보려면 &lt;b&gt;-\&lt;/b&gt; 와 같은 가짜 옵션을 입력하십시오 &lt;b&gt;. &lt;/b&gt;긴 사용 메시지가 제공됩니다. 많은 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7513ca0f7dee98a8be8a3dca79c36e371b5b2223" translate="yes" xml:space="preserve">
          <source>To limit the allowed bracked notation methods to a specific list, use the whitelist() method:</source>
          <target state="translated">허용되는 bracked 표기법 메서드를 특정 목록으로 제한하려면 whitelist () 메서드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">숫자의 소수점 이하 자릿수를 제한하기 위해 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 . 자세한 내용 &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;은 perlop의 부동 소수점 산술&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0835636a7544b690a78e5a06870d277ecb58681d" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;&quot;Floating-point Arithmetic&quot; in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">숫자의 소수 자릿수를 제한하려면 &lt;code&gt;printf&lt;/code&gt; 또는 &lt;code&gt;sprintf&lt;/code&gt; 함수를 사용할 수 있습니다 . 자세한 내용 &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;은 perlop의 &quot;부동 소수점 산술&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">&lt;code&gt;TAP::Harness&lt;/code&gt; 플러그인 을로드하려면 일반적으로 &lt;code&gt;Build.PL&lt;/code&gt; 에서 &lt;code&gt;tap_harness_args&lt;/code&gt; 매개 변수를 &lt;code&gt;new&lt;/code&gt; 로 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="189a273951294ca8e561bbd38119a481f3bcdeb3" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, typically from your &lt;code&gt;Build.PL&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;TAP::Harness&lt;/code&gt; 플러그인 을로드하려면 일반적으로 &lt;code&gt;Build.PL&lt;/code&gt; 에서 &lt;code&gt;new&lt;/code&gt; 에 &lt;code&gt;tap_harness_args&lt;/code&gt; 매개 변수를 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">요청시로드 (&amp;ldquo;게으른&amp;rdquo;로딩이라고도 함) 구체적 으로 정의되지 않은 서브 루틴 대신 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="793c105080b4d15bf59a358db204c3e7d2658f2d" translate="yes" xml:space="preserve">
          <source>To load packages while adding them to &lt;code&gt;@ISA&lt;/code&gt;, see the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma. The discouraged &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma does this as well, but should not be used except when compatibility with the discouraged &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma is required.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 에 패키지를 추가하는 동안 패키지를로드하려면 &lt;a href=&quot;parent&quot;&gt;상위&lt;/a&gt; pragma를 참조하십시오 . 권장 되지 않는 &lt;a href=&quot;base&quot;&gt;기본&lt;/a&gt; pragma도이 작업을 수행하지만 권장 되지 않는 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; pragma 와의 호환성 이 필요한 경우를 제외하고는 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">이 모듈의 버전 1.x와의 호환성을 유지하기 위해 &lt;code&gt;gzreadline&lt;/code&gt; 은 &lt;code&gt;$/&lt;/code&gt; 변수를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; 작동 시키려면 실제 뮤 테이터를 직접 또는 &lt;code&gt;nomethod&lt;/code&gt; 로 구현해야합니다 . 우리는 &lt;code&gt;nomethod&lt;/code&gt; 내부에서 일을 계속하고 있으므로</target>
        </trans-unit>
        <trans-unit id="6a057782113c7191c271c05bf3e4a07cba925f05" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt;. We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt;, thus add</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 작동 하도록하려면 직접 또는 &lt;code&gt;nomethod&lt;/code&gt; 에서 실제 뮤 테이터를 구현해야합니다 . 우리는 &lt;code&gt;nomethod&lt;/code&gt; 내부에서 계속 작업을 수행 하므로</target>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">&lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 작동 하도록하기 위해 두 가지 변경 사항이있었습니다.</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">백업하려면 &lt;code&gt;inFile.txt&lt;/code&gt; 을 , 제공 &lt;code&gt;-i&lt;/code&gt; 추가 할 파일 확장자를 :</target>
        </trans-unit>
        <trans-unit id="6d55112a0a5725689f79da10048f1a7a2263eebb" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt;, give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">백업하려면 &lt;code&gt;inFile.txt&lt;/code&gt; 을 , 제공 &lt;code&gt;-i&lt;/code&gt; 추가 할 파일 확장자를 :</target>
        </trans-unit>
        <trans-unit id="6e23de5e44e6d05a87a65143f53c7e5d6f21dc61" translate="yes" xml:space="preserve">
          <source>To make a local branch of a remote branch:</source>
          <target state="translated">원격 분기의 로컬 분기를 만들려면 :</target>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">간단히 말해서 AV 및 HV와 함께 특수 변수 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 를 사용할 수 있지만 현재 수행중인 작업을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="da79e317ac8a925a940d2422dac9d23c152e3b6d" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;, &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">짧게 말하면 AV 및 HV에 특수 변수 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 를 사용할 수 있지만 수행중인 작업을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">중복 키를 처리 할 때 편리하게 사용할 수 있도록 &lt;b&gt;DB_File&lt;/b&gt; 에는 몇 가지 유틸리티 메소드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">제대로 사용하려면</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">Perl 코어에서 기능을 제거하는 것에 대해 이야기 할 때 동일한 내용에 대해 이야기 할 수 있도록 몇 가지 단어와 문구에 대한 특정 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">다른 모듈 에서 &lt;b&gt;모듈의&lt;/b&gt; 심볼 을 &lt;b&gt;가져올&lt;/b&gt; 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">필드 해시가 시작되도록하려면 &lt;code&gt;refaddr&lt;/code&gt; 를 다음 과 같이 재정의하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">이전 버전의 Perl에 인터페이스를 더 유용하게 만들기 위해 누락 된 배열 조작을 시뮬레이트하기 위해 &lt;b&gt;DB_File&lt;/b&gt; 과 함께 많은 메소드가 제공 됩니다. 이러한 모든 메소드는 타이 호출에서 리턴 된 오브젝트를 통해 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">이러한 호출을 실패하게하려면</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">보다 복잡한 작업을 위해 해시는 실제 대상에 대한 참조를 포함 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">위의 두 필터 모듈 중 하나를 사용하려면 아래 행을 Perl 소스 파일에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">그러나 스레딩을 사용하기 위해 일반적으로 스레드가 최소한 일부 데이터를 공유하려고합니다. 이것은 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt; 모듈과 &lt;code&gt;:shared&lt;/code&gt; 속성으로 수행됩니다 :</target>
        </trans-unit>
        <trans-unit id="a04c440174950d35de1ff03f07736720e16d8ea1" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">그러나 스레딩을 사용하려면 일반적으로 스레드가 자신간에 최소한 일부 데이터를 공유하기를 원합니다. 이는 &lt;a href=&quot;threads::shared&quot;&gt;threads :: shared&lt;/a&gt; 모듈 및 &lt;code&gt;:shared&lt;/code&gt; 속성으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 UTF-8로 표시하려면 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; 은 추가 검사없이 데이터를 UTF-8로 표시하는 반면 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 은 데이터가 실제로 유효한 UTF-8인지 확인합니다. 자세한 내용은 &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 UTF-8로 표시하려면 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; 은 추가 검사없이 데이터를 UTF-8로 표시하는 반면 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 은 데이터가 실제로 유효한 UTF-8인지 확인합니다. 자세한 내용은 &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5abdd218835bb6eb6001f3cd74ea29d6653d76a4" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;. &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 UTF-8로 표시하려면 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; 은 추가 확인없이 데이터를 UTF-8로 표시하고, &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 은 데이터가 실제로 유효한 UTF-8인지 확인합니다. 자세한 내용은 &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">sbrk (2)의 수를 최소화하기 위해 malloc ()은 더 많은 메모리를 요구합니다. 이 필드는 아직 사용되지 않은 부분의 크기를 제공합니다.이 부분은 sbrk (2)이지만 결코 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">이를 얻으려면 해시에 대한 참조를 전달해야합니다</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">차단하지 않고 파일을 열려면 필요한 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">추가 할 파일을 열려면 필요한 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">추가 할 파일을 열려면 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">읽을 파일을 열려면 :</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">업데이트 할 파일을 열려면 필요한 경우 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">업데이트 할 파일을 열려면 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">업데이트 할 파일을 열려면 파일이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">쓰기 위해 파일을 열려면 필요한 경우 새 파일을 만들거나 이전 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">쓰기 위해 파일을 열려면 새 파일을 만드십시오. 파일이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="d996476f79882a20a27ba1e93bb75ca52cdeca1e" translate="yes" xml:space="preserve">
          <source>To open the temporary filehandle with O_EXLOCK (open with exclusive file lock) use &lt;code&gt;EXLOCK=&amp;gt;1&lt;/code&gt;. This is supported only by some operating systems (most notably BSD derived systems). By default EXLOCK will be false. Former &lt;code&gt;File::Temp&lt;/code&gt; versions set EXLOCK to true, so to be sure to get an unlocked filehandle also with older versions, explicitly set &lt;code&gt;EXLOCK=&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">O_EXLOCK (독점 파일 잠금으로 열기)으로 임시 파일 핸들을 열려면 &lt;code&gt;EXLOCK=&amp;gt;1&lt;/code&gt; . 이는 일부 운영 체제 (특히 BSD 파생 시스템)에서만 지원됩니다. 기본적으로 EXLOCK은 false입니다. 이전 &lt;code&gt;File::Temp&lt;/code&gt; 버전은 EXLOCK을 true로 설정하므로 이전 버전에서도 잠금 해제 된 파일 핸들을 얻으려면 명시 적으로 &lt;code&gt;EXLOCK=&amp;gt;0&lt;/code&gt; 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">UTF-8을 출력하려면 &lt;code&gt;:encoding&lt;/code&gt; 또는 &lt;code&gt;:utf8&lt;/code&gt; 출력 레이어를 사용하십시오. 선행</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">이 제한을 극복하려면 &lt;code&gt;(?s)&lt;/code&gt; 지시문을 사용하여 접두사 패턴 내에서 / s 일치를 설정해야합니다 . '(? s). *? (? = &amp;lt;H1&amp;gt;)'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">고유 한 버전으로 Perl 내장 루틴을 대체하려면 컴파일시이를 가져와야합니다. 이것은 &lt;code&gt;subs&lt;/code&gt; pragma 로 편리하게 달성 할 수 있습니다 . 이것은 상기 서브 루틴을 가져온 패키지에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">내장 된 전역 (즉, 모든 네임 스페이스)을 재정의하려면 컴파일 타임에 함수를 &lt;code&gt;CORE::GLOBAL&lt;/code&gt; 의사 네임 스페이스 로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="675c69919880e76e4b55ea1a685db1213f2914e2" translate="yes" xml:space="preserve">
          <source>To override the standard utime():</source>
          <target state="translated">표준 utime ()을 재정의하려면 :</target>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">&lt;code&gt;@dates&lt;/code&gt; 배열에 트리플렛 (day, month, year)으로 저장된 날짜 를 바이트, 바이트, 짧은 정수 시퀀스로 묶기 위해</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">문자열 &lt;code&gt;$str&lt;/code&gt; 을 부동 소수점 숫자로 구문 분석하려면</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">일부 기본 &lt;code&gt;$base&lt;/code&gt; 사용 에서 문자열 &lt;code&gt;$str&lt;/code&gt; 을 숫자로 구문 분석하려면</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">이 코드를 구문 분석하기 위해 Perl은 본 패키지 이름, 현재 패키지에 존재하는 서브 루틴, 이전에 본 베어 워드 및 기타 입력에 따라 휴리스틱을 사용합니다. 말할 것도없이, 휴리스틱은 매우 놀라운 결과를 낳을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">서브 루틴에 오브젝트 메소드를 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="767a526ac8d0e957a93b83324d4f56d1ac303c9b" translate="yes" xml:space="preserve">
          <source>To pass in &lt;code&gt;NULL&lt;/code&gt; as the pointer to an optional buffer, pass in an empty list reference, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">선택적 버퍼에 대한 포인터로 &lt;code&gt;NULL&lt;/code&gt; 을 전달하려면 빈 목록 참조 &lt;code&gt;[]&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">&lt;code&gt; '|-' &lt;/code&gt; 또는 &lt;code&gt; '-|' &lt;/code&gt; 으로 열린 프로그램에 보충 인수를 전달하려면 시스템 EXPR과 같이 명령 문자열에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">배포를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">줄을 처음에 추가하려면 기존 줄을 인쇄하는 루프에 들어가기 전에 해당 줄을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">&amp;lt;extract_quotelike&amp;gt;가 이런 식으로 입력에 대해 뭉개지는 것을 막기 위해 (리스트 컨텍스트 &lt;code&gt;extract_quotelike&lt;/code&gt; 가 유일하게 사용하는 경우 ) 입력 변수를 보간 리터럴로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memoize&lt;/code&gt; 가 어디서나 memoized 버전을 설치 하지 못하게하려면 &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ceea23486fb8fa0dd3f37c46296eb6503b2487" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;memoize&lt;/code&gt; 가 어디서나 메모 된 버전을 설치하는 것을 방지하려면 &lt;code&gt;INSTALL =&amp;gt; undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">모호성을 방지하기 위해</target>
        </trans-unit>
        <trans-unit id="fb87adecfac8f5df4ab3fe938fde55af46ebf1a3" translate="yes" xml:space="preserve">
          <source>To prevent specific methods from being called in bracket notation, use the blacklist() method:</source>
          <target state="translated">특정 메서드가 대괄호 표기법으로 호출되는 것을 방지하려면 blacklist () 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d04ca12ba631be1e6e856ee05396b933016cf93" translate="yes" xml:space="preserve">
          <source>To prevent the &lt;code&gt;qv()&lt;/code&gt; function from being exported to the caller's namespace, either use version with a null parameter:</source>
          <target state="translated">&lt;code&gt;qv()&lt;/code&gt; 함수가 호출자의 네임 스페이스로 내보내 지지 않도록하려면 null 매개 변수와 함께 version을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">검사 및 / 또는 변경되는 동안 다른 스레드가 대기열의 내용을 수정하지 못하게하려면 로컬 블록 내부에서 대기열을 &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;잠그&lt;/a&gt; 십시오.</target>
        </trans-unit>
        <trans-unit id="b8427301b03347200dffe8c8bd3a067e2726323d" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;threads::shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">큐의 내용이 검사 및 / 또는 변경되는 동안 다른 스레드에 의해 수정되는 것을 방지하려면 로컬 블록 내에서 큐를 &lt;a href=&quot;threads::shared#lock-VARIABLE&quot;&gt;잠급니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">이를 방지하려면 프로그램 인수를 동일한 인수가 동일한 문자열로 바뀌는 방식으로 프로그램 인수를 문자열로 바꾸는 &lt;code&gt;NORMALIZER&lt;/code&gt; 함수를 제공하십시오. 위의 &lt;code&gt;f&lt;/code&gt; 에 대한 &lt;code&gt;NORMALIZER&lt;/code&gt; 함수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">보다 다른 이름으로 펄 바이너리를 생산하기 위해 &lt;code&gt;perl&lt;/code&gt; 중 하나를 말하자면,</target>
        </trans-unit>
        <trans-unit id="76b5e8be4f2c5ad1ba3d72bdd1d3c182b64412ef" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt;, either say</source>
          <target state="translated">보다 다른 이름으로 펄 바이너리를 생산하기 위해 &lt;code&gt;perl&lt;/code&gt; 중 하나를 말하자면,</target>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">호스트 시스템에서 성공을 증명하려면 win32 / 폴더에서 &quot;dumpbin / headers wince-arm-pocket-wce400 \ perl.exe&quot;를 실행하고 파일 헤더 값 및 &quot;서브 시스템 (Windows CE)에서&quot;시스템 (ARM) &quot;을 찾으십시오. 선택 사항 헤더 값에 GUI)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">이 라이브러리에 Perl 인터페이스를 제공하려면 &lt;code&gt;fh&lt;/code&gt; 매개 변수와 호출하려는 Perl 서브 루틴 사이를 맵핑 할 수 있어야합니다 . 해시는이 매핑을 저장하는 편리한 메커니즘입니다. 아래 코드는 가능한 구현을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">예를 들어, 인기있는 &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; 함수가 아직 유니 코드 데이터를 처리하지 않는다고 가정 해 봅시다 . 랩퍼 함수는 인수를 원시 UTF-8로 변환하고 결과를 다음과 같이 Perl의 내부 표현으로 다시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="67eb0c577eae9b827927188aaf0fb3c3cf029b5e" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;, a &lt;code&gt;pingecho()&lt;/code&gt; subroutine is available with the same functionality as before. &lt;code&gt;pingecho()&lt;/code&gt; uses the tcp protocol. The return values and parameters are the same as described for the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method. This subroutine is obsolete and may be removed in a future version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 제공하기 위해 &lt;a href=&quot;Net::Ping&quot;&gt;인터넷 :: 핑을&lt;/a&gt; 하는 &lt;code&gt;pingecho()&lt;/code&gt; 서브 루틴은 이전과 동일한 기능을 사용할 수 있습니다. &lt;code&gt;pingecho()&lt;/code&gt; 는 tcp 프로토콜을 사용합니다. 반환 값과 매개 변수는 &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; 메서드에 대해 설명한 것과 동일 합니다. 이 서브 루틴은 더 이상 사용되지 않으며 &lt;a href=&quot;Net::Ping&quot;&gt;Net :: Ping&lt;/a&gt; 의 향후 버전에서 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">이전 버전의 Net :: Ping과 역 호환성을 제공하기 위해 pingecho () 서브 루틴을 이전과 동일한 기능으로 사용할 수 있습니다. pingecho ()는 tcp 프로토콜을 사용합니다. 리턴 값과 매개 변수는 ping () 메소드에 대해 설명한 것과 동일합니다. 이 서브 루틴은 더 이상 사용되지 않으며 향후 Net :: Ping 버전에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">클래스 전체 설정을 설정 / 취득하는 기능을 제공하려면 대신 접근자를 서브 루틴 또는 클래스 메소드로 제공하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c22d13aed3a39a35ea13dd4bc32c2e899b497afb" translate="yes" xml:space="preserve">
          <source>To purchase this book, visit &lt;a href=&quot;http://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; or your favourite bookstore.</source>
          <target state="translated">이 책을 구입하려면 &lt;a href=&quot;http://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; 또는 좋아하는 서점을 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">구문 분석 메소드의 출력을 파일 핸들 대신 문자열로 넣으려면 output_fh () 대신 output_string () 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">&lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 의 유형을 빠르게 확인하려면 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">bzip2 설명서를 인용하려면</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">한 번의 작업 으로 전체 &lt;b&gt;파일&lt;/b&gt; 을 &lt;b&gt;문자열&lt;/b&gt; 로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">명령의 STDOUT과 STDERR을 별도로 읽으려면 명령을 파일로 개별적으로 리디렉션 한 다음 프로그램이 완료되면 해당 파일에서 읽는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">명령의 STDOUT과 STDERR을 별도로 읽으려면 임시 파일로 리디렉션하고 명령을 실행 한 다음 임시 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 에서 읽고 압축 된 데이터를 &lt;code&gt;$buffer&lt;/code&gt; 버퍼에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 을 읽고 압축되지 않은 데이터를 버퍼 &lt;code&gt;$buffer&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9b6c4a10d71392deb29372c2a92475955d692a6e" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 에서 읽고 압축 된 데이터를 버퍼 &lt;code&gt;$buffer&lt;/code&gt; 쓰려면 .</target>
        </trans-unit>
        <trans-unit id="7e4ba76e5ff4a01f16e01bd7d5a780beec6519c3" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 에서 읽고 압축되지 않은 데이터를 버퍼 &lt;code&gt;$buffer&lt;/code&gt; 쓰려면 .</target>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">읽기</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.1950&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 쓰려면 .</target>
        </trans-unit>
        <trans-unit id="bcdf55eeb6470c2b3d7fd6cf75243e9a7e9d3240" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt.1950&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.1951&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="4698f091bc1fdd774cb393f877e7282bc2a1c3c5" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt.1951&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.Compressed&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f301dbf129331d08eb2d42bb04443bcca2c06d9c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt.Compressed&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="263ebe5d94b7d39489ca2895d917dbacbfcc41fc" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.gz&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="328756a43a9eee1db660f9353e2936fa148261c1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt.gz&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">파일의 내용을 읽으려면 &lt;code&gt;file1.txt&lt;/code&gt; 파일로 압축 된 데이터 및 쓰기 &lt;code&gt;file1.txt.1950&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="58f6252b156248cb5d164937a716b657f41d643b" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.1950&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.1951&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fef40be75516f086b04d71827ac5f116bf2718cd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.1951&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="33aeb771cd352fb39ce6d9be074532d17039ae52" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.gz&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="2a2635502bb2923dab4d82f7333e4b41da9484a4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.gz&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.zip&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ae6686db2a7eebd5b91805c9b0d9008be2e94d9e" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.zip&lt;/code&gt; 파일에 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">실제로 Perl을 둘러 보려면 다음과 같이 디버깅을 위해 Perl을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 새 버전이 릴리스 될 때마다 알림을 받으려면 빈 이메일 메시지를 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 으로 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="c9c2c718f1481d7a23bdb92c3c65c5d23a83c26f" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 새 버전이 릴리스 될 때마다 알림을 받으려면 빈 이메일 메시지를 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 으로 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="59bd9384e894fc19ae43b0a3a96f9c688fce9ba8" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;a href=&quot;File::Path#make_path%28-%24dir1%2C-%24dir2%2C-....-%29&quot;&gt;&lt;code&gt;make_path&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">재귀 적으로 디렉토리 구조를 생성하려면 &lt;a href=&quot;File::Path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;a href=&quot;File::Path#make_path%28-%24dir1%2C-%24dir2%2C-....-%29&quot;&gt; &lt;code&gt;make_path&lt;/code&gt; &lt;/a&gt; 함수를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 구조를 재귀 적으로 작성하려면 &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;make_path&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 구조를 재귀 적으로 작성하려면 &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;make_path&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">가능한 한 오버 헤드를 줄이려면 확장 DLL을 찾기 위해 가능한 한 위치 만 확인합니다 (이 위치는 &lt;code&gt;make install&lt;/code&gt; 이 DLL을 배치하는 위치입니다 ). 찾을 수없는 경우 DLL 검색은 투명하게 &lt;code&gt;DynaLoader&lt;/code&gt; 에 위임 되며, &lt;code&gt;@INC&lt;/code&gt; 목록 에서 DLL을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2a76f398b95d1961552e49490d4d377316e986e8" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt;, which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">오버 헤드를 최대한 줄이기 위해 확장 DLL을 찾기 위해 가능한 한 위치 만 검사합니다 (이 위치는 &lt;code&gt;make install&lt;/code&gt; 이 DLL을 넣는 위치입니다 ). 찾을 수없는 경우 DLL 검색 은 &lt;code&gt;@INC&lt;/code&gt; 목록을 따라 DLL을 찾는 &lt;code&gt;DynaLoader&lt;/code&gt; 에 투명하게 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="66c3094c723d121eb0bf078e8289c66d4fdd4a9a" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;a href=&quot;File::Path#rmtree%28-%24dir-%29&quot;&gt;&lt;code&gt;rmtree&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 트리를 재귀 적으로 제거하려면 ( Unix에서는 &lt;code&gt;rm -rf&lt;/code&gt; ) &lt;a href=&quot;File::Path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;a href=&quot;File::Path#rmtree%28-%24dir-%29&quot;&gt; &lt;code&gt;rmtree&lt;/code&gt; &lt;/a&gt; 함수를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 트리를 재귀 적으로 제거하려면 ( UNIX의 경우 &lt;code&gt;rm -rf&lt;/code&gt; ) &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; 의 &lt;code&gt;rmtree&lt;/code&gt; 함수를보십시오. 모듈 .</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 트리를 재귀 적으로 제거하려면 ( UNIX의 경우 &lt;code&gt;rm -rf&lt;/code&gt; ) &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;rmtree&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">환경에서 묶인 환경 변수를 제거하려면 정의되지 않은 값을 지정하십시오</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">각 액세스에서 묶인 해시의 생성을 제거하기 위해 비 원형 참조 구조를 허용하는 추가적인 간접 수준이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">SV에서 마법을 제거하려면 sv_unmagic 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="1244516061f404f040587b4bb0bc9e4acce762e7" translate="yes" xml:space="preserve">
          <source>To replace any of these components I call one of these harness methods with the name of the replacement class:</source>
          <target state="translated">이러한 구성 요소를 대체하기 위해 대체 클래스의 이름으로 이러한 하네스 메서드 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">새로운 버그를보고하려면 다음을 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="e2d5ab4989d41c738d1504f8f7e7186c29958e2b" translate="yes" xml:space="preserve">
          <source>To reset your working directory to a pristine condition you can do:</source>
          <target state="translated">작업 디렉토리를 원래 상태로 재설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">디스크에 저장된 데이터를 검색하려면 파일 이름과 함께 &lt;code&gt;retrieve&lt;/code&gt; 를 사용 하십시오. 해당 파일에 저장된 객체는 메모리를 위해 다시 생성되며</target>
        </trans-unit>
        <trans-unit id="7f6b972558cf783871ca862e09f183ae72cbdc43" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;&quot;REGEXP Functions&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">XS 함수의 스칼라에서 &lt;code&gt;REGEXP&lt;/code&gt; 객체 를 검색하려면 &lt;code&gt;SvRX&lt;/code&gt; 매크로를 사용하십시오. perlapi의 &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;&quot;REGEXP 함수&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">XS 함수의 스칼라에서 &lt;code&gt;REGEXP&lt;/code&gt; 오브젝트 를 검색하려면 &lt;code&gt;SvRX&lt;/code&gt; 매크로를 사용하십시오. perlapi의 &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP 함수를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">빈 목록을 반환하려면 PPCODE : 블록을 사용해야하며 스택에서 반환 값을 푸시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c0fa2ebc492606f9abfba27c95d0995af195e45c" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">DPMI 플랫폼에서 Perl을 실행하려면 RSX 런타임이 필요합니다. 이것은 DOS-inside-OS / 2, Win0.3 *, Win0.95 및 WinNT에서 필요합니다 ( &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;기타 OS&quot;&lt;/a&gt; 참조 ). RSX는 EMX와 마찬가지로 VCPI에서만 작동하지 않으므로 DMPI가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">DPMI 플랫폼에서 Perl을 실행하려면 RSX 런타임이 필요합니다. 이것은 DOS-inside-OS / 2, Win0.3 *, Win0.95 및 WinNT에서 필요합니다 ( &lt;a href=&quot;#Other-OSes&quot;&gt;기타 OS&lt;/a&gt; 참조 ). RSX는 EMX와 마찬가지로 VCPI에서만 작동하지 않으며 DMPI가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;프로그램&lt;/b&gt; 또는 &lt;b&gt;서브 루틴&lt;/b&gt; 을 실행합니다 . &lt;b&gt;신호 처리기&lt;/b&gt; 를 실행하지 않는 한 내장 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 와는 아무런 관련이 없습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97a854ddf9aaf9c69e7b95eed2386df587b2d5c0" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;kill&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;프로그램&lt;/b&gt; 또는 &lt;b&gt;서브 루틴&lt;/b&gt; 을 실행합니다 . ( &lt;b&gt;신호 처리기&lt;/b&gt; 를 실행하지 않는 한 &lt;code&gt;kill&lt;/code&gt; 내장 기능 과 관련이 없습니다 .)&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">Unix 명령 행에서 Perl 프로그램을 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">이 코드를 실행하기 위해 &lt;code&gt;perl_run&lt;/code&gt; 이 호출되어 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행 한 다음 runops 루프를 시작합니다. 이 루프는 라인 1에서 eval 및 tie ops를 실행하고 eval은 &lt;code&gt;CxEVAL&lt;/code&gt; 을 푸시합니다 . 을 컨텍스트 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">최소한 대리 쌍은 유니 코드 컨소시엄의 가장 큰 실수였습니다. 그러나 더글러스 아담스의 말에 따르면</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">perlfaq 질문 제목을 검색하려면</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">컴퓨터에 대한 모든 내용을 보려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">(언) 패킹이 어떻게 작동하는지보기 위해, 바이트 시퀀스의 내용과 16 진 문자열 사이의 변환이 적은 간단한 템플릿 코드로 시작하겠습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 . 덤프 프로그램을 상기 시키거나 불행한 마지막 메시지는 야생 블루 저쪽으로 만료되기 전에 당신에게 던지지 않을 것입니다. 변수 &lt;code&gt;$mem&lt;/code&gt; 에 의미에 대해 아무 것도 가정하지 않고 검사하려는 바이트 시퀀스가 ​​있다고 가정하면 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02e337f8ffa5587c60ddae1e61c27bc0cb20b9a1" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;unpack&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">(un) packing이 어떻게 작동하는지보기 위해, 변환이 낮은 기어에있는 간단한 템플릿 코드로 시작할 것입니다 : 바이트 시퀀스의 내용과 16 진수 문자열 사이. &lt;code&gt;unpack&lt;/code&gt; 을 사용합시다. 이것은 당신에게 덤프 프로그램을 상기 시키거나 불행한 프로그램이 야생 블루 저쪽으로 만료되기 전에 당신에게 던지지 않을 절박한 마지막 메시지를 떠올리게 할 것이기 때문입니다. &lt;code&gt;$mem&lt;/code&gt; 변수 가 그 의미에 대해 가정하지 않고 검사하려는 바이트 시퀀스를 보유하고 있다고 가정하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에 어떤 영향을 미치는지 알아보기 위해 다음 두 C 구조를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="9053b5511eec27497eeb92618a57db0e9ef4499d" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">이것이 &lt;code&gt;pack&lt;/code&gt; 및 &lt;code&gt;unpack&lt;/code&gt; 에 어떤 영향을 미치는지 확인하기 위해 다음 두 C 구조를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="f4c245de21e3816d09a578f5e1c5f63c7d4c6210" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;a href=&quot;perlfunc#ref-EXPR&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">변수에 참조가 포함되어 있는지 확인하려면 &lt;a href=&quot;perlfunc#ref-EXPR&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 인수가 참조이면 true를 반환합니다. 실제로 그것은 그것보다 조금 낫습니다 : 해시 참조에 대해서는 &lt;code&gt;HASH&lt;/code&gt; 를 , 배열 참조에 대해서는 &lt;code&gt;ARRAY&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">변수에 참조가 포함되어 있는지 확인하려면 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 인수가 참조 인 경우 true를 리턴합니다. 실제로 그것은 그것보다 조금 낫습니다 : 해시 참조에 대해 &lt;code&gt;HASH&lt;/code&gt; 를 반환 하고 &lt;code&gt;ARRAY&lt;/code&gt; , 배열 참조의 경우 ARRAY 를 .</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">시스템이이 불일치에 의해 영향을 받는지 확인하려면 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; 은 잘못된 값을 반환합니다. NTPL 스레드는 POSIX 의미를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6370b1130305216b6c4037876a31e89ca9fbcd86" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">시스템이이 불일치의 영향을 받는지 확인하려면 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL&lt;/code&gt; 은 거짓 값을 반환합니다. NTPL 스레드는 POSIX 의미를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">실제로 작동하려면 메소드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fddb2e3b0651d7cee6f1eddfc0db7c585ec33e9f" translate="yes" xml:space="preserve">
          <source>To see the output of specific failing tests run the harness from the t directory:</source>
          <target state="translated">특정 실패한 테스트의 출력을 보려면 t 디렉토리에서 하네스를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">상태 설명이 어떻게 보이는지 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">시스템에 설치된 내용을 보려면</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">DVD에 포함 된 버전 (/ cdrom에 마운트 된 것으로 가정)을 보려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">데이터가 아닌 데이터가 있는지 확인하려면 BSD (또는 GNU) 호환 가능 &lt;code&gt;nm&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1349f12e189a41ade68fc4f2a3b99132d4421e66" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt;:</source>
          <target state="translated">상수가 아닌 데이터가 있는지 확인하려면 BSD (또는 GNU) 호환 &lt;code&gt;nm&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">이것이 왜 문제인지 확인하려면 &quot;A&quot;와 &quot;B&quot;의 두 프로세스가 동일한 &lt;b&gt;DB_File&lt;/b&gt; 을 업데이트하려고 할 때 발생할 수있는 작업을 고려하십시오.&lt;b&gt;&lt;/b&gt; 위에서 설명한 잠금 단계를 사용하여 데이터베이스 하십시오. &quot;A&quot;프로세스가 이미 데이터베이스를 열고 쓰기 잠금을 가지고 있지만 실제로 데이터베이스를 아직 업데이트하지 않았다고 가정합니다 (2 단계는 완료했지만 3 단계는 아직 시작되지 않음). 이제 프로세스 &quot;B&quot;는 동일한 데이터베이스를 열려고합니다. 1 단계는 성공하지만 &quot;A&quot;프로세스가 잠금을 해제 할 때까지 2 단계에서 차단됩니다. 여기서 주목할 점은이 시점에서 두 프로세스 모두 데이터베이스에서 동일한 초기 블록을 캐시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">이유를 확인하려면 중간 지점 교대에 여전히 문제가있는 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">여러 대상으로 동시에 &lt;b&gt;데이터 그램&lt;/b&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">올바른 목적지로 무언가를 보내기 위해. 종종 함수 &lt;b&gt;참조&lt;/b&gt; 테이블에서 조회 하거나 객체 &lt;b&gt;메소드&lt;/b&gt; 의 경우 &lt;b&gt;메소드&lt;/b&gt; 트리에 대해 가장 구체적인 정의를 찾기 위해 상속 트리를 탐색하여 알고리즘 적으로 선택된 대상으로 프로그래밍 제어를 전송 함을 나타 내기 위해 은유 적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">pragma의 상태를 설정하려면</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">개인 값을 설정하려면 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="16aae45044289a718089765d242152d067d315d5" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt;:</source>
          <target state="translated">개인 값을 설정하려면 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">생성을 종료하려면 &lt;code&gt;NO_META&lt;/code&gt; 플래그를 &lt;code&gt;WriteMakefile()&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="eacb74b08b83ca5e29c7e01a124f0c6492dc5d47" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt;.</source>
          <target state="translated">생성을 중단하려면 &lt;code&gt;NO_META&lt;/code&gt; 플래그를 &lt;code&gt;WriteMakefile()&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">세마포어에 신호를 보내려면 &lt;code&gt;-1&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 바꾸십시오 . 참조 &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc에서 시스템 V IPC&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 문서를.</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">세마포어에 신호를 보내려면 &lt;code&gt;-1&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 바꾸십시오 . 참조 &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;시스템 V IPC는 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 문서를.</target>
        </trans-unit>
        <trans-unit id="49cc3c1b8c165959fade8c0cdac2c114f0c70649" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt;. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Semaphore&quot;&gt;&lt;code&gt;IPC::Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어에 신호를 보내려면 &lt;code&gt;-1&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 바꾸십시오 . &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 &quot;SysV IPC&quot;&lt;/a&gt; 및 &lt;a href=&quot;IPC::SysV&quot;&gt; &lt;code&gt;IPC::SysV&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;IPC::Semaphore&quot;&gt; &lt;code&gt;IPC::Semaphore&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">HMQ가 더 이상 필요하지 않다는 것을 Perl에 알리려면 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 호출 하십시오 . HMQ가 필요하거나 필요하지 않은 경우 Perl 프로세스는 PM 프로세스에서 자동으로 PM 프로세스로 / 변형되지 않습니다. 메시지 큐가 제공 / 제공되지 않으면 펄은 종료 중에 &lt;code&gt;WM_QUIT&lt;/code&gt; 메시지를 자동으로 활성화 / 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="76395c3ce12a1fd4356ad20f5dad8a9f32df5165" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt;. Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">HMQ가 더 이상 필요하지 않다는 것을 Perl에 알리려면 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 호출 하십시오 . Perl 프로세스는 HMQ가 필요하거나 필요하지 않은 경우 PM 프로세스로 /에서 자동으로 변형 / 변형 해제됩니다. Perl은 메시지 대기열이 제공되거나 제공되지 않는 경우 종료 중에 &lt;code&gt;WM_QUIT&lt;/code&gt; 메시지를 자동으로 활성화 / 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">이를 Perl 연산자로 자동 해석하려면 연산자에서 &lt;code&gt;CORE::&lt;/code&gt; &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;접 두부를 사용&lt;/a&gt; 하거나 (예 : &lt;code&gt;CORE::log($x)&lt;/code&gt; ) 서브 루틴을 오브젝트 메소드로 선언하십시오 ( perlsub 또는 &lt;a href=&quot;attributes&quot;&gt;속성의 &lt;/a&gt;서브 루틴 속성 참조). ).</target>
        </trans-unit>
        <trans-unit id="77f74a1e8ed985d91bce77589cc0e8ad84a337cc" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt;) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;&quot;Subroutine Attributes&quot; in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">이를 Perl 연산자로 자동 해석하려면 연산자에 &lt;code&gt;CORE::&lt;/code&gt; 접두사 (예 : &lt;code&gt;CORE::log($x)&lt;/code&gt; )를 사용하거나 서브 루틴을 객체 메서드로 선언합니다 ( &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;perlsub&lt;/a&gt; 또는 &lt;a href=&quot;attributes&quot;&gt;속성의 &lt;/a&gt;&quot;서브 루틴 속성&quot; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">여러 줄 대체를 단순화하려면 &quot;.&quot; &lt;code&gt;/s&lt;/code&gt; 수정자를 사용하지 않으면 문자는 줄 바꿈과 절대 일치 하지 않습니다. 실제로는 문자열이 한 줄이 아닌 경우에도 Perl에게 문자열을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8a2c6b3c9e2b9a0960e93d5d6acb36d8aa948a45" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; character never matches a newline unless you use the &lt;a href=&quot;#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt;&lt;/a&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">여러 줄 대체를 단순화하기 위해 &lt;code&gt;&quot;.&quot;&lt;/code&gt; &lt;a href=&quot;#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; &lt;/a&gt; 수정자를 사용하지 않는 한 문자는 줄 바꿈과 일치하지 않습니다 . 실제로 Perl은 문자열이 한 줄인 것처럼 가장하도록 지시합니다. 그렇지 않은 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">줄을 건너 뛰려면 루핑 컨트롤을 사용하십시오. 이 예제 의 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 주석 행을 건너 뛰고 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 행 은 &lt;code&gt;__END__&lt;/code&gt; 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 발생하면 모든 처리를 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="fa5fe915c274707436eefaadbe2f71ad0bad5d61" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;next&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;last&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">줄을 건너 뛰려면 반복 제어를 사용하십시오. 이 예제 의 &lt;code&gt;next&lt;/code&gt; 는 주석 줄을 건너 뛰고 &lt;code&gt;last&lt;/code&gt; 는 &lt;code&gt;__END__&lt;/code&gt; 또는 &lt;code&gt;__DATA__&lt;/code&gt; 를 만나면 모든 처리를 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">이 문제를 해결하려면 다음과 같이 pipe (), fork () 및 open () 형식을 사용하여 한 파일 설명자를 다른 파일 설명 자로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f249829a932dbf9b88abd3f71ccd6d576666559" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">값으로 해시를 정렬하려면, 당신은 사용해야합니다 &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 기능을. 다음은 값에 따른 해시의 내림차순 숫자 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">값으로 해시를 정렬하려면, 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능을. 다음은 값에 따른 내림차순 숫자 해시입니다.</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">값으로 해시를 정렬하려면, 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능을. 다음은 값에 따른 내림차순 숫자 해시입니다.</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">해시를 정렬하려면 키로 시작하십시오. 이 예에서는 정렬 기능에 키 목록을 제공 한 다음 키를 ASCII 방식으로 비교합니다 (로케일 설정의 영향을받을 수 있음). 출력 목록에는 ASCII 순서의 키가 있습니다. 키가 있으면 키를 ASCII 키 순서로 나열하는 보고서를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">유니 코드 코드 포인트로 문자를 지정하려면 &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; 형식을 사용하십시오 . 여기서</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">쓸 때 압축 수준을 지정하려면 0에서 9 사이의 숫자를 모드 문자열에 추가하십시오. 0은 압축이 없음을 의미하고 9는 최대 압축을 의미합니다. 압축 수준을 지정하지 않으면 Z_DEFAULT_COMPRESSION이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="679c6d53c6265b7e7972b50aa21c407989720f3b" translate="yes" xml:space="preserve">
          <source>To specify a literal SPACE character, you can escape it with a backslash, like:</source>
          <target state="translated">리터럴 SPACE 문자를 지정하려면 다음과 같이 백 슬래시로 이스케이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">개별 스레드에 특정 스택 크기를 지정하려면 첫 번째 인수로 해시 참조를 사용하여 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">실시간 시간 초과를 지정하려면 &lt;code&gt;LIFETIME&lt;/code&gt; 옵션에 숫자 값을 제공하십시오. 캐시 된 데이터는 몇 초 후에 만료되며 만료되면 새로 조회됩니다. 데이터 항목을 새로 조회하면 수명이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">이름으로 지정하기 위해 문자 또는 문자 시퀀스의 이름은 중괄호 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde9b4df6bfb5d9f21839e498fe1e3acf75a91a1" translate="yes" xml:space="preserve">
          <source>To specify how numbers are formatted when printed, one is advised to use &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; instead.</source>
          <target state="translated">인쇄 할 때 숫자 형식을 지정하려면 대신 &lt;code&gt;printf&lt;/code&gt; 또는 &lt;code&gt;sprintf&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">쓸 때 압축 전략을 지정하려면 필터링 된 데이터에 'f'를 추가하고, 허프만 전용 압축에 'h'를, 런 렝스 인코딩에 'R'을 추가하십시오. 전략을 지정하지 않으면 Z_DEFAULT_STRATEGY가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">복잡한 설치 시나리오에서 작업 속도를 높이기 위해 CPAN.pm은 이미 수행 한 작업을 추적하고 두 번째 작업을 거부합니다. &lt;code&gt;get&lt;/code&gt; 하는 &lt;code&gt;make&lt;/code&gt; 가, 그리고 &lt;code&gt;install&lt;/code&gt; 반복되지 않습니다. &lt;code&gt;test&lt;/code&gt; 이전 테스트가 실패한 경우에만 반복됩니다. CPAN.pm이 두 번째로 무언가를 거부하면 진단 메시지는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">다음과 같이 문자열을 자동으로 분할하려면</target>
        </trans-unit>
        <trans-unit id="1c43b020de2fd47f4f4fe689a93a4f681f980968" translate="yes" xml:space="preserve">
          <source>To start exploring some of the features of Test::Harness I need to switch from</source>
          <target state="translated">Test :: Harness의 일부 기능을 탐색하려면 다음에서 전환해야합니다.</target>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">복잡한 명령 줄을 사용하여 외부 프로그램을 시작하기 위해 (예 : 파이프 사이 및 / 또는 인수 인용) Perl은 외부 쉘을 사용합니다. EMX 포트를 사용하면 이러한 쉘의 이름을 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">perl 소스 파일을 클릭하여 perl을 시작하려면 HKCR에서 해당 항목을 작성해야합니다 (참조</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo;(값에서 1을 제거하는 것을 의미) 또는&amp;ldquo; &lt;code&gt;$x&lt;/code&gt; by 3을 감소 &amp;rdquo;와 같이 변수에서 값을 빼기 .</target>
        </trans-unit>
        <trans-unit id="b3834a44244c88392770a12aebccbba7a107bc50" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt;&amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">&quot; &lt;code&gt;$x&lt;/code&gt; 감소 &quot;(값에서 1을 제거함을 의미) 또는 &quot; &lt;code&gt;$x&lt;/code&gt; 를 3만큼 감소 &quot;와 같이 변수에서 값을 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ec17769e0302f168a8a4f3337a21d3e87e35b66" translate="yes" xml:space="preserve">
          <source>To summarize,</source>
          <target state="translated">요약,</target>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">요약하면, C와 Perl 콜백 사이의 맵핑을 저장하기 위해 고려할 수있는 여러 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">요약하면 XS 코드에서 로캘을 처리하는 방법과 처리 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">요약하면, &lt;code&gt;\o{}&lt;/code&gt; 형식은 항상 사용하기에 안전하고 다른 형식은 정확히 세 자리 숫자를 사용하여 지정하는 경우 \ 077까지의 코드 포인트에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f40c24735c228769cecae3c743dcd1c13b34fed1" translate="yes" xml:space="preserve">
          <source>To summarize, this modifier provides protection for applications that don't wish to be exposed to all of Unicode. Specifying it twice gives added protection.</source>
          <target state="translated">요약하면,이 수정자는 모든 유니 코드에 노출되기를 원하지 않는 응용 프로그램을 보호합니다. 두 번 지정하면 추가 보호 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8b52f75bf07c40cc3e2dd50eeec591de76cf40c0" translate="yes" xml:space="preserve">
          <source>To support potentially complex type mappings, if a typemap entry used by an XSUB contains a comment like &lt;code&gt;/*scope*/&lt;/code&gt; then scoping will be automatically enabled for that XSUB.</source>
          <target state="translated">잠재적으로 복잡한 유형 매핑을 지원하기 위해 XSUB에서 사용하는 유형 맵 항목에 &lt;code&gt;/*scope*/&lt;/code&gt; 와 같은 주석이 포함되어 있으면 해당 XSUB에 대해 범위 지정이 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="91686b6431594592a741d6ffaa933cf36c582cbb" translate="yes" xml:space="preserve">
          <source>To support the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, the host and port information may be passed in a single string rather than as two separate arguments.</source>
          <target state="translated">&lt;code&gt;IO::Socket::INET&lt;/code&gt; API 를 지원하기 위해 호스트 및 포트 정보는 두 개의 개별 인수가 아닌 단일 문자열로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8462b0ae01f912ec184e35a1a54c294d3db9c0b" translate="yes" xml:space="preserve">
          <source>To support these systems a dl_expandspec() function can be implemented either in the</source>
          <target state="translated">이러한 시스템을 지원하기 위해 dl_expandspec () 함수는</target>
        </trans-unit>
        <trans-unit id="28ae7b79101a8be6ce604e7c61e718194e3e904d" translate="yes" xml:space="preserve">
          <source>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; to skip forward and back:</source>
          <target state="translated">문자열에서 짝수의 문자 쌍을 바꾸려면 여러 가지 기술을 사용할 수 있습니다. 먼저 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;X&lt;/code&gt; 를 사용 하여 앞뒤로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1051c83149c4c36730f97e1db8ce4187ba11feed" translate="yes" xml:space="preserve">
          <source>To switch back to blead:</source>
          <target state="translated">blead로 다시 전환하려면 :</target>
        </trans-unit>
        <trans-unit id="52ed4dc484d91fd5d94539987c6af1829eb4d58f" translate="yes" xml:space="preserve">
          <source>To switch back to the default behaviour, use</source>
          <target state="translated">기본 동작으로 다시 전환하려면</target>
        </trans-unit>
        <trans-unit id="58f194a064ccb257aaff951da440487e80ed0887" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;&quot;Pragmas and debugging&quot;&lt;/a&gt; below.</source>
          <target state="translated">엔진이 최적화를 수행하는 방법을 자세히 살펴 보려면 아래의 &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;&quot;프라 그마 및 디버깅&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ad4d27e66821295806e39cdf16c87b63c90f1ed" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragmas and debugging&lt;/a&gt; below.</source>
          <target state="translated">엔진이 최적화를 수행하는 방법을 자세히 살펴 보려면 아래의 &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragma 및 디버깅&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4f5b8181a41c615c87aa14a36a9140e586c5541" translate="yes" xml:space="preserve">
          <source>To tell PerlIO to use line buffer, implement -&amp;gt;needs_lines method for your encoding object. See &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt; for details.</source>
          <target state="translated">PerlIO에게 라인 버퍼를 사용하도록 지시하려면 인코딩 객체에-&amp;gt; needs_lines 메소드를 구현하십시오. 자세한 내용은 &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode :: Encoding&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3651fac40bf38f464aae40f7d0973a874e0f3ea" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support</source>
          <target state="translated">지원하는 시스템에서 코드가 올바르게 작동하고 COW 버퍼를 수정하지 않는지 테스트하려면</target>
        </trans-unit>
        <trans-unit id="9bfb4f72eb168db2a7d20587450847a727ac1bdf" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support &lt;a href=&quot;http://man.he.net/man2/mmap&quot;&gt;mmap(2)&lt;/a&gt; (i.e., Unix) you can configure perl with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; and it will turn buffer violations into crashes. You will find it to be marvellously slow, so you may want to skip perl's own tests.</source>
          <target state="translated">코드가 올바르게 작동하고 COW 버퍼를 수정하지 않는지 테스트하려면 &lt;a href=&quot;http://man.he.net/man2/mmap&quot;&gt;mmap (2)&lt;/a&gt; (예 : Unix) 를 지원하는 시스템 에서 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; 를 사용 하여 perl을 구성 하면 버퍼 위반이 충돌로 전환됩니다. 놀라 울 정도로 느리기 때문에 perl 자체 테스트를 건너 뛰고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ce0bdd874392ab18a8e9a217e048b7e9971ae31" translate="yes" xml:space="preserve">
          <source>To test whether a variable contains tainted data, and whose use would thus trigger an &quot;Insecure dependency&quot; message, you can use the &lt;code&gt;tainted()&lt;/code&gt; function of the Scalar::Util module, available in your nearby CPAN mirror, and included in Perl starting from the release 5.8.0. Or you may be able to use the following &lt;code&gt;is_tainted()&lt;/code&gt; function.</source>
          <target state="translated">변수에 오염 된 데이터가 포함되어 있고 그로 인해 &quot;안전하지 않은 종속성&quot;메시지가 트리거되는지 여부를 테스트하기 위해 Scalar :: Util 모듈 의 &lt;code&gt;tainted()&lt;/code&gt; 함수를 사용할 수 있습니다. 가까운 CPAN 미러에서 사용 가능하며 Perl 시작에 포함 릴리스 5.8.0부터. 또는 다음 &lt;code&gt;is_tainted()&lt;/code&gt; 함수 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="521a49c8c35183a9a627a2f63a5d516c8a7cf5ba" translate="yes" xml:space="preserve">
          <source>To the Perl program that called fork(), all this is designed to be transparent. The parent returns from the fork() with a pseudo-process ID that can be subsequently used in any process-manipulation functions; the child returns from the fork() with a value of &lt;code&gt;0&lt;/code&gt; to signify that it is the child pseudo-process.</source>
          <target state="translated">fork ()를 호출 한 Perl 프로그램에는이 모든 것이 투명하게 설계되었습니다. 부모는 모든 프로세스 조작 함수에서 나중에 사용할 수있는 의사 프로세스 ID로 fork ()에서 리턴합니다. 자식은 값이 &lt;code&gt;0&lt;/code&gt; 인 fork ()에서 반환되어 자식 의사 프로세스임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7e05b4fcf627d6e6c4197f19ffda73a879c664a" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will attempt to fix critical issues in the two most recent stable 5.x release series. Fixes for the current release series take precedence over fixes for the previous release series.</source>
          <target state="translated">우리의 능력을 최대한 발휘하기 위해 가장 안정적인 두 가지 최신 5.x 릴리스 시리즈에서 중요한 문제를 해결하려고 시도합니다. 현재 릴리스 시리즈의 수정 사항이 이전 릴리스 시리즈의 수정 사항보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="51a0f8c69bc4919eb0f20691df0fe50a577785df" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will provide &quot;critical&quot; security patches / releases for any major version of Perl whose 5.x.0 release was within the past three years. We can only commit to providing these for the most recent .y release in any 5.x.y series.</source>
          <target state="translated">우리의 능력을 최대한 발휘하기 위해 우리는 5.x.0 릴리스가 지난 3 년 이내 인 모든 주요 Perl 버전에 대해 &quot;중요한&quot;보안 패치 / 릴리스를 제공 할 것입니다. 우리는 5.xy 시리즈에서 가장 최근의 .y 릴리즈에 이것들을 제공 할 것을 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0150808aeae45323caf819f2a13c1da7ff5a8491" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, 唐鳳 has waived all copyright and related or neighboring rights to &lt;a href=&quot;test-use-ok&quot;&gt;Test-use-ok&lt;/a&gt;.</source>
          <target state="translated">법에 따라 가능한 한 唐鳳는 &lt;a href=&quot;test-use-ok&quot;&gt;Test-use-ok에&lt;/a&gt; 대한 모든 저작권 및 관련 또는 이웃 권리를 포기했습니다 .</target>
        </trans-unit>
        <trans-unit id="6fa12fa0dac95b52f8a74aca03b7455d8e9dea13" translate="yes" xml:space="preserve">
          <source>To throw away the current &lt;b&gt;process&lt;/b&gt;&amp;rsquo;s program and replace it with another, without exiting the process or relinquishing any resources held (apart from the old memory image).</source>
          <target state="translated">현재 &lt;b&gt;프로세스&lt;/b&gt; 의 프로그램 을 버리고 &lt;b&gt;프로세스&lt;/b&gt; 를 종료하거나 기존 메모리 이미지를 제외하고 보유한 리소스를 포기하지 않고 다른 &lt;b&gt;프로세스로&lt;/b&gt; 교체합니다.</target>
        </trans-unit>
        <trans-unit id="f643f5e924090f3cdd5f1a59fb90c2d5e840c683" translate="yes" xml:space="preserve">
          <source>To transfer files without &amp;lt;LF&amp;gt;&amp;lt;CR&amp;gt; translation Net::FTP provides the &lt;code&gt;binary&lt;/code&gt; method</source>
          <target state="translated">&amp;lt;LF&amp;gt; &amp;lt;CR&amp;gt; 번역없이 파일을 전송하려면 Net :: FTP는 &lt;code&gt;binary&lt;/code&gt; 방식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="448a61a17f3cda496b5d3ba49da88ff7c85062ed" translate="yes" xml:space="preserve">
          <source>To transform a bit vector into a string or list of 0's and 1's, use these:</source>
          <target state="translated">비트 벡터를 문자열 또는 0과 1의 목록으로 변환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52d3ead3184110f1e5fce1f1092454c6b16a6c41" translate="yes" xml:space="preserve">
          <source>To translate from and to an arbitrary text encoding, use the &lt;code&gt;:encoding&lt;/code&gt; layer. The matching of encoding names in &lt;code&gt;:encoding&lt;/code&gt; is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">임의의 텍스트 인코딩을 변환하려면 &lt;code&gt;:encoding&lt;/code&gt; 레이어를 사용하십시오 . &lt;code&gt;:encoding&lt;/code&gt; 에서 인코딩 이름의 일치 는 느슨합니다. 대소 문자는 중요하지 않으며 많은 인코딩에는 여러 별칭이 있습니다. 자세한 내용과 지원되는 로케일 목록은 &lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="944acb39535fd8c95944433695337f030097b9f4" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">텍스트 줄에서 후행 줄 바꿈을 자르려면 &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt; &lt;code&gt;chomp&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 기본 설정을 사용하면이 함수는 후행 &lt;code&gt;\n&lt;/code&gt; 문자를 찾아 이식 가능한 방식으로 트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="8d6d675a384b336013b57ff889fd3d31ada57c0a" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">텍스트 줄에서 후행 줄 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 를 자르려면 chomp ()를 사용하십시오 . 기본 설정을 사용하면이 기능은 후행 &lt;code&gt;\n&lt;/code&gt; 문자를 찾아 휴대가 용이합니다.</target>
        </trans-unit>
        <trans-unit id="fc544de4b36caa59d370fbe1d58c57b2dd4e85a5" translate="yes" xml:space="preserve">
          <source>To try dmake's parallel mode, type &quot;dmake -P2&quot;, where 2, is the maximum number of parallel jobs you want to run. A number of things in the build process will run in parallel, but there are serialization points where you will see just 1 CPU maxed out. This is normal.</source>
          <target state="translated">dmake의 병렬 모드를 시도하려면 &quot;dmake -P2&quot;를 입력하십시오. 여기서 2는 실행하려는 최대 병렬 작업 수입니다. 빌드 프로세스의 여러 항목이 병렬로 실행되지만 최대 1 개의 CPU 만 표시되는 직렬화 지점이 있습니다. 이것은 정상입니다.</target>
        </trans-unit>
        <trans-unit id="40f27a2565b48c1f61edc1951aa27946b5ec4637" translate="yes" xml:space="preserve">
          <source>To turn a hostname into a human-readable plain IP address use getaddrinfo() to turn the hostname into a list of socket structures, then getnameinfo() on each one to make it a readable IP address again.</source>
          <target state="translated">호스트 이름을 사람이 읽을 수있는 일반 IP 주소로 바꾸려면 getaddrinfo ()를 사용하여 호스트 이름을 소켓 구조 목록으로 바꾸고 각 호스트에서 getnameinfo ()를 사용하여 다시 읽을 수있는 IP 주소로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="f7838aca863be2066e77c33f9ec760e481423363" translate="yes" xml:space="preserve">
          <source>To turn one string representation into another by mapping each character of the source string to its corresponding character in the result string. Not to be confused with translation: for example, Greek</source>
          <target state="translated">소스 문자열의 각 문자를 결과 문자열의 해당 문자에 매핑하여 한 문자열 표현을 다른 문자열 표현으로 변환합니다. 번역과 혼동하지 말 것 : 예 : 그리스어</target>
        </trans-unit>
        <trans-unit id="2796f222a72ab401559f8c49bff573c8aee5f84f" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt; . For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">내장 양식을 명확하게 참조하려면 내장 패키지 이름 앞에 특수 패키지 규정 자 &lt;code&gt;CORE::&lt;/code&gt; . 예를 들어, 말 &lt;code&gt;CORE::open()&lt;/code&gt; 항상 참조하는 내장 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , 현재 패키지라는 다른 서브 루틴 가져올 경우에도 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 다른 곳에서합니다. 일반적인 함수 호출처럼 보이지만 그렇지는 않습니다.이 경우 CORE :: 접두사는 Perl 구문의 일부이며 CORE 패키지의 내용에 관계없이 모든 키워드에 대해 작동합니다. 이를 참조하면 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; 은 일부 키워드에서만 작동합니다. &lt;a href=&quot;core&quot;&gt;핵심을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="734561318cece230eccec304d2226018e762ebff" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt;. For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;open()&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt;, only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">내장 양식을 명확하게 참조하려면 내장 이름 앞에 특수 패키지 규정 자 &lt;code&gt;CORE::&lt;/code&gt; 를 붙이십시오 . 예를 들어, 말 &lt;code&gt;CORE::open()&lt;/code&gt; 항상 참조하는 내장 &lt;code&gt;open()&lt;/code&gt; , 현재 패키지라는 다른 서브 루틴 가져올 경우에도 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 다른 곳에서합니다. 일반 함수 호출처럼 보이지만 그렇지 않습니다.이 경우 CORE :: 접두사는 Perl 구문의 일부이며 CORE 패키지의 내용에 관계없이 모든 키워드에 대해 작동합니다. 참조, 즉 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; 은 일부 키워드에서만 작동합니다. &lt;a href=&quot;core&quot;&gt;CORE를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="248423c43b116b150a001ee976cc646676062436" translate="yes" xml:space="preserve">
          <source>To uncompress</source>
          <target state="translated">압축을 풀려면</target>
        </trans-unit>
        <trans-unit id="218af45982210497e46e853ffef0192283629105" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1950&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.1950&quot;과 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="5ddcb357cfd2b7762051e66890c8b84e7d960611" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1951&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.1951&quot;과 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="0e932ba5dc24bfd784757a246bd08027f46d4625" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.Compressed&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.Compressed&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="29a087f9cfa51d4e0c2f6a475a11f449e63412aa" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.bz2&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.bz2&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="61aa1a4650d4e1d7c6939abfa456f5aeb3345d9a" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.gz&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.gz&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="2754edb3f14d19ed8eebfcca373f83ac4a3282e7" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 8과 15 사이의 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44083e3f2b591fd2c77505655cdb2c8f0aceb349" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceb9d1b68954b1740a461cdcd4976b0e567a28d9" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f170e414b119e7ad18faa1ef3905d7483fe9aa7c" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="translated">RFC 1951 데이터 스트림의 압축 을 &lt;code&gt;-MAX_WBITS&lt;/code&gt; &lt;code&gt;WindowBits&lt;/code&gt; 를 -MAX_WBITS로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="42e613bd86be8bd3cb751a2f5e9d0b238c337e5e" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f4fb6ffd8b0c13548ef465f1f6d2c2d688e65fd" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt;.</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)의 &lt;code&gt;WindowBits&lt;/code&gt; 을 &lt;code&gt;WANT_GZIP&lt;/code&gt; WindowBits 를 WANT_GZIP로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfba75b19db48553fce3ae8bd422d26a25e30031" translate="yes" xml:space="preserve">
          <source>To understand that, here is a description of how we make computers grok our characters.</source>
          <target state="translated">이를 이해하기 위해 여기에 컴퓨터가 캐릭터를 괴롭히는 방법에 대한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be309868d7c608c972ac92d2374d84d68bbcff87" translate="yes" xml:space="preserve">
          <source>To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on &quot;Troubleshooting these Examples&quot; for more information.</source>
          <target state="translated">어떤 종류의 비 호환성을 예상 할 수 있으며 드문 경우이지만 컴퓨터의 Perl 버전이이 문서보다 오래된 경우 자세한 내용은 &quot;이 예제 문제 해결&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b79315e2daa0488ef5b85ec7b3ded4c1bf9ff5d" translate="yes" xml:space="preserve">
          <source>To understand what the above</source>
          <target state="translated">위의 내용을 이해하려면</target>
        </trans-unit>
        <trans-unit id="84e6e80a4aa5a302f6ddaa79d242cdcf126f821b" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt; , whichever comes first. They provide functionality similar to what the functions &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; provide.</source>
          <target state="translated">여러 문자를 대문자 또는 소문자로 사용하려면 &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 를 사용 하여 패턴의 끝이나 다음에 나오는 &lt;code&gt;\E&lt;/code&gt; 중 가장 먼저 나타날 때까지 뒤에 오는 모든 문자를 소문자 / 대문자로 사용합니다 . &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 가 제공 하는 기능과 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21a1fe6cbffcae1c27b590bd9990080f83e9d683" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt;, which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt;, whichever comes first. They provide functionality similar to what the functions &lt;code&gt;lc&lt;/code&gt; and &lt;code&gt;uc&lt;/code&gt; provide.</source>
          <target state="translated">여러 문자를 대문자 또는 소문자로 표시하려면 &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 를 사용할 수 있습니다.이 문자는 패턴의 끝이나 &lt;code&gt;\E&lt;/code&gt; 중 먼저 오는 다음 발생까지 그 뒤에 오는 모든 문자를 소문자 / 대문자로합니다 . &lt;code&gt;lc&lt;/code&gt; 및 &lt;code&gt;uc&lt;/code&gt; 함수가 제공하는 것과 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd3b3ccd26f316b1795adeb89ffff2bedd268ce6" translate="yes" xml:space="preserve">
          <source>To use 'load_remote' or 'autoload_remote', specify at 'use'.</source>
          <target state="translated">'load_remote'또는 'autoload_remote'를 사용하려면 'use'에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8a5610b8c5bc5858528e5c0711e8cd5aeeeaeb22" translate="yes" xml:space="preserve">
          <source>To use &lt;b&gt;AutoLoader&lt;/b&gt;, the author of a module has to place the definitions of subroutines to be autoloaded after an &lt;code&gt;__END__&lt;/code&gt; token. (See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;.) The &lt;b&gt;AutoSplit&lt;/b&gt; module can then be run manually to extract the definitions into individual files</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하려면 모듈 작성자가 &lt;code&gt;__END__&lt;/code&gt; 토큰 다음에 자동로드 할 서브 루틴의 정의를 배치해야합니다 . ( &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; 참조 ) 그런 다음 &lt;b&gt;AutoSplit&lt;/b&gt; 모듈을 수동으로 실행하여 정의를 개별 파일로 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="09401632ee7edad8ed959974db2a06c3088b608d" translate="yes" xml:space="preserve">
          <source>To use Bzip2 compression, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Bzip2 압축을 사용하려면 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d246c1b4a8c6fc55969eb14bc150616f75299064" translate="yes" xml:space="preserve">
          <source>To use Getopt::Long from a Perl program, you must include the following line in your Perl program:</source>
          <target state="translated">Perl 프로그램에서 Getopt :: Long을 사용하려면 Perl 프로그램에 다음 행을 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="ca5f9362859e86ac853b5005fcaab143b5cd4fd8" translate="yes" xml:space="preserve">
          <source>To use LZMA compression, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">LZMA 압축을 사용하려면 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9dc12bf802050f20704badfc03f5cc7c4d321fc" translate="yes" xml:space="preserve">
          <source>To use Net::FTP, or any other module in the libnet distribution, through a SOCKS firewall you must create a socks-ified perl executable by compiling perl with the socks library.</source>
          <target state="translated">Net :: FTP 또는 libnet 배포의 다른 모듈을 사용하려면 SOCKS 방화벽을 통해 socks 라이브러리로 perl을 컴파일하여 socks-ified perl 실행 파일을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a708529644756357339b6bd4e7ce1cb0f6dc3ee" translate="yes" xml:space="preserve">
          <source>To use a here-document to assign an array, one line per element, you might use an approach like this:</source>
          <target state="translated">here-document를 사용하여 요소 당 한 줄씩 배열을 할당하려면 다음과 같은 접근법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d339f8f2813eea011c2650e8b1ed1fdac84e3d1c" translate="yes" xml:space="preserve">
          <source>To use a lexical subroutine from inside the subroutine itself, you must predeclare it. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; declaration.</source>
          <target state="translated">서브 루틴 자체 내에서 어휘 서브 루틴을 사용하려면 미리 선언해야합니다. &lt;code&gt;sub foo {...}&lt;/code&gt; 서브 루틴 정의 구문면 이전의 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 또는 &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="46735f54baf859d9a048ed8b3d013ded7487875d" translate="yes" xml:space="preserve">
          <source>To use adb, download the Android SDK from &lt;a href=&quot;https://developer.android.com/sdk/index.html&quot;&gt;https://developer.android.com/sdk/index.html&lt;/a&gt;. The &quot;SDK Tools Only&quot; version should suffice -- if you downloaded the ADT Bundle, you can find the sdk under</source>
          <target state="translated">adb를 사용하려면 &lt;a href=&quot;https://developer.android.com/sdk/index.html&quot;&gt;https://developer.android.com/sdk/index.html&lt;/a&gt; 에서 Android SDK를 다운로드 하십시오 . &quot;SDK 도구 전용&quot;버전이면 충분합니다. ADT 번들을 다운로드 한 경우 아래에서 sdk를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6c22616496274a8c0483ef0b81201680edefba" translate="yes" xml:space="preserve">
          <source>To use in your program as a pragma, merely invoke</source>
          <target state="translated">프로그램에서 pragma로 사용하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c9702d448044d584ba0f08cf12e0416ad038a1b6" translate="yes" xml:space="preserve">
          <source>To use it more practically, you have to give the names of encodings to check (</source>
          <target state="translated">보다 실용적으로 사용하려면 확인할 인코딩 이름을 지정해야합니다 (</target>
        </trans-unit>
        <trans-unit id="b4e86d7d6b51808534a6c222afc66338bce81e3d" translate="yes" xml:space="preserve">
          <source>To use ssh, you'll need to install and run a sshd app and set it up properly. There are several paid and free apps that do this rather easily, so you should be able to spot one on the store. Remember that Perl requires a passwordless connection, so set up a public key.</source>
          <target state="translated">ssh를 사용하려면 sshd 앱을 설치 및 실행하고 올바르게 설정해야합니다. 이 작업을 쉽게 수행 할 수있는 유료 및 무료 앱이 여러 개 있으므로 상점에서 하나를 찾을 수 있어야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ Perl에는 암호없는 연결이 필요하므로 공개 키를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="22588255917f935bc82a9b5e6907a6c5af5e0773" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters ( or use the c style '...' definition) like this:</source>
          <target state="translated">OVERLOAD : 키워드를 사용하려면 다음과 같이 3 개의 입력 매개 변수를 사용하거나 c 스타일 '...'정의를 사용하는 XS 함수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2eb14825f964f456a1059f994fc559fc5aaaa465" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters (or use the C-style '...' definition) like this:</source>
          <target state="translated">OVERLOAD : 키워드를 사용하려면 다음과 같이 세 개의 입력 매개 변수를 사용하는 XS 함수를 만듭니다 (또는 C 스타일 '...'정의 사용).</target>
        </trans-unit>
        <trans-unit id="3dc634fc1f1bc1b5d00fde6bff6b384f2eeb3f97" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , e.g.</source>
          <target state="translated">: 펄을 사용하려면 당신은 당신이 당신의 PATH 환경 변수에 새 항목을 추가해야합니다 설치 &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , 예를 들어,</target>
        </trans-unit>
        <trans-unit id="c6290d7b4a4817dd1a944f6b3cabef3b11fd0b36" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt;, e.g.</source>
          <target state="translated">방금 설치 한 Perl을 사용하려면 PATH 환경 변수에 새 항목을 추가해야합니다. &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , 예 :</target>
        </trans-unit>
        <trans-unit id="7bc829cf0e8a5c97f97a31b7c617e9428478c19b" translate="yes" xml:space="preserve">
          <source>To use the forked debugger, you need to have the default display set to an X-11 Server and some environment variables set that Unix expects.</source>
          <target state="translated">분기 된 디버거를 사용하려면 기본 디스플레이를 X-11 서버로 설정하고 일부 환경 변수를 Unix에서 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc207fecfdae515e813f72872e49086f5b78c28e" translate="yes" xml:space="preserve">
          <source>To use the module it is necessary to do the following:</source>
          <target state="translated">모듈을 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd4bd0185af39ed243608e8976fc475a01dc61d4" translate="yes" xml:space="preserve">
          <source>To use this expiration policy, the user would say</source>
          <target state="translated">이 만료 정책을 사용하기 위해 사용자는</target>
        </trans-unit>
        <trans-unit id="538ca1c3044001d3cfa088cc4be7d0f4954981d6" translate="yes" xml:space="preserve">
          <source>To use this method you must have the Digest::MD5 or the MD5 module installed, otherwise this method will return</source>
          <target state="translated">이 방법을 사용하려면 Digest :: MD5 또는 MD5 모듈이 설치되어 있어야합니다. 그렇지 않으면이 방법이</target>
        </trans-unit>
        <trans-unit id="b3ee11508a4f000324b572266622a1fcc5b08715" translate="yes" xml:space="preserve">
          <source>To use this performance boost, set the current directory via</source>
          <target state="translated">이 성능 향상을 사용하려면 다음을 통해 현재 디렉토리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acb718902c4afb0dc31c479abac33d68d277ca9d" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;&quot;warn&quot;&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 경고하려면 &lt;a href=&quot;#warn&quot;&gt;&quot;warn&quot;&lt;/a&gt; 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="38c026c273aff885d8062765e295cb0676868f0f" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 &lt;a href=&quot;#warn&quot;&gt;경고&lt;/a&gt; 하려면 경고 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="be15e0c4892f05af6b92d2d4a6be1a0a5f9a6dcd" translate="yes" xml:space="preserve">
          <source>To watch the tail of a dynamically growing logfile, (from the command line):</source>
          <target state="translated">동적으로 증가하는 로그 파일의 꼬리를 보려면 (명령 줄에서) :</target>
        </trans-unit>
        <trans-unit id="a70297b48e7206cae4fcb0090dd44f6d0f3207a8" translate="yes" xml:space="preserve">
          <source>To work around this bug, surround the code with a second set of braces. This creates an inner block that defeats the &lt;code&gt;MULTICALL&lt;/code&gt; logic, and does get fresh SVs allocated each time:</source>
          <target state="translated">이 버그를 해결하려면 코드를 두 번째 중괄호로 묶습니다. 이것은 &lt;code&gt;MULTICALL&lt;/code&gt; 논리 를 물리 치는 매번 내부 블록을 생성하고 매번 새로운 SV를 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="df77a0e9f9993c56d24066721ca0f8c51a0345d4" translate="yes" xml:space="preserve">
          <source>To work around this, set environment variables as part of the</source>
          <target state="translated">이 문제를 해결하려면 환경 변수를</target>
        </trans-unit>
        <trans-unit id="67bc56a45c2b844733bf04f643db3f4d6359ddb1" translate="yes" xml:space="preserve">
          <source>To work with only alphanumeric sequences (including underscores), you might consider</source>
          <target state="translated">영숫자 시퀀스 (밑줄 포함)로만 작업하려면 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="737fcabd51bb1faacb7059e47b96e0c587be8c5f" translate="yes" xml:space="preserve">
          <source>To write a test for your new (and probably not even done) module, create a new file called</source>
          <target state="translated">새로운 모듈에 대한 테스트를 작성하려면 (아마도 수행되지 않은) 모듈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="02bfda7919e7b9ec9d9ea9a01639287be236928c" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt; , see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">쓰기 플랫폼 독립적 인 코드하려면 사용합니다 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 대신, 같은 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 또는 &lt;code&gt;\N{U+001B}&lt;/code&gt; 참조 &lt;a href=&quot;charnames&quot;&gt;charnames을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c88d87a2cc45115c74eeb5e575d4bb12e18a967" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt;, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">쓰기 플랫폼 독립적 인 코드하려면 사용합니다 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 대신, 같은 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 또는 &lt;code&gt;\N{U+001B}&lt;/code&gt; 참조 &lt;a href=&quot;charnames&quot;&gt;charnames을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32379df686c78a3422056dcfb4c9b1da18747d64" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt; . For example:</source>
          <target state="translated">사용 가능한 Perl 변수를 생성하기 위해 변수 구문의 일부가 아닌 문자는 밑줄로 변환됩니다. 예를 들어 &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 변수를 설정합니다 . 이 변수는 반드시 &lt;code&gt;main&lt;/code&gt; 이 아니라 호출 프로그램의 네임 스페이스에 상주합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a049b042bf8f7cb4d234fc89dd589815ab07f9de" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-return&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt;. Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt;. For example:</source>
          <target state="translated">사용 가능한 Perl 변수를 생성하기 위해 변수 구문의 일부가 아닌 문자는 밑줄로 변환됩니다. 예를 들어, &lt;code&gt;--fpp-struct-return&lt;/code&gt; 은 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 변수를 설정합니다 . 이 변수는 반드시 &lt;code&gt;main&lt;/code&gt; 이 아니라 호출 프로그램의 네임 스페이스에 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af2824d2ae2117d9a03cba6d58d8adc173a02e61" translate="yes" xml:space="preserve">
          <source>To%s: illegal mapping '%s'</source>
          <target state="translated">To % s : 잘못된 매핑 '% s'</target>
        </trans-unit>
        <trans-unit id="33224443be18843a7174975c46578d74787bc749" translate="yes" xml:space="preserve">
          <source>Tobias Brox, tobiasb@tobiasb.funcom.com</source>
          <target state="translated">토비아스 브록 스, tobiasb@tobiasb.funcom.com</target>
        </trans-unit>
        <trans-unit id="57a4f395602ffbc6392e66ae2e2c5974770b3c0a" translate="yes" xml:space="preserve">
          <source>Todo tests</source>
          <target state="translated">할일 테스트</target>
        </trans-unit>
        <trans-unit id="ec7a57e5883d57c428d8e15819e5060eeed56435" translate="yes" xml:space="preserve">
          <source>Together, these categories go a long way towards being able to customize a single program to run in many different locations. But there are deficiencies, so keep reading.</source>
          <target state="translated">이러한 범주는 하나의 프로그램을 여러 다른 위치에서 실행하도록 사용자 정의 할 수 있도록 먼 길을 가고 있습니다. 그러나 결함이 있으므로 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6f1eb05b47fbf56bdd9586b2ff6beeffab4ce59f" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the historical &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, which has (at least) two bugs in it, that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">이 두 기능은 함께 기존 프로그램을 깨지 않고 쉽게 고칠 수없는 적어도 두 개의 버그가 있는 과거 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 기능 을 대체하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4ce897ee72e1aab169ad26b4888dec08e507c975" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the legacy string &lt;code&gt;eval&lt;/code&gt; function, which behaves problematically in some instances. They are available starting with Perl 5.16, and are enabled by default by a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration.</source>
          <target state="translated">이 두 기능은 일부 경우에 문제가 발생 하는 레거시 문자열 &lt;code&gt;eval&lt;/code&gt; 함수 를 대체하기위한 것 입니다. Perl 5.16부터 사용할 수 있으며 기본적으로 &lt;code&gt;use 5.16&lt;/code&gt; 이상의 선언을 사용 하여 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="751e44ad1c63d964b7e27098dbfa3f7faca67a2f" translate="yes" xml:space="preserve">
          <source>Toggle buffered status.</source>
          <target state="translated">버퍼링 된 상태를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="5379fd6502d08f80951bb93415834c8443e36cd5" translate="yes" xml:space="preserve">
          <source>Toggle trace mode (see also the &lt;code&gt;AutoTrace&lt;/code&gt; option). Optional argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent.</source>
          <target state="translated">추적 모드 토글 (또한 참조 &lt;code&gt;AutoTrace&lt;/code&gt; 옵션을). 선택적 인수는 현재 레벨 아래에서 추적 할 최대 레벨 수입니다. 그보다 더 깊은 것은 침묵 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f422da5828ccca294dcf6d07ee5efb74761f28a1" translate="yes" xml:space="preserve">
          <source>Tokens from Pod::Simple::PullParser</source>
          <target state="translated">포드 :: Simple :: PullParser의 토큰</target>
        </trans-unit>
        <trans-unit id="e3f27977b0cf7c5ef1db648369c2aa76bc8a767d" translate="yes" xml:space="preserve">
          <source>Tokens of an RPN expression may be separated by whitespace, but such separation is usually not required. It is required only where unseparated tokens would look like a longer token. For example, &lt;code&gt;12 34 +&lt;/code&gt; can be written as &lt;code&gt;12 34+&lt;/code&gt;, but not as &lt;code&gt;1234 +&lt;/code&gt;.</source>
          <target state="translated">RPN 식의 토큰은 공백으로 구분할 수 있지만 일반적으로 이러한 구분은 필요하지 않습니다. 분리되지 않은 토큰이 더 긴 토큰처럼 보이는 경우에만 필요합니다. 예를 들어, &lt;code&gt;12 34 +&lt;/code&gt; 는 &lt;code&gt;12 34+&lt;/code&gt; 로 쓸 수 있지만 &lt;code&gt;1234 +&lt;/code&gt; 로 쓸 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="685cbbd2434336a1c0d592cb5e469ec23061ee59" translate="yes" xml:space="preserve">
          <source>Tom Christiansen</source>
          <target state="translated">톰 크리스티안 슨</target>
        </trans-unit>
        <trans-unit id="8be2aa955349ba9da124a5ab00db7e6f88ee861a" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;</source>
          <target state="translated">톰 크리스티안 슨 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca9f204e050f14afeeca056eec19f3529541293" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; wrote this, with occasional kibbitzing from Larry Wall and Jeffrey Friedl in the background.</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;은 Larry Wall과 Jeffrey Friedl의 백그라운드에서 가끔씩 kibbitzing하여 이것을 썼습니다.</target>
        </trans-unit>
        <trans-unit id="8e134c4a6e79e76b0db622556fcf6a08eb055742" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original perlfaq then expanded it with the help of Nat Torkington. brian d foy substantially edited and expanded the perlfaq. perlfaq-workers and others have also supplied feedback, patches and corrections over the years.</source>
          <target state="translated">Tom Christiansen은 원래 perlfaq을 작성한 다음 Nat Torkington의 도움으로 확장했습니다. brian d foy는 실질적으로 perlfaq을 편집하고 확장했습니다. perlfaq-workers 및 기타 사람들은 수년 동안 피드백, 패치 및 수정 사항을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="13f0322dc66b8435d53d03e97ab3bdb9a5e08c67" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original version of this document. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; wrote this version. See the individual perlfaq documents for additional copyright information.</source>
          <target state="translated">Tom Christiansen은이 문서의 원본을 썼습니다. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; 가이 버전을 썼습니다. 추가 저작권 정보는 개별 perlfaq 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="594631f752605ca51961fa701a3edb58acb263cd" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="95a03ceecd01437e5e0609dbfa8dc64983a0ce69" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, with occasional vestiges of Larry Wall's original version and suggestions from the Perl Porters.</source>
          <target state="translated">Tom Christiansen, Larry Wall의 원본 버전과 Perl Porters의 제안을 간혹 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86f2b4b3ae91b418a1683a4b91e72d3ad71dd15f" translate="yes" xml:space="preserve">
          <source>Tom Hukins &amp;lt;tom@eborcom.com&amp;gt;</source>
          <target state="translated">Tom Hukins &amp;lt;tom@eborcom.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e834545bca77fe29ecc8dac8de115465b8dcd679" translate="yes" xml:space="preserve">
          <source>Tom Lutz &amp;lt;</source>
          <target state="translated">톰 루츠 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="476ccb2f91007a71136d530d51755067de803643" translate="yes" xml:space="preserve">
          <source>Tom Phoenix, &amp;lt;</source>
          <target state="translated">톰 피닉스, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0d331f4232946333d8f1366dd1d47c9f81d210b2" translate="yes" xml:space="preserve">
          <source>Tomas Doran &amp;lt;bobtfish@bobtfish.net&amp;gt;</source>
          <target state="translated">토마스 도란 &amp;lt;bobtfish@bobtfish.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="28c9ef80202c4539b6ea96fa83f4e8656550b386" translate="yes" xml:space="preserve">
          <source>Tomohiro Hosaka &amp;lt;bokutin@bokut.in&amp;gt;</source>
          <target state="translated">호사카 토모히로 &amp;lt;bokutin@bokut.in&amp;gt;</target>
        </trans-unit>
        <trans-unit id="793b4a701cfe0913d08894024037c7429f46b186" translate="yes" xml:space="preserve">
          <source>Tony Cook &amp;lt;tony@develop-help.com&amp;gt;</source>
          <target state="translated">Tony Cook &amp;lt;tony@develop-help.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="60b01674cdd852dec165a416e0496fa965e8b91a" translate="yes" xml:space="preserve">
          <source>Too deeply nested ()-groups</source>
          <target state="translated">너무 깊게 중첩 된 ()-그룹</target>
        </trans-unit>
        <trans-unit id="1db6f1ae51bb58b9a4860785d43a21467f4cbb8c" translate="yes" xml:space="preserve">
          <source>Too few args to syscall</source>
          <target state="translated">syscall에 너무 적은 인수</target>
        </trans-unit>
        <trans-unit id="2364f2f117108b7557a903b349dc899cf3b08e9e" translate="yes" xml:space="preserve">
          <source>Too few arguments for subroutine '%s'</source>
          <target state="translated">서브 루틴 '% s'에 대한 인수가 너무 적습니다.</target>
        </trans-unit>
        <trans-unit id="ba42647932e0b5434947f286f404459ce1a76e83" translate="yes" xml:space="preserve">
          <source>Too few records will be retrieved.</source>
          <target state="translated">검색 할 레코드가 너무 적습니다.</target>
        </trans-unit>
        <trans-unit id="ff02d866660d5b53534c080f1fcb0457f7d00d24" translate="yes" xml:space="preserve">
          <source>Too late for &quot;-%s&quot; option</source>
          <target state="translated">&quot;-% s&quot;옵션에 너무 늦었습니다.</target>
        </trans-unit>
        <trans-unit id="769c54b58dcbc8ae188a5471b5a9ac818add3700" translate="yes" xml:space="preserve">
          <source>Too late to run %s block</source>
          <target state="translated">% s 블록을 실행하기에는 너무 늦었습니다.</target>
        </trans-unit>
        <trans-unit id="b3e03f0741d093e7b4fe7029e12428aa7a386bc5" translate="yes" xml:space="preserve">
          <source>Too many ('s</source>
          <target state="translated">너무 많은 ( 's</target>
        </trans-unit>
        <trans-unit id="db44b7d3a550f69ac66850f32920ad09e8328651" translate="yes" xml:space="preserve">
          <source>Too many )'s</source>
          <target state="translated">)가 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="9155bcdc24c3728c4025b090f8ec51766e724176" translate="yes" xml:space="preserve">
          <source>Too many args to syscall</source>
          <target state="translated">syscall에 너무 많은 인수</target>
        </trans-unit>
        <trans-unit id="3f95368fd6442a537ee2dd900f3e1bb4d5350d08" translate="yes" xml:space="preserve">
          <source>Too many arguments for %s</source>
          <target state="translated">% s에 대한 인수가 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="e4091f54a0813795be4fd20124afb6c89bed7942" translate="yes" xml:space="preserve">
          <source>Too many arguments for subroutine '%s'</source>
          <target state="translated">서브 루틴 '% s'에 대한 인수가 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="ef15ae49ed8dd79937ceab5a3d6972af6ced0871" translate="yes" xml:space="preserve">
          <source>Too many nested open parens in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에 중첩 된 열린 괄호가 너무 많습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="0f85c6fbc6b17f4b329c823a126de114fb51f097" translate="yes" xml:space="preserve">
          <source>Too many will be retrieved.</source>
          <target state="translated">너무 많이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="2f4169d30e0802a9d8a3d39c5549f0963dd393e1" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; SDK</source>
          <target state="translated">도구 및 SDK</target>
        </trans-unit>
        <trans-unit id="2d26e7b7bd96209071fc6ad7cab1a93d4b45e8bf" translate="yes" xml:space="preserve">
          <source>Tools to compile Perl modules</source>
          <target state="translated">Perl 모듈 컴파일 도구</target>
        </trans-unit>
        <trans-unit id="f0ad973010edc9e98f2f60aa9dbfdb7b904996da" translate="yes" xml:space="preserve">
          <source>Tools used by Test2 and friends.</source>
          <target state="translated">Test2와 친구들이 사용하는 도구.</target>
        </trans-unit>
        <trans-unit id="a00a8f35172e2849241ce00e52e7b7a9a0047d25" translate="yes" xml:space="preserve">
          <source>Top of Form Processing</source>
          <target state="translated">양식 처리 상단</target>
        </trans-unit>
        <trans-unit id="ee80479b0fa9a2d2efdf0ff5851a9a2f37c4056d" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &quot;_TOP&quot; appended, or &quot;top&quot; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;code&gt;$^&lt;/code&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;code&gt;$-&lt;/code&gt; , which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">맨 위 양식 처리가 자동으로 처리됩니다. 현재 페이지에 형식화 된 레코드를위한 공간이 충분하지 않은 경우 양식 피드를 작성하여 페이지가 진행되고 특수한 맨 위 형식이 새 페이지 머리글을 형식화하기 위해 사용됩니다. 기록이 작성됩니다. 기본적으로 페이지 상단 형식은 &quot;_TOP&quot;가 추가 된 파일 핸들의 이름이거나 전자 패키지가없는 경우 현재 패키지에서 &quot;top&quot;입니다. 이는 자동 활성화 된 파일 핸들에 문제가 될 수 있지만 해당 파일 핸들을 선택한 상태 에서 &lt;code&gt;$^&lt;/code&gt; 변수에 이름을 지정하여 선택한 형식으로 동적으로 설정 될 수 있습니다 . 현재 페이지에 남아있는 줄 수는 변수 &lt;code&gt;$-&lt;/code&gt; 에 있으며 새 페이지를 강제 실행 하기 위해 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f10b9e66ec3cf51c0d1a7e3d006886e22937c14a" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended, or &lt;code&gt;top&lt;/code&gt; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;a href=&quot;perlvar#%24%5E&quot;&gt;&lt;code&gt;$^&lt;/code&gt;&lt;/a&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;a href=&quot;perlvar#%24-&quot;&gt;&lt;code&gt;$-&lt;/code&gt;&lt;/a&gt;, which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">양식 상단 처리는 자동으로 처리됩니다. 현재 페이지에 서식이 지정된 레코드를위한 공간이 충분하지 않은 경우 양식 피드를 작성하여 페이지를 진행하고 특수 페이지 상단 형식을 사용하여 새 페이지 머리글의 형식을 지정합니다. 기록이 기록됩니다. 기본적으로 페이지 상단 형식은 &lt;code&gt;_TOP&lt;/code&gt; 가 추가 된 파일 핸들의 이름 이거나 전자가없는 경우 현재 패키지의 &lt;code&gt;top&lt;/code&gt; 입니다. 이것은 자동 생성 된 파일 핸들에 문제가 될 수 있지만 해당 파일 핸들이 선택되는 동안 &lt;a href=&quot;perlvar#%24%5E&quot;&gt; &lt;code&gt;$^&lt;/code&gt; &lt;/a&gt; 변수에 이름을 할당하여 선택한 형식으로 동적으로 설정 될 수 있습니다 . 현재 페이지에 남아있는 행 수는 &lt;a href=&quot;perlvar#%24-&quot;&gt; &lt;code&gt;$-&lt;/code&gt; &lt;/a&gt; 변수에 있으며 새 페이지를 강제 로 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
