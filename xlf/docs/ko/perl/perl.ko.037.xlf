<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="0e07d4919d304923f37fe1dc7b33e0707c964ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 활성화되어 잘 형성 UTF8 문자와 UTF8 경고 가리 키지 않는 제로가 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 은 (경우 설정 &lt;code&gt;retlen&lt;/code&gt; 는 -1 NULL이 아닌). 이러한 경고가 꺼져 있으면 잘 정의 된 경우 계산 된 값 (또는 그렇지 않은 경우 Unicode REPLACEMENT CHARACTER)이 자동으로 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 변형되지 않은 문자를 시작할 수 있는 &lt;code&gt;s&lt;/code&gt; 의 다음 가능한 위치 . REPLACEMENT CHARACTER가 반환 &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;되는시기에&lt;/a&gt; 대한 자세한 내용 은 perlapi의 &quot;utf8n_to_uvchr&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="344a52db4b11baa26a523460842709ff1b386ede" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;s&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 -1 NULL을 가리키고 있지 않음). 이러한 경고가 꺼져 있으면 잘 정의 된 경우 계산 된 값 (또는 그렇지 않은 경우 Unicode REPLACEMENT CHARACTER)이 자동으로 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 변형되지 않은 문자를 시작할 수 있는 &lt;code&gt;s&lt;/code&gt; 의 다음 가능한 위치 . REPLACEMENT CHARACTER가 반환 &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;되는시기에&lt;/a&gt; 대한 자세한 내용 은 perlapi의 &quot;utf8n_to_uvchr&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ee7a15600127f4d0959a8f8bcd7fe929dc1bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;s&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 -1). 이러한 경고가 꺼져 있으면 잘 정의 된 경우 계산 된 값 (또는 그렇지 않은 경우 Unicode REPLACEMENT CHARACTER)이 자동으로 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 변형되지 않은 문자를 시작할 수 있는 &lt;code&gt;s&lt;/code&gt; 의 다음 가능한 위치 . REPLACEMENT CHARACTER가 반환되는시기에 대한 자세한 내용 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba0fe2f6810522d3880f034d6ed2e0c1aaeec082" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_locale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;set_locale()&lt;/code&gt; 어떤 이유로 실패 (예를 들어, 시스템에 로케일 알 수없는 세트에 시도), 카테고리에 대한 로케일을 변경하고, 함수가 반환되지 않은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00fbad40868135a15b1b3119d64c803fbf76e3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setlocale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;setlocale()&lt;/code&gt; 어떤 이유로 실패 (예를 들어, 시스템에 로케일 알 수없는 세트에 시도), 카테고리에 대한 로케일을 변경하고, 함수가 반환되지 않은 &lt;code&gt;undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7def84ba14c7da181889f798540180404e1bc96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setmagic&lt;/code&gt; is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. &lt;code&gt;'local $x = $y'&lt;/code&gt;), and that will handle the magic.</source>
          <target state="translated">경우 &lt;code&gt;setmagic&lt;/code&gt; 이 거짓 후 정해진 마법은 새로운 (빈) SV에서 호출되지 않습니다. 이것은 일반적으로 할당이 곧 이어지고 (예 : &lt;code&gt;'local $x = $y'&lt;/code&gt; ) 마법을 처리 할 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6f1f3673ad86da277d3ff5d2cf4aee1d0694c871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;split&lt;/code&gt; is invoked as &lt;code&gt;split ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;split(' ', $_)&lt;/code&gt;, see &lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">경우 &lt;code&gt;split&lt;/code&gt; 로 호출 &lt;code&gt;split ' '&lt;/code&gt; (정말 의미 또는 인수가없는 &lt;code&gt;split(' ', $_)&lt;/code&gt; 참조 &lt;a href=&quot;perlfunc#split&quot;&gt;분할&lt;/a&gt; ), 펄이 플래그를 설정합니다. 그런 다음 정규식 엔진은이를 확인하고 SKIPWHITE 및 WHITE extflags를 설정할 수 있습니다. 이를 위해 Perl 엔진은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6d3fb59ce22521f54bad3dad454399653c576366" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start_color&lt;/code&gt; is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If &lt;code&gt;end_color&lt;/code&gt; is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">경우 &lt;code&gt;start_color&lt;/code&gt; (있는 경우) 다음은 개방 견적 후 삽입됩니다 null이 아닌하지만 탈출 텍스트 앞에이다. &lt;code&gt;end_color&lt;/code&gt; 가 널이 아닌 경우 이스케이프 된 텍스트 뒤에 따옴표 나 줄임표 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f49431f91057c4dbcea93169afee875e80cb6ef1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; already is UTF-8 (or if it is not &lt;code&gt;POK&lt;/code&gt;), or if &lt;code&gt;encoding&lt;/code&gt; is not a reference, nothing is done to &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;encoding&lt;/code&gt; is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">경우 &lt;code&gt;sv&lt;/code&gt; 이미 UTF-8 (또는 그렇지 않은 경우 &lt;code&gt;POK&lt;/code&gt; ), 또는 경우에 &lt;code&gt;encoding&lt;/code&gt; 기준 아닌, 아무것도 행해지 지 않는다에 &lt;code&gt;sv&lt;/code&gt; . 경우 &lt;code&gt;encoding&lt;/code&gt; 아니 어서 &lt;code&gt;Encode::XS&lt;/code&gt; 인코딩 객체 좋지 않은 일이 발생할 것이다. (보다</target>
        </trans-unit>
        <trans-unit id="04ffb889ba3672c819c8ebc2556d3ca7f2216415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; . Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 가 아직 마법이 아닌 경우 Perl은 &lt;code&gt;SvUPGRADE&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;sv&lt;/code&gt; 를 유형 &lt;code&gt;SVt_PVMG&lt;/code&gt; 로 변환 합니다. 그런 다음 Perl은 연결된 마법 기능 목록의 시작 부분에 새로운 마법을 추가합니다. 동일한 유형의 매직을 입력하면 삭제됩니다. 이를 재정의 할 수 있으며 동일한 유형의 매직의 여러 인스턴스를 SV와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab681f247e800a443c2ee4cb6d285861bd3cf7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt;. Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 가 아직 마 법적이지 않은 경우 Perl은 &lt;code&gt;SvUPGRADE&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;sv&lt;/code&gt; 를 &lt;code&gt;SVt_PVMG&lt;/code&gt; 유형 으로 변환 합니다. Perl은 계속해서 마법 기능의 링크 된 목록의 시작 부분에 새로운 마법을 추가합니다. 동일한 유형의 마법에 대한 이전 항목은 모두 삭제됩니다. 이것은 재정의 될 수 있으며 동일한 유형의 마법의 여러 인스턴스가 SV와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc4779d92424b9ed1e872ef029dc61c2a85f827" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 가 약한 참조의 대상 이면 sv 와 관련된 역 참조 구조를 반환합니다. 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f965fbaf23253043bd3c46cbaac3045ccac1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;system&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt;, then it uses &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">경우 &lt;code&gt;system&lt;/code&gt; 에 대한 인수로 지정 &lt;code&gt;autodie&lt;/code&gt; , 그것은 사용하는 &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC :: 시스템 :: 간단한&lt;/a&gt; 무거운 리프팅을 할 수 있습니다. 자세한 내용은 해당 모듈에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0b89db42e4e190758019494213d834ead62fc5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tgtsv&lt;/code&gt; is non-null then the string will be written into that SV (overwriting existing content) and it will be returned. If &lt;code&gt;tgtsv&lt;/code&gt; is a null pointer then the string will be written into a new mortal SV which will be returned.</source>
          <target state="translated">경우 &lt;code&gt;tgtsv&lt;/code&gt; 은 다음 문자열이 그 SV에 기록 될 것입니다 null이 아닌이 (기존 내용을 덮어 쓰기)과가 반환됩니다. 경우 &lt;code&gt;tgtsv&lt;/code&gt; 은 다음 문자열이 반환됩니다 새로운 인간 SV에 기록 될 것이다 널 포인터이다.</target>
        </trans-unit>
        <trans-unit id="c5c3008df77cfa39eeaefce991da14fbe22117ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;u1&lt;/code&gt; 사실, 문자열 &lt;code&gt;s1&lt;/code&gt; UTF-8 인코딩 유니 것으로 가정되고; 그렇지 않으면 네이티브 8 비트 인코딩으로 가정합니다. &lt;code&gt;s2&lt;/code&gt; 와 관련하여 &lt;code&gt;u2&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f5369cdc9e4df17df0fab9c265cc2a668b2d5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;u1&lt;/code&gt; 사실, 문자열 &lt;code&gt;s1&lt;/code&gt; UTF-8 인코딩 유니 것으로 가정되고; 그렇지 않으면 기본 8 비트 인코딩으로 간주됩니다. 상응 대한 &lt;code&gt;u2&lt;/code&gt; 에 대한 &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff7ae9da7000e2b33b5ec7b9b74b0d3b4543ad4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt;) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt;) is ordered after &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt;. In this point, &lt;code&gt;(normalization =&amp;gt; undef, preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;undef&lt;/code&gt; (안 문자열 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; )이 키 값으로 명시 적으로 전달되고, 어떤 정상화는 (모든 정상화가 요구되지 않은 경우이 쉽게 재봉 할 수 있습니다) 수행되지 않습니다. 에서 &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; 만 연속 수축 해결; 경우에도 예를 들면 &lt;code&gt;A-ring&lt;/code&gt; (및 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) 후 주문한 &lt;code&gt;Z&lt;/code&gt; 는 , &lt;code&gt;A-cedilla-ring&lt;/code&gt; 동일한 기본 것이다 . 이 시점에서 &lt;code&gt;(normalization =&amp;gt; undef, preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt; &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; 와 동일 &lt;b&gt;하지 않습니다&lt;/b&gt; . &lt;code&gt;A&lt;/code&gt; &lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1772452ed00715f0d1bcb6cc8461b97a45b8aa33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 파일을 읽지 않습니다 (하지만 &lt;code&gt;entry&lt;/code&gt; 를 통해 데이터 정렬 요소를 정의 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="1540dc791175456aa90cb4fef436e0dad501ecf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 한글 음절의 가중치는 한글 자모로 분해되지 않고 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 에서 한글 음절의 무게 정의 는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="87a9ff2f9d0e73da828c40d03f80e90b35d67f88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt; (see &lt;a href=&quot;perlrun#-Dletters&quot;&gt;&lt;b&gt;-D&lt;/b&gt; flags in perlrun&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;use Devel::Peek&lt;/code&gt; 지시자가있다 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 인수를,이 연산 코드 파견의 디버깅에 전환합니다. &lt;code&gt;FLAGS&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 의 조합이어야합니다 ( &lt;a href=&quot;perlrun#-Dletters&quot;&gt;perlrun의 &lt;/a&gt;&lt;b&gt;-D&lt;/b&gt; 플래그 참조 ).</target>
        </trans-unit>
        <trans-unit id="8e67b351362fc2288e4d85d1df0a7cb4397d6517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">경우 &lt;code&gt;use bytes&lt;/code&gt; 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="b63d1c4b73014a212e1adcb7458310fbabfcada8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) is in force then signed C integers are used (</source>
          <target state="translated">경우에 &lt;code&gt;use integer&lt;/code&gt; (참조 &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;정수 산술&quot;&lt;/a&gt; )의 힘에 다음 서명 C 정수가 사용됩니다 (</target>
        </trans-unit>
        <trans-unit id="055cb8f0eb7094e6bf1d58d9d0a382f3cec04e19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is disabled, then the result is also correctly encoded in those character sets (as both are proper subsets of Unicode, meaning that a Unicode string with all character values &amp;lt; 256 is the same thing as a ISO-8859-1 string, and a Unicode string with all character values &amp;lt; 128 is the same thing as an ASCII string in Perl).</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; 이 비활성화 된 경우 결과는 해당 문자 집합에서도 올바르게 인코딩됩니다 (둘 다 유니 코드의 적절한 하위 집합이므로 모든 문자 값이 256 미만인 유니 코드 문자열은 ISO-8859-1 문자열과 동일하며 모든 문자 값이 128 미만인 유니 코드 문자열은 Perl의 ASCII 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="91b6b629aef61b3ce3a48a95ca6e7795616126f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is enabled, you still get a correct UTF-8-encoded string, regardless of these flags, just some more characters will be escaped using &lt;code&gt;\uXXXX&lt;/code&gt; then before.</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; 이 활성화 된 경우 에도 이러한 플래그에 관계없이 올바른 UTF-8 인코딩 문자열을 얻을 수 있으며 이전보다 &lt;code&gt;\uXXXX&lt;/code&gt; 를 사용하여 더 많은 문자 만 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac03d59f846f562239a0cc40bb258a33efc729e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and &lt;code&gt;UNICODE_WARN_SURROGATE&lt;/code&gt; is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead &lt;code&gt;UNICODE_DISALLOW_SURROGATE&lt;/code&gt; is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">경우 &lt;code&gt;uv&lt;/code&gt; 유니 코드 서로 게이트 코드 포인트이며 &lt;code&gt;UNICODE_WARN_SURROGATE&lt;/code&gt; 가 설정되고, 함수는 경고, 제공 UTF8 경고가 활성화를 올릴 것이다. 대신 &lt;code&gt;UNICODE_DISALLOW_SURROGATE&lt;/code&gt; 가 설정되면 함수가 실패하고 NULL을 반환합니다. 두 플래그가 모두 설정되면 함수는 경고를 표시하고 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcb599464a46f537e87d3017df24f3e8e2283ffd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">경우 &lt;code&gt;uv&lt;/code&gt; 유니 코드 서로 게이트 코드 포인트이며 UNICODE_WARN_SURROGATE를 설정, 함수는 경고, 제공 UTF8 경고가 활성화를 올릴 것이다. 대신 UNICODE_DISALLOW_SURROGATE가 설정되면 함수는 실패하고 NULL을 반환합니다. 두 플래그가 모두 설정되면 함수는 경고를 표시하고 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c44318124964ccd942d87918bc5a4d0e5a866fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;val&lt;/code&gt; is true, do not print any errors/warnings.</source>
          <target state="translated">경우 &lt;code&gt;val&lt;/code&gt; 사실, 오류 / 경고를 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae30129230a55488ef814c14253472811e67904d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; in</source>
          <target state="translated">만약 &lt;code&gt;value&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="02c3454635e56b23178636e2bb6aec32fcd96776" translate="yes" xml:space="preserve">
          <source>If @DynaLoader::dl_resolve_using contains &lt;code&gt;-L*&lt;/code&gt; or &lt;code&gt;-l*&lt;/code&gt; entries then Mkbootstrap will automatically add a dl_findfile() call to the generated &lt;code&gt;*.bs&lt;/code&gt; file.</source>
          <target state="translated">@DynaLoader :: dl_resolve_using에 &lt;code&gt;-L*&lt;/code&gt; 또는 &lt;code&gt;-l*&lt;/code&gt; 항목이 포함되어 있으면 Mkbootstrap 은 생성 된 &lt;code&gt;*.bs&lt;/code&gt; 파일에 dl_findfile () 호출을 자동으로 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="203a87ac5779da1d943be09c716f0304a892b601" translate="yes" xml:space="preserve">
          <source>If @args is not given, an empty list will be used.</source>
          <target state="translated">@args를 지정하지 않으면 빈 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3523d8b4dddaad91344458f88af994bb31e6c10" translate="yes" xml:space="preserve">
          <source>If @imports are given, they are passed through to the use. So this:</source>
          <target state="translated">@imports가 제공되면 사용으로 전달됩니다. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="649b9ffd5b70f81915b08f4bc8291a1a2ce523f9" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">@suffixes가 주어지면 각 요소는 $ filename의 끝과 일치 하는 패턴 (문자열 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; )입니다. 일치하는 부분이 제거되고 $ suffix가됩니다.</target>
        </trans-unit>
        <trans-unit id="352f4bf8960a2fcba781ac944722d04a3329314f" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;qr//&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">@suffixes가 주어지면 각 요소는 $ filename의 끝과 일치 하는 패턴 (문자열 또는 &lt;code&gt;qr//&lt;/code&gt; )입니다. 일치하는 부분이 제거되고 $ suffix가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4498a59b542ad3816d9e8760461f7daf1fdeee5" translate="yes" xml:space="preserve">
          <source>If ATTR includes aliases, those aliases will be expanded at definition time and their values will be used to define the new alias. This means that if you define an alias A in terms of another alias B, and then later redefine alias B, the value of alias A will not change.</source>
          <target state="translated">ATTR에 별칭이 포함 된 경우 해당 별칭은 정의시 확장되며 해당 값은 새 별칭을 정의하는 데 사용됩니다. 즉, 다른 별칭 B와 관련하여 별칭 A를 정의한 다음 나중에 별칭 B를 재정의하면 별칭 A의 값이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fb13f58bf6ef66c743c6f31498345464e172f61" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard attribute or attributes to which ALIAS is aliased, if any, or undef if ALIAS does not exist. If it is aliased to multiple attributes, the return value will be a single string and the attributes will be separated by spaces.</source>
          <target state="translated">ATTR이 지정되지 않은 경우 coloralias ()는 ALIAS가 별칭이있는 경우 표준 속성을 반환하고 ALIAS가없는 경우 undef를 반환합니다. 여러 속성에 별칭이 지정된 경우 반환 값은 단일 문자열이되고 속성은 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e062bfde8c040f50084c09a806e3edbdcdba4c2d" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard color name to which ALIAS is aliased, if any, or undef if ALIAS does not exist.</source>
          <target state="translated">ATTR을 지정하지 않으면 coloralias ()는 ALIAS의 별칭이있는 표준 색상 이름을 반환하거나 ALIAS가 없으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f999d6f241c02db8ba7aa5052a43f699b6917b00" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, coloralias() sets up an alias of ALIAS for the standard color ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">ATTR을 지정하면 coloralias ()는 표준 색상 ATTR에 대한 별칭 별칭을 설정합니다. 그 시점부터 ALIAS는 color (), colored () 및 colorvalid ()로 전달 될 수 있으며 ATTR과 동일한 의미를 갖습니다. 이 기능을 사용할 수있는 한 가지 방법은 256 색 RGB 색상에 더 의미있는 이름을 지정하는 것입니다. 영숫자 만 &lt;code&gt;.&lt;/code&gt; 별명에는 , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef24de7525ed9aebc1ebe9e4502b970287362ec8" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, it is interpreted as a list of space-separated strings naming attributes or existing aliases. In this case, coloralias() sets up an alias of ALIAS for the set of attributes given by ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as the sequence of attributes given in ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only ASCII alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">ATTR이 지정되면 속성 또는 기존 별칭을 명명하는 공백으로 구분 된 문자열 목록으로 해석됩니다. 이 경우 coloralias ()는 ATTR이 제공하는 속성 집합에 대해 ALIAS의 별칭을 설정합니다. 그 시점부터 ALIAS는 color (), colors () 및 colorvalid ()로 전달 될 수 있으며 ATTR에 제공된 속성 시퀀스와 동일한 의미를 갖습니다. 이 기능을 사용할 수있는 한 가지 방법은 256 색 RGB 색상에보다 의미있는 이름을 지정하는 것입니다. ASCII 영숫자, &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 는 별칭 이름에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5f4e8c9b9a52c1f24694fe0f51b01b3e6fce9d" translate="yes" xml:space="preserve">
          <source>If BASE is less than or equal to 94, and a collation sequence is not specified, the following default collation sequence is used. It contains of all the 94 printable ASCII characters except space/blank:</source>
          <target state="translated">BASE가 94보다 작거나 같고 데이터 정렬 시퀀스가 ​​지정되지 않은 경우 다음 기본 데이터 정렬 시퀀스가 ​​사용됩니다. 여기에는 공백 / 공백을 제외한 모든 94 개의 인쇄 가능한 ASCII 문자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3759a11aeec37a7d745f2f4cdae15ec5d06a83ce" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with big-endian formats &lt;code&gt;n&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">BITS가 16 이상이면 입력 문자열의 바이트가 BITS / 8 크기의 청크로 그룹화되고 각 그룹은 big-endian 형식 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (그리고 BITS ==의 경우와 유사하게 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; )에서&lt;/a&gt; 와 같이 숫자로 변환됩니다. 64). 자세한 내용은 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ed33ee3bf815a6c3c728d6a64deacab551214ad3" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">BITS가 16 이상인 경우 입력 문자열의 바이트는 BITS / 8 크기의 청크로 그룹화되며 각 그룹은 큰 엔디안 형식의 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (및 유사하게 pack () / unpack ()과 같은 숫자로 변환됩니다. BITS == 64의 경우). 자세한 내용은 &lt;a href=&quot;#pack&quot;&gt;팩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5890dee5bd815a9a6b870ab0d81456c70fdb6033" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">BITS가 16 이상인 경우 입력 문자열의 바이트는 BITS / 8 크기의 청크로 그룹화되며 각 그룹은 큰 엔디안 형식의 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (및 유사하게 pack () / unpack ()과 같은 숫자로 변환됩니다. BITS == 64의 경우). 자세한 내용은 &lt;a href=&quot;pack&quot;&gt;팩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eafc581ec466397a85b26357c350bc4ac6773df9" translate="yes" xml:space="preserve">
          <source>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</source>
          <target state="translated">BITS가 8 인 경우 &quot;요소&quot;는 입력 문자열의 바이트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1e3d642ff4115aae3b45ab10f3f174f7b8799465" translate="yes" xml:space="preserve">
          <source>If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.</source>
          <target state="translated">BUILD_REQUIRES가 비어 있지 않으면 $ BUILD_REQUIRES hashref로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="2f52aed81a4b81abc4bfb5eb234cabe8285fe520" translate="yes" xml:space="preserve">
          <source>If CHLD_IN begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">CHLD_IN이 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 로 시작하면 CHLD_IN이 부모에서 닫히고 자식은 직접 읽습니다. CHLD_OUT 또는 CHLD_ERR이 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작 하면 자식은 해당 파일 핸들로 직접 출력을 보냅니다. 두 경우 모두 pipe (2) 대신 dup (2)이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="7212fe99a84e995b8956769eedd21cc0b4318074" translate="yes" xml:space="preserve">
          <source>If Configure detects &lt;code&gt;mmap()&lt;/code&gt; functions this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;) which does &quot;read&quot; operations by mmap()ing the file. Performance improvement is marginal on modern systems, so it is mainly there as a proof of concept. It is likely to be unbundled from the core at some point. The &quot;mmap&quot; layer is a reasonable model for a minimalist &quot;derived&quot; layer.</source>
          <target state="translated">Configure에서 &lt;code&gt;mmap()&lt;/code&gt; 함수를 감지하면 파일을 mmap () 하여 &quot;읽기&quot;작업을 수행하는이 계층이 &quot;perlio&quot;를 &quot;base&quot;로 제공합니다. 최신 시스템에서는 성능 향상이 미미하므로 주로 개념 증명으로 사용됩니다. 언젠가는 코어에서 번들로 제공 될 수 있습니다. &quot;mmap&quot;레이어는 미니멀리스트 &quot;파생&quot;레이어에 적합한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="47e49834bb6e6d998b14887fad543f4fe5a1147b" translate="yes" xml:space="preserve">
          <source>If Configure detects this system has a signbit() that will work with our NVs, then we just use it via the #define in perl.h. Otherwise, fall back on this implementation. The main use of this function is catching -0.0.</source>
          <target state="translated">Configure가이 시스템에 NV와 작동하는 signbit ()가 있음을 감지하면 perl.h의 #define을 통해 사용합니다. 그렇지 않으면이 구현으로 돌아갑니다. 이 함수의 주요 용도는 -0.0을 잡는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14abe49a0e4ae66bc9fb22dcac00158a0e0ddd4d" translate="yes" xml:space="preserve">
          <source>If D calls an autoloaded method 'foo' which is defined in class A, then the method is loaded into class A, then executed. If C then calls method 'foo', and that method was reimplemented in class B, but set to be autoloaded, then the lookup mechanism never gets to the AUTOLOAD mechanism in B because it first finds the method already loaded in A, and so erroneously uses that. If the method foo had been stubbed in B, then the lookup mechanism would have found the stub, and correctly loaded and used the sub from B.</source>
          <target state="translated">D가 클래스 A에 정의 된 자동로드 된 메소드 'foo'를 호출하면 메소드가 클래스 A에로드 된 후 실행됩니다. C가 메소드 'foo'를 호출하고 해당 메소드가 클래스 B에서 다시 구현되었지만 자동로드되도록 설정된 경우, 조회 메커니즘은 먼저 A에로드 된 메소드를 먼저 찾아서 잘못 검색하므로 B의 AUTOLOAD 메커니즘에 도달하지 않습니다. 사용합니다. 메소드 foo가 B에서 스텁 된 경우, 검색 메커니즘은 스텁을 찾아서 B에서 서브를 올바르게로드하고 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="91710ed7923201057d536dad32d2aa3d9a3bd35e" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">DUCET이 설치되어 있지 않은 경우 &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; 에서 &amp;lt;@INC&amp;gt; /Unicode/Collate/allkeys.txt의 위치로 파일을 수동으로 복사하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="16f5960189e018481d4424c6116d78e40717c6a6" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from http://www.unicode.org/Public/UCA/latest/allkeys.txt to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">DUCET이 설치되어 있지 않은 경우 http://www.unicode.org/Public/UCA/latest/allkeys.txt에서 &amp;lt;@INC의 위치&amp;gt; /Unicode/Collate/allkeys.txt로 수동으로 파일을 복사하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="63ee7188cb79ae72f03905ea0c72ed0cf711430e" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the list of file descriptors and the next call to poll will check for any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be removed from the list of file descriptors.</source>
          <target state="translated">EVENT_MASK가 제공되면 EVENT_MASK가 0이 아닌 경우 IO가 파일 디스크립터 목록에 추가되고 다음 폴링 호출은 EVENT_MASK에 지정된 이벤트를 확인합니다. EVENT_MASK가 0이면 IO가 파일 디스크립터 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3d21a82a01626375b0a1ef9fd969a22666fce2" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is not given then the return value will be the current event mask value for IO.</source>
          <target state="translated">EVENT_MASK가 제공되지 않으면 리턴 값은 IO의 현재 이벤트 마스크 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="24c1cc8102964c640118dc422f140e282d6a071d" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 또는 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; 인 경우 테스트가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c34219724e950095cf8c95b322a2257c22c1fa96" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 and EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 또는 &lt;code&gt;EXPR1 and EXPR2&lt;/code&gt; 인 경우 테스트가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="34b0086c490eacc160b851838628c17c1a42195c" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; 경우 || EXPR2 , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 또는 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; 테스트가 적용됨)</target>
        </trans-unit>
        <trans-unit id="64f0ed02041dd1423cf4f2ba1123160eb703a531" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt;, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt;, or &lt;code&gt;EXPR1 or EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , 또는 &lt;code&gt;EXPR1 or EXPR2&lt;/code&gt; , 테스트가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="872b533779048230ee59539b4fa97acddf5e7f67" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; assumes a</source>
          <target state="translated">EXPR이 베어 워드 인 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="204a0454b1de60634e71646d68fb30fb2441fd3c" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, the require assumes a &quot;</source>
          <target state="translated">EXPR이 기본 단어 인 경우 요구 사항은 &quot;</target>
        </trans-unit>
        <trans-unit id="5f142acc4fb900bf97a751d8d7ecef7ff58633e0" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; uses the current time (as returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">expr이 생략 된 경우 &lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt; (반환 된 현재 사용 시간 &lt;a href=&quot;#time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9736cd87f1cff71e99f8827cbdbed7d4bb55c258" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 현재 시간을 사용합니다 (time (3)에 의해 리턴 됨).</target>
        </trans-unit>
        <trans-unit id="6546ecbea2a684b1dddb3701f62d17cc4c008989" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 현재 시간을 사용합니다 (time (3)에 의해 리턴 됨).</target>
        </trans-unit>
        <trans-unit id="1a53ae320a45163e84b47c2cc6fa7f3f20a64bbd" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">EXPR이 생략되면 통계 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc0b8d50332776e14a75cf158fdbe3c24ae9c657" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 생략하면 통계 &lt;code&gt;$_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac7e9e53a5fc19d51bc46a87435c0e28a0433901" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">EXPR이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 문자열의 압축을 풉니 다 . 이 함수에 대한 소개는 &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="456f6be70dd618e1ee3287e7f4f8da001e29c2cb" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 문자열의 압축을 풉니 다 . &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; 참조이 기능에 대한 소개는 를 .</target>
        </trans-unit>
        <trans-unit id="b61a1720b65aee85f5ca14d3364f5d86fb223f23" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 문자열의 압축을 풉니 다 . &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; 참조이 기능에 대한 소개는 를 .</target>
        </trans-unit>
        <trans-unit id="26a60e10a6d0c75eb8213877c8d12c780af7f80d" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">EXPR이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dfe2e417f8e1e00ae0478764fd05788fcd47c267" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. To go the other way (produce a number in octal), use &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">EXPR이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 사용합니다 . 다른 방법으로 이동하려면 (8 진수로 숫자를 생성) &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; 를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d36eccdc92b1d6936c118cc354859012973685d8" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="1172cb3a4a7f1f2dfc6dcf55076a98d031996813" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; . To go the other way (produce a number in octal), use sprintf() or printf():</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 사용합니다. . 다른 방법으로 (8 진수로 숫자를 생성하려면) sprintf () 또는 printf ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0835de1ae9d548d447faabd3d40dd3e5da356962" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE -- the first argument in a call to &lt;code&gt;open&lt;/code&gt; -- is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 호출의 첫 번째 인수 인 FILEHANDLE 이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소)이면 새 파일 핸들이 자동으로 활성화됩니다. 즉, 변수에 새로 할당 된 익명 파일 핸들에 대한 참조가 할당됩니다. 그렇지 않으면 FILEHANDLE이 표현식이면 그 값은 실제 파일 핸들입니다. (이것은 그래서, 상징적 참조 간주됩니다 &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; 한다</target>
        </trans-unit>
        <trans-unit id="488f2cec4909ee80d1ac152c113a7f5b407ac400" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">FILEHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 새 파일 핸들이 자동으로 활성화되므로 변수에 새로 할당 된 익명 파일 핸들에 대한 참조가 지정됩니다. 그렇지 않으면 FILEHANDLE이 표현식 인 경우 해당 값은 실제 파일 핸들입니다. (이것은 그래서, 상징적 참조로 간주됩니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 한다</target>
        </trans-unit>
        <trans-unit id="7bf316535c25573b5c20cc7acfbdffbec7d384a1" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">FILEHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 새 파일 핸들이 자동으로 활성화되므로 변수에 새로 할당 된 익명 파일 핸들에 대한 참조가 지정됩니다. 그렇지 않으면 FILEHANDLE이 표현식 인 경우 해당 값은 실제 파일 핸들입니다. (이것은 그래서, 상징적 참조로 간주됩니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 한다</target>
        </trans-unit>
        <trans-unit id="78b86feaadc89f11ca72025d1989c281686ea22c" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE이 지정되지 않은 경우 출력은 현재 기본 출력 채널로 이동합니다.이 채널은 STDOUT으로 시작하지만 &lt;a href=&quot;#select-FILEHANDLE&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 연산자에 의해 변경 될 수 있습니다 . FILEHANDLE이 EXPR이면 표현식이 평가되고 결과 문자열이 런타임에 FILEHANDLE의 이름을 조회하는 데 사용됩니다. 형식에 대한 자세한 내용은 &lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7edd9359c1108403094d8175c9c20835e326b96f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 지정하지 않으면 출력이 현재 기본 출력 채널로 이동하여 STDOUT으로 시작하지만 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 연산자에 의해 변경 될 수 있습니다 . FILEHANDLE이 EXPR 인 경우 표현식이 평가되고 결과 문자열이 런타임에 FILEHANDLE의 이름을 찾는 데 사용됩니다. 형식에 대한 자세한 내용은 &lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64a3c2a915faecffdca2e95dc4489ca8da06212f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 지정하지 않으면 출력이 현재 기본 출력 채널로 이동하여 STDOUT으로 시작하지만 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 연산자에 의해 변경 될 수 있습니다 . FILEHANDLE이 EXPR 인 경우 표현식이 평가되고 결과 문자열이 런타임에 FILEHANDLE의 이름을 찾는 데 사용됩니다. 형식에 대한 자세한 내용은 &lt;a href=&quot;../perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7746cb09d04e425daae32ba450ffb46bfb9b6e05" translate="yes" xml:space="preserve">
          <source>If FILENAME doesn't exist on the filesystem, or if the filesystem doesn't support short ANSI filenames, then this function will translate the Unicode name into the system codepage using replacement characters.</source>
          <target state="translated">FILENAME이 파일 시스템에 없거나 파일 시스템이 짧은 ANSI 파일 이름을 지원하지 않는 경우이 함수는 대체 문자를 사용하여 유니 코드 이름을 시스템 코드 페이지로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="42bee98ad679afc0b47a6a37b45d0b7a351045fa" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">FUNCTION이 &lt;code&gt;CORE::&lt;/code&gt; 시작하는 문자열 인 경우 나머지는 Perl 내장의 이름으로 사용됩니다. 기본 제공 인수가 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같은 프로토 타입으로 적절하게 표현 될 수없는 경우 prototype ()은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. , 내장은 실제로 Perl 함수처럼 동작하지 않기 때문에 합니다. 그렇지 않으면 동등한 프로토 타입을 설명하는 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cae550505561d57b299b4a003dc8830ba8e1ee71" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">FUNCTION이 &lt;code&gt;CORE::&lt;/code&gt; 시작하는 문자열 인 경우 나머지는 Perl 내장의 이름으로 사용됩니다. 기본 제공 인수가 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같은 프로토 타입으로 적절하게 표현 될 수없는 경우 prototype ()은 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. , 내장은 실제로 Perl 함수처럼 동작하지 않기 때문에 합니다. 그렇지 않으면 동등한 프로토 타입을 설명하는 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0166703daf5c496c4bec8f243a081750014163a4" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt;, the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;#prototype-FUNCTION&quot;&gt;&lt;code&gt;prototype&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">FUNCTION이 &lt;code&gt;CORE::&lt;/code&gt; 시작하는 문자열 이면 나머지는 Perl 내장 이름으로 간주됩니다. 내장의 인수가 프로토 타입 (예 : &lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt; )에 의해 적절하게 표현 될 수없는 경우 , 내장이 실제로 Perl 함수처럼 작동하지 않기 때문에 &lt;a href=&quot;#prototype-FUNCTION&quot;&gt; &lt;code&gt;prototype&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 반환 합니다. 그렇지 않으면 동등한 프로토 타입을 설명하는 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cc31873f684622a14f7af2ea2005b39a1781e830" translate="yes" xml:space="preserve">
          <source>If G_ARRAY is specified</source>
          <target state="translated">G_ARRAY가 지정된 경우</target>
        </trans-unit>
        <trans-unit id="abc56a2d0a54c75c4dee47cdfefa046b0f36c198" translate="yes" xml:space="preserve">
          <source>If G_DISCARD is specified, the return value will always be 0.</source>
          <target state="translated">G_DISCARD가 지정되면 리턴 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="61b15d293eca2c7db4238b66ac8714ddc363a1b1" translate="yes" xml:space="preserve">
          <source>If G_SCALAR is specified</source>
          <target state="translated">G_SCALAR가 지정된 경우</target>
        </trans-unit>
        <trans-unit id="5c71a194d71e5b8b3f592792b3f56c1d07d85df4" translate="yes" xml:space="preserve">
          <source>If I don't have My::TAP::Harness installed on @INC I need to provide the correct path to perl when I run prove:</source>
          <target state="translated">@INC에 My :: TAP :: Harness가 설치되어 있지 않은 경우 증명을 실행할 때 올바른 경로를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd626ea4da9803c896a3f690bf6350bffa4a5047" translate="yes" xml:space="preserve">
          <source>If I don't see that &quot;Perl:&quot;, it's not from perl.</source>
          <target state="translated">&quot;Perl :&quot;이 보이지 않으면 펄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="03be8548f702da2e594e410d893934eeb0d8222b" translate="yes" xml:space="preserve">
          <source>If I have failing tests in a test suite that consists of more than a handful of scripts and takes more than a few seconds to run it rapidly becomes tedious to run the whole test suite repeatedly as I track down the problems.</source>
          <target state="translated">소수 이상의 스크립트로 구성된 테스트 스위트에서 테스트에 실패하고 실행하는 데 몇 초 이상이 걸리는 경우 문제를 추적하면서 전체 테스트 스위트를 반복적으로 실행하는 것이 지루해집니다.</target>
        </trans-unit>
        <trans-unit id="da15fab02b636d1da580f8c8673ab702a8e74b65" translate="yes" xml:space="preserve">
          <source>If I need a feature that prove doesn't provide I can easily write my own.</source>
          <target state="translated">제공하지 않는 기능이 필요하면 쉽게 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605963fd1be7406e13c1ff42eab8cd0d74775641" translate="yes" xml:space="preserve">
          <source>If I need to reach even deeper into the internals of the harness I can replace the classes that TAP::Parser uses to execute test scripts and tokenise their output. Before running a test script TAP::Parser creates a grammar (TAP::Parser::Grammar) to decode the raw TAP into tokens, a result factory (TAP::Parser::ResultFactory) to turn the decoded TAP results into objects and, depending on whether it's running a test script or reading TAP from a file, scalar or array a source or an iterator (TAP::Parser::IteratorFactory).</source>
          <target state="translated">하네스의 내부에 더 깊이 접근해야하는 경우 TAP :: Parser가 테스트 스크립트를 실행하고 출력을 토큰 화하는 데 사용하는 클래스를 대체 할 수 있습니다. 테스트 스크립트를 실행하기 전에 TAP :: Parser는 원시 TAP를 토큰으로 디코딩하는 문법 (TAP :: Parser :: Grammar)을 생성하고 결과 팩토리 (TAP :: Parser :: ResultFactory)를 생성하여 디코딩 된 TAP 결과를 객체로 변환하고 , 테스트 스크립트를 실행하는지 또는 파일에서 TAP를 읽는지, 스칼라 또는 배열 소스 또는 반복자 (TAP :: Parser :: IteratorFactory)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="985d558aa1f93c1b25225dff89cbd31a5a5a4d9a" translate="yes" xml:space="preserve">
          <source>If I save that as t/phptest.t the shebang line will ensure that it runs correctly along with all my other tests.</source>
          <target state="translated">t / phptest.t로 저장하면 shebang 라인이 다른 모든 테스트와 함께 올바르게 실행되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b9a5f2df715ea2336595f87758abbc0f6cdbf051" translate="yes" xml:space="preserve">
          <source>If I write a subclass of App::Prove I can customise any aspect of the test runner while inheriting all of prove's behaviour. Here's myprove:</source>
          <target state="translated">App :: Prove의 하위 클래스를 작성하면 모든 증명 동작을 상속하면서 테스트 실행기의 모든 측면을 사용자 지정할 수 있습니다. 다음은 myprove입니다.</target>
        </trans-unit>
        <trans-unit id="74809ed417c3b37088be3b29e4f08e09fd27f388" translate="yes" xml:space="preserve">
          <source>If I'm running my tests in parallel there may also be a multiplexer (TAP::Parser::Multiplexer) - the component that allows multiple tests to run simultaneously.</source>
          <target state="translated">테스트를 병렬로 실행하는 경우 다중 테스트를 동시에 실행할 수있는 구성 요소 인 멀티플렉서 (TAP :: Parser :: Multiplexer)도있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f881d9fe9fd9028d68d11b8271492af01bf7e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt; . If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">ID를 생략하면 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 입니다. ID에 단일 문자가 제공되면 해당 문자의 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3edb552ee59d2dff01961b99b98b93b199000e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt;. If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">ID가 생략되면 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. ID에 단일 문자가 제공되면 해당 문자의 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b781e9bc0c2157f6dabdbd2804f21e2dc4d3a773" translate="yes" xml:space="preserve">
          <source>If KEY starts and ends with a slash, the string in between is treated as a regular expression and only keys matching this regexp are displayed</source>
          <target state="translated">KEY가 슬래시로 시작하고 끝나는 경우 사이에있는 문자열은 정규식으로 취급되며이 정규 표현식과 일치하는 키만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97bf7fa576e4d2080ce6127c0f4cd5a7adce4cf1" translate="yes" xml:space="preserve">
          <source>If LAYER is omitted or specified as &lt;code&gt;:raw&lt;/code&gt; the filehandle is made suitable for passing binary data. This includes turning off possible CRLF translation and marking it as bytes (as opposed to Unicode characters). Note that, despite what may be implied in</source>
          <target state="translated">LAYER가 생략되거나 &lt;code&gt;:raw&lt;/code&gt; 로 지정된 경우 파일 핸들은 이진 데이터를 전달하는 데 적합합니다. 여기에는 가능한 CRLF 변환을 끄고 바이트 단위로 표시하는 것이 포함됩니다 (유니 코드 문자와 반대). 내포 된 내용에도 불구하고</target>
        </trans-unit>
        <trans-unit id="283b8c8f4ffd49cdc5f923f3f2b2ef054e93376f" translate="yes" xml:space="preserve">
          <source>If LAYER is present it is a single string, but may contain multiple directives. The directives alter the behaviour of the filehandle. When LAYER is present, using binmode on a text file makes sense.</source>
          <target state="translated">LAYER가 있으면 단일 문자열이지만 여러 지시문이 포함될 수 있습니다. 지시문은 파일 핸들의 동작을 변경합니다. LAYER가 있으면 텍스트 파일에서 binmode를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bc78056370f87ab6c8598a43f74f4b98bd9074c2" translate="yes" xml:space="preserve">
          <source>If LIMIT is negative, it is treated as if it were instead arbitrarily large; as many fields as possible are produced.</source>
          <target state="translated">LIMIT가 음수 인 경우에는 임의로 임의로 큰 것처럼 취급됩니다. 가능한 많은 분야가 생산됩니다.</target>
        </trans-unit>
        <trans-unit id="0394dbfeda7095aa516dcefff51b8b66aab7006b" translate="yes" xml:space="preserve">
          <source>If LIMIT is omitted (or, equivalently, zero), then it is usually treated as if it were instead negative but with the exception that trailing empty fields are stripped (empty leading fields are always preserved); if all fields are empty, then all fields are considered to be trailing (and are thus stripped in this case). Thus, the following:</source>
          <target state="translated">LIMIT가 생략 된 경우 (또는 동등하게 0 인 경우), 대신 빈 필드가 제거된다는 점을 제외하고는 일반적으로 음수 인 것처럼 처리됩니다 (빈 선행 필드는 항상 보존 됨). 모든 필드가 비어 있으면 모든 필드가 후행 인 것으로 간주되므로이 경우 제거됩니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec1ca6d6c3c8c30d74e46da0d1f8dfee1a937ce1" translate="yes" xml:space="preserve">
          <source>If LIMIT is specified and positive, it represents the maximum number of fields into which the EXPR may be split; in other words, LIMIT is one greater than the maximum number of times EXPR may be split. Thus, the LIMIT value &lt;code&gt;1&lt;/code&gt; means that EXPR may be split a maximum of zero times, producing a maximum of one field (namely, the entire value of EXPR). For instance:</source>
          <target state="translated">LIMIT가 지정되고 양수이면 EXPR이 분할 될 수있는 최대 필드 수를 나타냅니다. 즉, LIMIT는 EXPR이 분할 될 수있는 최대 횟수보다 1이 큽니다. 따라서 LIMIT 값 &lt;code&gt;1&lt;/code&gt; 은 EXPR이 최대 0 회 분할되어 최대 하나의 필드 (즉, EXPR의 전체 값)를 생성 할 수 있음을 의미합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="a1e79f492508e7edc8814a0c2f8fb560a886956d" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">LIST가 빈 문자열로 구성된 경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 &lt;b&gt;SPAWN&lt;/b&gt; 을 입력하는 것과 같은 방식으로 대화식 DCL 서브 프로세스를 생성합니다.&lt;b&gt;&lt;/b&gt; 은 DCL 프롬프트에서 을 합니다.</target>
        </trans-unit>
        <trans-unit id="d577e3a6f68cf3804f6d29aac95c4927c6f793ba" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;system&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">LIST가 빈 문자열로 구성된 경우 &lt;code&gt;system&lt;/code&gt; 은 DCL 프롬프트에서 &lt;b&gt;SPAWN&lt;/b&gt; 을 입력하는 것과 동일한 방식으로 대화 형 DCL 하위 프로세스를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c2cae660b4a3baec9a67c4d2cf72f2806437ed21" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">LIST가 생략되면 &lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8af421f1352b89476d8e2fb680c100c5c55fb16a" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">LIST가 생략되면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="15ba1dd13707a281770468c5a2f35927f1cf24ea" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">LIST가 생략되면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4da7e6771ebdbb0d68b845baa0f1af30e2550323" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value (typically from a previous &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;), then that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt;. This is useful for propagating exceptions:</source>
          <target state="translated">LIST가 비어 있거나 빈 문자열이되고 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 이미 예외 값 (일반적으로 이전 &lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; )이 포함 된 경우 해당 값은 &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 추가 한 후 다시 사용 됩니다. 이것은 예외를 전파하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="84674bcf3d3a118952a055d14ce31826e4bf5479" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;; i.e., as if &lt;code&gt;$@ = eval { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">LIST가 비어 있거나 빈 문자열이되고 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;PROPAGATE&lt;/code&gt; 메서드 가있는 개체 참조가 포함 된 경우 해당 메서드는 추가 파일 및 줄 번호 매개 변수와 함께 호출됩니다. 반환 값은 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 의 값을 대체합니다 . 즉, &lt;code&gt;$@ = eval { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 불렀다.</target>
        </trans-unit>
        <trans-unit id="281f7b6eb5d507578f647b0d70c67bd5a086771f" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is also empty, then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">LIST가 비어 있거나 빈 문자열이되고 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 도 비어 있으면 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 문자열 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e6165dd99b5382a91584396109e05b591d171e0" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt;, the file is opened for input (read-only). If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, the file is opened for appending, again being created if necessary.</source>
          <target state="translated">MODE가 &lt;code&gt;&amp;lt;&lt;/code&gt; 이면 입력을 위해 파일이 열립니다 (읽기 전용). MODE가 &lt;code&gt;&amp;gt;&lt;/code&gt; 이면 기존 파일이 먼저 잘리고 ( &quot;클로버 됨&quot;) 존재하지 않는 파일이 새로 생성 된 상태로 파일이 출력을 위해 열립니다. MODE가 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 이면 추가를 위해 파일이 열리고 필요한 경우 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="17ef4f93ed053708e4daa4192a3c5a507017945b" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;|-&lt;/code&gt;, then the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt;, the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt;) with the command. See &lt;a href=&quot;perlipc#Using-open%28%29-for-IPC&quot;&gt;&quot;Using open() for IPC&quot; in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; to a command that pipes both in</source>
          <target state="translated">MODE가 &lt;code&gt;|-&lt;/code&gt; 이면 파일 이름은 출력이 파이프 될 명령으로 해석되고 MODE가 &lt;code&gt;-|&lt;/code&gt; 이면 , 파일 이름은 출력을 우리에게 파이프하는 명령으로 해석됩니다. 2 인수 (및 1 인수) 형식에서 대시 ( &lt;code&gt;-&lt;/code&gt; )를 명령으로 바꿔야 합니다. &lt;a href=&quot;perlipc#Using-open%28%29-for-IPC&quot;&gt;이에&lt;/a&gt; 대한 더 많은 예를 보려면 perlipc의 &quot;IPC에 open () 사용&quot;을 참조하십시오 . ( 둘 다 파이프하는 명령 을 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f8725f581ae126bd53637cc6004bb31b10e046db" translate="yes" xml:space="preserve">
          <source>If Mac::Files could not be loaded, the empty string is returned.</source>
          <target state="translated">Mac :: Files를로드 할 수 없으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9556835597cabed412f1a27672edf9d6d8a5a68b" translate="yes" xml:space="preserve">
          <source>If N is &amp;gt; 0, rounds to the Nth digit from the left. If N &amp;lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &amp;lt; 0 is a no-op for them.</source>
          <target state="translated">N이 0보다 크면 왼쪽에서 N 번째 숫자로 반올림합니다. N &amp;lt;0 인 경우, 점 다음의 N 번째 숫자로 반올림합니다. BigInts는 정수이므로 N &amp;lt;0 인 경우에는 해당 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bb11b5e3bbf2cecd073552e16a6087ed08e448b" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NUMBER가 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="809aa45c402e18c1090663e0bbd2fdac630054bb" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">NUMBER가 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41978e4e598bdad208f30664c01c64d67097badb" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">OFFSET 및 LENGTH가 부분적으로 문자열 밖에있는 부분 문자열을 지정하면 문자열 내의 부분 만 반환됩니다. 부분 문자열이 문자열의 양쪽 끝을 넘어 &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt; 은 정의되지 않은 값을 반환하고 경고를 생성합니다. lvalue로 사용될 때 완전히 문자열 밖에있는 부분 문자열을 지정하면 예외가 발생합니다. 다음은 경계 케이스의 동작을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="6e18ed7b6aa1dfe2acf7667704a25f494c6c53b1" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, substr() returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">OFFSET 및 LENGTH가 부분적으로 문자열 외부에있는 부분 문자열을 지정하면 문자열 내의 부분 만 반환됩니다. 부분 문자열이 문자열의 양쪽 끝을 초과하면 substr ()은 정의되지 않은 값을 반환하고 경고를 생성합니다. lvalue로 사용될 때 전체 문자열 외부에있는 하위 문자열을 지정하면 예외가 발생합니다. 다음은 경계 사례의 동작을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="805a2c8a87b8f6b59ee6ee34433c46d30a4b7687" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">PATTERN이 &lt;code&gt;/^/&lt;/code&gt; 이면 &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;다중 행 수정 자&lt;/a&gt; ( &lt;code&gt;/^/m&lt;/code&gt; )를 사용한 것처럼 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="f31e710fa5dc3bb0149beaea0c04322fd5b027e6" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">PATTERN이 &lt;code&gt;/^/&lt;/code&gt; 이면 여러 줄 &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;수정자를&lt;/a&gt; 사용하는 것처럼 처리됩니다 ( &lt;code&gt;/^/m&lt;/code&gt; )를 .</target>
        </trans-unit>
        <trans-unit id="0d84847fbb60054df16b3ab82d500263906bc774" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt;, then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt;), since it isn't much use otherwise.</source>
          <target state="translated">PATTERN이 &lt;code&gt;/^/&lt;/code&gt; 이면 다른 방법으로는 많이 사용되지 않으므로 여러 줄 &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;수정 자&lt;/a&gt; ( &lt;code&gt;/^/m&lt;/code&gt; )를 사용한 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ab2206e4a8b71981bc3526b21e6f961d2fc978f" translate="yes" xml:space="preserve">
          <source>If PATTERN matches the empty string, the EXPR is split at the match position (between characters). As an example, the following:</source>
          <target state="translated">PATTERN이 빈 문자열과 일치하면 EXPR은 일치 위치 (문자 사이)에서 분할됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4c909b9fa78435a98bf6dd9ce2fb396fdd71cb" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">PERL5LIB가 정의되지 않은 경우 &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; 가 사용됩니다. 디렉토리는 (PATH에서와 같이) Unixish 플랫폼에서는 콜론으로, Windows에서는 세미콜론으로 구분됩니다 ( &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; 명령으로 적절한 경로 구분 기호가 제공됨 ).</target>
        </trans-unit>
        <trans-unit id="d1b7e2477c70af9a1ce418a622d9557a0b72af87" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, PERLLIB is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl
-V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">PERL5LIB가 정의되지 않은 경우 PERLLIB가 사용됩니다. 디렉토리는 PATH와 같이 Unixish 플랫폼의 콜론과 Windows의 세미콜론 ( &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; &lt;i&gt;path_sep&lt;/i&gt; 명령으로 제공되는 적절한 경로 구분 기호)으로 구분됩니다 .&lt;i&gt;&lt;/i&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e3cb4284864a564ca2b51274a4f3fa62dd73a592" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_ALL is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt; . Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">PERL_PV_ESCAPE_ALL이 설정되면 모든 입력 문자가 &lt;code&gt;\x01F1&lt;/code&gt; 스타일 이스케이프를 사용하여 출력되고 , 그렇지 않으면 PERL_PV_ESCAPE_NONASCII가 설정되면이 스타일을 사용하여 비 ASCII 문자 만 이스케이프됩니다. 그렇지 않으면 255 이상의 문자 만 이스케이프됩니다. 인쇄 할 수없는 다른 문자는 &lt;code&gt;\n&lt;/code&gt; 과 같은 8 진 또는 일반적인 이스케이프 패턴을 사용 합니다. 그렇지 않으면 PERL_PV_ESCAPE_NOBACKSLASH 인 경우 255 미만의 모든 문자는 인쇄 가능한 것으로 처리되고 리터럴로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="03a5b31adb12c35d2862c64e653c8076e4f81a1b" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">PERL_PV_ESCAPE_FIRSTCHAR이 설정되면 최대 값에 관계없이 문자열의 첫 번째 문자 만 이스케이프됩니다. 출력이 16 진인 경우 일반 16 진 순서로 리턴됩니다. 따라서 출력은 단일 문자, 8 진 이스케이프 시퀀스, &lt;code&gt;\n&lt;/code&gt; 과 같은 특수 이스케이프입니다. 또는 16 진수 값입니다.</target>
        </trans-unit>
        <trans-unit id="4fd0e08a5001bbfc2db16575c706877131f99c11" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and not a '\\'. This is because regexes very often contain backslashed sequences, whereas '%' is not a particularly common character in patterns.</source>
          <target state="translated">PERL_PV_ESCAPE_RE가 설정되면 사용 된 이스케이프 문자는 '\\'가 아닌 '%'가됩니다. 정규 표현식에는 백 슬래시 시퀀스가 ​​포함되는 경우가 많고 '%'는 패턴에서 특히 일반적인 문자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c327fff20e1a2d0d479391141282091e826a55c6" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_UNI is set then the input string is treated as UTF-8 if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">PERL_PV_ESCAPE_UNI가 설정된 경우 PERL_PV_ESCAPE_UNI_DETECT가 설정된 경우 입력 문자열은 UTF-8로 처리되고 입력 문자열은 &lt;code&gt;is_utf8_string()&lt;/code&gt; 을 사용하여 UTF-8인지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="19515a44b91c296bde08fb195c3206ce5ee06393" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt; . If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">PID가 파이프 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 의해 시작된 서브 프로세스 인 경우 ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 ) &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 는 해당 서브 프로세스를 대기하고 최종 상태 값을 &lt;code&gt;$?&lt;/code&gt; . PID가 다른 방식으로 작성된 서브 프로세스 인 경우 (예 : Perl을 호출하기 전에 SPAWNed) &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 는 프로세스가 완료되었는지 여부를 초당 한 번만 점검하고 프로세스가 완료되면 리턴합니다. PID가 현재 프로세스의 서브 프로세스가 아닌 프로세스를 지정하고 &lt;code&gt;-w&lt;/code&gt; 스위치를 사용하여 Perl을 호출 하면 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c89908fc623a7d026e9fd9f90cd1799c25d8d3" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;open()&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;waitpid&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt;. If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;waitpid&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">PID가 파이프 된 &lt;code&gt;open()&lt;/code&gt; 의해 시작된 하위 프로세스 인 경우 ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 ) &lt;code&gt;waitpid&lt;/code&gt; 는 해당 하위 프로세스를 기다렸다가 &lt;code&gt;$?&lt;/code&gt; . PID가 다른 방식으로 생성 된 하위 프로세스 인 경우 (예 : Perl이 호출되기 전에 SPAWNed) &lt;code&gt;waitpid&lt;/code&gt; 는 프로세스가 완료되었는지 여부를 초당 한 번씩 확인하고 완료되면 반환합니다. (PID가 현재 프로세스의 하위 프로세스가 아닌 프로세스를 지정하고 &lt;code&gt;-w&lt;/code&gt; 스위치로 Perl을 호출 하면 경고가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="2833d231deee2ce7c48c3ef06baaabad2e5a0de9" translate="yes" xml:space="preserve">
          <source>If PPCODE: directive is not used, &lt;code&gt;void&lt;/code&gt; return value should be used only for subroutines which do not return a value,</source>
          <target state="translated">PPCODE : 지시문을 사용하지 않으면 &lt;code&gt;void&lt;/code&gt; 반환 값은 값을 반환하지 않는 서브 루틴에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c393beed824f2acf513d9860e129eb5ffe2baeec" translate="yes" xml:space="preserve">
          <source>If PadnameOUTER is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">패드 이름에 PadnameOUTER가 설정되어 있으면 프레임 AV의 해당 슬롯은 &quot;외부&quot;의 어휘에 대한 REFCNT 참조입니다. 이러한 항목은 '가짜'라고도합니다. 이 경우, 이름은 cop_seq 범위를 저장하는 데 'low'및 'high'를 사용하지 않습니다. 범위는 전체에 걸쳐 있기 때문입니다. 대신 'high'는 실제 어휘에 대한 정보를 포함하는 일부 플래그를 저장하고 (익명으로 선언되고 여러 번 인스턴스화 될 수 있습니까?), 가짜 ANON의 경우 'low'는 부모 패드 내의 인덱스를 포함합니다. lexical의 값이 저장되어 복제 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="40be3d27de878e5185ba9875f176a67d8334894d" translate="yes" xml:space="preserve">
          <source>If Perl cannot find the method in any of these classes, it will die with an error message.</source>
          <target state="translated">Perl이 이러한 클래스 중 하나에서 메소드를 찾을 수 없으면 오류 메시지와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ef114bcc0bbc93d31f879d70b2e23b29c28c176d" translate="yes" xml:space="preserve">
          <source>If Perl detects that there are problems with the locale collation order, it reverts to using non-locale collation rules for that locale.</source>
          <target state="translated">Perl이 로케일 데이터 정렬 순서에 문제가 있음을 감지하면 해당 로케일에 대해 비 로케일 데이터 정렬 규칙을 사용하는 것으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="3a89c2d4d03a490ab54c26429553ad753f25a36f" translate="yes" xml:space="preserve">
          <source>If Perl finds that the found executable is of PM type when the current session is not, it will start the new process in a separate session of necessary type. Call via &lt;code&gt;OS2::Process&lt;/code&gt; to disable this magic.</source>
          <target state="translated">Perl이 현재 세션이 아닌 경우 발견 된 실행 파일이 PM 유형 인 경우 필요한 유형의 별도 세션에서 새 프로세스를 시작합니다. 이 마법을 비활성화하려면 &lt;code&gt;OS2::Process&lt;/code&gt; 를 통해 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="289a7b0542dd20aefdd9191d5f173083a238571f" translate="yes" xml:space="preserve">
          <source>If Perl has been compiled using Perl's malloc you can analyze Perl memory usage by setting $ENV{PERL_DEBUG_MSTATS}.</source>
          <target state="translated">Perl의 malloc을 사용하여 Perl을 컴파일 한 경우 $ ENV {PERL_DEBUG_MSTATS}를 설정하여 Perl 메모리 사용량을 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230e2bfc79d0ba462c1beaf813fc67b45a5f8378" translate="yes" xml:space="preserve">
          <source>If Perl is not built to use PerlIO as its IO system then only the two pseudo-layers &lt;code&gt;:bytes&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; are available.</source>
          <target state="translated">Perl이 IO 시스템으로 PerlIO를 사용하도록 빌드되지 않은 경우 두 개의 의사 계층 &lt;code&gt;:bytes&lt;/code&gt; 및 &lt;code&gt;:crlf&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6264d3e40b3079f00ff5fcba981797a472b669d0" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">Perl이 소켓 지원으로 빌드되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 시스템 호출 버전을 전혀 사용할 수 없습니다. 소켓 지원이 존재하면, 소켓에 접속 된 파일 디스크립터에 대해서만 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 함수 의 시스템 호출 버전 . CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 이후 일반 파일 또는 파이프에 대한 정보를 제공하지 않습니다. 루틴은이 기능을 제공하지 않기 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35e051c99f37dfed774297cb967d8106c5e199d4" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;select&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;select&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;select()&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">Perl이 소켓 지원으로 빌드되지 않은 경우 &lt;code&gt;select&lt;/code&gt; 의 시스템 호출 버전을 전혀 사용할 수 없습니다. 소켓 지원이있는 경우 소켓에 첨부 된 파일 설명자에 대해서만 &lt;code&gt;select&lt;/code&gt; 함수 의 시스템 호출 버전입니다 . CRTL &lt;code&gt;select()&lt;/code&gt; 루틴은이 기능을 제공하지 않기 때문에 일반 파일이나 파이프에 대한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4a129f6da7edb3d3e9d992e64ee7ec5edc1382d" translate="yes" xml:space="preserve">
          <source>If Perldoc is running under MSWin and uses this class as a formatter, the output will be opened with</source>
          <target state="translated">Perldoc이 MSWin에서 실행 중이고이 클래스를 포맷터로 사용하는 경우 출력은</target>
        </trans-unit>
        <trans-unit id="48a7e7d61da87b6e49574cb96f576ab3af92a97c" translate="yes" xml:space="preserve">
          <source>If Pod::Man is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Man and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Pod :: Man에 &lt;code&gt;utf8&lt;/code&gt; 이 제공된 경우 옵션 되면 가능한 경우 출력 파일 핸들의 인코딩이 기존 인코딩을 대체하여 UTF-8로 강제됩니다. 이것은 파일 핸들이 Pod :: Man에 의해 작성되지 않고 외부에서 전달 된 경우에도 수행됩니다. 이는 PERL_UNICODE 및 기타 설정에 관계없이 일관성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="89e668a66a16049973d228d4291fce70e3c9695a" translate="yes" xml:space="preserve">
          <source>If Pod::Man is unavailable, this function will warn and return undef.</source>
          <target state="translated">Pod :: Man을 사용할 수없는 경우이 함수는 경고를 표시하고 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b2424487d45dbfa5c1b518ecd9497b822e7398c" translate="yes" xml:space="preserve">
          <source>If Pod::Simple sends an event where the element name has a dash, period, or colon, the corresponding method name will have a underscore in its place. For example, &quot;foo.bar:baz&quot; becomes start_foo_bar_baz and end_foo_bar_baz.</source>
          <target state="translated">Pod :: Simple에서 요소 이름에 대시, 마침표 또는 콜론이있는 이벤트를 보내면 해당 메서드 이름에 밑줄이 표시됩니다. 예를 들어 &quot;foo.bar:baz&quot;는 start_foo_bar_baz 및 end_foo_bar_baz가됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0153ee2898f6429d842dbcd6c0696456ff28ca" translate="yes" xml:space="preserve">
          <source>If Pod::Text is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Text and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Pod :: Text에 &lt;code&gt;utf8&lt;/code&gt; 옵션 이 제공 되면 가능한 경우 출력 파일 핸들의 인코딩이 기존 인코딩을 대체하여 UTF-8로 강제됩니다. 이것은 파일 핸들이 Pod :: Text에 의해 작성되지 않고 외부에서 전달 된 경우에도 수행됩니다. 이는 PERL_UNICODE 및 기타 설정에 관계없이 일관성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a28c6ae29cd39f20d43e841a87f74f6e887bacb7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will behave like &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">이 플래그 외에 RXf_WHITE가 설정되면 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 Perl 엔진에서 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="cf4453d6aaace8cb227f665bb65347d32d2472e7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;split&lt;/code&gt; will behave like &lt;code&gt;split &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">이 플래그와 함께 RXf_WHITE를 설정하면 &lt;code&gt;split&lt;/code&gt; 은 Perl 엔진에서 &lt;code&gt;split &quot; &quot;&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="03dddb9eda0980e6158ca2dd506258dca11f657b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">SIGNAL이 숫자 0이거나 문자열 &lt;code&gt;ZERO&lt;/code&gt; (또는 &lt;code&gt;SIGZERO&lt;/code&gt; )이면 프로세스에 신호가 전송되지 않지만 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="a487625a13afee57a95232e398ffaae21162742b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">SIGNAL이 숫자 0이거나 문자열 &lt;code&gt;ZERO&lt;/code&gt; (또는 &lt;code&gt;SIGZERO&lt;/code&gt; )이면 프로세스에 신호가 전송되지 않지만 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="760e1ef9a0dd7acd780a886234880aed4a2bbd19" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt;), no signal is sent to the process, but &lt;a href=&quot;#kill-SIGNAL%2C-LIST&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; checks whether it's</source>
          <target state="translated">SIGNAL이 숫자 0 또는 문자열 &lt;code&gt;ZERO&lt;/code&gt; (또는 &lt;code&gt;SIGZERO&lt;/code&gt; )이면 프로세스에 신호가 전송되지 않지만 &lt;a href=&quot;#kill-SIGNAL%2C-LIST&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; 은</target>
        </trans-unit>
        <trans-unit id="e68aad72417aeb3ce465d6bb5919f187ede4dff2" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt;, depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">SUBNAME 또는 블록이 생략되면, &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 표준 문자열 비교 순서에요. SUBNAME이 지정되면 목록의 요소 순서에 따라 &lt;code&gt;0&lt;/code&gt; 보다 작거나 같거나 큰 정수를 리턴하는 서브 루틴의 이름을 제공합니다 . ( &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 및 &lt;code&gt;cmp&lt;/code&gt; 연산자는 이러한 루틴에서 매우 유용합니다.) SUBNAME은 스칼라 변수 이름 (구독되지 않음) 일 수 있으며,이 경우 값은 사용할 실제 서브 루틴의 이름 (또는 참조)을 제공합니다. SUBNAME 대신 BLOCK을 익명의 인라인 정렬 서브 루틴으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e4af5120e01452063bdba16ab4dbac8800d707" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">SUBNAME 또는 BLOCK이 생략 된 경우 표준 문자열 비교 순서로 s를 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . SUBNAME을 지정 하면 목록의 요소를 정렬하는 방법에 따라 &lt;code&gt;0&lt;/code&gt; 보다 작거나 같거나 큰 정수를 리턴하는 서브 루틴의 이름을 제공합니다 . ( &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 및 &lt;code&gt;cmp&lt;/code&gt; 연산자는 이러한 루틴에서 매우 유용합니다.) SUBNAME은 스칼라 변수 이름 (미 첨자) 일 수 있으며,이 경우 값은 사용할 실제 서브 루틴의 이름 (또는 참조)을 제공합니다. SUBNAME 대신, 익명의 인라인 정렬 서브 루틴으로 BLOCK을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6247155ef0e0949eed5f5b9ad662fcdc5e0b1a55" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">SUBNAME 또는 BLOCK이 생략 된 경우 표준 문자열 비교 순서로 s를 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . SUBNAME을 지정 하면 목록의 요소를 정렬하는 방법에 따라 &lt;code&gt;0&lt;/code&gt; 보다 작거나 같거나 큰 정수를 리턴하는 서브 루틴의 이름을 제공합니다 . ( &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 및 &lt;code&gt;cmp&lt;/code&gt; 연산자는 이러한 루틴에서 매우 유용합니다.) SUBNAME은 스칼라 변수 이름 (미 첨자) 일 수 있으며,이 경우 값은 사용할 실제 서브 루틴의 이름 (또는 참조)을 제공합니다. SUBNAME 대신, 익명의 인라인 정렬 서브 루틴으로 BLOCK을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e18998d6455bfefedf4a886cffa8b0ef65421368" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; is given, &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">TEMPLATE에 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 이 제공된 것보다 더 많은 인수가 필요한 경우 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 은 추가 &lt;code&gt;&quot;&quot;&lt;/code&gt; 인수를 가정합니다 . TEMPLATE에 주어진 것보다 적은 인수가 필요한 경우 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a13dff4a6a23dd2b6f1693ccf60f7a4736231a4" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than pack() is given, pack() assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">TEMPLATE에 pack ()보다 많은 인수가 필요한 경우 pack ()은 추가 &lt;code&gt;&quot;&quot;&lt;/code&gt; 인수를 가정합니다 . TEMPLATE에 지정된 것보다 적은 수의 인수가 필요한 경우 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6967af7192ea24b7740b2426c675e802544ce8cd" translate="yes" xml:space="preserve">
          <source>If UTF-8 is not an option, it is recommended that one use a simple source filter, such as that provided by &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter::Encoding&lt;/a&gt; on CPAN or this pragma's own &lt;code&gt;Filter&lt;/code&gt; option (see below).</source>
          <target state="translated">UTF-8이 옵션이 아닌 경우 CPAN의 &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter :: Encoding&lt;/a&gt; 또는이 pragma의 자체 &lt;code&gt;Filter&lt;/code&gt; 옵션 (아래 참조) 에서 제공하는 것과 같은 간단한 소스 필터를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fcb29e6534b18adbdd32bd69eb254a626c55b85e" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (See &lt;a href=&quot;Test::API&quot;&gt;Test::API&lt;/a&gt;) then any event that has made its way through a hub will be tagged with a UUID. A newly created event will not yet be tagged in most cases.</source>
          <target state="translated">UUID 태그가 활성화 된 경우 ( &lt;a href=&quot;Test::API&quot;&gt;Test :: API&lt;/a&gt; 참조 ) 허브를 통과 한 모든 이벤트는 UUID로 태그가 지정됩니다. 새로 생성 된 이벤트는 대부분의 경우 아직 태그가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8de2a274592488096eee3c1b57b817384e167ac5" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (see &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt;) then the hub will have a UUID.</source>
          <target state="translated">UUID 태깅이 활성화 된 경우 ( &lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt; 참조 ) 허브에 UUID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="71eeb63629102190a2491abe8e8c2cd018b18803" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">소켓에 유닉스 레벨 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 가 적절하지 않다면, &quot;유닉스&quot;레이어를 &quot;소켓&quot;레이어로 (개방 시간 또는 동적으로) 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad97d1c9f2c86a7f96565662052eb1a286aaff7" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">만약 유닉스 레벨 &lt;code&gt;read&lt;/code&gt; / &lt;code&gt;write&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 가 (예를 들어) 소켓에 적합하지 않다면 &quot;유닉스&quot;레이어는 (오픈 시간에 또는 동적으로) &quot;소켓&quot;레이어로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45f1369b52ed08794c418037dc006ec04f43394" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; iterator in the process.</source>
          <target state="translated">VARIABLE이 해시이면 키가 아닌 해시 값을 잘라내어 프로세스 의 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 반복기를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="adc19b00b38eb533e11534d089e59dc6d18d7552" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">VARIABLE이 해시 인 경우 프로세스에서 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 키가 아닌 해시 값을 숨 깁니다 .</target>
        </trans-unit>
        <trans-unit id="dafdb7a192ed4ebf56859ae04ece9ebbc7f84c1d" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">VARIABLE이 해시 인 경우 프로세스에서 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 키가 아닌 해시 값을 숨 깁니다 .</target>
        </trans-unit>
        <trans-unit id="748a0699c69c26183bfd333929c05d94a8696f0e" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;a href=&quot;#package-NAMESPACE&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">VERSION이 제공되면 &lt;a href=&quot;#package-NAMESPACE&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; 는 제공된 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수를 VERSION이 제공된 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 개체로 설정합니다. VERSION은 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈에서 정의한 &quot;엄격한&quot;스타일 버전 번호 여야합니다. 지수가없는 양의 십진수 (정수 또는 소수) 또는 선행 'v'문자와 최소 3 개가있는 점으로 구분 된 십진수 v- 문자열 구성 요소. &lt;code&gt;$VERSION&lt;/code&gt; 은 패키지 당 한 번만 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a9c742cbb93e88b3095e1366a5e0ca8820689343" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">VERSION이 제공되면 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 는 제공된 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수를 VERSION이 제공된 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 객체로 설정합니다. VERSION은 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈에 의해 정의 된 &quot;엄격한&quot;스타일 버전 번호 여야합니다. 지수가없는 양의 10 진수 (정수 또는 10 진수) 또는 앞에 'v'문자가 있고 최소 3 개의 점이있는 10 진 v-string 구성 요소. 패키지 당 &lt;code&gt;$VERSION&lt;/code&gt; 한 번만 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4bfad8b6a5366a04a7526e534903361716196c11" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">VERSION이 제공되면 &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 는 제공된 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수를 VERSION이 제공된 &lt;a href=&quot;../version&quot;&gt;버전&lt;/a&gt; 객체로 설정합니다. VERSION은 &lt;a href=&quot;../version&quot;&gt;버전&lt;/a&gt; 모듈에 의해 정의 된 &quot;엄격한&quot;스타일 버전 번호 여야합니다. 지수가없는 양의 10 진수 (정수 또는 10 진수) 또는 앞에 'v'문자가 있고 최소 3 개의 점이있는 10 진 v-string 구성 요소. 패키지 당 &lt;code&gt;$VERSION&lt;/code&gt; 한 번만 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="d95c8bef773580433166be7c2c32b85e8e849e6f" translate="yes" xml:space="preserve">
          <source>If a 2-digit code is entered, it is converted to 3 digits by prepending a 0.</source>
          <target state="translated">2 자리 코드를 입력하면 앞에 0을 붙여 3 자리로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e64a7d7369be70b0218a1b95be79c2c2deb28c1d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; is used in a context that is looking for a list, a list comprising all input lines is returned, one line per list element. It's easy to grow to a rather large data space this way, so use with care.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; 목록을 찾고 문맥에서 사용되는 모든 입력 라인을 포함하는 목록이 목록 요소마다 1 개 라인을 반환한다. 이런 식으로 다소 큰 데이터 공간으로 쉽게 확장 할 수 있으므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="259cdf2dd383c0f84fbe2ca3b6aceeeeaeccb785" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt; ; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt; , a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 컨텍스트 스택에서 &lt;code&gt;CxEVAL&lt;/code&gt; 블록을 찾을 수 스택이 해당 레벨로 팝되고 해당 블록의 리턴 op가 &lt;code&gt;PL_restartop&lt;/code&gt; 에 할당됩니다 . 그런 다음 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 이 수행됩니다. 이것은 일반적으로 제어를 가드로 다시 전달합니다. &lt;code&gt;perl_run&lt;/code&gt; 및 &lt;code&gt;call_sv&lt;/code&gt; 의 경우 널이 아닌 &lt;code&gt;PL_restartop&lt;/code&gt; 트리거는 runops 루프에 다시 입력합니다. 일반적인 방법이다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 내에 처리 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e842b426c14ec5c17e64ac341313bcce514b5ce" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식이 유효한 경우 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) &lt;code&gt;\l&lt;/code&gt; 사용하는 케이스 맵 , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; 에서 은 현재 로케일에서 가져옵니다. 유니 코드 (예 : &lt;code&gt;\N{}&lt;/code&gt; 또는 코드 포인트 0x100 이상)를 사용하는 경우 &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; 사용하는 대소 문자 맵 은 유니 코드에서 정의한 것과 같습니다. 즉, 단일 문자를 대소 문자로 매핑하면 때때로 여러 문자의 시퀀스가 ​​생성 될 수 있습니다. 에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; 같은 결과를 &lt;code&gt;\L&lt;/code&gt; UTF-8을 제외한 모든 로케일의 경우 이며 대신 유니 코드 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="549e5fcf45cf7944f8141812970bb7a27ad11345" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">경우 &lt;code&gt;Net::POP3&lt;/code&gt; 객체가 범위를 벗어나 전에 &lt;code&gt;quit&lt;/code&gt; 방법은 다음 호출되는 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 연결이 닫히기 전에 메소드가 호출됩니다. 즉, 삭제 표시된 메시지는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a47a3059ef284fb95d6b9b8a42daebf746f1630a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;reset&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">경우 &lt;code&gt;Net::POP3&lt;/code&gt; 객체가 범위를 벗어나 전에 &lt;code&gt;quit&lt;/code&gt; 방법은 다음 호출되는 &lt;code&gt;reset&lt;/code&gt; 연결이 닫히기 전에 메소드가 호출됩니다. 즉, 삭제 된 것으로 표시된 메시지는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50ca4e33c078b9485b94c680710b01ed3f239b5b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;die&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt;; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt;, a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;die&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;die&lt;/code&gt; 가 컨텍스트 스택에서 &lt;code&gt;CxEVAL&lt;/code&gt; 블록을 찾을 수 있으면 스택이 해당 레벨로 팝되고 해당 블록의 리턴 연산이 &lt;code&gt;PL_restartop&lt;/code&gt; 에 할당됩니다 . 그런 다음 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 가 수행됩니다. 이것은 일반적으로 통제권을 경비원에게 넘깁니다. &lt;code&gt;perl_run&lt;/code&gt; 및 &lt;code&gt;call_sv&lt;/code&gt; 의 경우 null이 아닌 &lt;code&gt;PL_restartop&lt;/code&gt; 은 runops 루프에 대한 재진입을 트리거합니다. 이것은 &lt;code&gt;eval&lt;/code&gt; 내에서 &lt;code&gt;die&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 을 처리 하는 일반적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="bb19ff7cc72a6855d9adc1ecae2faf667648c06d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;glob&lt;/code&gt; expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a &lt;code&gt;glob&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;glob&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">경우 &lt;code&gt;glob&lt;/code&gt; 발현이의 상태로 사용되는 &lt;code&gt;while&lt;/code&gt; 나 &lt;code&gt;for&lt;/code&gt; 루프, 다음은 암시 적으로 할당됩니다 &lt;code&gt;$_&lt;/code&gt; . 어느 경우 &lt;code&gt;glob&lt;/code&gt; 표현 또는 명시 적 할당 &lt;code&gt;glob&lt;/code&gt; 스칼라에 대한 표현이 사용되는 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 조건 다음 조건은 실제로하지 정기적 인 진리 값에 대한 표현식의 값 definedness에 대한 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c439913b54ad4e9472f5fab7228ffbede4917134" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout&lt;/code&gt; in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; (초)이 제공되는 제한은 핑 () 메소드 (아래)에 부여되지 않은 경우, 사용된다. 제한 시간은 0보다 커야하며 지정되지 않은 경우 기본값은 5 초입니다.</target>
        </trans-unit>
        <trans-unit id="05512b28e37ad32af54fde978f1e0fe4ada4db04" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;use locale&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식이 유효한 경우 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ), &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; 에서 사용하는 케이스 맵 은 현재 로케일에서 가져옵니다. 유니 코드 (예 : &lt;code&gt;\N{}&lt;/code&gt; 또는 0x100 이상의 코드 포인트)를 사용하는 경우 &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\U&lt;/code&gt; 사용하는 케이스 맵 은 유니 코드에서 정의한 것과 같습니다. 즉, 단일 문자의 대소 문자 매핑은 때때로 여러 문자의 시퀀스를 생성 할 수 있음을 의미합니다. 에서 &lt;code&gt;use locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; 같은 결과 생산 &lt;code&gt;\L&lt;/code&gt; UTF-8을 제외한 모든 로케일에 대해 대신 유니 코드 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="043d74f31a25532198b1527d3ae5c4b1da9715ef" translate="yes" xml:space="preserve">
          <source>If a CODE reference is not used, a</source>
          <target state="translated">코드 참조가 사용되지 않으면</target>
        </trans-unit>
        <trans-unit id="e12066458359083bdcf249636aa07df8a14816c7" translate="yes" xml:space="preserve">
          <source>If a CODE reference is used then a</source>
          <target state="translated">코드 참조가 사용 된 경우</target>
        </trans-unit>
        <trans-unit id="f9ad0abaf0eff45a492a44f419b412cf87f4dd03" translate="yes" xml:space="preserve">
          <source>If a FILEHANDLE is supplied, it must be writable and opened in append mode (i.e., use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt;. If a filename is supplied, it should not be held open elsewhere. (Win32)</source>
          <target state="translated">FILEHANDLE이 제공되면 쓰기 가능해야하며 추가 모드에서 열어야합니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt; . 파일 이름이 제공되면 다른 곳에서는 열지 말아야합니다 (Win32).</target>
        </trans-unit>
        <trans-unit id="4d47de1f691dd0b1134ca70f07b0ea6e9d81891d" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt;-marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding.</source>
          <target state="translated">Perl 스크립트가 유니 코드 &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE)으로 시작하거나 스크립트가 엔디안의 &lt;code&gt;BOM&lt;/code&gt; 표시가없는 UTF-16 처럼 보이는 경우 Perl은 스크립트에서 적절한 유니 코드 인코딩으로 올바르게 읽습니다.</target>
        </trans-unit>
        <trans-unit id="24e2f604f1de94503f88fcf2788fa5b11ed58ca8" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the bytes that form the UTF-8 encoding of the Unicode BYTE ORDER MARK (&lt;code&gt;BOM&lt;/code&gt;, see &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;), those bytes are completely ignored.</source>
          <target state="translated">Perl 스크립트가 Unicode BYTE ORDER MARK ( &lt;code&gt;BOM&lt;/code&gt; , &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;유니 코드 인코딩&quot;&lt;/a&gt; 참조) 의 UTF-8 인코딩을 형성하는 바이트로 시작하는 경우 해당 바이트는 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3af3f41934dd0fe8f979cc12d4f4c701b5fb0dcf" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any command other than the ones listed above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by default treat this as an error. It must not process the paragraph beginning with that command, must by default warn of this as an error, and may abort the parse. A Pod parser may allow a way for particular applications to add to the above list of known commands, and to stipulate, for each additional command, whether formatting codes should be processed.</source>
          <target state="translated">포드 프로세서에 위에 나열된 명령 이외의 명령 (예 : &quot;= head&quot;또는 &quot;= haed1&quot;또는 &quot;= stuff&quot;또는 &quot;= cuttlefish&quot;또는 &quot;= w123&quot;)이 표시되면 해당 프로세서는 기본적으로 이것을 오류로 취급하십시오. 해당 명령으로 시작하는 단락을 처리해서는 안되며, 기본적으로이를 오류로 경고하고 구문 분석을 중단 할 수 있습니다. 포드 파서는 특정 애플리케이션이 상기 알려진 커맨드의 목록에 추가하고, 포맷 코드가 처리되어야하는지의 여부를 추가 커맨드마다 규정하는 방법을 허용 할 수있다.</target>
        </trans-unit>
        <trans-unit id="84d7b60c1fec814496b3c4bc1816a8d5d03c5699" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any formatting code other than the ones listed above (as in &quot;N&amp;lt;...&amp;gt;&quot;, or &quot;Q&amp;lt;...&amp;gt;&quot;, etc.), that processor must by default treat this as an error. A Pod parser may allow a way for particular applications to add to the above list of known formatting codes; a Pod parser might even allow a way to stipulate, for each additional command, whether it requires some form of special processing, as L&amp;lt;...&amp;gt; does.</source>
          <target state="translated">Pod 프로세서가 위에 나열된 것 이외의 형식 코드 ( &quot;N &amp;lt;...&amp;gt;&quot;또는 &quot;Q &amp;lt;...&amp;gt;&quot;등)를 발견하면 해당 프로세서는 기본적으로이를 오류로 처리해야합니다. . 포드 파서는 특정 애플리케이션이 상기 알려진 포맷팅 코드 목록에 추가하는 방법을 허용 할 수있다. 포드 파서는 L &amp;lt;...&amp;gt;처럼 특정 형태의 특수 처리가 필요한지 여부에 관계없이 추가 명령마다 규정하는 방법을 허용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a69d2c6e5370a359253a714b367c144cea0b32a3" translate="yes" xml:space="preserve">
          <source>If a SKIP directive is included with the plan, this method will return it.</source>
          <target state="translated">SKIP 지시문이 계획에 포함되어 있으면이 메소드가이를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fc36fbb42452cd08e5fbc977b40571fcb5ba6163" translate="yes" xml:space="preserve">
          <source>If a SKIP directive was included with the plan, this method will return the explanation, if any.</source>
          <target state="translated">SKIP 지시문이 계획에 포함 된 경우이 메소드는 설명이있는 경우 설명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="21c8d4e7e9fdf0b61712f2ee7b9d5069189ec21c" translate="yes" xml:space="preserve">
          <source>If a TODO test does succeed, then the feature in question shouldn't be on the TODO list, now should it?</source>
          <target state="translated">TODO 테스트가 성공하면 해당 기능이 TODO 목록에 없어야합니다. 이제해야합니까?</target>
        </trans-unit>
        <trans-unit id="2e556764eb70dadb149264cc71dd4704e1aa8ecf" translate="yes" xml:space="preserve">
          <source>If a TODO test passes, &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will report it &quot;UNEXPECTEDLY SUCCEEDED&quot;. When that happens, remove the TODO block with &lt;code&gt;local $TODO&lt;/code&gt; and turn it into a real test.</source>
          <target state="translated">TODO 테스트가 통과되면 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 &quot;예상치 못한 성공&quot;을보고합니다. 이 경우 &lt;code&gt;local $TODO&lt;/code&gt; TODO 블록을 제거하고 실제 테스트로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc13fa8b4104f174148a214dadae282567de13a" translate="yes" xml:space="preserve">
          <source>If a character that isn't an octal digit is encountered, a warning is raised, and the value is based on the octal digits before it, discarding it and all following characters up to the closing brace. It is a fatal error if there are no octal digits at all.</source>
          <target state="translated">8 진수가 아닌 문자가 발견되면 경고가 발생하고 값은 8 진수 이전의 8 진수를 기준으로하며 그 뒤에있는 모든 문자와 닫는 중괄호까지 버립니다. 8 진수가 전혀 없으면 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b895fdf53ccf75b6f1d6a0f2ed9f43fb2b3e2bde" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;&quot;Scalar values&quot; in perldata&lt;/a&gt;):</source>
          <target state="translated">비어 있지 않은지 확인하는 것이 원하는 것이면 부울 컨텍스트에 넣습니다 ( &lt;a href=&quot;perldata#Scalar-values&quot;&gt;perldata의 &quot;스칼라 값&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="22ce7778730981e7a416c117aaec163fa0497dba" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;Scalar values in perldata&lt;/a&gt;):</source>
          <target state="translated">비어 있지 않은 검사가 원하는 경우 부울 컨텍스트에 넣습니다 ( &lt;a href=&quot;perldata#Scalar-values&quot;&gt;perldata의 스칼라 값&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7bbe66a04a030c6e054fb0dfd4a30c2a7ed6df30" translate="yes" xml:space="preserve">
          <source>If a child calls &quot;skip_all&quot; in the plan, a &lt;code&gt;Test::Builder::Exception&lt;/code&gt; is thrown. Trap this error, call &lt;code&gt;finalize()&lt;/code&gt; and don't run any more tests on the child.</source>
          <target state="translated">자녀가 계획에서 &quot;skip_all&quot;을 호출하면 &lt;code&gt;Test::Builder::Exception&lt;/code&gt; 이 발생합니다. 이 오류를 해결하고 &lt;code&gt;finalize()&lt;/code&gt; 호출 하고 자식에 대해 더 이상 테스트를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d87e3904bd84922ce3c7497d798c1def1d62966e" translate="yes" xml:space="preserve">
          <source>If a collation sequence is not given, a default collation sequence is used. If the base is less than or equal to 36, the collation sequence is the string consisting of the 36 characters &quot;0&quot; to &quot;9&quot; and &quot;A&quot; to &quot;Z&quot;. In this case, the letter case in the input is ignored. If the base is greater than 36, and smaller than or equal to 62, the collation sequence is the string consisting of the 62 characters &quot;0&quot; to &quot;9&quot;, &quot;A&quot; to &quot;Z&quot;, and &quot;a&quot; to &quot;z&quot;. A base larger than 62 requires the collation sequence to be specified explicitly.</source>
          <target state="translated">데이터 정렬 시퀀스가 ​​제공되지 않으면 기본 데이터 정렬 시퀀스가 ​​사용됩니다. 기준이 36보다 작거나 같으면 조합 시퀀스는 36 자 &quot;0&quot;- &quot;9&quot;및 &quot;A&quot;- &quot;Z&quot;로 구성된 문자열입니다. 이 경우 입력의 대소 문자는 무시됩니다. 기준이 36보다 크고 62보다 작거나 같은 경우 조합 시퀀스는 62 자 &quot;0&quot;- &quot;9&quot;, &quot;A&quot;- &quot;Z&quot;및 &quot;a&quot;- &quot;z&quot;로 구성된 문자열입니다. &quot;. 62보다 큰 기본은 데이터 정렬 시퀀스를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e2b6a0e0e45f39177eb31d01e15e452bd57cce8" translate="yes" xml:space="preserve">
          <source>If a comparison subroutine (comp) is defined, it must return less than zero, zero, or greater than zero, if the first comparand is less than, equal, or greater than the second comparand.</source>
          <target state="translated">비교 서브 루틴 (comp)이 정의 된 경우, 첫 번째 비교가 두 번째 비교보다 작거나 같거나 크면 0보다 작거나 0보다 크거나 0보다 큰 값을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bcefbb01c642f7f0fc9b06ad8c1d9b86690b30e" translate="yes" xml:space="preserve">
          <source>If a config variable name ends with &lt;code&gt;list&lt;/code&gt; , it is a list. &lt;code&gt;o conf
KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; removes the first element of the list, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; removes the last element of the list. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; prepends a list of values to the list, &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; appends a list of valued to the list.</source>
          <target state="translated">구성 변수 이름이 &lt;code&gt;list&lt;/code&gt; 로 끝나는 경우 목록입니다. &lt;code&gt;o conf KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 는 목록의 첫 번째 요소를 제거하고 &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 목록의 마지막 요소를 제거합니다. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; 는 값 목록을 목록 앞에 추가합니다. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; 은 목록에 값 목록을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5109117db036bd8645f50a5e04d368af63084ec5" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; , any other thread doing a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; won't block.</source>
          <target state="translated">해시 또는 배열과 같은 컨테이너 객체가 잠겨 있으면 해당 컨테이너의 모든 요소가 잠기지 않습니다. 스레드는 않는다 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; 하는 일 다른 쓰레드 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; 차단하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="0b9475795c5acef3f94e436ae886fcd1f2079b25" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;lock @a&lt;/code&gt;, any other thread doing a &lt;code&gt;lock($a[12])&lt;/code&gt; won't block.</source>
          <target state="translated">해시 또는 배열과 같은 컨테이너 개체가 잠겨 있으면 해당 컨테이너의 모든 요소가 잠기지 않습니다. 예를 들어 스레드가 &lt;code&gt;lock @a&lt;/code&gt; &lt;code&gt;lock($a[12])&lt;/code&gt; 수행하면 lock ($ a [12]) 을 수행하는 다른 스레드 는 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86e40904bfdd4ce1f2ea77e8cac744710e6b6d3c" translate="yes" xml:space="preserve">
          <source>If a custom key refers to a data structure, a deep clone is returned.</source>
          <target state="translated">사용자 지정 키가 데이터 구조를 참조하는 경우 전체 복제가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35f34b9c616480c978cfd69625d6aeaae5e87694" translate="yes" xml:space="preserve">
          <source>If a data type is a Map or Map subtype, valid subkeys will be described as well.</source>
          <target state="translated">데이터 유형이 Map 또는 Map 하위 유형 인 경우 유효한 하위 키도 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="dca4e72f15d2d8185a5bffef1f8b63be490eec41" translate="yes" xml:space="preserve">
          <source>If a default timeout ($def_timeout) in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">기본 시간 초과 ($ def_timeout)가 초 단위로 제공되면 ping () 메소드에 시간 초과가 제공되지 않을 때 사용됩니다 (아래). 제한 시간은 0보다 커야하며, 지정되지 않은 경우 기본값은 5 초입니다.</target>
        </trans-unit>
        <trans-unit id="9cb3d5a547282377cc66b4c5457632db46bb8ed9" translate="yes" xml:space="preserve">
          <source>If a dereference operator is overloaded then it must return a</source>
          <target state="translated">역 참조 연산자에 과부하가 걸리면</target>
        </trans-unit>
        <trans-unit id="fe98464b03f834d1a964476866ec0454738cfc5e" translate="yes" xml:space="preserve">
          <source>If a directory name is specified, Perl will switch to that directory before running the program. The &lt;b&gt;-x&lt;/b&gt; switch controls only the disposal of leading garbage. The program must be terminated with &lt;code&gt;__END__&lt;/code&gt; if there is trailing garbage to be ignored; the program can process any or all of the trailing garbage via the &lt;code&gt;DATA&lt;/code&gt; filehandle if desired.</source>
          <target state="translated">디렉토리 이름이 지정되면 Perl은 프로그램을 실행하기 전에 해당 디렉토리로 전환합니다. &lt;b&gt;-x&lt;/b&gt; 스위치는 선도적 인 쓰레기의 처분을 제어합니다. 무시할 가비지가있는 경우 &lt;code&gt;__END__&lt;/code&gt; 로 프로그램을 종료해야합니다 . 프로그램은 &lt;code&gt;DATA&lt;/code&gt; 를 통해 후행 쓰레기의 일부 또는 전부를 처리 할 수 ​​있습니다 원하는 경우 파일 핸들을 .</target>
        </trans-unit>
        <trans-unit id="5aaf565f5088172c3b4f50e88e5260fa4d43f871" translate="yes" xml:space="preserve">
          <source>If a distribution defines a minimal required perl version, this is added to the output as an additional line of the form:</source>
          <target state="translated">배포판이 최소한의 필수 perl 버전을 정의하면 다음과 같은 형식의 추가 행으로 출력에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="42b6266ffbedee9d19b5a6a2dc00e2ab21c075e3" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">false 값 ( &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 아님)이 전달되면 &lt;code&gt;overrideHangul&lt;/code&gt; 이 적용되지 않습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; 은 이전 것을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="d7bef52fc8efdf02d89c731e11f307c96984c0d4" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">false 값 ( &lt;code&gt;undef&lt;/code&gt; 아님)이 전달되면 &lt;code&gt;overrideHangul&lt;/code&gt; 은 적용되지 않습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; 은 이전 항목을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="41f3060c136c5cb39245327e845028b89a018338" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">잘못된 값 ( &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 포함 )이 전달되면 &lt;code&gt;overrideCJK&lt;/code&gt; 가 적용되지 않습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; 는 이전 것을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="4ce3e5ab6913747cb34ccc5fe411d22f75b39a20" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">잘못된 값 ( &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 포함 )이 전달되면 &lt;code&gt;overrideOut&lt;/code&gt; 이 적용되지 않습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; 은 이전 것을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="2efe2419737305523ab6685944b8e5967c625c40" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">false 값 ( &lt;code&gt;undef&lt;/code&gt; 포함 )이 전달되면 &lt;code&gt;overrideCJK&lt;/code&gt; 는 효과가 없습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; 이전 버전을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="b769b78df558ed0ae95630bec3fdf7981f2aba03" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">false 값 ( &lt;code&gt;undef&lt;/code&gt; 포함 )이 전달되면 &lt;code&gt;overrideOut&lt;/code&gt; 은 적용되지 않습니다. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; 은 이전 항목을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="14cf492ed81687842dddeeef058d5e33b14e6b8c" translate="yes" xml:space="preserve">
          <source>If a field width obtained through &lt;code&gt;*&lt;/code&gt; is negative, it has the same effect as the &lt;code&gt;-&lt;/code&gt; flag: left-justification.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 통해 얻은 필드 너비 가 음수이면 &lt;code&gt;-&lt;/code&gt; 와 같은 효과가 있습니다. 플래그 : 왼쪽 정렬 .</target>
        </trans-unit>
        <trans-unit id="b67747c87623a5829c474216ed820d9c376a76fd" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">어떤 이유로 인수로 명명 된 파일을 열 수없는 경우 Perl은 이에 대해 경고하고 다음 파일로 이동합니다. 선은 자동으로 인쇄됩니다. 인쇄 중에 발생하는 오류는 치명적인 것으로 간주됩니다. 인쇄를 억제하려면 &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; 스위치를 사용하십시오 . &lt;b&gt;-p&lt;/b&gt; 재정의하는 &lt;b&gt;-n&lt;/b&gt; 스위치.</target>
        </trans-unit>
        <trans-unit id="9605e9893d52ad305cb79e90d906d025024d5412" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;b&gt;-n&lt;/b&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">어떤 이유로 인수로 명명 된 파일을 열 수없는 경우 Perl은 이에 대해 경고하고 다음 파일로 이동합니다. 줄이 자동으로 인쇄됩니다. 인쇄 중에 발생하는 오류는 치명적인 것으로 처리됩니다. 인쇄를 억제하려면 &lt;b&gt;-n&lt;/b&gt; 스위치를 사용하십시오 . &lt;b&gt;-p&lt;/b&gt; 재정의하는 &lt;b&gt;-n&lt;/b&gt; 스위치.</target>
        </trans-unit>
        <trans-unit id="7607c4673d0f39465175ed86077289b9bf56cef9" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a key from a DBM database.</source>
          <target state="translated">이 방법으로 필터를 설치 한 경우 DBM 데이터베이스에서 키를 읽을 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ffcdc45cfdda9fabc4fc72ffad32b6bd83924c58" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a value from a DBM database.</source>
          <target state="translated">이 방법으로 필터를 설치 한 경우 DBM 데이터베이스에서 값을 읽을 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cd250eca2a3b32b9a72984e5551322c2a78954ba" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a key to a DBM database.</source>
          <target state="translated">이 방법으로 필터를 설치 한 경우 DBM 데이터베이스에 키를 쓸 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4a7b6c0f00f48df8682a8b26e45e64646603ea" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a value to a DBM database.</source>
          <target state="translated">이 방법으로 필터를 설치 한 경우 DBM 데이터베이스에 값을 쓸 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="07c279eee0e239fdbb7a9180f0e7ca0c343b1372" translate="yes" xml:space="preserve">
          <source>If a finalized set of requirements is cloned, the cloned requirements are not also finalized.</source>
          <target state="translated">최종 요구 사항 집합이 복제되면 복제 된 요구 사항도 마무리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3c644e7c4d09f78ea460ddc805cbed0f24eef71" translate="yes" xml:space="preserve">
          <source>If a fully qualified $class is given, its abbreviated version is checked first.</source>
          <target state="translated">정규화 된 $ class가 제공되면 약어 버전이 먼저 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="61efacc190b96b684717f3100b2802427ca3f5f2" translate="yes" xml:space="preserve">
          <source>If a hyphen in a character class cannot syntactically be part of a range, for instance because it is the first or the last character of the character class, or if it immediately follows a range, the hyphen isn't special, and so is considered a character to be matched literally. If you want a hyphen in your set of characters to be matched and its position in the class is such that it could be considered part of a range, you must escape that hyphen with a backslash.</source>
          <target state="translated">문자 클래스의 하이픈이 구문 적으로 범위의 일부가 될 수없는 경우 (예 : 문자 클래스의 첫 번째 또는 마지막 문자이므로) 또는 범위 바로 뒤에 오는 경우 하이픈은 특별하지 않으므로 고려됩니다. 문자 그대로 일치하는 문자. 문자 세트의 하이픈을 일치시키고 클래스에서의 위치가 범위의 일부로 간주 될 수 있도록하려면 하이픈을 백 슬래시로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e9b736d2bd9dc9660e81744f77377a13eb0a302" translate="yes" xml:space="preserve">
          <source>If a key appears more than once in the initializer list of a hash, the last occurrence wins:</source>
          <target state="translated">해시의 이니셜 라이저 목록에 키가 두 번 이상 나타나면 마지막 항목이 승리합니다.</target>
        </trans-unit>
        <trans-unit id="e38101b895429346e058b0e8e435924731bb16b2" translate="yes" xml:space="preserve">
          <source>If a layer provides &lt;code&gt;Open()&lt;/code&gt; it should normally call the &lt;code&gt;Open()&lt;/code&gt; method of next layer down (if any) and then push itself on top if that succeeds. &lt;code&gt;PerlIOBase_open&lt;/code&gt; is provided to do exactly that, so in most cases you don't have to write your own &lt;code&gt;Open()&lt;/code&gt; method. If this method is not defined, other layers may have difficulty pushing themselves on top of it during open.</source>
          <target state="translated">레이어가 &lt;code&gt;Open()&lt;/code&gt; 제공하는 경우 일반적으로 다음 레이어 의 &lt;code&gt;Open()&lt;/code&gt; 메소드를 호출 한 다음 (있는 경우) 맨 위로 밀어야합니다. &lt;code&gt;PerlIOBase_open&lt;/code&gt; 은 정확히 그렇게하기 위해 제공되므로 대부분의 경우 자신의 &lt;code&gt;Open()&lt;/code&gt; 을 작성할 필요가 없습니다. 메소드 . 이 방법을 정의하지 않으면 다른 레이어가 열려있는 동안 레이어 위로 밀기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dbe9c1af884c682c784ff2164f939b559495d3" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt; ) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt; .</source>
          <target state="translated">어휘 변수에 속성이 제공되면 해당 변수에 속하는 기호 테이블이 없으므로 기호 테이블 인수 ( &lt;code&gt;$_[1]&lt;/code&gt; )가 문자열 &lt;code&gt;'LEXICAL'&lt;/code&gt; 로 설정됩니다 . 마찬가지로, 익명 서브 루틴에 속성을 부여하면 기호 테이블 인수 &lt;code&gt;'ANON'&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e69004ab41c9f2ba069a062aa5bbadc27b894ffc" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt;) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt;.</source>
          <target state="translated">어휘 변수에 속성이 주어지면 해당 변수가 속한 기호 테이블 이 &lt;code&gt;'LEXICAL'&lt;/code&gt; 경우 기호 테이블 인수 ( &lt;code&gt;$_[1]&lt;/code&gt; )는 문자열 'LEXICAL' 로 설정됩니다 . 마찬가지로 익명 서브 루틴에 속성을 지정하면 &lt;code&gt;'ANON'&lt;/code&gt; 기호 테이블 인수가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="373e9d26b4e220dbf14e875851af78e4ef70cdec" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt; . A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt; . The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">소스 스트림에서 라인을 사용할 수있는 경우 &lt;code&gt;filter_read()&lt;/code&gt; 는 0보다 큰 상태 값을 리턴하고 라인을 &lt;code&gt;$_&lt;/code&gt; 추가합니다 . 상태 값이 0이면 파일 끝을 나타내고 0보다 작 으면 오류를 나타냅니다. 필터 함수 자체는 같은 방식으로 상태를 반환하고 소스 스트림에 쓰려는 필터링 된 행을 &lt;code&gt;$_&lt;/code&gt; 넣습니다 . 사용 &lt;code&gt;$_&lt;/code&gt; 대부분의 펄 소스 필터의 간결함을 차지한다.</target>
        </trans-unit>
        <trans-unit id="b437e27438def56dcad1625b5eefb30ef0e6432f" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt;. A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt;. The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">소스 스트림에서 라인을 사용할 수있는 경우 &lt;code&gt;filter_read()&lt;/code&gt; 는 0보다 큰 상태 값을 반환하고 해당 라인을 &lt;code&gt;$_&lt;/code&gt; 추가합니다 . 상태 값이 0이면 파일 끝을 나타내고 0보다 작 으면 오류를 의미합니다. 필터 함수 자체는 동일한 방식으로 상태를 반환하고 &lt;code&gt;$_&lt;/code&gt; 의 소스 스트림에 쓰고 자하는 필터링 된 행을 넣습니다 . &lt;code&gt;$_&lt;/code&gt; 의 사용은 대부분의 Perl 소스 필터의 간결함을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9579e356ad7f9bb206c2b31ab9df7d7dd13fd989" translate="yes" xml:space="preserve">
          <source>If a list is given then it is evaluated from left to right so that any specifications in the list that conflict with a previous specification are overridden by the later.</source>
          <target state="translated">목록이 제공되면 왼쪽에서 오른쪽으로 평가되어 이전 사양과 충돌하는 목록의 모든 사양이 나중에 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="eb73e02f11dc05b75008088bd5b205cf808a5add" translate="yes" xml:space="preserve">
          <source>If a matching entry cannot be found, and a default entry exists, then a reference to the default entry is returned.</source>
          <target state="translated">일치하는 항목을 찾을 수없고 기본 항목이 있으면 기본 항목에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c613dbc045a6d1ccd39d5e4d8985654cb6efdedb" translate="yes" xml:space="preserve">
          <source>If a message can be controlled by the &lt;code&gt;warnings&lt;/code&gt; pragma, its warning category is included with the classification letter in the description below. E.g. &lt;code&gt;(W closed)&lt;/code&gt; means a warning in the &lt;code&gt;closed&lt;/code&gt; category.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; pragma 로 메시지를 제어 할 수있는 경우 해당 경고 범주는 아래 설명의 분류 문자에 포함됩니다. 예를 들어 &lt;code&gt;(W closed)&lt;/code&gt; 는 &lt;code&gt;closed&lt;/code&gt; 범주 의 경고를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f00576e48e7083129f4536c4d9542b2af3efddb9" translate="yes" xml:space="preserve">
          <source>If a method for an operation is not found then Perl tries to autogenerate a substitute implementation from the operations that have been defined.</source>
          <target state="translated">오퍼레이션의 메소드를 찾지 못하면 Perl은 정의 된 오퍼레이션에서 대체 구현을 자동 생성하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0bdd74a3b17bde34780674e393224f07968f9f1d" translate="yes" xml:space="preserve">
          <source>If a module attempts to import any of these symbols the Exporter will give the module an opportunity to handle the situation before generating an error. The Exporter will call an export_fail method with a list of the failed symbols:</source>
          <target state="translated">모듈이 이러한 기호 중 하나를 가져 오려고 시도하면 내보내기는 오류를 생성하기 전에 상황을 처리 할 수있는 기회를 모듈에 제공합니다. 내보내기는 실패한 심볼 목록과 함께 export_fail 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a6c5a19663c54ceb738fad6d48fbb290bbe10648" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">어떤 이유로 모듈이 빌드되지 않으면 실패한 이유를주의 깊게 살펴보고 모듈 작성자에게 문제를보고하십시오. 확장 빌드 지원에 문제가있는 것 같으면 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; 에서 GitHub 문제 추적기를 사용하여 빌드 실패에 대한 자세한 내용을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="46e9244ade28e8f11cc0bc5968d58da31945ce21" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the perlbug utility.</source>
          <target state="translated">어떤 이유로 모듈이 빌드되지 않으면 실패한 이유를주의해서 살펴보고 모듈 작성자에게 문제점을보고하십시오. 확장 빌드 지원에 결함이있는 것 같으면 perlbug 유틸리티를 사용하여 빌드가 실패한 방법에 대한 전체 세부 사항을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="094a8b4d892c0d307d87dac5429320ae267e0ba1" translate="yes" xml:space="preserve">
          <source>If a module implements XSUBs, you will need one of the supported C compilers. You must make sure you have set up the environment for the compiler for command-line compilation before running &lt;code&gt;perl Makefile.PL&lt;/code&gt; or any invocation of make.</source>
          <target state="translated">모듈이 XSUB를 구현하는 경우 지원되는 C 컴파일러 중 하나가 필요합니다. &lt;code&gt;perl Makefile.PL&lt;/code&gt; 또는 make 호출을 실행하기 전에 명령 행 컴파일을위한 컴파일러 환경을 설정했는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9711733a9e84337767e9b5acb7ff59757c774ea1" translate="yes" xml:space="preserve">
          <source>If a name does not already have a suitable prefix and/or suffix then the corresponding file will be searched for by trying combinations of prefix and suffix appropriate to the platform: &quot;$name.o&quot;, &quot;lib$name.*&quot; and &quot;$name&quot;.</source>
          <target state="translated">이름에 적절한 접두사 및 / 또는 접미사가없는 경우 플랫폼에 적합한 접두사와 접미사를 조합하여 해당 파일을 검색합니다 : &quot;$ name.o&quot;, &quot;lib $ name. *&quot;및 &quot; $ name &quot;.</target>
        </trans-unit>
        <trans-unit id="71674c3e4540508bc53564e31d00df9a0af1f1d2" translate="yes" xml:space="preserve">
          <source>If a name resolve operation fails to provide a name, then this flag will cause getnameinfo() to indicate an error, rather than returning the numeric representation as a human-readable string.</source>
          <target state="translated">이름 해석 조작이 이름을 제공하지 못하면,이 플래그는 숫자 표시를 사람이 읽을 수있는 문자열로 리턴하지 않고 getnameinfo ()가 오류를 표시하게합니다.</target>
        </trans-unit>
        <trans-unit id="31b368c0d757e116a5dfb072a97b4193c426b9b0" translate="yes" xml:space="preserve">
          <source>If a negative array index is used to read from an array, the index will be translated to a positive one internally by calling FETCHSIZE before being passed to FETCH. You may disable this feature by assigning a true value to the variable &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; in the tied array class.</source>
          <target state="translated">음수 배열 인덱스를 사용하여 배열을 읽으면 FETCH에 전달되기 전에 FETCHSIZE를 호출하여 인덱스가 내부적으로 양수로 변환됩니다. 연결된 배열 클래스 의 변수 &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; 에 true 값을 할당하여이 기능을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77fd7f19527eab5261c210a54c173bb0abc87920" translate="yes" xml:space="preserve">
          <source>If a package uses overload, it carries a special flag. This flag is also set when new functions are defined or @ISA is modified. There will be a slight speed penalty on the very first operation thereafter that supports overloading, while the overload tables are updated. If there is no overloading present, the flag is turned off. Thus the only speed penalty thereafter is the checking of this flag.</source>
          <target state="translated">패키지가 과부하를 사용하는 경우 특수 플래그를 전달합니다. 이 플래그는 새로운 함수가 정의되거나 @ISA가 수정 될 때도 설정됩니다. 오버로드를 지원하는 첫 번째 작업에는 오버로드 테이블이 업데이트되는 동안 약간의 속도 저하가 있습니다. 과부하가 없으면 플래그가 꺼집니다. 따라서 이후의 유일한 속도 불이익은이 플래그를 점검하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eef6b1875e2dcae080c75ee35ffb78afc980a5f8" translate="yes" xml:space="preserve">
          <source>If a pattern does not contain a special backtracking verb that allows an argument, then &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; are not touched at all.</source>
          <target state="translated">패턴에 인수를 허용하는 특수 역 &lt;code&gt;$REGERROR&lt;/code&gt; 동사가 포함되어 있지 않으면 $ REGERROR 및 &lt;code&gt;$REGMARK&lt;/code&gt; 에 전혀 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f0b6253b5fcfd411b56a12da1005e8889d7cecd" translate="yes" xml:space="preserve">
          <source>If a piece of code is under the control of the &lt;code&gt;warnings&lt;/code&gt; pragma, both the &lt;code&gt;$^W&lt;/code&gt; variable and the &lt;b&gt;-w&lt;/b&gt; flag will be ignored for the scope of the lexical warning.</source>
          <target state="translated">코드 조각이 &lt;code&gt;warnings&lt;/code&gt; pragma 의 제어하에있는 경우 &lt;code&gt;$^W&lt;/code&gt; 변수와 &lt;b&gt;-w&lt;/b&gt; 플래그가 어휘 경고 범위에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dc66a04b7fd6c8f1331b2adb91a4455713a61616" translate="yes" xml:space="preserve">
          <source>If a plan has not yet been output, it will do so.</source>
          <target state="translated">계획이 아직 출력되지 않은 경우 계획이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d2f49ea2b290886ecf360d9425d5113040021a" translate="yes" xml:space="preserve">
          <source>If a precision obtained through &lt;code&gt;*&lt;/code&gt; is negative, it counts as having no precision at all.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 통해 얻은 정밀도 가 음수이면 정밀도가 전혀없는 것으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2493d17a98c3b1f685aa6fcd91f6a228a3382409" translate="yes" xml:space="preserve">
          <source>If a precompiled pattern is embedded in a larger pattern then the effect of &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; will be propagated appropriately. The effect that the &lt;code&gt;/o&lt;/code&gt; modifier has is not propagated, being restricted to those patterns explicitly using it.</source>
          <target state="translated">미리 컴파일 된 패턴이 더 큰 패턴에 포함되면 &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; 의 효과가 적절하게 전파됩니다. &lt;code&gt;/o&lt;/code&gt; 수정자가 갖는 효과 는 전파되지 않고 명시 적으로 사용하는 패턴으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="cfe77c7e04c6532a52f2ea4bb204b4b081b46114" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">프로그램 환경이 LC_NUMERIC 로케일을 지정 하고 형식을 선언 할 때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우, 로케일은 형식화 된 출력에서 ​​소수점 문자를 지정하는 데 사용됩니다. write ()가 호출 될 때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용하여&lt;/a&gt; 형식화 된 출력을 제어 할 수 없습니다 . 로케일 처리에 대한 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bedf07956f494f1e8bca1dc60af93c0e865cbc39" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;use locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;use locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">프로그램의 환경이 LC_NUMERIC 로케일을 지정 하고 형식이 선언 될 때 &lt;code&gt;use locale&lt;/code&gt; 이 유효한 경우 로케일은 형식화 된 출력에서 ​​소수점 문자를 지정하는 데 사용됩니다. 형식화 된 출력은 write ()가 호출 될 때 &lt;code&gt;use locale&lt;/code&gt; 을 사용 하여 제어 할 수 없습니다 . 로케일 처리에 대한 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f41131148d4a0b9a531181bbeee21c21fa27808" translate="yes" xml:space="preserve">
          <source>If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">속성이 더 이상 사용되지 않는 경우 등의 항목은 &lt;b&gt;D&lt;/b&gt; 또는 &lt;b&gt;S&lt;/b&gt; 와 같이 &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;위 섹션&lt;/a&gt; 의 표에 사용 된 동일한 문자로 플래그가 지정됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbdd7653484d14bb99878153118f9a9fc7a64201" translate="yes" xml:space="preserve">
          <source>If a queue is empty, &lt;code&gt;dequeue()&lt;/code&gt; blocks until another thread enqueues something. This makes queues ideal for event loops and other communications between threads.</source>
          <target state="translated">큐가 비어 있으면 다른 스레드가 무언가를 큐에 넣을 때까지 &lt;code&gt;dequeue()&lt;/code&gt; 차단됩니다. 따라서 큐는 이벤트 루프 및 스레드 간 기타 통신에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="d8a808372475f8c939dd3899bae64db28b71a73e" translate="yes" xml:space="preserve">
          <source>If a reference happens to be a reference to an object, then there are probably methods to access the things referred to, and you should probably stick to those methods unless you're in the class package that defines the object's methods. In other words, be nice, and don't violate the object's encapsulation without a very good reason. Perl does not enforce encapsulation. We are not totalitarians here. We do expect some basic civility though.</source>
          <target state="translated">참조가 객체에 대한 참조 인 경우, 참조 된 것들에 액세스하는 메소드가있을 수 있으며, 객체의 메소드를 정의하는 클래스 패키지에 있지 않는 한 해당 메소드를 고수해야합니다. 다시 말해, 아주 좋은 이유없이 객체의 캡슐화를 위반하지 마십시오. Perl은 캡슐화를 시행하지 않습니다. 우리는 전체 주의자가 아닙니다. 우리는 약간의 기본 시민을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="c8efe9417a8ca522054e8e0f20aa5ebe3ad20734" translate="yes" xml:space="preserve">
          <source>If a regexp has a variable that interpolates a code expression, Perl treats the regexp as an error. If the code expression is precompiled into a variable, however, interpolating is ok. The question is, why is this an error?</source>
          <target state="translated">정규 표현식에 코드 표현식을 보간하는 변수가 있으면 Perl은 정규 표현식을 오류로 처리합니다. 그러나 코드 표현식이 변수로 사전 컴파일 된 경우 보간은 정상입니다. 문제는 왜 이것이 오류입니까?</target>
        </trans-unit>
        <trans-unit id="d5bd95a2da72abd4235bfb3025f329041ecd2afc" translate="yes" xml:space="preserve">
          <source>If a regexp matches in more than one place in the string, Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">정규 표현식이 문자열에서 둘 이상의 위치에서 일치하면 Perl은 항상 문자열에서 가능한 가장 빠른 지점에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="eaf4b93182f52023e0f84b564980685b7296c6d9" translate="yes" xml:space="preserve">
          <source>If a regular bracketed character class contains a &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; and is matched against a non-Unicode code point, a warning may be raised, as the result is not Unicode-defined. No such warning will come when using this extended form.</source>
          <target state="translated">일반 대괄호 문자 클래스에 &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 되어 있고 비 유니 코드 코드 포인트와 일치하는 경우 결과가 유니 코드로 정의되지 않으므로 경고가 발생할 수 있습니다. 이 확장 양식을 사용할 때는 그러한 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f85e430ff8e0f946fbbcd7fbdf03ad676d0029b5" translate="yes" xml:space="preserve">
          <source>If a result does not have a callback defined for it, this callback will be invoked. Thus, if all of the previous result types are specified as callbacks, this callback will</source>
          <target state="translated">결과에 콜백이 정의되어 있지 않으면이 콜백이 호출됩니다. 따라서 모든 이전 결과 유형이 콜백으로 지정된 경우이 콜백은</target>
        </trans-unit>
        <trans-unit id="7c88e9a20d1a229d11dbc65d34fee24d0f8252b1" translate="yes" xml:space="preserve">
          <source>If a script does not contain such a cooky, then to avoid calling</source>
          <target state="translated">스크립트에 그러한 쿠키가 포함되어 있지 않으면 호출을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="7e6d780b3e70414e72c5be7308b60f82c00d250e" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt; . (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">두 번째 인수가 제공되고 유효한 로케일에 해당하는 경우 카테고리의 로케일이 해당 값으로 설정되고 함수는 현재 현재 로케일 값을 리턴합니다. 그런 다음이를 &lt;code&gt;setlocale()&lt;/code&gt; 또 다른 호출에서 사용할 수 있습니다 . (일부 구현에서, 반환 값은 때로는 두 번째 인수로 제공 한 값과 다를 수 있습니다. 제공 한 값의 별칭으로 생각하십시오.)</target>
        </trans-unit>
        <trans-unit id="3e39a56243de1505c2a60308e0e3b7ae64ceb413" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt;. (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">두 번째 인수가 제공되고 유효한 로케일에 해당하는 경우 카테고리의 로케일은 해당 값으로 설정되고 함수는 현재 현재 로케일 값을 리턴합니다. 그런 다음 &lt;code&gt;setlocale()&lt;/code&gt; 또 다른 호출에서 이것을 사용할 수 있습니다 . (일부 구현에서는 반환 값이 두 번째 인수로 제공 한 값과 다를 수 있습니다. 제공 한 값의 별칭으로 생각하면됩니다.)</target>
        </trans-unit>
        <trans-unit id="91a945f54fa17399a38d6421bac299acb5873c21" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should be the name of the desired output file. If the special output filename &quot;-&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; is given then the STDOUT filehandle is used for output (and no open or close is performed). If the special output filename &quot;&amp;gt;&amp;amp;STDERR&quot; is given then the STDERR filehandle is used for output (and no open or close is performed). If no output filehandle is currently in use and no output filename is specified, then &quot;-&quot; is implied. Alternatively, filehandle references or objects that support the regular IO operations (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, e.g. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt;) are also accepted; the object must already be opened.</source>
          <target state="translated">두 번째 인수가 제공되면 원하는 출력 파일의 이름이어야합니다. 특수 출력 파일 이름 &quot;-&quot;또는 &quot;&amp;gt; &amp;amp; STDOUT&quot;이 제공되면 STDOUT 파일 핸들이 출력에 사용되며 열기 또는 닫기가 수행되지 않습니다. 특수 출력 파일 이름 &quot;&amp;gt; &amp;amp; STDERR&quot;이 제공되면 STDERR 파일 핸들이 출력에 사용되며 열기 또는 닫기가 수행되지 않습니다. 현재 사용중인 출력 파일 핸들이없고 출력 파일 이름을 지정하지 않으면 &quot;-&quot;가 내포됩니다. 또한, 일반 IO 작업을 지원 파일 핸들 참조 또는 객체 (같은 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , 예를 들어, &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: 문자열&lt;/a&gt; )도 허용됩니다; 개체가 이미 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="477169172ccc2cfa646e6b1ff7ebcaf7ea663dbd" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should correspond to a filehandle where output should be sent (otherwise the default output filehandle is &lt;code&gt;STDOUT&lt;/code&gt; if no output filehandle is currently in use).</source>
          <target state="translated">두 번째 인수가 제공되면 출력을 보내야하는 파일 핸들에 해당해야합니다 (그렇지 않으면 현재 출력 파일 핸들을 사용하지 않는 경우 기본 출력 파일 핸들은 &lt;code&gt;STDOUT&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="93e01c4263faa2fd7e903bd96fbfc6f719b4224a" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">특정 유형의 신호가 오피 코드 동안 (예 : 세밀한 타이머에서) 여러 번 발생하는 경우 오피 코드가 완료된 후 해당 신호에 대한 핸들러가 한 번만 호출됩니다. 다른 모든 인스턴스는 삭제됩니다. 또한, opcode가 완료 될 때 발생했지만 아직 포착되지 않은 (따라서 지연되지 않은) 신호가있는 지점까지 시스템의 신호 대기열이 플러딩되면 후속 opcode 중에 해당 신호가 포착되어 지연 될 수 있습니다. 때때로 놀라운 결과. 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; 호출 한 후에도 알람이 전달되는 것을 볼 수 있습니다후자는 경보 발생을 중지하지만 발생했지만 아직 포착되지 않은 경보의 전달을 취소하지는 않습니다. 현재 구현의 부작용이며 향후 버전의 Perl에서 변경 될 수 있으므로이 단락에 설명 된 동작에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1391421af9c89c0d87f56f7e90949f1788025d04" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;alarm(0)&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">특정 유형의 신호가 opcode 동안 여러 번 발생하면 (예 : 세분화 된 타이머에서) 해당 신호에 대한 핸들러는 opcode가 완료된 후 한 번만 호출됩니다. 다른 모든 인스턴스는 삭제됩니다. 또한 시스템의 신호 대기열이 opcode가 완료 될 때 발생했지만 아직 포착되지 않은 (따라서 지연되지 않은) 신호가있는 지점까지 플러드되면 해당 신호는 후속 opcode 중에 포착되고 지연 될 수 있습니다. 때로는 놀라운 결과. 예를 들어 &lt;code&gt;alarm(0)&lt;/code&gt; 호출 한 후에도 전달 된 경보를 볼 수 있습니다.후자는 알람 발생을 중지하지만 발생했지만 아직 잡히지 않은 알람의 전달을 취소하지 않기 때문입니다. 이 단락에 설명 된 동작은 현재 구현의 부작용이며 Perl의 향후 버전에서 변경 될 수 있으므로 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54c4924d3d30f658cd6ca34abca8d30fc0b456c3" translate="yes" xml:space="preserve">
          <source>If a single version is listed, then that version is considered to be the minimum version supported.</source>
          <target state="translated">단일 버전이 나열되면 해당 버전이 지원되는 최소 버전으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca9f14adad1a4346557fbd963ffe8837b4e2de6" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt; . You may use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">지정된 상수 &lt;code&gt;EFOO&lt;/code&gt; 가 시스템에 없으면 &lt;code&gt;$!{EFOO}&lt;/code&gt; 는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 리턴합니다 . 당신이 사용할 수 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; 상수는 시스템에서 사용할 수 있는지 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bf4eb314d513c3316ce1fa9889a8d0bccfeb7ad3" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt;. You may use &lt;code&gt;exists $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">지정된 상수 &lt;code&gt;EFOO&lt;/code&gt; 가 시스템에 없으면 &lt;code&gt;$!{EFOO}&lt;/code&gt; 는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 . 시스템에서 상수를 사용할 수 있는지 확인하기 위해 &lt;code&gt;exists $!{EFOO}&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f800d47729ac41db50a73befe5a0c18db31026bf" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt; .</source>
          <target state="translated">문자열이 UTF-8 인 경우 &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; 가 아닌 경우 &lt;code&gt;*s&lt;/code&gt; 를 사용할 수있는 경우가 아니면 &lt;b&gt;항상 &lt;/b&gt; &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 를 사용 하여 값을 얻으십시오 .</target>
        </trans-unit>
        <trans-unit id="5565b45434f39b2ddc21d26b181951efb62cd428" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">문자열이 UTF-8 인 경우 &lt;code&gt;*s&lt;/code&gt; 를 사용할 수있는 &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; 가 아니라면 &lt;b&gt;항상 &lt;/b&gt; &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 를 사용 하여 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1be10a035bc9dd04a9faa3e7d6666d736bd26b25" translate="yes" xml:space="preserve">
          <source>If a sub has both a PROTO and a BLOCK, the prototype is not applied until after the BLOCK is completely defined. This means that a recursive function with a prototype has to be predeclared for the prototype to take effect, like so:</source>
          <target state="translated">서브에 PROTO와 BLOCK이 모두 있으면 BLOCK이 완전히 정의 될 때까지 프로토 타입이 적용되지 않습니다. 즉, 다음과 같이 프로토 타입을 적용하려면 프로토 타입이있는 재귀 함수를 미리 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="0608dc713e7e2ffc835fe7b94ed6aa1dd9da10a4" translate="yes" xml:space="preserve">
          <source>If a subroutine reference was given, it is invoked as:</source>
          <target state="translated">서브 루틴 참조가 제공된 경우 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b26c7bacf7c0c773c98a08b7cfd7b95eaadc8d" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt; , as in &lt;code&gt;floating 'k'$&lt;/code&gt; .</source>
          <target state="translated">서브 스트링이 행 끝에서만 일치하는 것으로 알려진 경우 &lt;code&gt;floating 'k'$&lt;/code&gt; 에서와 같이 &lt;code&gt;$&lt;/code&gt; 다음에 $ 가 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2a7b0f64e136490191d68028d9bfc30ff8c824f" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt;, as in &lt;code&gt;floating 'k'$&lt;/code&gt;.</source>
          <target state="translated">부분 문자열이 줄 끝에서만 일치하는 것으로 알려진 경우 &lt;code&gt;floating 'k'$&lt;/code&gt; 에서와 같이 &lt;code&gt;$&lt;/code&gt; 뒤에 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8bac00f48a56f95c981f68b27c67c1613b3abed" translate="yes" xml:space="preserve">
          <source>If a test had either a &lt;code&gt;TODO&lt;/code&gt; or &lt;code&gt;SKIP&lt;/code&gt; directive, this method will return the accompanying explanation, if present.</source>
          <target state="translated">테스트에 &lt;code&gt;TODO&lt;/code&gt; 또는 &lt;code&gt;SKIP&lt;/code&gt; 지시문이 있으면이 메소드는 첨부 된 설명 (있는 경우)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="65b9290b4f037c914cf42f893f1aba1433a9e97a" translate="yes" xml:space="preserve">
          <source>If a test number is greater than the number of planned tests, this method will return true. Unplanned tests will</source>
          <target state="translated">테스트 수가 계획된 테스트 수보다 큰 경우이 방법은 true를 반환합니다. 계획되지 않은 테스트는</target>
        </trans-unit>
        <trans-unit id="6169b8ce6480907cccaf2d8c56d0f00c7332c0b3" translate="yes" xml:space="preserve">
          <source>If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt;).</source>
          <target state="translated">연결된 해시가 스칼라 컨텍스트에서 평가되면 &lt;code&gt;SCALAR&lt;/code&gt; 메서드가 호출됩니다 ( &lt;code&gt;FIRSTKEY&lt;/code&gt; 로의 폴백 포함 ).</target>
        </trans-unit>
        <trans-unit id="99f0a88031cba297a38b9bb2a8d9794138cdfcc6" translate="yes" xml:space="preserve">
          <source>If a transformation subroutine (xfrm) is defined, its value is used to transform the lines read from the filehandle before their comparison.</source>
          <target state="translated">변환 서브 루틴 (xfrm)이 정의 된 경우 해당 값은 비교 전에 파일 핸들에서 읽은 행을 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="571f9ad4d812cfdda52b01e4ae41c48c7aa1a889" translate="yes" xml:space="preserve">
          <source>If a true value is given (non-zero but should be positive), it will be added as a terminator primary weight to the end of every standard Hangul syllable. Secondary and any higher weights for terminator are set to zero. If the value is false or &lt;code&gt;hangul_terminator&lt;/code&gt; key does not exist, insertion of terminator weights will not be performed.</source>
          <target state="translated">0이 아닌 양수인 값이 true이면 모든 표준 한글 음절 끝에 터미네이터 기본 가중치로 추가됩니다. 터미네이터에 대한 2 차 및 더 높은 가중치는 0으로 설정됩니다. 값이 false이거나 &lt;code&gt;hangul_terminator&lt;/code&gt; 키가 없으면 종료 자 가중치 삽입이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06c503e180fbd73d4ade263d4ec3fc736e96785b" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class
$var&lt;/code&gt; ) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">참조를 보유한 유형화 된 어휘 변수 ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class $var&lt;/code&gt; )를 사용하여 해시 요소에 액세스하고 해당 유형이이 pragma를 사용하여 클래스 필드를 선언 한 것과 동일한 이름을 가진 패키지에 액세스하는 경우, 컴파일시 해시 키가 확인됩니다. 변수를 입력하지 않으면 런타임시에만 액세스가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="748870f6864101e2665ecfedb42ab9a1b32e539e" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;my Class $var&lt;/code&gt;) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">참조를 포함하는 형식화 된 어휘 변수 ( &lt;code&gt;my Class $var&lt;/code&gt; )가 해시 요소에 액세스하는 데 사용되며 형식과 동일한 이름을 가진 패키지가이 pragma를 사용하여 클래스 필드를 선언 한 경우 컴파일 타임에 해시 키가 확인됩니다. 변수를 입력하지 않으면 런타임에만 액세스가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="a56a688e323d9747dee356792880eafa156d2877" translate="yes" xml:space="preserve">
          <source>If a utility or module isn't available, it will be marked in a cache (see the &lt;code&gt;$METHOD_FAIL&lt;/code&gt; variable further down), so it will not be tried again. The &lt;code&gt;fetch&lt;/code&gt; method will only fail when all options are exhausted, and it was not able to retrieve the file.</source>
          <target state="translated">유틸리티 나 모듈을 사용할 수없는 경우 캐시에 표시되므로 ( &lt;code&gt;$METHOD_FAIL&lt;/code&gt; 변수를 참조하십시오 ) 다시 시도하지 않습니다. &lt;code&gt;fetch&lt;/code&gt; 모든 옵션이 소진 때 메서드는 실패하고이 파일을 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17e415afdb54d5332d73e9d658477c2317a9747c" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt; -type or &lt;code&gt;+&lt;/code&gt; -type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;Initializing Function Parameters&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">변수가 CODE : 섹션 내에 선언되면 입력 매개 변수에 대해 생성 된 모든 유형 맵 코드를 따릅니다. 이로 인해 C 코드 다음에 선언이 끝나고 C 구문 오류가 발생할 수 있습니다. 비슷한 오류가 명시 적으로 발생할 수 있습니다 &lt;code&gt;;&lt;/code&gt; 매개 변수의 -type 또는 &lt;code&gt;+&lt;/code&gt; -type 초기화가 사용됩니다 ( &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;함수 매개 변수 초기화&lt;/a&gt; 참조 ). INIT : 섹션에서 이러한 변수를 선언하면 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1207e0b0d0efedf009a2fba67d60a91b64445106" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt;-type or &lt;code&gt;+&lt;/code&gt;-type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;&quot;Initializing Function Parameters&quot;&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">변수가 CODE : 섹션 내에서 선언되면 입력 매개 변수에 대해 내 보낸 모든 타입 맵 코드를 따릅니다. 이로 인해 C 구문 오류 인 C 코드 뒤에 선언이 끝날 수 있습니다. 명시 적으로 유사한 오류가 발생할 수 있습니다 &lt;code&gt;;&lt;/code&gt; 매개 변수의 -type 또는 &lt;code&gt;+&lt;/code&gt; 유형 초기화가 사용됩니다 ( &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;&quot;함수 매개 변수 초기화&quot;&lt;/a&gt; 참조 ). INIT : 섹션에서 이러한 변수를 선언하면 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b3996807bb1f09e79ba835867b4d5ba2a1e4f04" translate="yes" xml:space="preserve">
          <source>If a version object is compared against a non-version object, the non-object term will be converted to a version object using &lt;code&gt;parse()&lt;/code&gt;. This may give surprising results:</source>
          <target state="translated">버전 객체를 버전이 아닌 객체와 비교하면 객체가 아닌 용어는 &lt;code&gt;parse()&lt;/code&gt; 사용하여 버전 객체로 변환됩니다 . 이것은 놀라운 결과를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1e1471095c4d68dab8592febf94b7e3ac2a2016" translate="yes" xml:space="preserve">
          <source>If accept() is interrupted by a signal, $! will be set to EINTR. If this happens, we can safely continue to the next iteration of the loop and another call to accept(). It is important that your signal handling code not modify the value of $!, or else this test will likely fail. In the REAPER subroutine we create a local version of $! before calling waitpid(). When waitpid() sets $! to ECHILD as it inevitably does when it has no more children waiting, it updates the local copy and leaves the original unchanged.</source>
          <target state="translated">accept ()가 신호에 의해 중단되면 $! EINTR로 설정됩니다. 이런 일이 발생하면 루프의 다음 반복과 accept ()에 대한 다른 호출을 안전하게 계속할 수 있습니다. 신호 처리 코드가 $!의 값을 수정하지 않는 것이 중요합니다. 그렇지 않으면이 테스트가 실패 할 수 있습니다. REAPER 서브 루틴에서 $의 로컬 버전을 만듭니다! waitpid ()를 호출하기 전에 waitpid ()가 $!를 설정하면 더 이상 대기중인 자식이 없을 때 필연적으로 ECHILD에서 로컬 사본을 업데이트하고 원본을 변경하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="752e6cffd40215caddfd723588dccf4863a5ed16" translate="yes" xml:space="preserve">
          <source>If adding a new module to a set, follow the original author's standards for naming modules and the interface to methods in those modules.</source>
          <target state="translated">세트에 새 모듈을 추가하는 경우 모듈 이름 지정에 대한 원래 작성자의 표준 및 해당 모듈의 메소드에 대한 인터페이스를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="740a7df0564a13f66fe6f00e1a8f73b803531ecf" translate="yes" xml:space="preserve">
          <source>If after any stripping of indentation in verbatim blocks, there remain tabs, this method call indicates what to do with them. &lt;code&gt;0&lt;/code&gt; means leave them as tabs, any other number indicates that each tab is to be translated so as to have tab stops every &lt;code&gt;n&lt;/code&gt; columns.</source>
          <target state="translated">축 어적 블록에서 들여 쓰기를 제거한 후에도 탭이 남아있는 경우이 메서드 호출은 탭으로 수행 할 작업을 나타냅니다. &lt;code&gt;0&lt;/code&gt; 은 탭으로 남겨 두는 것을 의미하고, 다른 숫자는 각 탭이 &lt;code&gt;n&lt;/code&gt; 열 마다 탭 정지를 갖도록 변환됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c30aaa76b20fc01d8891caaf8c421bdbbefa39ad" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; will fail.</source>
          <target state="translated">해당 프로세스 후에도 레이어가 여전히 정의되지 않으면 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c550e6d69474a6a7c10a80260775c6595e782f16" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;open&lt;/code&gt; will fail.</source>
          <target state="translated">해당 프로세스 후에도 레이어가 정의되지 않으면 &lt;code&gt;open&lt;/code&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3f5b65dba45a85e174c3b613f61ee902daa93694" translate="yes" xml:space="preserve">
          <source>If all actions were successful install will return a hashref of the results as described above for the $result parameter. If any action is a failure then install will die, therefore it is recommended to pass in the $result parameter instead of using the return value. If the result parameter is provided then the returned hashref will be the passed in hashref.</source>
          <target state="translated">모든 조치가 완료되면 $ result 매개 변수에 대해 위에서 설명한대로 결과의 해시 참조를 리턴합니다. 조치가 실패하면 설치가 종료되므로 리턴 값을 사용하는 대신 $ result 매개 변수를 전달하는 것이 좋습니다. 결과 매개 변수가 제공되면 리턴 된 hashref가 hashref로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="127255eea385053cfe8f53f8f2c648f76a8be49c" translate="yes" xml:space="preserve">
          <source>If all data that comes from a certain handle is encoded in exactly the same way, you can tell the PerlIO system to automatically decode everything, with the &lt;code&gt;encoding&lt;/code&gt; layer. If you do this, you can't accidentally forget to decode or encode anymore, on things that use the layered handle.</source>
          <target state="translated">특정 핸들에서 나오는 모든 데이터가 정확히 같은 방식으로 인코딩 된 경우 PerlIO 시스템에 &lt;code&gt;encoding&lt;/code&gt; 계층을 사용하여 모든 것을 자동으로 디코딩하도록 지시 할 수 있습니다 . 이렇게하면 계층화 된 핸들을 사용하는 항목에서 실수로 더 이상 디코딩하거나 인코딩하는 것을 잊을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e7d1b1bb140827b5655410f34d1155c7f80618e" translate="yes" xml:space="preserve">
          <source>If all goes okay and no errors during a build, you'll get two independent distributions: &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; and &lt;code&gt;mips-wce300-thr&lt;/code&gt; .</source>
          <target state="translated">빌드 중에 모든 것이 정상이고 오류가 없으면 &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; 과 &lt;code&gt;mips-wce300-thr&lt;/code&gt; 의 두 가지 독립적 인 배포판을 얻게 됩니다.</target>
        </trans-unit>
        <trans-unit id="f9089d68477d6441e4f9e9f5ebed86f489f07115" translate="yes" xml:space="preserve">
          <source>If all is well then update your blead branch:</source>
          <target state="translated">모든 것이 잘되면 blead 브랜치를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="2ab3e0df4f550d075ed2874e19cdd1793f373e2a" translate="yes" xml:space="preserve">
          <source>If all this is intimidating, have no (well, maybe only a little) fear. There are modules that can help. The &lt;code&gt;File::Spec&lt;/code&gt; modules provide methods to do the Right Thing on whatever platform happens to be running the program.</source>
          <target state="translated">이 모든 것이 협박이라면 두려움이 없습니다. 도움이 될 수있는 모듈이 있습니다. &lt;code&gt;File::Spec&lt;/code&gt; 모듈은 프로그램을 실행하는 일이 어떤 플랫폼에서 옳은 일을 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ae7ad2a8e725968ebffe98c6ec06a2f880b60f52" translate="yes" xml:space="preserve">
          <source>If all you want to do is pretend to be telnet but don't need the initial telnet handshaking, then the standard dual-process approach will suffice:</source>
          <target state="translated">텔넷 인 것처럼 가장하지만 초기 텔넷 핸드 쉐이킹이 필요하지 않은 경우 표준 이중 프로세스 방식으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9403f48a0d39d844d9c0ac74b1c19be5f1602977" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">모든 테스트가 통과되면 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 는 0 (정상)으로 종료됩니다. 실패한 것이 있으면 실패한 횟수와 함께 종료됩니다. 계획 한 것보다 적은 (또는 더 많은) 테스트를 실행하면 누락 된 (또는 추가 된) 테스트가 실패로 간주됩니다. 테스트가 실행되지 않은 경우 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 는 경고를 표시하고 255로 종료합니다. 테스트가 종료 된 경우 모든 테스트를 성공적으로 완료 한 후에도 여전히 실패로 간주되고 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="114fc5763881eaed2b695ddb5eda1e514b33dd63" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">모든 테스트가 통과되면 &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; 가 0으로 종료됩니다 (정상). 실패한 항목이 몇 개 있으면 종료됩니다. 계획 한 것보다 적은 (또는 더 많은) 테스트를 실행하면 누락 (또는 추가)이 실패로 간주됩니다. 테스트가 실행되지 않은 경우 &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; 는 경고를 발생시키고 255로 종료합니다. 테스트가 모두 완료된 후에도 테스트가 종료 된 경우에도 여전히 실패로 간주되어 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a98f6624ef41fa5865752ff72d1c88c5adce8ff1" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Builder will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Builder will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">모든 테스트가 통과되면 Test :: Builder가 0으로 종료됩니다 (정상). 실패한 항목이 몇 개 있으면 종료됩니다. 계획 한 것보다 적은 (또는 더 많은) 테스트를 실행하면 누락 (또는 추가)이 실패로 간주됩니다. 테스트가 실행되지 않은 경우 Test :: Builder는 경고를 발생시키고 255로 종료합니다. 테스트가 모두 완료된 후에도 테스트가 종료 된 경우에도 여전히 실패로 간주되어 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ec52cc18e24a40a3b425f46525ccb32d3bbfcd0d" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Simple will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Simple will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">모든 테스트가 통과되면 Test :: Simple은 0으로 종료됩니다 (정상). 실패한 항목이 몇 개 있으면 종료됩니다. 계획 한 것보다 적은 (또는 더 많은) 테스트를 실행하면 누락 (또는 추가)이 실패로 간주됩니다. 테스트가 실행되지 않은 경우 Test :: Simple은 경고를 발생시키고 255로 종료합니다. 테스트가 모두 완료된 후에도 테스트가 종료 된 경우에도 여전히 실패로 간주되어 255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bf21a78dfdb342ccff4796ddae824fa3095f386e" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">는 IF &lt;code&gt;ExtraField&lt;/code&gt; 의 옵션을 지정하고 간단한 스칼라입니다 RFC 1952에 정의 된대로, 그것은 서브 필드 구조에 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="703bb32d1796efb54146381859e7e166335fd702" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, the structure will not be checked. The only error is if the length is too big.</source>
          <target state="translated">는 IF &lt;code&gt;ExtraField&lt;/code&gt; 의 옵션을 지정하고 간단한 스칼라이다, 구조는 검사하지 않습니다. 길이가 너무 큰 경우 유일한 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d5888ada14b086770c285ef36da99e64d4b36a12" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified the second byte of the ID will be checked in each subfield to ensure that it does not contain the reserved value 0x00.</source>
          <target state="translated">는 IF &lt;code&gt;ExtraField&lt;/code&gt; 의 옵션은 지정된 ID의 두 번째 바이트는 예약 된 값 &amp;times; 00이 없도록 각 서브 필드에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba67c55f0a73d622c034c758b4c54c06d0297ce" translate="yes" xml:space="preserve">
          <source>If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable of the XSUB's package.</source>
          <target state="translated">Perl 서브 루틴과 같이 AUTOLOAD 루틴이 XSUB 인 경우 Perl은 자동로드 서브 루틴의 완전한 이름을 XSUB 패키지의 $ AUTOLOAD 변수에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="5f16d14b8173a324e3c6a5e5bf643eb4986c26e1" translate="yes" xml:space="preserve">
          <source>If an IPC encounters a fatal error it should use this. This will print the message to STDERR with &lt;code&gt;'IPC Fatal Error: '&lt;/code&gt; prefixed to it, then it will forcefully exit 255. IPC errors may occur in threads or processes other than the main one, this method provides the best chance of the harness noticing the error.</source>
          <target state="translated">IPC에 치명적인 오류가 발생하면이를 사용해야합니다. 이렇게하면 &lt;code&gt;'IPC Fatal Error: '&lt;/code&gt; 접두사가 붙은 STDERR에 메시지가 인쇄되고 강제로 255가 종료됩니다. IPC 오류는 기본 스레드가 아닌 스레드 또는 프로세스에서 발생할 수 있습니다.이 방법은 하네스가 오류.</target>
        </trans-unit>
        <trans-unit id="42bdc376fb833e498b49e6edb80ebe7de88f4149" translate="yes" xml:space="preserve">
          <source>If an Input glob matches the same file more than once, only the first will be used.</source>
          <target state="translated">입력 글로브가 동일한 파일을 두 번 이상 일치하면 첫 번째 파일 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7ac1d42b2433b8600fc2dd6eb1a16139df0641" translate="yes" xml:space="preserve">
          <source>If an XSUB is created to offer a direct translation between this function and Perl, then this XSUB will be used from Perl with the following code. The $status and $timep variables will contain the output of the function.</source>
          <target state="translated">이 함수와 Perl간에 직접 변환을 제공하기 위해 XSUB가 작성되면이 XSUB는 다음 코드와 함께 Perl에서 사용됩니다. $ status 및 $ timep 변수에는 함수 출력이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b382afe3d07f60c5f6eced5294d3838170432890" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt; , it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">XSUB 이름에 &lt;code&gt;::&lt;/code&gt; 가 포함 된 경우 C ++ 메소드로 간주됩니다. 생성 된 Perl 함수는 첫 번째 인수가 객체 포인터라고 가정합니다. 객체 포인터는 THIS라는 변수에 저장됩니다. 객체는 new () 함수를 사용하여 C ++에 의해 작성되었고 sv_setref_pv () 매크로를 사용하여 Perl에 의해 축복을 받아야합니다. Perl에 의한 객체의 축복은 타입 맵에 의해 처리 될 수 있습니다. 이 섹션의 끝에 typemap 예제가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3718c1d670d39036e818ea2e8844505748f38c" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt;, it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">XSUB 이름에 &lt;code&gt;::&lt;/code&gt; 가 포함되어 있으면 C ++ 메서드로 간주됩니다. 생성 된 Perl 함수는 첫 번째 인수가 객체 포인터라고 가정합니다. 개체 포인터는 THIS라는 변수에 저장됩니다. 객체는 new () 함수를 사용하여 C ++에 의해 생성되어야하며 sv_setref_pv () 매크로를 사용하여 Perl에 의해 축복 받아야합니다. Perl에 의한 객체의 축복은 typemap에 의해 처리 될 수 있습니다. 이 섹션의 끝에는 예제 타입 맵이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2e1d1934ece2d63d504b4355cb9c8a6aa0fa5a" translate="yes" xml:space="preserve">
          <source>If an angle-bracket-based globbing expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a globbing expression or an explicit assignment of a globbing expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">꺾쇠 괄호 기반 globbing 표현식이 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 루프 의 조건으로 사용 되면 암시 적으로 &lt;code&gt;$_&lt;/code&gt; 할당됩니다 . globbing 표현식이나 스칼라에 대한 명시적인 globbing 표현식 할당이 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 조건 으로 사용되는 경우 조건은 실제로 정규 진리 값이 아닌 표현식 값의 정의를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a5be5707a4fed01d7fc6a9c5c683f16ea2406809" translate="yes" xml:space="preserve">
          <source>If an argument callback routine is specified, &lt;code&gt;@ARGV&lt;/code&gt; will always be empty upon successful return of GetOptions() since all options have been processed. The only exception is when &lt;code&gt;--&lt;/code&gt; is used:</source>
          <target state="translated">인수 콜백 루틴이 지정되면 모든 옵션이 처리되었으므로 GetOptions ()가 성공적으로 리턴 되면 &lt;code&gt;@ARGV&lt;/code&gt; 가 항상 비어 있습니다. &lt;code&gt;--&lt;/code&gt; 가 사용되는 경우 는 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="b39b97b3c5875ed6ddbb4cadef1665f0d49ebbe7" translate="yes" xml:space="preserve">
          <source>If an argument is given, it must correspond to the desired section heading number, in which case only the specified section heading is returned. If there is no current section heading at the specified level, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 제공되면 원하는 섹션 제목 번호에 해당해야하며,이 경우 지정된 섹션 제목 만 반환됩니다. 지정된 수준에 현재 섹션 제목이 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7271fc38171101f8ded47e78d280e28ab4aefe24" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , or &lt;code&gt;CODE&lt;/code&gt; ), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">속성 핸들러가 선언되고 &lt;code&gt;:ATTR&lt;/code&gt; 지정자에 내장 유형의 이름 ( &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; 또는 &lt;code&gt;CODE&lt;/code&gt; )이 지정된 경우 핸들러는 해당 유형의 선언에만 적용됩니다. 예를 들어 다음과 같은 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c7ef44f90555314050f910e8588b5f9dbab3f7" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, or &lt;code&gt;CODE&lt;/code&gt;), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">속성 핸들러가 선언되고 &lt;code&gt;:ATTR&lt;/code&gt; 지정자에 내장 유형 ( &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; 또는 &lt;code&gt;CODE&lt;/code&gt; ) 의 이름이 제공 되면 핸들러는 해당 유형의 선언에만 적용됩니다. 예를 들어 다음 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62eb757e944d2fdd579513e058242369fd9ee059" translate="yes" xml:space="preserve">
          <source>If an element of</source>
          <target state="translated">요소가</target>
        </trans-unit>
        <trans-unit id="12dcad5cabf51c630b511f4237ee95faf62760f4" translate="yes" xml:space="preserve">
          <source>If an element, call it ELEMENT, is not on this list, try using this command to find out why:</source>
          <target state="translated">ELEMENT라고 부르는 요소가이 목록에없는 경우 다음 명령을 사용하여 이유를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="ac822e62f394feec698ce4d683fc3173f8604479" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, or nothing that matches the first 3 values above is returned, then &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks at the remaining elements of &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt;. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">빈 목록, &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 또는 위의 처음 3 개 값과 일치하는 항목이 반환되지 않으면 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;perlvar#%40INC&quot;&gt; &lt;code&gt;@INC&lt;/code&gt; &lt;/a&gt; 의 나머지 요소를 살펴 봅니다 . 이 파일 핸들은 실제 파일 핸들이어야합니다 (엄격하게는 typeglob 또는 축복 여부에 관계없이 typeglob에 대한 참조). 묶인 파일 핸들은 무시되고 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="34964fb1164dd648c7d2582c841b9ac59c8a6438" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">빈 목록이 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 위의 첫 번째 3 값과 일치하거나 아무 것도 반환되지 않으며, 다음 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; @ INC의 나머지 요소에 모습을. 이 파일 핸들은 실제 파일 핸들이어야합니다 (축적이든 비 축적이든 엄격하게 타입 글로브 또는 타입 글로브에 대한 참조). 묶인 파일 핸들은 무시되고 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e6b9ed06c157d2ccb39c11bcda5c6ea1f6b42a42" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">빈 목록이 경우 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 위의 첫 번째 3 값과 일치하거나 아무 것도 반환되지 않으며, 다음 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; @ INC의 나머지 요소에 모습을. 이 파일 핸들은 실제 파일 핸들이어야합니다 (축적이든 비 축적이든 엄격하게 타입 글로브 또는 타입 글로브에 대한 참조). 묶인 파일 핸들은 무시되고 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f919dfddbef4a1a12f08337d7a834831006d9b11" translate="yes" xml:space="preserve">
          <source>If an error is encountered during conversion, output file will be removed and a warning emitted instead of terminating the conversion immediately.</source>
          <target state="translated">변환 중에 오류가 발생하면 출력 파일이 제거되고 변환을 즉시 종료하지 않고 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9714806e81ca60318ef1d507fb9add3187535d9b" translate="yes" xml:space="preserve">
          <source>If an error occurs &lt;code&gt;blocking&lt;/code&gt; will return undef and &lt;code&gt;$!&lt;/code&gt; will be set.</source>
          <target state="translated">에러가 발생하면 &lt;code&gt;blocking&lt;/code&gt; 은 undef와 &lt;code&gt;$!&lt;/code&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="223081f636c4dc0e612cdeecd4fd8749800bcc2c" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree (most likely null) is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">구문 분석 또는 컴파일 과정에서 오류가 발생하면 대부분의 경우 유효한 op 트리 (대부분의 경우 null)가 반환됩니다. 오류는 파서 상태에 반영되어 일반적으로 발생한 모든 컴파일 오류를 포괄하는 최상위 수준의 구문 분석에서 단일 예외를 발생시킵니다. 그러나 일부 컴파일 오류는 즉시 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="409c88cc16ea56deb3ee2fd13496f8443cdeb8ed" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">구문 분석 또는 컴파일에서 오류가 발생하면 대부분의 경우 유효한 op 트리가 반환됩니다. 오류는 파서 상태에 반영되어 일반적으로 발생한 모든 컴파일 오류를 포괄하는 최상위 수준의 구문 분석에서 단일 예외를 발생시킵니다. 그러나 일부 컴파일 오류는 즉시 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fb3a0347b1d41b96c13bdbefc10e2d1afbf9de50" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing, which can only occur if the label is mandatory, a valid label is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred.</source>
          <target state="translated">구문 분석시 오류가 발생하면 레이블이 필수 인 경우에만 발생할 수 있으며 유효한 레이블이 반환됩니다. 오류는 파서 상태에 반영되어 일반적으로 발생한 모든 컴파일 오류를 포괄하는 최상위 수준의 구문 분석에서 단일 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d9bdcdf03abe1ba577aa0e79f3435579268caad1" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the fragment of string that has been converted and modify $octets in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">오류가 발생하면 변환 된 문자열 조각을 반환하고 $ octets를 수정하여 변환 된 부분을 제거하여 문제 조각으로 시작해야합니다 (SHOULD). perlio_ok ()가 true이면 반드시 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5cf7457198e3f9cd671a04a577836ab4a9017358" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the octet sequence for the fragment of string that has been converted and modify $string in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">오류가 발생하면 변환 된 문자열 조각에 대한 옥텟 시퀀스를 반환하고 $ string을 수정하여 변환 된 부분을 제거하여 문제 조각으로 시작해야합니다. perlio_ok ()가 true이면 반드시 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2d11e497e2ae0afa960e508853e27c914d2845" translate="yes" xml:space="preserve">
          <source>If an existing module &lt;b&gt;almost&lt;/b&gt; does what you want, consider writing a patch, writing a subclass, or otherwise extending the existing module rather than rewriting it.</source>
          <target state="translated">기존 모듈이 &lt;b&gt;거의&lt;/b&gt; 원하는 작업을 수행하는 경우 패치 작성, 서브 클래스 작성 또는 기존 모듈을 다시 쓰지 않고 확장하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="82c1aacb1c3709d4e7d697aae2bed5c77802f47c" translate="yes" xml:space="preserve">
          <source>If an exit status</source>
          <target state="translated">종료 상태 인 경우</target>
        </trans-unit>
        <trans-unit id="cea12036a9c231320c44066b7b5457646bd39537" translate="yes" xml:space="preserve">
          <source>If an exit status is</source>
          <target state="translated">종료 상태가</target>
        </trans-unit>
        <trans-unit id="e2873de2f1e9af5ea740b20953d89320900ebe0e" translate="yes" xml:space="preserve">
          <source>If an extant $SIG{__WARN__} handler is discovered, it will continue to be honored, but only after the diagnostics::splainthis() function (the module's $SIG{__WARN__} interceptor) has had its way with your warnings.</source>
          <target state="translated">현존하는 $ SIG {__ WARN__} 핸들러가 발견되면 진단 :: splainthis () 함수 (모듈의 $ SIG {__ WARN__} 인터셉터)가 경고와 함께 수행 된 후에 만 ​​계속 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d72e4c503af6f4a09cfa2171e2474d37da483a9b" translate="yes" xml:space="preserve">
          <source>If an extension is being built away from the perl source then MakeMaker will leave PERL_SRC undefined and default to using the installed copy of the perl library. The other variables default to the following:</source>
          <target state="translated">확장 기능이 perl 소스와 별도로 구축 된 경우 MakeMaker는 PERL_SRC를 정의되지 않은 상태로두고 설치된 perl 라이브러리 사본을 사용하도록 기본 설정합니다. 다른 변수는 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1c876b366d6c58e85d7243f2dbcbb0c36548470" translate="yes" xml:space="preserve">
          <source>If an extension is being built below the &lt;code&gt;ext/&lt;/code&gt; directory of the perl source then MakeMaker will set PERL_SRC automatically (e.g., &lt;code&gt;../..&lt;/code&gt;). If PERL_SRC is defined and the extension is recognized as a standard extension, then other variables default to the following:</source>
          <target state="translated">확장이 perl 소스 의 &lt;code&gt;ext/&lt;/code&gt; 디렉토리 아래에 빌드되는 경우 MakeMaker는 PERL_SRC를 자동으로 설정합니다 (예 : &lt;code&gt;../..&lt;/code&gt; ). PERL_SRC가 정의되고 확장이 표준 확장으로 인식되면 다른 변수의 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0316d054e0262fb322cda466200340b0b6b9a08" translate="yes" xml:space="preserve">
          <source>If an extractor returns a defined value, that value is immediately treated as the next extracted field and pushed onto the list of fields. If the extractor was specified in a hash reference, the field is also blessed into the appropriate class,</source>
          <target state="translated">추출기가 정의 된 값을 리턴하면 해당 값은 즉시 다음 추출 된 필드로 처리되고 필드 목록으로 푸시됩니다. 추출기가 해시 참조에 지정된 경우 해당 필드는 해당 클래스에도 축복됩니다.</target>
        </trans-unit>
        <trans-unit id="19aae17e0a99010e0b921850c1a03e6076850e68" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, &lt;code&gt;*sp&lt;/code&gt; will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and &lt;code&gt;*sp&lt;/code&gt; will not move.</source>
          <target state="translated">무한대 또는 숫자가 아님이 인식되면 &lt;code&gt;*sp&lt;/code&gt; 는 인식 된 문자열의 끝을지나 1 바이트를 가리 킵니다. 인식에 실패하면 0이 반환되고 &lt;code&gt;*sp&lt;/code&gt; 는 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7e24bf211ae35444c0a5b02834d4c163f847646" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, the *sp will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and the *sp will not move.</source>
          <target state="translated">무한대 또는 숫자가 아닌 것이 인식되면 * sp는 인식 된 문자열의 끝을지나 1 바이트를 가리 킵니다. 인식이 실패하면 0이 리턴되고 * sp는 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce09f2ed6b39791e05ffc528e1a968457528299e" translate="yes" xml:space="preserve">
          <source>If an object does not support the method specified (determined using UNIVERSAL::can()) then the call will be skipped. If the method dies a warning will be generated.</source>
          <target state="translated">객체가 지정된 메소드를 지원하지 않으면 (UNIVERSAL :: can ()을 사용하여 결정) 호출을 건너 뜁니다. 메소드가 종료되면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24adf3fb9ad8a72560fd633d7f97a817649bd630" translate="yes" xml:space="preserve">
          <source>If an operation is trapped in this way, then the code in STRING will not be executed. If such a trapped operation occurs or any other compile-time or return error, then $@ is set to the error message, just as with an eval().</source>
          <target state="translated">이러한 방식으로 작업이 트랩되면 STRING의 코드가 실행되지 않습니다. 이러한 트랩 된 작업이 발생하거나 다른 컴파일 타임 또는 반환 오류가 발생하면 eval ()과 마찬가지로 $ @가 오류 메시지로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="010067cf6d54e236b69f60d21b2be969b22dcb45" translate="yes" xml:space="preserve">
          <source>If an optional feature is used by a consumer to add additional prerequisites, the consumer should merge the optional feature prerequisites into those given by the &lt;code&gt;prereqs&lt;/code&gt; key using the same semantics. See &lt;a href=&quot;#Merging-and-Resolving-Prerequisites&quot;&gt;&quot;Merging and Resolving Prerequisites&quot;&lt;/a&gt; for details on merging prerequisites.</source>
          <target state="translated">옵션 기능이 추가 전제 조건을 추가하기 위해 소비자가 사용되는 경우, 소비자는 주어진 사람들에 옵션 기능의 전제 조건 병합한다 &lt;code&gt;prereqs&lt;/code&gt; 같은 의미를 사용하여 키를. 를 참조하십시오 &lt;a href=&quot;#Merging-and-Resolving-Prerequisites&quot;&gt;&quot;병합 및 해결 전제 조건&quot;&lt;/a&gt; 통합 전제 조건에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="ed03e924684c92a9ff3960f906eb5ec6eb3ba279" translate="yes" xml:space="preserve">
          <source>If an output file depends on extra input files beside the script itself, a hash ref can be used in version 7.36 and above:</source>
          <target state="translated">출력 파일이 스크립트 자체 옆에있는 추가 입력 파일에 의존하는 경우 버전 7.36 이상에서 해시 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c694eae799a264caff23c78599d66c65a6eff8ab" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; with this pseudocode:</source>
          <target state="translated">포착되지 않은 예외로 인해 인터프리터 종료가 발생하면 종료 코드는 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;그리고 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;이 의사 코드로 :</target>
        </trans-unit>
        <trans-unit id="215592828190613f91a4fc9378ebe41cd5d2be61" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; with this pseudocode:</source>
          <target state="translated">포착되지 않은 예외로 인해 인터프리터 종료가 발생하면 종료 코드는 &lt;code&gt;$!&lt;/code&gt; 값에서 결정됩니다 . 그리고 &lt;code&gt;$?&lt;/code&gt; 이 의사 코드로 :</target>
        </trans-unit>
        <trans-unit id="9816162ad52f74eb6f76cc05f87a2c2e46e90fd4" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;CreateFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="translated">현재 다른 프로세스에 파일에 대한 읽기, 쓰기 및 / 또는 삭제 액세스 권한이 있고 해당 수준의 공유를 허용하지 않으면 &lt;code&gt;CreateFile&lt;/code&gt; 호출 이 실패합니다. 읽기, 쓰기 및 / 또는 삭제 액세스를 요청했고 다른 프로세스에 이미 파일이 열려 있지만 해당 수준의 공유를 허용하지 않는 경우 &lt;code&gt;createFile&lt;/code&gt; 에 대한 호출 이 실패합니다. 파일을 열면 다른 프로세스가 읽기, 쓰기 및 / 또는 삭제 권한으로 파일을 열려고 시도하고 해당 수준의 공유를 허용하지 않으면 해당 프로세스에서 파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92c5b88805d10f4113bd0a0998d163f4bc00c5dc" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="translated">현재 다른 프로세스에 파일에 대한 읽기, 쓰기 및 / 또는 삭제 액세스 권한이 있고 해당 수준의 공유를 허용하지 않으면 &lt;code&gt;createFile&lt;/code&gt; 호출 이 실패합니다. 읽기, 쓰기 및 / 또는 삭제 액세스를 요청했고 다른 프로세스에 이미 파일이 열려 있지만 해당 수준의 공유를 허용하지 않는 경우 &lt;code&gt;createFile&lt;/code&gt; 에 대한 호출 이 실패합니다. 파일을 열면 다른 프로세스가 읽기, 쓰기 및 / 또는 삭제 권한으로 파일을 열려고 시도하고 해당 수준의 공유를 허용하지 않으면 해당 프로세스에서 파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b864a885bc89443cbce8d662bf2be7249be99d8" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;test_args&lt;/code&gt; are given they will be appended to the end of the command argument list.</source>
          <target state="translated">어떤 경우 &lt;code&gt;test_args&lt;/code&gt; 이 주어진다 그들은 명령 인수 목록의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="37251314e00b333d40467d467ca5c0c35c0e366e" translate="yes" xml:space="preserve">
          <source>If any argument to &lt;b&gt;podselect&lt;/b&gt; is a reference to a hash (associative array) then the values with the following keys are processed as follows:</source>
          <target state="translated">&lt;b&gt;podselect에&lt;/b&gt; 대한 인수가 해시 (연관 배열)에 대한 참조 인 경우 다음 키가있는 값은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa7b6de1acc5eb4980a2653a96afb04a72dd14b" translate="yes" xml:space="preserve">
          <source>If any arguments remain, and &lt;code&gt;GetOptionsFromString&lt;/code&gt; was not called in list context, a message will be given and &lt;code&gt;GetOptionsFromString&lt;/code&gt; will return failure.</source>
          <target state="translated">인수가 남아 있고 목록 컨텍스트에서 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 이 호출되지 않은 경우 메시지가 표시되고 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 이 실패를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="59b5cfa2ac91aed4f93a07d4f29fc54a851c06d0" translate="yes" xml:space="preserve">
          <source>If any destructors are triggered as a result, the hv itself may be freed.</source>
          <target state="translated">결과적으로 소멸자가 트리거되면 hv 자체가 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd7074163e07f37b8a41bd25ef8050c203f85577" translate="yes" xml:space="preserve">
          <source>If any directories are included in @names they are searched before @dl_library_path. Directories may be specified as &lt;b&gt;-Ldir&lt;/b&gt;. Any other names are treated as filenames to be searched for.</source>
          <target state="translated">@names에 디렉토리가 포함되어 있으면 @dl_library_path 전에 검색됩니다. 디렉토리는 &lt;b&gt;-Ldir&lt;/b&gt; 로 지정 될 수 있습니다 . 다른 이름은 검색 할 파일 이름으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="864b32c42a324d7506e9ca2ec49f2bbc8bbdcf83" translate="yes" xml:space="preserve">
          <source>If any element of LIST is an lvalue, you can modify it by modifying VAR inside the loop. Conversely, if any element of LIST is NOT an lvalue, any attempt to modify that element will fail. In other words, the &lt;code&gt;foreach&lt;/code&gt; loop index variable is an implicit alias for each item in the list that you're looping over.</source>
          <target state="translated">LIST의 요소가 lvalue 인 경우 루프 내에서 VAR을 수정하여 수정할 수 있습니다. 반대로 LIST의 요소가 lvalue가 아닌 경우 해당 요소를 수정하려는 시도는 실패합니다. 다시 말해, &lt;code&gt;foreach&lt;/code&gt; 루프 인덱스 변수는 목록의 각 항목에 대한 암시 적 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="3cbc5bd59ee7e5290e2a6a24d40e5bd7de01e87c" translate="yes" xml:space="preserve">
          <source>If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">함수에 OVERLOAD : 키워드가있는 경우 오버로드 매직에 등록하기 위해 xsubpp에서 생성 한 c 파일에 몇 개의 추가 행이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="705cbac0d6d9464ed1b8a92ba681b4a46a07d153" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">리스트 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 등) 또는 단항 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 등) 뒤에 다음 토큰으로 왼쪽 괄호가 오는 경우, 괄호 안의 연산자와 인수는 우선 순위가 가장 높습니다. 정상적인 함수 호출처럼.</target>
        </trans-unit>
        <trans-unit id="cec7c53718240c968018769a330928a1255918e0" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">리스트 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 등) 또는 단항 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 등) 뒤에 다음 토큰으로 왼쪽 괄호가 오는 경우, 괄호 안의 연산자와 인수는 우선 순위가 가장 높습니다. 정상적인 함수 호출처럼. 예를 들어, 명명 된 단항 연산자가 &lt;code&gt;||&lt;/code&gt; 보다 우선 순위가 높기 때문에 :</target>
        </trans-unit>
        <trans-unit id="fc09b29b0e202c3ba1b9de2b8c7b1a00d9fcb394" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">목록 연산자 ( &lt;code&gt;print()&lt;/code&gt; 등) 또는 단항 연산자 ( &lt;code&gt;chdir()&lt;/code&gt; 등) 다음에 다음 토큰으로 왼쪽 괄호가 오면 괄호 안의 연산자와 인수가 가장 높은 우선 순위를 갖습니다. 일반적인 함수 호출과 같습니다.</target>
        </trans-unit>
        <trans-unit id="189e6bb75ad5ffde9c93fb5cd316abd2034296e1" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">목록 연산자 ( &lt;code&gt;print()&lt;/code&gt; 등) 또는 단항 연산자 ( &lt;code&gt;chdir()&lt;/code&gt; 등) 다음에 다음 토큰으로 왼쪽 괄호가 오면 괄호 안의 연산자와 인수가 가장 높은 우선 순위를 갖습니다. 일반적인 함수 호출과 같습니다. 예를 들어, 명명 된 단항 연산자는 &lt;code&gt;||&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b227e6f9b5d8d36337845d9688db6eb8efa3551d" translate="yes" xml:space="preserve">
          <source>If any module's own AUTOLOAD subroutine has no need to fallback to the AutoLoader's AUTOLOAD subroutine (because it doesn't have any AutoSplit subroutines), then that module should not use &lt;b&gt;AutoLoader&lt;/b&gt; at all.</source>
          <target state="translated">모듈 자체의 AUTOLOAD 서브 루틴이 AutoLoader의 AUTOLOAD 서브 루틴으로 대체 될 필요가없는 경우 (AutoSplit 서브 루틴이 없기 때문에) 해당 모듈은 &lt;b&gt;AutoLoader&lt;/b&gt; 를 전혀 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="54f05d2b51008f086be29ce06ad2dc1e36ce0970" translate="yes" xml:space="preserve">
          <source>If any of the alternatives matches, the hash &lt;code&gt;%+&lt;/code&gt; is bound to contain the three key-value pairs.</source>
          <target state="translated">대안이 일치하면 해시 &lt;code&gt;%+&lt;/code&gt; 는 세 개의 키-값 쌍을 포함하도록 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dde2e9ba6df88b543ea738e9014946a615cc8feb" translate="yes" xml:space="preserve">
          <source>If any of the entries in an import list begins with !, : or / then the list is treated as a series of specifications which either add to or delete from the list of names to import. They are processed left to right. Specifications are in the form:</source>
          <target state="translated">가져 오기 목록의 항목 중 하나가!, : 또는 /로 시작하면 목록은 가져올 이름 목록에 추가하거나 삭제하는 일련의 스펙으로 처리됩니다. 왼쪽에서 오른쪽으로 처리됩니다. 사양은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="eed3f110a3402c08d6252799be2b5ee0618e62e2" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt;, and you need to remember that &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;stat _&lt;/code&gt;). Example:</source>
          <target state="translated">파일 테스트 (또는 &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt; 연산자)에 단독 밑줄로 구성된 특수 파일 핸들이 제공되면 이전 파일 테스트 (또는 &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 연산자) 의 stat 구조 가 사용되어 시스템 호출이 절약됩니다. (이는 &lt;code&gt;-t&lt;/code&gt; 와 함께 작동하지 않으며 &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;-l&lt;/code&gt; 은 실제 파일이 아닌 심볼릭 링크의 stat 구조에 값 을 남긴다 는 점을 기억해야 합니다.) (또한 stat 버퍼가 &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt; 호출에 의해 채워진 경우 , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 &lt;code&gt;stat _&lt;/code&gt; 의 결과로 재설정합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3fd2433b191431a7e89003ab4a4e523c3a5de0d9" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">파일 테스트 (또는 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 연산자)에 단독 밑줄로 구성된 특수 파일 처리가 제공되면 이전 파일 테스트 (또는 stat 연산자)의 통계 구조가 사용되어 시스템 호출을 저장합니다. (이것은 &lt;code&gt;-t&lt;/code&gt; 에서는 작동하지 않으며 lstat () 및 &lt;code&gt;-l&lt;/code&gt; 은 실제 파일이 아닌 기호 링크의 통계 구조에 값을 남겨 둡니다.) (또한 통계 버퍼가 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 호출, &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 의 결과로 재설정합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="c70d4afb0f7f0b8a4b2bcb0de7d2fe106cb41892" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">파일 테스트 (또는 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 연산자)에 단독 밑줄로 구성된 특수 파일 처리가 제공되면 이전 파일 테스트 (또는 stat 연산자)의 통계 구조가 사용되어 시스템 호출을 저장합니다. (이것은 &lt;code&gt;-t&lt;/code&gt; 에서는 작동하지 않으며 lstat () 및 &lt;code&gt;-l&lt;/code&gt; 은 실제 파일이 아닌 기호 링크의 통계 구조에 값을 남겨 둡니다.) (또한 통계 버퍼가 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 호출, &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 의 결과로 재설정합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="4eae7869337353cadd5cbfe4d84a955fd03cd8ba" translate="yes" xml:space="preserve">
          <source>If any of the given search directories contains a</source>
          <target state="translated">주어진 검색 디렉토리 중 하나에</target>
        </trans-unit>
        <trans-unit id="0865eba790bb7da4cb38d4fafb11a71c0ca93d75" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">세 개의 값 중 하나 인 경우 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 그 시간 값을 사용하지 않습니다. 예를 들어 &lt;code&gt;$mtime&lt;/code&gt; 만 설정 하려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f9ae80c94036ecc3639a1310fc69fc12fe61781c" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;undef&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">세 개의 값 중 하나 인 경우 &lt;code&gt;undef&lt;/code&gt; 그 시간 값을 사용하지 않습니다. 예를 들어 &lt;code&gt;$mtime&lt;/code&gt; 만 설정 하려면</target>
        </trans-unit>
        <trans-unit id="341a4d7e4dbc9eeb69d34b947d58bc6f15ecb9f2" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;. So don't do that.</source>
          <target state="translated">LIST의 일부가 배열 인 경우 루프 본문 내에 요소를 추가하거나 제거하면 (예 : &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;foreach&lt;/code&gt; 가 매우 혼란스러워집니다 . 그러지 마</target>
        </trans-unit>
        <trans-unit id="a6977803bb4132cdee0ca3d69dd5582749d63459" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;splice&lt;/code&gt;. So don't do that.</source>
          <target state="translated">LIST의 일부가 배열 인 경우, 예를 들어 &lt;code&gt;splice&lt;/code&gt; 와 같이 루프 본문 내에서 요소를 추가하거나 제거하면 &lt;code&gt;foreach&lt;/code&gt; 가 매우 혼란스러워집니다 . 그러지 마십시오.</target>
        </trans-unit>
        <trans-unit id="31cf9c709860eea50a338d60ff5edf1e2478723c" translate="yes" xml:space="preserve">
          <source>If applicable, please include details on what the user should do to correct the error; documenting an error as indicating &quot;the input buffer is too small&quot; without telling the user how to increase the size of the input buffer (or at least telling them that it isn't possible) aren't very useful.</source>
          <target state="translated">해당되는 경우 사용자가 오류를 해결하기 위해 수행해야하는 작업에 대한 세부 정보를 포함하십시오. 사용자에게 입력 버퍼의 크기를 늘리는 방법을 알려주지 않고 (또는 적어도 가능하지 않다고 알리는) 오류를 &quot;입력 버퍼가 너무 작습니다&quot;라고 표시하는 것은 그리 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17ebb7f065dcd7d1005a6e70cd7fc9ddab662a16" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">인수가 지정되면 히스토리에 포함될 최소 크기의 행에 대한 조언입니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 역사에 아무것도 포함하지 않음을 의미합니다. 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="558be544e424e324e7828785f1d0946baec4a52b" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;undef&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">인자를 지정하면 히스토리에 포함 할 줄의 최소 크기에 대한 조언입니다. &lt;code&gt;undef&lt;/code&gt; 는 기록에 아무것도 포함하지 않음을 의미합니다. 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2dfd62fe55f271b39c6841425a803e9153fccfd7" translate="yes" xml:space="preserve">
          <source>If at least one handle is ready for the specified kind of operation, the result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon timeout, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; unchanged. Upon error, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; set to indicate the error. To distinguish between timeout and error, set &lt;code&gt;$!&lt;/code&gt; to zero before calling this method, and check it after an empty list is returned.</source>
          <target state="translated">지정된 종류의 작업에 대해 하나 이상의 핸들이 준비된 경우 결과는 각각 읽기, 쓰기 및 예외가있는 핸들을 보유 할 배열에 대한 참조 인 3 개 요소의 배열이됩니다. 시간이 초과되면 &lt;code&gt;$!&lt;/code&gt; 와 함께 빈 목록이 반환됩니다 . 변하지 않은. 오류가 발생하면 &lt;code&gt;$!&lt;/code&gt; 와 함께 빈 목록이 반환됩니다 . 오류를 나타내도록 설정합니다. 시간 초과와 오류를 구분하려면 &lt;code&gt;$!&lt;/code&gt; 이 메서드를 호출하기 전에 0으로 설정하고 빈 목록이 반환 된 후 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="84097126d5165e3f6c46b39868c8cad17c6bb873" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls &lt;b&gt;under&lt;/b&gt; 5.6 is important, one must write instead a &lt;code&gt;use vars&lt;/code&gt; statement.</source>
          <target state="translated">5.6 &lt;b&gt;미만의&lt;/b&gt; Perls &lt;b&gt;에&lt;/b&gt; 대한 이전 버전과의 호환성 이 중요한 경우 대신 &lt;code&gt;use vars&lt;/code&gt; 문을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd699eb48fd240fe4a2bcf57e3a3520a6ee8d6f2" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls under 5.6 is important, one must write instead a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; statement.</source>
          <target state="translated">5.6 미만의 Perls에 대한 이전 버전과의 호환성이 중요한 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 문을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b7d0b9799b974e77c25f857fd60005fd09516395" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">비트가 4 이하이면 문자열이 바이트로 분할되고 각 바이트의 비트가 8 / BITS 그룹으로 분할됩니다. 바이트의 비트는 &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; 과 같이 리틀 엔디안 방식으로 번호가 매겨집니다 . 예를 들어, 단일 입력 바이트 &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 을 두 그룹으로 나누면 목록 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; . 4 그룹으로 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="77d4537f5763ddf89d58388ac5f77f55fec21e75" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">비트가 4 이하이면 문자열이 바이트로 분할되고 각 바이트의 비트가 8 / BITS 그룹으로 분할됩니다. 바이트의 비트는 &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; 과 같이 리틀 엔디안 방식으로 번호가 매겨집니다 . 예를 들어, 단일 입력 바이트 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 을 두 그룹으로 나누면 목록 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; . 4 그룹으로 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fce82eab0f0647014ec432d0b3fa1af89e83a3" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt;, &lt;code&gt;0x02&lt;/code&gt;, &lt;code&gt;0x04&lt;/code&gt;, &lt;code&gt;0x08&lt;/code&gt;, &lt;code&gt;0x10&lt;/code&gt;, &lt;code&gt;0x20&lt;/code&gt;, &lt;code&gt;0x40&lt;/code&gt;, &lt;code&gt;0x80&lt;/code&gt;. For example, breaking the single input byte &lt;code&gt;chr(0x36)&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt;; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt;.</source>
          <target state="translated">비트가 4 이하이면 문자열이 바이트로 나뉘고 각 바이트의 비트가 8 / BITS 그룹으로 나뉩니다. 바이트의 비트는 &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; 에서와 같이 리틀 엔디안 방식으로 번호가 매겨집니다 . 예를 들어, 단일 입력 바이트 &lt;code&gt;chr(0x36)&lt;/code&gt; 을 두 그룹으로 나누면 목록 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; . 4 개의 그룹으로 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0f5d848a9043e820336aaa7c2b5b535010685b" translate="yes" xml:space="preserve">
          <source>If both arguments to &lt;code&gt;copy&lt;/code&gt; are not file handles, then &lt;code&gt;copy&lt;/code&gt; will perform a &quot;system copy&quot; of the input file to a new output file, in order to preserve file attributes, indexed file structure,</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 할 두 인수가 모두 파일 핸들이 아닌 경우, &lt;code&gt;copy&lt;/code&gt; 는 파일 속성, 색인화 된 파일 구조를 보존하기 위해 입력 파일의 &quot;시스템 복사&quot;를 새 출력 파일로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e9104a77e501731bf3173e5f8cc7012527cca560" translate="yes" xml:space="preserve">
          <source>If both the SIGNAL and the PROCESS are negative, the results are undefined. A warning may be produced in a future version.</source>
          <target state="translated">SIGNAL과 PROCESS가 모두 음수이면 결과가 정의되지 않습니다. 향후 버전에서는 경고가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c2b718c80fc2756eb63ba9991217396d36da72" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt; ), the left column contains both forms, with and without braces.</source>
          <target state="translated">속성을 지정하는 데 중괄호가 필요하지 않은 경우 (예 : &lt;code&gt;\pL&lt;/code&gt; ) 왼쪽 열에는 중괄호가 있거나없는 두 양식이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8260701f533c58633eabb2e152bfb995da51c762" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt;), the left column contains both forms, with and without braces.</source>
          <target state="translated">속성을 지정하는 데 중괄호가 필요하지 않은 경우 (예 : &lt;code&gt;\pL&lt;/code&gt; ) 왼쪽 열에는 중괄호가 있거나없는 두 형식이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4169e83148646605b11ff599e0ccd6579a7d78" translate="yes" xml:space="preserve">
          <source>If branches are involved (ie. $Revision: 1.5.3.4$) it's a little more complicated.</source>
          <target state="translated">브랜치가 관련된 경우 (예 : $ Revision : 1.5.3.4 $) 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="2c0abc37f0d263edf159adfc0dd160a4e923f046" translate="yes" xml:space="preserve">
          <source>If building completes successfully, you can set up smoke testing as described in the Test::Smoke documentation.</source>
          <target state="translated">빌드가 성공적으로 완료되면 Test :: Smoke 문서에 설명 된대로 연기 테스트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c319407a62fb715df8d4d26f7931f9374106237" translate="yes" xml:space="preserve">
          <source>If building natively on PASE, please do the build under the /QOpenSys directory, since Perl is happier when built on a case sensitive filesystem.</source>
          <target state="translated">기본적으로 PASE로 빌드하는 경우, 대소 문자 구분 파일 시스템에서 빌드 할 때 Perl이 더 행복하므로 / QOpenSys 디렉토리에서 빌드를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="973afa89149c95161585621016fbc1be5e704a2e" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.org you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">mingw-w64.org에서 제공하는 크로스 컴파일러로 빌드하는 경우 makefile.mk에서 GCCCROSS를 설정하는 줄의 주석 처리를 제거해야합니다. 교차 컴파일러 인 경우에만이 작업을 수행하십시오. 즉, bin 폴더에 gcc.exe가 포함되어 있지 않은 경우에만 수행하십시오. (크로스 컴파일러는 gcc.exe, g ++. exe, ar.exe 등을 제공하지 않습니다. 대신 이러한 모든 실행 파일에는 'x86_64-w64-mingw32-'접두사가 붙습니다.)</target>
        </trans-unit>
        <trans-unit id="2edb493675bf68411bac8372236ccf07c63ce62d" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.sourceforge.net you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">mingw-w64.sourceforge.net에서 제공하는 크로스 컴파일러로 빌드하는 경우 makefile.mk에서 GCCCROSS를 설정하는 행의 주석을 해제해야합니다. 크로스 컴파일러 인 경우에만, 즉 bin 폴더에 gcc.exe가없는 경우에만 수행하십시오. 크로스 컴파일러는 gcc.exe, g ++. exe, ar.exe 등을 제공하지 않습니다. 대신 이러한 모든 실행 파일 앞에는 'x86_64-w64-mingw32-'가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="9e17d613e1404f153f1b0ce16d928004818ba4b8" translate="yes" xml:space="preserve">
          <source>If by daemon process you mean one that's detached (disassociated from its tty), then the following process is reported to work on most Unixish systems. Non-Unix users should check their Your_OS::Process module for other solutions.</source>
          <target state="translated">데몬 프로세스에 의해 분리 된 (tty와 분리 된) 프로세스를 의미하는 경우 다음 프로세스가 대부분의 Unixish 시스템에서 작동하는 것으로보고됩니다. Unix 이외의 사용자는 Your_OS :: Process 모듈에서 다른 솔루션을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f14156857ddead4c835ba55e44d3f79ccfb246a2" translate="yes" xml:space="preserve">
          <source>If by some reasons</source>
          <target state="translated">어떤 이유로</target>
        </trans-unit>
        <trans-unit id="85a1911ef5d789d9bb6809a0f2c6b323a8f5cec0" translate="yes" xml:space="preserve">
          <source>If callbacks are used, they will be issued before this call returns.</source>
          <target state="translated">콜백이 사용되면이 콜이 반환되기 전에 콜백이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="313e870db9c5d448dca42a14416b5684a916e7ce" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, calls get magic.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvfn&lt;/code&gt; 으로 호출 되거나 플래그에 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 비트가 설정 되어 있으면 호출이 마법을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="706aad3a29650f166c943e5c886b39dcd0a4394e" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags include &lt;code&gt;SV_GMAGIC&lt;/code&gt; , calls get magic.</source>
          <target state="translated">로 불리는 경우 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 또는 플래그가 포함 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 을 , 호출은 마법을 얻을.</target>
        </trans-unit>
        <trans-unit id="614a0f52f1c33eb959730f1d5d32f8786b9d57d8" translate="yes" xml:space="preserve">
          <source>If called as an instance method (i.e. $md5-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case.</source>
          <target state="translated">인스턴스 메소드 (즉, $ md5-&amp;gt; new)로 호출되면 객체의 상태를 새로 작성된 객체의 상태로 재설정하기 만하면됩니다. 이 경우 새로운 객체가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9eff0140ef6933e6b5cb7ac53c50b2609e62aacb" translate="yes" xml:space="preserve">
          <source>If called as an instance method, the value is assigned to the invocand.</source>
          <target state="translated">인스턴스 메서드로 호출되면 값이 호출자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8679ce9e8862eb205bcd677039372fd6e97a03da" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">목록 컨텍스트에서 호출되고 글로벌 변수 &lt;code&gt;$INSTANCES&lt;/code&gt; 가 true 값이면 &lt;code&gt;PATH&lt;/code&gt; 에서 찾은 이진 인스턴스의 전체 경로 목록을 찾 거나 찾지 못한 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df3b5a11aab4c086bd9cac6e1ddae966355312d8" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="translated">목록 컨텍스트에서 호출되고 전역 변수 &lt;code&gt;$INSTANCES&lt;/code&gt; 가 참 값이면 &lt;code&gt;PATH&lt;/code&gt; 에서 찾은 바이너리 인스턴스에 대한 전체 경로 목록을 반환 하거나 찾을 수없는 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8293e343dafdb403ea7c5d5ddbde243205b61a6" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">목록 컨텍스트에서 호출되면 &lt;code&gt;PATH&lt;/code&gt; 에서 찾은 이진 인스턴스의 전체 경로 목록을 찾 거나 찾지 못한 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5370268c560e6f64c9874ef2c0fc0f892b2ca25" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="translated">목록 컨텍스트에서 호출되면 &lt;code&gt;PATH&lt;/code&gt; 에서 찾은 바이너리 인스턴스에 대한 전체 경로 목록을 반환 하거나 찾을 수없는 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="522ffa67a9fbac5fe032f13cc8e4e97e4f0b245b" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it was not.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 찾은 바이너리에 대한 전체 경로를 반환하거나 그렇지 않은 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8320f2054497a9bae0f18de5b046bd415cc37b89" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;undef&lt;/code&gt; if it was not.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 찾은 바이너리에 대한 전체 경로를 반환하고 그렇지 않은 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95f63f3ffa5199ae8cbe82545b9235a06bf20e5c" translate="yes" xml:space="preserve">
          <source>If called in a scalar context, &lt;code&gt;getsym&lt;/code&gt; returns the value of the symbol whose name is given as the argument to the call, or &lt;code&gt;undef&lt;/code&gt; if no such symbol exists. Symbols in the local symbol table are always used in preference to symbols in the global symbol table. If called in a list context, &lt;code&gt;getsym&lt;/code&gt; returns a two-element list, whose first element is the value of the symbol, and whose second element is the string 'GLOBAL' or 'LOCAL', indicating the table from which the symbol's value was read.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되는 경우 &lt;code&gt;getsym&lt;/code&gt; 은 호출에 대한 인수로 이름이 지정된 기호의 값을 반환하거나 그러한 기호가 없으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다. 로컬 기호 테이블의 기호는 항상 전역 기호 테이블의 기호보다 우선적으로 사용됩니다. 목록 컨텍스트에서 호출되면 &lt;code&gt;getsym&lt;/code&gt; 은 첫 번째 요소가 기호 값이고 두 번째 요소가 문자열 'GLOBAL'또는 'LOCAL'인 두 요소 목록을 반환하여 기호 값을 읽은 테이블을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="b5dcbe2314e7e7c1c4c1bcc0ca660c9625dfb9c3" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the &lt;code&gt;O_TEMPORARY&lt;/code&gt; flag) the file is marked for deletion when the program ends (equivalent to setting UNLINK to 1). The &lt;code&gt;UNLINK&lt;/code&gt; flag is ignored if present.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 파일 핸들 만 반환되고이를 지원하는 운영 체제에서 닫힐 때 파일이 자동으로 삭제됩니다 (이 문서의 다른 부분에서 tmpfile ()에 대한 설명 참조). 이것은 파일 핸들 만 가지고있는 것처럼 파일 이름을 더듬어 경합 조건을 만들 수 없기 때문에 선호되는 작업 모드입니다. 열린 파일의 링크를 해제 할 수 없거나 파일을 열 때 임시로 표시 할 수없는 시스템 (예 : Windows NT는 &lt;code&gt;O_TEMPORARY&lt;/code&gt; 플래그 사용)에서 프로그램이 종료 될 때 파일이 삭제 표시됩니다 (UNLINK를 1로 설정하는 것과 동일). . &lt;code&gt;UNLINK&lt;/code&gt; 플래그가있는 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5e86b593d758e5e3c8998823e4b17f5dfdc961bc" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the C</source>
          <target state="translated">스칼라 컨텍스트에서 호출 된 경우, 파일 핸들 만 리턴되며이를 지원하는 운영 체제에서 파일을 닫으면 파일이 자동으로 삭제됩니다 (이 문서의 다른 곳에서 tmpfile ()에 대한 설명 참조). 파일 핸들 만 가지고있는 것처럼 파일 이름으로 인해 경쟁 조건을 만들 수 없으므로 선호되는 작동 모드입니다. 열린 파일을 링크 해제 할 수 없거나 파일을 열 때 파일을 임시 파일로 표시 할 수없는 시스템 (예 : Windows NT는 C</target>
        </trans-unit>
        <trans-unit id="2926650808a88d22bd30c27717549af3be1de564" translate="yes" xml:space="preserve">
          <source>If called when &lt;code&gt;use utf8&lt;/code&gt; is in effect, the string will be assumed to be encoded in UTF-8, and &lt;code&gt;evalbytes&lt;/code&gt; will make a temporary copy to work from, downgraded to non-UTF-8. If this is not possible (because one or more characters in it require UTF-8), the &lt;code&gt;evalbytes&lt;/code&gt; will fail with the error stored in &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 이 유효 할 때 호출되면 문자열은 UTF-8로 인코딩 된 것으로 간주되고 &lt;code&gt;evalbytes&lt;/code&gt; 는 작업 할 임시 복사본을 만들어 비 UTF-8로 다운 그레이드합니다. 이것이 가능하지 않은 경우 (하나 이상의 문자에 UTF-8이 필요하기 때문에) &lt;code&gt;evalbytes&lt;/code&gt; 는 &lt;code&gt;$@&lt;/code&gt; 저장된 오류와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c83187abf3e8e59deed13ec45be5007e63c321fb" translate="yes" xml:space="preserve">
          <source>If called with a property that doesn't have synonyms for its values, it returns the input value, possibly normalized with capitalization and underscores, but not necessarily checking that the input value is valid.</source>
          <target state="translated">값과 동의어가없는 속성으로 호출 된 경우 입력 값을 반환합니다. 대문자와 밑줄로 정규화 할 수 있지만 입력 값이 유효한지 반드시 확인하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="abcbf5b218ac08698c7495d3bca85cf2f5fc593a" translate="yes" xml:space="preserve">
          <source>If called with an argument &lt;code&gt;blocking&lt;/code&gt; will turn on non-blocking IO if &lt;code&gt;BOOL&lt;/code&gt; is false, and turn it off if &lt;code&gt;BOOL&lt;/code&gt; is true.</source>
          <target state="translated">인수 &lt;code&gt;blocking&lt;/code&gt; 과 함께 호출 하면 &lt;code&gt;BOOL&lt;/code&gt; 이 false 인 경우 비 차단 IO가 켜지고 &lt;code&gt;BOOL&lt;/code&gt; 이 true이면 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="cd8fbca057a7b0f8546bef2e8eba78cd01155b5c" translate="yes" xml:space="preserve">
          <source>If called with an argument the &lt;code&gt;list&lt;/code&gt; returns the size of the message in octets.</source>
          <target state="translated">인수와 함께 호출하면 &lt;code&gt;list&lt;/code&gt; 은 메시지 크기를 옥텟으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3101b42b801bc480044d4583af8814cf3a6fda1" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt; 's of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">인수없이 호출하면 해시에 대한 참조가 반환됩니다. 키는 삭제되지 않은 모든 메시지 의 &lt;code&gt;MSGNUM&lt;/code&gt; 이 되고 값은 옥텟 단위의 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="9173f9598d9b0aafc765ff35df05afedacca6dc3" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt;'s of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">인수없이 호출하면 해시에 대한 참조가 반환됩니다. 키는 삭제되지 않은 모든 메시지 의 &lt;code&gt;MSGNUM&lt;/code&gt; 이며 값은 옥텟 단위의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="048702f1da8ec8b9e869f3d2d0c04bad9a57c4d8" translate="yes" xml:space="preserve">
          <source>If can not unlink open file, defer removal until later available since 0.06.</source>
          <target state="translated">열려있는 파일의 연결을 해제 할 수없는 경우 0.06 이후에 사용할 수있을 때까지 제거를 연기합니다.</target>
        </trans-unit>
        <trans-unit id="e77963c1065ed922557c941a37ed57186c92ec48" translate="yes" xml:space="preserve">
          <source>If capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such</source>
          <target state="translated">캡처 괄호를 정규식에 사용하면 일치하는 소스 문자열 부분을 참조하고 정확히 같은 것을 일치시킬 수 있습니다. 그러한 것을 언급하는 세 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="ca37e501b1a5684a1fb419774ed5fda0c1e909b2" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG&lt;/code&gt;), both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">&lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; ( &lt;code&gt;-Accflags=-DPERL_MEM_LOG&lt;/code&gt; )로 컴파일하면 메모리 할당과 SV 할당이 모두 로깅 기능을 거치므로 중단 점 설정에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8ef19162a844967deef3f5d85d04764641f71041" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; , both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">&lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 로 컴파일하면 메모리 및 SV 할당 모두 로깅 기능 을 거치므로 중단 점 설정에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="505c257963541e6d1081b0bfdec05dc2d7991e03" translate="yes" xml:space="preserve">
          <source>If constant folding was not performed, the execution-order thread is created.</source>
          <target state="translated">상수 폴딩이 수행되지 않으면 실행 순서 스레드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0592ae26e8bb261300ebbed2b588cacc05e4ff" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable can be used to modify the environment on the target system. However, how and where it's used, and even if it's used at all, is entirely dependent on both the transport mechanism (targetrun) and what the target system is. Unless the relevant documentation says otherwise, it is genereally not useful.</source>
          <target state="translated">교차 컴파일의 경우이 변수를 사용하여 대상 시스템의 환경을 수정할 수 있습니다. 그러나 사용 방법과 위치, 심지어 사용하더라도 전송 메커니즘 (targetrun)과 대상 시스템이 무엇인지에 전적으로 달려 있습니다. 관련 문서에서 달리 언급하지 않는 한, 실제로는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c66c617b16e576e77dc9dc8e186d44f33fe447f3" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the location of sh on the target system. If not, this will be the same as $sh.</source>
          <target state="translated">교차 컴파일의 경우이 변수에는 대상 시스템에서 sh의 위치가 포함됩니다. 그렇지 않으면 $ sh와 같습니다.</target>
        </trans-unit>
        <trans-unit id="60357fb3a62a70cdf0b8804a617b55fe7b82dc59" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the target architecture. If not, this will be empty.</source>
          <target state="translated">크로스 컴파일시이 변수에는 대상 아키텍처가 포함됩니다. 그렇지 않으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5ce981aa84829db1548a6d11516c6b5fa9cbc60" translate="yes" xml:space="preserve">
          <source>If d_procselfexe is defined, $procselfexe is the filename of the symbolic link pointing to the absolute pathname of the executing program.</source>
          <target state="translated">d_procselfexe가 정의 된 경우 $ procselfexe는 실행중인 프로그램의 절대 경로 이름을 가리키는 기호 링크의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dc4c096ee5da0f37bd52c68590795a5281826f8c" translate="yes" xml:space="preserve">
          <source>If declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.</source>
          <target state="translated">가장 바깥 쪽 범위 (파일 범위)에서 선언 된 경우 어휘는 C의 파일 정적처럼 작동합니다. 그것들은 아래에 선언 된 동일한 파일의 모든 기능에 사용할 수 있지만 해당 파일 외부에서는 액세스 할 수 없습니다. 이 전략은 모듈 전체에서 볼 수있는 개인 변수를 만들기 위해 모듈에서 사용되기도합니다.</target>
        </trans-unit>
        <trans-unit id="145d6c1efc9692f7f88fb5f7ebc95c113e29dc12" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. If not specified it defaults to &lt;code&gt;1&lt;/code&gt; (blocking mode).</source>
          <target state="translated">정의되었지만 거짓이면 소켓은 비 차단 모드로 설정됩니다. 지정하지 않으면 기본값은 &lt;code&gt;1&lt;/code&gt; (차단 모드)입니다.</target>
        </trans-unit>
        <trans-unit id="9038caa549899b94401a0838d72ace7d4bde5fe6" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. Otherwise it will default to blocking mode. See the NON-BLOCKING section below for more detail.</source>
          <target state="translated">정의되었지만 거짓이면 소켓은 비 차단 모드로 설정됩니다. 그렇지 않으면 기본적으로 차단 모드가됩니다. 자세한 내용은 아래 NON-BLOCKING 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ae3059e06d397630c09d4c165cce518cf89f33b" translate="yes" xml:space="preserve">
          <source>If defined specifies whether color output is desired. If &lt;code&gt;color&lt;/code&gt; is not defined it will default to color output if color support is available on the current platform and output is not being redirected.</source>
          <target state="translated">정의 된 경우 컬러 출력을 원하는지 여부를 지정합니다. 경우 &lt;code&gt;color&lt;/code&gt; 정의되지 않은 색상 지원은 현재 플랫폼에서 사용할 수 있으며 출력은 재 지정되지 않는 경우는 컬러 출력을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f94a897ccd9f764c01b106a5cdfcd1ac35d63b36" translate="yes" xml:space="preserve">
          <source>If defined, gives a maximum time in seconds to block per &lt;code&gt;connect()&lt;/code&gt; call when in blocking mode. If missing, no timeout is applied other than that provided by the underlying operating system. When in non-blocking mode this parameter is ignored.</source>
          <target state="translated">정의 된 경우 차단 모드에서 &lt;code&gt;connect()&lt;/code&gt; 호출 당 차단할 최대 시간 (초)을 제공 합니다. 누락 된 경우 기본 운영 체제에서 제공하는 시간 제한 외에는 적용되지 않습니다. 비 차단 모드에서는이 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f028cf73562b9d54628306ef212e57f51c8b344" translate="yes" xml:space="preserve">
          <source>If defined, puts the socket into listening mode where new connections can be accepted using the &lt;code&gt;accept&lt;/code&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="translated">정의 된 경우 소켓을 &lt;code&gt;accept&lt;/code&gt; 메소드를 사용하여 새 연결을 승인 할 수있는 청취 모드로 설정합니다 . 주어진 값은 &lt;code&gt;listen(2)&lt;/code&gt; 큐 크기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e020a19c9382a48776779d2ba22b74e383d938da" translate="yes" xml:space="preserve">
          <source>If defined, set the &lt;code&gt;IPV6_V6ONLY&lt;/code&gt; sockopt when creating &lt;code&gt;PF_INET6&lt;/code&gt; sockets to the given value. If true, a listening-mode socket will only listen on the &lt;code&gt;AF_INET6&lt;/code&gt; addresses; if false it will also accept connections from &lt;code&gt;AF_INET&lt;/code&gt; addresses.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;PF_INET6&lt;/code&gt; 소켓을 만들 때 &lt;code&gt;IPV6_V6ONLY&lt;/code&gt; sockopt 를 지정된 값으로 설정합니다. 참이면 청취 모드 소켓은 &lt;code&gt;AF_INET6&lt;/code&gt; 주소 에서만 청취 합니다. false이면 &lt;code&gt;AF_INET&lt;/code&gt; 주소의 연결도 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="dc3bd5a9c7fbd30c1f819a008f41219b5c451f73" translate="yes" xml:space="preserve">
          <source>If desired, an optional hash-ref may be specified as the first argument to customize certain aspects of the parse-tree that is created and returned. The set of recognized option keywords are:</source>
          <target state="translated">원하는 경우, 생성 및 리턴되는 구문 분석 트리의 특정 측면을 사용자 정의하기위한 선택적 해시 참조가 첫 번째 인수로 지정 될 수 있습니다. 인식되는 옵션 키워드 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c417457bb41c44d12dd8e05efc098db997c407b3" translate="yes" xml:space="preserve">
          <source>If developing modules for private internal or project specific use, that will never be released to the public, then you should ensure that their names will not clash with any future public module. You can do this either by using the reserved Local::* category or by using a category name that includes an underscore like Foo_Corp::*.</source>
          <target state="translated">개인용 또는 프로젝트 전용 용도로 개발 된 모듈을 일반인에게 공개하지 않는 경우 해당 모듈 이름이 향후 공용 모듈과 충돌하지 않도록해야합니다. 예약 된 Local :: * 범주를 사용하거나 Foo_Corp :: *와 같이 밑줄을 포함하는 범주 이름을 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bf0d1f77248c2c58d4104ac428f32e38cbba679" translate="yes" xml:space="preserve">
          <source>If either (or both!) is a subroutine reference, it is run and used as the value for comparing. For example:</source>
          <target state="translated">서브 루틴 참조 중 하나 (또는 ​​둘 다)가 실행되면 비교를위한 값으로 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28e0eb14814bacb4c751344661d230f561ecbcda" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;LocalHost&lt;/code&gt; or &lt;code&gt;PeerHost&lt;/code&gt; (or their &lt;code&gt;...Addr&lt;/code&gt; synonyms) have any of the following special forms then special parsing is applied.</source>
          <target state="translated">어느 경우 &lt;code&gt;LocalHost&lt;/code&gt; 또는 &lt;code&gt;PeerHost&lt;/code&gt; (또는 &lt;code&gt;...Addr&lt;/code&gt; 동의어는) 다음 특수 형태의이 특별한 구문 분석이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0201c4d3bcdfd14f6a2e27e712be0d303b850c91" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이름 중 하나를 알 수 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다. Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄이 있거나없는)를 사용하여 정규식에서 특성 이름을 인식합니다 . 이 함수는 속성 매개 변수의 항목을 인식하지 않고 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="2293e2a6915536d356b477a7689ee15921487cbe" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">두 이름 중 하나를 알 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄 포함 또는 제외)가 있는 정규식의 속성 이름을 인식합니다 . 이 함수는 속성 매개 변수의 항목을 인식하지 않고 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3926f5454427802efbe3e6cffcb07732270c9a24" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt; ) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">스칼라 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 의 피연산자가 상수 표현식 인 경우, 해당 피연산자가 현재 입력 행 번호 ( &lt;code&gt;$.&lt;/code&gt; 변수)와 같으면 ( &lt;code&gt;==&lt;/code&gt; ) 참으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ec204ca8034e3ccafb322d0a50a88db1356b7fd" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt;) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">스칼라 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 의 피연산자가 상수 표현식이면 해당 피연산자가 현재 입력 행 번호 ( &lt;code&gt;$.&lt;/code&gt; 변수)와 같으면 ( &lt;code&gt;==&lt;/code&gt; ) 참으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2cb5b8cc9c4debb5e9c1cd9b0aff54bfa3a6950" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the empty string or undefined, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">reader 또는 writer가 빈 문자열이거나 정의되지 않은 경우 자동 생성 된 파일 핸들로 대체됩니다. 그렇다면 호출자에서 덮어 쓸 수 있도록 매개 변수 슬롯에 유효한 lvalue를 전달해야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f99b132bd00ba92228931c93b4096f125672ade0" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">reader 또는 writer가 널 (null) 문자열 인 경우 자동 생성 된 파일 핸들로 대체됩니다. 그렇다면 호출자에서 덮어 쓸 수 있도록 매개 변수 슬롯에 유효한 lvalue를 전달해야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c51794930a0cb952da1b5da2c73c8a1455bd1093" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">스크립트 에서 내장 된 문서 (pod 형식의 경우 &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )가 감지되면 &lt;code&gt;--help&lt;/code&gt; 는 설명서에 액세스하는 방법도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="497536c61f20254b3ce1e548c2f1737e3ae2f43e" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">포함 된 문서 (pod 형식, &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )가 스크립트에서 감지되면 &lt;code&gt;--help&lt;/code&gt; 는 문서에 액세스하는 방법도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="69dc58793e20f2f8fe02b29cbd122e892cc2714a" translate="yes" xml:space="preserve">
          <source>If empty is false, mark gv with GVf_INTRO so the next reference assigned is localized, which is how &lt;code&gt; local *foo = $someref; &lt;/code&gt; works.</source>
          <target state="translated">empty가 false이면 gv를 GVf_INTRO로 표시하여 할당 된 다음 참조가 지역화되도록합니다. 이것이 &lt;code&gt; local *foo = $someref; &lt;/code&gt; 공장.</target>
        </trans-unit>
        <trans-unit id="d0235b3841ba3dad5d7f48423a5cbad1433ac050" translate="yes" xml:space="preserve">
          <source>If empty is true, replace the GP with a new GP.</source>
          <target state="translated">비어 있으면 GP를 새 GP로 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="29d066b26000935ae7bb2e10a40ebaebacd4b8b0" translate="yes" xml:space="preserve">
          <source>If enabled, case is ignored when matching option names. If, however, bundling is enabled as well, single character options will be treated case-sensitive.</source>
          <target state="translated">사용 가능한 경우 옵션 이름과 일치 할 때 대소 문자가 무시됩니다. 그러나 번들링이 활성화 된 경우 단일 문자 옵션은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="db7040756e9968d1786c608e978b27880a9b3f0b" translate="yes" xml:space="preserve">
          <source>If everything else fails, you need to build a stand-alone DLL for perl. Contact me, I did it once. Sockets would not work, as a lot of other stuff.</source>
          <target state="translated">다른 모든 것이 실패하면 perl에 대한 독립형 DLL을 빌드해야합니다. 저에게 연락하십시오. 소켓은 다른 많은 것들과 같이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86e67737b28b03a977f15c49feac3a8313e09ab0" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">예외 처리에 관심이 있다면 &lt;a href=&quot;Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt; 와 같이 예외를 처리하는 많은 CPAN 모듈 중 하나를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a7b09ae5de32a801bf3504292c1ba7f8a26bf8f" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">예외 처리에 관심이있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt; 와 같은 예외를 처리하는 많은 CPAN 모듈 중 하나를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="24299a423807f4b77a396032f4cc65f70fe49537" translate="yes" xml:space="preserve">
          <source>If explicitly enabled by</source>
          <target state="translated">에 의해 명시 적으로 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="8ede30fd7e2f6fae82106f61a77ef1de04cb5cb3" translate="yes" xml:space="preserve">
          <source>If false, STDERR is not captured (though it is 'relayed' to keep it somewhat synchronized with STDOUT.)</source>
          <target state="translated">false 인 경우 STDERR이 캡처되지 않습니다 (STDOUT과 다소 동기화 된 상태를 유지하기 위해 '릴레이'됨).</target>
        </trans-unit>
        <trans-unit id="9b5838f52003c96db3e6bffb7f5e0838c7d79e5c" translate="yes" xml:space="preserve">
          <source>If false, readline support in the debugger is disabled in order to debug applications that themselves use ReadLine.</source>
          <target state="translated">False이면 ReadLine을 사용하는 응용 프로그램을 디버깅하기 위해 디버거에서 readline 지원이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b1fe899108d979b4e6baf329c011d799eeebe85b" translate="yes" xml:space="preserve">
          <source>If filenames might use strange characters, it is safest to open it with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; , and &lt;code&gt;|&lt;/code&gt;, which may be the wrong thing to do. (Sometimes, though, it's the right thing.) Three-arg open can also help protect against this translation in cases where it is undesirable.</source>
          <target state="translated">파일 이름이 이상한 문자를 사용할 수있는 경우로 엽니 가장 안전 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 은 마술이며 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; , 이것은 잘못된 일일 수 있습니다. (때로는 옳은 일입니다.) Three-arg open은 바람직하지 않은 경우이 번역으로부터 보호하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f78c1ed61e34e06bf280f0bbcc412ab7e6a2d2f" translate="yes" xml:space="preserve">
          <source>If find is used in &lt;a href=&quot;perlsec#Taint-mode&quot;&gt;taint-mode&lt;/a&gt; (-T command line switch or if EUID != UID or if EGID != GID), then internally directory names have to be untainted before they can be &lt;code&gt;chdir&lt;/code&gt;'d to. Therefore they are checked against a regular expression</source>
          <target state="translated">find가 &lt;a href=&quot;perlsec#Taint-mode&quot;&gt;taint-mode&lt;/a&gt; (-T 명령 행 스위치 또는 EUID! = UID 또는 EGID! = GID 인 경우)에서 사용되는 경우, 내부적으로 디렉토리 이름이 오염되지 않아야 &lt;code&gt;chdir&lt;/code&gt; 'd가 가능합니다. 따라서 정규 표현식에 대해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca04d4d675b32f985d24c749a113dd2e8503548" translate="yes" xml:space="preserve">
          <source>If find is used in taint-mode (-T command line switch or if EUID != UID or if EGID != GID) then internally directory names have to be untainted before they can be chdir'ed to. Therefore they are checked against a regular expression</source>
          <target state="translated">taint-mode (-T 명령 행 스위치 또는 EUID! = UID 또는 EGID! = GID)에서 find를 사용하는 경우 내부적으로 디렉토리 이름을 숨겨야 chdir 할 수 있습니다. 따라서 정규식에 대해 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1ec16d1d9147a52b3c1c50c90741c5c208db46" translate="yes" xml:space="preserve">
          <source>If flags contains &lt;code&gt;PERL_PV_ESCAPE_QUOTE&lt;/code&gt; then any double quotes in the string will also be escaped.</source>
          <target state="translated">플래그에 &lt;code&gt;PERL_PV_ESCAPE_QUOTE&lt;/code&gt; 가 포함 된 경우 문자열의 모든 큰 따옴표도 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="ae542d10e971a673bbde2971d115357debc351d4" translate="yes" xml:space="preserve">
          <source>If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string will also be escaped.</source>
          <target state="translated">플래그에 PERL_PV_ESCAPE_QUOTE가 포함 된 경우 문자열의 큰 따옴표도 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="5f11c4bbd633be0ac4ec3da7d6d4106626b272c7" translate="yes" xml:space="preserve">
          <source>If for some reason you want to have complete control over the data connection, this includes generating it and calling the &lt;code&gt;response&lt;/code&gt; method when required, then the user can use these methods to do so.</source>
          <target state="translated">어떤 이유로 데이터 연결을 완전히 제어하려면 필요한 경우 데이터 생성 및 &lt;code&gt;response&lt;/code&gt; 메소드 호출이 포함됩니다 . 사용자는 이러한 메소드를 사용하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527032a383661eed954e5386c22fa00fa6ffa0b3" translate="yes" xml:space="preserve">
          <source>If generating a manual page from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="translated">표준 입력에서 매뉴얼 페이지를 생성하는 경우이 옵션이 제공되지 않으면 이름이 &lt;code&gt;STDIN&lt;/code&gt; 으로 설정 됩니다. 의미있는 매뉴얼 페이지 이름을 설정하려면이 옵션을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="33f20d3ebb86a1fb4909973670b43aa80acbb4c8" translate="yes" xml:space="preserve">
          <source>If hash values couldn't be lists, you lose. You'd probably have to combine all the cities into a single string somehow, and then when time came to write the output, you'd have to break the string into a list, sort the list, and turn it back into a string. This is messy and error-prone. And it's frustrating, because Perl already has perfectly good lists that would solve the problem if only you could use them.</source>
          <target state="translated">해시 값을 목록으로 만들 수 없으면 손실됩니다. 어쨌든 모든 도시를 단일 문자열로 결합해야 할 때 출력을 쓸 시간이되었을 때 문자열을 목록으로 나누고 목록을 정렬 한 다음 다시 문자열로 바꿔야합니다. 이것은 지저분하고 오류가 발생하기 쉽습니다. 그리고 Perl은 이미 당신이 사용할 수만 있다면 문제를 해결할 완벽한 목록을 가지고 있기 때문에 실망 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="774c1ecd49cf47f66e5a805e842abcc07904cbac" translate="yes" xml:space="preserve">
          <source>If hints are not available for the specified subroutines, this will cause a compile-time error. Insisting on hints for Perl's built-in functions (eg, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt;) is always successful.</source>
          <target state="translated">지정된 서브 루틴에 힌트를 사용할 수없는 경우 컴파일 타임 오류가 발생합니다. Perl의 내장 함수 (예 : &lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;close&lt;/code&gt; ) 에 대한 힌트를 요구하는 것은 항상 성공적입니다.</target>
        </trans-unit>
        <trans-unit id="7e8d248524799b9e3f004b01925fdada9567cc4f" translate="yes" xml:space="preserve">
          <source>If i&amp;lt;checked_at&amp;gt; is a reference to a scalar, then instead it gives the characters pre-checked at the beginning, (and the number of chars by which the C variable name has been advanced. These need to be chopped from the front of</source>
          <target state="translated">i &amp;lt;checked_at&amp;gt;이 스칼라에 대한 참조 인 경우 대신 처음에 사전 확인 된 문자 (및 C 변수 이름이 진보 한 문자 수)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0cd56861a4473054d59049046296e1c9cc1b21dc" translate="yes" xml:space="preserve">
          <source>If illegalproto warnings are enabled, the prototype declared inside this attribute will be sanity checked at compile time.</source>
          <target state="translated">잘못된 프로토콜 경고가 활성화 된 경우이 속성 내에 선언 된 프로토 타입은 컴파일 타임에 완전성 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3aefb53a3e40d895443465bbfd3168415b47af" translate="yes" xml:space="preserve">
          <source>If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.</source>
          <target state="translated">확실하지 않은 경우 표현식을 더 간단한 용어로 나누거나 모든 피연산자를 원하는 결과 유형으로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ce224243c2c27e9c319eeded5da4d7520f7a48e0" translate="yes" xml:space="preserve">
          <source>If instead of the recommended GNU make you would like to use the system supplied make program then be sure to install the default rules file properly via the shell command:</source>
          <target state="translated">권장 GNU make 대신 시스템 제공 make 프로그램을 사용하려면 shell 명령을 통해 기본 규칙 파일을 올바르게 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="8c224a826076db854fafc0daefe6f5025badc4ce" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">대신 줄 끝에서 'foo'단어와 공백, 다음 줄에서 'bar'단어를 찾으려면 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="835a22059d43bc5ff6100b52d4ba22bb32621c13" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;m/$(?)\/&lt;/code&gt; (for example: &lt;code&gt;m/foo$(?)\s+bar/&lt;/code&gt;).</source>
          <target state="translated">대신 줄 끝에있는 단어 'foo'와 공백이 뒤 따르는 단어와 다음 줄의 단어 'bar'를 일치시키려는 경우 &lt;code&gt;m/$(?)\/&lt;/code&gt; 사용할 수 있습니다 (예 : &lt;code&gt;m/foo$(?)\s+bar/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d629d0bcda097aa38909a34c55f2d4899baf7fd4" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array &lt;code&gt;@key&lt;/code&gt; with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">대신 비교 루틴 &lt;code&gt;find_records()&lt;/code&gt; 를 사용 하여 &lt;code&gt;@key&lt;/code&gt; 배열을 정렬하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03def7cbe4cc9c7f39111662b050f07a1bc1197" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array @key with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">대신 배열 @key를 비교 루틴 &lt;code&gt;find_records()&lt;/code&gt; 로 정렬하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1fc62400435ca2b18e437e1de72ea45d0c40705" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt; ) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">유효하지 않은 경우 잘못된 &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; 경고가 생성됩니다. &quot;C0&quot;은 &quot;문자 당 문자열 문자 처리&quot;를 의미합니다. 그없이, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; 에서 작동 할 &lt;code&gt;U0&lt;/code&gt; 의 모드 (기본 경우와 형식 문자열이 시작 &lt;code&gt;U&lt;/code&gt; )과이 (가) 대상 문자열의 UTF-8 인코딩을 구성하는 바이트 반환 뭔가 항상 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7e4f3a7639737362f11e314ec120738bd4bec5b1" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;unpack(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt;) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">유효하지 않은 경우 잘못된 &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; 경고가 생성됩니다. &quot;C0&quot;은 &quot;문자 당 문자열 문자 처리&quot;를 의미합니다. 그없이, &lt;code&gt;unpack(&quot;U*&quot;, ...)&lt;/code&gt; 에서 작동 할 &lt;code&gt;U0&lt;/code&gt; 의 모드 (기본 경우와 형식 문자열이 시작 &lt;code&gt;U&lt;/code&gt; )과이 (가) 대상 문자열의 UTF-8 인코딩을 구성하는 바이트 반환 뭔가 항상 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51c33e52f177d40ae2c3679305c70e4a9572745e" translate="yes" xml:space="preserve">
          <source>If it ain't broke, don't fix it! Perl 4 library scripts should continue to work with no problems. You may need to make some minor changes (like escaping non-array @'s in double quoted strings) but there is no need to convert a .pl file into a Module for just that.</source>
          <target state="translated">고장 나지 않았다면 고치지 마십시오! Perl 4 라이브러리 스크립트는 문제없이 계속 작동해야합니다. 작은 따옴표로 묶인 문자열에서 배열이 아닌 @를 이스케이프 처리하는 것과 같이 약간의 변경을 수행해야 할 수도 있지만 .pl 파일을 모듈로 변환 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ae3aaa5715ffc32724b48d8610f7a354399dcc4" translate="yes" xml:space="preserve">
          <source>If it does not yet provide support for any encoding, one could write a derived class with such a &lt;code&gt;param&lt;/code&gt; method:</source>
          <target state="translated">아직 인코딩을 지원하지 않으면 그러한 &lt;code&gt;param&lt;/code&gt; 메소드를 사용하여 파생 클래스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9548720aabed2519dabd7936701802a11d8a7465" translate="yes" xml:space="preserve">
          <source>If it exists, this field must contains a</source>
          <target state="translated">존재하는 경우이 필드에는</target>
        </trans-unit>
        <trans-unit id="6ed0026aa4685c99082bcd85012c95fb26671228" translate="yes" xml:space="preserve">
          <source>If it is defined and perl is compiled with the C macro &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; defined, then it is called automatically when the interpreter exits for every shared object or library loaded by DynaLoader::bootstrap. All such library references are stored in @dl_librefs by DynaLoader::Bootstrap as it loads the libraries. The files are unloaded in last-in, first-out order.</source>
          <target state="translated">정의되고 perl이 정의 된 C 매크로 &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; 로 컴파일 되면 DynaLoader :: bootstrap이로드 한 모든 공유 객체 또는 라이브러리에 대해 인터프리터가 종료 될 때 자동으로 호출됩니다. 이러한 모든 라이브러리 참조는 라이브러리를로드 할 때 DynaLoader :: Bootstrap에 의해 @dl_librefs에 저장됩니다. 파일은 처음부터 끝까지 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="5b2268451c0f057ce91551f0143bc7efcca84a61" translate="yes" xml:space="preserve">
          <source>If it is determined to be case insensitive, during survey() it may skip pod files/modules that happen to be equal to names it's already seen, ignoring case.</source>
          <target state="translated">대소 문자를 구분하지 않는 것으로 판단되면, survey () 동안 이미 본 이름과 동일한 pod 파일 / 모듈을 건너 뛰고 대소 문자를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d25babefad3e04149e431c9fc9b4ab7fa3f715" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the issue tracker (you will be subscribed to notifications for issues you submit or comment on) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">버그를 수정하는 것이 중요하다면 이슈 트래커 (제출 또는 댓글에 대한 알림을 구독하게됩니다)와 Perl 개발 버전에 대한 커밋 로그를 모니터링하고 친절한 말이나 서리가 내린 음료 제공. (관리자에게 친절하게 대하십시오. 그들을 괴롭 히거나 불 태우는 것은 당신이 원하는 것과 반대되는 효과를 가질 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="860a9992a29a5bed07a92916afafcc39c4466897" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the perl5-porters@perl.org mailing list (mailing lists are moderated, your message may take a while to show up) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">버그를 수정하는 것이 중요한 경우 perl5-porters@perl.org 메일 링리스트 (메일 링리스트가 조정되고 메시지가 표시되는 데 시간이 걸릴 수 있음)와 Perl 개발 버전에 대한 커밋 로그를 모니터링하십시오. 서리가 내린 음료를 친절한 말이나 제안으로 유지하도록 장려하십시오. (관리자에게 친절하게 행동하십시오. 괴롭 히거나 불에 태우면 원하는 것과 반대의 영향을 줄 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="835fcc1c62a963fd6a71d84d2861d08fa2d6dba4" translate="yes" xml:space="preserve">
          <source>If it is impossible to tell from the parameters passed back from the C callback what the context is, then you may need to create a sequence of C callback interface functions, and store pointers to each in an array.</source>
          <target state="translated">컨텍스트가 무엇인지 C 콜백에서 다시 전달 된 매개 변수에서 알 수없는 경우 C 콜백 인터페이스 함수 시퀀스를 작성하고 각각에 대한 포인터를 배열에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="5680f195fb6f8f7119b1a5d53970a5a24089ffc3" translate="yes" xml:space="preserve">
          <source>If it is intended that a new perl binary be produced, this variable may hold a name for that binary. Defaults to perl</source>
          <target state="translated">새로운 perl 바이너리를 생성하려는 경우이 변수는 해당 바이너리의 이름을 가질 수 있습니다. 기본적으로 perl</target>
        </trans-unit>
        <trans-unit id="3922ec0b4a5411b9d0c3915227bde5d37e804a93" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;&quot;&lt;code&gt;PERL_BADFREE&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">지속되면이 경고를 비활성화 할 수 있습니다 . &lt;a href=&quot;#PERL_BADFREE&quot;&gt;&quot; &lt;code&gt;PERL_BADFREE&lt;/code&gt; &quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb1ca7ba722f679f82900212b2623b7a140c3fd8" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;.</source>
          <target state="translated">지속되면이 경고를 비활성화 할 수 있습니다 ( &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3596d2c66fdea5d09f2cf7238ff867c93df8d69a" translate="yes" xml:space="preserve">
          <source>If it runs thru the entire given list of language-tags, and finds no classes for those exact terms, it then tries &quot;superordinate&quot; language classes. So if no &quot;en-US&quot; class (i.e., YourProjClass::en_us) was found, nor classes for anything else in that list, we then try its superordinate, &quot;en&quot; (i.e., YourProjClass::en), and so on thru the other language-tags in the given list: &quot;es&quot;. (The other language-tags in our example list: happen to have no superordinates.)</source>
          <target state="translated">주어진 전체 언어 태그 목록을 통해 실행되고 정확한 용어에 대한 클래스를 찾지 못하면 &quot;상위&quot;언어 클래스를 시도합니다. 따라서 &quot;en-US&quot;클래스 (예 : YourProjClass :: en_us)가 없거나 해당 목록의 다른 클래스가 없으면 상위 &quot;en&quot;(예 : YourProjClass :: en) 등을 시도합니다. 주어진 목록에있는 다른 언어 태그를 통해 : &quot;es&quot;. (예제 목록의 다른 언어 태그는 상위 항목이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="956013cc75574f32898bd3291e14ae9c281c9d63" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;Time::Local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">항상 동일한 형식을 가질만큼 규칙적인 문자열이면 분할 하여 표준 &lt;a href=&quot;Time::Local&quot;&gt;Time :: Local&lt;/a&gt; 모듈의 &lt;code&gt;timelocal&lt;/code&gt; 에 부분을 ​​전달할 수 있습니다 . 그렇지 않으면 CPAN 의 &lt;a href=&quot;Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; , &lt;a href=&quot;Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt; 및 &lt;a href=&quot;Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt; 모듈을 살펴 봐야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e9c27ad93f7400ed6fd8cabde972a2941b1fcc1" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">규칙이 충분한 문자열이면 항상 같은 형식을 &lt;code&gt;timelocal&lt;/code&gt; 습니다. 표준 &lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt; 모듈 에서 분할하여 파트를 timelocal 에 전달할 수 있습니다 . 그렇지 않으면 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt; 모듈을 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="95cd7c9791eb757b708be268b21d99a1603edf51" translate="yes" xml:space="preserve">
          <source>If it's run from a terminal,</source>
          <target state="translated">터미널에서 실행되면</target>
        </trans-unit>
        <trans-unit id="6e686f47ff84852246c986f46416264b0b26f101" translate="yes" xml:space="preserve">
          <source>If just a raw diff is provided, it is also possible use this two-step process:</source>
          <target state="translated">원시 diff 만 제공되는 경우 다음 두 단계 프로세스를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e1fe8c1c0f93c5cc464283fb0d88ef22d53da9" translate="yes" xml:space="preserve">
          <source>If layers are not explicitly specified, the handle will be opened with the layers specified by the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;${^OPEN}&lt;/a&gt; variable (usually set by using the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma for a lexical scope, or the &lt;code&gt;-C&lt;/code&gt; command-line switch or &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable for the main program scope).</source>
          <target state="translated">계층이 명시 적으로 지정하지 않는 경우, 핸들에 의해 지정된 층으로 열린다 &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;$ {^ OPEN}&lt;/a&gt; 변수 (보통 사용하여 설정 &lt;a href=&quot;open&quot;&gt;개방&lt;/a&gt; 어휘 범위에 대한 래그를, 또는 &lt;code&gt;-C&lt;/code&gt; 명령 줄 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 의 환경 변수 주요 프로그램 범위).</target>
        </trans-unit>
        <trans-unit id="e46426c1bbbb04008f9627a6d4ae412c2a64f7b8" translate="yes" xml:space="preserve">
          <source>If layers are not specified in the open() call or &lt;code&gt;${^OPEN}&lt;/code&gt; variable, the handle will be opened with the default layer stack configured for that architecture; see &lt;a href=&quot;#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot;&lt;/a&gt;.</source>
          <target state="translated">레이어가 open () 호출 또는 &lt;code&gt;${^OPEN}&lt;/code&gt; 변수에 지정되지 않은 경우 해당 아키텍처에 대해 구성된 기본 레이어 스택으로 핸들이 열립니다. &lt;a href=&quot;#Defaults-and-how-to-override-them&quot;&gt;&quot;기본값 및 재정의 방법&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec1e5cfa3f1d5f23853bddc58974b89d51e4343" translate="yes" xml:space="preserve">
          <source>If linking miniperl</source>
          <target state="translated">miniperl을 연결하는 경우</target>
        </trans-unit>
        <trans-unit id="6f1ded59583efe50b40fd8b1ab3b5be326101642" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed, unless the locale is a UTF-8 one. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">로케일 일치 규칙이 적용되는 경우 255 미만의 코드 포인트에 대해서는 현재 로케일에서, 더 큰 코드 포인트에 대해서는 유니 코드 규칙에서 케이스 맵을 가져옵니다. 그러나 유니 코드 규칙 / 비 유니 코드 규칙 경계 (ords 255/256)를 넘는 일치는 로케일이 UTF-8이 아닌 경우 성공하지 못합니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bdbff6d4225cd79b23186ed9cad6253292a76ca" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">로케일 일치 규칙이 적용되는 경우 255보다 작은 코드 포인트의 경우 현재 로케일 및 더 큰 코드 포인트의 경우 유니 코드 규칙에서 사례 맵을 가져옵니다. 그러나 유니 코드 규칙 / 비 유니 코드 규칙 경계 (코드 255/256)를 넘는 일치는 성공하지 못합니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="763f933c48615038adc7019dfce8f6c0c593c306" translate="yes" xml:space="preserve">
          <source>If locale rules are not in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="translated">로캘 규칙이 적용되지 않는 경우 유니 코드 속성을 사용하면 정규식이 아직 없으면 유니 코드 규칙을 사용하게됩니다.</target>
        </trans-unit>
        <trans-unit id="d834fc3f63056ccac9737e1620e9488be6eb7541" translate="yes" xml:space="preserve">
          <source>If maketext goes to look in an individual %Lexicon for an entry for</source>
          <target state="translated">maketext가 개별 % Lexicon에서 항목을 찾을 경우</target>
        </trans-unit>
        <trans-unit id="3e3dcee3a8b9bd973fa29d705bfdb80867c80c81" translate="yes" xml:space="preserve">
          <source>If many functions use the same failure indication based on the return value, you may want to create a special typedef to handle this situation. Put</source>
          <target state="translated">많은 함수가 반환 값을 기반으로 동일한 실패 표시를 사용하는 경우이 상황을 처리하기 위해 특별한 typedef를 만들 수 있습니다. 놓다</target>
        </trans-unit>
        <trans-unit id="b606db88e20200612d730cc961241a27da21957f" translate="yes" xml:space="preserve">
          <source>If module is installed, peeks into the module's manpage, reads the headline, and returns it. Moreover, if the module has been downloaded within this session, does the equivalent on the downloaded module even if it hasn't been installed yet.</source>
          <target state="translated">모듈이 설치된 경우 모듈 맨 페이지를 들여다보고 헤드 라인을 읽은 다음 반환합니다. 또한이 세션 내에서 모듈을 다운로드 한 경우 아직 설치되지 않은 경우에도 다운로드 된 모듈에서 동등한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dd58d8ff347dcd8c05f67e1fd3ee4d2440157ff1" translate="yes" xml:space="preserve">
          <source>If more arguments are provided then they are all appended to the message, thus all these lines will have the same effect on the state of the $ctx object:</source>
          <target state="translated">더 많은 인수가 제공되면 모두 메시지에 추가되므로 이러한 모든 행은 $ ctx 객체의 상태에 동일한 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="d7d32d6074826a3d2d75814ea308b5ddeaca2f3c" translate="yes" xml:space="preserve">
          <source>If more delimiters than escape chars are specified, the last escape char is used for the remaining delimiters. If no escape char is specified for a given specified delimiter, '\' is used.</source>
          <target state="translated">이스케이프 문자보다 많은 구분 기호를 지정하면 나머지 구분 기호에 마지막 이스케이프 문자가 사용됩니다. 지정된 구분 기호에 이스케이프 문자를 지정하지 않으면 '\'가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="285c13c421c908ec1b5157ff1d11ce664fe6f585" translate="yes" xml:space="preserve">
          <source>If more than one argument is given then the entire argument list is assumed to be a hash. If a hash is supplied (either as a reference or as a list) it should contain one or more elements with the following keys:</source>
          <target state="translated">둘 이상의 인수가 제공되면 전체 인수 목록이 해시 인 것으로 가정합니다. 해시가 제공되면 (참조 또는 목록으로) 다음 키를 가진 하나 이상의 요소를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="39e41b545db315dc5126671cc2bd5d88f5c30e3d" translate="yes" xml:space="preserve">
          <source>If more than one restriction of &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; , etc. is specified, the results of the separately computed match values must all match. If so, the hashref represented by the YAML document is returned as the preference structure for the current distribution.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; 등의 제한이 둘 이상 지정된 경우 별도로 계산 된 일치 값의 결과가 모두 일치해야합니다. 그렇다면 YAML 문서로 표시되는 해시 참조는 현재 배포의 기본 설정 구조로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="da05e2a6f3037e503e2698db0f33736532af13ae" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="463724a0fef86ec9bcf7097a4a23f19c350c87fd" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder. However, since initialization of state variables in such lists is currently not possible this would serve no purpose.</source>
          <target state="translated">둘 이상의 변수가 나열되면 목록을 괄호로 묶어야합니다. 괄호로 묶인 목록을 사용하면 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 더미 자리 표시 자로 사용할 수 있습니다. 그러나 이러한 목록에서 상태 변수를 초기화하는 것은 현재 불가능하기 때문에 이것은 아무 소용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5915108dabbdb47d0e6487842fce0264a4b8c92e" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다. 괄호로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용할 수 있습니다. 그러나 목록 컨텍스트에서 상태 변수를 초기화하는 것은 현재 불가능하므로 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="13f0dd65ec56750a188884a636ba7b4f0428367d" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다. 괄호로 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용할 수 있습니다. 그러나 목록 컨텍스트에서 상태 변수를 초기화하는 것은 현재 불가능하므로 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc246b70384e8a417eb59e4e6e4575312d9d1e0a" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 에 둘 이상의 변수 또는 표현식이 제공되면 괄호 안에 넣어야합니다. 이 연산자는 해당 변수의 현재 값을 인수 목록의 숨겨진 스택에 저장하고 블록, 서브 루틴 또는 평가 종료시 복원합니다. 이것은 호출 된 서브 루틴이 로컬 변수를 참조 할 수 있지만 글로벌 변수는 참조 할 수 없음을 의미합니다. 원하는 경우 인수 목록을 할당하여 지역 변수를 초기화 할 수 있습니다. (특정 변수에 대해 초기화자가 제공되지 않으면 정의되지 않은 값으로 작성됩니다.)</target>
        </trans-unit>
        <trans-unit id="085c88b116674b900e024434a6a7c1e9689729b6" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;local&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">둘 이상의 변수 또는 표현식이 &lt;code&gt;local&lt;/code&gt; 에 제공되는 경우 괄호로 묶어야합니다. 이 연산자는 해당 변수의 현재 값을 숨겨진 스택의 인수 목록에 저장하고 블록, 서브 루틴 또는 평가를 종료 할 때 복원하는 방식으로 작동합니다. 이것은 호출 된 서브 루틴이 지역 변수를 참조 할 수도 있지만 전역 변수는 참조 할 수 없음을 의미합니다. 원하는 경우 인수 목록을 할당하여 로컬 변수를 초기화 할 수 있습니다. (특정 변수에 대해 이니셜 라이저가 제공되지 않으면 정의되지 않은 값으로 생성됩니다.)</target>
        </trans-unit>
        <trans-unit id="e6e3db41fbfcf6140e9c02e059dd4c934fd6f5ad" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name then the $+{NAME} will refer to the leftmost defined group in the match.</source>
          <target state="translated">여러 개의 고유 캡처 그룹이 동일한 이름을 갖는 경우 $ + {NAME}은 일치하는 가장 왼쪽에 정의 된 그룹을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="585d6ab5fb9075615690fae06a03a5a68fb5033a" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="translated">여러 개별 캡처 그룹의 이름이 동일한 경우 &lt;code&gt;$+{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 은 일치에서 가장 왼쪽에 정의 된 그룹을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="ba43723459a9559595b0c9aa2500eb340a4dc46e" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{NAME}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="translated">여러 개별 캡처 그룹의 이름이 동일한 경우 &lt;code&gt;$+{NAME}&lt;/code&gt; 은 일치에서 가장 왼쪽에 정의 된 그룹을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0bfee97a70420feb4c2945973c34123d251dd9c2" translate="yes" xml:space="preserve">
          <source>If multiple files from one program are desired an array ref can be used.</source>
          <target state="translated">한 프로그램의 여러 파일이 필요한 경우 배열 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081ad6caef0052cfab1aad2ae1061ca747e43248" translate="yes" xml:space="preserve">
          <source>If multiple transliterations are given for a character, only the first one is used:</source>
          <target state="translated">한 문자에 여러 음역이 제공되면 첫 번째 음역 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c414b75ce1c860047ef0a566364396ec60b38e43" translate="yes" xml:space="preserve">
          <source>If my tests take too long to run I may be able to speed them up by running multiple test scripts in parallel. This is particularly effective if the tests are I/O bound or if I have multiple CPU cores. I tell prove to run my tests in parallel like this:</source>
          <target state="translated">테스트를 실행하는 데 너무 오래 걸리면 여러 테스트 스크립트를 병렬로 실행하여 테스트 속도를 높일 수 있습니다. 이는 테스트가 I / O 바운드이거나 여러 CPU 코어가있는 경우 특히 효과적입니다. 다음과 같이 테스트를 병렬로 실행하는 것을 증명합니다.</target>
        </trans-unit>
        <trans-unit id="766c6735ff098a4b925a773897fe49012fa4895d" translate="yes" xml:space="preserve">
          <source>If name passed in doesn't specify a readable file, appends</source>
          <target state="translated">전달 된 이름이 읽을 수있는 파일을 지정하지 않으면 추가</target>
        </trans-unit>
        <trans-unit id="1afec739c7f1e924deac0edbd4a6af96f74019ce" translate="yes" xml:space="preserve">
          <source>If necessary switch the input stream to handle unicode. This only has any effect for I/O handle based streams.</source>
          <target state="translated">필요한 경우 입력 스트림을 전환하여 유니 코드를 처리하십시오. 이것은 I / O 핸들 기반 스트림에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="1f88753647459114bf0fff92153d71fa3be1ef0c" translate="yes" xml:space="preserve">
          <source>If needed, &lt;code&gt;$new_size&lt;/code&gt; will be rounded up to the next multiple of the memory page size (usually 4096 or 8192).</source>
          <target state="translated">필요한 경우 &lt;code&gt;$new_size&lt;/code&gt; 는 메모리 페이지 크기의 다음 배수 (일반적으로 4096 또는 8192)로 올림됩니다.</target>
        </trans-unit>
        <trans-unit id="13ffb9e8f4aa9a45a3175ee9916b5d80efc23ef5" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . This will cause the thread to return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">필요한 경우 언제든지 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 호출하여 스레드를 종료 할 수 있습니다 . 이것은 스레드가 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 하거나 목록 컨텍스트에서 빈 목록 을 리턴하게 합니다.</target>
        </trans-unit>
        <trans-unit id="7fa85a1effefc4c0579975cf6db618b5a32a7f98" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. This will cause the thread to return &lt;code&gt;undef&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">필요한 경우 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 호출하여 언제든지 스레드를 종료 할 수 있습니다 . 이로 인해 스레드 는 스칼라 컨텍스트에서 &lt;code&gt;undef&lt;/code&gt; 를 반환 하거나 목록 컨텍스트에서 빈 목록 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4f2509d5dd63a76d44f087cc7f42f7f77c757a" translate="yes" xml:space="preserve">
          <source>If needed, scripts can be written so as to run on both threaded and non-threaded Perls:</source>
          <target state="translated">필요한 경우 스레드 및 스레드가 아닌 Perls에서 실행되도록 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91fbdba912e7cde9b89fa3cefbc9b3e7d8d65343" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">필요한 경우 이러한 메소드는 &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; 또는 &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속하는 패키지로 정의해야합니다 . &lt;code&gt;SCALAR&lt;/code&gt; 가 존재하지 않을 때 어떤 일이 발생하는지 알아 보려면 &lt;a href=&quot;../perltie#SCALAR&quot;&gt;perltie의 SCALAR를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7be13126ea530b0bd8ee259471daa2d8234b8a5" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;perltie#SCALAR&quot;&gt;&quot;SCALAR&quot; in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">필요한 경우 이러한 메서드는 &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; 또는 &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속 된 패키지에 의해 정의되어야합니다 . &lt;code&gt;SCALAR&lt;/code&gt; 가 존재하지 않을 때 어떤 일이 발생하는지 알아 보려면 &lt;a href=&quot;perltie#SCALAR&quot;&gt;perltie의 &quot;SCALAR&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7a52a7ddea6d450e656d921a0db2fecb1485c60" translate="yes" xml:space="preserve">
          <source>If needed, thread warnings can be suppressed by using:</source>
          <target state="translated">필요한 경우 다음을 사용하여 스레드 경고를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aac81b2bba7d90df4570fdaec9abe8879fce464" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Family&lt;/code&gt; nor any hosts or addresses are passed, nor any &lt;code&gt;*AddrInfo&lt;/code&gt;, then the constructor has no information on which to decide a socket family to create. In this case, it performs a &lt;code&gt;getaddinfo&lt;/code&gt; call with the &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; flag, no host name, and a service name of &lt;code&gt;&quot;0&quot;&lt;/code&gt;, and uses the family of the first returned result.</source>
          <target state="translated">어느 경우 &lt;code&gt;Family&lt;/code&gt; 이나 어떤 호스트 또는 주소가 전달 않으며, 어떤 &lt;code&gt;*AddrInfo&lt;/code&gt; 다음 생성자는 소켓 가족이 만드는 결정하는 아무런 정보가 없습니다. 이 경우 &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; 플래그, 호스트 이름 없음, 서비스 이름 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 으로 &lt;code&gt;getaddinfo&lt;/code&gt; 호출을 수행 하고 첫 번째 반환 된 결과의 계열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1d589a6c51332c7705521b2b0ef94169fba9785" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Type&lt;/code&gt; nor &lt;code&gt;Proto&lt;/code&gt; hints are provided, a default of &lt;code&gt;SOCK_STREAM&lt;/code&gt; and &lt;code&gt;IPPROTO_TCP&lt;/code&gt; respectively will be set, to maintain compatibility with &lt;code&gt;IO::Socket::INET&lt;/code&gt;. Other named arguments that are not recognised are ignored.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 또는 &lt;code&gt;Proto&lt;/code&gt; 힌트가 제공 되지 않으면 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 과의 호환성을 유지하기 위해 기본값 인 &lt;code&gt;SOCK_STREAM&lt;/code&gt; 및 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; 가 각각 설정됩니다 . 인식되지 않는 다른 명명 된 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="620d906a2e9dd53f3e33bb69b96c36a7f678920a" translate="yes" xml:space="preserve">
          <source>If neither of those work, then you can't use adb to cross-compile to your device. Either try rooting it, or go for the ssh route.</source>
          <target state="translated">둘 다 작동하지 않으면 adb를 사용하여 장치로 크로스 컴파일 할 수 없습니다. 루팅을 시도하거나 ssh 경로로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="7b8270c68932b39381b724db912d7e0064edb351" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;-L&lt;/code&gt; or &lt;code&gt;-l&lt;/code&gt; prefix is present in an entry, the entry is considered a directory to search if it is in fact a directory, and a library to search for otherwise. The &lt;code&gt;$Config{lib_ext}&lt;/code&gt; suffix will be appended to any entries that are not directories and don't already have the suffix.</source>
          <target state="translated">항목에 &lt;code&gt;-L&lt;/code&gt; 또는 &lt;code&gt;-l&lt;/code&gt; 접두어가 없으면 항목은 실제로 디렉토리 인 경우 검색 할 디렉토리로, 그렇지 않으면 검색 할 라이브러리로 간주됩니다. &lt;code&gt;$Config{lib_ext}&lt;/code&gt; 접미사가없는 디렉토리이며, 이미 접미사가없는 모든 항목에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2d1c5c51b75ebf17552d122abb9f110644200dac" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;G_METHOD&lt;/code&gt; nor &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, the SV may be any of a CV, a GV, a reference to a CV, a reference to a GV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the sub to call.</source>
          <target state="translated">어느 경우 &lt;code&gt;G_METHOD&lt;/code&gt; 도 &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; 플래그가 공급되면, SV는 CV 중 임의의 것일 수있다하는 GV하는 CV 참조하는 GV 또는 참조 &lt;code&gt;SvPV(sv)&lt;/code&gt; 호출 서브 이름으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="33d1d1804f2f0f5f5a1b0fb679650c8cfecd87fb" translate="yes" xml:space="preserve">
          <source>If neither the exit status nor the verbose level is specified, then the default is to use an exit status of 2 with a verbose level of 0.</source>
          <target state="translated">종료 상태와 상세 레벨이 모두 지정되지 않은 경우 기본값은 상세 레벨이 0 인 종료 상태 2를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca010fd55b822b0537501828b1432d2b69dedb67" translate="yes" xml:space="preserve">
          <source>If neither your configured &lt;code&gt;yaml_module&lt;/code&gt; nor YAML.pm is installed, CPAN.pm falls back to using Data::Dumper and Storable and looks for files with the extensions &lt;code&gt;.dd&lt;/code&gt; or &lt;code&gt;.st&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; directory. These files are expected to contain one or more hashrefs. For Data::Dumper generated files, this is expected to be done with by defining &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; , etc. The YAML shell would produce these with the command</source>
          <target state="translated">구성된 &lt;code&gt;yaml_module&lt;/code&gt; 과 YAML.pm이 모두 설치되어 있지 않으면 CPAN.pm은 Data :: Dumper 및 Storable을 사용하여 폴백하여 &lt;code&gt;.dd&lt;/code&gt; 또는 &lt;code&gt;.st&lt;/code&gt; 확장자를 가진 파일을 &lt;code&gt;prefs_dir&lt;/code&gt; 디렉토리 에서 찾습니다 . 이 파일은 하나 이상의 해시 참조를 포함해야합니다. Data :: Dumper 생성 파일의 경우 &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; 등 을 정의 하여이 작업을 수행 할 수 있습니다 . YAML 쉘은 명령을 사용하여이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1ff3f3f68e857a065a27224d0e20ede58778f1ae" translate="yes" xml:space="preserve">
          <source>If new() is called as an instance method (i.e. $ctx-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case, and the return value is the reference to the object (i.e. $ctx).</source>
          <target state="translated">new ()가 인스턴스 메소드 (즉, $ ctx-&amp;gt; new)로 호출되면 객체의 상태를 새로 작성된 객체의 상태로 재설정하기 만합니다. 이 경우 새 객체가 만들어지지 않으며 반환 값은 객체에 대한 참조입니다 (예 : $ ctx).</target>
        </trans-unit>
        <trans-unit id="2e13ee0a65adecfa0d8e7d8968c5c8fbe048cddb" translate="yes" xml:space="preserve">
          <source>If no $default is provided an empty string will be used instead.</source>
          <target state="translated">$ default가 제공되지 않으면 빈 문자열이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0472c17854436e8327aa450d7bb9d0ca29c0fa4c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$VERSION&lt;/code&gt; was specified on the &lt;code&gt;bootstrap&lt;/code&gt; line, the last line becomes</source>
          <target state="translated">&lt;code&gt;bootstrap&lt;/code&gt; 줄 에 &lt;code&gt;$VERSION&lt;/code&gt; 이 지정 되지 않은 경우 마지막 줄은</target>
        </trans-unit>
        <trans-unit id="1b4091cfd69b61e159053e0bbc2425f479136432" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$section_spec&lt;/code&gt; arguments are given, then the existing set of selected sections is cleared out (which means &lt;code&gt;all&lt;/code&gt; sections will be processed).</source>
          <target state="translated">&lt;code&gt;$section_spec&lt;/code&gt; 인수가 제공 되지 않으면 기존의 선택된 섹션 세트가 지워집니다 ( &lt;code&gt;all&lt;/code&gt; 섹션이 처리됨 을 의미 함 ).</target>
        </trans-unit>
        <trans-unit id="c0be16a9153a991182a683ab2886f1fa902dd9f4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; , the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 이 없고 마지막 명령문이 표현식 인 경우 해당 값이 리턴됩니다. 마지막 명령문이 &lt;code&gt;foreach&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 과 같은 루프 제어 구조 인 경우 리턴 된 값은 지정되지 않습니다. 빈 하위는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97d668cbdc526d3cbea7edc6414a728eb26feaf0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;return&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt;, the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 이 없고 마지막 문이 표현식이면 해당 값이 반환됩니다. 마지막 문이 &lt;code&gt;foreach&lt;/code&gt; 또는 a &lt;code&gt;while&lt;/code&gt; 과 같은 루프 제어 구조 인 경우 반환 된 값은 지정되지 않습니다. 빈 하위는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf9cd2f55bd05fa55b1648853a5a5e34325f19ca" translate="yes" xml:space="preserve">
          <source>If no @args are given, no @cmds will be returned.</source>
          <target state="translated">@args를 지정하지 않으면 @cmds가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d11be4d28581ad6cd28ff2cca82d45474710696d" translate="yes" xml:space="preserve">
          <source>If no MANIFEST.SKIP file is found, a default set of skips will be used, similar to the example above. If you want nothing skipped, simply make an empty MANIFEST.SKIP file.</source>
          <target state="translated">MANIFEST.SKIP 파일이 없으면 위의 예와 유사한 기본 건너 뛰기 세트가 사용됩니다. 건너 뛰지 않으려면 비어있는 MANIFEST.SKIP 파일을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="482e18ae3dbe759dbfcebf52b00cc2a6c84ee16a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the highest possible setting will be used, which is rarely useful.</source>
          <target state="translated">인수가 제공되지 않으면 가능한 가장 높은 설정이 사용되며 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fc9afdb8826971e1f36212e96bd04623eb38e92" translate="yes" xml:space="preserve">
          <source>If no argument is given, the limit check will be deactivated (same as when &lt;code&gt;0&lt;/code&gt; is specified).</source>
          <target state="translated">인수가 제공되지 않으면 한계 검사가 비활성화됩니다 ( &lt;code&gt;0&lt;/code&gt; 이 지정된 경우와 동일 ).</target>
        </trans-unit>
        <trans-unit id="cae10c8870eae9f10da944c7a01e813768cc713b" translate="yes" xml:space="preserve">
          <source>If no arguments are given to pod2man it will read from @ARGV.</source>
          <target state="translated">pod2man에 인수가 없으면 @ARGV에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="87c6b87283ba7c4ecec068cb48f3ae13420b59ed" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">인수가 제공되지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 는 전체 형식의 아카이브를 문자열로 반환하므로 아카이브를 소켓이나 gzip 등의 파이프에 넣을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0ab20efd7be2867edc836fd9f4e9fd1df47b1ae4" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;write&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">인수가 제공되지 않으면 &lt;code&gt;write&lt;/code&gt; 는 형식화 된 전체 아카이브를 문자열로 반환합니다. 이는 아카이브를 소켓에 넣거나 gzip에 대한 파이프 등으로 채우려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886a141165f04df6d6f369bc4c3d2d482bb6efce" translate="yes" xml:space="preserve">
          <source>If no arguments are passed then the current article in the currently selected newsgroup is fetched.</source>
          <target state="translated">인수가 전달되지 않으면 현재 선택된 뉴스 그룹의 현재 기사가 페치됩니다.</target>
        </trans-unit>
        <trans-unit id="1361c81765e284924a4726230ee621f378f42412" translate="yes" xml:space="preserve">
          <source>If no error occurs, &lt;code&gt;eval&lt;/code&gt; sets &lt;code&gt;$@&lt;/code&gt; to the empty string.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;eval&lt;/code&gt; 은 &lt;code&gt;$@&lt;/code&gt; 를 빈 문자열로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="ddc296f09027fdaaecb023b3cebc4e9cba37abbb" translate="yes" xml:space="preserve">
          <source>If no extension is supplied, and your system supports it, the original</source>
          <target state="translated">확장이 제공되지 않고 시스템에서 확장을 지원하는 경우 원래</target>
        </trans-unit>
        <trans-unit id="85c571c913f7bfa21e872b065c24a094b4bb7659" translate="yes" xml:space="preserve">
          <source>If no files or directories are supplied, &lt;code&gt;prove&lt;/code&gt; looks for all files matching the pattern &lt;code&gt;t/*.t&lt;/code&gt;.</source>
          <target state="translated">파일이나 디렉토리가 제공되지 않은 경우 &lt;code&gt;prove&lt;/code&gt; 는 패턴 &lt;code&gt;t/*.t&lt;/code&gt; 와 일치하는 모든 파일을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a4c68647b34bca31278b9d9c157de53c4f611c93" translate="yes" xml:space="preserve">
          <source>If no flags argument is give then &lt;code&gt;GLOB_CSH&lt;/code&gt; is set, and on VMS and Windows systems, &lt;code&gt;GLOB_NOCASE&lt;/code&gt; too. Otherwise the flags to use are determined solely by the flags argument. The POSIX defined flags are:</source>
          <target state="translated">flags 인수가 제공되지 않으면 &lt;code&gt;GLOB_CSH&lt;/code&gt; 가 설정되고 VMS 및 Windows 시스템에서도 &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 가 설정 됩니다. 그렇지 않으면 사용할 플래그는 flags 인수에 의해서만 결정됩니다. POSIX 정의 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cea57f19921408109bb2fb4d00e16350d27b4844" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible VMS-specific features are assumed. Currently, there are four VMS-specific features available: 'status' (a.k.a '$?'), 'exit', 'time' and 'hushed'.</source>
          <target state="translated">가져 오기 목록이 제공되지 않으면 가능한 모든 VMS 관련 기능이 가정됩니다. 현재 '상태'(일명 '$?'), '종료', '시간'및 '허시'와 같은 4 가지 VMS 관련 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ceff2a6aadec6052244b97bba7012539a0b105" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible restrictions are assumed. (This is the safest mode to operate in, but is sometimes too strict for casual programming.) Currently, there are three possible things to be strict about: &quot;subs&quot;, &quot;vars&quot;, and &quot;refs&quot;.</source>
          <target state="translated">가져 오기 목록이 제공되지 않으면 가능한 모든 제한 사항이 가정됩니다. (이는 운영하기에 가장 안전한 모드이지만 때로는 일상적인 프로그래밍에는 너무 엄격합니다.) 현재 &quot;subs&quot;, &quot;vars&quot;및 &quot;refs&quot;에 대해 엄격하게 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6512b9a9d5a5a9bf4112bcb1e3a393263f0b9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 인덱스에 항목이없는 경우 (즉, 큐가 비어 있거나 인덱스가 큐의 항목 수를 초과하는 경우) &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78d629698ed39f1b937dab840c0e7631f8015fc9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 인덱스에 항목이 없으면 (즉, 큐가 비어 있거나 인덱스가 큐의 항목 수를 초과하는 경우) &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9e3e2a819c8fb3d75385fda77f033e08dfb423" translate="yes" xml:space="preserve">
          <source>If no options are given, Pod::Man uses the name of the input file with any trailing &lt;code&gt;.pod&lt;/code&gt;, &lt;code&gt;.pm&lt;/code&gt;, or &lt;code&gt;.pl&lt;/code&gt; stripped as the man page title, to section 1 unless the file ended in &lt;code&gt;.pm&lt;/code&gt; in which case it defaults to section 3, to a centered title of &quot;User Contributed Perl Documentation&quot;, to a centered footer of the Perl version it is run with, and to a left-hand footer of the modification date of its input (or the current date if given &lt;code&gt;STDIN&lt;/code&gt; for input).</source>
          <target state="translated">옵션이 제공되지 않으면 Pod :: Man은 파일이 &lt;code&gt;.pm&lt;/code&gt; 으로 끝나지 않는 한 맨 페이지 제목으로 후행 &lt;code&gt;.pod&lt;/code&gt; , &lt;code&gt;.pm&lt;/code&gt; 또는 &lt;code&gt;.pl&lt;/code&gt; 이있는 입력 파일 이름 을 섹션 1에 사용 합니다. 기본적으로 섹션 3, &quot;사용자 제공 Perl 문서&quot;의 중심 제목, 함께 실행되는 Perl 버전의 중심 바닥 글 및 입력 수정 날짜의 왼쪽 바닥 글 (또는 현재 날짜 인 경우) 주어진 &lt;code&gt;STDIN&lt;/code&gt; 입력).</target>
        </trans-unit>
        <trans-unit id="1f1608fb3d0f72aad27d7541f9de6e52f802b4ee" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt; , the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your</source>
          <target state="translated">두 번째 인수가 제공되지 않고 카테고리가 &lt;code&gt;LC_ALL&lt;/code&gt; 인 경우 결과는 구현에 따라 다릅니다. 연결된 로캘 이름의 문자열 (구분자도 구현에 따라 다름) 또는 단일 로캘 이름 일 수 있습니다. 상담하십시오</target>
        </trans-unit>
        <trans-unit id="267c1696e15f2baca20bbece162193151736f0bb" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt;, the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your &lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale(3)&lt;/a&gt; man page for details.</source>
          <target state="translated">두 번째 인수가 제공되지 않고 카테고리가 &lt;code&gt;LC_ALL&lt;/code&gt; 인 경우 결과는 구현에 따라 다릅니다. 연결된 로케일 이름 (구분자도 구현에 따라 다름)의 문자열이거나 단일 로케일 이름 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale (3)&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ed489574b7ebc8c696d017fb9515c4a591232a34" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt; , the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">두 번째 인수가 제공되지 않고 카테고리가 &lt;code&gt;LC_ALL&lt;/code&gt; 이외의 다른 경우 함수는 카테고리의 현재 로케일을 명명하는 문자열을 리턴합니다. 당신은에 대한 후속 호출에서 두 번째 인수로이 값을 사용할 수 있습니다 &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;하지만&lt;/b&gt; 일부 플랫폼에서 문자열은 대부분의 사람들이 무엇을 의미하는지 로케일로 해독 할 수있을 것이라고 불투명하지 무언가이다.</target>
        </trans-unit>
        <trans-unit id="64041fec58a65d66b2f703a3782bbd84be6d1203" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt;, the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt;, &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">두 번째 인수가 제공되지 않고 카테고리가 &lt;code&gt;LC_ALL&lt;/code&gt; 이 아닌 경우 함수는 카테고리의 현재 로케일 이름을 지정하는 문자열을 리턴합니다. 당신은에 대한 후속 호출에서 두 번째 인수로이 값을 사용할 수 있습니다 &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;하지만&lt;/b&gt; 일부 플랫폼에서 문자열은 대부분의 사람들이 무엇을 의미하는지 로케일로 해독 할 수있을 것이라고 불투명하지 무언가이다.</target>
        </trans-unit>
        <trans-unit id="53385049e198591f3af9c0f621b19586d0e6e03c" translate="yes" xml:space="preserve">
          <source>If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; variable is searched and modified. Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified must be a scalar variable, an array element, a hash element, or an assignment to one of those; that is, some sort of scalar lvalue.</source>
          <target state="translated">&lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 연산자 를 통해 문자열을 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 변수가 검색되고 수정됩니다. &lt;code&gt;/r&lt;/code&gt; 옵션을 사용 하지 않으면 지정된 문자열은 스칼라 변수, 배열 요소, 해시 요소 또는 그 중 하나에 대한 지정이어야합니다. 즉, 일종의 스칼라 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="9ee4d303ec9de35b4bd6b8caf1f726ddd4ca7c6e" translate="yes" xml:space="preserve">
          <source>If no such Pod file is found, this method returns undef.</source>
          <target state="translated">이러한 포드 파일이 없으면이 메소드는 undef를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="34cd3d77c3969309ab95d1d80fe464b5d299344d" translate="yes" xml:space="preserve">
          <source>If no urllist has been chosen yet, would you prefer CPAN.pm to connect to the built-in default sites without asking? (yes/no)?</source>
          <target state="translated">아직 urllist를 선택하지 않은 경우, CPAN.pm이 묻지 않고 내장 된 기본 사이트에 연결하도록 하시겠습니까? (예 아니오)?</target>
        </trans-unit>
        <trans-unit id="b1457b54499e074ed5ffc48ffd57a11b298ba627" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed.</source>
          <target state="translated">속성과 연관된 값이 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9e6ead3ce8c862f9ee6e9b2af0ca9c9d3945d613" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;undef&lt;/code&gt; is passed.</source>
          <target state="translated">속성과 연관된 값이 없으면 &lt;code&gt;undef&lt;/code&gt; 가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf2ca53d71d01f547a112c6b13519e5e34d198d" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;a href=&quot;#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">비어 있지 않은 중괄호가 &lt;a href=&quot;#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; 에&lt;/a&gt; 사용되는 유일한 와일드 카드 문자 인 경우 일치하는 파일 이름이 없지만 잠재적으로 많은 문자열이 반환됩니다. 예를 들어 다음은 과일과 색상의 각 쌍에 대해 하나씩 9 개의 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3641612d3261f449a8b25c55086ede32d34dbbcb" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">비어 있지 않은 중괄호가 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 에 사용 된 유일한 와일드 카드 문자 인 경우 파일 이름이 일치하지 않지만 많은 문자열이 반환 될 수 있습니다. 예를 들어, 과일과 색상의 각 쌍마다 하나씩 9 개의 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1328c99f7fc26be401ecc4c3daf8d11e272b065b" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">비어 있지 않은 중괄호가 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 에 사용 된 유일한 와일드 카드 문자 인 경우 파일 이름이 일치하지 않지만 많은 문자열이 반환 될 수 있습니다. 예를 들어, 과일과 색상의 각 쌍마다 하나씩 9 개의 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cf3289643abb0e0247bc66bf82c16e180f16eb54" translate="yes" xml:space="preserve">
          <source>If none of the above apply, for backwards compatibility reasons, the &lt;code&gt;/d&lt;/code&gt; modifier is the one in effect by default. As this can lead to unexpected results, it is best to specify which other rule set should be used.</source>
          <target state="translated">위의 어느 것도 적용되지 않으면 이전 버전과의 호환성을 위해 &lt;code&gt;/d&lt;/code&gt; 수정자가 기본적으로 적용됩니다. 예기치 않은 결과가 발생할 수 있으므로 사용해야 할 다른 규칙 집합을 지정하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c4f8a0262880dda1d52bfe8a37ad85562f38ba99" translate="yes" xml:space="preserve">
          <source>If none of the settings are enabled or the respective methods are missing, &lt;code&gt;JSON::PP&lt;/code&gt; throws an exception.</source>
          <target state="translated">활성화 된 설정이 없거나 각 메서드가 누락 된 경우 &lt;code&gt;JSON::PP&lt;/code&gt; 에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ca7c7d8696c46f8858c11c99d7d1a93c5e34454b" translate="yes" xml:space="preserve">
          <source>If none of the three command line flags (&lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt;) that control warnings is used and neither &lt;code&gt;$^W&lt;/code&gt; nor the &lt;code&gt;warnings&lt;/code&gt; pragma are used, then default warnings will be enabled and optional warnings disabled. This means that legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">경고를 제어 하는 세 개의 명령 행 플래그 ( &lt;b&gt;-w&lt;/b&gt; , &lt;b&gt;-W&lt;/b&gt; 또는 &lt;b&gt;-X&lt;/b&gt; )가 사용되지 않고 &lt;code&gt;$^W&lt;/code&gt; 또는 &lt;code&gt;warnings&lt;/code&gt; pragma가 사용 되지 않으면 기본 경고가 사용 가능하고 선택적 경고가 사용 불가능합니다. 즉, 경고를 제어하지 않는 레거시 코드는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3318e55dc39962c8bcf2ab6429b4489bcf36fce0" translate="yes" xml:space="preserve">
          <source>If none of those language-tags leads to loadable classes, we then try classes derived from YourProjClass-&amp;gt;fallback_languages() and then if nothing comes of that, we use classes named by YourProjClass-&amp;gt;fallback_language_classes(). Then in the (probably quite unlikely) event that that fails, we just return undef.</source>
          <target state="translated">해당 언어 태그 중 어느 것도로드 가능한 클래스로 연결되지 않으면 YourProjClass-&amp;gt; fallback_languages ​​()에서 파생 된 클래스를 시도한 다음 그 중 아무것도 없으면 YourProjClass-&amp;gt; fallback_language_classes ()로 명명 된 클래스를 사용합니다. 그런 다음 실패 할 가능성이 높은 이벤트에서 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92205bb5b979576b7a4566bdd880e8993ef8accb" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section</source>
          <target state="translated">0이 아닌 경우 서브 루틴이 리턴 한 항목 수입니다. 이러한 항목은 Perl 스택에 저장됩니다. 그 부분</target>
        </trans-unit>
        <trans-unit id="59c73f98889212850b2a78b85e24e752ffbdf926" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;Returning a List of Values&quot;&lt;/a&gt; gives an example of using the G_ARRAY flag and the mechanics of accessing the returned items from the Perl stack.</source>
          <target state="translated">0이 아니면 서브 루틴이 반환 한 항목 수를 계산합니다. 이러한 항목은 Perl 스택에 저장됩니다. &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;값 목록 반환&quot;&lt;/a&gt; 섹션에서는 G_ARRAY 플래그를 사용하는 예와 Perl 스택에서 반환 된 항목에 액세스하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="15089e00b79e7ab36a4d99102807c33fe5f2fa61" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">스레드 공유가 아닌 경우 다른 복잡한 데이터 유형은 큐에 배치되기 전에 스레드 공유 구조 로 복제됩니다 (필요한 경우 재귀 적으로, &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 및 읽기 전용 설정 포함).</target>
        </trans-unit>
        <trans-unit id="bd2af9d148c476fa264b6faed90957e58a463b95" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;bless&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">아직 스레드 공유가 아닌 경우 다른 복잡한 데이터 유형은 큐에 배치되기 전에 스레드 공유 구조 로 복제됩니다 (필요한 경우 반복적으로, &lt;code&gt;bless&lt;/code&gt; 및 읽기 전용 설정 포함).</target>
        </trans-unit>
        <trans-unit id="68037dc7029dc4e3c365e1435ac66af09bfe7401" translate="yes" xml:space="preserve">
          <source>If not defined, the socket option will not be changed, and default value set by the operating system will apply. For repeatable behaviour across platforms it is recommended this value always be defined for listening-mode sockets.</source>
          <target state="translated">정의되지 않은 경우 소켓 옵션은 변경되지 않으며 운영 체제에서 설정 한 기본값이 적용됩니다. 플랫폼 간 반복 가능한 동작의 경우이 값은 항상 청취 모드 소켓에 대해 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e6242ea32a785a3ff0172e42255ea915052f271" translate="yes" xml:space="preserve">
          <source>If not explicitly stated, the thread's context is implied from the context of the &lt;code&gt;-&amp;gt;create()&lt;/code&gt; call:</source>
          <target state="translated">명시 적으로 언급되지 않은 경우 스레드의 컨텍스트는 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 호출 의 컨텍스트에서 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="546f552a865a929b4eb67739806b6d1165a21c9a" translate="yes" xml:space="preserve">
          <source>If not present or if it returns false, then the stream is left with the UTF-8 flag clear. The</source>
          <target state="translated">존재하지 않거나 false를 리턴하면 UTF-8 플래그가 지워진 상태로 스트림이 남습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2aa39c0e8f5ce84edfe0042135e7b88219cc53b5" translate="yes" xml:space="preserve">
          <source>If not specified, this parameter defaults to the OS code of the Operating System this module was built on. The value 3 is used as a catch-all for all Unix variants and unknown Operating Systems.</source>
          <target state="translated">지정되지 않은 경우이 매개 변수의 기본값은이 모듈이 작성된 운영 체제의 OS 코드입니다. 값 3은 모든 Unix 변형 및 알려지지 않은 운영 체제에 대한 포괄적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5be9107047108eada41300dc934c5b436deb60f0" translate="yes" xml:space="preserve">
          <source>If not successful &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">실패하면 &lt;code&gt;$status&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="aff9c9f30e8137171bc8ec7e751402e0d4e840fb" translate="yes" xml:space="preserve">
          <source>If not successful, &lt;code&gt;$i&lt;/code&gt; will be</source>
          <target state="translated">성공하지 못하면 &lt;code&gt;$i&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b50aafa5c3c8fb148f77f7f985f1a7044430dc1d" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">성공하지 못한 경우 반환 된 압축 개체 &lt;code&gt;$z&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="12b14a0f96d5dc839995d0658014681616dce040" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="translated">성공하지 못하면 반환 된 압축 개체 &lt;code&gt;$z&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="e8abade20743149de14f55b6a98559ef8ef9d29a" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt; , will be</source>
          <target state="translated">성공하지 못한 경우 반환 된 수축 객체 &lt;code&gt;$d&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="a55077829587b52f718a05dd4622ff7cb59c31d0" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt;, will be</source>
          <target state="translated">성공하지 못하면 반환 된 디플레이션 개체 &lt;code&gt;$d&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="98576d6e30e44a960914f7dcf4587ee17092e2df" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt; ) will be</source>
          <target state="translated">성공하지 못하면 반환 된 수축 스트림 ( &lt;code&gt;$d&lt;/code&gt; )은</target>
        </trans-unit>
        <trans-unit id="31b0629650565b4db9feee16aed7f875e955eba9" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt;) will be</source>
          <target state="translated">성공하지 못하면 반환 된 디플레이션 스트림 ( &lt;code&gt;$d&lt;/code&gt; )은</target>
        </trans-unit>
        <trans-unit id="b7bd4ba1b78daba8a26ec4a9a7d4b9cf1b5da29e" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">성공하지 못한 경우 반환 된 압축 해제 객체 &lt;code&gt;$z&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="ff81451b912d52c5c65d903982a9c2e6578403e7" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="translated">성공하지 못하면 반환 된 압축 해제 개체 &lt;code&gt;$z&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c88e7dc3b6ede485e4fd5bdcc2d18ce257150ea" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the source is treated as ASCII + 128 extra controls, and identifiers should match</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 하지 않는 경우 utf8 소스는 ASCII + 128 추가 제어로 처리되며 식별자는 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6275358c6fb498ac9c62eac9a2037ee571ebd990" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;use utf8&lt;/code&gt;, the source is treated as ASCII + 128 extra generic characters, and identifiers should match</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 을 사용 하지 않는 경우 소스는 ASCII + 128 개의 추가 일반 문자로 처리되며 식별자가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="adf92a54eaec2aef254d98d2b3572cf157430f6f" translate="yes" xml:space="preserve">
          <source>If not, you can use a Fisher-Yates shuffle.</source>
          <target state="translated">그렇지 않은 경우 Fisher-Yates 셔플을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63aa47bb8d880da4c29744c1e2b5b0be9d2d8c10" translate="yes" xml:space="preserve">
          <source>If not, you may need to dig in the indices to find it in the directory of the current maintainer.</source>
          <target state="translated">그렇지 않은 경우 현재 관리자의 디렉토리에서 색인을 찾아서 색인을 찾아야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86c0e89f96b9aaaff68e6f577691cea5717917d9" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the description is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="translated">ob가 true이고 SV가 blessed이면 설명은 클래스 이름이고 그렇지 않으면 SV, &quot;SCALAR&quot;, &quot;ARRAY&quot;등의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="89bf684ef82a39d22f842daf13f965778d5ecf34" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the string is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="translated">ob가 true이고 SV가 blessed이면 문자열은 클래스 이름이고 그렇지 않으면 SV, &quot;SCALAR&quot;, &quot;ARRAY&quot;등의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e3dd66c8bbe90e184bf0c3b78ff920f066856ccf" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt; , triggering the previously described</source>
          <target state="translated">생략하면 PATTERN의 기본값은 단일 공간 &lt;code&gt;&quot; &quot;&lt;/code&gt; 으로 설정되어 앞에서 설명한대로 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="48ccc574ab641252333c06cf11483c32d32127b7" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt;, triggering the previously described</source>
          <target state="translated">생략하면 PATTERN은 기본적으로 단일 공백 &lt;code&gt;&quot; &quot;&lt;/code&gt; 으로 설정되어 이전에 설명한</target>
        </trans-unit>
        <trans-unit id="9db6f61ce06c88ac7402efe003ec5c4f69fd8d53" translate="yes" xml:space="preserve">
          <source>If omitted, the maximum is the 4th.</source>
          <target state="translated">생략하면 최대 값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="8cf02da092076b8bc64e89cb4d51247518c5d4fc" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt; , which will lead to an infinite loop.</source>
          <target state="translated">이 값을 인쇄하려고하면 오버로드 된 연산자 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 호출되고 &lt;code&gt;nomethod&lt;/code&gt; 연산자 가 호출 됩니다 . 이 연산자의 결과는 다시 문자열로 표시되지만이 결과는 다시 &lt;code&gt;symbolic&lt;/code&gt; 유형 이므로 무한 루프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9a4c46026548a387f73d613ce2e2d57e8735167" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt;, which will lead to an infinite loop.</source>
          <target state="translated">이 값을 인쇄하려고하면 오버로드 된 연산자 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 호출되어 &lt;code&gt;nomethod&lt;/code&gt; 연산자 를 호출 합니다. 이 연산자의 결과는 다시 문자열 화되지만이 결과는 다시 &lt;code&gt;symbolic&lt;/code&gt; 유형 이되어 무한 루프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e1adcb84ff8cdfac7bb94b3520eb9afd47061bae" translate="yes" xml:space="preserve">
          <source>If one can be sure that a particular program is a Perl script expecting filenames in @ARGV, the clever programmer can write something like this:</source>
          <target state="translated">특정 프로그램이 @ARGV에서 파일 이름을 예상하는 Perl 스크립트임을 확신 할 수 있다면, 영리한 프로그래머는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9a4785b4cb95e8fee7a09364380427defe0f204" translate="yes" xml:space="preserve">
          <source>If one is compiling Perl with the &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; the &lt;code&gt;dVAR&lt;/code&gt; definition is needed if the Perl global variables (see</source>
          <target state="translated">&lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; 를 사용 하여 Perl을 컴파일 하는 경우 Perl 전역 변수 인 경우 &lt;code&gt;dVAR&lt;/code&gt; 정의가 필요합니다 (참조</target>
        </trans-unit>
        <trans-unit id="e3e822ed5577ab52cc19452e08717fd8eeaeaafa" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt; , one can substitute the name of the length-argument by &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">C 함수에 대한 입력 인수 중 하나가 문자열 인수 &lt;code&gt;NAME&lt;/code&gt; 의 길이 인 경우 XSUB 선언에서 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 인수의 이름을 length (NAME) 로 대체 할 수 있습니다 . 생성 된 Perl 함수가 호출 될 때이 인수를 생략해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="9ecfea0dc1bd53f365a6275977cf6664ba11e8c2" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt;, one can substitute the name of the length-argument by &lt;code&gt;length(NAME)&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">C 함수에 대한 입력 인수 중 하나가 문자열 인수 &lt;code&gt;NAME&lt;/code&gt; 의 길이 인 경우 XSUB 선언에서 &lt;code&gt;length(NAME)&lt;/code&gt; 인수의 이름을 length (NAME) 로 대체 할 수 있습니다 . 이 인수는 생성 된 Perl 함수가 호출 될 때 생략되어야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="80356b3107601264757c736090081f30d00dbd0c" translate="yes" xml:space="preserve">
          <source>If one of the values is the string &quot;FATAL&quot;, then all the warnings in that list will be considered fatal, just as with the &lt;b&gt;warnings&lt;/b&gt; pragma itself. Should you need to specify that some warnings are fatal, and others are merely enabled, you can pass the &lt;b&gt;warnings&lt;/b&gt; parameter twice:</source>
          <target state="translated">값 중 하나가 문자열 &quot;FATAL&quot;인 경우 &lt;b&gt;경고&lt;/b&gt; 프라 그마 자체 와 마찬가지로 해당 목록의 모든 경고가 치명적인 것으로 간주 됩니다. 일부 경고는 치명적이며 다른 경고는 단순히 활성화되도록 지정해야하는 경우 &lt;b&gt;warnings&lt;/b&gt; 매개 변수를 두 번 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b3d6b8eb5c53fb4bf738ec026bd17996fb8d7b" translate="yes" xml:space="preserve">
          <source>If one wants to use pure Perl and to be compatible with Perl versions prior to 5.10, the general answer is to use &lt;code&gt;if-elsif-else&lt;/code&gt;:</source>
          <target state="translated">순수한 Perl을 사용하고 5.10 이전의 Perl 버전과 호환되기를 원한다면 일반적인 대답은 &lt;code&gt;if-elsif-else&lt;/code&gt; 를 사용 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4cca592d5a52d0591c75e10935311d781bcd5906" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">PATTERN 만 제공되는 경우 EXPR의 기본값은 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12b8235b34f1e041150a031d0b9fbd780bdea304" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">PATTERN 만 제공되는 경우 EXPR의 기본값은 &lt;code&gt;$_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b59bbcd014d4d50d7bf3779e9aa4f7e93178c1ba" translate="yes" xml:space="preserve">
          <source>If only a filename is available, the following approach may be used:</source>
          <target state="translated">파일 이름 만 사용할 수있는 경우 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b33dab707b9e6e2b41538d9f24bfd52b59d430" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also set &lt;code&gt;$uFlags&lt;/code&gt; to include &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="translated">명명 된 파이프의 클라이언트 측을 여는 경우 사용할 보안 서비스 품질을 지정하기 위해 다른 &lt;code&gt;SECURITY_*&lt;/code&gt; 상수 중 하나와 함께 &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; 를 포함하도록 &lt;code&gt;$uFlags&lt;/code&gt; 를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f62f719bae656eebb99613fc3c3f5af6bf3f5f" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also specify &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="translated">명명 된 파이프의 클라이언트 측을 여는 경우에, 당신은 또한 지정할 수 있습니다 &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; 을 다른 중 하나와 함께 &lt;code&gt;SECURITY_*&lt;/code&gt; 서비스의 보안 품질을 사용할 수 있도록 지정하는 상수.</target>
        </trans-unit>
        <trans-unit id="16392afc89510c0fc9dd7ff46ccb0d1b3e97fcef" translate="yes" xml:space="preserve">
          <source>If other charset support is needed, please file a bug report against CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend the support or maybe UTF-8 terminals become widely available.</source>
          <target state="translated">다른 문자 집합 지원이 필요한 경우 rt.cpan.org에 CPAN.pm에 대한 버그 보고서를 제출하고 요구 사항을 설명하십시오. 지원을 확장하거나 UTF-8 터미널을 널리 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a07176206cda4e320bb3d161ccf541de7489aeb9" translate="yes" xml:space="preserve">
          <source>If our include file had contained #include directives, these would not have been processed by h2xs. There is no good solution to this right now.</source>
          <target state="translated">포함 파일에 #include 지시문이 포함되어 있으면 h2xs에서 처리하지 않았을 것입니다. 현재로서는 이것에 대한 좋은 해결책이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1342cd54e96ee75c7832a17e50d7545968334b8a" translate="yes" xml:space="preserve">
          <source>If parse errors are found in the TAP output, a note of this will be made in the summary report. To see all of the parse errors, set this argument to true:</source>
          <target state="translated">TAP 출력에서 ​​구문 분석 오류가 발견되면이를 요약 보고서에 기록합니다. 모든 구문 분석 오류를 보려면이 인수를 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="390961095f8040e196a232b583180a54cb19ea61" translate="yes" xml:space="preserve">
          <source>If passed a filehandle will write a copy of all parsed TAP to that handle.</source>
          <target state="translated">파일 핸들이 전달되면 파싱 된 모든 TAP 사본을 해당 핸들에 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a4f883097b033ba66596455cc092c01c5e9be39" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt;, and then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">성능이 문제이고 출력이 입력과 같은 경우에 신경 쓰지 않으면 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 를 사용하여 데이터 내에서 가장 많이 사용되는 사례로 변환 하십시오 . 데이터가 주로 대문자 이외의 라틴어 1 인 경우 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt; 를 적용한 다음 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . 데이터가 주로 비 라틴어 1 인 경우 정렬 전에 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 . 데이터가 주로 대문자이고 Latin-1 문자를 포함하는 경우 다음을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="9462aa1810ea1a2dacbf899e5d319c5498156bac" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;tr///&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;tr/[a-z]/[A-Z]/&lt;/code&gt;, and then &lt;code&gt;sort()&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;tr/[A-Z]/[a-z]/&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">성능이 문제이고 출력이 입력과 동일한 케이스에 있는지 상관하지 않는 경우 &lt;code&gt;tr///&lt;/code&gt; 를 사용하여 데이터 내에서 가장 많이 사용되는 케이스로 변환 하십시오 . 데이터가 주로 라틴어가 아닌 대문자 인 경우 &lt;code&gt;tr/[a-z]/[A-Z]/&lt;/code&gt; 를 적용한 다음 &lt;code&gt;sort()&lt;/code&gt; . 데이터가 주로 Latin1이 아닌 소문자 인 경우 정렬하기 전에 &lt;code&gt;tr/[A-Z]/[a-z]/&lt;/code&gt; 를 적용하십시오 . 데이터가 주로 대문자이고 Latin-1 문자를 포함하는 경우 다음을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="751a8c8edea51ef360f8293f82ac9e36b697517a" translate="yes" xml:space="preserve">
          <source>If perl has been configured to not have the current directory in &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; by default, this variable can be set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; to reinstate it. It's primarily intended for use while building and testing modules that have not been updated to deal with &quot;.&quot; not being in &lt;code&gt;@INC&lt;/code&gt; and should not be set in the environment for day-to-day use.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;perlvar#%40INC&quot;&gt; &lt;code&gt;@INC&lt;/code&gt; &lt;/a&gt; 에 현재 디렉토리가 없도록 perl이 구성된 경우이 변수를 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 로 설정 하여 복원 할 수 있습니다. 주로 &quot;.&quot;를 처리하도록 업데이트되지 않은 모듈을 빌드하고 테스트하는 동안 사용하기위한 것입니다. 에없는 &lt;code&gt;@INC&lt;/code&gt; 및 일상적인 사용을위한 환경 설정되어서는 안된다.</target>
        </trans-unit>
        <trans-unit id="ab79de5389c6af407dc202c7877566f66fb7264b" translate="yes" xml:space="preserve">
          <source>If perl has not yet been installed then PERL_SRC can be defined on the command line as shown in the previous section.</source>
          <target state="translated">perl이 아직 설치되지 않은 경우 PERL_SRC는 이전 섹션에 표시된대로 명령 행에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527ed5a2bdcdb5849d3d992698d64bca35b1da28" translate="yes" xml:space="preserve">
          <source>If perl is invoked using the &lt;b&gt;-e&lt;/b&gt; option or the perl script is read from &lt;code&gt;STDIN&lt;/code&gt; then FindBin sets both &lt;code&gt;$Bin&lt;/code&gt; and &lt;code&gt;$RealBin&lt;/code&gt; to the current directory.</source>
          <target state="translated">&lt;b&gt;-e&lt;/b&gt; 옵션을 사용하여 perl을 호출 하거나 &lt;code&gt;STDIN&lt;/code&gt; 에서 perl 스크립트를 읽는 경우 &lt;code&gt;$RealBin&lt;/code&gt; 은 &lt;code&gt;$Bin&lt;/code&gt; 및 $ RealBin 을 모두 현재 디렉토리로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c28bb9f5b57ae9540614c1c058beb6e3302cae11" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see</source>
          <target state="translated">perl이 올바르게 설치되고 새도우 라이브러리가 올바르게 작성된 경우, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된 &lt;code&gt;getpw*()&lt;/code&gt; 함수는 이론적으로 새도우 비밀번호 파일의 항목에 대한 (읽기 전용) 액세스를 제공해야합니다. 파일을 변경하려면 새 섀도우 암호 파일을 만드십시오 (시스템마다 형식이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eba76bf8bea1221ff81d36866fefb38b38f1c83e" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd(1)&lt;/a&gt; for specifics) and use &lt;code&gt;pwd_mkdb(8)&lt;/code&gt; to install it (see &lt;a href=&quot;http://man.he.net/man8/pwd_mkdb&quot;&gt;pwd_mkdb(8)&lt;/a&gt; for more details).</source>
          <target state="translated">perl이 올바르게 설치되고 섀도우 라이브러리가 제대로 작성된 경우 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된 &lt;code&gt;getpw*()&lt;/code&gt; 함수는 이론적으로 섀도우 암호 파일의 항목에 대한 (읽기 전용) 액세스를 제공해야합니다. 파일을 변경하려면 새 섀도우 암호 파일을 만들고 (형식은 시스템마다 다릅니다. 자세한 내용은 &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd (1)&lt;/a&gt; 참조 ) &lt;code&gt;pwd_mkdb(8)&lt;/code&gt; 를 사용하여 설치합니다 (자세한 내용은 &lt;a href=&quot;http://man.he.net/man8/pwd_mkdb&quot;&gt;pwd_mkdb (8)&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4aa77499616bd2f38224ed594fc316a580948f20" translate="yes" xml:space="preserve">
          <source>If possible, move() will simply rename the file. Otherwise, it copies the file to the new location and deletes the original. If an error occurs during this copy-and-delete process, you may be left with a (possibly partial) copy of the file under the destination name.</source>
          <target state="translated">가능한 경우 move ()는 단순히 파일 이름을 바꿉니다. 그렇지 않으면 파일을 새 위치로 복사하고 원본을 삭제합니다. 이 복사 및 삭제 프로세스 중에 오류가 발생하면 대상 이름 아래에 파일의 (일부) 사본이 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2306ef44bf2f2a60c7ac6a896505074bcea6c96c" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. Follow the instructions and links on:</source>
          <target state="translated">가능하면 모듈을 CPAN에 등록하십시오. 다음의 지침과 링크를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="821e3f8f257e241afb18f9d12ceda656792b21cb" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. You should include details of its location in your announcement.</source>
          <target state="translated">가능하면 CPAN에 모듈을 등록하십시오. 공지 사항에 해당 위치의 세부 사항을 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="00df1bad6fa3810b7a0fb796a7103c7f28a05f8c" translate="yes" xml:space="preserve">
          <source>If possible, this form should be used to prevent possible race conditions.</source>
          <target state="translated">가능하면 경쟁 조건을 방지하기 위해이 양식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="34d4da8aa87987ec9ceda1c43801e78b64cdc28a" translate="yes" xml:space="preserve">
          <source>If present on a regex, &lt;code&gt;&quot;#&quot;&lt;/code&gt; comments will be handled differently by the tokenizer in some cases.</source>
          <target state="translated">정규식에있는 경우 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 주석은 경우에 따라 토크 나이저에 의해 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb106d01e2834098b09ad25220c5df2510aa768" translate="yes" xml:space="preserve">
          <source>If present, $hints should be a reference to a hash, where the following keys are recognised:</source>
          <target state="translated">존재하는 경우 $ hints는 다음 키가 인식되는 해시에 대한 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="768b78e920d55b41dde42ac4d330e515e86f1cd7" translate="yes" xml:space="preserve">
          <source>If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used:</source>
          <target state="translated">존재하는 경우, 주어진 메소드 유형에 해당하는 각 콜백은 &lt;code&gt;run&lt;/code&gt; 메소드가 사용되는 경우 결과를 인수로 사용하여 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="80e76146570d6b35c93035dd97f6090cb9b7cbba" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store all files and directories unlinked during the call. If nothing is unlinked, the array will be empty.</source>
          <target state="translated">있는 경우 스칼라를 참조해야합니다. 이 스칼라는 배열을 참조하기 위해 만들어지며 호출 중에 링크되지 않은 모든 파일과 디렉토리를 저장하는 데 사용됩니다. 아무것도 연결되어 있지 않으면 배열이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="865f6f3c95c9ee0c681ecdf2cdcadf01272955ae" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;&quot;ERROR HANDLING&quot;&lt;/a&gt; section for more information.</source>
          <target state="translated">존재하는 경우 스칼라에 대한 참조 여야합니다. 이 스칼라는 발생한 오류를 저장하는 데 사용되는 배열을 참조하도록 만들어집니다. 자세한 내용은 &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;&quot;오류 처리&quot;&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eaf6326ff6faceb306eebc039298d3cef21ae0f2" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;ERROR HANDLING&lt;/a&gt; section for more information.</source>
          <target state="translated">있는 경우 스칼라를 참조해야합니다. 이 스칼라는 배열을 참조하도록 만들어지며 발생하는 모든 오류를 저장하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;오류 처리&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28236ec2fcbd77071db6f4df51ebe2ad1353410f" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;make_path&lt;/code&gt; to print the name of each directory as it is created. By default nothing is printed.</source>
          <target state="translated">있는 경우 &lt;code&gt;make_path&lt;/code&gt; 가 작성 될 때 각 디렉토리의 이름을 인쇄합니다. 기본적으로 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba616b58ac8bd248e0e92e90224a9f0e82a7126d" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;remove_tree&lt;/code&gt; to print the name of each file as it is unlinked. By default nothing is printed.</source>
          <target state="translated">존재하는 경우, &lt;code&gt;remove_tree&lt;/code&gt; 가 링크 해제 된 각 파일의 이름을 인쇄하게합니다. 기본적으로 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da38e80a5de666bdd4124bbd72eac17c8b7acaf5" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt; . If the value is numeric, it will be interpreted as a uid, otherwise as username is assumed. An error will be issued if the username cannot be mapped to a uid, or the uid does not exist, or the process lacks the privileges to change ownership.</source>
          <target state="translated">존재하면 &lt;code&gt;$owner&lt;/code&gt; 가 생성 한 디렉토리를 소유하게됩니다 . 값이 숫자이면 uid로 해석되고, 그렇지 않으면 username으로 간주됩니다. 사용자 이름을 uid에 매핑 할 수 없거나 uid가 없거나 프로세스에 소유권을 변경할 수있는 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ff53c547d7a4dd3bf846157fd728900f2d937f3" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt;. If the value is numeric, it will be interpreted as a uid; otherwise a username is assumed. An error will be issued if the username cannot be mapped to a uid, the uid does not exist or the process lacks the privileges to change ownership.</source>
          <target state="translated">존재하는 경우 생성 된 모든 디렉토리가 &lt;code&gt;$owner&lt;/code&gt; 소유가됩니다 . 값이 숫자이면 uid로 해석됩니다. 그렇지 않으면 사용자 이름으로 간주됩니다. 사용자 이름을 uid에 매핑 할 수 없거나 uid가 존재하지 않거나 프로세스에 소유권을 변경할 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6bc6a6c714ec1098b00e8f4665bf29765d41191" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt; . If the value is numeric, it will be interpreted as a gid, otherwise as group name is assumed. An error will be issued if the group name cannot be mapped to a gid, or the gid does not exist, or the process lacks the privileges to change group ownership.</source>
          <target state="translated">있는 경우 &lt;code&gt;$group&lt;/code&gt; 그룹이 작성된 디렉토리를 소유하게됩니다 . 값이 숫자 인 경우 gid로 해석되고, 그렇지 않으면 그룹 이름으로 간주됩니다. 그룹 이름을 gid에 맵핑 할 수 없거나 gid가 없거나 프로세스에 그룹 소유권을 변경할 수있는 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ebd22cc8259df10471aba5e6db2f4331d3b55f7" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt;. If the value is numeric, it will be interpreted as a gid; otherwise a group name is assumed. An error will be issued if the group name cannot be mapped to a gid, the gid does not exist or the process lacks the privileges to change group ownership.</source>
          <target state="translated">존재하는 경우 생성 된 모든 디렉토리를 &lt;code&gt;$group&lt;/code&gt; 그룹이 소유하게됩니다 . 값이 숫자이면 gid로 해석됩니다. 그렇지 않으면 그룹 이름이 가정됩니다. 그룹 이름을 gid에 매핑 할 수 없거나 gid가 존재하지 않거나 프로세스에 그룹 소유권을 변경할 권한이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a365bb62991d043cada86ad3beb15687e9b5977b" translate="yes" xml:space="preserve">
          <source>If program usage has been explicitly requested by the user, it is often desirable to exit with a status of 1 (as opposed to 0) after issuing the user-requested usage message. It is also desirable to give a more verbose description of program usage in this case.</source>
          <target state="translated">사용자가 프로그램 사용을 명시 적으로 요청한 경우 사용자 요청 사용 메시지를 발행 한 후 상태가 1 (0이 아닌)로 종료하는 것이 바람직합니다. 이 경우 프로그램 사용에 대한 자세한 설명을 제공하는 것도 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="8bf641be539c33c01972d9eed772b4572f957d25" translate="yes" xml:space="preserve">
          <source>If provided, this argument will place the socket into listening mode. New connections can then be accepted using the &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="translated">제공된 경우이 인수는 소켓을 청취 모드로 전환합니다. 그런 다음 &lt;a href=&quot;IO::Socket#accept&quot;&gt;IO :: Socket&lt;/a&gt; 메서드 에서 &quot;accept&quot;를 사용하여 새 연결을 수락 할 수 있습니다 . 주어진 값은 &lt;code&gt;listen(2)&lt;/code&gt; 큐 크기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff3608d191706961b1f05c1c4d43ca10631cdf8b" translate="yes" xml:space="preserve">
          <source>If run on any operating system other than Windows, this will import the functions &lt;code&gt;setlocale&lt;/code&gt; and &lt;code&gt;LC_ALL&lt;/code&gt; from &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;. On Windows it does nothing.</source>
          <target state="translated">Windows 이외의 운영 체제에서 실행되는 경우 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 에서 &lt;code&gt;setlocale&lt;/code&gt; 및 &lt;code&gt;LC_ALL&lt;/code&gt; 함수를 가져옵니다 . Windows에서는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d9d2ff0e902fe5020fe3d38bdc23ea71c9ea208" translate="yes" xml:space="preserve">
          <source>If run with no arguments, filters standard input to standard output.</source>
          <target state="translated">인수없이 실행하면 표준 입력을 표준 출력으로 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="53f4c878607755d2bdfa2564e4393c026538b21e" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if $ENV{TMPDIR} is tainted, it is not used.</source>
          <target state="translated">오염 모드에서 실행 중이고 $ ENV {TMPDIR}이 오염 된 경우에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c028c3067c9e1833a7b2f721beaf502c1d3b87c3" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if the environment variables are tainted, they are not used.</source>
          <target state="translated">오염 모드에서 실행 중이고 환경 변수가 오염 된 경우에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc42709752d603d6e86a31cea878bd9ef78c5a40" translate="yes" xml:space="preserve">
          <source>If safety matters to you (and why else would you be using the Opcode module?) then you should not rely on the definition of this, or indeed any other, optag!</source>
          <target state="translated">안전이 중요한 이유 (및 다른 이유는 Opcode 모듈을 사용하는 이유는 무엇입니까?)에 대한 정의 나 다른 optag에 의존해서는 안됩니다!</target>
        </trans-unit>
        <trans-unit id="84fe2228be06f7c485981c30717e0cd96c85c324" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">설정된 경우 &lt;code&gt;formatter&lt;/code&gt; 는 TAP 출력을 형식화 할 수있는 오브젝트 여야합니다. 예제는 &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c49a3b26a25358ee584c0e87edb350360c053486" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">설정된 경우 &lt;code&gt;formatter&lt;/code&gt; 는 TAP 출력을 형식화 할 수있는 오브젝트 여야합니다. 예제는 &lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d7e12ada666ebe5ce88788573ab7d416ccee0e3" translate="yes" xml:space="preserve">
          <source>If set and Encode is not available, silently fall back to non-UTF-8 mode without complaining to standard error. This environment variable is set during Perl core builds, which build Encode after podlators. Encode is expected to not (yet) be available in that case.</source>
          <target state="translated">설정되어 있고 인코딩을 사용할 수없는 경우 표준 오류에 대해 불평하지 않고 비 UTF-8 모드로 자동으로 폴백합니다. 이 환경 변수는 Podlator 이후 Encode를 빌드하는 Perl 코어 빌드 중에 설정됩니다. 이 경우 인코딩은 (아직) 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc6406e3d3c8ec686d43e0bd0630b45054571335" translate="yes" xml:space="preserve">
          <source>If set forward, the details of the missing tests are filled in as 'unknown'. if set backward, the details of the intervening tests are deleted. You can erase history if you really want to.</source>
          <target state="translated">설정하면 누락 된 테스트의 세부 사항이 '알 수 없음'으로 채워집니다. 뒤로 설정하면 중재 테스트의 세부 사항이 삭제됩니다. 정말로 원한다면 역사를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94a6b6735d1cf67d97faf5afa93385c976f8d9ca" translate="yes" xml:space="preserve">
          <source>If set to 'none', no man pages will be installed.</source>
          <target state="translated">'없음'으로 설정하면 매뉴얼 페이지가 설치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35193d3a52f1a67d3457cb0804a53caff3b762a2" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">0으로 설정 하면 압축되지 않은 데이터가 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드 의 출력 매개 변수 내용을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="0eba3cfab3094093ee2a0a7a3f1a02110ff8208f" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;read&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">0으로 설정 하면 압축되지 않은 데이터가 &lt;code&gt;read&lt;/code&gt; 메서드 의 출력 매개 변수 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="63134c061d53f609b58fe4db77f806b2b217214c" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">1로 설정하면 압축되지 않은 모든 데이터가 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드 의 출력 매개 변수에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9f5b0a88e94e90aa98c8ce846cf8f2a8299b4e1" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;read&lt;/code&gt; method.</source>
          <target state="translated">1로 설정하면 압축되지 않은 모든 데이터가 &lt;code&gt;read&lt;/code&gt; 메서드 의 출력 매개 변수에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="a99badbf73893e25506e2b45aeb306043f0421e4" translate="yes" xml:space="preserve">
          <source>If set to a true value instruct &lt;code&gt;TAP::Parser&lt;/code&gt; to ignore exit and wait status from test scripts.</source>
          <target state="translated">true 값으로 설정되면 테스트 스크립트의 종료 및 대기 상태를 무시 하도록 &lt;code&gt;TAP::Parser&lt;/code&gt; 에 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="7addd0cdb6e060b7f425d641cdc5802f63dc6646" translate="yes" xml:space="preserve">
          <source>If set to a true value then MakeMaker's prompt function will always return the default without waiting for user input.</source>
          <target state="translated">true 값으로 설정하면 MakeMaker의 프롬프트 기능은 항상 사용자 입력을 기다리지 않고 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37acce4270c3ae4d059b2f5d5497684bcefbd070" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::PlainText will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">True 값으로 설정하면 Pod :: PlainText는 각 문장이 두 공백으로 끝나고 해당 간격을 유지하려고 시도합니다. false로 설정하면 비언어적 단락의 모든 연속 공백이 단일 공백으로 압축됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="9fb9b386eec98159e51954bb5d28974ecee8a0eb" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to false.</source>
          <target state="translated">true 값으로 설정하면 Pod :: Text는 각 문장이 두 개의 공백으로 끝나는 것으로 간주하고 해당 공백을 유지하려고합니다. false로 설정하면 비언어적 단락의 모든 연속 공백이 단일 공백으로 압축됩니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="a1e0bdf314190ede062d43bfa363f6d6ba57f992" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">True 값으로 설정하면 Pod :: Text는 각 문장이 두 공백으로 끝나고 해당 간격을 유지하려고 시도합니다. false로 설정하면 비언어적 단락의 모든 연속 공백이 단일 공백으로 압축됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c7ea67874e15073f2f8a8748dd116175b232517b" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt; , although one is still printed after &lt;code&gt;=head2&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">true 값으로 설정되면 &lt;code&gt;=head1&lt;/code&gt; 제목 다음에 빈 줄이 인쇄 됩니다. false (기본값)로 설정하면 &lt;code&gt;=head1&lt;/code&gt; 뒤에 빈 줄이 인쇄되지 않지만 &lt;code&gt;=head2&lt;/code&gt; 뒤에 여전히 인쇄 됩니다. 수동 페이지의 예상 형식이므로 이것이 기본값입니다. 임의의 텍스트 문서를 형식화하는 경우이 값을 true로 설정하면 출력이 더 좋아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12cadcd0631c167f67b19339e2f3ebc608babfe8" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt;, although one is still printed after &lt;code&gt;=head2&lt;/code&gt;. This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">true 값으로 설정하면 &lt;code&gt;=head1&lt;/code&gt; 머리글 뒤에 빈 줄이 인쇄 됩니다. false (기본값)로 설정하면 &lt;code&gt;=head1&lt;/code&gt; 뒤에 빈 행이 인쇄되지 않지만 &lt;code&gt;=head2&lt;/code&gt; 뒤에 하나가 인쇄 됩니다. 이것은 매뉴얼 페이지의 예상 형식이기 때문에 기본값입니다. 임의의 텍스트 문서의 서식을 지정하는 경우이 값을 true로 설정하면 더 만족스러운 출력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c7d693600594b39fe949ae434a7a5fc8a792dc" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=headN&lt;/code&gt; headings. If set to false (the default), no blank line is printed after &lt;code&gt;=headN&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">true 값으로 설정하면 &lt;code&gt;=headN&lt;/code&gt; 머리글 다음에 빈 줄이 인쇄 됩니다. false (기본값)로 설정하면 &lt;code&gt;=headN&lt;/code&gt; 뒤에 빈 줄이 인쇄되지 않습니다 . 수동 페이지의 예상 형식이므로 이것이 기본값입니다. 임의의 텍스트 문서를 형식화하는 경우이 값을 true로 설정하면 출력이 더 좋아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb0153c7c54ce2bccc40f5b7e2d5aff19532ce7" translate="yes" xml:space="preserve">
          <source>If set to a true value, indicates to the debugger that the code being debugged uses threads.</source>
          <target state="translated">true 값으로 설정되면 디버깅중인 코드가 스레드를 사용함을 디버거에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e75bb2ef91a1a8c8b0ee4cbc07e5ef237213911f" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; , or &lt;code&gt;comments&lt;/code&gt; .</source>
          <target state="translated">true 값으로 설정하면 지시문이있는 테스트 결과 만 표시됩니다. &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; 또는 &lt;code&gt;comments&lt;/code&gt; 과 같은 다른 설정보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="6403db7bde854649adecbe2fe72bc17d3ded2ac7" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt; .</source>
          <target state="translated">true 값으로 설정하면 지시문이있는 테스트 결과 만 표시됩니다. &lt;code&gt;verbose&lt;/code&gt; 또는 &lt;code&gt;failures&lt;/code&gt; 와 같은 다른 설정보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="5dc7bcb42a07b398704f1044000bc451673cf348" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt;.</source>
          <target state="translated">참 값으로 설정하면 지시문이있는 테스트 결과 만 표시됩니다. 이것은 &lt;code&gt;verbose&lt;/code&gt; 또는 &lt;code&gt;failures&lt;/code&gt; 와 같은 다른 설정을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="56370371763a8fe8f684fb9af4f85fc5b478e2a6" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt;, &lt;code&gt;failures&lt;/code&gt;, or &lt;code&gt;comments&lt;/code&gt;.</source>
          <target state="translated">참 값으로 설정하면 지시문이있는 테스트 결과 만 표시됩니다. 이것은 &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; 또는 &lt;code&gt;comments&lt;/code&gt; 과 같은 다른 설정을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="ace0eebb3ad1da3562cf6ba2f4eb062020ce0829" translate="yes" xml:space="preserve">
          <source>If set to a true value, selects an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin. Defaults to false.</source>
          <target state="translated">true 값으로 설정된 경우, 다른 제목 스타일을 사용 하고 왼쪽 여백에 콜론으로 &lt;code&gt;=item&lt;/code&gt; 항목을 표시하는 대체 출력 형식을 선택합니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="341f05ae650241bc98a8aa05ba502f05572aa8ee" translate="yes" xml:space="preserve">
          <source>If set to a true value, source entries will be converted into utf8-strings (available in Perl 5.6.1 or later). This feature needs the &lt;b&gt;Encode&lt;/b&gt; or &lt;b&gt;Encode::compat&lt;/b&gt; module.</source>
          <target state="translated">true 값으로 설정하면 소스 항목이 utf8 문자열로 변환됩니다 (Perl 5.6.1 이상에서 사용 가능). 이 기능에는 &lt;b&gt;Encode&lt;/b&gt; 또는 &lt;b&gt;Encode :: compat&lt;/b&gt; 모듈 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e52de704a5928c9a6d768f4b0d7d8f6e786b6b18" translate="yes" xml:space="preserve">
          <source>If set to a true value, the non-POD parts of the input file will be included in the output. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">true 값으로 설정하면 입력 파일의 비 POD 부분이 출력에 포함됩니다. POD를 렌더링하고 코드를 그대로 유지 한 상태에서 POD 블록으로 문서화 된 코드를 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="77ffaa19bbb496da1b7f2a485ed0c35990cc9fa8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; for that. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">0이 아닌 값으로 설정하면 현재 선택된 출력 채널에서 모든 쓰기 또는 인쇄 후에 즉시 플러시를 수행합니다. 기본값은 0입니다 (채널이 실제로 시스템에 의해 버퍼링되는지 여부에 관계없이; &lt;code&gt;$|&lt;/code&gt; 는 각 쓰기 후에 플러시를 명시 적으로 플러시했는지 여부 만 알려줍니다). 출력이 터미널에 출력되면 STDOUT은 일반적으로 라인 버퍼링되고 그렇지 않으면 블록 버퍼링됩니다. 이 변수를 설정하면 &lt;b&gt;rsh&lt;/b&gt; 에서 Perl 프로그램을 실행 중이고 출력이 발생하는 것을 확인하려는 경우와 같이 파이프 또는 소켓으로 출력 할 때 주로 유용합니다 . 이것은 입력 버퍼링에 영향을 미치지 않습니다. &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; 를 참조하십시오 . 출력 채널을 선택하는 방법에 대한 &lt;a href=&quot;functions/select&quot;&gt;선택&lt;/a&gt; 을 참조 하십시오 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b32ab50f4a2e4d52971c50b3ce21204c6ea713f8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt; for that. See &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">0이 아닌 값으로 설정하면 현재 선택된 출력 채널에서 쓰기 또는 인쇄 할 때마다 즉시 플러시를 강제 실행합니다. 기본값은 0입니다 (채널이 실제로 시스템에 의해 버퍼링되었는지 여부에 관계없이 &lt;code&gt;$|&lt;/code&gt; 는 Perl이 각 쓰기 후 플러시하도록 명시 적으로 요청했는지 여부 만 알려줍니다). STDOUT은 일반적으로 출력이 터미널로 전송되는 경우 라인 버퍼링되고 그렇지 않은 경우 블록 버퍼링됩니다. 이 변수를 설정하는 것은 주로 파이프 나 소켓으로 출력 할 때 유용합니다. 예를 들어 &lt;b&gt;rsh&lt;/b&gt; 에서 Perl 프로그램을 실행 중이고 출력이 발생하는 것을보고 싶을 때입니다. 이것은 입력 버퍼링에 영향을주지 않습니다. 이에 대해서는 &lt;a href=&quot;perlfunc#getc&quot;&gt;perlfunc의 &quot;getc&quot;를&lt;/a&gt; 참조하십시오 . 출력 채널을 선택하는 방법 &lt;a href=&quot;perlfunc#select&quot;&gt;은 perlfunc의 &quot;select&quot;를&lt;/a&gt; 참조하십시오 . 참조 &lt;a href=&quot;IO::Handle&quot;&gt;IO ::핸들&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="615ff3b3ad3b33807d03afb15df6a2d1917cfce6" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device when Perl is run with the &lt;a href=&quot;#-Dletters&quot;&gt;-Di&lt;/a&gt; command-line switch, the logging of certain operations of the PerlIO subsystem will be redirected to the specified file rather than going to stderr, which is the default. The file is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">&lt;a href=&quot;#-Dletters&quot;&gt;-Di&lt;/a&gt; 명령 줄 스위치를 사용하여 Perl을 실행할 때 파일 또는 장치의 이름으로 설정 하면 PerlIO 하위 시스템의 특정 작업에 대한 로깅이 기본값 인 stderr로 이동하지 않고 지정된 파일로 리디렉션됩니다. 파일이 추가 모드로 열립니다. 일반적인 용도는 Unix입니다.</target>
        </trans-unit>
        <trans-unit id="910076b95e48e767183ba95d8bfd82a29fd1f4b7" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device, certain operations of PerlIO subsystem will be logged to that file, which is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">파일 또는 장치 이름으로 설정하면 PerlIO 하위 시스템의 특정 작업이 해당 파일에 기록되며 추가 모드에서 열립니다. 일반적인 용도는 Unix입니다.</target>
        </trans-unit>
        <trans-unit id="a2a487ec4b2cdae05d408b6e8c6a9dd6b1beda15" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환하는 대신 템플릿 유효성 검사 중에 오류가 발생할 때 &lt;code&gt;croak&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="39e47711b0a2673f5f59abca021e0aa968949985" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt; 는 더 이상 사용자 입력의 모든 키를 소문자로 변환하지 않고 대신 템플릿이 제공된 경우에있을 것으로 예상합니다. 템플릿에서 대 / 소문자가 다른 유사한 키를 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f253f67365056571734a093e4d2ab45914323e0" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;defined&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;defined&lt;/code&gt; instead.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt; 는 전달 된 모든 값을 &lt;code&gt;defined&lt;/code&gt; 합니다. 이를 '키별'기준으로 활성화하려면 대신 &lt;code&gt;defined&lt;/code&gt; 템플릿 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="42e74293048eac70b152d671b3afa7d17f3695a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt; 는 템플릿의 온 전성 검사를 수행하여 오류 및 알 수없는 키를 확인합니다. 디버깅에 매우 유용하지만 핫 코드 및 대형 루프에서는 다소 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907b3689c8943c9530c2bccd5f2399b3ea311ce8" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">true로 설정하면 템플릿 유효성 검사 중 오류가 발생하면 &lt;code&gt;false&lt;/code&gt; 를 반환하지 않고 &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; 가 &lt;code&gt;croak&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="262e77d8ecddf65d8252c722de18aca6dafa7dd4" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; 는 더 이상 사용자 입력의 모든 키를 소문자로 변환하지 않지만 대신 템플릿이 제공 한 경우 일 것으로 예상합니다. 템플릿에서 다른 케이스와 유사한 키를 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fcd2802dc60a0f5aa656aa8d36630b4a5a1195a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; 는 전달 된 모든 값을 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 합니다. 이 기능을 '키당'으로 활성화하려면 대신 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 템플릿 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b62a3740f4d2f3949ae331d68aff300bd8b9c5aa" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">true로 설정된 경우 &lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt; 는 오류 및 알 수없는 키의 유효성을 검사하여 템플릿을 검사합니다. 디버깅에 매우 유용하지만 핫 코드 및 큰 루프에서는 다소 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df88f116b1eff18f21bd345796868ca93d04ee66" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">true로 설정하면 압축되지 않은 데이터의 crc32 체크섬이 계산됩니다. 이 값을 검색 하려면 &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbd8aed6bbb2cb495083f75e98d7497f01edca37" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">true로 설정하면 압축되지 않은 데이터의 crc32 체크섬이 계산됩니다. 이 값을 검색 하려면 &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4a8f4d307b72654b7c09182b593e029ffb7af20" translate="yes" xml:space="preserve">
          <source>If set to true, all keys in the template that are marked as to be stored in a scalar, will also be removed from the result set.</source>
          <target state="translated">true로 설정하면 스칼라에 저장되도록 표시된 템플리트의 모든 키도 결과 세트에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9a61d55c40cdf983928fb90e5f246e820a5b49" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">true로 설정하면 압축되지 않은 데이터의 adler32 체크섬이 계산됩니다. 이 값을 검색 하려면 &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a30a93daed908c592b28db82a1a0b5d4a5ffc0" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">true로 설정하면 압축되지 않은 데이터의 adler32 체크섬이 계산됩니다. 이 값을 검색 하려면 &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbc945146e02b49c89057b1636cf31aa2669f101" translate="yes" xml:space="preserve">
          <source>If set to true, immediately extract entries when reading them. This gives you the same memory break as the &lt;code&gt;extract_archive&lt;/code&gt; function. Note however that entries will not be read into memory, but written straight to disk. This means no &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects are created for you to inspect.</source>
          <target state="translated">true로 설정하면 항목을 읽을 때 즉시 추출하십시오. 이것은 &lt;code&gt;extract_archive&lt;/code&gt; 함수 와 동일한 메모리 브레이크를 제공합니다 . 그러나 항목은 메모리로 읽히지 않고 디스크에 직접 쓰여집니다. 이것은 검사 할 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체가 생성 되지 않음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="8be646f7a5def96ccc7c7343df2cffa456a1c220" translate="yes" xml:space="preserve">
          <source>If set to true, no &quot;1..N&quot; header will be printed.</source>
          <target state="translated">true로 설정하면 &quot;1..N&quot;헤더가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7adb95e8ec0ed6e84fcb01131c2b90c160ee5335" translate="yes" xml:space="preserve">
          <source>If set to true, this option will remove compressed data from the input buffer of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method as the inflate progresses.</source>
          <target state="translated">true로 설정하면이 옵션은 팽창이 진행됨 에 따라 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 메소드 의 입력 버퍼에서 압축 된 데이터를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="d55732bd7089a68f6b5548af27b4b056d17dc65d" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt; .</source>
          <target state="translated">true로 설정하면 진단이 인쇄되지 않습니다. 여기에는 &lt;code&gt;diag()&lt;/code&gt; 호출이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5397281aac6b794ebe8bf86c258022bd58733ebd" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 진단이 인쇄되지 않습니다. 여기에는 &lt;code&gt;diag()&lt;/code&gt; 호출이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6758cd1f0be9e6394226a98fea1a97b18f4a012d" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;TAP::Parser::Source#config_for&quot;&gt;&quot;config_for&quot; in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">설정된 경우 &lt;code&gt;sources&lt;/code&gt; 는 로드 및 / 또는 구성 할 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 의 이름을 포함하는 해시 참조 여야 합니다. 값은 &lt;a href=&quot;TAP::Parser::Source#config_for&quot;&gt;TAP :: Parser :: Source의 &quot;config_for&quot;를&lt;/a&gt; 통해 소스 핸들러에 액세스 할 수있는 구성의 해시입니다 .</target>
        </trans-unit>
        <trans-unit id="767e45d99bc3772f600dade44827bcaf3503a3c0" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;parser/source#config_for&quot;&gt;config_for in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">설정되면 &lt;code&gt;sources&lt;/code&gt; 는 로드 및 / 또는 구성 할 &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 의 이름이 포함 된 해시 참조 여야 합니다. 값은 &lt;a href=&quot;parser/source#config_for&quot;&gt;TAP :: Parser :: Source의 config_for를&lt;/a&gt; 통해 소스 핸들러가 액세스 할 수있는 구성의 해시입니다 .</target>
        </trans-unit>
        <trans-unit id="1f1db51044dc4cdaf8453a0cac36827443c78520" translate="yes" xml:space="preserve">
          <source>If set, END blocks are executed when the interpreter is destroyed. This is normally set by perl itself after the interpreter is constructed.</source>
          <target state="translated">설정되면 인터프리터가 파괴 될 때 END 블록이 실행됩니다. 이것은 일반적으로 인터프리터가 구성된 후 perl 자체에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7a162adb7a0dc8b66567284e3d48459cecdcd046" translate="yes" xml:space="preserve">
          <source>If set, a directory which fails the</source>
          <target state="translated">설정된 경우 실패한 디렉토리</target>
        </trans-unit>
        <trans-unit id="430e0a0ebf21ab8f824a0951a1408be6d39c892f" translate="yes" xml:space="preserve">
          <source>If set, and POD_MAN_DATE and the &lt;code&gt;date&lt;/code&gt; options are not set, this will be used as the modification time of the source file, overriding the timestamp of the input file or the current time. It should be set to the desired time in seconds since UNIX epoch. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent. See &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; for the full specification.</source>
          <target state="translated">설정되고 POD_MAN_DATE 및 &lt;code&gt;date&lt;/code&gt; 옵션이 설정되지 않은 경우 소스 파일의 수정 시간으로 사용되어 입력 파일의 타임 스탬프 또는 현재 시간을 재정의합니다. UNIX epoch 이후 원하는 시간 (초)으로 설정해야합니다. 이는 파일 타임 스탬프가 일관되지 않을 수있는 경우에도 동일한 소스 및 Pod :: Man 버전이 지정된 동일한 출력 파일의 재현 가능한 빌드를 보장하는 데 주로 유용합니다. 전체 사양 은 &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; 를 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="50fc3d2d4510057c46811e96115fbf4e2aa5439b" translate="yes" xml:space="preserve">
          <source>If set, general protection faults do not generate a dialogue box but can instead be handled by the process via an exception handler. This bit should not be set by programs that don't know how to handle such faults.</source>
          <target state="translated">설정된 경우 일반 보호 오류는 대화 상자를 생성하지 않지만 예외 처리기를 통해 프로세스에서 처리 할 수 ​​있습니다. 이 비트는 이러한 오류를 처리하는 방법을 모르는 프로그램에 의해 설정되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="36dd77001e7c6eaf4c115da0bfdc18f666edd086" translate="yes" xml:space="preserve">
          <source>If set, indicates that when a critical error is encountered, the call that triggered the error fails immediately. Normally this bit is not set, which means that a critical error causes a dialogue box to appear notifying the desktop user that some application has triggered a critical error. The dialogue box allows the desktop user to decide whether the critical error is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="translated">설정된 경우 심각한 오류가 발생하면 오류를 트리거 한 호출이 즉시 실패 함을 나타냅니다. 일반적으로이 비트는 설정되지 않습니다. 즉, 심각한 오류가 발생하면 데스크톱 사용자에게 일부 응용 프로그램에서 심각한 오류가 발생했음을 알리는 대화 상자가 나타납니다. 대화 상자를 통해 데스크톱 사용자는 심각한 오류가 프로세스로 반환되는지, 무시되는지 또는 문제가되는 작업을 다시 시도할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e6aaabd1216511f49764603b89114f7c2c7520" translate="yes" xml:space="preserve">
          <source>If set, should be the name of a file (in the output directory) to write the HTML index to. The default value is &quot;index.html&quot;. If you set this to a false value, no contents file will be written.</source>
          <target state="translated">설정된 경우 HTML 색인을 쓸 파일 이름 (출력 디렉토리에 있음)이어야합니다. 기본값은 &quot;index.html&quot;입니다. 이 값을 false로 설정하면 내용 파일이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fed7ed0698b463358f79ea435791a3f79370827d" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into &lt;code&gt;NonStop&lt;/code&gt; mode and will not connect to a TTY. If interrupted (or if control goes to the debugger via explicit setting of $DB::signal or $DB::single from the Perl script), it connects to a TTY specified in the &lt;code&gt;TTY&lt;/code&gt; option at startup, or to a tty found at runtime using the &lt;code&gt;Term::Rendezvous&lt;/code&gt; module of your choice.</source>
          <target state="translated">설정된 경우 디버거는 &lt;code&gt;NonStop&lt;/code&gt; 모드 로 전환되고 TTY에 연결되지 않습니다. 중단 된 경우 (또는 Perl 스크립트에서 $ DB :: signal 또는 $ DB :: single의 명시 적 설정을 통해 제어가 디버거로 이동하는 경우) 시작시 &lt;code&gt;TTY&lt;/code&gt; 옵션에 지정된 TTY 또는 선택한 &lt;code&gt;Term::Rendezvous&lt;/code&gt; 모듈을 사용하는 런타임 .</target>
        </trans-unit>
        <trans-unit id="f19bf560504f7c9497b672610231bba49eba7830" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into non-interactive mode until interrupted, or programmatically by setting $DB::signal or $DB::single.</source>
          <target state="translated">설정된 경우 디버거는 중단 될 때까지 또는 $ DB :: signal 또는 $ DB :: single을 설정하여 프로그래밍 방식으로 비 대화식 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="f315d5d8357d35b3e7a9f240785d04d5f2c0b17f" translate="yes" xml:space="preserve">
          <source>If set, then when an attempt to continue reading from or writing to an already open file [usually on a removable medium like a floppy diskette] finds the file no longer available, the call will immediately fail. Normally this bit is not set, which means that instead a dialogue box will appear notifying the desktop user that some application has run into this problem. The dialogue box allows the desktop user to decide whether the failure is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="translated">설정된 경우 이미 열려있는 파일 (일반적으로 플로피 디스켓과 같은 이동식 매체에 있음)에서 계속 읽거나 쓰려는 시도가 파일을 더 이상 사용할 수 없음을 발견하면 호출이 즉시 실패합니다. 일반적으로이 비트는 설정되지 않습니다. 즉, 데스크톱 사용자에게 일부 응용 프로그램에서이 문제가 발생했음을 알리는 대화 상자가 나타납니다. 대화 상자를 통해 데스크톱 사용자는 실패가 프로세스로 반환되는지, 무시되는지 또는 문제가되는 작업을 다시 시도할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8533dab20da5503a1d14e1f563a58d7fccbc547" translate="yes" xml:space="preserve">
          <source>If set, this causes memory access misalignment faults to be automatically fixed in a manner invisible to the process. This flag is ignored on x86-based versions of Windows NT. This flag is not supported on Windows 95.</source>
          <target state="translated">설정된 경우 메모리 액세스 정렬 불량 오류가 프로세스에 표시되지 않는 방식으로 자동으로 수정됩니다. x86 기반 버전의 Windows NT에서는이 플래그가 무시됩니다. 이 플래그는 Windows 95에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="825ea211f8cc0b564969fbeabe2d0a330315f1a6" translate="yes" xml:space="preserve">
          <source>If set, this dumps out memory statistics after execution. If set to an integer greater than one, also dumps out memory statistics after compilation.</source>
          <target state="translated">설정하면 실행 후 메모리 통계를 덤프합니다. 1보다 큰 정수로 설정하면 컴파일 후 메모리 통계도 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="8b969433f335481102ca199a1faf8cf07ca2debd" translate="yes" xml:space="preserve">
          <source>If set, this symbol indicates that only the version-specific components of a perl installation should be installed. This may be useful for making a test installation of a new version without disturbing the existing installation. Setting versiononly is equivalent to setting installperl's -v option. In particular, the non-versioned scripts and programs such as a2p, c2ph, h2xs, pod2*, and perldoc are not installed (see &lt;code&gt;INSTALL&lt;/code&gt; for a more complete list). Nor are the man pages installed. Usually, this is undef.</source>
          <target state="translated">설정된 경우이 기호는 perl 설치의 버전 별 구성 요소 만 설치해야 함을 나타냅니다. 기존 설치를 방해하지 않고 새 버전을 테스트 설치하는 데 유용 할 수 있습니다. versiononly 설정은 installperl의 -v 옵션 설정과 같습니다. 특히 a2p, c2ph, h2xs, pod2 * 및 perldoc과 같은 버전이없는 스크립트 및 프로그램은 &lt;code&gt;INSTALL&lt;/code&gt; 되지 않습니다 (자세한 내용은 INSTALL 참조 ). 매뉴얼 페이지도 설치되어 있지 않습니다. 일반적으로 이것은 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="80c94ecda6e710c6fc8e753f6f4382b5d0835ec4" translate="yes" xml:space="preserve">
          <source>If set, this will be used as the value of the left-hand footer unless the &lt;code&gt;date&lt;/code&gt; option is explicitly set, overriding the timestamp of the input file or the current time. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent.</source>
          <target state="translated">설정된 경우 &lt;code&gt;date&lt;/code&gt; 옵션이 명시 적으로 설정 되지 않은 경우 왼쪽 바닥 글의 값으로 사용되어 입력 파일의 타임 스탬프 또는 현재 시간을 재정의합니다. 이는 파일 타임 스탬프가 일관되지 않을 수있는 경우에도 동일한 소스 및 Pod :: Man 버전이 지정된 동일한 출력 파일의 재현 가능한 빌드를 보장하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5be95242fd4f1700426db0866219ce183a7c4d43" translate="yes" xml:space="preserve">
          <source>If setmagic is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. 'local $x = $y'), and that will handle the magic.</source>
          <target state="translated">setmagic이 false이면 새로운 (빈) SV에서 설정된 매직이 호출되지 않습니다. 이는 일반적으로 과제가 곧 따를 것 (예 : 'local $ x = $ y')을 의미하며 마술을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b7db0eb29b687c30aa2094a54d8f1f63ca4df7c5" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; , it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 에 여러 심볼 범주가있는 경우 &quot;use&quot;문을 단순화하기 위해 유틸리티 &quot;: all&quot;을 만드는 것이 일반적으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3f21602986b59b3bc1a9d6d50edec0ff3a9a1224" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt;, it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 에 여러 기호 범주가있는 경우 일반적으로 &quot;use&quot;문을 단순화하기 위해 유틸리티 &quot;: all&quot;을 만드는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d650df7f1b284cce9178200761c079c663691a8" translate="yes" xml:space="preserve">
          <source>If so, please try to reuse the existing modules either in whole or by inheriting useful features into a new class. If this is not practical try to get together with the module authors to work on extending or enhancing the functionality of the existing modules. A perfect example is the plethora of packages in perl4 for dealing with command line options.</source>
          <target state="translated">그렇다면 기존 모듈을 전체적으로 재사용하거나 유용한 기능을 새로운 클래스로 상속하여 시도하십시오. 이것이 실용적이지 않으면 모듈 작성자와 함께 기존 모듈의 기능을 확장하거나 향상시키는 작업을 시도하십시오. 완벽한 예는 명령 줄 옵션을 처리하기위한 perl4의 많은 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="dcc2c875ef26b86def7f4287ef7a97e0b0212c08" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please attach your patch to the report using the &lt;code&gt;-p&lt;/code&gt; option. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">그렇다면 좋은 소식입니다. 패치가있는 버그 보고서는 패치가없는 버그 보고서보다 훨씬 더 많은주의와 관심을받습니다. &lt;code&gt;-p&lt;/code&gt; 옵션을 사용하여 패치를 보고서에 첨부하십시오 . 패치를 보낼 때, 가능하다면 &lt;code&gt;git format-patch&lt;/code&gt; 를 사용하여 패치를 만드십시오. &lt;code&gt;diff -pu&lt;/code&gt; 로 작성된 통합 된 diff 도 거의 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="dfaefac0caf9158c6cac0a67edf5328c9dac8509" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please submit your patch via the GitHub Pull Request workflow as described in &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;. You may also send patches to &lt;b&gt;perl5-porters@perl.org&lt;/b&gt;. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">그렇다면 좋은 소식입니다. 패치가있는 버그 보고서는 패치가없는 보고서보다 훨씬 더 많은 관심과 관심을받을 가능성이 높습니다. &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlhack&quot;&gt;perlhack에&lt;/a&gt; 설명 된대로 GitHub Pull Request 워크 플로를 통해 패치를 제출하세요 . &lt;b&gt;perl5-porters@perl.org&lt;/b&gt; 로 패치를 보낼 수도 있습니다 . 패치를 보낼 때 가능하면 &lt;code&gt;git format-patch&lt;/code&gt; 를 사용하여 생성하십시오. &lt;code&gt;diff -pu&lt;/code&gt; 로 생성 된 통합 diff 도 거의 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="e41db44860ffe2b84a712b997e64175db6318266" translate="yes" xml:space="preserve">
          <source>If some events detected in</source>
          <target state="translated">일부 이벤트가 감지 된 경우</target>
        </trans-unit>
        <trans-unit id="4a24b9aa82fff6a4581557ce8337d0476898456b" translate="yes" xml:space="preserve">
          <source>If some threads have not finished running when the main Perl thread ends, Perl will warn you about it and die, since it is impossible for Perl to clean up itself while other threads are running.</source>
          <target state="translated">주 Perl 스레드가 종료 될 때 일부 스레드가 실행을 완료하지 않으면 Perl은 다른 스레드가 실행중인 동안 자체 정리할 수 없으므로 Perl에 대해 경고하고 죽습니다.</target>
        </trans-unit>
        <trans-unit id="5c202d6491a5606cc9c88606232cf0104e601803" translate="yes" xml:space="preserve">
          <source>If something in a program isn&amp;rsquo;t the value you&amp;rsquo;re looking for but indicates where the value is, that&amp;rsquo;s indirection. This can be done with either &lt;b&gt;symbolic references&lt;/b&gt; or &lt;b&gt;hard&lt;/b&gt;.</source>
          <target state="translated">프로그램의 어떤 것이 당신이 찾고있는 가치가 아니지만 그 가치가 어디에 있는지를 나타내면 간접적입니다. 이것은 &lt;b&gt;기호 참조&lt;/b&gt; 나 &lt;b&gt;hard&lt;/b&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d353132ec4a6837954d3ce352dc8e97cba1ae50" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;deprecated&lt;/b&gt;, we may remove it from the core in the future, though we might not. Generally, backward incompatible changes will have deprecation warnings for two release cycles before being removed, but may be removed after just one cycle if the risk seems quite low or the benefits quite high.</source>
          <target state="translated">Perl 코어의 어떤 것이 &lt;b&gt;더 이상 사용되지 않는&lt;/b&gt; 것으로 표시 되면 나중에 코어에서 제거 할 수 있습니다. 일반적으로 이전 버전과 호환되지 않는 변경 사항은 제거되기 전에 두 릴리스주기에 대해 사용 중단 경고가 표시되지만 위험이 매우 낮거나 이점이 매우 높은 경우 한주기 후에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fdc0cac0824435fe5437bd44fc271afb23e92f6" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;experimental&lt;/b&gt;, we may change its behaviour, deprecate or remove it without notice. While we'll always do our best to smooth the transition path for users of experimental features, you should contact the perl5-porters mailinglist if you find an experimental feature useful and want to help shape its future.</source>
          <target state="translated">Perl 코어의 어떤 것이 &lt;b&gt;실험적인&lt;/b&gt; 것으로 표시되면 , 우리는 그 행동을 예고없이 변경하거나, 더 이상 사용하지 않거나 제거 할 수 있습니다. 실험 기능 사용자를위한 전환 경로를 매끄럽게하기 위해 항상 최선을 다하지만, 실험 기능이 유용하고 미래를 구체화하려면 perl5-porters 메일 링리스트에 문의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fae6eb432d77d8528c8b9785dccec21b272faf2" translate="yes" xml:space="preserve">
          <source>If something in there fails, you'll know which one it was and that will make tracking down the problem easier. Try to put a bit of debugging information into the test names.</source>
          <target state="translated">거기에있는 무언가가 실패하면 그것이 무엇인지 알 수 있고 문제를 더 쉽게 추적 할 수 있습니다. 테스트 이름에 약간의 디버깅 정보를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="12083dc2cfbc1c39486c5540691a063ce5c5018f" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">공백이 입력 텍스트의 다음 청크로 확장되면 다음 청크를 읽습니다. 일반적으로 현재 청크는 동시에 버려지지만</target>
        </trans-unit>
        <trans-unit id="14e709a02e4eecb15fa27505b7e71a09c11f743c" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="translated">공백이 입력 텍스트의 다음 청크로 확장되면 다음 청크를 읽습니다. 일반적으로 현재 청크는 동시에 삭제되지만 &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; 비트가 설정되어 있으면 현재 청크는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="593e478a0d37f7a9d8665d309a9a7733f6ec02c1" translate="yes" xml:space="preserve">
          <source>If specified the contents of &lt;code&gt;DATA&lt;/code&gt; and a termination string &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; is sent to the server. The result will be true if the data was accepted.</source>
          <target state="translated">지정된 경우 &lt;code&gt;DATA&lt;/code&gt; 의 내용 과 종료 문자열 &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; 이 서버로 전송됩니다. 데이터가 승인 된 경우 결과는 참입니다.</target>
        </trans-unit>
        <trans-unit id="b6dd58d3559146e497eb5b446f27a9cb126713f8" translate="yes" xml:space="preserve">
          <source>If specified, strings are normalized before preparation of sort keys (the normalization is executed after preprocess).</source>
          <target state="translated">지정된 경우 정렬 키를 준비하기 전에 문자열이 정규화됩니다 (정규화는 사전 처리 후 실행 됨).</target>
        </trans-unit>
        <trans-unit id="c54d25c0a371a4a7533e5b6eb7a37c54566669f4" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to preprocess each string before the formation of sort keys.</source>
          <target state="translated">지정된 경우, coderef는 정렬 키를 형성하기 전에 각 문자열을 사전 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df742ffc92755882ac205c4e8f1710a25c417cf9" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; . The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">지정된 경우 coderef는 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 의 행을 다시 쓰는 데 사용됩니다 . coderef는 각 줄을 가져온 다음 UCA 파일 형식에 따라 다시 작성된 줄을 반환해야합니다. 코드 참조가 빈 줄을 반환하면 줄을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="65a1895406fe003bd9c8df18e562302ad473cb2d" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt;. The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">지정된 경우 coderef는 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 행을 다시 쓰는 데 사용됩니다 . coderef는 각 줄을 가져온 다음 UCA 파일 형식에 따라 다시 작성된 줄을 반환해야합니다. coderef가 빈 줄을 반환하면 해당 줄을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fd186f184cd201e115617cc1e9809ac56ff41627" translate="yes" xml:space="preserve">
          <source>If specified, the given string will be stripped off from the beginning of the C function name in the generated XS functions (if it starts with that prefix). This only applies to XSUBs without &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;PPCODE&lt;/code&gt; blocks. For example, the XS:</source>
          <target state="translated">지정된 경우 지정된 문자열은 생성 된 XS 함수에서 C 함수 이름의 시작 부분에서 제거됩니다 (해당 접두어로 시작하는 경우). 이것은 &lt;code&gt;CODE&lt;/code&gt; 또는 &lt;code&gt;PPCODE&lt;/code&gt; 블록이 없는 XSUB에만 적용됩니다 . 예를 들어 XS :</target>
        </trans-unit>
        <trans-unit id="db33e17f1262611ad9b1ad5050ad6146c6b090c4" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">이 옵션을 지정하면 zip 로컬 및 중앙 헤더에서 모든 추가 필드를 만들 수 없습니다. 따라서 &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 및 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa95b55da4c40155f92625ffd4e21427121a5f5" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt;, &lt;code&gt;exUnix2&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt;, &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">지정된 경우이 옵션은 zip 로컬 및 중앙 헤더의 모든 추가 필드 생성을 비활성화합니다. 따라서 &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 및 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0066c7ecc8871ce3a62f9b83ef61508d6113e7" translate="yes" xml:space="preserve">
          <source>If specified, this option will force the creation of the smallest possible compliant gzip header (which is exactly 10 bytes long) as defined in RFC 1952.</source>
          <target state="translated">이 옵션을 지정하면 RFC 1952에 정의 된대로 가능한 가장 작은 호환 가능한 gzip 헤더 (정확하게 10 바이트 길이)를 작성하게됩니다.</target>
        </trans-unit>
        <trans-unit id="74b346bb75048f3d43315e1f91c059eb29d865aa" translate="yes" xml:space="preserve">
          <source>If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though.</source>
          <target state="translated">속도가 중요하지 않은 경우 공통 관용구는 스칼라 컨텍스트에서 grep을 사용하여 (조건을 통과 한 항목 수를 리턴 함) 전체 목록을 탐색합니다. 그래도 일치하는 항목 수를 알려주는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8029f3ea6d316f66b8a86b9af29af453cce204da" translate="yes" xml:space="preserve">
          <source>If start_color is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If end_color is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">start_color가 널이 아닌 경우 여는 인용 부호 (있는 경우) 뒤에 이스케이프 된 텍스트 앞에 삽입됩니다. end_color가 널이 아닌 경우 이스케이프 된 텍스트 뒤에 따옴표 나 생략 부호 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="741bc8e54000bbf6547a93a37e27f9bd7b7bf22e" translate="yes" xml:space="preserve">
          <source>If straightforward stream-based parsing wont meet your needs (as is likely the case for tasks such as translating PODs into structured markup languages like HTML and XML) then you may need to take the tree-based approach. Rather than doing everything in one pass and calling the &lt;b&gt;interpolate()&lt;/b&gt; method to expand sequences into text, it may be desirable to instead create a parse-tree using the &lt;b&gt;parse_text()&lt;/b&gt; method to return a tree-like structure which may contain an ordered list of children (each of which may be a text-string, or a similar tree-like structure).</source>
          <target state="translated">스트림 기반 구문 분석이 사용자의 요구를 충족시키지 못하면 (POD를 HTML 및 XML과 같은 구조화 된 마크 업 언어로 변환하는 것과 같은 작업의 경우처럼) 트리 기반 접근 방식을 취해야합니다. 한 번에 모든 작업을 수행하고 &lt;b&gt;interpolate ()&lt;/b&gt; 메서드를 호출하여 시퀀스를 텍스트로 확장하는 대신 &lt;b&gt;parse_text ()&lt;/b&gt; 메서드를 사용하여 구문 분석 트리를 만들어 정렬 된 목록을 포함 할 수있는 트리와 같은 구조를 반환하는 것이 &lt;b&gt;좋습니다.&lt;/b&gt; 어린이 (각각 텍스트 문자열 또는 유사한 나무와 같은 구조 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="2063c72cde7216e8c8fe940ebf2fb1f781846427" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">서브 루틴 서명이 활성화 된 경우 ( &lt;a href=&quot;#Signatures&quot;&gt;&quot;서명&quot;&lt;/a&gt; 참조 ), 서명과 충돌 할 수 있으므로 더 짧은 PROTO 구문을 사용할 수 없습니다. 이 경우 프로토 타입은 속성 형식으로 만 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d14b7e2a788098ee234bfc1585ff4767dfdaee2" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">서브 루틴 서명이 사용 가능한 경우 ( &lt;a href=&quot;#Signatures&quot;&gt;서명&lt;/a&gt; 참조 ) 더 짧은 PROTO 구문은 서명과 충돌하므로 사용할 수 없습니다. 이 경우 프로토 타입은 속성 형식으로 만 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c7d01f7359f4959eaf7c155ab3009451137cea" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">성공하면 &lt;code&gt;$i&lt;/code&gt; 는 인플레이션 객체를 보유하고 &lt;code&gt;$status&lt;/code&gt; 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6796a439d489957a46f406c119c69951b658a8" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;$i&lt;/code&gt; 는 인플레이션 개체를 보유하고 &lt;code&gt;$status&lt;/code&gt; 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="ec38a973765ca012bc6fc104f4b8ef70937c9614" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">성공하면 &lt;code&gt;$i&lt;/code&gt; 는 인플레이션 스트림을 보유하고 &lt;code&gt;$status&lt;/code&gt; 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6af1f82c337ffb0cd08fe17aa27a424683eba9a" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;$i&lt;/code&gt; 는 인플레이션 흐름을 유지하고 &lt;code&gt;$status&lt;/code&gt; 는 &lt;code&gt;Z_OK&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="f34b524a05a94eda9eec45a5e52e923221e9853a" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">성공하면 메모리 내 gzip 파일을 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$gzerrno&lt;/code&gt; 변수는 zlib 오류 코드를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="81c786291c2ee4a09a4250b9266414c8b0d7512f" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">성공하면 메모리 내 gzip 파일을 반환합니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환 하고 &lt;code&gt;$gzerrno&lt;/code&gt; 변수는 zlib 오류 코드를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a4a46b7cfb2406db4688f3a0ac9d424f4865a652" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">성공하면 압축되지 않은 gzip 파일을 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$gzerrno&lt;/code&gt; 변수는 zlib 오류 코드를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b546e05843ef34edaf10ea0003e7e36111124750" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">성공하면 압축되지 않은 gzip 파일을 반환합니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환 하고 &lt;code&gt;$gzerrno&lt;/code&gt; 변수는 zlib 오류 코드를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0f77490ec0c061ac3ae6e48aedaf1d41d413b95c" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">성공적인 경우, 초기화 압축 개체를 반환 &lt;code&gt;$z&lt;/code&gt; 와 &lt;code&gt;$status&lt;/code&gt; 의 &lt;code&gt;BZ_OK&lt;/code&gt; 목록 맥락에서입니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$z&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="afab4c4ec82d17a0d3d79f9261a109b3948960bc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="translated">성공하면 초기화 된 압축 개체 &lt;code&gt;$z&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; &lt;code&gt;BZ_OK&lt;/code&gt; 를 목록 컨텍스트 에 반환 합니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$z&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="003d593630b18abe30c9939f8d44076e1ce90807" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">성공적인 경우, 초기화 디플레이션 개체를 반환 &lt;code&gt;$d&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; 의 &lt;code&gt;Z_OK&lt;/code&gt; 목록 맥락에서입니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$d&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b9aa536487df74029d769a48c392afba84c5f24e" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="translated">성공하면 초기화 된 디플레이션 개체 &lt;code&gt;$d&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; &lt;code&gt;Z_OK&lt;/code&gt; 를 목록 컨텍스트 에 반환 합니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$d&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f86208486cf7be6093bb8b7191e306d09fb04dc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">성공 하면 목록 컨텍스트에서 &lt;code&gt;Z_OK&lt;/code&gt; 의 초기화 된 수축 스트림 &lt;code&gt;$d&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; 를 반환 합니다. 스칼라 컨텍스트에서는 디플레이션 스트림 &lt;code&gt;$d&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dab6fec9c63017bda459ab8c2b830d444d4282cf" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="translated">성공하면 초기화 된 디플레이션 스트림, &lt;code&gt;$d&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; 를 목록 컨텍스트에 반환합니다 . 스칼라 컨텍스트에서는 디플레이션 스트림 &lt;code&gt;$d&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="05d2c70da3dce90528345981e79d77f52c5f5ddb" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">성공적인 경우는 초기화 비 압축 개체를 반환 &lt;code&gt;$z&lt;/code&gt; 와 &lt;code&gt;$status&lt;/code&gt; 의 &lt;code&gt;BZ_OK&lt;/code&gt; 목록 맥락에서입니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$z&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d2677208b617b8465686e69e5dcf570d05d7bc09" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="translated">성공하면 초기화 된 압축 해제 개체 &lt;code&gt;$z&lt;/code&gt; 및 &lt;code&gt;$status&lt;/code&gt; &lt;code&gt;BZ_OK&lt;/code&gt; 를 목록 컨텍스트 에 반환 합니다. 스칼라 컨텍스트에서는 디플레이션 객체 &lt;code&gt;$z&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9905dac4184f6f7193dddf39eab6d02ad4540f03" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, &lt;code&gt;charblock()&lt;/code&gt; tries to do the opposite and interpret the argument as an old-style block name. On an ASCII platform, the return value is a</source>
          <target state="translated">코드 포인트가 될 수없는 인수가 제공되면, &lt;code&gt;charblock()&lt;/code&gt; 은 반대를 수행하고 인수를 구식 블록 이름으로 해석합니다. ASCII 플랫폼에서 반환 값은</target>
        </trans-unit>
        <trans-unit id="343b1f1d2e0b0c3a0e2a3dffed0083feca7d527c" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, charscript() tries to do the opposite and interpret the argument as a script name. The return value is a</source>
          <target state="translated">코드 포인트가 될 수없는 인수가 제공되는 경우 charscript ()는 반대로 수행하여 인수를 스크립트 이름으로 해석합니다. 반환 값은</target>
        </trans-unit>
        <trans-unit id="95ecffacfac149266d204e25c816abb11a57c234" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version</source>
          <target state="translated">핵심 Perl 버전에서 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="f6599907df819640d703f0de46e603f79205c931" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name for the current directory if the long pathname cannot be represented in the system codepage.</source>
          <target state="translated">핵심 Perl 버전에서 지원하는 경우이 함수는 시스템 코드 페이지에 긴 경로 이름을 표시 할 수없는 경우 현재 디렉토리에 대한 ANSI 경로 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2dcad45e80ec56c1bf86fbe3660554c170755ed1" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name if the full pathname cannot be represented in the system codepage.</source>
          <target state="translated">핵심 Perl 버전에서 지원하는 경우 전체 경로 이름을 시스템 코드 페이지에 표시 할 수없는 경우이 함수는 ANSI 경로 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="608c69ec5dc593b8e31469808e911c9b8c28fab1" translate="yes" xml:space="preserve">
          <source>If tcsh is your login shell then use the setenv command.</source>
          <target state="translated">tcsh가 로그인 쉘인 경우 setenv 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6722301f4d6d5b294f3eee46d693b203a67e97d7" translate="yes" xml:space="preserve">
          <source>If that doesn't make much sense, consider the analogy of a command pipeline. Say you have a shell script stored in the compressed file</source>
          <target state="translated">이것이 의미가 없다면 명령 파이프 라인의 비유를 고려하십시오. 압축 파일에 쉘 스크립트가 저장되어 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="e0190f66a1f731aebdad4c16cbe570cf5e90169e" translate="yes" xml:space="preserve">
          <source>If that doesn't suit your needs, you can explicitly set the filename used in the zip archive by specifying the &lt;a href=&quot;#File-Naming-Options&quot;&gt;Name&lt;/a&gt; option, like so</source>
          <target state="translated">필요에 맞지 않으면 다음 과 같이 &lt;a href=&quot;#File-Naming-Options&quot;&gt;Name&lt;/a&gt; 옵션 을 지정하여 zip 아카이브에 사용되는 파일 이름을 명시 적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce337d0a942d7a20e0ccbeff20a1fe0816cdba5" translate="yes" xml:space="preserve">
          <source>If that doesn't work (it relies on features of your stdio implementation), then you need something more like this:</source>
          <target state="translated">그래도 작동하지 않으면 (stdio 구현의 기능에 의존) 다음과 같은 것이 더 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ace9cde0327f63e0372278440efb1605dee92be3" translate="yes" xml:space="preserve">
          <source>If that doesn't work (some I/O implementations are particularly cantankerous), you might need something like this:</source>
          <target state="translated">그래도 작동하지 않으면 (일부 I / O 구현은 특히 무시할 수 있습니다) 다음과 같은 것이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b21d1151e484221dbc92ea1c2c56d3ec4082a9" translate="yes" xml:space="preserve">
          <source>If that doesn't work, give up on your stdio package and use sysread.</source>
          <target state="translated">그래도 작동하지 않으면 stdio 패키지를 포기하고 sysread를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0580b926aa13464eaf5222ef23bd075e2a2e806d" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file and then back.</source>
          <target state="translated">그래도 문제가 해결되지 않으면 파일의 다른 부분을 찾은 다음 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b4eb30982662b9e20db4ab3ae1666e6a76a6e58a" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file, reading something, and then seeking back.</source>
          <target state="translated">그래도 문제가 해결되지 않으면 파일의 다른 부분을 찾아서 무언가를 읽은 다음 다시 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="4c63d398b08eb5cb7f3f37514cbe92856008dc42" translate="yes" xml:space="preserve">
          <source>If that gives too much output every day, you may want to watch only for three modules. You can write</source>
          <target state="translated">매일 너무 많은 출력을 제공하는 경우 세 개의 모듈 만 감시 할 수 있습니다. 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b86041bbbb4cc3f3c7bede4e6b1882292fbc734e" translate="yes" xml:space="preserve">
          <source>If that module is not available, then HTTP::Tiny will search several system-specific default locations for a CA certificate file:</source>
          <target state="translated">해당 모듈을 사용할 수없는 경우 HTTP :: Tiny는 CA 인증서 파일에 대한 여러 시스템 별 기본 위치를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="0c73f5392dc820a97b0a4426cb998de73cb28f26" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">호출 모듈에서 해당 경고 범주가 &quot;FATAL&quot;로 설정되어 있으면 죽습니다. 그렇지 않으면 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="313f3cd86007469b883802f17e39affb3f8c8794" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the scope where &lt;code&gt;$object&lt;/code&gt; is first used then die. Otherwise return.</source>
          <target state="translated">&lt;code&gt;$object&lt;/code&gt; 가 처음 사용되는 범위에서 해당 경고 범주가 &quot;FATAL&quot;로 설정되어 있으면 죽습니다. 그렇지 않으면 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="dea88bea19f46633af98810723372bbf40ef70b7" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;undef&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt;) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;.</source>
          <target state="translated">&quot;비트&quot;기능이 활성화 된 경우 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ), 다섯 번째 TRUE 인수가 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이것은 호출자가 숫자 동작을 예상하고 있음을 나타냅니다. 네 번째 인수는 &lt;code&gt;undef&lt;/code&gt; 가됩니다. 해당 위치 ( &lt;code&gt;$_[3]&lt;/code&gt; )는 &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt; 사용을 위해 예약되어 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="961ec9e4bcc802a6b4814ce90b4ef69a38577267" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28 this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">&lt;code&gt;use feature 'bitwise'&lt;/code&gt; 을 사용 하거나 &lt;code&gt;use v5.28&lt;/code&gt; 을 사용하여 활성화 된 경우이 연산자는 항상 피연산자를 숫자로 취급합니다. Perl 5.28 이전에는이 ​​기능이 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 범주 에서 경고를 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="64579e960549e55b6b337ed2444636b1b80df4aa" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28. this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">&lt;code&gt;use feature 'bitwise'&lt;/code&gt; 을 사용 하거나 &lt;code&gt;use v5.28&lt;/code&gt; 을 사용하여 활성화 된 경우이 연산자는 항상 피연산자를 숫자로 취급합니다. Perl 5.28 이전. 이 기능은 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 범주 에서 경고를 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="27af0b330e562f7c0bf54946fd3c82282b9d8b27" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt;, always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt;. Until Perl 5.28, this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">&lt;code&gt;use feature 'bitwise'&lt;/code&gt; 을 사용 하거나 &lt;code&gt;use v5.28&lt;/code&gt; 경우 단항 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 항상 인수를 숫자로 취급하고 대체 형식의 연산자 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , 항상 인수를 문자열로 취급합니다. 따라서 &lt;code&gt;~0&lt;/code&gt; 및 &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 은 32 비트 플랫폼에서 2 ** 32-1을 제공하는 반면 &lt;code&gt;~.0&lt;/code&gt; 및 &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 은 모두 &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 합니다. Perl 5.28까지이 기능은 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 범주 에서 경고를 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="4493cf703f913ddbd099cc80db075e294c3617b1" translate="yes" xml:space="preserve">
          <source>If the &quot;external&quot; protocol is specified, the ping() method attempts to use the &lt;code&gt;Net::Ping::External&lt;/code&gt; module to ping the remote host. &lt;code&gt;Net::Ping::External&lt;/code&gt; interfaces with your system's default &lt;code&gt;ping&lt;/code&gt; utility to perform the ping, and generally produces relatively accurate results. If &lt;code&gt;Net::Ping::External&lt;/code&gt; if not installed on your system, specifying the &quot;external&quot; protocol will result in an error.</source>
          <target state="translated">&quot;외부&quot;프로토콜이 지정된 경우 ping () 메소드는 &lt;code&gt;Net::Ping::External&lt;/code&gt; 모듈을 사용하여 원격 호스트를 ping합니다. &lt;code&gt;Net::Ping::External&lt;/code&gt; 을 수행하기 위해 시스템의 기본 &lt;code&gt;ping&lt;/code&gt; 유틸리티 와 외부 인터페이스 를 수행하며 일반적으로 비교적 정확한 결과를 생성합니다. 경우 &lt;code&gt;Net::Ping::External&lt;/code&gt; 시스템에 설치하지 않을 경우는 &quot;외부&quot;프로토콜 오류가 발생합니다 지정.</target>
        </trans-unit>
        <trans-unit id="b022b01a378125712b4875c54365686882089f63" translate="yes" xml:space="preserve">
          <source>If the &quot;icmp&quot; protocol is specified, the ping() method sends an icmp echo message to the remote host, which is what the UNIX ping program does. If the echoed message is received from the remote host and the echoed information is correct, the remote host is considered reachable. Specifying the &quot;icmp&quot; protocol requires that the program be run as root or that the program be setuid to root.</source>
          <target state="translated">&quot;icmp&quot;프로토콜이 지정된 경우 ping () 메소드는 UNIX ping 프로그램이 수행하는 원격 호스트에 icmp echo 메시지를 보냅니다. 반향 메시지가 원격 호스트로부터 수신되고 반향 정보가 올 바르면 원격 호스트에 도달 할 수있는 것으로 간주됩니다. &quot;icmp&quot;프로토콜을 지정하려면 프로그램을 root로 실행하거나 프로그램을 root로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="20101303a26c3ad1b48f828a91b98648450fed40" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. This protocol does not require any special privileges.</source>
          <target state="translated">&quot;syn&quot;프로토콜이 지정되면 &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; 메서드는 TCP SYN 패킷을 원격 호스트로만 보낸 다음 즉시 반환합니다. syn 패킷이 성공적으로 전송되면 true 값을 반환하고 그렇지 않으면 false를 반환합니다. 참고 : 다른 프로토콜과 달리 반환 값은 전체 TCP 3 방향 핸드 셰이크가 아직 완료되지 않았을 수 있으므로 원격 호스트가 활성 상태인지 여부를 결정하지 않습니다. 원격 호스트는 지정된 시간 초과 내에 TCP ACK를 수신하는 경우에만 도달 가능한 것으로 간주됩니다. ACK 패킷 대기를 시작하려면 &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;를&lt;/a&gt; 사용하십시오.아래에 설명 된대로 방법. 병렬 TCP SYN 패킷을 전송하여 동시에 여러 대상의 도달 가능성을 판별하려면 &quot;tcp&quot;프로토콜 대신 &quot;syn&quot;프로토콜을 사용하십시오. 각 원격 호스트를 테스트하는 동안 차단되지 않습니다. 이 프로토콜에는 특별한 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3280089081e0a65bf27928777cbd13d99f6f66b" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the ping() method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the ack() method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. demo/fping is provided in this distribution to demonstrate the &quot;syn&quot; protocol as an example. This protocol does not require any special privileges.</source>
          <target state="translated">&quot;syn&quot;프로토콜이 지정되면 ping () 메소드는 TCP SYN 패킷 만 원격 호스트로 전송 한 후 즉시 리턴합니다. syn 패킷이 성공적으로 전송되면 true 값을 반환하고, 그렇지 않으면 false를 반환합니다. 참고 : 다른 프로토콜과 달리 반환 값은 전체 TCP 3 방향 핸드 셰이크가 아직 완료되지 않았기 때문에 원격 호스트가 활성 상태인지 여부를 결정하지 않습니다. 원격 호스트는 지정된 시간 초과 내에 TCP ACK를 수신 한 경우에만 연결할 수있는 것으로 간주됩니다. ACK 패킷 대기를 시작하려면 아래 설명 된대로 ack () 메소드를 사용하십시오. 병렬 TCP SYN 패킷을 전송하여 여러 대상의 도달 가능성을 동시에 판별하려면 &quot;tcp&quot;프로토콜 대신 &quot;syn&quot;프로토콜을 사용하십시오. 각 원격 호스트를 테스트하는 동안 차단되지 않습니다.데모 / fping은이 배포판에 제공되어 &quot;syn&quot;프로토콜을 예로 들어 설명합니다. 이 프로토콜에는 특별한 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7238cf0824cb05db1486e3141c96b6c642d31d1f" translate="yes" xml:space="preserve">
          <source>If the &quot;user:password&quot; stanza contains reserved characters, they must be percent-escaped:</source>
          <target state="translated">&quot;user : password&quot;스탠자에 예약 된 문자가 포함되어 있으면 퍼센트 이스케이프 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="318d6b49d6250a4816190433cf297845eb70cba7" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">$ crc 매개 변수가 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 crc 값이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="abcc06c7fad286b05b36114515df89ab3f899db0" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">$ crc 매개 변수가 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 crc 값이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9952545241861fa2f27861c631fbcce0156104" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;undef&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">$ crc 매개 변수가 &lt;code&gt;undef&lt;/code&gt; 이면 crc 값이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="302e31c3384df8bb8c31ef52a9d8291c6e65b38e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">$ must_be_file 인수가 제공되고 TRUE 인 경우 이미지가 파일 덤프에 속하는 것처럼 보이지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="32046e73c61ab6dfbb991e61669caae203688f3e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;undef&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">$ must_be_file 인수가 제공되고 TRUE이면 이미지가 파일 덤프에 속하는 것처럼 보이지 않는 한 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="865165ad77b0593f721d466f6d0ebabfe1d34482" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ string이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="688f0ecd47d63e749a9dd5c5cac2e57d32b8ed3a" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;undef&lt;/code&gt;, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">$ string이 &lt;code&gt;undef&lt;/code&gt; 이면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="076c07280263c9d15e3255695b14d837c538bc87" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;$input_filename_or_reference&amp;gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">&amp;lt;$ input_filename_or_reference&amp;gt; 매개 변수가 단순 스칼라 인 경우 파일 이름 인 것으로 가정합니다. 이 파일은 읽기 위해 열리고 입력 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e6e87357913d48be4073006d8b0866ceef5457d5" translate="yes" xml:space="preserve">
          <source>If the 'name' is '&amp;amp;' the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">'name'이 '&amp;amp;'인 경우 PAD의 해당 항목은 가능한 폐쇄를 나타내는 CV입니다.</target>
        </trans-unit>
        <trans-unit id="85fe5da8ded285f9f24f40aa84216e564fcc0c0a" translate="yes" xml:space="preserve">
          <source>If the 'name' is &lt;code&gt;&amp;amp;&lt;/code&gt; the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">'이름'이 &lt;code&gt;&amp;amp;&lt;/code&gt; PAD의 해당 항목이 가능한 폐쇄를 나타내는 CV 인 경우.</target>
        </trans-unit>
        <trans-unit id="cab0adefdbb8eb1bb75234fb2c512e529ae68ac9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;Mozilla::CA&quot;&gt;Mozilla::CA&lt;/a&gt; module is installed, HTTP::Tiny will use the CA file included with it as a source of trusted CA's. (This means you trust Mozilla, the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the toolchain used to install it, and your operating system security, right?)</source>
          <target state="translated">경우 &lt;a href=&quot;Mozilla::CA&quot;&gt;모질라 :: CA의&lt;/a&gt; 모듈이 설치되어 HTTP : 작은 신뢰할 수있는 CA의의 소스로 포함 된 CA 파일을 사용합니다. (이는 Mozilla :: CA의 작성자 인 Mozilla, Mozilla :: CA가있는 CPAN 미러, 설치에 사용 된 도구 체인 및 운영 체제 보안을 신뢰 함을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="45cb5ded2282f7dcd41dd84a212cb40770ba3961" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt; . This includes all files that get included via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">경우] &lt;b&gt;-W&lt;/b&gt; 플래그는 명령 라인에 사용되며, 관계없이 경고 로컬 중지 사용하지되었는지의 과정에 걸쳐 모든 경고있게 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 또는 &lt;code&gt;$^W =0&lt;/code&gt; . 여기에는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 통해 포함되는 모든 파일이 포함됩니다 . &quot;lint&quot;명령과 동등한 Perl로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="67f0f299ae6f5832a23754313dcbdf3deeea5b62" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt;. This includes all files that get included via &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">경우] &lt;b&gt;-W&lt;/b&gt; 플래그는 명령 라인에 사용되며, 관계없이 경고 로컬 중지 사용하지되었는지의 과정에 걸쳐 모든 경고있게 &lt;code&gt;no warnings&lt;/code&gt; 또는 &lt;code&gt;$^W =0&lt;/code&gt; . 여기에는 &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 를 통해 포함되는 모든 파일이 포함됩니다 . &quot;lint&quot;명령에 해당하는 Perl이라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="544ad5b88e657a2b04055790eb69377a583771e6" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">는 IF &lt;b&gt;위한 ExtUtils :: 삽입&lt;/b&gt; 모듈은에서를 검색 할 수 있습니다, 당신의 펄 배포판의 일부가 아닌 &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; 이 문서에서 제공된 경우 (당신의 펄 배포판, 5.004 이상을 실행 중이며 이미 가지고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e9d6651b3488b419cbb556cfd921ab740de960ba" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;https://metacpan.org/pod/ExtUtils::Embed&quot;&gt;https://metacpan.org/pod/ExtUtils::Embed&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">는 IF &lt;b&gt;:: 임베드위한 ExtUtils&lt;/b&gt; 모듈이 펄 배포판의 일부가 아닌, 당신은에서를 검색 할 수 있습니다 &lt;a href=&quot;https://metacpan.org/pod/ExtUtils::Embed&quot;&gt;https://metacpan.org/pod/ExtUtils::Embed&lt;/a&gt; 이 문서는 당신의 펄 배포판에서 제공된 경우 당신에게 다음 (있는 거 실행 5.004 이상이고 이미 가지고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="40e97ddfc26315857071022b6a58a8c5330f9bda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;-S&quot;&lt;/code&gt; or &lt;code&gt;-&quot;S&quot;&lt;/code&gt; switch is present</source>
          <target state="translated">는 IF &lt;code&gt;&quot;-S&quot;&lt;/code&gt; 또는 &lt;code&gt;-&quot;S&quot;&lt;/code&gt; 스위치가 존재</target>
        </trans-unit>
        <trans-unit id="bcfb6b5f36fe9b097b6d4cfdd0d5b8347d4498d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot; the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt; , because they can tell a program that their SHELL is</source>
          <target state="translated">경우] &lt;code&gt;#!&lt;/code&gt; line에는 단어 &quot;perl&quot;이나 단어 &quot;indir&quot;이 포함되지 않습니다 &lt;code&gt;#!&lt;/code&gt; Perl 인터프리터 대신 실행됩니다. 이것은 약간 기괴하지만, &lt;code&gt;#!&lt;/code&gt; 를하지 않는 기계를 사용하는 사람들에게 도움이됩니다 ! 프로그램에 SHELL이 있음을 알릴 수 있기 때문에</target>
        </trans-unit>
        <trans-unit id="604833b3bed6d2cdd6969680b3567a88335ca6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot;, the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt;, because they can tell a program that their SHELL is</source>
          <target state="translated">경우] &lt;code&gt;#!&lt;/code&gt; 줄에 &quot;perl&quot;이라는 단어 나 &quot;indir&quot;이라는 단어가 포함되어 있지 않습니다.이 프로그램은 &lt;code&gt;#!&lt;/code&gt; Perl 인터프리터 대신 실행됩니다. 이것은 약간 기이하지만 &lt;code&gt;#!&lt;/code&gt; , 프로그램에 자신의 SHELL이</target>
        </trans-unit>
        <trans-unit id="263d47f71006c52e232d04a65727d383732b439a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt; .</source>
          <target state="translated">경우] &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; 변수가 참 값으로 설정되고, 어떠한 추론는 UTF8 / 16 / (32)에 적용되지 않으며, 그 결과는 용의자 한정한다 &lt;code&gt;ascii&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353ab226583ec1c10fd3aef68a690f9c11e31e86" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; 변수가 참 값으로 설정되고, 어떠한 추론는 UTF8 / 16 / (32)에 적용되지 않으며, 그 결과는 용의자 한정한다 &lt;code&gt;ascii&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ad3f883582e4c647a3748b90c080c6161d8d898" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle, the compressed data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">경우] &lt;code&gt;$input&lt;/code&gt; 파라미터는 핸들이며, 압축 데이터는 그로부터 판독 될 것이다. 문자열 '-'는 표준 입력의 별명으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe51b5d7f895a2847c85f0654d41581417ffbf8a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the</source>
          <target state="translated">경우] &lt;code&gt;$input&lt;/code&gt; 파라미터는 파일명이며, 값 &lt;code&gt;$input&lt;/code&gt; 에 사용될</target>
        </trans-unit>
        <trans-unit id="7b21ca0ba17da1de5557b8c2561a39c672e345ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a scalar, it is assumed to be a filename. This file will be opened for reading and the compressed data will be read from it.</source>
          <target state="translated">경우] &lt;code&gt;$input&lt;/code&gt; 매개 변수는 스칼라이고, 파일명 것으로 가정된다. 이 파일은 읽기 위해 열리고 압축 된 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f3e74e002fc30cd5c7fe440b4d039e155035cde7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, the</source>
          <target state="translated">는 IF &lt;code&gt;$input&lt;/code&gt; 매개 변수는 파일 이름은 아니다</target>
        </trans-unit>
        <trans-unit id="8c806bbadc7d9dce5be50aca2c285d39455523f0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a filehandle, the input data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">는 IF &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수는 파일 핸들이며, 입력 데이터는 그것에서 읽을 수 있습니다. 문자열 '-'는 표준 입력의 별명으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c3cf35342f4c34421c4e26433c64dd55c114d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">는 IF &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수는 간단한 스칼라, 파일 이름으로 간주됩니다. 이 파일은 읽기 위해 열리고 입력 데이터는 여기에서 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="573972f31f94bcc5ce697159aca1ad87294adc22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">는 IF &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수는 다른 유형, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="95490becd5727b45000e58c74b6e1c6ae0970e6a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">는 IF &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 매개 변수는 다른 유형, &lt;code&gt;undef&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4cccbcdf0c65cc8f40030797afae3d268325f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt; ; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;$need&lt;/code&gt; 인수가 지정되어 그것이 (패키지의 $ VERSION 변수에 의해 정의 된 바와 같이) 현재의 버전과 동일하거나보다 큰 것으로 확인한다 &lt;code&gt;$need&lt;/code&gt; ; 그렇지 않은 경우 사망합니다. 이 메소드는 &lt;code&gt;VERSION&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 형식에 의해 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a6a3d7b2f8102b10a0c4c1e7ed04569381bcca7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt;; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;$need&lt;/code&gt; 인수가 지정되어 그것이 (패키지의 $ VERSION 변수에 의해 정의 된 바와 같이) 현재의 버전과 동일하거나보다 큰 것으로 확인한다 &lt;code&gt;$need&lt;/code&gt; ; 그렇지 않으면 죽을 것입니다. 이 메서드는 &lt;code&gt;VERSION&lt;/code&gt; 형식의 &lt;code&gt;use&lt;/code&gt; 의해 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e612a8de15e6e3ebce7b57945845f8b7dc29222" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">경우] &lt;code&gt;$output&lt;/code&gt; 파라미터는 핸들이며, 압축 데이터가 기록된다. 문자열 '-'는 표준 출력의 별명으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1b12c1cf4a15c9b6156dfb74283d87ea201fd5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">경우] &lt;code&gt;$output&lt;/code&gt; 파라미터 단순한 스칼라이를 파일명 것으로 가정된다. 이 파일은 쓰기 위해 열리고 압축 된 데이터가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="59757227a4fe8fdd27a95b595bd3ff8c8a163939" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; undef를 반환합니다 :: 새.</target>
        </trans-unit>
        <trans-unit id="837bf156c80a35ed162d613d42ade6562e2894a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt;::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; undef를 반환합니다 :: 새.</target>
        </trans-unit>
        <trans-unit id="cadc0cd9a0990edba8eef6811ffbf43a8f495bbc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: 새가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="196148e89da9cfbfe329bbc55db61beb8a5968d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: 새가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3e714bc9d0ca60a68f45566881bf3e6145bc1ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; undef를 반환합니다 :: 새.</target>
        </trans-unit>
        <trans-unit id="08b9bed1be5f46be48a5455f8dcb9b223a356d8d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; undef를 반환합니다 :: 새.</target>
        </trans-unit>
        <trans-unit id="876928fea8ebdaa591df8075f9c404fb23d04a28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: undef를 반환합니다 새.</target>
        </trans-unit>
        <trans-unit id="5fc1018e332332481571232c14a9c9881c4640fa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형 인, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: undef를 반환합니다 새.</target>
        </trans-unit>
        <trans-unit id="38552f9e6ec9c67c09d8bddc8275dd8bdd5d8803" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형이다 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: 새가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1b6039aa2ae2d0c506fff4cceb4d05934eba7f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt;::new will return undef.</source>
          <target state="translated">는 IF &lt;code&gt;$output&lt;/code&gt; 매개 변수는 다른 유형이다 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: 새가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc18113fea92f93f29a91b56f7f76e4dd3fc2c3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 파일 핸들이며, 압축 된 데이터가 기록됩니다. 문자열 '-'는 표준 출력의 별명으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b000e8d3bf3971a53c3d271eb802381bc6b99814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the uncompressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 파일 핸들이며, 압축되지 않은 데이터가 기록됩니다. 문자열 '-'는 표준 출력의 별명으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4843925dd2f30aabd060449fee92e5566394585d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 간단한 스칼라, 파일 이름으로 간주됩니다. 이 파일은 쓰기 위해 열리고 압축 된 데이터가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="82c61471bec0e7ab85ea6d51b841a7cd924bb91c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the uncompressed data will be written to it.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 간단한 스칼라, 파일 이름으로 간주됩니다. 이 파일은 쓰기 위해 열리고 압축되지 않은 데이터가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="171f6debdc3c19e16dbddc9b4ccb5eb09a1f9e1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 다른 유형, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7817f217aafc05c7b99d4b799af6c64aa75fd355" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">는 IF &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 매개 변수는 다른 유형, &lt;code&gt;undef&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2259a2e974894cbf8831f8e74de6dee67d652d9c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">는 IF &lt;code&gt;$regexp&lt;/code&gt; 변수가 코드 식을 포함, 사용자는 임의의 펄 코드를 실행할 수 있습니다. 예를 들어, 일부 조커는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; 검색 할 수 있습니다 . 파일을 지우려면 이런 의미에서 보간과 코드 표현식의 조합</target>
        </trans-unit>
        <trans-unit id="f36385595fbe40440c2dd4edd9a51197f185c95d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;system('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">&lt;code&gt;$regexp&lt;/code&gt; 변수에 코드 표현식이 포함되어 있으면 사용자는 임의의 Perl 코드를 실행할 수 있습니다. 예를 들어, 어떤 조커는 &lt;code&gt;system('rm -rf *');&lt;/code&gt; 파일을 지우려면. 이런 의미에서 보간과 코드 표현식의 조합은</target>
        </trans-unit>
        <trans-unit id="cead10e67b406c29ab565d567b9609063d5776ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;$z&lt;/code&gt; 오브젝트 버퍼와 관련되며,이 방법은 리턴 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e56611d957be7289e8984a9c8a2d5654cbe3409" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$z&lt;/code&gt; 객체가 버퍼와 ​​연결되어 있으면 이 메서드는 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="58dcaddb355cecd931c021172a4bedf908dd76a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$z&lt;/code&gt; 객체가 파일 또는 파일 핸들과 연결되어 있으면 &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 는 기본 파일 설명자를 반환합니다. &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출 되면 &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fd0509a249a2be85806909612af8871ff25800ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;fileno&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;close&lt;/code&gt; method is called &lt;code&gt;fileno&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$z&lt;/code&gt; 개체가 파일 또는 파일 핸들과 연결되어 있으면 &lt;code&gt;fileno&lt;/code&gt; 는 기본 파일 설명자를 반환합니다. &lt;code&gt;close&lt;/code&gt; 메소드가 호출 되면 &lt;code&gt;fileno&lt;/code&gt; 는 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c8acbfda88a1601bef7d039c62529de82f9b15c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, this method returns the current autoflush setting for the underlying filehandle. If &lt;code&gt;EXPR&lt;/code&gt; is present, and is non-zero, it will enable flushing after every write/print operation.</source>
          <target state="translated">는 IF &lt;code&gt;$z&lt;/code&gt; 객체가 파일 또는 파일 핸들과 연관되어,이 방법은 기본 파일 핸들의 현재의 autoflush 설정을 반환합니다. 경우 &lt;code&gt;EXPR&lt;/code&gt; 이 존재하고, 0이 아닌, 그것은 모든 쓰기 / 인쇄 작업 후 세척 할 수있게된다.</target>
        </trans-unit>
        <trans-unit id="4f22b38f141c1394908e5c44c3cf641e6013a601" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(*ACCEPT)&lt;/code&gt; is inside of capturing groups then the groups are marked as ended at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; was encountered. For instance:</source>
          <target state="translated">만약 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 시점에서 종료로 다음 그룹이 표시되어 그룹 포착 내부 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 가 발생 하였다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="d96d9f9f8c91a22bdf7e1a3536eeb47596adfe1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is disabled, the comment field can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">는 IF &lt;code&gt;-Strict&lt;/code&gt; 옵션을 사용하지 주석 필드는 NULL 문자를 제외한 모든 문자를 포함 할 수 있습니다. 널 문자가 존재하면 필드는 첫 번째 NULL에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8a0625a9517209d9c735d420fbb7b372c06cae56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, &lt;code&gt;$string&lt;/code&gt; can only consist of ISO 8859-1 characters.</source>
          <target state="translated">경우 &lt;code&gt;-Strict&lt;/code&gt; 옵션이 활성화되어, &lt;code&gt;$string&lt;/code&gt; 에만 ISO 8859-1 문자로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e727e67c9a9b626ab111993b625d6fae0b44b5e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, the comment can only consist of ISO 8859-1 characters plus line feed.</source>
          <target state="translated">경우 &lt;code&gt;-Strict&lt;/code&gt; 옵션이 활성화되어, 코멘트는 ISO 8859-1 문자와 줄 바꿈으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687858bb0364e03075315214e49915f4063efd20" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-i&lt;/code&gt; switch is present but no extension for a backup copy is given, then inplace editing creates a new version of a file; the existing copy is not deleted. (Note that if an extension is given, an existing file is renamed to the backup file, as is the case under other operating systems, so it does not remain as a previous version under the original filename.)</source>
          <target state="translated">경우 &lt;code&gt;-i&lt;/code&gt; 스위치가 존재하지만 백업 사본에 대한 확장을 지정하지, 다음 올바른 위치 편집 파일의 새 버전을 생성; 기존 사본은 삭제되지 않습니다. 확장명이 제공되면 다른 운영 체제의 경우와 마찬가지로 기존 파일의 이름이 백업 파일로 바뀌므로 원래 파일 이름에서 이전 버전으로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee96a00037808dbdc95697095ca0c22513112f61" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-v&lt;/code&gt; option is present, column 1 is expanded to include</source>
          <target state="translated">경우 &lt;code&gt;-v&lt;/code&gt; 옵션이 존재, 1 열을 포함하도록 확장</target>
        </trans-unit>
        <trans-unit id="8e7588692ec4768237d3953ea6a6c6164462271b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;...Host&lt;/code&gt; argument is in this special form and the corresponding &lt;code&gt;...Service&lt;/code&gt; or &lt;code&gt;...Port&lt;/code&gt; argument is also defined, the one parsed from the &lt;code&gt;...Host&lt;/code&gt; argument will take precedence and the other will be ignored.</source>
          <target state="translated">는 IF &lt;code&gt;...Host&lt;/code&gt; 인수가이 특별한 형태이며, 해당 &lt;code&gt;...Service&lt;/code&gt; 또는 &lt;code&gt;...Port&lt;/code&gt; 인수는 정의의에서 구문 분석 한 &lt;code&gt;...Host&lt;/code&gt; 인수 우선하고 다른 하나는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4eacdf4c079f427c39ca731549e9ca77acc2ef88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier is in effect ...</source>
          <target state="translated">는 IF &lt;code&gt;/a&lt;/code&gt; 수정이 적용됩니다 ...</target>
        </trans-unit>
        <trans-unit id="e67bdd40f66f8b280f344ca0cd6466ca71728404" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier, is in effect ...</source>
          <target state="translated">는 IF &lt;code&gt;/a&lt;/code&gt; 수정, 효과에 ...</target>
        </trans-unit>
        <trans-unit id="45a06195ed61d1ad05b053f7cec670bab3d1b47d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the</source>
          <target state="translated">만약 &lt;code&gt;/c&lt;/code&gt; 수정 지정되면,</target>
        </trans-unit>
        <trans-unit id="d41dfd0659ebb24e37b486d073bb483e95d40816" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the characters to be transliterated are the ones NOT in</source>
          <target state="translated">는 IF &lt;code&gt;/c&lt;/code&gt; 수정자가 지정, 문자는 자역하는 사람 NOT에 있습니다</target>
        </trans-unit>
        <trans-unit id="d32f95725bf186859393e8afb0285f817b2b2c4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is specified, any characters specified by</source>
          <target state="translated">는 IF &lt;code&gt;/d&lt;/code&gt; 를 수정자가 지정된 모든 문자에 의해 지정</target>
        </trans-unit>
        <trans-unit id="61f363164df63c08b01c2f8d842eb83178238fca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is used, the</source>
          <target state="translated">는 IF &lt;code&gt;/d&lt;/code&gt; 개질제를 사용하는 경우,</target>
        </trans-unit>
        <trans-unit id="228d53bdcd18fe101fa332b95e05c49d501e9bd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">는 IF &lt;code&gt;/g&lt;/code&gt; 옵션을 사용하지 않고, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 리스트 컨텍스트에 패턴에서 괄호 일치 하위 표현식 구성된리스트 (반환 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (참고로 여기에 &lt;code&gt;$1&lt;/code&gt; 등 설정되어 있습니다). 패턴에 괄호가 없으면 리턴 값은 성공을위한 목록 &lt;code&gt;(1)&lt;/code&gt; 입니다. 괄호를 사용하거나 사용하지 않고 실패하면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4847a17bc99ad2bd83a46004a16f9056518239f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;m//&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">는 IF &lt;code&gt;/g&lt;/code&gt; 옵션을 사용하지 않고, &lt;code&gt;m//&lt;/code&gt; 리스트 컨텍스트에 패턴에서 괄호 일치 하위 표현식 구성된리스트 (반환 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (참고로 여기에 &lt;code&gt;$1&lt;/code&gt; 등 설정 됨). 패턴에 괄호가 없으면 반환 값은 성공 목록 &lt;code&gt;(1)&lt;/code&gt; 입니다. 괄호가 있거나없는 경우 실패시 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3f80ef36f0d767bd1b67ec24494f102a4ec7c1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is present, a new copy of the string is made and its characters transliterated, and this copy is returned no matter whether it was modified or not: the original string is always left unchanged. The new copy is always a plain string, even if the input string is an object or a tied variable.</source>
          <target state="translated">는 IF &lt;code&gt;/r&lt;/code&gt; (비파괴) 옵션이 존재하는 문자열의 새 복사본을 만들어 그 문자는 자역,이 사본은 상관없이이 수정되었는지 여부를 반환되지 않습니다되어 원래 문자열은 항상 변경되지 않습니다. 입력 문자열이 객체이거나 묶인 변수 인 경우에도 새 복사본은 항상 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a9229f75d9765b6c9e80a754666b4ec3786ce235" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is used then it runs the substitution on a copy of the string and instead of returning the number of substitutions, it returns the copy whether or not a substitution occurred. The original string is never changed when &lt;code&gt;/r&lt;/code&gt; is used. The copy will always be a plain string, even if the input is an object or a tied variable.</source>
          <target state="translated">는 IF &lt;code&gt;/r&lt;/code&gt; (비파괴) 옵션은 다음 사용은 문자열의 복사본을 대체를 실행하고 대신 대체의 수를 반환하는, 그것은 대체가 발생하는지 여부를 복사본을 반환합니다. &lt;code&gt;/r&lt;/code&gt; 을 사용할 때 원래 문자열은 변경되지 않습니다 . 입력이 객체 또는 묶인 변수 인 경우에도 복사본은 항상 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c65b706b15e1b297f5f1c28d84acdcb1bb86c23a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/s&lt;/code&gt; modifier is specified, sequences of characters, all in a row, that were transliterated to the same character are squashed down to a single instance of that character.</source>
          <target state="translated">는 IF &lt;code&gt;/s&lt;/code&gt; 의 수정을 지정, 같은 문자로 음역 된 문자 시퀀스, 연속 모두, 그 문자의 단일 인스턴스 아래로 숙청된다.</target>
        </trans-unit>
        <trans-unit id="98015ad9cab949396e11223bb4b809b828f32a12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADLER32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">는 IF &lt;code&gt;ADLER32&lt;/code&gt; 의 옵션이 객체의 생성자에 사용할 수 없습니다,이 메소드는 항상 0을 반환합니다;</target>
        </trans-unit>
        <trans-unit id="e7e3cc3b120420d3fe3e5903cbe74d0d544abd6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to false, the output buffers in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods will be truncated before uncompressed data is written to them.</source>
          <target state="translated">는 IF &lt;code&gt;AppendOutput&lt;/code&gt; 의 옵션이 false로 설정되어있는 출력 버퍼 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 과 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 압축되지 않은 데이터가 그들에 기록되기 전에 방법을 잘립니다.</target>
        </trans-unit>
        <trans-unit id="dc67d2e9493b30b20a1a27f63c6bc36f875e42fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">경우] &lt;code&gt;AppendOutput&lt;/code&gt; 의 옵션이 생성자 true로 설정되어 &lt;code&gt;$d&lt;/code&gt; 오브젝트, 압축 데이터에 부가한다 &lt;code&gt;$output&lt;/code&gt; . False 인 경우 압축 된 데이터를 기록하기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="894535f526af30d884a71d76dd392439745e70a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">경우] &lt;code&gt;AppendOutput&lt;/code&gt; 의 옵션이 생성자 true로 설정되어 &lt;code&gt;$d&lt;/code&gt; 오브젝트, 압축 데이터에 부가한다 &lt;code&gt;$output&lt;/code&gt; . false이면 압축 된 데이터가 기록되기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="241ec910d4c3fc198870214959a19e4587117b91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">는 IF &lt;code&gt;AppendOutput&lt;/code&gt; 의 옵션이 오브젝트의 생성자에서 true로 설정되어, 압축되지 않은 데이터에 추가됩니다 &lt;code&gt;$output&lt;/code&gt; . False 인 경우 압축되지 않은 데이터가 기록되기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="41b5894e323b1e78083ec3fd1e539c059bbe6e54" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">는 IF &lt;code&gt;AppendOutput&lt;/code&gt; 의 옵션이 오브젝트의 생성자에서 true로 설정되어, 압축되지 않은 데이터에 추가됩니다 &lt;code&gt;$output&lt;/code&gt; . false이면 압축되지 않은 데이터가 기록되기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="23a4bdafd5b4aee2bfba5a403d17509d788319bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Archive::Tar&lt;/code&gt; module is installed and either the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files.</source>
          <target state="translated">경우 &lt;code&gt;Archive::Tar&lt;/code&gt; 모듈이 설치되어 중 하나입니다 &lt;code&gt;uncompress&lt;/code&gt; 또는 &lt;code&gt;gunzip&lt;/code&gt; 이 프로그램을 사용할 수 있습니다, 당신은 읽을 이러한 해결 방법 중 하나를 사용할 수 &lt;code&gt;.tar.Z&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="da717ba776ac7b943780ea377cd85c35cc7f2655" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Bzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 :: Bzip2의 객체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2451f14f493fd0c1b2a744f1ca680885802c97fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Deflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 :: 공기를 빼다 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a262cca6ca624ccbcc230f0a9a299f301469ea87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Gzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 : Gzip으로 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e1abc2a1019c01d985ed7b90e95e969f6f299bf2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::RawDeflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 :: RawDeflate 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ea66329ad2b4187630d779016bfcf01873661d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Zip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 : 우편 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="efa0131be286b8ee087293f106c69cc7176b941b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 :: AnyInflate 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d7295924866c46c6268e8a714d1d64a580c31683" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyUncompress object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">자동 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 :: AnyUncompress 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d590344cfdd3022553efe336602191d1dbf477b6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Bunzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 :: bunzip2는 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d48a250e20975c54010e5628db4f5baad9a34122" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Gunzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축을 풉니 다 : gunzip이 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="52452c9550cd8363c6c8237af362cc345e53f457" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Inflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 :: 팽창 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="34f0502573716752984911463b9f0d1cdbf46468" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::RawInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 :: RawInflate 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a69474f66acefa05c78e7afea37ef49d0b67b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Unzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; IO :: 압축 풀기 : 압축을 풀고 개체를 만들 때 옵션이 사용 가능하고, 객체가 파일과 연관된, 기본 파일은 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94bf536d1f0d5c1626e7c3b73aa7b49722d0966b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is set in &lt;code&gt;gflags&lt;/code&gt; then it indicates that the caller only knows about the genuine GV version of &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit will always be set in &lt;code&gt;*ckflags_p&lt;/code&gt;, regardless of the check function's recorded requirements. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is clear in &lt;code&gt;gflags&lt;/code&gt; then it indicates the caller knows about the possibility of passing something other than a GV as &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit may be either set or clear in &lt;code&gt;*ckflags_p&lt;/code&gt;, indicating the check function's recorded requirements.</source>
          <target state="translated">&lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 비트가 &lt;code&gt;gflags&lt;/code&gt; 에 설정되어 있으면 호출자가 &lt;code&gt;namegv&lt;/code&gt; 의 정품 GV 버전에 대해서만 알고 있으므로 체크 함수의 기록 된 요구 사항에 관계없이 해당 비트가 항상 &lt;code&gt;*ckflags_p&lt;/code&gt; 에 설정 됨을 나타냅니다 . 는 IF &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 의 비트에 분명하다 &lt;code&gt;gflags&lt;/code&gt; 다음은 호출자가 같은 GV가 아닌 다른 뭔가를 통과의 가능성에 대해 알고 나타냅니다 &lt;code&gt;namegv&lt;/code&gt; 하고 그에 따라 대응하는 비트 중 하나를 세트로 또는에서 취소 할 수 있습니다 &lt;code&gt;*ckflags_p&lt;/code&gt; 체크 기능의 기록 요구 사항을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4c82a8f9dcfd859cf531bf1cebfe4f1f3355707c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; environment variable does not exist, and if &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt;. If &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown. Note that at the time of writing, the only useful values are 1, which will tell &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; to guess, or &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; - if you want to use a newer JSON module, see &lt;a href=&quot;#CPAN_META_JSON_BACKEND&quot;&gt;&quot;CPAN_META_JSON_BACKEND&quot;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; 의 환경 변수가하는 존재하지, 그리고 경우 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 의 환경 변수가 존재, 사실과 &quot;JSON : PP&quot;아니다, 다음 &lt;a href=&quot;json&quot;&gt;JSON의&lt;/a&gt; 모듈 (버전 2.5 이상)로드하고 해석하는 데 사용됩니다 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 을 . 경우 &lt;a href=&quot;json&quot;&gt;JSON을&lt;/a&gt; 설치하거나 너무 오래되지 않은 예외가 발생합니다. 작성 당시 유일하게 유용한 값은 1이며 &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 에 추측하도록 지시하거나 &lt;a href=&quot;JSON::XS&quot;&gt;JSON :: XS입니다&lt;/a&gt; . 최신 JSON 모듈을 사용하려면 &lt;a href=&quot;#CPAN_META_JSON_BACKEND&quot;&gt;&quot;CPAN_META_JSON_BACKEND&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5ac2a9fbc05192cf46afe1261683a81419aaa4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CRC32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">경우 &lt;code&gt;CRC32&lt;/code&gt; 의 옵션이 객체의 생성자에 사용할 수 없습니다,이 메소드는 항상 0을 반환합니다;</target>
        </trans-unit>
        <trans-unit id="1078abcc96e5bc5e00a4c013f64ebcf42ad64647" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">는 IF &lt;code&gt;ConsumeInput&lt;/code&gt; 의 때 옵션이 true로 설정되어있는 &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; 객체가 생성되면, &lt;code&gt;$input&lt;/code&gt; 매개 변수에 의해 수정 &lt;code&gt;inflate&lt;/code&gt; . 완료되면 인플레이션 후 입력 버퍼에 남아있는 내용이 포함됩니다. 실제로 이것은 반환 상태가 &lt;code&gt;Z_OK&lt;/code&gt; 일 때 &lt;code&gt;$input&lt;/code&gt; 매개 변수에 빈 문자열이 포함되고 반환 상태가 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 인 경우 &lt;code&gt;$input&lt;/code&gt; 매개 변수는 수축 된 데이터 후 입력 버퍼에 저장된 내용을 포함합니다 (있는 경우). 흐름.</target>
        </trans-unit>
        <trans-unit id="fc67951579ca54e84043acbb0bb761bab4628359" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">는 IF &lt;code&gt;ConsumeInput&lt;/code&gt; 의 때 옵션이 true로 설정되어있는 &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; 객체가 생성되면, &lt;code&gt;$input&lt;/code&gt; 매개 변수에 의해 수정 &lt;code&gt;inflate&lt;/code&gt; . 완료되면 인플레이션 후 입력 버퍼의 나머지 부분이 포함됩니다. 실제로 이는 반환 상태가 &lt;code&gt;Z_OK&lt;/code&gt; 일 때 &lt;code&gt;$input&lt;/code&gt; 매개 변수에 빈 문자열이 포함되고 반환 상태가 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 일 때 &lt;code&gt;$input&lt;/code&gt; 매개 변수에 압축 된 데이터 이후에 입력 버퍼에 저장된 내용 (있는 경우)이 포함됨을 의미합니다. 흐름.</target>
        </trans-unit>
        <trans-unit id="6a12981a50e52bd8360e58342fda216fd19888ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; bit is</source>
          <target state="translated">경우 &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; 비트입니다</target>
        </trans-unit>
        <trans-unit id="62a22e2f1c67e582e14dc75490b36c8927949628" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD&lt;/code&gt; flag is supplied, the SV may be a reference to a CV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="translated">경우] &lt;code&gt;G_METHOD&lt;/code&gt; 의 플래그가 공급되면, SV는 CV 또는 참조 할 수있다 &lt;code&gt;SvPV(sv)&lt;/code&gt; 호출 메소드의 이름으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="60434689d4799ff053da9df2280e53454e60d84f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="translated">경우] &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; 플래그가 공급되고, &lt;code&gt;SvPV(sv)&lt;/code&gt; 호출에있어서의 이름으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="1bd3991b928d2bed7eef1e209952394cc1a3b16f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">는 IF &lt;code&gt;Listen&lt;/code&gt; 인수가 주어하지만 거짓되고, 큐 크기는 5로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1143100ee61e97ea2197747ccc58abb62c39ba7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Minimal&lt;/code&gt; option is set to true, this option will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;Minimal&lt;/code&gt; 옵션이 true로 설정되어,이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ef4eef7ec7365669f7a6fdd21df15f840876c21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_ELLIPSES&lt;/code&gt; flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">는 IF &lt;code&gt;PERL_PV_PRETTY_ELLIPSES&lt;/code&gt; 의 플래그가 설정되고 문자열의 모든 문자가 다음 출력 줄임표했다입니다 &lt;code&gt;...&lt;/code&gt; 문자열에 추가됩니다. 이것은 인용 된 후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49e3d7b68bb44fc1098b8d656037c9de9b76dfb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_QUOTE&lt;/code&gt; flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the &lt;code&gt;PERL_PV_PRETTY_LTGT&lt;/code&gt; flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">는 IF &lt;code&gt;PERL_PV_PRETTY_QUOTE&lt;/code&gt; 의 플래그가 설정되어 결과는 이중 이스케이프 문자열에있는 큰 따옴표로 인용 될 것이다. 그렇지 않으면 &lt;code&gt;PERL_PV_PRETTY_LTGT&lt;/code&gt; 플래그가 설정된 경우 결과는 꺾쇠 괄호로 묶입니다.</target>
        </trans-unit>
        <trans-unit id="113ffd5bd789ac46d3a6013680e6ad870731e0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;REQUEST_METHOD&lt;/code&gt; environment variable is set, then this might be a CGI process and &lt;code&gt;HTTP_PROXY&lt;/code&gt; would be set from the &lt;code&gt;Proxy:&lt;/code&gt; header, which is a security risk. If &lt;code&gt;REQUEST_METHOD&lt;/code&gt; is set, &lt;code&gt;HTTP_PROXY&lt;/code&gt; (the upper case variant only) is ignored.</source>
          <target state="translated">는 IF &lt;code&gt;REQUEST_METHOD&lt;/code&gt; 의 환경 변수가 설정되고,이는 CGI 프로세스 일 수 있으며 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 를 으로부터 설정됩니다 &lt;code&gt;Proxy:&lt;/code&gt; 헤더를 보안 위험이다. 경우 &lt;code&gt;REQUEST_METHOD&lt;/code&gt; 가 설정되어 &lt;code&gt;HTTP_PROXY&lt;/code&gt; (위의 경우 변형 만 해당) 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b0cd9b590461a3324fa8fa68396f36ebee97301" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Strict&lt;/code&gt; is on it will automatically enable this option.</source>
          <target state="translated">경우 &lt;code&gt;Strict&lt;/code&gt; 에 자동이 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a5a03dfea212cb5b29a1fbf2d5e717d48359451" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;YAML&lt;/code&gt; or the &lt;code&gt;YAML::Syck&lt;/code&gt; module is installed a record of the internal state of all modules is written to disk after each step. The files contain a signature of the currently running perl version for later perusal.</source>
          <target state="translated">경우] &lt;code&gt;YAML&lt;/code&gt; 또는 &lt;code&gt;YAML::Syck&lt;/code&gt; 모듈은 모든 모듈의 내부 상태의 기록 설치된 각 단계 후에 디스크에 기록된다. 파일에는 나중에 실행하기 위해 현재 실행중인 perl 버전의 서명이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82a6fc0a2f95bf7629d02360284d3c7a1ca8a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt; . If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">는 IF &lt;code&gt;can&lt;/code&gt; false를 반환, 그 다음이 전달됩니다 &lt;code&gt;ok&lt;/code&gt; . 그것은 사실, 그 다음 더 큰 표현 반환하는 경우 &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; 을 반환 1, &lt;code&gt;ok&lt;/code&gt; 당신이 기대하는 것처럼, 성공의 간단한 신호로 볼 수있다.</target>
        </trans-unit>
        <trans-unit id="876835f5a189b420b4b1dda2b457e7a93555e339" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt;. If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">는 IF &lt;code&gt;can&lt;/code&gt; false를 반환, 그 다음이 전달됩니다 &lt;code&gt;ok&lt;/code&gt; . 그것은 사실, 그 다음 더 큰 표현 반환하는 경우 &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; 을 반환 1, &lt;code&gt;ok&lt;/code&gt; 당신이 기대하는 것처럼, 성공의 간단한 신호로 볼 수있다.</target>
        </trans-unit>
        <trans-unit id="8bb03363c1cc83c40db7187bc0c1808c11643507" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">는 IF &lt;code&gt;charscript()&lt;/code&gt; 인수가 알려진 스크립트 아니라, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ecb007ef4038a90f65cf1dae4d321b995b3815d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">는 IF &lt;code&gt;charscript()&lt;/code&gt; 인수가 알려진 스크립트 아니라, &lt;code&gt;undef&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="abc210b43b03b8ee41f920df8c0e913cce7e9cdb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is a code reference, it will be called iteratively to provide the content body of the request. It should return the empty string or undef when the iterator is exhausted.</source>
          <target state="translated">는 IF &lt;code&gt;content&lt;/code&gt; 옵션 코드 참조이며, 요구 내용 몸을 제공하기 위해 반복적으로 호출됩니다. 반복기가 소진되면 빈 문자열 또는 undef를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c7688f4c054c95562671f461204e8d1909c8763" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is the empty string, no &lt;code&gt;content-type&lt;/code&gt; or &lt;code&gt;content-length&lt;/code&gt; headers will be generated.</source>
          <target state="translated">는 IF &lt;code&gt;content&lt;/code&gt; 옵션은 빈 문자열, 어떤 &lt;code&gt;content-type&lt;/code&gt; 또는 &lt;code&gt;content-length&lt;/code&gt; 헤더가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a6115ecc6df609b525cd058a3289a9b186700a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;data_callback&lt;/code&gt; option is provided, it will be called iteratively until the entire response body is received. The first argument will be a string containing a chunk of the response body, the second argument will be the in-progress response hash reference, as described below. (This allows customizing the action of the callback based on the &lt;code&gt;status&lt;/code&gt; or &lt;code&gt;headers&lt;/code&gt; received prior to the content body.)</source>
          <target state="translated">경우 &lt;code&gt;data_callback&lt;/code&gt; 옵션이 제공되어 전체 응답 본문을 수신 할 때까지, 그것은 반복적으로 호출됩니다. 아래에 설명 된 것처럼 첫 번째 인수는 응답 본문의 청크를 포함하는 문자열이고 두 번째 인수는 진행중인 응답 해시 참조입니다. (이를 통해 콘텐츠 본문 이전에 수신 된 &lt;code&gt;status&lt;/code&gt; 또는 &lt;code&gt;headers&lt;/code&gt; 기반으로 콜백 작업을 사용자 정의 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="15aaa040db904ad0d7e939ff87d0289e4ed113e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">는 IF &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; 변환 정보의 손실없이 할 수없는, 결과는 변환 시퀀스와 호환 &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . 특히 &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; 와 같은 숫자 는 1로 반올림 될 가능성이 있지만 반올림은 0으로 강하게 바이어스됩니다 .</target>
        </trans-unit>
        <trans-unit id="c844a354fc5d5e3ba8448bfcc0461c2e96ef53fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt;. In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">는 IF &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; 변환 정보의 손실없이 할 수없는, 결과는 변환 시퀀스와 호환 &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . 특히, &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; 와 같은 숫자 는 1로 반올림 될 가능성이 있지만 반올림은 0으로 강하게 바이어스됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e4484ac7779a53de50aea47a7a5981f680fda36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; pragma is in scope then the lengths returned are calculated from the length of &lt;code&gt;$/&lt;/code&gt; in Unicode characters, which is not always the same as the length of &lt;code&gt;$/&lt;/code&gt; in the native encoding.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; pragma가 범위 내에있는 경우 반환되는 길이는 &lt;code&gt;$/&lt;/code&gt; 의 길이 에서 유니 코드 문자 로 계산되며 기본 인코딩 의 &lt;code&gt;$/&lt;/code&gt; 의 길이와 항상 같지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bb917cbee0d97141aac38b7ae445c57c18b27f43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;export_fail&lt;/code&gt; method returns an empty list then no error is recorded and all the requested symbols are exported. If the returned list is not empty then an error is generated for each symbol and the export fails. The Exporter provides a default &lt;code&gt;export_fail&lt;/code&gt; method which simply returns the list unchanged.</source>
          <target state="translated">는 IF &lt;code&gt;export_fail&lt;/code&gt; 의 방법은 다음 오류가 기록되지 않은 빈 목록을 반환하고 요청 된 모든 기호를 수출하고 있습니다. 리턴 된 목록이 비어 있지 않으면 각 기호에 대해 오류가 생성되고 내보내기에 실패합니다. Exporter는 기본 &lt;code&gt;export_fail&lt;/code&gt; 메소드를 제공하여 단순히 목록을 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="276362d098a443c72a3870f2a2d48ae260499ef9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; .</source>
          <target state="translated">는 IF &lt;code&gt;gv&lt;/code&gt; 존재하고 심볼 테이블에없는,이 함수는 단순히 반환합니다. &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; 경우이 옵션을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="9956d32eb4cf510432b5c2113065ce4d2ab05fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;gv&lt;/code&gt; 존재하고 심볼 테이블에없는,이 함수는 단순히 반환합니다. 이것은 &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; 인 경우 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="798f35bb0e17493f55f47f1e0e601507174d7021" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maxdepth&lt;/code&gt; is included, it must be a numeral</source>
          <target state="translated">&lt;code&gt;maxdepth&lt;/code&gt; 가 포함 된 경우 숫자 여야합니다</target>
        </trans-unit>
        <trans-unit id="58bc648a8e07d1ab46d67c368d31d1e61d6eb6fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realpath&lt;/code&gt; function is not available, or is unable to return the real path of the file, &lt;code&gt;unixrealpath&lt;/code&gt; will use the same internal procedure as the &lt;code&gt;vmsrealpath&lt;/code&gt; function and convert the output to a Unix format specification. It is not available on non-VMS systems.</source>
          <target state="translated">는 IF &lt;code&gt;realpath&lt;/code&gt; 의 기능을 사용할 수 없습니다 또는 파일의 실제 경로를 반환 할 수없는, &lt;code&gt;unixrealpath&lt;/code&gt; 는 과 같은 내부 절차를 사용합니다 &lt;code&gt;vmsrealpath&lt;/code&gt; 의 기능과 유닉스 형식 사양 출력을 변환합니다. 비 VMS 시스템에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="622e9bbb1973cba189a5047eab876b3fea0127f4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;table&lt;/code&gt; attribute (see below) is set then a renderer may choose to display the table instead of the details.</source>
          <target state="translated">는 IF &lt;code&gt;table&lt;/code&gt; 속성 (아래 참조)로 설정 한 후 렌더러는 세부 대신 테이블을 표시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4672f4a6483db1b05eeb609d8e652aab384c295c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;timelocal()&lt;/code&gt; function is given a non-existent local time, it will simply return an epoch value for the time one hour later.</source>
          <target state="translated">는 IF &lt;code&gt;timelocal()&lt;/code&gt; 함수가 존재하지 않는 현지 시간을 주어, 단순히 1 시간 후 시간에 대한 획기적인 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8b1721e1ae657f367e4018c29dc66b147cf1c09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files from &lt;code&gt;Archive::Tar&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;uncompress&lt;/code&gt; 또는 &lt;code&gt;gunzip&lt;/code&gt; 이 프로그램을 사용할 수 있습니다, 당신은 읽을 이러한 해결 방법 중 하나를 사용할 수 &lt;code&gt;.tar.Z&lt;/code&gt; 파일을 &lt;code&gt;Archive::Tar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cddc99dbc25aed0c730c0fe2bb39cef906b6e6a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">는 IF &lt;code&gt;unicode_eval&lt;/code&gt; 기능 (아래에있는 A 기본값 인 설정되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 이상 선언), EXPR 또는 &lt;code&gt;$_&lt;/code&gt; 그래서 문자열로 처리됩니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언은 아무런 효과가없고, 소스 필터가 금지된다. &lt;code&gt;unicode_eval&lt;/code&gt; 기능 이 없으면 내부 인코딩에 따라 문자열이 문자 및 바이트로 처리되는 경우가 있으며, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 활성화 된 소스 필터 는 일부 외부 파일 범위에 영향을 미치는 비정상적이지만 역사적 동작을 나타냅니다. 여전히 컴파일 중입니다. 또한 참조 &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes을&lt;/a&gt;키워드는 입력을 항상 바이트 스트림으로 취급하고 소스 필터 및 와 올바르게 작동합니다&lt;a href=&quot;feature&quot;&gt;&lt;/a&gt;프라 그마 기능 .</target>
        </trans-unit>
        <trans-unit id="87e45908e093ce58a5e789307a68cc9a88437767" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">는 IF &lt;code&gt;unicode_eval&lt;/code&gt; 기능 (아래에있는 A 기본값 인 설정되어 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 이상 선언), EXPR 또는 &lt;code&gt;$_&lt;/code&gt; 그래서 문자열로 처리됩니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언은 아무런 효과가없고, 소스 필터가 금지된다. &lt;code&gt;unicode_eval&lt;/code&gt; 기능 이 없으면 내부 인코딩에 따라 문자열이 문자 및 바이트로 처리되는 경우가 있으며, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에서 활성화 된 소스 필터 는 일부 외부 파일 범위에 영향을 미치는 비정상적이지만 역사적 동작을 나타냅니다. 여전히 컴파일 중입니다. &lt;a href=&quot;evalbytes&quot;&gt;evalbytes을&lt;/a&gt;입력을 항상 바이트 스트림으로 취급하고 소스 필터와 올바르게 작동 하는 키워드 도 참조하십시오 .&lt;a href=&quot;../feature&quot;&gt; 기능&lt;/a&gt; pragma .</target>
        </trans-unit>
        <trans-unit id="094a307e3b02182e7190ab8c7d41908a31be7b6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt; option is not given, the encoding of its output file handle will be forced to the detected encoding of the input POD, which preserves whatever the input text is. This ensures backward compatibility with earlier, pre-Unicode versions of this module, without large numbers of Perl warnings.</source>
          <target state="translated">는 IF &lt;code&gt;utf8&lt;/code&gt; 옵션이 제공되지 않으며, 출력 파일 핸들의 인코딩은 입력 텍스트가 무엇이든 보존 입력 POD의 감지 인코딩으로 강제됩니다. 이를 통해 많은 수의 Perl 경고없이이 모듈의 이전 프리 유니 코드 버전과 역 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9b06ad91f4e14141b1e47f8d38395a6c62e787" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt;-flag is enabled, &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; will encode all characters using the corresponding UTF-8 multi-byte sequence, and will expect your input strings to be encoded as UTF-8, that is, no &quot;character&quot; of the input string must have any value &amp;gt; 255, as UTF-8 does not allow that.</source>
          <target state="translated">는 IF &lt;code&gt;utf8&lt;/code&gt; -flag가 활성화되어, &lt;code&gt;encode&lt;/code&gt; / &lt;code&gt;decode&lt;/code&gt; 해당 UTF-8 멀티 바이트 시퀀스를 사용하는 모든 문자를 인코딩되며, 귀하의 입력 문자열이 UTF-8, 입력의 어떤 &quot;문자&quot;입니다로 인코딩 할 것으로 예상됩니다 문자열은 UTF-8에서 허용하지 않으므로 255보다 큰 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="b5abb9df31ef6516fcae104f653339d0026bd9e0" translate="yes" xml:space="preserve">
          <source>If the AIX Toolbox version of lib gdbm &amp;lt; 1.8.3-5 is installed on your system then Perl will not work. This library contains the header files /opt/freeware/include/gdbm/dbm.h|ndbm.h which conflict with the AIX system versions. The lib gdbm will be automatically removed from the wanted libraries if the presence of one of these two header files is detected. If you want to build Perl with GDBM support then please install at least gdbm-devel-1.8.3-5 (or higher).</source>
          <target state="translated">lib gdbm &amp;lt;1.8.3-5의 AIX Toolbox 버전이 시스템에 설치되어 있으면 Perl이 작동하지 않습니다. 이 라이브러리에는 AIX 시스템 버전과 충돌하는 헤더 파일 /opt/freeware/include/gdbm/dbm.h|ndbm.h가 포함되어 있습니다. 이 두 헤더 파일 중 하나가 존재하면 lib gdbm이 원하는 라이브러리에서 자동으로 제거됩니다. GDBM 지원으로 Perl을 빌드하려면 gdbm-devel-1.8.3-5 이상을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="e4f37200eb3cc7a4dd0c87959fbb6c2e093e138e" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; , except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">C 함수 setvbuf ()를 사용할 수 있으면 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 의 버퍼링 정책을 설정합니다. 버퍼 매개 변수가 버퍼로 사용할 스칼라 변수를 지정하는 것을 제외하고 Perl 함수의 호출 순서는 매크로 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 포함하여 C 대응 함수와 동일 합니다. 경고 : &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 가 버퍼로 사용하는 변수 는 FileHandle을 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 를 다시 호출 할 때까지 어떤 식 으로든 수정해서는 안됩니다. 그렇지 않으면 메모리 손상이 발생할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="299d706db577fab624c88622bc091e3abdb77143" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt;, except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">C 함수 setvbuf ()를 사용할 수있는 경우 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 는 FileHandle에 대한 버퍼링 정책을 설정합니다. Perl 함수의 호출 시퀀스 는 버퍼 매개 변수가 버퍼로 사용할 스칼라 변수를 지정한다는 점을 제외 하면 매크로 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 포함하여 C 대응 부 와 동일합니다. 경고 : &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 에서 버퍼로 사용하는 변수 는 FileHandle이 닫히거나 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 가 다시 호출 될 때까지 어떤 식 으로든 수정해서는 안됩니다. 그렇지 않으면 메모리 손상이 발생할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="1a7ae4abb775cdaecaa965021a5be89b2c2a0678" translate="yes" xml:space="preserve">
          <source>If the C functions fgetpos() and fsetpos() are available, then &lt;code&gt;FileHandle::getpos&lt;/code&gt; returns an opaque value that represents the current position of the FileHandle, and &lt;code&gt;FileHandle::setpos&lt;/code&gt; uses that value to return to a previously visited position.</source>
          <target state="translated">C 함수 fgetpos () 및 fsetpos ()를 사용할 수있는 경우 &lt;code&gt;FileHandle::getpos&lt;/code&gt; 는 FileHandle 의 현재 위치를 나타내는 불투명 한 값을 반환하고 &lt;code&gt;FileHandle::setpos&lt;/code&gt; 는 해당 값을 사용하여 이전에 방문한 위치로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="50ebbabfe865d409f0b42636c02f4e83fa99aca9" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">C 함수 setbuf () 및 / 또는 setvbuf ()를 사용할 수있는 경우 &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; 및 &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; 는 IO :: Handle에 대한 버퍼링 정책을 설정합니다. 버퍼 매개 변수가 버퍼로 사용할 스칼라 변수를 지정한다는 점을 제외하고 Perl 함수의 호출 시퀀스는 상수 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 포함하여 C 대응 함수와 동일 합니다. I / O 전이나 flush를 호출 한 직후에만 버퍼를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b39a4db83d5ceb015a67a35d8f623bb0eb08d0e" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">C 함수 setbuf () 및 / 또는 setvbuf ()를 사용할 수있는 경우 &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; 및 &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; 는 IO :: Handle에 대한 버퍼링 정책을 설정합니다. Perl 함수의 호출 시퀀스 는 버퍼 매개 변수가 버퍼로 사용할 스칼라 변수를 지정한다는 점을 제외하면 setvbuf ()에 대한 상수 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 포함하여 C 대응 요소 와 동일합니다. I / O 전 또는 flush 호출 직후에만 버퍼를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb7a6c24ac237588ebe82997b3227d4077970889" translate="yes" xml:space="preserve">
          <source>If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the header must match the crc16 value of the gzip header actually read.</source>
          <target state="translated">FHCRC 비트가 gzip FLG 헤더 바이트에 설정된 경우 헤더의 CRC16 바이트는 실제로 읽은 gzip 헤더의 crc16 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="716df9a8cd6dfb775c171f4188701d3aabf993bd" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">PATTERN에 &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;캡처 그룹이&lt;/a&gt; 포함 된 경우 각 구분 기호에 대해 그룹에 의해 캡처 된 각 하위 문자열에 대해 추가 필드가 생성됩니다 ( &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;역 참조에&lt;/a&gt; 따라 그룹이 지정된 순서대로 ). 그룹이 일치하지 않으면 하위 문자열 대신 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 캡처합니다 . 또한 이러한 추가 필드는 구분 기호가있을 때마다 (즉, 분할이 발생할 때마다) 생성되며 이러한 추가 필드는 LIMIT에 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 목록 컨텍스트에서 평가 된 다음 표현식을 고려하십시오 (각 리턴 된 목록은 연관된 주석에 제공됨).</target>
        </trans-unit>
        <trans-unit id="19ac8a832643510531c14e9722a2a956f43fd56c" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">PATTERN에 &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;캡처 링 그룹이&lt;/a&gt; 포함 된 경우 각 구분 기호에 대해 그룹이 캡처 한 각 하위 문자열에 대해 추가 필드가 생성됩니다 ( &lt;a href=&quot;perlretut#Backreferences&quot;&gt;역 참조에&lt;/a&gt; 따라 그룹이 지정된 순서대로 ). 일치하지 않는 그룹이 있으면 하위 문자열 대신 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 값을 캡처합니다 . 또한 이러한 추가 필드는 구분 기호가있을 때마다 (즉, 분할이 발생할 때마다) 생성되며 이러한 추가 필드는 LIMIT에 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 목록 컨텍스트에서 평가 된 다음 표현식을 고려하십시오 (반환 된 각 목록은 연관된 주석에 제공됨).</target>
        </trans-unit>
        <trans-unit id="82d842f2ab3731c9a4a0e7946b2b84aa92b80adc" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">PATTERN에 &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;캡처 그룹이&lt;/a&gt; 포함 된 경우 각 구분 기호에 대해 그룹에 의해 캡처 된 각 하위 문자열에 대해 추가 필드가 생성됩니다 ( &lt;a href=&quot;perlretut#Backreferences&quot;&gt;역 참조에&lt;/a&gt; 따라 그룹이 지정된 순서대로 ). 그룹이 일치하지 않으면 하위 문자열 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 캡처합니다 . 또한 이러한 추가 필드는 구분 기호가있을 때마다 (즉, 분할이 발생할 때마다) 생성되며 이러한 추가 필드는 LIMIT에 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 목록 컨텍스트에서 평가 된 다음 표현식을 고려하십시오 (각 리턴 된 목록은 연관된 주석에 제공됨).</target>
        </trans-unit>
        <trans-unit id="4e7443d40abaa23829b9ab709311a1922fe461b6" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">PERL_PV_PRETTY_ELLIPSES 플래그가 설정되고 문자열의 모든 문자가 출력되지 않은 경우 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 가 문자열에 추가됩니다. 이것은 인용 된 후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="09680d261a6a88f2e5836c919a2510509957b1e5" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_QUOTE flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">PERL_PV_PRETTY_QUOTE 플래그가 설정되면 문자열에서 이스케이프 된 큰 따옴표와 함께 결과가 큰 따옴표로 표시됩니다. 그렇지 않으면 PERL_PV_PRETTY_LTGT 플래그가 설정된 경우 결과는 꺾쇠 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="b990fe2846203877eedfbcf554045c1e773431f8" translate="yes" xml:space="preserve">
          <source>If the POD is inconsistent about the indentation of verbatim blocks, but you have figured out a heuristic to determine how much a particular verbatim block is indented, you can pass a code reference instead. The code reference will be executed with one argument, an array reference of all the lines in the verbatim block, and should return the value to be stripped from each line. For example, if you decide that you're fine to use the first line of the verbatim block to set the standard for indentation of the rest of the block, you can look at the first line and return the appropriate value, like so:</source>
          <target state="translated">POD가 동사 블록 들여 쓰기에 대해 일관성이 없지만 특정 동사 블록 들여 쓰기 정도를 결정하는 휴리스틱을 찾은 경우 대신 코드 참조를 전달할 수 있습니다. 코드 참조는 하나의 인수, 즉 동사 블록의 모든 줄에 대한 배열 참조로 실행되며 각 줄에서 제거 할 값을 반환해야합니다. 예를 들어, 동사 블록의 첫 번째 줄을 사용하여 나머지 블록의 들여 쓰기에 대한 표준을 설정하는 것이 좋다고 결정한 경우 첫 번째 줄을보고 다음과 같이 적절한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38f09a374f3f254883a79ac66d4d89714b8faea" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or CP 1252) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. (If the POD source contains only ASCII bytes, the encoding is assumed to be ASCII.)</source>
          <target state="translated">POD 소스에 &lt;code&gt;=encoding&lt;/code&gt; 선언이 포함되지 않은 경우 파서는 첫 번째 비 ASCII 바이트를 검사하고 &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec에&lt;/a&gt; 설명 된 휴리스틱을 적용하여 인코딩을 추측합니다 (UTF-8 또는 CP 1252 중 하나 선택) . (POD 소스에 ASCII 바이트 만 포함 된 경우 인코딩은 ASCII로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="e9fd97e2c853d040e2b1f08382eba5acd7317a9d" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or Latin-1) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">POD 소스에 &lt;code&gt;=encoding&lt;/code&gt; 선언이 포함되어 있지 않으면 파서는 ASCII가 아닌 첫 번째 바이트를 검사하고 &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec에&lt;/a&gt; 설명 된 휴리스틱을 적용하여 인코딩 (UTF-8 또는 Latin-1 중 하나를 선택)을 추측합니다 .</target>
        </trans-unit>
        <trans-unit id="539121ee50a224917b8fad7fe828de50a4356761" translate="yes" xml:space="preserve">
          <source>If the POD you're parsing adheres to a consistent indentation policy, you can have such indentation stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what to strip. For two-space indents, you'd use:</source>
          <target state="translated">구문 분석중인 POD가 일관된 들여 쓰기 정책을 준수하는 경우 동사 블록의 모든 줄의 시작 부분에서 이러한 들여 쓰기를 제거 할 수 있습니다. 이 방법은 Pod :: Simple에게 무엇을 제거할지 알려줍니다. 두 칸 들여 쓰기의 경우 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="41c4b629a3e2e0346fc506d9a6f6a02afa0eab8b" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in Perl's extended UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns FALSE if the PV is invalid UTF-8.</source>
          <target state="translated">SV의 PV가 Perl의 확장 UTF-8의 옥텟 시퀀스이고 다중 바이트 문자를 포함하는 경우 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그가 켜져 문자처럼 보입니다. PV에 1 바이트 문자 만 포함 된 경우 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그는 꺼져 있습니다. PV의 유효성을 검사하고 PV가 유효하지 않은 UTF-8이면 FALSE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="767d61bbd817028665e597ffd44d52d2f3072a5a" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns false if the PV is invalid UTF-8.</source>
          <target state="translated">SV의 PV가 UTF-8의 8 진수 시퀀스이고 멀티 바이트 문자를 포함하는 경우 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그가 켜져 문자처럼 보입니다. PV에 1 바이트 문자 만 포함 된 경우 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그는 꺼져 있습니다. PV가 유효한지 검사하고 PV가 유효하지 않은 UTF-8이면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ce916c1cc7717c4e805155c2d7548fbc24c77ee" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt; , then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">Perl 스크립트가 &lt;code&gt;perl scriptname&lt;/code&gt; 으로 실행 되면 &lt;b&gt;-% c&lt;/b&gt; 옵션이 명령 행에 표시되어야합니다 ( &lt;code&gt;perl -%c scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f041d8f750e7891231f6ef945e98ccc9b459b45e" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt;, then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">Perl 스크립트가 &lt;code&gt;perl scriptname&lt;/code&gt; 으로 실행되는 경우 &lt;b&gt;-% c&lt;/b&gt; 옵션이 명령 줄에 나타나야합니다 . &lt;code&gt;perl -%c scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde4187a6aa163d9c96f574141763bdd38ae34f7" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt; .</source>
          <target state="translated">Perl 스크립트가 #! 명령을 사용하여 명령으로 실행되는 경우 메카니즘 (또는 그에 상응하는 부분)의 경우이 오류는 일반적으로 #! &lt;b&gt;-% c&lt;/b&gt; 옵션이 Perl의 첫 번째 인수의 일부가 되도록하십시오 . 예 : &lt;code&gt;perl -n -%c&lt;/code&gt; 를 &lt;code&gt;perl -%c -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8bf71d735699bc0d3dafa8fc7795c33b9452d54" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt;.</source>
          <target state="translated">Perl 스크립트가 #! 메커니즘 (또는 이에 상응하는 로컬)의 경우이 오류는 일반적으로 #! &lt;b&gt;-% c&lt;/b&gt; 옵션이 Perl의 첫 번째 인수의 일부가 되도록 행하십시오 . 예를 들어 &lt;code&gt;perl -n -%c&lt;/code&gt; 를 &lt;code&gt;perl -%c -n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c878ced38c4f673dcc4c3921e7ce406e54b4b71" translate="yes" xml:space="preserve">
          <source>If the README file seems to be getting too large you may wish to split out some of the sections into separate files: INSTALL, Copying, ToDo etc.</source>
          <target state="translated">README 파일이 너무 커 보인다면 일부 섹션을 INSTALL, Copying, ToDo 등 별도의 파일로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcda0ef071779fc235b5cd85b1d75a393d7ae1e4" translate="yes" xml:space="preserve">
          <source>If the Time::HiRes module has been installed, you can specify the special tag &lt;code&gt;:hireswallclock&lt;/code&gt; for Benchmark (if Time::HiRes is not available, the tag will be silently ignored). This tag will cause the wallclock time to be measured in microseconds, instead of integer seconds. Note though that the speed computations are still conducted in CPU time, not wallclock time.</source>
          <target state="translated">Time :: HiRes 모듈이 설치된 경우 벤치 마크에 특수 태그 &lt;code&gt;:hireswallclock&lt;/code&gt; 을 지정할 수 있습니다 (Time :: HiRes를 사용할 수없는 경우 태그는 자동으로 무시됩니다). 이 태그는 벽시계 시간이 정수 초가 아닌 마이크로 초 단위로 측정되게합니다. 속도 계산은 여전히 ​​벽시계 시간이 아니라 CPU 시간으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0de044d27a1f06d198fa6cd4b199e7a501a7e3" translate="yes" xml:space="preserve">
          <source>If the UNTIE method exists then the warning above does not occur. Instead the UNTIE method is passed the count of &quot;extra&quot; references and can issue its own warning if appropriate. e.g. to replicate the no UNTIE case this method can be used:</source>
          <target state="translated">UNTIE 방법이 존재하면 위의 경고가 발생하지 않습니다. 대신 UNTIE 방법에는 &quot;추가&quot;참조 수가 전달되며 적절한 경우 자체 경고를 발행 할 수 있습니다. 예를 들어 UNTIE가 아닌 경우를 복제하려면이 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="143e00ba94fc0b7d94b37e36ca76fc91860f4e9a" translate="yes" xml:space="preserve">
          <source>If the URL includes a &quot;user:password&quot; stanza, they will be used for Basic-style authorization headers. (Authorization headers will not be included in a redirected request.) For example:</source>
          <target state="translated">URL에 &quot;user : password&quot;스탠자가 포함 된 경우 기본 스타일 권한 헤더에 사용됩니다. (승인 헤더는 리디렉션 된 요청에 포함되지 않습니다.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ecfe64b91fdc6593a92259993f050bf990c0868" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; will call the &lt;code&gt;VERSION&lt;/code&gt; method in class Module with the given version as an argument:</source>
          <target state="translated">VERSION 인수가 Module과 LIST 사이에 있으면 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 은 지정된 버전을 인수로 사용하여 Module 클래스 에서 &lt;code&gt;VERSION&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="afcfedf6cd11f719819da193333a7cf6de0732a7" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">버전 인수가 모듈 및 LIST 사이에 존재하는 경우, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 인수로 주어진 버전으로 클래스 모듈의 버전 메소드를 호출합니다. 지정된 버전이 &lt;code&gt;$Module::VERSION&lt;/code&gt; 변수의 값보다 크면 UNIVERSAL 클래스에서 상속 된 기본 VERSION 메소드가 사라집니다 .</target>
        </trans-unit>
        <trans-unit id="28fd8c6bb88e030936b47d8b396e97702a34b855" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">버전 인수가 모듈 및 LIST 사이에 존재하는 경우, &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 인수로 주어진 버전으로 클래스 모듈의 버전 메소드를 호출합니다. 지정된 버전이 &lt;code&gt;$Module::VERSION&lt;/code&gt; 변수의 값보다 크면 UNIVERSAL 클래스에서 상속 된 기본 VERSION 메소드가 사라집니다 .</target>
        </trans-unit>
        <trans-unit id="333bd150f2ebb931ff98dd0682381076be3b30d6" translate="yes" xml:space="preserve">
          <source>If the XSUB has a return type of &lt;code&gt;void&lt;/code&gt; then the compiler will not declare a RETVAL variable for that function. When using a PPCODE: section no manipulation of the RETVAL variable is required, the section may use direct stack manipulation to place output values on the stack.</source>
          <target state="translated">XSUB의 반환 유형이 &lt;code&gt;void&lt;/code&gt; 인 경우 컴파일러는 해당 함수에 대한 RETVAL 변수를 선언하지 않습니다. PPCODE : 섹션을 사용할 때 RETVAL 변수를 조작 할 필요가없는 경우 섹션은 직접 스택 조작을 사용하여 출력 값을 스택에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebee72fc9aa0a9b169227a410e90f7f3df000ed" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">위의 방법으로 작동하지 않거나 응용 프로그램에 적합하지 않은 경우 &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; 에 문제가있는 모듈 에 대한 버그 보고서를 제출 하십시오.</target>
        </trans-unit>
        <trans-unit id="f43e61e618bcd86d5e8194fe59eff43dd8c761f1" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">위의 방법이 작동하지 않거나 애플리케이션에 적합하지 않은 경우 &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt; 에서 문제가있는 모듈 에 대한 버그 보고서를 제출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="77f8b1f2470978bb7eb295cba54688c501c99623" translate="yes" xml:space="preserve">
          <source>If the above evaluates as true, the following methods will be available on the &lt;code&gt;$result&lt;/code&gt; object.</source>
          <target state="translated">위의 내용이 true로 평가되면 &lt;code&gt;$result&lt;/code&gt; 객체 에서 다음 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3626e8a47b75cd9814f9aabb6f3226e20a12cd72" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt; . Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 를 통해 모듈을 가져 오지 않으면 소스 코드 필터링이 중단되고 가져 &lt;code&gt;unimport&lt;/code&gt; 서브 루틴을 작성하고 &lt;code&gt;filter_del&lt;/code&gt; 을 호출해야합니다 . 확인에 대한 호출 확인 &lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 5 단계에서 실수로 과거 읽지 않습니다 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이 필터링하는 소스 코드의 사전 사전 분석을 수행하지 않는 한 효과적으로 소스 코드 필터를 라인 단위로 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="03a3b15e2a6cd5a22375d6379cdf2984cfbb61b0" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;no&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt;. Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;no&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;import&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">모듈 가져 오기를 해제하는 행위 ( &lt;code&gt;no&lt;/code&gt; 를 통해 )로 인해 소스 코드 필터링이 중단되어야하는 경우 &lt;code&gt;unimport&lt;/code&gt; 서브 루틴을 만들고 &lt;code&gt;filter_del&lt;/code&gt; 을 호출하도록 합니다. 확인에 대한 호출 확인 &lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 5 단계에서 실수로 과거 읽지 않습니다 &lt;code&gt;no&lt;/code&gt; . &lt;code&gt;import&lt;/code&gt; 서브 루틴이 필터링하는 소스 코드를 미리 파싱하지 않는 한 이는 효과적으로 소스 코드 필터를 라인 단위 작업으로 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="f14d384ae54d7fd6956617c902dc52b4f7c913e2" translate="yes" xml:space="preserve">
          <source>If the archive creation fails for any reason, &lt;code&gt;create_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">어떤 이유로 든 아카이브 작성에 실패하면 &lt;code&gt;create_archive&lt;/code&gt; 는 false를 리턴합니다. &lt;code&gt;error&lt;/code&gt; 의 원인을 찾으 려면 오류 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdb2a47c2b4d923874ce10a47d541cda074eec3d" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">인수에 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 와 일치하는 문자 이외의 문자가 있으면 파일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="78aee964b82335874ff16d75333783914537914b" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">인수에 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 와 일치하지 않는 문자 가있는 경우 파일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ad412a6b0ecba8c1d6ad813bdece11aeaddeb49" translate="yes" xml:space="preserve">
          <source>If the argument is &quot;/cygdrive&quot;, then just the volume mount settings, and the cygdrive mount prefix are returned.</source>
          <target state="translated">인수가 &quot;/ cygdrive&quot;인 경우 볼륨 마운트 설정과 cygdrive 마운트 접두사 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f2982f0afdcf62760763525865c85306c36f4e" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">인수가 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 컴파일 된 정규식 인 경우이 함수는 패턴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b654339779464179184dbeba32e40251c7e2e80" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">인수가 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 의해 리턴 된 컴파일 된 정규식 인 경우, 이 함수는 옵티마이 저가 패턴에서 가장 긴 고정 고정 문자열 및 가장 긴 부동 고정 문자열로 간주하는 것을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="81692e2cadc8efc40c200d83e4422a4728d67dbc" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">인수가 &lt;code&gt;qr//&lt;/code&gt; 의해 반환 된 컴파일 된 정규식 이면이 함수는 패턴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5c12c2dc9e5c6145a6b58c7acda0a55ed2d46c4" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">인수가 &lt;code&gt;qr//&lt;/code&gt; 의해 반환 된 컴파일 된 정규식 인 경우이 함수는 옵티마이 저가 패턴에서 가장 긴 고정 된 고정 문자열과 가장 긴 부동 고정 문자열로 간주하는 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5788205c6ad8a4a8ebfb81bffe26f845a9b7bbcb" translate="yes" xml:space="preserve">
          <source>If the argument is a distribution file name (recognized by embedded slashes), it is processed. If it is a module, CPAN determines the distribution file in which this module is included and processes that, following any dependencies named in the module's META.yml or Makefile.PL (this behavior is controlled by the configuration parameter &lt;code&gt;prerequisites_policy&lt;/code&gt; ). If an argument is enclosed in slashes it is treated as a regular expression: it is expanded and if the result is a single object (distribution, bundle or module), this object is processed.</source>
          <target state="translated">인수가 분산 파일 이름 인 경우 (내장 슬래시로 인식) 처리됩니다. 모듈 인 경우 CPAN은이 모듈이 포함 된 분배 파일을 판별하고 모듈의 META.yml 또는 Makefile.PL에 이름 지정된 종속성에 따라이를 처리합니다 (이 동작은 구성 매개 변수 &lt;code&gt;prerequisites_policy&lt;/code&gt; 에 의해 제어 됨 ). 인수가 슬래시로 묶인 경우 일반 표현식으로 처리됩니다. 인수가 확장되고 결과가 단일 오브젝트 (분포, 번들 또는 모듈) 인 경우이 오브젝트가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b117f48b026da0b0825304f95daf71b17bbf61f6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;[\w:']&lt;/code&gt;, it must be a module</source>
          <target state="translated">인수가 &lt;code&gt;[\w:']&lt;/code&gt; 만 일치 하면 모듈이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0af3cf093a2df4958131449dc2e48cabc581ef28" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt; , it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">인수가 &lt;code&gt;\w&lt;/code&gt; 만 일치 하면 모듈 또는 파일 일 수 있습니다. &lt;code&gt;@INC&lt;/code&gt; 에서 먼저 &lt;code&gt;file.pm&lt;/code&gt; 을 찾으려고 시도 하고 실패하면 @INC에서 &lt;code&gt;file&lt;/code&gt; 을 찾으려고 시도합니다 . 둘 다 실패하면 각각의 오류 메시지로 죽습니다.</target>
        </trans-unit>
        <trans-unit id="a134e7d8148a5bb9fcca57ef03ba8d4ffbcb83b6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt;, it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">인수가 &lt;code&gt;\w&lt;/code&gt; 와만 일치 하면 모듈 또는 파일 일 수 있습니다. 먼저 &lt;code&gt;@INC&lt;/code&gt; 에서 &lt;code&gt;file.pm&lt;/code&gt; 을 찾고 실패하면 @INC에서 &lt;code&gt;file&lt;/code&gt; 을 찾습니다 . 둘 다 실패하면 각각의 오류 메시지와 함께 죽습니다.</target>
        </trans-unit>
        <trans-unit id="950fc5f071c3850318ce53caaa9abf5b8d7e4b09" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the</source>
          <target state="translated">예를 들어 수용 할 수없는 수의 인수를 사용하여 인수 op가 프로토 타입에 동의하지 않으면 유효한 op 트리가 반환됩니다. 오류는 파서 상태에 반영되어 일반적으로 발생한 모든 컴파일 오류를 포괄하는 최상위 수준의 구문 분석에서 단일 예외를 발생시킵니다. 오류 메시지에서 수신자는</target>
        </trans-unit>
        <trans-unit id="83ab7b8277b9fed6236e40a3daaed85d393da0e1" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the &lt;code&gt;namegv&lt;/code&gt; parameter.</source>
          <target state="translated">인수 ops가 프로토 타입과 일치하지 않는 경우 (예 : 허용 할 수없는 수의 인수가있는 경우) 어쨌든 유효한 op 트리가 반환됩니다. 오류는 파서 상태에 반영되며 일반적으로 발생한 모든 컴파일 오류를 포함하는 파싱의 최상위 수준에서 단일 예외가 발생합니다. 오류 메시지에서 수신자는 &lt;code&gt;namegv&lt;/code&gt; 매개 변수에 정의 된 이름으로 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d4e5120bb33dd7cd87d33b762323635453284d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;charblock()&lt;/code&gt; 대한 인수가 알려진 블록이 아닌 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cddc796120fb296cf9c181c113316137b8a64880" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;charblock()&lt;/code&gt; 대한 인수가 알려진 블록이 아니면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d7830cf54412f961c402c681fff76496d227d2f2" translate="yes" xml:space="preserve">
          <source>If the attribute name is unqualified, the attribute is installed in the current package. Otherwise it is installed in the qualifier's package:</source>
          <target state="translated">속성 이름이 규정되지 않은 경우 속성은 현재 패키지에 설치됩니다. 그렇지 않으면 한정자 패키지에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="c1735572aa151643b864cff0b5bfb1e1bb6554fd" translate="yes" xml:space="preserve">
          <source>If the author's vision of the future of their module is sufficiently different from the vision of the pumpkin holder and perl5-porters as a whole so as to cause serious problems for Perl, the pumpkin holder may choose to formally fork the version of the module in the Perl core from the one maintained by the author. This should not be done lightly and should &lt;b&gt;always&lt;/b&gt; if at all possible be done only after direct input from Larry. If this is done, it must then be made explicit in the module as distributed with the Perl core that it is a forked version and that while it is based on the original author's work, it is no longer maintained by them. This must be noted in both the documentation and in the comments in the source of the module.</source>
          <target state="translated">모듈의 미래에 대한 저자의 비전이 호박 홀더 및 perl5 포터의 비전과 완전히 다르면 Perl에 심각한 문제가 발생할 수 있습니다. 호박 홀더는 모듈 버전을 공식적으로 포크하도록 선택할 수 있습니다. 저자가 관리하는 Perl 코어. 이 가볍게해서는 안해야하고 &lt;b&gt;항상&lt;/b&gt; 경우 가능한 모든에서만 래리에서 직접 입력 한 후 수행 할 수. 이 작업이 완료되면 포크 버전이며 Perl 코어와 함께 배포 된 모듈에서 명시 적으로 작성해야하며 원래 작성자의 작업을 기반으로하므로 더 이상 유지 관리되지 않습니다. 이것은 문서와 모듈 소스의 주석 모두에 언급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="955f45edead883f952974a52b2340b4943a3c2b2" translate="yes" xml:space="preserve">
          <source>If the av argument is a tied array then will call the &lt;code&gt;EXTEND&lt;/code&gt; tied array method with an argument of &lt;code&gt;(key+1)&lt;/code&gt;.</source>
          <target state="translated">av 인수가 연결 배열이면 &lt;code&gt;(key+1)&lt;/code&gt; 인수를 사용 하여 &lt;code&gt;EXTEND&lt;/code&gt; 연결 배열 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1ff96c964c43432c71bf023f75aff4edc100165c" translate="yes" xml:space="preserve">
          <source>If the backslash is followed by a single digit, it's a backreference.</source>
          <target state="translated">백 슬래시 다음에 한 자리 숫자가 오는 경우 역 참조입니다.</target>
        </trans-unit>
        <trans-unit id="a1567cb832ddb83a0b923a12411e03c46deba90f" translate="yes" xml:space="preserve">
          <source>If the beginning of some prebuilt path matches</source>
          <target state="translated">사전 빌드 된 경로의 시작이 일치하는 경우</target>
        </trans-unit>
        <trans-unit id="e7f4bb43b4cedf6c41cad2b5a8c09df968a788f0" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;&quot;pairmap&quot;&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">&lt;a href=&quot;#pairmap&quot;&gt;&quot;pairmap&quot;에&lt;/a&gt; 제공된 코드 블록에 반환 된 클로저에 의해 캡처 된 어휘 변수가 포함되어 있고 블록이 다음 반복을 위해 재사용 된 후 클로저가 실행되면 이러한 어휘는 올바른 값을 볼 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10167b28b5bd2cad97967630ae689888c6716c8a" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">&lt;a href=&quot;#pairmap&quot;&gt;pairmap에&lt;/a&gt; 제공된 코드 블록에 리턴 된 클로저가 캡처 한 어휘 변수가 포함되어 있고 다음 반복에 블록을 재사용 한 후 클로저가 실행되면 이러한 어휘는 올바른 값을 볼 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4767b1747b48c85b5657695ae3a62c62eedbd7cb" translate="yes" xml:space="preserve">
          <source>If the bunzip2 program encounters a file containing multiple bzip2 files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="translated">bunzip2 프로그램이 함께 연결된 여러 bzip2 파일을 포함하는 파일을 발견하면 자동으로 모든 파일의 압축을 해제합니다. 아래 예는이 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="440a5d8f345e7d80a2856dd0eeb83f250fbc92a1" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">바이트 길이 &lt;code&gt;l1&lt;/code&gt; 이 0이 아닌 경우, &lt;code&gt;s1&lt;/code&gt; 에서 fold equality를 확인하기위한 거리를 나타 냅니다. 즉, &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 이 도달 목표로 사용됩니다. 목표에 도달하지 않으면 스캔이 일치하는 것으로 간주되지 않으며 해당 목표를 지나서도 스캔이 계속되지 않습니다. &lt;code&gt;s2&lt;/code&gt; 와 관련하여 &lt;code&gt;l2&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c2fca1e4d1004f5ffcdaa83a7b896a3cca0e13fe" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">바이트 길이 &lt;code&gt;l1&lt;/code&gt; 이 0이 아닌 경우 &lt;code&gt;s1&lt;/code&gt; 에서 폴드 등식을 확인하기 위해 얼마나 멀리 떨어져 있는지를 나타냅니다. 즉, &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 이 도달 목표로 사용됩니다. 목표에 도달하지 않는 한 스캔은 일치로 간주되지 않으며 스캔은 해당 목표를지나 계속되지 않습니다. 상응를위한 &lt;code&gt;l2&lt;/code&gt; 에 대한 &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7b55adcf46426f8905247d52b7cd465b36f52b" translate="yes" xml:space="preserve">
          <source>If the c89 compiler complains of syntax errors during the build of the Socket extension then be sure to fix the syntax error in the system header /usr/include/sys/socket.h.</source>
          <target state="translated">소켓 확장을 빌드하는 동안 c89 컴파일러가 구문 오류를 불평하는 경우 시스템 헤더 /usr/include/sys/socket.h에서 구문 오류를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="440bf862cd2a86e099efb047265c5fac0693c286" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</source>
          <target state="translated">호출이 lvalue 서브 루틴에 대한 것이고 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; 가 정의 된 경우 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="679d082044403152b577fab1a0ed8a9174ec8af7" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt;(</source>
          <target state="translated">lvalue 서브 루틴에 대한 호출이고 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; 가 정의 된 경우 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="3e23c7323ae1871ee025af31121766b37b8d3a26" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;load&lt;/code&gt; is from &lt;code&gt;YourPackage&lt;/code&gt; , then that can be further simplified to</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 호출 이 &lt;code&gt;YourPackage&lt;/code&gt; 에서 온 경우 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5682bd082d01ef4bbac6126150d3b6f81612d0af" translate="yes" xml:space="preserve">
          <source>If the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it's listed below. A few letters have not been used yet, so escaping them with a backslash doesn't change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].</source>
          <target state="translated">백 슬래시 뒤의 문자가 ASCII 문자 또는 ASCII 숫자이면 시퀀스가 ​​특별 할 수 있습니다. 그렇다면 아래에 나열되어 있습니다. 몇 개의 문자가 아직 사용되지 않았으므로 백 슬래시로 이스케이프 처리해도 특수 문자로 변경되지는 않습니다. 이후 버전의 Perl은 특별한 의미를 부여 할 수 있으므로 경고를 설정 한 경우 이러한 순서를 사용하면 Perl에서 경고를 발행합니다. [1].</target>
        </trans-unit>
        <trans-unit id="da17f25e114b45ba4ef865a9786c813cdbdd1421" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자가 정식 분해 가능한 경우 (한글 음절 포함) 정식 분해 (전체)를 문자열로 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49a5873bb2356b7ed86679de87b264a15f6d0e92" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">문자가 정규 분해 가능한 경우 (한글 음절 포함), (전체) 정규 분해를 문자열로 반환합니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="68a39c4975b03ffeafb0215bb69dbcb4fdb18e47" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자가 호환성 분해 가능 (한글 음절 포함) 인 경우 (완전한) 호환성 분해를 문자열로 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5de2fa7cb97ef2dd5b4c83623de57ebc81f1d7c6" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">문자가 호환성 분해 가능 (한글 음절 포함)이면 (전체) 호환성 분해를 문자열로 반환합니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="27e1499119842240cb994c8553e174c966c0608a" translate="yes" xml:space="preserve">
          <source>If the characters delimiting</source>
          <target state="translated">문자 구분</target>
        </trans-unit>
        <trans-unit id="65221cae28ebb56c2b7e384de16ed70d718d62d1" translate="yes" xml:space="preserve">
          <source>If the child falls out of scope before &lt;code&gt;finalize&lt;/code&gt; is called, a failure diagnostic will be issued and the child is considered to have failed.</source>
          <target state="translated">전에 아이가 범위 밖으로 떨어지면 &lt;code&gt;finalize&lt;/code&gt; 호출, 고장 진단이 발행되고 아이가 실패한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ac2316f205b2709d84d9e07b732224a9e1bdef17" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to $chld_in is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">어떤 이유로 든 자식 프로세스가 종료되면 $ chld_in에 대한 다음 쓰기는 부모에서 SIGPIPE를 생성 할 가능성이 있으며 이는 기본적으로 치명적입니다. 따라서이 신호를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc80dbef3fa7a98447bcda86b6b6a922737dbbf" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">어떤 이유로 하위 프로세스가 종료되면 CHLD_IN에 대한 다음 쓰기는 상위에서 SIGPIPE를 생성 할 가능성이 높으며 기본적으로 치명적입니다. 따라서이 신호를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd5594c7134763067cde3b54f3bfaeaa68b552a" translate="yes" xml:space="preserve">
          <source>If the child process follows the convention of C programs compiled with the _POSIX_EXIT macro set, the status value will contain the actual value of 0 to 255 returned by that program on a normal exit.</source>
          <target state="translated">하위 프로세스가 _POSIX_EXIT 매크로 세트로 컴파일 된 C 프로그램의 규칙을 따르는 경우, 상태 값에는 정상 종료시 해당 프로그램이 리턴 한 실제 값 0-255가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba30380d4c3fff1189949a912a23e2f3c323237f" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">&lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;에&lt;/a&gt; 표시된 클래스 가 MyClass.pm 모듈에 배치 된 경우 다음 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a2359effbd1215640880aada1292b5fa0877c9a" translate="yes" xml:space="preserve">
          <source>If the class shown in &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; were placed in the MyClass.pm module, then the following code:</source>
          <target state="translated">&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 에 표시된 클래스 가 MyClass.pm 모듈에 배치 된 경우 다음 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f9ec72ad3a19d5c4b84af5eba887a50b7eef9b5" translate="yes" xml:space="preserve">
          <source>If the client asks for &quot;fr&quot;, that will look up successfully in %greetings, to the value &quot;Bonjour&quot;. And if the client asks for &quot;i-mingo&quot;, that will look up successfully in %greetings, to the value &quot;Hau'&quot;.</source>
          <target state="translated">클라이언트가 &quot;fr&quot;을 요청하면 % greetings에서 &quot;Bonjour&quot;값으로 성공적으로 조회됩니다. 그리고 클라이언트가 &quot;i-mingo&quot;를 요청하면, &quot;Hau&quot; &quot;값으로 % greetings에서 성공적으로 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="1e012fb4a0052bc107066983e24cd424b0582af0" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt; .)</source>
          <target state="translated">코드 포인트가 할당되지 않은 경우 할당 된 경우 해당 코드 블록이 반환됩니다. (사용중인 유니 코드 버전이 블록을 갖지 않을 정도로 빠른 경우 모든 코드 포인트는 &lt;code&gt;No_Block&lt;/code&gt; 에있는 것으로 간주됩니다 .)</target>
        </trans-unit>
        <trans-unit id="318dcf1cce3429cb8c9fd8f8fb72e309dc55b11b" translate="yes" xml:space="preserve">
          <source>If the code point is unassigned, this returns the block it would belong to if it were assigned. (If the Unicode version being used is so early as to not have blocks, all code points are considered to be in &lt;code&gt;No_Block&lt;/code&gt;.)</source>
          <target state="translated">코드 포인트가 할당되지 않은 경우 할당 된 경우 해당하는 블록을 반환합니다. (사용중인 유니 코드 버전이 블록이 없을 정도로 빠르면 모든 코드 포인트가 &lt;code&gt;No_Block&lt;/code&gt; 에있는 것으로 간주됩니다 .)</target>
        </trans-unit>
        <trans-unit id="46675f67eada0291c64ffce7fc8980b9b58c2b77" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Examples:</source>
          <target state="translated">실행할 코드가 다양하지 않은 경우 eval-BLOCK 형식을 사용하여 매번 다시 컴파일하는 패널티를 발생시키지 않고 런타임 오류를 트랩 할 수 있습니다. 오류가있는 경우 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 계속 반환됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="ced2db748e9e7079888c75fca8f7175caebcea61" translate="yes" xml:space="preserve">
          <source>If the code to be executed doesn't vary, you may use the eval-BLOCK form to trap run-time errors without incurring the penalty of recompiling each time. The error, if any, is still returned in &lt;code&gt;$@&lt;/code&gt; . Examples:</source>
          <target state="translated">실행할 코드가 다르지 않으면 eval-BLOCK 양식을 사용하여 매번 재 컴파일의 페널티를 발생시키지 않으면 서 런타임 오류를 잡을 수 있습니다. 오류가있는 경우 여전히 &lt;code&gt;$@&lt;/code&gt; 반환됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="2bd498c74c7384947431c9fbfc4c96437164ae53" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; , there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">실행할 코드가 문자열 &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; 으로 전달 된 경우 가상 timeout () 함수가 호출자의 범위에서 어휘 변수 $ line에 다시 액세스 할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="c1827c22ec543702fffafe0a0fe1de8c30879660" translate="yes" xml:space="preserve">
          <source>If the code to execute had been passed in as a string, &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt;, there would have been no way for the hypothetical timeout() function to access the lexical variable $line back in its caller's scope.</source>
          <target state="translated">실행할 코드가 &lt;code&gt;'$line = &amp;lt;STDIN&amp;gt;'&lt;/code&gt; 문자열로 전달 되었다면 가상의 timeout () 함수가 호출자의 범위에서 어휘 변수 $ line에 다시 액세스 할 방법이 없었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="68179989040030e944377fc50f5fa69dee822170" translate="yes" xml:space="preserve">
          <source>If the command works, you can move to the next step, but beware: &lt;b&gt;You'll have to remove the directory from the device once you are done! Unlike &lt;i&gt;/mnt/asec&lt;/i&gt;, &lt;i&gt;/data/local/tmp&lt;/i&gt; may not get automatically garbage collected once you shut off the phone&lt;/b&gt;.</source>
          <target state="translated">명령이 작동하면 다음 단계로 이동할 수 있지만주의하십시오. &lt;b&gt;완료되면 장치에서 디렉토리를 제거해야합니다! 달리 &lt;i&gt;을 / mnt / ASEC&lt;/i&gt; , &lt;i&gt;/ 데이터 / 지역 / tmp를이&lt;/i&gt; 당신이 전화를 차단하면 수집 자동으로 얻을 수 없습니다 쓰레기&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9c340c9bb0fb834396be0e28dd3dddd81bf15437" translate="yes" xml:space="preserve">
          <source>If the condition expression of a &lt;code&gt;while&lt;/code&gt; statement is based on any of a group of iterative expression types then it gets some magic treatment. The affected iterative expression types are &lt;a href=&quot;perlfunc#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt;&lt;/a&gt; input operator, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&lt;code&gt;&amp;lt;PATTERN&amp;gt;&lt;/code&gt;&lt;/a&gt; globbing operator, and &lt;a href=&quot;perlfunc#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;. If the condition expression is one of these expression types, then the value yielded by the iterative operator will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If the condition expression is one of these expression types or an explicit assignment of one of them to a scalar, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">a의 상태를 표현하는 경우 &lt;code&gt;while&lt;/code&gt; 문이 반복 표현 유형의 그룹의 기반으로 다음 몇 가지 마법 처리를 얻을 수 있습니다. 영향을받는 반복 표현식 유형은 &lt;a href=&quot;perlfunc#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt; &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; &lt;/a&gt; 입력 연산자, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt; &lt;code&gt;&amp;lt;PATTERN&amp;gt;&lt;/code&gt; &lt;/a&gt; globbing 연산자 및 &lt;a href=&quot;perlfunc#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 입니다. 조건식이 이러한 식 유형 중 하나이면 반복 연산자에 의해 생성 된 값이 암시 적으로 &lt;code&gt;$_&lt;/code&gt; 할당됩니다.. 조건식이 이러한 식 유형 중 하나이거나 그 중 하나를 스칼라에 명시 적으로 할당하는 경우 조건은 실제로 정규 진리 값이 아닌 식 값의 정의를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c5dcda0eb63d695c2273d9f58a5b27fc7e844c60" translate="yes" xml:space="preserve">
          <source>If the configurations variable &lt;code&gt;build_dir_reuse&lt;/code&gt; is set to a true value, then CPAN.pm reads the collected YAML files. If the stored signature matches the currently running perl, the stored state is loaded into memory such that persistence between sessions is effectively established.</source>
          <target state="translated">구성 변수 &lt;code&gt;build_dir_reuse&lt;/code&gt; 가 true 값으로 설정되면 CPAN.pm은 수집 된 YAML 파일을 읽습니다. 저장된 서명이 현재 실행중인 perl과 일치하면 저장된 상태는 메모리에로드되어 세션 간의 지속성이 효과적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a91d44bc473043f072a494275450d9c876250d17" translate="yes" xml:space="preserve">
          <source>If the connection is via a firewall then the &lt;code&gt;authorize&lt;/code&gt; method will be called with no arguments.</source>
          <target state="translated">방화벽을 통한 연결 인 경우, &lt;code&gt;authorize&lt;/code&gt; 메소드가 인수없이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="880ff18ec98ddcf514d383275dae13c355bbcadf" translate="yes" xml:space="preserve">
          <source>If the construct is a here-doc, the ending delimiter is a line that has a terminating string as the content. Therefore &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; is terminated by &lt;code&gt;EOF&lt;/code&gt; immediately followed by &lt;code&gt;&quot;\n&quot;&lt;/code&gt; and starting from the first column of the terminating line. When searching for the terminating line of a here-doc, nothing is skipped. In other words, lines after the here-doc syntax are compared with the terminating string line by line.</source>
          <target state="translated">구문이 here-doc 인 경우 끝 구분 기호는 내용으로 종료 문자열이있는 줄입니다. 따라서 &lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt; 는 종료된다 &lt;code&gt;EOF&lt;/code&gt; 바로 뒤에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 과 종단 행의 첫 번째 열에서 시작. here-doc의 종료 라인을 검색 할 때 건너 뛰는 것이 없습니다. 즉, here-doc 구문 뒤의 줄은 종료 문자열과 한 줄씩 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="e1f5405c8fb7cef756ea27523f26d6d391697258" translate="yes" xml:space="preserve">
          <source>If the constructor fails undef will be returned and an error message will be in $@</source>
          <target state="translated">생성자가 실패하면 undef가 반환되고 오류 메시지는 $ @에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd68f60bc1a46c89ed70417ef132417733df0aab" translate="yes" xml:space="preserve">
          <source>If the constructor fails, it will set &lt;code&gt;$@&lt;/code&gt; to an appropriate error message; this may be from &lt;code&gt;$!&lt;/code&gt; or it may be some other string; not every failure necessarily has an associated &lt;code&gt;errno&lt;/code&gt; value.</source>
          <target state="translated">생성자가 실패하면 &lt;code&gt;$@&lt;/code&gt; 를 적절한 오류 메시지로 설정 합니다. &lt;code&gt;$!&lt;/code&gt; 에서 올 수 있습니다 ! 또는 다른 문자열 일 수 있습니다. 모든 실패에 반드시 연관된 &lt;code&gt;errno&lt;/code&gt; 값 이있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a03d6a855f28c1f0fcb373d36da3e2b752b1b618" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;Peer&lt;/code&gt; specification.</source>
          <target state="translated">생성자에 단일 인수 만 전달되면 &lt;code&gt;Peer&lt;/code&gt; 사양으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="59d6c514d80580b526f459658680b5bcb3039600" translate="yes" xml:space="preserve">
          <source>If the constructor is only passed a single argument, it is assumed to be a &lt;code&gt;PeerAddr&lt;/code&gt; specification.</source>
          <target state="translated">생성자에 단일 인수 만 전달되면 &lt;code&gt;PeerAddr&lt;/code&gt; 로 간주됩니다. 사양으로 .</target>
        </trans-unit>
        <trans-unit id="253c66bbe032a626b97c6e706376db98b636ddae" translate="yes" xml:space="preserve">
          <source>If the constructor is passed a defined but false value for the &lt;code&gt;Blocking&lt;/code&gt; argument then the socket is put into non-blocking mode. When in non-blocking mode, the socket will not be set up by the time the constructor returns, because the underlying &lt;code&gt;connect(2)&lt;/code&gt; syscall would otherwise have to block.</source>
          <target state="translated">생성자가 &lt;code&gt;Blocking&lt;/code&gt; 인수에 대해 정의되었지만 false 값이 전달 되면 소켓은 비 차단 모드로 전환됩니다. 비 차단 모드에있을 때 기본 &lt;code&gt;connect(2)&lt;/code&gt; 호출이 차단되어야하기 때문에 생성자가 반환 할 때까지 소켓이 설정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c1d4da7e238174b01de906293d93c6822b7ffed" translate="yes" xml:space="preserve">
          <source>If the count doesn't impress your friends, then the code might. :-)</source>
          <target state="translated">카운트가 친구에게 감동을주지 않으면 코드가 영향을 줄 수 있습니다. :-)</target>
        </trans-unit>
        <trans-unit id="e2812a31f32729d7d8acbab2252b618f1597089e" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt; , so there may be a race condition.</source>
          <target state="translated">현재 디렉토리에 쓰기 가능하지 않은 경우 수정 된 &lt;code&gt;tmpnam&lt;/code&gt; 을 사용하여 파일이 작성 되므로 경쟁 조건이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58341845d1b46d579ba494b307ff64132940c287" translate="yes" xml:space="preserve">
          <source>If the current directory is not writable, file is created using modified &lt;code&gt;tmpnam&lt;/code&gt;, so there may be a race condition.</source>
          <target state="translated">현재 디렉토리가 쓰기 가능하지 않은 경우 수정 된 &lt;code&gt;tmpnam&lt;/code&gt; 을 사용하여 파일이 생성 되므로 경쟁 조건이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="494e23aba89eecf5e12f5237686e230eddf4cf1f" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">현재 테스트가 &quot;TODO&quot;로 간주되면 이유가있는 경우이를 반환합니다. 이 이유는 &lt;code&gt;$TODO&lt;/code&gt; 변수 또는 마지막 &lt;code&gt;todo_start()&lt;/code&gt; 호출에서 비롯 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33c537a42d68a9fab37456220c53df0c1404714b" translate="yes" xml:space="preserve">
          <source>If the current tests are considered &quot;TODO&quot; it will return the reason, if any. This reason can come from a &lt;code&gt;$TODO&lt;/code&gt; variable or the last call to &lt;code&gt;todo_start()&lt;/code&gt;.</source>
          <target state="translated">현재 테스트가 &quot;TODO&quot;로 간주되면 이유를 반환합니다. 이 이유는 &lt;code&gt;$TODO&lt;/code&gt; 변수 또는 &lt;code&gt;todo_start()&lt;/code&gt; 대한 마지막 호출 에서 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d07a75af0e09b32f52321893f3368ffdcf3680ce" translate="yes" xml:space="preserve">
          <source>If the data the &lt;code&gt;info&lt;/code&gt; facet needs to convey can be represented as a table then the data may be placed in this attribute in a more raw form for better display. The data must also be represented in the &lt;code&gt;details&lt;/code&gt; attribute for renderers which do not support rendering tables directly.</source>
          <target state="translated">하여 데이터 경우 &lt;code&gt;info&lt;/code&gt; 면의 요구를 전달하기는 다음 테이블로 표현 될 수있는 데이터가 더 나은 디스플레이를 위해 더 원시 형태로이 속성에 배치 될 수있다. 테이블 렌더링을 직접 지원하지 않는 렌더러 의 경우 데이터는 &lt;code&gt;details&lt;/code&gt; 속성 에도 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4dc2b173d8d4940a748b9c83e49e0862799d41a0" translate="yes" xml:space="preserve">
          <source>If the debugging output of &lt;code&gt;-D&lt;/code&gt; doesn't help you, it's time to step through perl's execution with a source-level debugger.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; 의 디버깅 출력이 도움이되지 않으면 소스 레벨 디버거를 사용하여 perl의 실행을 단계별로 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e01dfde61dfe31eebc6c4d98caf34437480ee91e" translate="yes" xml:space="preserve">
          <source>If the default collation sequence is used, and the BASE is less than or equal to 36, the letter case in STR is ignored.</source>
          <target state="translated">기본 데이터 정렬 시퀀스가 ​​사용되고 BASE가 36보다 작거나 같으면 STR의 대소 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9b61b179e59a5faa76c718b44a80bf30b29231" translate="yes" xml:space="preserve">
          <source>If the deferred-write buffer isn't yet full, but the total size of the buffer and the read cache would exceed the &lt;code&gt;memory&lt;/code&gt; limit, the oldest records will be expired from the read cache until the total size is under the limit.</source>
          <target state="translated">지연 쓰기 버퍼가 아직 가득 차지 않았지만 버퍼 및 읽기 캐시의 총 크기가 &lt;code&gt;memory&lt;/code&gt; 초과하는 경우 제한을 하면 총 크기가 한계 미만이 될 때까지 가장 오래된 레코드가 읽기 캐시에서 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="2d787ba93d433e8611c0010f5b5125e21c2fae5b" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no interpolation is done on either the</source>
          <target state="translated">선택한 구분자가 작은 따옴표 인 경우에는</target>
        </trans-unit>
        <trans-unit id="938284088206ea35ed759b0277c2738a57db55da" translate="yes" xml:space="preserve">
          <source>If the delimiter chosen is a single quote, no variable interpolation is done on either the</source>
          <target state="translated">선택한 구분 기호가 작은 따옴표 인 경우 어느 쪽에서도 변수 보간이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd691ad27529116a3a5593dc1f80d4b01d408999" translate="yes" xml:space="preserve">
          <source>If the destination (second argument) already exists and is a directory, and the source (first argument) is not a filehandle, then the source file will be copied into the directory specified by the destination, using the same base name as the source file. It's a failure to have a filehandle as the source when the destination is a directory.</source>
          <target state="translated">대상 (두 번째 인수)이 이미 존재하고 디렉토리이고 소스 (첫 번째 인수)가 파일 핸들이 아닌 경우 소스 파일은 소스 파일과 동일한 기본 이름을 사용하여 대상이 지정한 디렉토리에 복사됩니다. . 대상이 디렉토리 인 경우 파일 핸들을 소스로 사용하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="bf967ef029273cc2d212ca164cc9a8a6a20b4430" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt; , the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt; , a reference to the element itself is returned.</source>
          <target state="translated">요소 유형이 &lt;code&gt;'*'&lt;/code&gt; 로 시작하지 않는 경우 접근자는 요소 값을 할당 후 반환합니다. 요소 유형이 &lt;code&gt;'*'&lt;/code&gt; 로 시작 하면 요소 자체에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="087f6b4ba4b4848e4cef927f8a6659e4cd63651c" translate="yes" xml:space="preserve">
          <source>If the element type does not start with a &lt;code&gt;'*'&lt;/code&gt;, the accessor returns the element value (after assignment). If the element type starts with a &lt;code&gt;'*'&lt;/code&gt;, a reference to the element itself is returned.</source>
          <target state="translated">요소 유형이 &lt;code&gt;'*'&lt;/code&gt; 로 시작하지 않으면 접근자는 할당 후 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*'&lt;/code&gt; 로 시작 하면 요소 자체에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4e23930732591461e14ec21d8b1f90dcd530ad74" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt; , the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt; , a reference to the element is returned.</source>
          <target state="translated">요소 유형이 &lt;code&gt;'$'&lt;/code&gt; 인 경우 (할당 후) 요소 값이 리턴됩니다. 요소 유형이 &lt;code&gt;'*$'&lt;/code&gt; 이면 요소에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="416316907f2cce96ccc209eeb130ba72299c8e3b" translate="yes" xml:space="preserve">
          <source>If the element type is &lt;code&gt;'$'&lt;/code&gt;, the value of the element (after assignment) is returned. If the element type is &lt;code&gt;'*$'&lt;/code&gt;, a reference to the element is returned.</source>
          <target state="translated">요소 유형이 &lt;code&gt;'$'&lt;/code&gt; 이면 요소 값 (할당 후)이 반환됩니다. 요소 유형이 &lt;code&gt;'*$'&lt;/code&gt; 이면 요소에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1bac597df37b35f3a7dd05dd8ec187e68ab2f23b" translate="yes" xml:space="preserve">
          <source>If the empty regex &lt;code&gt;//&lt;/code&gt; is used, the string is split into individual characters. If the regex has groupings, then the list produced contains the matched substrings from the groupings as well:</source>
          <target state="translated">빈 정규식 &lt;code&gt;//&lt;/code&gt; 을 사용하면 문자열이 개별 문자로 분할됩니다. 정규식에 그룹화가있는 경우 생성 된 목록에 그룹화에서 일치하는 하위 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e04e07bd20c824f00e23be10a97b35d7d8bdaf8" translate="yes" xml:space="preserve">
          <source>If the empty regexp &lt;code&gt;//&lt;/code&gt; is used, the regexp always matches and the string is split into individual characters. If the regexp has groupings, then the resulting list contains the matched substrings from the groupings as well. For instance,</source>
          <target state="translated">빈 정규 표현식 &lt;code&gt;//&lt;/code&gt; 을 사용하면 정규 표현식이 항상 일치하고 문자열이 개별 문자로 분할됩니다. 정규 표현식에 그룹이 있으면 결과 목록에 그룹의 일치하는 하위 문자열도 포함됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9160efcd7b61ecdb5eab89bb5f1048b8690bd897" translate="yes" xml:space="preserve">
          <source>If the entereval op is permitted then the code can use eval &quot;...&quot; to 'hide' code which might use denied ops. This is not a major problem since when the code tries to execute the eval it will fail because the opmask is still in effect. However this technique would allow clever, and possibly harmful, code to 'probe' the boundaries of what is possible.</source>
          <target state="translated">entereval op가 허용되면 코드는 eval &quot;...&quot;을 사용하여 거부 된 op를 사용할 수있는 코드를 '숨길'수 있습니다. 코드가 eval을 실행하려고 할 때 opmask가 여전히 유효하기 때문에 실패하기 때문에 이것은 큰 문제가 아닙니다. 그러나이 기술은 영리하고 유해 할 수있는 코드를 통해 가능한 것의 경계를 '탐색'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dd91d8fc44e261add22f788040f3b0d9653b9a" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; is defined it should name a directory into which a copy of the raw TAP for each test will be written. TAP is written to files named for each test. Subdirectories will be created as needed.</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_TEST_HARNESS_DUMP_TAP&lt;/code&gt; 가 정의되면 각 테스트에 대한 원시 TAP 사본이 작성 될 디렉토리의 이름을 지정해야합니다. TAP는 각 테스트에 대해 명명 된 파일에 작성됩니다. 필요에 따라 서브 디렉토리가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1677cef1b7d08b33d16cc5ab5e637dae11805c4b" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;SSL_CERT_FILE&lt;/code&gt; is present, HTTP::Tiny will try to find a CA certificate file in that location.</source>
          <target state="translated">환경 변수 &lt;code&gt;SSL_CERT_FILE&lt;/code&gt; 이있는 경우 HTTP :: Tiny는 해당 위치에서 CA 인증서 파일을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="85e9e60a253e04ba9480e07ca8d4f04ff80b74d6" translate="yes" xml:space="preserve">
          <source>If the event is a final subtest event, this should contain the subtest ID.</source>
          <target state="translated">이벤트가 최종 하위 테스트 이벤트 인 경우 하위 테스트 ID를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d65844b53fa3e967e642960ca12717bb316d545" translate="yes" xml:space="preserve">
          <source>If the event is inside a subtest this should have the subtest ID.</source>
          <target state="translated">이벤트가 하위 테스트 내에있는 경우 하위 테스트 ID가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e66c1c6198ecf06cc2142e9e5e1dd957bf8c18d" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script with the &quot;magic&quot; &lt;code&gt;#!&lt;/code&gt; line or &lt;code&gt;extproc&lt;/code&gt; line which specifies shell;</source>
          <target state="translated">system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; 에 의해 호출 된 실행 파일 이 &quot;magic&quot; &lt;code&gt;#!&lt;/code&gt; 쉘을 지정하는 라인 또는 &lt;code&gt;extproc&lt;/code&gt; 라인;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
