<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것은 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 이 목적 으로 규칙적인 &lt;code&gt;foreach&lt;/code&gt; 루프를 사용하는 것이 대부분 더 명확합니다. BLOCK 또는 EXPR이 true로 평가되는 원래 목록의 해당 항목으로 구성된 배열에 대해서는 &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것은 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 이 목적 으로 규칙적인 &lt;code&gt;foreach&lt;/code&gt; 루프를 사용하는 것이 대부분 더 명확합니다. BLOCK 또는 EXPR이 true로 평가되는 원래 목록의 해당 항목으로 구성된 배열에 대해서는 &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;$processed&lt;/code&gt; (비어있을 수있다 &lt;code&gt;$normalized&lt;/code&gt; 후, 마지막에는 스타터 시동 또는 시작을 포함하지 않는다), 및 &lt;code&gt;$unprocessed&lt;/code&gt; 전체 같아야 &lt;code&gt;$normalized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2dca7ba63a68f9fddd9b7ac309791bf8abd311e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f1dc26add5ebccf190f8ef66eb27e1f5723ef3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt;, the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2098e1cc9941a87eb89bbdff478cb887098142a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(?[ ])&lt;/code&gt; is a regex-compile-time construct. Any attempt to use something which isn't knowable at the time the containing regular expression is compiled is a fatal error. In practice, this means just three limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09559e1981494f86fde1566facece3e2639305" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--opt value&lt;/code&gt; is still accepted, even though GNU getopt_long() doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc9bdd2d79f09af0f88913bcc31f66fb74dccd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-register&lt;/code&gt; is a global setting that applies to the entire program; it cannot be applied only for certain callers, removed, or limited by lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">참고 &lt;code&gt;-s/a/b/&lt;/code&gt; 부정 된 대체하지 않습니다. 말하는 &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 예상대로 여전히 작동하지만 : 마이너스를 다음 단 하나의 문자가 파일 테스트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">참고 &lt;code&gt;-s/a/b/&lt;/code&gt; 부정 된 대체하지 않습니다. 말하는 &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 예상대로 여전히 작동하지만 : 마이너스를 다음 단 하나의 문자가 파일 테스트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f960c753f2dbcaaba10ddc75d049f8c367286e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-exp($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">참고 &lt;code&gt;:constants256&lt;/code&gt; 당신이 둘을 혼합하려는 경우 그래서, 당신은 포함해야, 다른 상수를 포함하지 않는 &lt;code&gt;:constants&lt;/code&gt; 물론. 다음 과 같이 명시 적으로 적어도 &lt;code&gt;RESET&lt;/code&gt; 을 가져와야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e353e5ca3a012a60bd40d8c3d650a30fa181791c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt;, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">하는 것으로 &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 각 테스트의 대기 종료 상태의 합계입니다. 이 값은 0이 아닌 경우에만 실제 값을 제공하기 위해 합계됩니다.</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">주의 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 은 위에 나열되지 않습니다. Time :: Piece 객체에서 메서드로 호출되면 생성자 역할을하여 현재 시간에 대한 새로운 Time :: Piece 객체를 반환합니다. 다시 말해, 그들은 방법으로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 반환에게 마지막 문자를. 마지막 문자를 제외한 모든 문자를 반환하려면 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 당신의 전화를하지 않습니다 &lt;code&gt;END&lt;/code&gt; 의 블록 않으며 호출합니다 &lt;code&gt;DESTROY&lt;/code&gt; 의 오브젝트의 메소드를.</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">양해 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 은 fcntl (2)를 구현하지 않는 컴퓨터에서 사용하는 경우 예외를 발생시킵니다. 시스템에서 어떤 기능을 사용할 수 있는지 알아 보려면 Fcntl 모듈 또는 fcntl (2) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 정상 파일 핸들을 사용하는 경우 일반적으로 필요하지 않습니다; 필요한 경우 기존 레코드 구조 파일에 대한 I / O를 제어 할 수 있도록 제공됩니다. VMS :: Stdio 확장에서 &lt;code&gt;vmsfopen&lt;/code&gt; 기능을 사용하여 레코드 구조가 다른 파일 및 장치에 대한 I / O를보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 반환에게 마지막 문자를. 마지막 문자를 제외한 모든 문자를 반환하려면 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 당신의 전화를하지 않습니다 &lt;code&gt;END&lt;/code&gt; 의 블록 않으며 호출합니다 &lt;code&gt;DESTROY&lt;/code&gt; 의 오브젝트의 메소드를.</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">양해 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 은 fcntl (2)를 구현하지 않는 컴퓨터에서 사용하는 경우 예외를 발생시킵니다. 시스템에서 어떤 기능을 사용할 수 있는지 알아 보려면 Fcntl 모듈 또는 fcntl (2) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 공백 및 취급에 별도의 패턴으로 각 세그먼트를 인수 분할합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 는 모든 파일과 a</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; EMX의 현재 버전에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 가 fdopen () C 라이브러리 기능에 따라 달라집니다. 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패하는 것으로 알려져 있습니다. 그보다 많은 파일 디스크립터가 필요한 경우 POSIX :: open () 함수 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 않습니다 &lt;b&gt;하지&lt;/b&gt; 같은 정규 표현식 문자 클래스를 할 &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;\pL&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 운영자는 일치하지 않는 &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; 유틸리티. 소문자 / 대문자간에 문자열을 매핑하려면 &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 및 &lt;a href=&quot;functions/uc&quot;&gt;uc를&lt;/a&gt; 참조 하고 일반적 으로 정규식이 필요한 경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 연산자 사용을 고려하십시오 . &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;\l&lt;/code&gt; 치환 연산자 오른쪽 문자열 보간 탈출 정확한 대소 매핑을 수행 할 것이지만 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; 레거시 7 비트 데이터를 제외하고는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">참고는 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 보간 문자열에가 대문자로 변환 한 상태 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\u&lt;/code&gt; 보간 된 문자열의 (구별없이 언어 자로 상당)을 구분하는 언어는 타이틀 케이스로 변환한다.</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 공백 및 취급에 별도의 패턴으로 각 세그먼트를 인수 분할합니다. 따라서 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 는 모든 파일과 a</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 가 fdopen () C 라이브러리 기능에 따라 달라집니다. 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패하는 것으로 알려져 있습니다. 그보다 많은 파일 디스크립터가 필요한 경우 POSIX :: open () 함수 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f9b1a84ba3ae7615ac251b965f25b6f6929c148a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; requires &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; because the conversion routine cannot differentiate whether the last &lt;code&gt;.&lt;/code&gt; of a Unix specification is delimiting a version, or is just part of a file specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">참고 &lt;code&gt;Dump&lt;/code&gt; 보고하지 않습니다</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">참고 &lt;code&gt;END&lt;/code&gt; 의 코드 블록이되어 &lt;b&gt;있지&lt;/b&gt; 문자열의 끝에서 실행 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; : 어떤 경우 &lt;code&gt;END&lt;/code&gt; 의 코드 블록은 문자열에서 만든 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , 그들은 다른처럼 실행됩니다 &lt;code&gt;END&lt;/code&gt; LIFO 순서 그냥 해당 패키지의 코드 블록 통역사가 종료되기 전에.</target>
        </trans-unit>
        <trans-unit id="87d3d5579888e295497dd30ab3df3385d0ee5915" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;eval()&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;eval()&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; 및 &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; 전역 변수를 설정하고, 따라서 &lt;b&gt;어떤&lt;/b&gt; 새로 생성 된 번호가 글로벌 반올림 대상이 될 것입니다 &lt;b&gt;즉시&lt;/b&gt; . 이것은 위 예제 에서 &lt;code&gt;bdiv()&lt;/code&gt; 인수 인 &lt;code&gt;3&lt;/code&gt; 도 &lt;b&gt;5&lt;/b&gt; 의 정확도를 얻음을 의미합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;NULL&lt;/code&gt; 이 유효하다 &lt;code&gt;proto&lt;/code&gt; 항상 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="199f2f9c1f354b6dfdfcfb899b79a41c177c2dfa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">참고 &lt;code&gt;STDERR&lt;/code&gt; 는 관계없이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">참고 &lt;code&gt;TAP::Parser&lt;/code&gt; 는 대부분의 새로운 개체를 만드는 책임이있다 : 즉, - 중앙 &quot;메이커&quot;를 수 있도록 설계되었습니다 &lt;code&gt;TAP::Parser::*&lt;/code&gt; 네임 스페이스.</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">참고 &lt;code&gt;UNIVERSAL&lt;/code&gt; (그리고 모든 회원 &lt;code&gt;UNIVERSAL&lt;/code&gt; 의 MRO)이, 클래스의 MRO의 일부가 아닌 경우에도 암시 적으로 모든 클래스에서 상속 방법하지만 &lt;code&gt;UNIVERSAL&lt;/code&gt; 과 그 부모.</target>
        </trans-unit>
        <trans-unit id="d2ebe68731e3dfdbe752ef6caa15931a10fc553d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt;'s MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd56e1e046b5a0f876bfdbc7dc77a2bed0822bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, it matches the character or character sequence whose name is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">참고 &lt;code&gt;\N&lt;/code&gt; 두 가지 의미를 갖는다. &lt;code&gt;\N{NAME}&lt;/code&gt; 형식 인 경우 이름이 &lt;code&gt;NAME&lt;/code&gt; 인 문자 또는 문자 시퀀스와 일치합니다 . 마찬가지로 &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; 형식 인 경우 유니 코드 코드 포인트가 문자 인 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;\N{...}&lt;/code&gt; 비열한 수있는 &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;이름 또는 번호 문자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;\N{...}&lt;/code&gt; 컴파일 시간; 큰 따옴표 문자열 안에 사용되는 특수한 형식의 문자열 상수입니다. 이는 &lt;code&gt;\N{...}&lt;/code&gt; 내부에서 변수를 사용할 수 없음을 의미합니다 . 비슷한 런타임 기능을 원하면 &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame ()을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ceeaecdecef4fbab384a44465508a20a199dce2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt;. If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">참고 &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; , 어디</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">참고 &lt;code&gt;\c\&lt;/code&gt; 정규 표현식 (또는 두 배 인용 문자열)의 끝에 혼자가 유효하지 않습니다. 백 슬래시 뒤에 다른 문자가 와야합니다. 즉, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; 의미 합니다. 모든 문자에 대해 ' &lt;i&gt;X&lt;/i&gt; '</target>
        </trans-unit>
        <trans-unit id="e1ebc62194ed9270f2f0ded9d5873b50990282bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;binmode&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">참고 &lt;code&gt;blessed($thing)&lt;/code&gt; 경우도 false를 반환합니다 &lt;code&gt;$thing&lt;/code&gt; &quot;0&quot;라는 이름의 클래스로 축복하고있다. 이것은 가능하지만 병리학 적입니다. 수행중인 작업을 모르면 &quot;0&quot;이라는 클래스를 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e26f8bbaa602bc77ce825cb115ea483aef29de1d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cx_pushblock()&lt;/code&gt; sets two new floors: for the args stack (to &lt;code&gt;MARK&lt;/code&gt;) and the temps stack (to &lt;code&gt;PL_tmps_ix&lt;/code&gt;). While executing at this scope level, every &lt;code&gt;nextstate&lt;/code&gt; (amongst others) will reset the args and tmps stack levels to these floors. Note that since &lt;code&gt;cx_pushblock&lt;/code&gt; uses the current value of &lt;code&gt;PL_tmps_ix&lt;/code&gt; rather than it being passed as an arg, this dictates at what point &lt;code&gt;cx_pushblock&lt;/code&gt; should be called. In particular, any new mortals which should be freed only on scope exit (rather than at the next &lt;code&gt;nextstate&lt;/code&gt;) should be created first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">참고 &lt;code&gt;gen_delimited_pat&lt;/code&gt; 가 이전에 불려 &lt;code&gt;delimited_pat&lt;/code&gt; . 해당 이름은 계속 사용할 수 있지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72d7884266eebfa7e1a24e791ad9ea94730bed68" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt;. That name may still be used, but is now deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a865bc718b78b08d20efdc599ac6b3675ef080" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;kill -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd7dada581d4f39d8fce5c8c1d0ecbac2ea1218" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">참고 &lt;code&gt;make_source&lt;/code&gt; 및 &lt;code&gt;make_perl_source&lt;/code&gt; 가 왔다</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">그 주 &lt;code&gt;openlog()&lt;/code&gt; 지금처럼 세 개의 인수를 &lt;code&gt;openlog(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="107847c03394449c5b753c11d610306353b4ed86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20aeb476985aacd52e5f965fd1bbff8fbe0c7c39" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;pad_findlex()&lt;/code&gt; is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in &lt;code&gt;xpadn_low&lt;/code&gt; the index into the parent pad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;size&lt;/code&gt; 대상 버퍼의 전체 크기이며, 결과가 보장되는 &lt;code&gt;NUL&lt;/code&gt; 은 공간이있는 경우로 끝나는. &lt;code&gt;NUL&lt;/code&gt; 을 위한 공간 은 &lt;code&gt;size&lt;/code&gt; 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1eb316f8ef59a8e93ddd67dae614660ddbd436c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt;-terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8099742523782e905e75bc531c5f7ea28d83c88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort_by&lt;/code&gt; affects all the plain hashes in the data structure. If you need finer control, &lt;code&gt;tie&lt;/code&gt; necessary hashes with a module that implements ordered hash (such as &lt;a href=&quot;Hash::Ordered&quot;&gt;Hash::Ordered&lt;/a&gt; and &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt;). &lt;code&gt;canonical&lt;/code&gt; and &lt;code&gt;sort_by&lt;/code&gt; don't affect the key order in &lt;code&gt;tie&lt;/code&gt;d hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">참고 &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 있습니다</target>
        </trans-unit>
        <trans-unit id="c694dbb84b91dadc0270b7093942a49dccfcd18d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297cb2762357bcbc37087b287127235df664073c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs, and add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">참고 &lt;code&gt;sv_magicext&lt;/code&gt; 가 이 일 수 &lt;code&gt;sv_magic&lt;/code&gt; 는 하지 않습니다를. 특히 SvREADONLY SV에 마법을 추가하고 동일한 '방법'의 인스턴스를 두 개 이상 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">참고 &lt;code&gt;sv_setref_pv&lt;/code&gt; 의 복사본을 포인터이 복사하는 동안 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">참고 &lt;code&gt;sv_setref_pvn&lt;/code&gt; 에 복사합니다 문자열이 복사하는 동안 포인터를.</target>
        </trans-unit>
        <trans-unit id="ca9054fd02ce103d72fc003e486b493405a56eb5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tr&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt;. The &lt;code&gt;tr&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; utility. &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; will uppercase the 26 letters &quot;a&quot; through &quot;z&quot;, but for case changing not confined to ASCII, use &lt;a href=&quot;perlfunc#lc&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#uc&quot;&gt;&lt;code&gt;uc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lcfirst&quot;&gt;&lt;code&gt;lcfirst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ucfirst&quot;&gt;&lt;code&gt;ucfirst&lt;/code&gt;&lt;/a&gt; (all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;), or the &lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;substitution operator &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt;&lt;/a&gt; (with &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968eb220f1920402825447b300d7614d04828e7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;uc()&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;ucfirst&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40c8f91ea36b67ee3cfa45c32946c2ec3844b33" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqint&lt;/code&gt; are well-behaved as integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf172390d0d301f41e881eb119b5f9d655cba59" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqnum&lt;/code&gt; are well-behaved as numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1438af20c640a879b280a807cfcb4c4b1f563f7c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other string operations treat it; it compares equal to the empty string but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into an empty string, so that the entire list of values returned by &lt;code&gt;uniqstr&lt;/code&gt; are well-behaved as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">참고 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 문자열 바이트에 맞지 않는 문자가 포함 된 경우 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="244a344737b42f7a4dc0804c6a1816a678ff0765" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">= end 명령은 현재 열려있는 = begin 명령과 일치해야합니다. 즉, 제대로 중첩되어야합니다. 예를 들어, 이것은 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="eaeb65853d186efa2ac24ebd60591d6679af5af8" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&quot;&quot;\c%c&quot; is more clearly written simply as &quot;%s&quot;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">제어 문자에 맵핑되지 않은 ASCII 문자는 사용하지 않는 것이 좋으며 경고를 생성합니다 (활성화 된 경우). &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c % c는 더 명확하게 % s로 작성됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">E &amp;lt;번호&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">1.14 이전의 GNU tar는 &lt;code&gt;POSIX header prefix&lt;/code&gt; 잘 맞지 않습니다 . 이러한 버전을 사용하는 경우 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1703b14dd9d7aca1f4b440f1de3dd5da07ea976" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt;. If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">GNU의 gzip / gunzip은 Info-ZIP의 zip / unzip 패키지와 다릅니다. 전자는 간단한 압축 도구입니다. 후자는 다중 파일 아카이브 작성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">이상적인 해시의 경우 해시 품질 평가 점수가 1이고, 1 이하의 숫자는 좋은 해싱을 나타내고, 위의 숫자는 점수가 좋지 않은 것을 나타냅니다. 실제로는 0.95에서 1.05 사이 여야합니다. 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5fc2a35e63a8ddebfc4d138e20ffc7c6e9a57238" translate="yes" xml:space="preserve">
          <source>Note that I could not run successful smokes when initiated by the Synology Task Scheduler. I resorted to initiating the smokes via a cron job run on another system, using ssh:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4524e41048103b895691d929d6149e5d9f22f" translate="yes" xml:space="preserve">
          <source>Note that ISO-8859-1-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">META 파일은 UTF-8 인코딩으로 만 예상됩니다. 문자열 데이터를 변환 할 때는 먼저 UTF-8에서 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">MakeMaker는 실제로 사용하고 있다고 생각하는 'make'에 따라 다른 구문으로 makefile을 생성합니다. 따라서 Config.pm에 다음 값 중 하나가 나타나는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">Perl은 ASCII 또는 EBCDIC에서 컴파일되고 실행될 수 있습니다 ( &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; 참조 ). 대부분의 문서 (및 코드의 주석)는 EBCDIC 가능성을 무시합니다. 거의 모든 목적을 위해 차이점이 투명합니다. 예를 들어, UTF-8 대신 EBCDIC에서 UTF-EBCDIC는 유니 코드 문자열을 인코딩하는 데 사용 &lt;code&gt;utf8&lt;/code&gt; 문서가 utf8 (및 함수 이름을 포함하여 해당 이름의 변형)을 참조 할 때마다 (기본적으로 투명하게) &lt;code&gt;UTF-EBCDIC&lt;/code&gt; 을 의미합니다 . 그러나 문자 순서는 ASCII, EBCDIC 및 UTF- 인코딩간에 다르며 UTF-EBCDIC로 인코딩 된 문자열은 UTF-8보다 많은 바이트를 차지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8390b60c04725a0174dd4b5588a54acdd18f9b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt;. But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy a different number of bytes than in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">Perl은 grapheme 클러스터를 별도의 문자로 간주하므로</target>
        </trans-unit>
        <trans-unit id="29139db0e01423398a38202c816ab0163a1e630a" translate="yes" xml:space="preserve">
          <source>Note that Perl does Full case-folding in matching, not Simple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">COMSPEC은 사용자간에 변동성이 높기 때문에 Perl은 이러한 목적으로 COMSPEC을 사용하지 않으므로 이식성 문제가 발생합니다. 또한 Perl은 대화식으로 사용하기에 적합하지 않은 쉘을 사용할 수 있으며 이러한 쉘로 COMSPEC을 설정하면 다른 프로그램 (일반적으로 COMSPEC에서 대화식으로 사용하기에 적합 함)을 올바르게 작동하는 데 방해가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">Perl은 syscall에 최대 14 개의 인수 만 전달할 수 있습니다. 실제로는 일반적으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">OS / 2가 지정된 응용 프로그램을 시작할 수없는 경우에만 Perl이 스크립트를 찾기 시작하므로 실행 파일이 있으면 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; 는 스크립트를 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44957b723edd6e235f882ee4085c7777338d3275" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;system 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">포드 작성자는 &quot;L &amp;lt;text | name&amp;gt;&quot;의 &quot;text&quot;부분 내에서 형식 코드를 사용할 수 있습니다 (L &amp;lt;text | / &quot;sec&quot;&amp;gt; 등).</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">RFC 1951 데이터는 특히 자동 감지하려는 경우 압축 형식을 선택하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">SHA-1과 SHA-2는</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">TODO 테스트</target>
        </trans-unit>
        <trans-unit id="40402ed7efd78d7a86f48194a3b6516e77f57a23" translate="yes" xml:space="preserve">
          <source>Note that Test::Builder ensures that any diagnostics end in a \n and it in earlier versions of Test::Tester it was essential that you have the final \n in your expected diagnostics. From version 0.10 onward, Test::Tester will add the \n if you forgot it. It will not add a \n if you are expecting no diagnostics. See below for help tracking down hard to find space and tab related problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">Tie :: File은 내부적으로 열린 파일 핸들 만 닫습니다. 위와 같이 파일 핸들을 전달한 경우, 파일 핸들을 &quot;소유&quot;하고 @array를 풀고 닫을 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bba5758898958160c86aa3ac20956cb9f092bfd" translate="yes" xml:space="preserve">
          <source>Note that Vietnamese is listed above. Also read &quot;Encoding vs Charset&quot; below. Also note that these are implemented in distinct modules by countries, due to the size concerns (simplified Chinese is mapped to 'CN', continental China, while traditional Chinese is mapped to 'TW', Taiwan). Please refer to their respective documentation pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6817ce7211b8227d70ebd744addb1493f99a5309" translate="yes" xml:space="preserve">
          <source>Note that [= =] and [. .] are not currently implemented; they are simply placeholders for future extensions and will cause fatal errors. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">&quot;= 시작</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">빈 줄에는 공백이 없어야합니다. 따라서 &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; 은 한 단락이지만 &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; 은 두 단락 입니다.</target>
        </trans-unit>
        <trans-unit id="06686ad7be28b42e56c1b53fdf5f7299621f801d" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; can be used to effect an early exit out of such a block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af33f5ad0150d9ac083cf6a5c7a2b96b3db24b" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will exit such a block early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98374e4e319a2a54ea762e6c2ec205f5e2e7d62" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 는 그러한 블록에서 조기에 빠져 나오는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 그러한 블록을 일찍 종료합니다.</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 그러한 블록 내부에서 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 하면 효과적으로 블록을 구성으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 는 그러한 블록에서 조기에 빠져 나오는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 그러한 블록을 일찍 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 그러한 블록 내부에서 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 하면 효과적으로 블록을 구성으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">8 진수 이스케이프로 표현 된 문자는 정규식 엔진에서 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">이 이스케이프 중 하나로 표현 된 문자는 정규식 엔진에서 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">명명 된 또는 번호가 지정된 문자로 표현 된 문자 또는 문자 시퀀스는 정규식 엔진에 의해 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="1aed6736ceb1599c4759de82b494ba581fec4d4a" translate="yes" xml:space="preserve">
          <source>Note that a comment can go just about anywhere, except in the middle of an escape sequence. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">여러 요소 범위의 오프셋을 추가하여 해당 속성 만 조정해야하는 경우 형식은 문자 &quot;a&quot;로 시작합니다. 이러한 모든 특성에 대해 맵이 정수인 스칼라 인 경우에만 항목을 조정해야합니다. 즉, 정규식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1afc508afbed8c0f7ac0e4b478337da8478bd121" translate="yes" xml:space="preserve">
          <source>Note that a parser is not expected to distinguish between something that looks like pod, but is in a quoted string, such as a here document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">숫자 연산을 통해 스칼라에 문자열 및 숫자 내용을 모두 갖도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e66da593ccdd13e9412f5c3278043542df9a102" translate="yes" xml:space="preserve">
          <source>Note that a server that is also a domain controller is reported as PRODUCTTYPE 2 (Domaincontroller) and not PRODUCTTYPE 3 (Server).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">공유 변수는 둘 이상의 스레드가 동시에이를 수정하려고 할 때 변수의 내부 상태가 손상되지 않도록합니다. 그러나 다음 섹션에서 설명하는 것처럼이 이상의 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">위의 부작용은 &lt;code&gt;mkpath&lt;/code&gt; 와 &lt;code&gt;rmtree&lt;/code&gt; 가 더 이상 내보내지지 않는다는 것입니다. &lt;code&gt;Exporter&lt;/code&gt; 모듈이 작동 하는 방식 때문 입니다. 새 인터페이스를 사용하기 위해 코드베이스를 마이그레이션하는 경우 모든 것을 명시 적으로 나열해야합니다. 그러나 그것은 어쨌든 좋은 습관입니다.</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">POSIX 1003.1-1996에 따라 FILENAME에는 여러 개의 후행 슬래시가있을 수 있습니다. 일부 운영 및 파일 시스템은이 권한을 얻지 못하므로 Perl은 모든 슬래시를 자동으로 제거하여 모든 사람을 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="128d061a1fa86fd129c7cba87a1e4d16eaa8deb7" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">모든 C 프로그램 (C로 작성된 perl 인터프리터 포함)에는 항상 기본 로케일이 있습니다. &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; 호출로 변경되지 않는 한 해당 로케일은 &quot;C&quot;로케일 입니다. Perl은 시작할 때 기본 로케일을 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 로 표시된 로케일로 변경합니다 . 사용하는 경우 &lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈 또는 XS 코드를 작성, 기본 로케일이 프로그램이 명시 적으로 변경되지 않은 경우에도, &quot;C&quot;가 아닌 다른 것이 될 수 있다는 것을 명심하는 것이 중요하다.</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">모든 Perl API 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 접두사 로 참조해야합니다 . 다시, 여기에 나열되지 않은 것은 확장 기능 작성자가 사용하지 않으며 통지없이 변경하거나 제거 할 수 있습니다. 매크로와 동일합니다. 오래된 매크로 이름과의 호환성을 위해 일부 매크로가 제공되지만 이후 릴리스에서는이 지원이 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">모든 액세스는 읽기 전용입니다. 이 모듈을 사용하여 내부를 수정할 수 없습니다. 또한이 모듈에 의해 생성 된 B :: OP 및 B :: SV 객체는 기본 객체가 존재하는 한 유효합니다. 그들의 생성은 기본 객체의 참조 카운트를 증가시키지 않습니다. 해제 된 객체의 필드에 액세스하려고하면 이해할 수없는 결과가 발생하거나 더 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">필수적이지 않은 모든 밑줄은 아래의 짧은 이름 표시에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">위의 모든 내용은 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 범위 내에서 재정의됩니다 . 그러나이 pragma는 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">% result의 모든 업데이트는 추가 적이므로 해시는 사용 전에 지워지지 않으므로 많은 설치 상태 결과를 쉽게 집계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">이 빠른 개요에서 여기에 설명 된 모든 것은 &lt;b&gt;Pod :: Parser&lt;/b&gt; 를 스트림 기반 구문 분석을 수행 하는 가장 단순하고 간단한 방법 입니다. 보다 정교한 트리 기반 구문 분석을 수행 하기 위해 &lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt; 함수 를 사용할 수도 있습니다 . &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;트리 기반 패링을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31e72345bf22d6545d4882f14a8418945d8ea12a" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. But there are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt;s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt;, both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">거의 모든 속성은 대소 문자를 구분하지 않습니다. 즉, &lt;code&gt;/i&lt;/code&gt; 정규식 수정자를 추가해도 일치하는 내용은 변경되지 않습니다. 영향을받는 두 세트가 있습니다. 첫 번째 세트는 &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; 및 &lt;code&gt;Titlecase_Letter&lt;/code&gt; 일치, 모두 &lt;code&gt;Cased_Letter&lt;/code&gt; 를 아래 &lt;code&gt;/i&lt;/code&gt; 정합. 두 번째 세트는 &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; 및 &lt;code&gt;Titlecase&lt;/code&gt; 모두 매치 그중 &lt;code&gt;Cased&lt;/code&gt; 아래 &lt;code&gt;/i&lt;/code&gt; 정합. (이 세트의 차이점은 로마 숫자와 같은 일부는 대문자와 소문자로 표시되므로 &lt;code&gt;Cased&lt;/code&gt; 하지만이되지 않도록, 문자로 간주되지 않습니다 &lt;code&gt;Cased_Letter&lt;/code&gt; 들. 실제로는 &lt;code&gt;Letter_Number&lt;/code&gt; 입니다.)이 세트에는 &lt;code&gt;/i&lt;/code&gt; 아래 &lt;code&gt;PosixAlpha&lt;/code&gt; 와 일치 하는 &lt;code&gt;PosixUpper&lt;/code&gt; 및 &lt;code&gt;PosixLower&lt;/code&gt; 하위 세트도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="410bccdb373a09459be0a143786fbdbb58b254bf" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be a dual-valued variable, it is actually implemented as a magical variable inside the interpreter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">비록 &lt;code&gt;$!&lt;/code&gt; 이중 값 변수 인 것처럼 보이며 실제로는 스칼라를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역에는 일부 내용이 있어야합니다. 즉, 저자는 다음과 같이 빈 영역이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">INVARIANT 문자 (예 : 비 EBCDIC 시스템의 ASCII)는 유효한 UTF-8 문자입니다.</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">&quot;use vmsish&quot;로 인해 'hushed'로 컴파일 된 exit () 또는 die ()는 런타임에 vmsish :: hushed (0)을 호출하여 숨겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81d903b0a8613702e9500c6611625b2061527ec5" translate="yes" xml:space="preserve">
          <source>Note that an implication of this form is that there are identifiers only legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, and vice-versa, for example the identifier &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; is legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, but is otherwise considered to be the single character variable &lt;code&gt;$&amp;eacute;&lt;/code&gt; followed by the bareword &lt;code&gt;&quot;tat&quot;&lt;/code&gt;, the combination of which is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51bafab03bc7a99a9ff353e9d7023e5249a4ecb" translate="yes" xml:space="preserve">
          <source>Note that any &lt;code&gt;()&lt;/code&gt; constructs enclosed within this one will still capture unless the &lt;code&gt;/n&lt;/code&gt; modifier is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d96be8f0f46d40e0807e85460543821cad6f82" translate="yes" xml:space="preserve">
          <source>Note that any filehandle being printed to under UTF-8 must be expecting UTF-8 in order to get good results and avoid Wide-character warnings. One way to do this for typical filehandles is to invoke perl with the &lt;code&gt;-C&lt;/code&gt;&amp;gt; parameter. (See &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;-C [number/list]&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">이 문서 (또는 &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; ) 에 문서화되어 있지 않은 모든 변수와 함수는 내부 용으로 만 고려되며 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">이 맨 페이지 (또는 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; ) 에 설명되어 있지 않은 모든 변수와 함수는 내부 용으로 만 간주되며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 내부의 모든 내용 은 &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않습니다 . 그리고 &lt;code&gt;/x&lt;/code&gt; 는 단일 다중 문자 구성 내에서 공간 해석에 영향을 미치지 않습니다. 예를 들어 &lt;code&gt;\x{...}&lt;/code&gt; 에서 &lt;code&gt;/x&lt;/code&gt; 수정 자에 관계없이 공백이 없어야합니다. &lt;code&gt;{3}&lt;/code&gt; 또는 &lt;code&gt;{5,}&lt;/code&gt; 와 같은 &lt;a href=&quot;#Quantifiers&quot;&gt;수량 자에&lt;/a&gt; 대해서도 동일합니다 . 마찬가지로 &lt;code&gt;(?:...)&lt;/code&gt; 은 &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; 사이에 공백을 사용할 수 없습니다 . 이러한 구문의 구분 기호 내에서 허용되는 공백은 &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않으며 구문에 따라 다릅니다. &lt;code&gt;\x{...}&lt;/code&gt; 16 진수에는 공백이 없기 때문에 공백을 사용할 수 없습니다. 그러나 유니 코드 속성에는 공백 이있을 수 있으므로 &lt;code&gt;\p{...}&lt;/code&gt; 에는 유니 코드 규칙을 따르는 공백이있을 수 있습니다 . 이에 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;대해서는 perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 속성 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f395c3581775a33605e1a803ed3454f86e6d0f9b" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt;, regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt;. Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;?&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; 는 명명 된 시퀀스를 큰 따옴표로 묶은 문자열에 삽입하고 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; 는이 함수와 동일한 문자열을 반환하지만 또한 시퀀스 이름이 아닌 문자 이름에 대해 작동합니다. &lt;a href=&quot;../charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d84df2d91f0e561094d3cfef990178b71accb1" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">Perl 5.20부터 변수 이름의 리터럴 제어 문자는 더 이상 사용되지 않습니다. Perl 5.22부터는 그래픽이 아닌 다른 문자도 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">atan2 (0, 0)은 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 단계에 대해 스케줄 된 속성 핸들러 는 속성이 감지되는 즉시 (즉, 이후에 정의 된 &lt;code&gt;BEGIN&lt;/code&gt; 블록이 실행 되기 전에 ) 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">그 때문에주의 &lt;b&gt;-i&lt;/b&gt; 이름 바꾸기 또는 동일한 이름의 새 파일을 작성하기 전에 원본 파일을 삭제, 유닉스 스타일의 소프트 및 하드 링크가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8849f4f72b8ea78a7d87446400823a7e27b0cb3" translate="yes" xml:space="preserve">
          <source>Note that because how the floating point formats work out, on the most common platforms signaling payload of zero is best avoided, since it might end up being identical to &lt;code&gt;+Inf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">여러 확장 프로그램에서 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 또는 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 매직을 사용하고있을 수 있으므로 확장 프로그램이 충돌을 피하기 위해 특별한주의를 기울여야합니다. 일반적으로 확장과 같은 클래스에 축복받은 물건에 마법을 사용하는 것으로 충분합니다. 들어 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 의 마법, 일반적으로 정의하는 좋은 아이디어입니다 &lt;code&gt;MGVTBL&lt;/code&gt; 를 모든 분야가 될 것입니다 경우에도 &lt;code&gt;0&lt;/code&gt; 을 개별 그래서, &lt;code&gt;MAGIC&lt;/code&gt; 포인터가 마법 가상 테이블을 사용하여 마법의 특별한 종류로 식별 할 수 있습니다. &lt;code&gt;mg_findext&lt;/code&gt; 는 다음과 같은 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cd112df3b0c7a62a90b0cf37e126e846a5257960" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt;, even if all its fields will be &lt;code&gt;0&lt;/code&gt;, so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">어리석은 OS / 2 제한 사항으로 인해 &lt;code&gt;extproc&lt;/code&gt; 을 사용할 때 perl 스크립트의 전체 경로를 사용할 수 없으므로 &lt;code&gt;-S&lt;/code&gt; perl 스위치를 사용해야하며 스크립트가 &lt;code&gt;PATH&lt;/code&gt; 에 있어야합니다 . 좋은 점은 스크립트의 전체 경로를 알고 있다면 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c787f61f07dfdba933460c5bff80047d250cdab7" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt;, thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt;. As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">이 렌더링은 스레드되지 않은 perl에서 수행되었으므로 이전 예제의 PADOP는 이제 SVOP이며 일부 (대부분은 아님) 대괄호는 둥근 대괄호로 대체되었습니다. 이것은 스레드 및 스레드되지 않은 perls의 렌더링을 시각적으로 구분하기위한 미묘한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">우리는 실수의 근사값으로 작업하기 때문에, 위에서 언급 한 특이점에 너무 근접 할 때 이러한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">모두 유의 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 펄을 사용하여 직접 구현 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; C. 경우의에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (참조 &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; ) C 정수를 사용하는 다음 서명 힘이고, 다른 부호 C의 정수를 사용한다. 어느 쪽이든, 구현은 Perl이 빌드 한 정수형의 크기 (32 비트 또는 64 비트)보다 큰 결과를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">참고 둘 것을 &lt;code&gt;hv_store&lt;/code&gt; 및 &lt;code&gt;hv_store_ent&lt;/code&gt; 는 저장된의 참조 횟수가 증가하지 않는 &lt;code&gt;val&lt;/code&gt; 호출자의 책임입니다. 이러한 함수가 NULL 값을 반환하면 호출자는 일반적으로 메모리 누수를 피하기 위해 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 줄여야합니다 .</target>
        </trans-unit>
        <trans-unit id="621c69fc1e5d56916169e38ace21016b25be56a4" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt;, which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">두 경로 모두 디렉토리 경로 (후행 ':')와 파일 경로 (후행 ':'없음)를 구별하는 표기법으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="faee99938a7847d18bb03c4600be6dd36dc0274e" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; 및 &lt;code&gt;FilterName&lt;/code&gt; 옵션 모두 zip 파일 이름 헤더 필드에 사용 된 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">bsd_glob ()는 &lt;code&gt;ENOENT&lt;/code&gt; 및 &lt;code&gt;ENOTDIR&lt;/code&gt; 을 오류로 간주하지 않음으로써 POSIX 및 FreeBSD glob (3) 동작에서 벗어납니다 . &lt;code&gt;GLOB_ERR&lt;/code&gt; 플래그가 설정되어 있지 않으면 bsd_glob ()는 이러한 오류에도 불구하고 처리를 계속 합니다.</target>
        </trans-unit>
        <trans-unit id="bacd6d900d14ad3f25c92e37f8d7ca4d2e6dc3f9" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; on array values is strongly discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c998cb784e028342e5006462f8a42c5345c1974" translate="yes" xml:space="preserve">
          <source>Note that calls to the platform's underlying &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function may block. If &lt;code&gt;IO::Socket::IP&lt;/code&gt; has to perform this lookup, the constructor will block even when in non-blocking mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">재귀 내에서 일치하는 캡처 그룹은 재귀가 반환 된 후에 액세스 할 수 없으므로 추가 캡처 그룹 계층이 필요합니다. 따라서 &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; &lt;code&gt;$+{NAME}&lt;/code&gt; 이 (가)있을 지라도 $ + {NAME_PAT} 이 (가) 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">특정 지수 표현식은 잘못 정의되어 있습니다. 여기에는 &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; 및 &lt;code&gt;Inf**0&lt;/code&gt; 됩니다. 이 특별한 경우의 특정 결과를 기대하지 마십시오. 결과는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3494a62839407764105a4d292aa5c1e195c2757d" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt;, &lt;code&gt;1**Inf&lt;/code&gt;, and &lt;code&gt;Inf**0&lt;/code&gt;. Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">128 ~ 255 (포함)의 문자는 기본적으로 이전 버전과의 호환성을 위해 내부적으로 UTF-8로 인코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a46ebdf91483bc350551ae23b26255499157816" translate="yes" xml:space="preserve">
          <source>Note that checking for a &lt;code&gt;%DOES&lt;/code&gt; hash is an &lt;code&gt;autodie&lt;/code&gt;-only short-cut. Other modules do not use this mechanism for checking roles, although you can use the &lt;code&gt;Class::DOES&lt;/code&gt; module from the CPAN to allow it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;GNU Extended Header&lt;/code&gt; 기능을 지원하지 않는 클라이언트 는이 아카이브를 읽을 수 없습니다. 이러한 클라이언트에는 &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; 및 &lt;code&gt;AIX&lt;/code&gt; 의 tar가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="aae32a0db7b8c17096153a5cf305d70abda69477" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt;, &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">코드 6 (빠른 깜박임) 및 9 (스트라이크 스루)는 ANSI X3.64 및 ECMA-048에 지정되어 있지만 대부분의 디스플레이 및 에뮬레이터에서 일반적으로 지원되지 않으므로 현재이 모듈에서는 지원되지 않습니다. ECMA-048은 또한 글꼴 변경, Fraktur 문자, 이중 밑줄, 프레임, 순환 및 오버 라이닝에 대한 일련의 속성을 포함하여 많은 다른 속성을 지정합니다. 이러한 속성 중 어느 것도 광범위하게 지원되거나 유용하지 않으므로 현재이 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d50e349cf31b07ee4610e705d5521fb0f229097d" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">임의의 스칼라를 일반 PV로 강제 변환하면 유용한 데이터가 제거 될 수 있습니다. 예를 들어, SV가 &lt;code&gt;SvROK&lt;/code&gt; 이면 참조자는 참조 카운트가 감소하고 SV 자체는 &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; 와 같은 값을 포함하는 문자열 버퍼 를 사용하여 &lt;code&gt;SvPOK&lt;/code&gt; 스칼라 로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a47c04c6a9f8c8144c760b18adcdfe977bf88a30" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt;, then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">connected ()는 반 열린 TCP 소켓을 &quot;연결된 상태&quot;로 간주합니다. 특히 connected ()는 &lt;b&gt;ESTABLISHED&lt;/b&gt; 와 &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP 상태를 구분하지 않습니다 . 두 경우 모두 undef가 아닌 peer 주소를 반환합니다. 따라서 일반적으로 connected ()를 사용하면 대부분의 경우 (아래 참조) 로컬 응용 프로그램이 shutdown ()을 호출하거나 닫을 때까지 로컬 TCP 상태 시스템이 &lt;b&gt;CLOSE-WAIT&lt;/b&gt; 상태로 유지되므로 피어가 정상적으로 종료를 시작했는지 여부를 확실하게 알 수 없습니다. (); 그 시점에서만 connected ()가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">현재 일부 테스트 스크립트는 병렬로 실행할 때 실패 할 수 있습니다 (주로</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">define_alias ()는 표준 인코딩 이름을 대체 할 수 없습니다. 잠재적 인 별명을 시도하기 전에 먼저 표준 이름으로 인코딩을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">이 optag의 존재에도 불구하고 메모리 리소스 공격은 여전히 ​​: base_core ops 만 사용하여 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">점 (</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">과도한 편집증으로 인해 $ Getopt :: Std :: STANDARD_HELP_VERSION이 true가 아닌 경우 (기본값은 false), 메시지가 STDERR에 인쇄되고 메시지가 인쇄 된 후에 처리가 계속됩니다. 이는 표준을 따르는 동작과 반대이므로 $ Getopt :: Std :: STANDARD_HELP_VERSION을 true로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f123bfd592be78aee28a3c608d5e5a65fa7978a4" translate="yes" xml:space="preserve">
          <source>Note that due to how &lt;code&gt;%^H&lt;/code&gt; works, some of these utilities are only useful during the compilation phase of a perl module and relies on the internals of how perl handles references in &lt;code&gt;%^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">각 &lt;code&gt;pp_&lt;/code&gt; 함수는 다음 op에 대한 포인터를 반환해야합니다. perl 서브 (및 평가 블록)에 대한 호출은 동일한 runops 루프 내에서 처리되며 C 스택에서 추가 공간을 소비하지 않습니다. 예를 들어, &lt;code&gt;pp_entersub&lt;/code&gt; 및 &lt;code&gt;pp_entertry&lt;/code&gt; 는 &lt;code&gt;CxSUB&lt;/code&gt; 또는 &lt;code&gt;CxEVAL&lt;/code&gt; 블록 구조를 컨텍스트 호출로 푸시합니다. 여기에는 서브 호출 또는 평가 다음에 op의 주소가 포함됩니다. 그런 다음 해당 하위 또는 평가 블록의 첫 번째 op를 반환하므로 해당 하위 또는 블록의 실행이 계속됩니다. 나중에하는 &lt;code&gt;pp_leavesub&lt;/code&gt; 또는 &lt;code&gt;pp_leavetry&lt;/code&gt; 영업 이익은 팝업 &lt;code&gt;CxSUB&lt;/code&gt; 또는 &lt;code&gt;CxEVAL&lt;/code&gt; 를 , 그것에서 반환 연산을 검색하고 반환 그것.</target>
        </trans-unit>
        <trans-unit id="88c1f48b446d24b42913aa2c3b31a8759cf531cc" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt;, retrieves the return op from it, and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">&lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; &lt;i&gt;whatever (value)&lt;/i&gt; 로 호출하면 각각 &lt;code&gt;$self&lt;/code&gt; 반환 합니다 . 이렇게하면 집합 속성 호출을 다음과 같이 연결할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">SunOS 및 Solaris가 이진 호환 가능하더라도이 값은 다릅니다. 그림을 이동.</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">대소 문자를 구분하지 않는 &lt;code&gt;/i&lt;/code&gt; 정규 표현식 일치 의 결과로 실패한 대 / 소문자 변경 작업 은이 경고에서 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 작업 이있는 것으로 표시됩니다 (정규 표현식 엔진이 뒤에서 호출 함).</target>
        </trans-unit>
        <trans-unit id="50700c4c785fb49bbf6b2d46cdd32517f497bd69" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;fc&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">플러싱은 압축 비율을 심각하게 저하시킬 수 있으므로 압축 해제를 종료하는 경우 ( &lt;code&gt;Z_FINISH&lt;/code&gt; 사용 ) 또는</target>
        </trans-unit>
        <trans-unit id="4b30f403949fb025e96fa50a8f6344798f310af3" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt;) or when you want to create a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">제어 문자 ( &lt;code&gt;Gc=cc&lt;/code&gt; )의 경우 유니 코드 데이터 파일의 문자열은 &quot; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;이지만 이러한 각 문자의 실제 이름은 빈 문자열입니다. 이 함수는 실제 이름 인 빈 문자열을 반환합니다. 이러한 문자의 이름이 있지만 이름 특성 이름이 아닌 별명으로 간주되며 &lt;code&gt;Name_Alias&lt;/code&gt; 특성에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8932792e5f906f3f8b41da393da4b0b602a3cd6" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt;), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt;&quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc65a24a4a2d5395b160b7910a7ec94be07f4893" translate="yes" xml:space="preserve">
          <source>Note that for example the Series 60 2.0 VC SDK installation talks about ActivePerl build 518, which does no more (as of mid-2005) exist at the ActiveState website. The ActivePerl 5.8.4 build 810 was used successfully for compiling Perl on Symbian. The 5.6.x ActivePerls do not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed7cbcc3a273da5d5e361c4e690dfc2af7612b3" translate="yes" xml:space="preserve">
          <source>Note that for internal reasons, all precompiled regexps (&lt;code&gt;qr/.../&lt;/code&gt;) are blessed references; thus &lt;code&gt;ref()&lt;/code&gt; returns the package name string &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; on these but &lt;code&gt;reftype()&lt;/code&gt; will return the underlying C structure type of &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; in all capitals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">비트 열이 클수록 2 인수 버전을 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">간단한 테스트 요구 사항에 대해서는 종종 위의 코드를 단일 &lt;code&gt;runtests&lt;/code&gt; 호출로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d204c8dce6be8d36767ba5943e30dba9a432c61" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">참고를위한 것으로 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;NaN&lt;/code&gt; 이 (무한대 숫자가 아닌 값) &quot;숫자&quot;의 정의 다소 특이한 경우 : ( &quot;Inf를&quot;같은) 자체는 숫자로 간주되는 문자열, 그들은 숫자가 아닌 것으로 간주됩니다 다음 아무것도.</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">형식은 anon 서브로 취급되며 쓰기가 필요할 때마다 복제됩니다 (필요한 경우).</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">객체 구조를 고정하고 즉시 해동하면 실제로 해당 구조를 심도있게 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">에서 유의 &lt;a href=&quot;../bigint&quot;&gt;수학 ::에서 BigInt는&lt;/a&gt; 이후 v1.76 가능하면 FastCalc가 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="8d38bae54b038eb6f174267d0d214d08b91f6765" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over large DBM files. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cded70f7d04a11712cae33c05ba272338aaac47b" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over such. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 큰 DBM 파일에서 사용될 때 큰 목록을 반환 할 수 있습니다. 당신은 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 큰 DBM 파일을 반복하는 기능. 예:</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 반복 하는 것을 선호 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 큰 DBM 파일에서 사용될 때 큰 목록을 반환 할 수 있습니다. 당신은 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 큰 DBM 파일을 반복하는 기능. 예:</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 반복 하는 것을 선호 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">keys () 및 values ​​()와 같은 함수는 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. 이러한 반복을 위해 each () 함수를 사용하는 것이 좋습니다. 예:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 등은 glibc 버전 2.17 이전에는 버그가 있습니다. 프로그램의 현재 기본 로케일이 UTF-8 인 경우 UTF-8 형식이 아닌 문자열을 정확하게 작성할 수있는 &lt;code&gt;%.s&lt;/code&gt; 형식을 허용 하지 않습니다. 결과는 &lt;code&gt;%s&lt;/code&gt; 와 피연산자가 예고없이 간단히 건너 뜁니다. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b12e74f81fc8b09d013b39d154bb46d47ab07cc" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">globbing은 명시 적으로 요청 된 디렉토리 만 나열합니다. 예를 들어 FOO / *는 FOO / bar / Acme-Sthg-n.nn.tar.gz를 나열하지 않습니다. 이것은 향후 버전에서 변경 될 수있는 버그로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">경우주의 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 작업에 대한 외부 데이터를 필요로 어떤 서브 루틴 호출이 없이는 불가능합니다. 예를 들어, 표준 디버거의 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 는 &lt;code&gt;$DB::deep&lt;/code&gt; 변수 에 의존 합니다 (필수 중단 전에 갈 수있는 디버거 깊이의 재귀 수준을 정의합니다). 경우 &lt;code&gt;$DB::deep&lt;/code&gt; 정의되지 않은, 서브 루틴 호출에도 불구하고, 불가능 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 존재한다.</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">경우 참고 &lt;code&gt;CanonicalName&lt;/code&gt; 가 활성화되어, 정규화 된 파일 이름이 하위에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 내에서 컴파일 된 패턴을 다시 컴파일하면 ( &lt;code&gt;'strict'&lt;/code&gt; 외부의 다른 패턴으로 보간하여 엄격 성을 다시 확인하지 않습니다. 엄격하게 작동하는 경우 엄격하지 않은 상태에서 작동해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5ee9a3d19116b2071dbcf7039492ca7c1889754a" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt;, it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">문자열 인수가 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 시작하면 자체 옵션으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b48bf5ef9d46bdb5c44d53b224dcfec68d33eb04" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, it will be considered an option on itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">오염 된 문자열이 &lt;code&gt;@INC&lt;/code&gt; 에 추가 되면 다음과 같은 문제가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="a96ea078157000b1da678edf47d2488720c25a67" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt;, the following problem will be reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab97fe678be0eb16cdcbc59a7f09857930450fc" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. &lt;code&gt;chdir()&lt;/code&gt; out of the directory first before calling &lt;code&gt;cleanup()&lt;/code&gt;. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">임시 디렉토리가 현재 디렉토리 인 경우 제거 할 수 없습니다. 씨</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">초기화 된 스칼라 변수를 대신 사용하면 결과가 다릅니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하면&lt;/a&gt; 그러한 관행을 금합니다.</target>
        </trans-unit>
        <trans-unit id="fa54ff84091944bfa52d0352fb337bc37692f612" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt;. &lt;code&gt;use strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">단일 POD 문서 (아마도 미래 &lt;code&gt;=include&lt;/code&gt; 지시문 의 결과)에 대해 여러 파일이 구문 분석되는 경우 구문 분석 된 모든 파일에 대해이 메소드가 호출됩니다. 문서 당 한 번 특정 초기화를 수행하려면 &lt;b&gt;begin_pod ()&lt;/b&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;$err&lt;/code&gt; 는 빈 배열을 참조합니다. 이것은 &lt;code&gt;$err&lt;/code&gt; 가 항상 TRUE가 된다는 것을 의미 합니다. 따라서 &lt;code&gt;@$err&lt;/code&gt; 를 테스트 하여 오류가 발생했는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bfefb6d862aaaa4bec0b5f0b65d69bbc80cc525" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">테스트에 후행 계획이있는 경우 계획에 도달 할 때까지 계획되지 않은 것으로 알 수 없으므로 계획되지 않은 테스트에 대해이 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">캐시가 연결 해시 인 경우 &lt;code&gt;flush_cache&lt;/code&gt; 는 해시 에서 &lt;code&gt;CLEAR&lt;/code&gt; 메소드 를 호출하려고 시도합니다 . &lt;code&gt;CLEAR&lt;/code&gt; 방법 이 없으면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">파일 핸들이 &lt;code&gt;:utf8&lt;/code&gt; 로 표시되면 바이트 대신 유니 코드 문자를 읽습니다 (LENGTH, OFFSET 및 sysread ()의 반환 값은 유니 코드 문자 임). &lt;code&gt;:encoding(...)&lt;/code&gt; 층 내재적 도입 &lt;code&gt;:utf8&lt;/code&gt; 층. &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; , &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">파일 핸들이 &lt;code&gt;:utf8&lt;/code&gt; 로 표시되면 바이트 대신 유니 코드 문자를 읽습니다 (LENGTH, OFFSET 및 sysread ()의 반환 값은 유니 코드 문자 임). &lt;code&gt;:encoding(...)&lt;/code&gt; 층 내재적 도입 &lt;code&gt;:utf8&lt;/code&gt; 층. &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64c93021972ce0767115d7755bbd49afcf9ee53b" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;sysread&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b0f714c8a186567b6c90a5e0bc13fd3099264" translate="yes" xml:space="preserve">
          <source>Note that if the hostname resolves to multiple address candidates, the same timeout will apply to each connection attempt individually, rather than to the operation as a whole. Further note that the timeout does not apply to the initial hostname resolve operation, if connecting by hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">입력 텍스트가 읽기 전용 문자열 인 경우 (예 : 리터럴) 추출 된 텍스트를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">플랫폼에 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 및 / 또는 &lt;code&gt;LC_MONETARY&lt;/code&gt; 를 사용할 수 없거나 활성화 하지 않은 경우 해시의 해당 요소가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">정규식이 오염 된 경우 서브 루틴의 이름이 오염 된 데이터에 의해 결정될 때 서브 루틴을 호출하지 않고 Perl이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="fe055d833210baa880117658e3debc03ef9f92ae" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5d364aee605b39052a767be97bf595da7e180a" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">PM 모듈의 버전이 NV (부동 소수점 수) 인 경우 XS 모듈의 버전과 더 이상 일치하지 않도록 가능한 정밀도 손실 (현재 소수점 이하 9 자리까지 잘림)로 문자열 화됩니다. . 긴 버전 번호를 사용하는 경우 $ VERSION 선언을 인용하여 문자열로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">우리와 29 행 사이에 서브 루틴 호출이 있고, 이를 통해 &lt;b&gt;단일 단계&lt;/b&gt; 를 &lt;b&gt;수행&lt;/b&gt; 하고자 한다면 ' &lt;b&gt;s&lt;/b&gt; '명령을 사용할 수 있고, 그 단계를 넘어 서기 위해 서브를 실행하는 ' &lt;b&gt;n&lt;/b&gt; '을 사용할 것입니다. 검사를 위해 내려 가지 않습니다. 이 경우, 우리는 단순히 29 행까지 계속합니다 :</target>
        </trans-unit>
        <trans-unit id="59c2ff6ec5006b141610e96d370fba70e324be70" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;next EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;next LABEL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">위 의 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 버려진 행에서도 실행됩니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 펄 5.18.0의로 제공 형태는, 레이블 이름을 달리 동일한되고, 런타임에 계산 될 수 있도록 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">위의 코드에 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 , redex가 continue 블록을 건너 뛰기 때문에 정규식에 의해 삭제 된 행에서만 실행됩니다. 연속 블록은 종종 라인 카운터 또는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; 일회성 일치 :</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">위 의 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 버려진 행에서도 실행됩니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 펄 5.18.0의로 제공 형태는, 레이블 이름을 달리 동일한되고, 런타임에 계산 될 수 있도록 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89a8bc172fcf3b8db606f977ce516e0ca56f06e" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;continue&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;m?pat?&lt;/code&gt; one-time matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">&lt;a href=&quot;../threads&quot;&gt;스레드&lt;/a&gt; 가 아직로드되지 않은 상태 에서이 모듈을 가져 오면 이러한 기능이 모두 작동하지 않습니다. 이를 통해 스레드 환경과 스레드되지 않은 환경 모두에서 작동하는 모듈을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb1ed53a6e66a00d38de3c7beb368af62d0f805" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">이 연산자가 교대로 사용되지 않고 사용되는 경우 &lt;code&gt;(*PRUNE)&lt;/code&gt; 연산자 와 똑같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">gcc를 사용하는 경우 Perl 5.9.5부터 Perl 코어 소스 코드 파일 (소스 코드 배포의 최상위 레벨에 있지만 ext / 아래의 확장자는 아님)은 가능한 한 많은 파일로 자동 컴파일됩니다. &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 플래그 선택 (cflags.SH 참조)</target>
        </trans-unit>
        <trans-unit id="ae719f393d44a0bc8f5885617f97e53f1b2edd48" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt;, &lt;code&gt;-ansi&lt;/code&gt;, &lt;code&gt;-pedantic&lt;/code&gt;, and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">Module :: Signature가 설치되어 있지 않으면 서명 확인이 전혀 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">perl 자체를 빌드하지 않으려는 경우 EMX를 속여서 파일 이름을자를 수 있습니다. 지원되지 않습니다. EMX 문서를 읽고 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">가지고 있다면</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">주 당신이 당신의 스크립트에서 8 번째 비트와 바이트가있는 경우 (예를 들어 라틴 1 귀하의 문자열 리터럴에 포함 된) 것을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 바이트가 가장 아마 잘 형성되지 UTF-X 때문에 불행 할 것이다. 당신이 아래 같은 바이트 갖고 싶어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , 당신은 (또는 파일 최상위 레벨에있는 경우) 마지막 블록까지이 pragma를 사용하지 않도록 설정할 수 있습니다하여 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">임시 디렉토리에 chdir을 설정 한 후 END 블록에서 또는 오브젝트 제거의 일부로 정리 된 경우 File :: Path :: rmtree ()에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2acb4728d0e1f7a70ad075cf5c70995a564c7a8" translate="yes" xml:space="preserve">
          <source>Note that if you have non-ASCII, non-UTF-8 bytes in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;use utf8&lt;/code&gt; will be unhappy. If you want to have such bytes under &lt;code&gt;use utf8&lt;/code&gt;, you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;no utf8;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">런타임까지 모르는 문자열을 찾아야하는 경우 모든 패턴을 항상 다시 컴파일하지 않도록 전체 루프를 문자열과 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 빌드 할 수 있습니다 . &lt;code&gt;$/&lt;/code&gt; 를 정의하지 않고 전체 파일을 하나의 레코드로 입력하면 fgrep (1)과 같은 특수 프로그램보다 훨씬 빠릅니다. 다음은 파일 목록 ( &lt;code&gt;@files&lt;/code&gt; )에서 단어 목록 ( &lt;code&gt;@words&lt;/code&gt; )을 검색하고 일치하는 파일이있는 파일의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">런타임까지 모르는 문자열을 찾아야하는 경우 모든 패턴을 항상 다시 컴파일하지 않도록 전체 루프를 문자열과 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 빌드 할 수 있습니다 . &lt;code&gt;$/&lt;/code&gt; 를 정의하지 않고 전체 파일을 하나의 레코드로 입력하면 fgrep (1)과 같은 특수 프로그램보다 훨씬 빠릅니다. 다음은 파일 목록 ( &lt;code&gt;@files&lt;/code&gt; )에서 단어 목록 ( &lt;code&gt;@words&lt;/code&gt; )을 검색하고 일치하는 파일이있는 파일의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">참조가 약한 스칼라 사본을 가져 오면 사본이 강력하게 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="0e444f4b856d65b2f09fb19cd71f6f782807ee73" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">많은 포드 문서를 HTML로 일괄 변환하려면 &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt; 모듈이 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">모듈에 의해 등록 된 경고 범주를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; (예 : 경고 'File :: Find'사용 )이 모듈을 먼저로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e4f1270136e80fe4169f2c75c88690d42981098" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;use warnings 'File::Find'&lt;/code&gt;), you must have loaded this module first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">C-local environ 배열의 요소를 fork / exec로 시작하지 않거나 C 프로그램을 실행하지 않는 서브 프로세스로 전달하려는 경우, 이들을 논리 이름으로 &quot;승격&quot;할 수 있습니다. 현재 프로세스는 모든 하위 프로세스에 의해 다음과 같이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Windows를 사용하는 경우이 문제에 대한 해결책은 없습니다. Perl이 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 에뮬레이트하더라도 Windows에는 argc / argv 스타일 API가 없기 때문에 여전히 멈출 것입니다.</target>
        </trans-unit>
        <trans-unit id="1aa1a6be319ce084016212a914b567d8abc1a457" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;fork()&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">분기 된 자식이 파이프 나 소켓으로 실제로 연결된 STDIN 및 STDOUT과 같은 시스템 파일 디스크립터를 상속하는 경우 종료하더라도 원격 서버 (예 : CGI 스크립트 또는 원격에서 실행 된 백그라운드 작업) 쉘) 당신이 끝났다고 생각하지 않습니다. 당신은 그들을 다시 열어야합니다</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">Perl 5.17.3 및 이전 버전에서는 마지막 세 상수가 변수의 캐럿 변형에도 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">5.18 이전의 Perl 버전에서 &lt;code&gt;fallback&lt;/code&gt; 키의 상속은 위의 규칙에 의해 통제되지 않았습니다. 오버로드 된 첫 번째 조상 의 &lt;code&gt;fallback&lt;/code&gt; 값 이 사용되었습니다. 이것은 일반적인 상속 규칙을 따르기 위해 5.18에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">경우에 따라이 변환을 소스 코드로 완벽하게 다시 전달할 수는 없습니다. 예를 들어 루프의 이니셜 라이저가 내 변수를 선언하면 루프 외부에 올바른 범위가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">목록 컨텍스트에서 원래 입력 텍스트 (첫 번째 인수)의 내용은 어떤 식 으로든 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">&quot;E &amp;lt;whatever&amp;gt;&quot;의 모든 경우에</target>
        </trans-unit>
        <trans-unit id="6ce30555742bc236d7228f5681b0d8b9d5625260" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, this description does not contain the actual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">대조적으로 참고 &lt;a href=&quot;#EXAMPLE-1&quot;&gt;예 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;실시 예 2&lt;/a&gt; 및 &lt;a href=&quot;#EXAMPLE-3&quot;&gt;실시 예 3은&lt;/a&gt; , 이러한 설명은 실제가 포함되지 않은</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">이 모듈의 이전 버전에서 &lt;code&gt;error()&lt;/code&gt; 메소드는 위와 같이 인스턴스 메소드를 호출하더라도 효과적으로 글로벌 값을 리턴합니다. 그 이후 &lt;code&gt;Archive::Tar&lt;/code&gt; 되었으며 이제 여러 Archive :: Tar 인스턴스에 별도의 오류 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">스칼라 및 void 컨텍스트에서이 인수의 값은 자동으로 1로 재설정됩니다 ( &lt;code&gt;-w&lt;/code&gt; 에서 인수를 재설정해야하는 경우 경고가 발행 됨).</target>
        </trans-unit>
        <trans-unit id="b672aba9889e3334f6f71797b988ee0e00c12f3a" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt;, a warning is issued if the argument has to be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">위의 경우, &lt;code&gt;thing($foo)&lt;/code&gt; 및 &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="312240e44caf4f031c0d90c515deeb5d10139037" translate="yes" xml:space="preserve">
          <source>Note that in the above example, tests in the first subdirectory will not be run. To run all tests in the intermediary subdirectory preceding the one the test files are in, you need to explicitly note it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">install ()은 의미있는 반환 값을 제공하지 않습니다. uptodate ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="275e7ac15e1f8f9535995287531c3b4b0bc12858" translate="yes" xml:space="preserve">
          <source>Note that it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">모든 메소드 ( &lt;code&gt;AUTOLOAD&lt;/code&gt; 포함 )가 동일한 이름을 갖지 않는 메소드를 재발송하려고 하면 치명적인 오류입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c47d269e31ad3d486ed4d3aa4e0693a8502eee1" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt;) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">INST_DRV 및 INST_TOP을 이전 빌드에서 이미 존재하는 경로로 설정하여 perl을 빌드하는 것은 일반적으로 좋지 않습니다. 특히, 이로 인해 lib / ExtUtils / t / Embed.t 테스트에 문제가 발생하여 테스트 프로그램을 빌드하려고 시도하고 테스트중인 디렉토리가 아닌 설치된 perl의 lib / CORE 디렉토리에 대해 빌드를 끝낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d81b2599960bdecb9620115e70e867f7359ae0c4" translate="yes" xml:space="preserve">
          <source>Note that it is illegal to have code points that are larger than what can fit in an IV on the current machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">perl 5.8의 버그는 구문 분석을 거부하고 알 수없는 오류가 발생하므로 __CALLER __ :: Roo 식별자를 인용하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">신호가 동일한 핸들에서 I / O 조작을 인터럽트 한 신호 핸들러 내에서 파일 핸들에 액세스하는 것은 바람직하지 않습니다. perl은 최소한 충돌하지 않도록 노력하지만 데이터 무결성을 보장하지는 않습니다. 예를 들어 일부 데이터는 삭제되거나 두 번 쓰여질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">이 경우 &lt;code&gt;PUSHMARK&lt;/code&gt; 를 호출 할 필요는 없습니다 . 이 때문입니다</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">이미 perl에 링크 된 종속 라이브러리를 포함하는 라이브러리를 작성해도됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ad638116e9353f8a4dbaec6ebfef4f8d3c123f" translate="yes" xml:space="preserve">
          <source>Note that it is possible that the actions of a destructor called directly or indirectly by freeing an element of the array could cause the reference count of the array itself to be reduced (e.g. by deleting an entry in the symbol table). So it is a possibility that the AV could have been freed (or even reallocated) on return from the call unless you hold a reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">여러 파일의 동일한 패키지에 &lt;code&gt;__DATA__&lt;/code&gt; 토큰 을 보유 할 수 있으며 컴파일러에서 발생하는 지정된 패키지 의 마지막 &lt;code&gt;__DATA__&lt;/code&gt; 토큰은 파일 핸들로 액세스 할 수있는 토큰입니다. 이는 &lt;code&gt;__END__&lt;/code&gt; 및 main 에도 적용됩니다 . 즉, 'main'프로그램에 &lt;code&gt;__END__&lt;/code&gt; 가 있지만 해당 프로그램에서 '필수'(_not_ 'use'd) 한 모듈에'package main; '이있는 경우 선언은 &quot;다음 &lt;code&gt;__DATA__&lt;/code&gt; '이면, &lt;code&gt;DATA&lt;/code&gt; 의 핸들이 데이터 후의 액세스로 설정 &lt;code&gt;__DATA__&lt;/code&gt; 애프터 데이터 들여지지 모듈에 &lt;code&gt;__END__&lt;/code&gt; 컴파일러가&quot;필요 &quot;가 발생하기 때문에,&quot;메인 &quot;프로그램 토큰d 나중에 파일.</target>
        </trans-unit>
        <trans-unit id="7c22ec5e674939ca7dd16521f1a2590b4ddee243" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt;, but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt;', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">유니 코드 숫자로 항목을 지정하고 변환 함수를 사용하여 이식 가능한 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">import () 및 unimport () 메소드가 아닌 어디에서나 함수 overload :: constant () 및 overload :: remove_constant ()를 호출하는 것은 의미가 없습니다. 이 방법들로부터 그것들은</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">어쨌든 이러한 유형의 범위를 지정하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">추가 해시 항목이 포함될 수있는 파생 클래스에 의해 혼동되지 않도록 최소한의 구조 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">일부 라인에는 테스트 번호가 있고 다른 라인에는 테스트 번호가 없어도됩니다. 그러나 테스트 번호가 발견되면 순서대로 표시되어야합니다. 다음도 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; (빈 정규식)은 실제로 &lt;code&gt;//&lt;/code&gt; (정의 된 또는 연산자) 라는 생각으로 Perl을 혼동 할 수 있습니다 . 펄은 일반적으로 이것에 대해 꽤 좋은,하지만 몇 가지 병적 인 경우는 같은이를 트리거 할 수 &lt;code&gt;$x///&lt;/code&gt; (입니다 &lt;code&gt;($x) / (//)&lt;/code&gt; 또는 &lt;code&gt;$x // /&lt;/code&gt; ?) 및 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; ( &lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt; ?).이 모든 예에서 Perl은 정의 된 것으로 가정하거나 빈 정규식을 의미하는 경우 괄호 나 공백을 사용하여 명확하게하거나 접두사를 붙입니다. 빈 정규 표현식은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 으로 (따라서 &lt;code&gt;//&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a12f25b19f578d4ada5cb29c677b041e1603c474" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt;?) and &lt;code&gt;print $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;m&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;m//&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">C에서와 마찬가지로 Perl은 변수가 증가 또는 감소되는 &lt;b&gt;시기를&lt;/b&gt; 정의하지 않습니다 . 값이 반환되기 전이나 후에 언젠가 수행 될 것입니다. 이는 또한 동일한 명령문에서 변수를 두 번 수정하면 정의되지 않은 동작이 발생 함을 의미합니다. 다음과 같은 진술을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">해시가 그 순서대로 초기화되었다고해서 그 순서대로 나오는 것은 아닙니다. 출력 순서를 정렬하는 방법에 대한 예는 &lt;a href=&quot;functions/sort&quot;&gt;정렬&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f5a81a69fc5b10cd51900312887345ba64586f5" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">모든 문장 부호 변수와 마찬가지로 현재 &lt;code&gt;$^W&lt;/code&gt; 에서 my ()를 사용할 수 없으며 local () 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fe7b7d8a3cbe9873ed0d90c76831403a33df538" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt;, only local().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">매크로 &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; 및 &lt;code&gt;XSRETURN*()&lt;/code&gt; 은 CODE : 섹션 및 PPCODE : 섹션에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="590d78c14b1f30644ceca6febcb1f178361e32a4" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt;, &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">대부분의 유니 코드 문자에는 분해가 없으므로 분해 유형은 &lt;code&gt;&quot;None&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5c45d58bad9499717ca648bdb916a02ec0cb0a26" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">여러 &quot;프론트 엔드&quot;가이 디버깅 API에 동시에 래치 될 수 있습니다. 이것은 명령 줄과 GUI를 이용한 디버깅, 디버거 디버깅 등을 용이하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">참고도 있음을 &lt;b&gt;-w&lt;/b&gt; 플래그 또는 &lt;code&gt;$^W&lt;/code&gt; 비활성화하는 데 사용 될 수 / 기본 경고를 할 수 있습니다. 이 경우에는 여전히 필수입니다.</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">모든 &lt;code&gt;siginfo&lt;/code&gt; 값이 동시에 의미가있는 것은 아니며 (일부 신호는 특정 신호에만 유효 함) Perl 관점에서 모든 값이 의미가있는 것은 아닙니다. 시스템의 &lt;code&gt;sigaction&lt;/code&gt; 및 &lt;code&gt;siginfo&lt;/code&gt; 문서 를 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">모든 속성이 모든 터미널 유형에서 지원되는 것은 아니며 일부 터미널은 이러한 시퀀스를 지원하지 않을 수도 있습니다. 어둡고 희미한, 기울임 꼴, 깜박임 및 은폐는 종종 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">모든 디스플레이가 ISO 6429와 호환되거나 X3.64와 호환되는 것은 아닙니다 (또는 그렇게 시도하고 있음). 이 모듈은 Windows NT 또는 Windows 2000의 cmd.exe, 4nt.exe 및 command.com과 같은 이스케이프 시퀀스를 따르지 않는 디스플레이에서 예상대로 작동하지 않습니다. 무시되거나 또는 다음과 같이 표시 될 수 있습니다. 명백한 쓰레기가 뒤 따르는 ESC 문자.</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">이러한 환경에서 Perl의 모든 기능을 사용할 수있는 것은 아닙니다. 이것은 기능에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="b41fed2960927bbd3a7a4879e6c7ebbfd5148f75" translate="yes" xml:space="preserve">
          <source>Note that not all folders are defined on all versions of Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">모든 비 호환성이 발견되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">모든 모듈이 모든 플랫폼에서 작동하는 것은 아닙니다. 이식성 문제에 대한 자세한 내용 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 . 설명서를 읽고 시스템에서 모듈이 작동하는지 확인하십시오. 기본적으로 모든 플랫폼에서 &quot;바로&quot;작동하지 않는 세 가지 범주의 모듈이 있습니다 (일부 중복 가능성).</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">CPAN에서 사용 가능한 모든 확장이 Windows 환경에서 작동하지는 않습니다. 쉽게 구축 할 수없는 포팅 모듈에 너무 많은 노력을 기울이기 전에 &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; 에서 정보를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b09aa2530ba4d13d5bf9a219720506b2be0033b4" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4084be0514f39566a9c52b9eaf1e3d0173ba9e" translate="yes" xml:space="preserve">
          <source>Note that not all platforms support disabling this option. Some, at least OpenBSD and MirBSD, will fail with &lt;code&gt;EINVAL&lt;/code&gt; if you attempt to disable it. To determine whether it is possible to disable, you may use the class method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6848dffa9b06cabb4c87ddb649c3cc22a5f54c" translate="yes" xml:space="preserve">
          <source>Note that numerical precision has the same meaning as under Perl (so binary to decimal conversion follows the same rules as in Perl, which can differ to other languages). Also, your perl interpreter might expose extensions to the floating point numbers of your platform, such as infinities or NaN's - these cannot be represented in JSON, and it is an error to pass those in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">numf는 모든 정량화 숫자를 문자열 화하기 위해 quant에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">참고 이전의 포드 포매터 8 진수인지 또는 16 진수 숫자 탈출을하고, 많은 포매터 안정적 포매터도 렌더링처럼, 라틴-1 / CP-1252 문자의 손상 렌더링을 사용 할 수 있습니다 (255 위의 문자를 렌더링 할 수 없습니다하지 않을 수도 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; 그냥 평범한 &quot;e&quot;</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">Windows에서 주소 공간 할당 단위는 64KB이므로 스택을 Win32 Perl보다 작게 설정하면 더 이상 메모리가 절약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">입력시 (문자열에서 숫자로) Perl은 여러 형식으로 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 을 허용 합니다. 대소 문자는 무시되고 &lt;code&gt;1.#INF&lt;/code&gt; 와 같은 Win32 관련 형식 은 이해되지만 출력시 값은 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 으로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6ea49ea44abd8799ce4dfc75293c4bfcb155f89" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">일부 시스템에서 리턴 값 &lt;code&gt;-1&lt;/code&gt; 은 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다. 자세한 내용 및 기타 예는 &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">일부 시스템에서 리턴 값 &lt;code&gt;-1&lt;/code&gt; 은 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다. 자세한 내용 및 기타 예는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">현지화 된 변수 변경 만 취소됩니다. 코드 표현식 실행의 다른 부작용은 영구적입니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">Perl만이 진정으로 Perl을 구문 분석 할 수 있으므로 모든 CASE 도구는 특히 Perl을 C 프로그래머로 프로그래밍하지 않는 경우에는 다소 부족합니다.</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">op_next는 조작되지 않으며 노드는 해제되지 않습니다. 그것은 발신자의 책임입니다. 또한 빈 목록 등에 대한 새 목록 op를 만들지 않습니다. 이를 위해 op_append_elem ()과 같은 고급 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">pad_findlex ()는 재귀 적입니다. CV 체인을 되풀이 한 다음 다시 내려 가면서 가짜 항목을 추가합니다. anon protoypes의 가짜 이름은 xlow에 색인을 부모 패드에 저장해야하기 때문에 이런 식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">간단한 변수가 아닌 것을 숨길 때는 괄호가 필요합니다. &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 때문입니다 . &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; 로 해석됩니다 ; 예상 보다 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 보다는 . 마찬가지로, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 로 해석 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 대신 것과는 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">간단한 변수가 아닌 것을 숨길 때는 괄호가 필요합니다. &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 때문입니다 . &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; 로 해석됩니다 ; 예상 보다 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 보다는 . 마찬가지로, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 로 해석 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 대신 것과는 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="018c1697a99aff61964cd62c6350adc2116be64d" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt;, rather than as &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;chomp $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;chomp($a), $b&lt;/code&gt; rather than as &lt;code&gt;chomp($a, $b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b290990bc28b21efbb6fc62a4d6a7e3869dd2f55" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">이 코드의 일부 는 Adam Kennedy의 허락하에 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 에서 파생되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">포드 번역기는 포드 지시어로 시작하는 단락 만 분석해야합니다 (파싱이 더 쉬워집니다). 반면 컴파일러는 실제로 단락 중간에서도 포드 이스케이프를 찾는 것을 알고 있습니다. 이것은 컴파일러와 번역가 모두 다음과 같은 비밀을 무시한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97f97f44b8a98fafc1d8a756bd8a55c77c58d9e9" translate="yes" xml:space="preserve">
          <source>Note that precision is not accuracy - binary floating point values cannot represent most decimal fractions exactly, and when converting from and to floating point, JSON::PP only guarantees precision up to but not including the least significant bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">이전 버전의 Perl, 특히 현재 안정 버전의 Perl을 테스트하지 않았 음을 나타내는 버그에 대한 보고서는 현재 릴리스의 버그에 대한 보고서보다 Perl을 빌드하고 유지 관리하는 자원 봉사자의 관심이 적습니다. .</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">다음과 같이 배열을 자체로 되돌립니다. &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; 가능할 때마다 존재하지 않는 요소를 보존합니다. 즉, 마술이 아닌 배열 또는 &lt;code&gt;EXISTS&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 방법 을 사용하는 연결 배열의 경우 .</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">다음과 같이 배열을 자체로 되돌립니다. &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; 가능할 때마다 존재하지 않는 요소를 보존합니다. 즉, 마술이 아닌 배열 또는 &lt;code&gt;EXISTS&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 방법 을 사용하는 연결 배열의 경우 .</target>
        </trans-unit>
        <trans-unit id="cefecfaf8ad606f51bb60e49b8b1e7ead07fd207" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = reverse @a&lt;/code&gt;) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">rewinddir ()은 Windows에서 비슷한 제한 사항이 있으므로 readdir ()이 디렉토리를 다시 읽도록 강요하지 않습니다. 새로 열린 디렉토리 핸들 만 디렉토리의 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">섹션 이름에 마크 업이 포함될 수 있습니다. 즉, 섹션이 다음으로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">정밀도와 정확도를 동시에 설정하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="2dfa6206994e5b2e572924979f052b36e73802cd" translate="yes" xml:space="preserve">
          <source>Note that several apps spew crap to stderr every time you connect, which can throw off Configure. You may need to monkeypatch the part of Configure that creates &lt;code&gt;run-ssh&lt;/code&gt; to have it discard stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">Perl 5.10.0 이후로 //</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Perl 5.8.1부터 &lt;code&gt;v65&lt;/code&gt; 와 같은 단일 숫자 v- 문자열 은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 이전에 v- 문자열이 아닙니다 (일반적으로 해시 키와 해시 값을 분리하는 데 사용됨). 대신 리터럴 문자열 ( 'v65')로 해석됩니다. 그것들은 Perl 5.6.0에서 Perl 5.8.0까지의 v- 문자열 이었지만, 그것은 좋은 것보다 더 많은 혼란과 파손을 야기했습니다. 여러 숫자의 v- 문자열 &lt;code&gt;v65.66&lt;/code&gt; 및 &lt;code&gt;65.66.67&lt;/code&gt; 문자열은 항상 v- 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="008b6ecd9594a1f31168dc7af3eef7ef69846a54" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt;) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">Perl 버전 5.16부터이 기능은 작동하지 않았지만 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">공백을 건너 뛰면이 구문의 내부에만 적용됩니다. 초기 문자 &lt;code&gt;(?[&lt;/code&gt; . 닫는 &lt;code&gt;])&lt;/code&gt; 사이에는 공백 이 없어야 함) 사이에 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="545af0b2b09ce2f37c97dabd56794edec8a64fad" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt;. Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7426c9a1b07347627eeb1ac1cf62af6a1907ba1a" translate="yes" xml:space="preserve">
          <source>Note that some UNIX mail systems can mess with text attachments containing 'From '. This will fix them up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">문자 또는 프로토콜 제한 문제를 극복하기 위해 일부 URL에는 16 진 ASCII 코드 포인트가 있습니다. 예를 들어 물결표 문자가 모든 키보드에있는 것은 아니므로 다음 형식의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="b0ec6733c239960d7ab748fd5e743c87866db919" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;b&gt;--release&lt;/b&gt; to the last modified date and &lt;b&gt;--date&lt;/b&gt; to the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5782148c53cb53f800e7cc24f499baa2f09d812f" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;code&gt;release&lt;/code&gt; to the last modified date and &lt;code&gt;date&lt;/code&gt; to the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">함수에 대한 일부 유형의 인수 / 반환 값은 XSUB 선언 / 유형 맵 항목으로 인해 수동 편집이 필요할 수 있습니다. &lt;code&gt;long long&lt;/code&gt; 과 같은 포인터, 함수에 대한 포인터 또는 배열로 /에서 변환 할 수없는 객체 일 수 있습니다 . &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;-x 제한에&lt;/a&gt; 대한 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6ea1587e3db14d628357c10f80019ced4d3486b" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt;), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;&quot;LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 위한 format 인수의 공백은 리터럴 공백을 나타내지 않습니다. 공백으로 구분 된 데이터가있는 경우 원할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 대신 분할 을.</target>
        </trans-unit>
        <trans-unit id="662d6982ca6578815a4a0f18cc0ec8305ec26773" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;unpack&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;split&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">빈 문자열로 평가되는 EXPR을 분할하면 지정된 LIMIT에 관계없이 항상 0 개의 필드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Perl 5.7.2 (및 결과적으로 5.8.0)부터 AIX 4.3 이상에서 Perl 릴리스 5.6.1 및 5.3에서 사용 된 에뮬레이트 된 인터페이스 대신 이른바 런타임 링크 모드에서 AIX 기본 동적로드 인터페이스를 사용합니다. 이전 또는 AIX 릴리스 4.2 이전. 이 변경은 이전 Perl 릴리스에서 컴파일 된 모듈과의 호환성을 손상시킵니다. Perl이 AIX 기본 인터페이스를 사용하는 Apache / mod_perl과 같은 다른 응용 프로그램과 호환되도록 변경되었습니다. 이 변경으로 인해 Perl 확장에서 정적 생성자 및 소멸자와 함께 C ++ 코드를 사용할 수 있었지만 에뮬레이트 된 인터페이스로는 불가능했습니다.</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">유니 코드 6.1부터 많은 블록 이름의 동의어가 더 짧습니다. 이들은 항상 새로운 스타일로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">strtol () 및 strtoul ()은 Strtol (), Strtoul (), Atol (), Atoul ()로 위장 될 수 있습니다. 그것들도 피하십시오.</target>
        </trans-unit>
        <trans-unit id="1f8d123671f8fe6351f73c10ea6c3fa3f4b1a51f" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are compared strictly, meaning 1 tab will not match 8 spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da058756ddccf3047bc3134e13ea20e3af855473" translate="yes" xml:space="preserve">
          <source>Note that testing is finished. If no plan has been set this will generate a Plan event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="6672243740cead8683b9d1445f8ead3531c13383" translate="yes" xml:space="preserve">
          <source>Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl. The default can be overridden by setting the environment variable PERLIO to a space or colon separated list of layers, however this cannot be used to set layers that require loading modules like &lt;code&gt;:encoding&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94925dc9df0f22c049d74f88d76450a9a690c2cd" translate="yes" xml:space="preserve">
          <source>Note that the 0 index of @{^CAPTURE} is equivalent to $1, the 1 index is equivalent to $2, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f90013b3209e32ef045a540920a533398fa647" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; emulation of &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fcc2fd58a5941d9e57fbe4a6f4e6ca8d35d36f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt;&lt;code&gt;select FILEHANDLE&lt;/code&gt;&lt;/a&gt; form is generally portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5879e45ce93c6c3511286267d5813593e72f0a4e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;p&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;&quot;a&quot;&lt;/code&gt;'s) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;use warnings&lt;/code&gt;; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">있습니다 &lt;code&gt;%a&lt;/code&gt; 및 &lt;code&gt;%b&lt;/code&gt; , 요일과 올해의 달의 짧은 형태, 반드시 넓은 세 문자하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">참고 것을 &lt;code&gt;-L&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 접두사가되어 &lt;b&gt;필요하지&lt;/b&gt; 만, 내선의 유닉스 OS / 2 버전은 ()을 필요로하기 때문에 자신의 확장을하고자하는 저자는, 접두사를 사용해야 유닉스 또는 OS / 2에 이식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">합니다 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; 형태는 일반적으로 휴대용이다.</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">있습니다 &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker 옵션 MakeMaker에 의해 생성 된 메이크 파일에 이러한 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">참고 그 , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , 및 &lt;code&gt;u&lt;/code&gt; 수정은 그들이 단지 활성화 될 수 있다는 사용할 수없는 특수, 그리고 , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , 및 &lt;code&gt;u&lt;/code&gt; 수정이 상호 배타적 인 하나 드 지정 다른 사람을 지정, 그리고 구조물 에는 최대 1 개 (또는 2 개의 &lt;code&gt;a&lt;/code&gt; )가 나타날 수 있습니다. 따라서 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 경고에서 컴파일 될 때 &lt;code&gt;(?-p)&lt;/code&gt; 는 경고합니다 . &lt;code&gt;(?-d:...)&lt;/code&gt; 및 &lt;code&gt;(?dl:...)&lt;/code&gt; 은 치명적인 오류입니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">점을 유의 &lt;code&gt;digest&lt;/code&gt; 작업이 효과적으로 파괴 판독 회 동작이다. 일단 수행되면 $ ctx 객체가 자동으로 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 되고 다른 다이제스트 값을 계산하는 데 사용할 수 있습니다. 다이제스트 상태를 재설정하지 않고 다이제스트를 계산하려면 $ ctx-&amp;gt; clone-&amp;gt; 다이제스트를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ce0a012ac00944b517f4c494f69adcd759afd120" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">점을 유의 &lt;code&gt;digest&lt;/code&gt; 작업이 효과적으로 파괴 판독 회 동작이다. 일단 수행되면 &lt;code&gt;Digest::MD5&lt;/code&gt; 개체가 자동으로 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 되고 다른 다이제스트 값을 계산하는 데 사용할 수 있습니다. 요약 상태를 재설정하지 않고 요약을 계산하려면 $ md5-&amp;gt; clone-&amp;gt; digest를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="30d1356fb08343a518e41acb4dd7ec7580812f65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">(가) 있습니다 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 와 &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 매크로에</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">있습니다 &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; 모드는 포드 :: 간단한 만들 것 (등)은, 이후 및 포드는 :: 간단한 :: DEBUG가 일정한 하위되지 않습니다 더 이상, 오히려 느리게 실행 Pod :: Simple (et al)은 상수 폴딩으로 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20cd55dfd99c6b7ca8f8c3e96afe94485ab2aeca" translate="yes" xml:space="preserve">
          <source>Note that the API described here changed considerably in perl 5.24; prior to that, big macros like &lt;code&gt;PUSHBLOCK&lt;/code&gt; and &lt;code&gt;POPSUB&lt;/code&gt; were used; in 5.24 they were replaced by the inline static functions described below. In addition, the ordering and detail of how these macros/function work changed in many ways, often subtly. In particular they didn't handle saving the savestack and temps stack positions, and required additional &lt;code&gt;ENTER&lt;/code&gt;, &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; compared to the new functions. The old-style macros will not be described further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">CPU 초는 &lt;b&gt;최소&lt;/b&gt; 시간입니다. CPU 스케줄링 및 기타 운영 체제 요인으로 인해 시간이 조금 더 소요될 수 있습니다. 그러나 벤치 마크 결과는 초당 &lt;code&gt;$code&lt;/code&gt; run 의 수를 나타내며 이는 실제로 소요 된 시간보다 더 흥미로운 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">최종 작업이 해시 또는 배열 키 조회 또는 서브 루틴 이름 인 경우 EXPR은 임의로 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0084fb8a7b9ce4d56aecba3fadc51d825f62ba8" translate="yes" xml:space="preserve">
          <source>Note that the Encode implementation of GSM0338 does not implement the reuse of Latin capital letters as Greek capital letters (for example, the 0x5A is U+005A (LATIN CAPITAL LETTER Z), not U+0396 (GREEK CAPITAL LETTER ZETA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">G_KEEPERR 플래그는 내부 에바로 전파되지 않습니다. 이것들은 여전히 &lt;code&gt;$@&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="997492b2704e0f5c940f0988ed8b0f1470e9f2f1" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">MAP_TARGET 값 * must *의 확장자는 &quot;.exe&quot;이거나 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 을 대체하기 위해 &quot;perl.exe&quot;를 작성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8caaca0bc214aa98766a1940f6cdf2d7b3d021af" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">MD5 알고리즘은 예전보다 강력하지 않습니다. 2005 년 이후 동일한 MD5 다이제스트를 생성하는 다른 메시지를 쉽게 생성 할 수있었습니다. 주어진 다이제스트를 생성하는 메시지를 생성하는 것은 여전히 ​​어려운 것처럼 보이지만 다이제스트에 의존하여 메시지를 고유하게 식별하는 응용 프로그램에 대해 더 강력한 알고리즘으로 이동하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="247c1a806843ed2e2d60424a5f01f9ce095fc287" translate="yes" xml:space="preserve">
          <source>Note that the MinGW build currently requires a MinGW runtime version earlier than 3.21 (check __MINGW32_MAJOR_VERSION and __MINGW32_MINOR_VERSION).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">PerlIO와 &lt;code&gt;fread&lt;/code&gt; 및 &lt;code&gt;fwrite&lt;/code&gt; 는 C 라이브러리 와 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b520e7f3d86206ae6fb132d75305e69c64963146" translate="yes" xml:space="preserve">
          <source>Note that the Script_Extensions property is an improved version of the Script property, and you should probably be using that instead, with the &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">Symbian 파일 시스템은 매우 까다 롭습니다. / 대신 \를 강력하게 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">위의 구현은 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 과 달리 배열을 순서대로 섞은 다음 목록을 가져 와서 새로운 순서 섞은 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">위의 두 호출은 도달 가능한 메모리 및 누출 검사가 기본적으로 활성화되어 있기 때문에 매우 장황합니다. 순수한 오류를 보려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">다양한 필드의 실제 의미가 제대로 표준화되지 않았으므로 이식성이 뛰어나지 않습니다. 그만큼 &lt;code&gt;$sysname&lt;/code&gt; 운영 체제의 이름의 수 있습니다 &lt;code&gt;$nodename&lt;/code&gt; 의 호스트의 이름을들 수 있습니다 &lt;code&gt;$release&lt;/code&gt; 의 운영 체제의 (주) 릴리스 번호 수 있습니다 &lt;code&gt;$version&lt;/code&gt; (작은) 릴리스 번호 수 있습니다 운영 체제의, 그리고 &lt;code&gt;$machine&lt;/code&gt; 하드웨어 식별자 수 있습니다. 아마도.</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">EU_INSTALL_ALWAYS_COPY가 최소 1.50 릴리스까지 정의되지 않으면 EU_ALWAYS_COPY 별칭이 지원됩니다. 올바른 EU_INSTALL_ALWAYS_COPY를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b57c85ca6eca16bd7229db94019acde3ad48fd66" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">할당이 &lt;code&gt;$\ = $/&lt;/code&gt; 이면 스위치가 처리 될 때 수행되므로 &lt;b&gt;-l&lt;/b&gt; 스위치 뒤에 &lt;b&gt;-0&lt;/b&gt; 스위치 가 있으면 입력 레코드 구분 기호가 출력 레코드 구분 기호와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">백 슬래시 자체는 특별합니다. 백 슬래시를 일치 시키려면 백 슬래시로 백 슬래시를 이스케이프해야합니다. &lt;code&gt;/\\/&lt;/code&gt; 는 단일 백 슬래시와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">반환 된 base64 인코딩 문자열은 4 바이트의 배수로 채워지지 않습니다. 다른 base64로 인코딩 된 md5 다이제스트와 상호 운용성을 원할 경우 중복 문자열 &quot;==&quot;을 결과에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">블록에 한 줄만 있어도 Perl에는 중괄호가 필요합니다. 그러나 한 줄 조건부 블록을 영어와 같이 영어로 만드는 영리한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece9838263d6bf6e2a7db9094c48c8c8ea6e66ec" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">호출자는 참조 카운트를 적절하게 증가시킬 책임이 있습니다. &lt;code&gt;val&lt;/code&gt; 호출 전에 val 시키고 함수가 NULL을 리턴하면 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">&lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; 시퀀스 내에 중첩 된 형식화 코드가있는 경우 코드가 여러 세그먼트로 나 might 수 있습니다 . &lt;code&gt;handle_code&lt;/code&gt; 호출 사이 다른 마크 업 태그가 생성되었을 수 있습니다. &lt;code&gt;codes_in_verbatim&lt;/code&gt; 옵션이 설정 되어 있으면 그대로 사용하는 섹션에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">효과는 컴파일 타임이며 일단 정의되면 변경할 수 없습니다. 그러나 서브 루틴에는 단일 매개 변수가 전달되는데, 이는 대소 문자 구분 일치가 적용되면 0이고 대소 문자 구분 일치가 적용되면 0이 아닙니다. 서브 루틴은 플래그 값에 따라 다른 값을 리턴 할 수 있으며 한 세트의 값은 대소 문자를 구분하는 모든 일치에 대해 유효하며 다른 세트는 대소 문자를 구분하지 않는 모든 일치에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="82a2a038be5dc98f1cb9f3946ca4a644efda3ae0" translate="yes" xml:space="preserve">
          <source>Note that the effect of &lt;code&gt;binmode&lt;/code&gt; differs from that of the binmode() function on operating systems such as Windows and MSDOS, and is not needed to process most types of file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">문자열에 포함 된 작은 따옴표는 허용되는 분리 문자로 지정되지 않았으므로 분리 문자가 아닌 문자로 취급되므로 무시되므로이 경우 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a60f273853beeeddbd8dccab4c57df4281d7707" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; implements. Most if not all systems implement &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; in terms of &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">lockf (3)으로 빌드 된 에뮬레이션은 공유 잠금을 제공하지 않으며 쓰기 의도로 FILEHANDLE을 열어야합니다. 이들은 lockf (3)가 구현하는 의미론입니다. 그러나 대부분의 시스템이 fcntl (2) 잠금의 관점에서 lockf (3)을 구현하는 것은 아니지만, 다른 의미론이 너무 많은 사람들을 물지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">인코딩 자체는 공식적으로 유효한 언어 태그 가 &lt;b&gt;아닙니다&lt;/b&gt; . 또한 현재 인코딩에서 인코딩 된 언어 태그로 다시 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">확장 된 형태는 펄이 그러한 구조를 내부적으로 처리하는 방식을 나타냅니다.이 옵션은 실제로 B :: Deparse가 일반적으로하는 역변환을 끕니다. 반면에 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; 는 &lt;code&gt;$x = $y&lt;/code&gt; 와 같지 않습니다. . 전자는 할당을 수행하기 전에 $ y의 값을 문자열로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7363f38426987fddbd769148d6ed0f8d3381792d" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt;: the former makes the value of $y into a string before doing the assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">저장된 경로를 사용한 추출이 여전히 필요하다는 점에 유의하십시오 (기본값은 unzip, &lt;code&gt;-d&lt;/code&gt; 를 pkunzip으로 지정 ). 그러나 파일을 추출 할 위치를 알아야합니다. 또한 수동으로 항목을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">flock (3)의 fcntl (2) 에뮬레이션에서는 LOCK_SH를 사용하려면 FILEHANDLE을 읽기 의도로 열어야하고 LOCK_EX를 사용하려면 쓰기 의도로 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="85ef7ad11abd8bc54af52a716405bd9eb2cc5233" translate="yes" xml:space="preserve">
          <source>Note that the file path is relative to &lt;code&gt;$dir&lt;/code&gt; if that is specified. This &lt;b&gt;must not&lt;/b&gt; be used directly for CPAN META &lt;code&gt;provides&lt;/code&gt;. See the &lt;code&gt;provides&lt;/code&gt; method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">파일은 지정된 동일한 이름으로 두 번 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">최종 문자열은 pvlim보다 최대 7 자 더 길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd6cdc78eed59a6e15c0c2c30dcc231f761afe79" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://man.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">첫 번째 인수가 필요합니다. 섹션 번호는 섹션 번호에서 구문 분석되며 누락 된 경우 기본값은 1로 설정됩니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; 은 현재 해당 페이지에 링크 가능한 ID 또는 앵커 이름을 포함하지 않으므로 두 번째 인수는 현재 무시됩니다 . 다른 매뉴얼 페이지 HTTP 서버에 링크하기위한 서브 클래스.</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">위의 첫 번째는 Time :: Seconds 객체를 반환하므로 객체를 검사하는 동안 (오버로드로 인해) 초 수를 인쇄하지만 분, 시간, 일, 주 및 년 수를 얻을 수도 있습니다. Time :: Seconds API를 사용하여 해당 델타.</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">여기서 일반적인 패턴은 접근 자 메소드가 &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; 값을 &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; &lt;i&gt;attribute&lt;/i&gt; ( &lt;i&gt;newvalue&lt;/i&gt; )로 &lt;i&gt;속성&lt;/i&gt; 값을 설정한다는 것입니다.&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt; 입니다. 각 접근 자에 대해 일반적으로 실제로 가장 많이 사용한다고 생각하는 구문을 하나만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">글로벌 변수 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; 는 &lt;code&gt;parent&lt;/code&gt; 메소드를 지원하지 않는 이전 perls에서 정의되지 않고 정의되었지만 메소드를 지원하지만 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 없이 빌드 된 perls에서는 false입니다. 이며 그렇지 않은 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="33122f52d4f72485938536bba048d13bb9c994d8" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt;, and is true otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">이 모듈에서 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 을 구현 한다고해서 압축 파일 / 버퍼에 대한 임의의 랜덤 액세스는 제공하지 않습니다. &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 할 매개 변수에 지정된 비 압축 오프셋에 도달 할 때까지 파일 / 버퍼의 현재 오프셋에서 데이터를 압축 해제하여 작동합니다. . 아주 작은 파일의 경우 허용되는 동작 일 수 있습니다. 큰 파일의 경우 허용되지 않는 지연이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2278932c41e8894955fd432303661d611324abc" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;seek&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;seek&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">중첩 클래스의 이니셜 라이저는 해당 클래스의 객체로 지정되거나 중첩 된 구조체의 생성자에 전달되는 이니셜 라이저의 해시에 대한 참조로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">알람과 슬립 간의 상호 작용은 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">이 함수에 의해 반환 된 반전리스트는 유니 코드가 아닌 코드 포인트, 즉 0x10FFFF보다 큰 코드 포인트를 포함 할 수 있습니다. 이러한 코드 포인트에는 유니 코드 속성이 정의되어 있지 않습니다. 이를 포함하지 않도록 출력을 변경하고자 할 수 있습니다. 비어 있지 않은 반환 목록의 끝에 0x110000을 추가하십시오 (아직 해당 값이 아닌 경우). 그 값이 있다면 그 값을 팝; 처럼:</target>
        </trans-unit>
        <trans-unit id="b0e71b8ea159a9c2edf24faa2295a4b51fa39394" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; for these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">&lt;code&gt;Case_Folding&lt;/code&gt; 및 &lt;code&gt;Simple_Case_Folding&lt;/code&gt; 특성에 대해 리턴 된 반전 맵 에는 Turkic-locale 맵핑이 포함되지 않습니다. 이를 위해 &lt;a href=&quot;#casefold()&quot;&gt;casefold ()&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">유니 코드에서 가장 큰 코드 포인트는 U + 10FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">이들 중 마지막 두 가지는 실제로 MS Windows 용 완전한 gcc 툴체인을 제공하는 경쟁 프로젝트입니다.</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">파일 이름에서 선행 &quot;:&quot;이 제거되므로</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">일반적인 연관 배열과 마찬가지로 검색된 키의 순서는 명백하게 임의의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="f7e4be377938ec5b2bd579fa7c5058874b5e3a40" translate="yes" xml:space="preserve">
          <source>Note that the line number of the error/warning may refer to the line number of the start of the paragraph in which the error/warning exists, not the line number that the error/warning is on. This bug is present in errors/warnings related to formatting codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eb999d3e69609ef8f64d4732450cbda274eea8" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">줄은 기본적으로 인쇄되지 않습니다. &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; 참조줄을 인쇄하려면 를 . 어떤 이유로 인수로 명명 된 파일을 열 수없는 경우 Perl은 이에 대해 경고하고 다음 파일로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b32153557293284be92deec6168f3ee23705dad2" translate="yes" xml:space="preserve">
          <source>Note that the list form of exec() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ea4347f8d164bb526f1210c5912fa3af79feb" translate="yes" xml:space="preserve">
          <source>Note that the list form of system() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">목록은 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3e41c72d7fee1ff8c764beabf8a96c567a3b6233" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">substr ()의 3 인수 버전에서 반환 된 lvalue는 '마법의 탄환'역할을합니다. 할당 될 때마다 원래 문자열의 어떤 부분이 수정되고 있는지 기억합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">맵핑은 유니 코드 데이터 파일에 지정된 맵핑이며 최종 분해를 얻으려면 재귀 적으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="41e59b746c6a84ae0b237b2221463c64daa4df44" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively. Unicode in fact discourages use of this property except internally in implementations of the Unicode Normalization Algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">최소 일치 수량자는 &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;??&lt;/code&gt; 중첩 된 한정자 인 것처럼 보이지만 그렇지 않습니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b41b3d83f67f68a69236e54f8aeb3e828ab48b2" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">지수 계수가 100보다 작은 숫자에 대해 과학적 표기법에서 &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; 및 &lt;code&gt;%G&lt;/code&gt; 로 생성 한 지수 자릿수 는 시스템에 따라 다릅니다. 세 개 이하 (제로 채워짐) 필요에 따라). 즉, 1.23 곱하기 10에서 99까지는 &quot;1.23e99&quot;또는 &quot;1.23e099&quot;일 수 있습니다. &lt;code&gt;%a&lt;/code&gt; 및 &lt;code&gt;%A&lt;/code&gt; 와 유사하게 지수 또는 16 진수가 부동 될 수 있습니다. 특히 &quot;long doubles&quot;Perl 구성 옵션은 놀라움을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bcb562562261f56086728520662f93907434b0" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt;: the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">확장 기능을 작성하는 일반적인 방법에서 변경된 두 가지 사항 은 Perl 헤더를 포함하기 전에 &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; 를 추가 한 다음 dTHX 를 추가하는 것입니다 &lt;code&gt;dTHX;&lt;/code&gt; Perl API를 호출 할 모든 함수 시작시 선언 (C 컴파일러가 해당 함수에 선언되지 않은 식별자가 있다고 불평하기 때문에 어떤 함수가 필요한지 알 수 있습니다.) XS () 매크로가 암시 적 컨텍스트로 전달되도록 올바르게 정의되어 있으므로 XSUB 자체에는 변경이 필요하지 않습니다. 필요한 경우.</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">opmask는 이미 컴파일 된 코드에는 영향을 미치지 않으며, 오직 어떤 코드에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">옵션 종료 자 (기본값 &lt;code&gt;--&lt;/code&gt; )도있는 경우 &lt;code&gt;@ARGV&lt;/code&gt; 에도 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d140eced205e7240d0cac12aab6ec294f45d708" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt;), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b99871b0f7ac49ac26656a96e644a594657e984" translate="yes" xml:space="preserve">
          <source>Note that the outer &lt;code&gt;=over&lt;/code&gt; is a block because it has no &lt;code&gt;=item&lt;/code&gt;s but still has content: the inner &lt;code&gt;=over&lt;/code&gt;. The inner &lt;code&gt;=over&lt;/code&gt;, in turn, is completely empty, and is treated as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">&lt;code&gt;(?=regexp)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; 의 괄호는 폭이 0 인 어설 션이므로 캡처되지 않습니다. 따라서 두 번째 정규 표현식에서 캡처 된 하위 문자열은 전체 정규 표현식 자체의 하위 문자열입니다. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; 는 임의의 정규 표현식 과 일치 할 수 있지만 lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 는 고정 너비의 정규 표현식 , 즉 고정 된 수의 문자 길이에 대해서만 작동합니다. 따라서 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; 는 괜찮지 만 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; 는 그렇지 않습니다. lookahead 및 lookbehind 어설 션의 부정 버전은 각각 &lt;code&gt;(?!regexp)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; 됩니다. 정규 표현식이 수행하면 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b450a76f799fbd2000fb736a0e284dee87f232b7" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in these are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead can match arbitrary regexps, but lookbehind prior to 5.30 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">emacs의 펄-모드는 &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (작은 따옴표) 와 맞고 들여 쓰기와 강조 표시를 망칠 것 입니다. 어쨌든 새로운 Perl 코드에서 &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; 를 사용하고있을 것이므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">소유 정량 기 수정자는 욕심없는 수정 자와 결합 될 수 없습니다. 이것은 말이되지 않기 때문입니다. 다음 동등성 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="05a31604712dc06b57292f7d6e6baf36004c8881" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">프로세스는 사용하는 각 파일에 대해 계속 증가합니다. 또한 &lt;code&gt;AUTOLOAD&lt;/code&gt; ed 서브 루틴 및 Perl의 기호 테이블이 커지는 기타 조건이 있을 수 있습니다 . 메모리 소비를 최소화하기 위해 프로세스 크기를 추적하거나 특정 횟수의 요청 후에 다시 시작하는 논리를 추가 할 수 있습니다. 또한와 범위 당신의 변수를 원하는 것 &lt;a href=&quot;functions/my&quot;&gt;내&lt;/a&gt; 보입니다.</target>
        </trans-unit>
        <trans-unit id="19133e9511ee15654168135f8179ad57c8de3d7c" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt;ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;perlfunc#my&quot;&gt;&quot;my&quot; in perlfunc&lt;/a&gt; whenever possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">알고리즘이 분석되고 기계가 더 빨리 성장함에 따라 알고리즘의 속성은 시간이 지남에 따라 변경됩니다. 예를 들어 응용 프로그램이 다른 메시지에 대해 동일한 다이제스트를 생성하는 것이 &quot;불가능한&quot;방법에 의존하는 경우 사용되는 알고리즘이 약해질수록 더 강력한 알고리즘을 쉽게 연결할 수 있습니다. 여기에 설명 된 인터페이스를 사용하면 나중에 알고리즘을 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">&quot;_&quot;로 시작하는 키가 _AUTO에 영향을 미치지 않는 이유는 일반적으로 밑줄 문자에 대해 마술이 아닙니다. 필자는 대부분의 어휘 키를 자동화 할 수있는 방법을 원했습니다. 소수를 구별하기위한 신호로 선행 밑줄을 사용하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">상기 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 는 암시 적 범위에 의해 구속 된다는 점에 유의한다 . 결과적으로 새로 도입 된 어휘 변수 또는 수정 된 캡처 버퍼 내용은 평가 후에 유실됩니다. 디버거는 Perl을 배우기에 좋은 환경이지만, 같은 범위에 있어야하는 재료를 사용하여 대화식으로 실험하는 경우 한 줄에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="471933a1768d0ec6bc98ec34dbc5facf0b071a6f" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;eval&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">단일 매개 변수는</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">소스 코드는 단일 문자열로 전달되므로 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 를 사용하여 행 경계를 감지 하는 모든 정규식 에는 &lt;code&gt;/m&lt;/code&gt; 플래그 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="262f4baab34cdad3f12b64cb0a920818da7a10be" translate="yes" xml:space="preserve">
          <source>Note that the spaces are required around the &lt;code&gt;SVf&lt;/code&gt; in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">특수 변수 &lt;code&gt;$^N&lt;/code&gt; 은 중첩 괄호 수를 추적하지 않고도 변수의 부분 일치 결과를 캡처하는 코드 블록에 특히 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">지정된 &lt;code&gt;fail&lt;/code&gt; 동작은 중첩 된 태그에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">지정된 구분 기호는 자동으로 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">스택은 &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; 가 true 인 블록에서 &lt;code&gt;POPs&lt;/code&gt; 를 사용하여 팝됩니다 . 이것은 항상 필요하기 때문에</target>
        </trans-unit>
        <trans-unit id="710a5c79e66bbfbe96fbdcb6dc7413e03b66071c" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">무한대의 문자열 형식은 플랫폼마다 다릅니다. 예를 들어 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2587b73a26222076539535f74b276c7c807272c" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">여기서 구문은 &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; 가 아니라 &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; 입니다. 즉, 코드 표현식의 경우 조건부 주위에 추가 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 의 태그 이름 에는 선행 ':'이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d0f8cfa5599a4759e632a786adcd5ca20b3cfca" translate="yes" xml:space="preserve">
          <source>Note that the third argument to &lt;code&gt;open&lt;/code&gt; is a string containing the program name (&lt;code&gt;sort&lt;/code&gt;) plus all its arguments: in this case, &lt;code&gt;-u&lt;/code&gt; to specify unqiue sort, and then a fileglob specifying the files to sort. The resulting filehandle &lt;code&gt;$sort_fh&lt;/code&gt; works just like a read-only (&lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;) filehandle, and your program can subsequently read data from it as if it were opened onto an ordinary, single file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bef6f0ef3eec50d14d3b84a1a8afd14c67d76b" translate="yes" xml:space="preserve">
          <source>Note that the third argument, specifying the command that we wish to pipe to, sets up &lt;code&gt;cat&lt;/code&gt; to redirect its output via that &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; symbol into the file &lt;code&gt;numbered.txt&lt;/code&gt;. This can start to look a little tricky, because that same symbol would have meant something entirely different had it showed it in the second argument to &lt;code&gt;open&lt;/code&gt;! But here in the third argument, it's simply part of the shell command that Perl will open the pipe into, and Perl itself doesn't invest any special meaning to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">후행 슬래시가 필요합니다. 구성이 실행될 때 몇 가지 무해한 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">제한된 작업의 트래핑은 원자 적이 지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">하이픈의 양쪽에있는 두 문자가 반드시 문자 나 숫자가 아닌 것은 아닙니다. 권장되지는 않지만 모든 문자가 가능합니다. &lt;code&gt;['-?]&lt;/code&gt; 에는 다양한 문자가 포함되어 있지만 대부분의 사람들은 어떤 문자를 의미하는지 알지 못합니다. 또한 EBCDIC와 같은 다른 문자 집합을 사용하는 플랫폼에서 코드를 실행해야하는 경우 이러한 범위로 인해 이식성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">사용자의 인수도 플러그인의 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 함수에 목록으로 전달됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b14ba3e78a188703ed0553b34c3137fe88a72a21" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;import()&lt;/code&gt; function as a list, eg:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 실행될 때마다 값이 구문 분석됩니다 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 평가 됩니다. 이 양식은 일반적으로 런타임까지 EXPR 텍스트의 구문 분석 및 후속 실행을 지연시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 실행될 때마다 값이 구문 분석됩니다 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 평가 됩니다. 이 양식은 일반적으로 런타임까지 EXPR 텍스트의 구문 분석 및 후속 실행을 지연시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">&lt;code&gt;RV&lt;/code&gt; 의 가치는 우리가 $ b를 묶을 때 보이는 숫자와 일치합니다. IV () 안의 주소 는 &lt;code&gt;SV&lt;/code&gt; 의 현재 상태를 유지하는 &lt;code&gt;X***&lt;/code&gt; 구조의 주소입니다 . 이 주소는 SV 수명 동안 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66bc2a839853392e6ca68b6e60b0dadd045339b5" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt;. This address may change during lifetime of an SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">값은 복사되지 않으므로 값을 수정하면 해시의 내용이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebcf1c39304e5cedc9f3bd9f293f7823399a8398" translate="yes" xml:space="preserve">
          <source>Note that the values for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">코드 표현식 외부의 일반 변수에서와 같이 regexp가 컴파일 될 때 변수 &lt;code&gt;$z0&lt;/code&gt; 및 &lt;code&gt;$z1&lt;/code&gt; 은 대체되지 않습니다. 오히려 전체 코드 블록은 perl이 리터럴 regexp 패턴을 포함하는 코드를 컴파일하는 것과 동시에 perl 코드로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">다른 &quot;long doubles&quot;가 있습니다 : Perl은 컴파일러가 가진 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">최대 길이 &lt;code&gt;$0&lt;/code&gt; 에는 플랫폼 별 제한이 있습니다 . 가장 극단적 인 경우에는 원래 &lt;code&gt;$0&lt;/code&gt; 차지하는 공간으로 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ee80c0ec2ca365e28a84cac33edad0345d62e8d" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt;. In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">현재 로케일의 영향을받지 않는 것이 몇 가지 있습니다. 모든 리터럴 문자는 주어진 플랫폼의 기본 문자입니다. 따라서 'A'는 ASCII 플랫폼의 코드 포인트 65와 EBCDIC의 193을 의미합니다. 해당 로케일에 'A'가있는 경우 현재 로케일에서 'A'일 수도 있고 아닐 수도 있습니다. 마찬가지로 특정 문자에 대한 모든 이스케이프 시퀀스 ( 예 : &lt;code&gt;\n&lt;/code&gt; 는 항상 플랫폼의 기본 이스케이프 문자를 의미합니다. 예를 들어, 정규식 (모든 문자이지만 개행 문자)의 &lt;code&gt;\N&lt;/code&gt; 은 플랫폼 문자 세트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">&lt;code&gt;unlock()&lt;/code&gt; 함수 는 없습니다 . 변수를 잠금 해제하는 유일한 방법은 범위를 벗어나는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">주의 반환 값된다는 보장이 없다는 것을 &lt;code&gt;SvPV()&lt;/code&gt; 와 같다 &lt;code&gt;SvPVX(sv)&lt;/code&gt; , 또는 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 유효한 데이터 또는 해당 연속 호출을 포함 &lt;code&gt;SvPV(sv)&lt;/code&gt; 같은 포인터 값을 매번 반환합니다. 이는 오버로드 및 쓰기시 복사와 같은 것들이 처리되는 방식 때문입니다. 이 경우 반환 값은 임시 버퍼 또는 이와 유사한 것을 가리킬 수 있습니다. SvPVX 필드가 유효해야하는 경우 (예 : 필드에 쓰려는 경우) &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7173a3e77270e17008cce0d5bec933c84a84832b" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt;, or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the &lt;code&gt;SvPVX&lt;/code&gt; field to be valid (for example, if you intend to write to it), then see &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">더 이상 Tie :: Cycle 모듈을 가져올 필요가 없습니다. Attribute :: Handlers가이를 자동으로 처리합니다. 클래스 이름에 인수를 추가하여 모듈의 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴에 인수를 전달할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c645ae5150cd4da2a80be90839d213441cd9479" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;import&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0baced4cf34e750c502cd9ad3044c3426673e61e" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the &lt;code&gt;File::Temp&lt;/code&gt; object. The object itself acts as a filehandle. The object isa &lt;code&gt;IO::Handle&lt;/code&gt; and isa &lt;code&gt;IO::Seekable&lt;/code&gt; so all those methods are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">C &amp;lt;: temp&amp;gt; 객체에서 파일 핸들을 얻는 방법은 없습니다. 객체 자체는 파일 핸들 역할을합니다. 객체는 C &amp;lt;: handle&amp;gt; 및 isa C &amp;lt;: seekable&amp;gt;이므로 모든 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7964282b8c77ed0956498c86928309abbe4d836" translate="yes" xml:space="preserve">
          <source>Note that there is no validation to confirm that the handle is a handle or something that can act like one. Passing something that isn't a handle will cause a exception when trying to read from it. The &lt;code&gt;filename&lt;/code&gt; argument is mandatory or undef will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">주어진 클래스의 여러 서브 클래스를 정의하는 데 아무런 문제가 없습니다. 이것은 일반적이며 안전합니다. 예를 들어, 다른 유형의 mp3 파일을 구분하기 위해 &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; 및 &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; 클래스를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">이 구성 옵션은 생성에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">이 기능은 94-95의 이전 포트가 아닌 * nix와 호환됩니다. 우선 순위는 절대적이며 32에서 -95로, 낮을수록 빠릅니다. 기본 우선 순위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">이 함수는 &lt;code&gt;SV*&lt;/code&gt; 키를 사용하므로 해시 구조를 처리하는 확장 코드 작성이 간단 해집니다. 이 기능은 또한의 통과 허용 &lt;code&gt;SV*&lt;/code&gt; 하는 키를 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (기능의 이전 세트와 달리) 키를 캐릭터 라인 화 할 시작하지 않고 기능을.</target>
        </trans-unit>
        <trans-unit id="7cd84224dc690f45347275d943903d70df26fb0c" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;tie&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">이 매크로는</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">이러한 문제는 작은 프로그램에 영향을 줄 가능성이 낮으므로 실험을 방해해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">이 루틴은</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">이 통계는 요약에 불과합니다. 실제 성능은 해시에 액세스하는 실제 적중 / 미스 비율에 따라 다릅니다. 적중률이 우려되는 경우 다음과 같은 방법으로 해시를 &quot;대형 크기&quot;하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="614e9c1a8e14a9fc6d986754f7def273a10af2f8" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag is set), as in both cases, 0 is returned, and, depending on the malformation, &lt;code&gt;retlen&lt;/code&gt; may be set to 1. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;s&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt;; if not, the input had an error. Or you can use &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">이 API는 &lt;code&gt;NUL&lt;/code&gt; 문자의 성공적인 디코딩 과 오류 리턴 (UTF8_CHECK_ONLY 플래그가 설정되지 않은 경우)간에 명확성을 요구합니다. 두 경우 모두 0이 리턴됩니다. 명확하게하기 위해, 0 리턴시 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 첫 바이트 도 0 인지 확인하십시오 . 그렇다면 입력은 &lt;code&gt;NUL&lt;/code&gt; 입니다 . 그렇지 않으면 입력에 오류가있었습니다.</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">스폰하지 않을 때이 문제는 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">이 동작은 네임 스페이스를 변경하는 데 루트 모듈을 사용할 수있는 안전 모듈 버전 1.00과 다릅니다. 그 기능은 더 깊이 고려되어 철회되었습니다.</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">개행을 피하는이 사업은 디버거에 입력 된 대화식 명령에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">이 클래스는 또한 Pod :: Simple :: HTMLBatch :: go 함수를 제공하지만 내보내지는 않습니다. 이것은 기본적으로 &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 의 바로 가기입니다 . 명령 행에서 호출하기에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="f83d5136d4b8e93ddca0e990f1293f696287db16" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt;. It's meant to be handy for calling from the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">이것은 축소되지 * 않습니다 *</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">이것은 유효한 로케일을 존중하지 않습니다. 플랫폼의 고유 문자 세트에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">이 예제는 어휘의 값을 보여 주지만 다른 예제는 그렇지 않습니다 (컴파일 타임 일 뿐이므로).</target>
        </trans-unit>
        <trans-unit id="750194633912e1b1b2810b4a6624c08076cb7c4d" translate="yes" xml:space="preserve">
          <source>Note that this feature is currently &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt;; using it yields a warning in the &lt;code&gt;experimental::regex_sets&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="770403ff8ad9becd7464272640adcfe95f14a6a1" translate="yes" xml:space="preserve">
          <source>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single &lt;code&gt;0&lt;/code&gt; is accepted, but not &lt;code&gt;00&lt;/code&gt; nor &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;002&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">이 하네스는</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">이 해시는 숫자 (예 : &quot;64&quot;또는 &quot;x981c&quot;)를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">이것은 버전 &lt;code&gt;1.36&lt;/code&gt; 과 이전 버전 과 호환되지 않는 변경 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">이것은리스트 연산자가 아닌 단항 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">이는 향후 Perl 릴리스에서 변경되거나 제거 될 수있는 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">이것은 이론적으로 더 모호한 유산의 껍질에서는 일반적으로 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">이것은 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 과 동일하지 않으므로 현재 클래스의 조상을 검색하는 것으로 제한되는 새 디스패치를 ​​시작합니다. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 은 현재 클래스를 역 추적하여 &lt;code&gt;$self&lt;/code&gt; 의 다른 조상에서 적합한 메소드를 찾을 수 있지만 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 은 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="511522d55453b336eeec0192506af6b8fb160bde" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt;, which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;()&lt;/code&gt; - 그룹 의 반복 횟수를 결정할 수 없기 때문에 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에 동일한 템플릿을 사용할 수없는 드문 경우 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="31c689cdab9ea9a66fe06d7827f40cae99aad3e2" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; because &lt;code&gt;pack&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt;-group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">이 단어는 실제로 영어의 단어가 아닙니다. 공백이 아닌 연속 된 문자 덩어리입니다.</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">필요한 Apple 프레임 워크가 PPC64 지원을 제공하지 않으므로이 문제로 인해 많은 Macintosh 특정 CPAN 모듈 ( &lt;code&gt;Mac::*&lt;/code&gt; )을 구축 할 수 없습니다. 마찬가지로 Fink 또는 Darwinports에서 다운로드 한 파일은 64 비트 지원을 제공하지 않을 것입니다. 라이브러리는 적절한 컴파일러 및 링커 플래그를 사용하여 소스에서 다시 작성해야합니다. 자세한 내용은 Apple의</target>
        </trans-unit>
        <trans-unit id="e01d7922e9382b1372af232c43cd56d7c9562fcf" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt;), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">이 마지막 예는</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">이는 Perl이 다른 소프트웨어가 동일한 방식으로 작동 할 것으로 예상한다는 것을 의미합니다. Perl이 STDIN이 UTF-8이어야한다고 믿게되었지만 다른 명령에서 들어오는 STDIN이 UTF-8이 아니라면 Perl은 잘못된 UTF-8.</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">이는 내부 패턴이 외부에 정의 된 캡처 그룹을 참조 할 방법이 없음을 의미합니다. (코드 블록 자체는 &lt;code&gt;$1&lt;/code&gt; 등을 사용하여 둘러싸는 패턴의 캡처 그룹을 참조 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="75120e6f9c48966777ee766b66dc5e5bb92f00ed" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85a4e8b339d0e328effdd49337132425d3cb1dc" translate="yes" xml:space="preserve">
          <source>Note that this method considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, it does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than &lt;code&gt;undef&lt;/code&gt;, in either case. Thus, in general, it cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls &lt;a href=&quot;IO::Socket#shutdown&quot;&gt;&quot;shutdown&quot; in IO::Socket&lt;/a&gt; or &lt;code&gt;close&lt;/code&gt;. Only at that point does this function return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">이 방법은 쓰지 않습니다 &lt;code&gt;on the fly&lt;/code&gt; 말하자면, 아카이브를 작성하기 전에 여전히 모든 파일을 메모리로 읽습니다. 문제가있는 경우 아래 FAQ를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">이 메소드는 주석 앞에 '#'이 오는 주석 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">이것은 모든 산술 및 관계 &lt;b&gt;연산자&lt;/b&gt; 가 피연산자와 결과를 처리 하는 방식에만 영향을 미치며 모든 숫자가 처리되는 방식 에는 영향을 &lt;b&gt;주지 않습니다&lt;/b&gt; . 특히 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; .산술 연산자 (+,-, *, /, %, + =,-=, * =, / =, % = 및 단항 빼기)의 결과를 계산하기 전에 비교 연산자 (&amp;lt;, &amp;lt; =,&amp;gt;,&amp;gt; =, ==,! =, &amp;lt;=&amp;gt;) 및 비트 연산자 (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, | =, &amp;amp; =, ^ =, &amp;lt;&amp;lt; =, &amp;gt;&amp;gt; =), 피연산자에는 분수 부분이 잘 리거나 바닥이 있으며 결과에도 분수 부분이 잘립니다. 또한 피연산자와 결과 범위는 익숙한 2의 보수 정수, 즉-(2 ** 31) .. (2 ** 31-1) (32 비트 아키텍처) 및-(2 **)의 범위로 제한됩니다. 63) .. (2 ** 63-1) 64 비트 아키텍처. 예를 들어,이 코드</target>
        </trans-unit>
        <trans-unit id="444b0c1a203433a23ae5410357a56dc9fd46182a" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;use integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed01a3c9fe729c5926b4311c21dc0630e4d43559" translate="yes" xml:space="preserve">
          <source>Note that this option alone doesn't cause any debugging information to be output. What it does is stop the normal suppression of execution-related debugging information during the matching portion of the compilation of wildcards. You also have to specify which execution debugging information you want, such as by also including the EXECUTE option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">이 옵션은 여러 POD 파일을 한 번에 변환 할 때 유용하지 않을 수 있습니다. 명령에 대한 Unix 매뉴얼 페이지의 규칙은 명령이 아닌 경우에도 매뉴얼 페이지 제목이 모두 대문자가되도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="23d0291a11d0e9160102c369e2e83afde2d6c5ee" translate="yes" xml:space="preserve">
          <source>Note that this option only works with Perl 5.8.4 or better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898ae211ecf9d9481d220ef526611f5faf15a726" translate="yes" xml:space="preserve">
          <source>Note that this section does not document what</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 AV *를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 HV *를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 SV *에 참조를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">이 변수는 Perl 5.14.0에서 추가되었습니다. 이전 버전의 Perl에서 글로벌 폐기 단계를 감지하려면 CPAN 에서 &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">이 버전 번호는 Storable 모듈 자체의 버전 번호와 동일하지 않습니다. 예를 들어 Storable v0.7은 v2.0 형식의 파일을 작성하고 Storable v2.15는 v2.7 형식의 파일을 작성합니다. 파일 형식 버전 번호는 이전 버전의 모듈을 혼동시키는 추가 기능이 추가 된 경우에만 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">종속성 누락으로 인해 테스트에 실패한 배포에는 적용되지 않습니다. 또한 &quot;force&quot;를 사용하여 기록에 관계없이 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bcf77d3862c68d316c827809d40fa450ae96c79" translate="yes" xml:space="preserve">
          <source>Note that this will not work on uninstalled perls when called with &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt;, but it works when that path is in &lt;code&gt;$PERL5LIB&lt;/code&gt; or in &lt;code&gt;$PERL5OPT&lt;/code&gt;, as paths passed using &lt;code&gt;-I&lt;/code&gt; are not known when the &lt;code&gt;-V&lt;/code&gt; information is collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">이렇게하면 비슷한 내용이 나오지만 읽기가 훨씬 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="b8bf897da733e3c7fd8c9b9e480c0bb39918d58f" translate="yes" xml:space="preserve">
          <source>Note that this works only when you &lt;code&gt;decode&lt;/code&gt;. You can set incompatible boolean objects (like &lt;a href=&quot;boolean&quot;&gt;boolean&lt;/a&gt;), but when you &lt;code&gt;encode&lt;/code&gt; a data structure with such boolean objects, you still need to enable &lt;code&gt;convert_blessed&lt;/code&gt; (and add a &lt;code&gt;TO_JSON&lt;/code&gt; method if necessary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Bzip2 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">Bzip2 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 가 설치되어 있어야합니다. &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 를 사용할 수 없을 때 Bzip2 컨텐츠를 작성하려고하면 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">LZMA 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">Lzma 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 가 설치되어 있어야합니다. &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 를 사용할 수 없을 때 Lzma 컨텐츠를 작성하려고하면 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">중단 점을 삭제하려면 'B'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">옵션 처리를 종료하려면 여전히 이중 대시 ( &lt;code&gt;--&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d940f3704d17dd3194fc775422b4ac6a56659d1f" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">이 속성을 true로 설정해도 복구 할 수없는 오류가 거의 발생하지 않는다는 한 가지 또는 두 가지 유형의 불만은 억제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c769b2bb4c9d14e0051897b1dc06f73914041f2" translate="yes" xml:space="preserve">
          <source>Note that under &lt;code&gt;/i&lt;/code&gt;, a few single characters match two or three other characters. This makes them variable length, and the 255 length applies to the maximum number of characters in the match. For example &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; matches the sequence &lt;code&gt;&quot;ss&quot;&lt;/code&gt;. Your lookbehind assertion could contain 127 Sharp S characters under &lt;code&gt;/i&lt;/code&gt;, but adding a 128th would generate a compilation error, as that could match 256 &lt;code&gt;&quot;s&quot;&lt;/code&gt; characters in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b40c66bbd4f3571d75ea521000a6cee32083010" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; depends on the &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; C library function. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the &lt;a href=&quot;posix#open&quot;&gt;&lt;code&gt;POSIX::open&lt;/code&gt;&lt;/a&gt; function. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f7379eb3bd6961a9d597915f1b15a614c4f1c6" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">5.8.0 이전의 Perls에서 Perl은 표준 C 라이브러리의 fdopen ()을 사용하여 &lt;code&gt;=&lt;/code&gt; 기능 을 구현합니다 . 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패합니다. Perls 5.8.0 이상에서는 PerlIO가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">Win32에서</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">bigint에서 결과는 정수로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">OS / 2와 같은 일부 시스템에서는 다양한 Perl 실행 파일이있을 수 있으며, 일부는 포크를 지원할 수 있지만 일부는 지원하지 않을 수 있습니다. Perl이라고 부르는 이름을 &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; 등으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="beba1d81b386ec1f5c90abc173f3ea4f03db2d8a" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt;, &lt;code&gt;perl__&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">불행히도 위의 상수 중 어느 것도 특정 플랫폼에서 사용 가능한 것은 아닙니다. 안전을 위해 다음과 같이 평가판을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; (및 &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; ) 와 달리 \ &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\v&lt;/code&gt; 는 활성 로캘과 같은 다른 요인이나 소스 문자열이 UTF-8 형식인지 여부에 관계없이 항상 동일한 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d708883d1ad8d31236c3f53f155ad26ec2c29df3" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt;), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ce79a861dd3251a8090941fe7f7a3f1e9ae60" translate="yes" xml:space="preserve">
          <source>Note that unlike most other regex magic variables there is no single letter equivalent to &lt;code&gt;@{^CAPTURE}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">안전 모듈 1.00 버전은 두 번째 선택적 매개 변수 인 MASK를 지원했습니다. 그 기능은 더 깊이 고려되어 철회되었습니다. 아래 설명 된 허가 및 거부 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">&lt;code&gt;autotie&lt;/code&gt; 메커니즘이 인수 목록을 목록으로 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 때문에 (Tie :: Whatever 예제에서 와 같이) 사이클링 값을 배열 참조로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b3c2527a47a822b83bab8f40e829ac7eb6aa7b2" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;tie&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">모든 카테고리를 포함하지 않는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 형식 이 지정되면 Perl은 제외 된 카테고리를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5b47f718523df526f757f6266d1dae38d1cc63ec" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;use locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50a1c7dfac9f6431a51ba8239dc629a049684b8" translate="yes" xml:space="preserve">
          <source>Note that when a module installs from CPAN to a core library directory rather than the site library directories, the user gains no protection from having installed it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">스트리밍 모드가 비활성화 된 상태에서 ( &lt;code&gt;Stream&lt;/code&gt; is 0) 파일로 출력 할 때는 출력 파일을 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">zlib 소스가이 모듈과 함께 빌드 될 때 &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 플래그 (비트 24, 25 및 26)는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="726c87af26a5b86094bbbbcff91a0a7370ca0001" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;sprintf&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">섹션 인수 만있는 경우 URL은 단순히 현재 문서의 섹션에 대한 링크 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">Win32의 기본 빌드 구성에서 perl을 사용할 때 (특히 perl_IMPLICIT_SYS를 사용하여 perl을 빌드 할 때) perl 인터프리터는 자체 환경 사본을 유지하며 기본 인터프리터 만 strftime에 표시된 프로세스 환경을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">스레드와 Linux를 사용할 때 Linux 프로세스와 스레드는 같은 종류이기 때문에 스레드를 종료하는 좋은 방법 이 &lt;b&gt;아닙니다&lt;/b&gt; (참고 : 2003 년 초의 상황이지만 스레드가있는 프로젝트가 진행 중입니다) 리눅스에서 더 POSIXly 의미론). 실에서 돌아 가지 않으려면 실을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">파일 핸들을 전달할 때 모든 파일이 파일 핸들에 그대로 인쇄되므로 압축 인수가 무시됩니다. 파일 핸들로 압축을 사용하려면 &lt;code&gt;IO::Zlib&lt;/code&gt; 또는 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 파일 핸들을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ec13b11833cba251c4e9511d82658d6fc77550f" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or &lt;code&gt;IO::Compress::Xz&lt;/code&gt; filehandle instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870efa0c38496f8567ab5707b290598c28081f5a" translate="yes" xml:space="preserve">
          <source>Note that where possible, values should be saved in the context struct rather than on the save stack; it's much faster that way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf20737dd41f077e46c31d590a5ed13707c1390" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신호 (SIGALRM) 후에 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 가 다시 시작 되는지 여부 는 구현에 따라 다릅니다. &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 이식성에 대한 참고 사항 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신호 (SIGALRM) 후에 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 가 다시 시작 되는지 여부 는 구현에 따라 다릅니다. &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 이식성에 대한 참고 사항 은 &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">동안 참고 &lt;code&gt;prove&lt;/code&gt; 시험의 목록을 받아 (또는 물건을 테스트 할은), &lt;code&gt;new&lt;/code&gt; 인수 상당히 풍부한 있습니다. 모든 코드가 어떻게 사용되는지 확인하려면이 코드를주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">위의 범주 시스템은 현재 엄격한 계층 구조이지만이를 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">스레드 자체는 별도의 실행 스레드이고 Perl 데이터는 명시 적으로 공유되지 않는 한 스레드 전용이지만 스레드는 프로세스 범위 상태에 영향을 미쳐 모든 스레드에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">멋진 작은 스크립트를 사용하여이 값을 얻었지만 간단한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="91f5f2f1e7150921d4bad701418dc42005b9e8df" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">괄호로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용하여 초기 값 할당을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">괄호로 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용하여 초기 값 할당을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">위의 모든 경우에서 첫 번째 ( &quot;-cut&quot;, &quot;-&quot;pod &quot;) 포드 단락을 검사하여&quot;= over &quot;...&quot;= back &quot;유형을 결정할 수 있습니다. &quot;= over&quot;명령.</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">쓰기는</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">당신이</target>
        </trans-unit>
        <trans-unit id="f571df233f4fa852ab6d69ef3a354636c953afea" translate="yes" xml:space="preserve">
          <source>Note that you &lt;b&gt;must&lt;/b&gt; quote the version when writing an alpha Decimal version. The stringified form of Decimal versions will always be the same string that was used to initialize the version object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">잡은 예외는 항상 다시 발생시켜야합니다. 이러한 매크로를 사용하면 예외를 잡아 무시할 수 없습니다. 예외를 무시 &lt;code&gt;call_*&lt;/code&gt; 경우 call_ * 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">단일 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 에 동일한 유형의 필터를 두 개 이상 적용 할 수도 있습니다 . 예를 들어 다음은 정규 매크로에만 적용되는 간단한 매크로 프리 프로세서이며 최종 소스 코드를 출력하는 최종 디버깅 패스입니다.</target>
        </trans-unit>
        <trans-unit id="2ed5dd8db2d6301ae073b216ad36ce2358ae0947" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt;. For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">&lt;code&gt;batch_convert&lt;/code&gt; 과 같이 batch_convert 를 클래스 메서드로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">참고 현재 수 &lt;b&gt;없는&lt;/b&gt; 패스 &lt;code&gt;gzip&lt;/code&gt; 을 함께 열려 있지 압축 파일 핸들, &lt;code&gt;IO::Zlib&lt;/code&gt; 하는 &lt;code&gt;bzip2&lt;/code&gt; 에 와 열려 있지 압축 파일 핸들, &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 하나 (도 전체 아카이브 정보를 포함하는 문자열을 압축 또는 비 압축). 이것들은 가치가 있지만 현재 구현되어 있지는 않지만 가치가 있습니다. &lt;code&gt;TODO&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36599b3f8142ec45ea2057810c7d1951232a084e" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt;, a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt;, a &lt;code&gt;xz&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt;, nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d20f2cbb1dd523835c53fe8971ba143f49fe81" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">자신의 속성을 정의 할 수 있습니다. &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode의 사용자 정의 문자 특성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; 와 일치한다는 점에서 URL 링크를 다른 것과 구별 할 수 있습니다 . 따라서 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; 은 URL이지만 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; 는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="64a115a0f7c10604758c941480143a80f74b2845" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt;. So &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5601b7465138e046c297f9bd7f032a15e613deb" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using &lt;code&gt;binmode()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">C를 사용하여 File :: Temp에서 연 파일의 인코딩을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령을 사용 하여이 경로를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">이것을 사용하여 &quot;todo&quot;테스트를 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">안전 신호를 사용하는 경우 자체 신호 처리기에서 신호를 안정적으로 차단하거나 차단 해제 할 수 없습니다. 다른 신호는 안정적으로 차단 또는 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">(디) 조성 및 케이싱은</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">변수를 명시 적으로 잠금 해제 할 수는 없습니다. 잠금이 범위를 벗어날 때까지만 기다릴 수 있습니다. 이것은 블록 안에서 변수를 잠그면 가장 쉽게 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">&quot; &lt;code&gt;NaN&lt;/code&gt; -ness&quot;는 다음과 같이 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="46d548823c2cd0fd3c7dcc027abf5e4fd2f7c713" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt;-ness&quot; with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">@EXPORT 또는 @EXPORT_OK에서는 태그를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1c43451d9784c36057c8528c7269957014b039f" translate="yes" xml:space="preserve">
          <source>Note that you do not have to use wildcards. You can specify explicitly which subdirectories to run tests in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">메소드 이름을 (재) 지정하지 마십시오. 항상 시작한 메소드와 동일한 메소드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1110cd59b64cb9b7410432e108a9ed2c0c79bda1" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; yourself since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; 파일 핸들로 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 오류를 처리 할 수 ​​없습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ARGV&lt;/code&gt; 를 다르게 처리 하므로 &lt;code&gt;@ARGV&lt;/code&gt; 의 각 요소를 직접 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; 파일 핸들로 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 오류를 처리 할 수 ​​없습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ARGV&lt;/code&gt; 를 다르게 처리 하므로 &lt;code&gt;@ARGV&lt;/code&gt; 의 각 요소를 직접 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">예를 들어, 프로그램이 키보드에서 입력을 받아 &quot;(Y / N)&quot;질문을하는 경우 어휘집에 저장되어있을 수 있습니다. 예를 들어, &quot;Y&quot;에 해당하는 것이 무엇인지 알아야합니다. [es] / N [o] &quot;는 모든 언어로되어 있습니다. &quot;y&quot;와 &quot;n&quot;의 대답이 무엇인지 알아야 할 수도 있습니다. 어휘집에 해당 정보를 저장할 수 있습니다 (예 : &quot;~ answer_y&quot;및 &quot;~ answer_n&quot;키 아래에 긴 형식은 &quot;~ answer_yes&quot;및 &quot;~ answer_no&quot;). 여기서 &quot;~&quot;는 임시 문자입니다. 프로그래머 / 번역가에게 출력 문구가 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;wanted()&lt;/code&gt; 함수 로 검색 할 디렉토리 목록에서 디렉토리와 (비 디렉토리가 아닌) 파일을 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">인코딩 또는 스크립트를 번역하려는 경우 경우에 따라 &lt;code&gt;maketext&lt;/code&gt; 메서드를 &quot;after method&quot; 로 재정의하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">tar 표준에 따라 아카이브의 모든 파일은 Unix 경로 여야하므로 $ new_name에 Unix 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">이 작업을 수행하려면 Module :: Signature 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">이 모듈을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 치명적이지 않은 오류를 트랩 하므로 특정 기능 (예 : &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; )이 구현 되는지 여부를 판별하는 데 유용합니다 . 또한 다이 연산자가 예외를 발생시키는 데 사용되는 Perl의 예외 트래핑 메커니즘이기도합니다.</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 치명적이지 않은 오류를 트랩 하므로 특정 기능 (예 : &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; )이 구현 되는지 여부를 판별하는 데 유용합니다 . 또한 다이 연산자가 예외를 발생시키는 데 사용되는 Perl의 예외 트래핑 메커니즘이기도합니다.</target>
        </trans-unit>
        <trans-unit id="891df8b540bc28be318d138e0d3e28e333361aa1" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;eval&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; operator is used to raise exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">때문에, 그 주 &lt;code&gt;Cycle&lt;/code&gt; 특성은 그것의 주장을 수신 &lt;code&gt;$data&lt;/code&gt; 속성이 인수의 목록이 제공되면, 변수 &lt;code&gt;$data&lt;/code&gt; 하나의 어레이 구성을 참조한다; 그렇지 않으면 단일 인수로 직접 구성됩니다. Tie :: Cycle은 사이클링 값을 배열 참조로 전달해야하므로 배열이 아닌 인수를 배열 생성자에서 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">기록 호환성을 위해 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 대신 &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efb52146528e00d45c6657da7bafa7f9366f782d" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">옵션 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;all&lt;/code&gt; 및 auto_abbrev가 사용 가능한 경우 가능한 인수 및 옵션 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49deca6d624d23372bddba3920f15c27d6789299" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt;, and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">비 대화식으로 구성을 실행하려면 (자세한 내용은 INSTALL 문서를 참조하십시오) 올바른 힌트 파일을 선택하려면 Configure 명령 행에 -Dhintfile = riscos 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">코드가 권장에서 실행되는 경우, 그 주 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; 프라그를, 당신은 이러한 패키지 변수를 선언해야합니다 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="399039fd0a4c09c727bec9d6e24cc011d4967d80" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;use strict vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;our&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;unless&lt;/code&gt; 과 달리 명령문이 항상 빈 목록으로 평가 &lt;code&gt;when&lt;/code&gt; 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="b41c93e43651e0e37405584834ec3d27a0bc44f8" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd6a1e156c7625206e1247c798d73aecaea5a68" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-hexadecimal up to the ending brace is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903c4c2bcdceef7b085f257005c8eb256d0f0ea7" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-octal up to the ending brace is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">참고하십시오 &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : C 컴파일러가 컴파일 할 때 긴 정수를 패킹하고 싶습니다. 그리고 지금까지도 컴파일러가 위와 같이 정렬하는 플랫폼에서만 작동합니다. 그리고 누군가 어딘가에 플랫폼이 없습니다. [ &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;long&lt;/code&gt; 이 모두 8 바이트 인 Cray 일 수 있습니다. :-)]</target>
        </trans-unit>
        <trans-unit id="0e14a4a995907061486f3bd76c1f023bc121f4f5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt;: We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt;s, &lt;code&gt;int&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt;s are all 8 bytes. :-)]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">위 의 &lt;code&gt;$]&lt;/code&gt; 는 리터럴이 아닙니다. 해당 항목을 존중하려는 모든 버전의 perl을 대체하십시오 (예 : &lt;code&gt;5.6.0&lt;/code&gt; ) . Windows에서와 같이 경로는 세미콜론으로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="99261696a47484abd841ec0d1ec91dfef269c276" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt;. Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">노트 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; 발현에 의해 둘러싸여 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; . 이것에 대한 아이디어는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate' 를 만드는 고전적인 관용구와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">메모 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 들 : 같은 피연산자 중 하나 변하지 않는 표준 조작 방법에서는 여기서 자동 생성 결과 &lt;code&gt;-&lt;/code&gt; ( &quot;뮤 테이터&quot;피연산자 변경 연산자 구현하는데 이용되는 여기를 &lt;code&gt;--&lt;/code&gt; 및 &lt;code&gt;-=&lt;/code&gt; ), Perl은 undef를 세 번째 인수로 전달합니다. 피연산자가 교체되지 않았지만 서브 루틴이 이러한 경우 동작을 변경할 수있는 기회를 제공한다는 사실과 일치하지만 여전히 FALSE로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="200da24930e3f664e651210aeef65207c51b5b78" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;tr//&lt;/code&gt; expression is surrounded by &lt;code&gt;qq{}&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;tr///&lt;/code&gt; 'interpolate':</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7ea810ebe5fef24b0b382427a65305a168d9de" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;undef&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt;, being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt;), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db05bb20e1742aeb610b95cb1ced4c32c7213bb5" translate="yes" xml:space="preserve">
          <source>Note the API instability warning in &lt;a href=&quot;#setpayload&quot;&gt;&quot;setpayload&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c6b44fb15bcf48412bfa33391fc2030093296e" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; to do the reverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LIST는 한 번에 하나의 요소가 아닌 전체가 앞에 붙어 있으므로 앞에 붙은 요소는 동일한 순서로 유지됩니다. &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 를 사용하여 반대 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LIST는 한 번에 하나의 요소가 아닌 전체가 앞에 붙어 있으므로 앞에 붙은 요소는 동일한 순서로 유지됩니다. &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 를 사용하여 반대 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">PERL_SET_CONTEXT () 호출에 유의하십시오. 이것은 어떤 인터프리터가 특정 프로세스 나 스레드에서 어떤 인터프리터가 &quot;현재&quot;인지 추적하는 전역 상태를 초기화하는 데 필요합니다. 둘 이상의 인터프리터가 있고 인터리브 방식으로 두 인터프리터 모두에서 perl API 호출을 수행하는 경우 항상 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5b392e74eb48b0aee9cb28bffd1d6dc73cfac7a" translate="yes" xml:space="preserve">
          <source>Note the early capture of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;old_ss_ix&lt;/code&gt;, which is later passed as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;. In the case of &lt;code&gt;pp_entersub&lt;/code&gt;, this is because, although most values needing saving are stored in fields of the context struct, an extra value needs saving only when the debugger is running, and it doesn't make sense to bloat the struct for this rare case. So instead it is saved on the savestack. Since this value gets calculated and saved before the context is pushed, it is necessary to pass the old value of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;cx_pushblock&lt;/code&gt;, to ensure that the saved value gets freed during scope exit. For most users of &lt;code&gt;cx_pushblock&lt;/code&gt;, where nothing needs pushing on the save stack, &lt;code&gt;PL_savestack_ix&lt;/code&gt; is just passed directly as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c788344d48bbaf6f108e51a7241322de827d97" translate="yes" xml:space="preserve">
          <source>Note the emphasis on bytes: even if the filehandle has been set to operate on characters (for example using the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I/O layer), the &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; family of functions use byte offsets, not character offsets, because seeking to a character offset would be very slow in a UTF-8 file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">위의 여러 바이트 항목 앞에 &quot;*&quot;로 표시된 간격을 확인하십시오. 가장 짧은 인코딩을 피하는 합법적 인 UTF-8로 인해 발생합니다. 기술적으로 단일 코드 포인트를 다른 방식으로 UTF-8로 인코딩하는 것이 가능하지만 명시 적으로 금지되며 가능한 가장 짧은 인코딩을 항상 사용해야합니다. 펄이하는 일입니다).</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">세미콜론에 유의하십시오. 내부에서 코드가 즉시 실행되지 않는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 과 같은 연산자만큼 선언이 아닙니다 . (그러나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; 에 있지 않는 한 특정 행을 몇 번이나 실행하더라도 $ coderef는 여전히</target>
        </trans-unit>
        <trans-unit id="ba98181394143476434b95cb278177df7d3eab51" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;sub {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;do{}&lt;/code&gt; or &lt;code&gt;eval{}&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">다음 두 가지 형태에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">마지막 예에서 &lt;code&gt;\&lt;/code&gt; 대신 &lt;code&gt;$&lt;/code&gt; 를 사용하십시오 . &lt;b&gt;sed&lt;/b&gt; 와는 달리 , 우리는 \ &amp;lt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="774d755cbcc9927f9bd666b04c889ec17f9ec2e7" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;code&gt;Minimal&lt;/code&gt; option in the code above. When using gzip for Content-Encoding you should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">여기에는 두 가지 단계가 있습니다. 1) Wild.pm을 만들어 perl lib 디렉토리에 저장해야합니다. 2) PERL5OPT 환경 변수를 설정해야합니다. argv 확장을 기본값으로 설정하려면 기본 시작 환경에서 PERL5OPT를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3aa39411508c2033438cf708df8c04c8a846a8d6" translate="yes" xml:space="preserve">
          <source>Note there is a distinction between a capture buffer which matches the empty string a capture buffer which is optional. Eg, &lt;code&gt;(x?)&lt;/code&gt; and &lt;code&gt;(x)?&lt;/code&gt; The latter may be undef, the former not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">성능상의 이유로이 인터페이스는 &lt;code&gt;gv_stashpvn&lt;/code&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">이것은 패치 수준 0부터 최신이며 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">다음과 같은 구문에서도 트리거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">이 이동은 \ x {D800}-\ x {DFFF}를 금지 구역으로 만들었지 만 perl은이 범위 내의 문자 사용을 금지하지 않습니다. 펄하기 위해, \ x {0000_0000}의 모든 것은 최대 \ x {ffff_ffff} (*)입니다.</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">여전히 Perl 5.18 또는 이전 버전을 사용하는 사람들을 참고하십시오 : &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; 을 사용하면 프로그램 내의 &lt;b&gt;모든&lt;/b&gt; 정규식 사용 이 느려집니다 . 문의 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 대한 &lt;code&gt;@-&lt;/code&gt; 그 속도가 느려지지 아래의 원인이됩니다 상응하는 표현을 볼 수 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt; 도 참조하십시오 . Perl 5.10부터는 등가 변수 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 를 사용할 수도 있지만, 정의하려면 &lt;code&gt;/p&lt;/code&gt; (preserve) 수정자를 지정해야 합니다. 정규식. Perl 5.20에서 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 속도 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="58f853df3fafdf36ed80cd1751e4f069c0f1707d" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">정규 표현식에서 / x 수정자를 사용할 때 현재 패턴 구분자를 포함하는 주석은 정규 표현식을 즉시 종료시킵니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">그러나 &quot;= 시작됨에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">그러나 (대부분의 다른 OO 언어와 달리) Perl은 어떤 식 으로든 캡슐화를 보장하거나 시행하지 않습니다. 실제로 객체를 원한다면</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">그러나 서식 코드와 Z &amp;lt;&amp;gt;는 L &amp;lt;...&amp;gt;의 모든 부분에서 발생할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="1ced7964eb00ec0017dbaa24226307b98c43e3bb" translate="yes" xml:space="preserve">
          <source>Note, however, that sometimes the Pod events aren't processed in exactly the same order as the code lines are -- i.e., if you have a file with Pod, then code, then more Pod, sometimes the code will be processed (via whatever you have code_handler call) before the all of the preceding Pod has been processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">그러나 이것이 Perl 코드를 인용 할 때 항상 작동하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">그러나 이로 인해 일부 값의 지역화가 제한됩니다. 예를 들어, 다음 명령문은 perl 5.10.0에서 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">부수적으로, 각 그룹의 항목은 &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated가 아니라 쉼표로 구분됩니다 . 즉,이 대괄호 그룹은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6f16890b60d4dbdb1b39ad263c84c7dffbf2eae" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt;-separated. That is, you might expect that this bracket group:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">참고,이 값이 이에 모듈의 버전이 지정되지 않은 것으로 가능하다 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용하므로, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; 그 무엇 당신에게있는 거 테스트의 경우.</target>
        </trans-unit>
        <trans-unit id="0424f392af8ee6773275c7a49c920c35add5c370" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;undef&lt;/code&gt;, so use &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e4009ec57ba2c9432c9aea5b719c678f3436d3" translate="yes" xml:space="preserve">
          <source>Note, prior to 5.25 this function returned what is now returned by the hv_bucket_ratio() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">Perl 5.18부터 &lt;code&gt;BELL&lt;/code&gt; 이라는 이름 은 기존 U + 0007 대신 유니 코드 문자 U + 1F514를 나타냅니다. 후자의 경우 &lt;code&gt;ALERT&lt;/code&gt; 또는 &lt;code&gt;BEL&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="610f3ee797f1ad4a61eeefe27944e6e308608f88" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">두 경우 모두 물결표 확장은 기본적으로 perl 또는 make가 아닌 MakeMaker에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="557c3756e4a3c96fb446dffbb0c22ffbb956fd7d" translate="yes" xml:space="preserve">
          <source>Note, there is a limitation of this technique. Some compression file formats store extra information along with the compressed data payload. For example, gzip can optionally store the original filename and Zip stores a lot of information about the original file. If the original compressed file contains any of this extra information, it will not be transferred to the new compressed file using the technique above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 으로 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 의해 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">참고 사용 &lt;code&gt;gv_stashsv&lt;/code&gt; 대신 &lt;code&gt;gv_stashpvn&lt;/code&gt; 강하게 성능상의 이유로 추천 가능.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="04e9999aa448d4f7736e19660c8cdd3fdd576ad9" translate="yes" xml:space="preserve">
          <source>Note: 'pinyin' is Han in Latin, 'zhuyin' is Han in Bopomofo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdcc6395bb5bb305f89c21276194ad5f5be7723" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; on directories is not supported on many operating systems. Use &lt;a href=&quot;#rmdir-FILENAME&quot;&gt;&lt;code&gt;rmdir&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 : 수퍼 유저이고 &lt;b&gt;-U&lt;/b&gt; 플래그가 Perl에 제공 되지 않으면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 디렉토리 삭제를 시도하지 않습니다 . 이러한 조건이 충족 되더라도 디렉토리를 연결 해제하면 파일 시스템이 손상 될 수 있다는 경고가 표시됩니다. 마지막으로 많은 운영 체제에서 디렉토리에서 링크 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 지원되지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">참고 : 이 예제 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 이 필요하지 않습니다. &lt;code&gt;strftime()&lt;/code&gt; 은 항상 현재 &lt;code&gt;LC_TIME&lt;/code&gt; 로케일을 따르는 표준 시스템 제공 &lt;code&gt;libc&lt;/code&gt; 함수를 사용하는 POSIX 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">참고 : 이 예제 중 일부에서는 필요하지 않으므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 표시되지 않습니다. &lt;code&gt;strcoll()&lt;/code&gt; 및 &lt;code&gt;strxfrm()&lt;/code&gt; 은 항상 현재 &lt;code&gt;LC_COLLATE&lt;/code&gt; 로케일을 따르는 표준 시스템 제공 &lt;code&gt;libc&lt;/code&gt; 함수를 사용하는 POSIX 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 : 수퍼 유저이고 &lt;b&gt;-U&lt;/b&gt; 플래그가 Perl에 제공 되지 않으면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 디렉토리 삭제를 시도하지 않습니다 . 이러한 조건이 충족 되더라도 디렉토리를 연결 해제하면 파일 시스템이 손상 될 수 있다는 경고가 표시됩니다. 마지막으로 많은 운영 체제에서 디렉토리에서 링크 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 지원되지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">참고 : &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 은 stdio 레이어의 레이어를 검색합니다. 찾지 못하면 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 을 호출 하여 새 stdio &lt;code&gt;FILE&lt;/code&gt; 을 생성합니다 . 원하는 경우 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 만 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="724e5762fee6d350a318fc2fb4b30294baaefc44" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt;. Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f6afd463560b84ea6b975b1be869772594ae4f" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f06e6aec634d9ac607b849e5f22d774716a195" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">참고 : export_to_level을 호출하기 전에 &lt;code&gt;@_&lt;/code&gt; 을 전혀 수정하지 않도록주의하십시오. 그렇지 않으면 패키지를 사용하는 사람들이 설명 할 수없는 결과를 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">참고 : 5.21.0 이전에는 &quot;누락 된&quot;어휘 경고 범주가 내부적으로 &quot;초기화되지 않은&quot;범주와 동일하도록 정의되었습니다. 이제는 그 자체로 최상위 카테고리입니다.</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">참고 : Perl 5.8.0 이전의 어휘 경고 범주 &quot;더 이상 사용되지 않음&quot;은 &quot;구문&quot;범주의 하위 범주였습니다. 이제는 그 자체로 최상위 카테고리입니다.</target>
        </trans-unit>
        <trans-unit id="d209ffe48badd4b3ce623fe1073da3a9d734affc" translate="yes" xml:space="preserve">
          <source>Note: Between XSUB and pure Perl, there is an incompatibility about the interpretation of &lt;code&gt;$code_point&lt;/code&gt; as a decimal number. XSUB converts &lt;code&gt;$code_point&lt;/code&gt; to an unsigned integer, but pure Perl does not. Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;$code_point&lt;/code&gt; 에 부동 소수점이나 음수 부호를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="668a585af93a214a0b5974e95d57e4c940a86f77" translate="yes" xml:space="preserve">
          <source>Note: Due to XS issues the block passed may be able to access the outer @_ directly. This is not intentional and will break under debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7d3334d006afa6b870b1e3ad78d323bdbd6bec" translate="yes" xml:space="preserve">
          <source>Note: Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd381c6324e161a3ae5c4a254351b2b3b48d1d8" translate="yes" xml:space="preserve">
          <source>Note: Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">참고 : FCC는 4 가지 정규화 형식 (NF *)뿐만 아니라 고유합니다.</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">참고 : FCD는 항상 고유하지는 않으며 복수 형식은 서로 동일 할 수 있습니다. &lt;code&gt;FCD()&lt;/code&gt; 는 이와 동등한 형식 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">참고 : 일부 확장의 경우 Dave Beazley의 SWIG 시스템이 확장 글루 코드를 작성하는 데 훨씬 더 편리한 메커니즘을 제공 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">참고 : Mac OS X 10.6 &quot;Snow Leopard&quot;부터 Apple은 Intel 기반 하드웨어 만 지원합니다. 즉, 이전 Apple 컴퓨터가 ppc에서 실행 중이거나 이전 버전과 호환되는 perl 바이너리를 만들지 않는 한이 섹션을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">참고 : 문자열이 FCD에 없으면 FCC에 있으면 안됩니다. 따라서 &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; 은 &lt;code&gt;NO&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c308958e09dd00a6a549fa78fd5e059fbed4455" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">참고 : &lt;code&gt;Sparseseen&lt;/code&gt; 을 켜면 본 해시의 내용에 의존해서는 안됩니다. 내용은 구현 세부 사항이므로!</target>
        </trans-unit>
        <trans-unit id="9f446264c9bfae66320393c5089f48ed5b46e500" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt;, then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da841189af3f04f4eb088d72b96bc951d2d81fc" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">참고 : 많은 사람들이 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 과도하게 사용하는 경향 이 있으며 숫자 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;&quot;&quot;&lt;/code&gt; (길이가 0 인 문자열)가 실제로 정의 된 값이라는 것을 알게되면 놀랍니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">참고 : 많은 사람들이 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 과도하게 사용하는 경향 이 있으며 숫자 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;&quot;&quot;&lt;/code&gt; (길이가 0 인 문자열)가 실제로 정의 된 값이라는 것을 알게되면 놀랍니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">참고 : Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 함수는 초 단위로 측정 된 4 개의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f4979746c04c5a2101a3a8cfcb2e0ca83bb94c8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;times()&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">참고 : 일부 사람들은 구어체로이 문장 부호를 &quot;yada-yada&quot;또는 &quot;triple-dot&quot;라고하지만 실제 이름은 실제로 줄임표입니다.</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">참고 : CPAN에서 다운로드 한 일부 모듈은 NetWare에서 빌드하기 위해 NetWare 관련 API가 필요할 수 있습니다. 그러나 다른 모듈은 모듈 유형에 따라 사소한 변경 여부에 관계없이 매끄럽게 구축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">참고 : 일부 사이트는 DEC의 DFS를 통해 액세스 한 파일에서 파일 액세스 테스트 ( &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; )를 사용할 때 문제점을보고했습니다 . 특히, DFS는 현재 원격 볼륨에있는 파일의 확장 파일 헤더에 대한 액세스를 제공하지 않기 때문에 ACL 검사 시도가 실패하고 파일 테스트는 &lt;code&gt;$!&lt;/code&gt; 파일이 존재하지 않음을 나타냅니다. UIC 기반 보호 만 검사 한 다음 C 컴파일러에서 정의한대로 적절한 비트를 수동으로 검사하므로이 파일에 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31012ee5baab20630d192eb344f3fbf19e1f0ce3" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;stat&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">참고 : 일부 공급 업체는 &lt;code&gt;strtod()&lt;/code&gt; 및 &lt;code&gt;strtol()&lt;/code&gt; 하지만 &lt;code&gt;strtoul()&lt;/code&gt; 하지 않습니다 . &lt;code&gt;strtoul()&lt;/code&gt; 제공하는 다른 공급 업체는 &quot;-1&quot;을 유효한 값으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="09354bfd47c342dd837df1ad765f45f04db5692c" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt;. Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41fee180b1c4bc188eb2c171834172ecd8c3be5" translate="yes" xml:space="preserve">
          <source>Note: The functions with names ending in &lt;code&gt;_at_level&lt;/code&gt; were added in Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">참고 : 반복자 ( &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) 및 파일 테스트 ( &lt;code&gt;'-X'&lt;/code&gt; ) 연산자는 정상적으로 작동합니다. 피연산자가 축복 된 glob 또는 IO 참조가 아닌 경우 문자열로 변환됩니다 ( &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; 또는 &lt;code&gt;'bool'&lt;/code&gt; )은 glob 또는 파일 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e872c50dbea2dd944dd1795cb2d6b5ca0cb3d48d" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt;) and file test (&lt;code&gt;'-X'&lt;/code&gt;) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, or &lt;code&gt;'bool'&lt;/code&gt;) to be interpreted as a glob or filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">참고 : 요청한 라이브러리를로드 할 수 없으면 키워드 'lib'가 경고합니다. 경고를 표시하지 않으려면 대신 'try'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9be19f662c327b39a0c7dc7dd26cac18cf3a2650" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7df03e2ca7476b6f129d5fb49ca21db5f16ee3" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version) can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">참고 :이 목록 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 리턴 현재 perl 및 현재 설치에서 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="79a0d5348f570c35ca9be395234112a023471f03" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;require&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">참고 : 바이트에 맞는 코드 포인트에는 로캘 규칙을 사용하는 정책과 균일하지 않은 코드 포인트에는 유니 코드 규칙을 사용하는 정책이 있습니다. v5.12 이전에는 다소 우연이 있었다. v5.12에서는 대괄호로 묶은 문자 클래스를 제외하고 정규식 일치에 상당히 일관되게 적용되었습니다. v5.14에서는 모든 정규식 일치로 확장되었습니다. v5.16에서는 &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 와 같은 케이싱 작업을 수행 합니다. 데이터 정렬의 경우, 지금까지의 모든 릴리스에서 시스템의 &lt;code&gt;strxfrm()&lt;/code&gt; 함수가 호출되며 그 기능은 무엇이든 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131995001a6829f0723ee9a84a7ecc32cd05fa54" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;uc()&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get. Starting in v5.26, various bugs are fixed with the way perl uses this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">참고 :이 기능은 perl 5.8.3과 함께 릴리스 된 Exporter 버전 5.57에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . &lt;code&gt;U+FFFE&lt;/code&gt; 이외의 다른 문자는 &lt;code&gt;entry&lt;/code&gt; 별로 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="287eea86bd8ed6619f824147ed2c55a69584e9bd" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . &lt;code&gt;U+FFFF&lt;/code&gt; 이외의 다른 문자는 &lt;code&gt;entry&lt;/code&gt; 별로 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fc676f4776bf9d00f6e8ce3ee423f9f2208472e" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">참고 :이 방법은 zlib 1.0.6 이상을 실행중인 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">참고 :이 메소드는 Math :: BigInt 버전 1.78에서 필요했지만 필요한 API 버전 번호가 증가하지 않았으므로 API 버전 1을 지원하지만 &lt;code&gt;_as_oct()&lt;/code&gt; 지원하지 않는 이전 라이브러리가 있습니다. 있습니다.</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">참고 : Math :: BigInt :: GMP가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">참고 : $ FTP_PASSIVE가 true 인 경우 &lt;code&gt;ncftp&lt;/code&gt; 수동 모드는이 바이너리에 대해서만 대화식으로 만 설정할 수 있으므로 는 파일을 가져 오는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">참고 : 목록 컨텍스트에서 호출 될 때 gmtime이 마지막으로 반환 한 $ isdst는 항상 &lt;code&gt;0&lt;/code&gt; 입니다. GMT에는 일광 절약 시간 제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="16d88e8a12adc9d5938fa24b2acb9b6eac47525d" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt;. There is no Daylight Saving Time in GMT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">참고 : &lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; 와 같은 서브 클래스에서도 작동 합니다. 각 클래스에는 Math :: BigInt와 분리 된 자체 전역이 있지만 Math :: BigInt를 서브 클래 싱하고 하위 클래스 별칭의 전역을 Math :: BigInt의 전역으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">참고 : Math :: BigFloat와 같은 서브 클래스에서도 작동합니다. 각 클래스에는 Math :: BigInt와 분리 된 자체 전역이 있지만 Math :: BigInt를 서브 클래 싱하고 하위 클래스 별칭의 전역을 Math :: BigInt의 전역으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">참고 : / ade / lib / perl5 / man / man3 디렉토리에서 맨 페이지를 검색하려면 man.conf 파일을 수정해야합니다. 그렇지 않으면 perl 라이브러리의 맨 페이지를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7379f095d2d22d8a649d49142d79afd3489318b" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">참고 : 아마도 &lt;a href=&quot;#accuracy()&quot;&gt;정확도 ()를&lt;/a&gt; 대신 사용하려고합니다 . 와 &lt;a href=&quot;#accuracy()&quot;&gt;정확성 ()&lt;/a&gt; 당신과 함께, 각각의 결과가 있어야한다 자릿수를 설정 &lt;a href=&quot;#precision()&quot;&gt;() 정밀&lt;/a&gt; 어디 라운드에 장소를 설정!</target>
        </trans-unit>
        <trans-unit id="d6d84b096f34f15c07402e918e2379728ec1301e" translate="yes" xml:space="preserve">
          <source>Note: choosing anyhing but 'yes' for this option will need Devel::DistnameInfo being installed for taking effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;bundling&lt;/code&gt; 을 비활성화하면 &lt;code&gt;bundling_override&lt;/code&gt; 도 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="ec5d46114c3638c4121c26c4c917e18fe48cdbc0" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;bundling_override&lt;/code&gt; 를 비활성화하면 &lt;code&gt;bundling&lt;/code&gt; 도 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2b48dd6d444bef92ae0ebb4e15997ba10818fb" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;ignore_case&lt;/code&gt; 를 비활성화하면 &lt;code&gt;ignore_case_always&lt;/code&gt; 도 비활성화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="57bf189846e7e76bf8482fb5e477ff8f8dfe7b29" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;ignore_case_always&lt;/code&gt; 를 비활성화하면 &lt;code&gt;ignore_case&lt;/code&gt; 도 비활성화 됩니다. .</target>
        </trans-unit>
        <trans-unit id="1946def9c6cdf88287ce6da335562aa361a54824" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;applypatch&lt;/code&gt; 의 프로그램이 설치되어 있고 &lt;code&gt;CPAN::Config&lt;/code&gt; 그것에 대해 알고 &lt;b&gt;및&lt;/b&gt; 패치가에 의해 작성 &lt;code&gt;makepatch&lt;/code&gt; 의 프로그램, 다음 &lt;code&gt;CPAN.pm&lt;/code&gt; 는 할 수 &lt;code&gt;applypatch&lt;/code&gt; 패치를 적용합니다. &lt;code&gt;makepatch&lt;/code&gt; 와 &lt;code&gt;applypatch&lt;/code&gt; 는 모두 CPAN에서 &lt;code&gt;JV/makepatch-*&lt;/code&gt; 배포판으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">참고 : 계산이 비싸거나 해시에 많은 요소가있는 경우 Schwartzian Transform을보고 계산 결과를 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29df041b4a10cf81a3e0b4f7f89bd122aed969f0" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">참고 : 대부분의 경우 특히 &lt;a href=&quot;#Copy-Constructor&quot;&gt;복사 생성자&lt;/a&gt; 는 적절한 동작이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b33df475ae354b7fb1f3b9c4cafb1584ab7a3e6" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">참고 : &lt;code&gt;fallback&lt;/code&gt; 을 FALSE 로 설정하여이 섹션에서 설명 된 동작을 비활성화 할 수 있습니다 ( &lt;a href=&quot;#fallback&quot;&gt;폴백&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="62b2ca1948759ac7f684eceb704736b180023c07" translate="yes" xml:space="preserve">
          <source>Note: the exact nature of the fancy specifications like &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; is subject to change. Advance notice will be given here. The simple specifications like &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; will not change in format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ca88f5d5dc89450fb8556231f6b8efe29797ea" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">참고 : 이전 단락에서는 Perl이 스칼라를 기반으로 객체의 복사 생성자를 자동 생성 할 때 발생하는 상황에 대해 설명합니다. 다른 경우에는 &lt;a href=&quot;#Copy-Constructor&quot;&gt;생성자 복사를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">참고 :이 구성 변수는 더 이상 사용되지 않으며 이후 버전의 CPAN.pm에서 제거됩니다. $ LANG 및 $ LC_ * 환경 변수 패밀리 주위의 규칙으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">참고 :이 기능은 여전히 ​​알파 상태이며 CPAN.pm의 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb52a79f4bb85f30f68ef37f28e8e379caceb4dc" translate="yes" xml:space="preserve">
          <source>Note: this function has not been specified by POSIX since 1990 and is included only for backwards compatibility. New code should use &lt;a href=&quot;perlfunc#getlogin&quot;&gt;&lt;code&gt;getlogin()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">참고 : 이것은 소켓 기능 군에 새로 추가 된 것이므로 모든 시스템이 아직이를 지원하지 않을 수 있습니다. 시스템에서 지원하지 않는 경우이 방법을 사용하면 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">참고 : use_sqlite가 켜져 있고 SQLLite가 실행 중이면이 메커니즘이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">참고 :이 구성 변수 설정 방법은 맨 페이지보다 변수 기능에 대한 자세한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56d243ce60967f77fdfcf106f1d4d7d0a8b3112b" translate="yes" xml:space="preserve">
          <source>Note: using a static or global variable to store the SV isn't thread-safe. You can either use the &lt;code&gt;MY_CXT&lt;/code&gt; mechanism documented in &lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;&quot;Safely Storing Static Data in XS&quot; in perlxs&lt;/a&gt; which is fast, or store the values in perl global variables, using get_sv(), which is much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532592c5b33f1b1b988a3bcb06f60ee822f44348" translate="yes" xml:space="preserve">
          <source>Note: when this field is true, post-configuration prerequisites are not guaranteed to bear any relation whatsoever to those stated in the metadata, and relying on them doing so is an error. See also &lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;&quot;Prerequisites for dynamically configured distributions&quot;&lt;/a&gt; in the implementors' notes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">참고 : gdb 섹션에서 최대 20 개의 변환 바로 가기를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f83b80ea2831e263f522f29c3cbd52e6213eb57" translate="yes" xml:space="preserve">
          <source>Noted explicit support for 'perl' in prerequisites</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8922b61958be2a8d272cbf3db875ad134d3a3576" translate="yes" xml:space="preserve">
          <source>Noted that the &lt;a href=&quot;#distribution_type&quot;&gt;&quot;distribution_type&quot;&lt;/a&gt; field is basically meaningless, and shouldn't really be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03baeca66519780c80b0846ea1bac63e81b58e40" translate="yes" xml:space="preserve">
          <source>Notepad++</source>
          <target state="translated">Notepad++</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Compress :: Zlib 버전 1 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="60a645effd583025acef3ba80266a7c7168ec1f6" translate="yes" xml:space="preserve">
          <source>Notes on 64-bit Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">포드 프로세서 구현에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="8f983f019ad00a2df5935875ac129acc0e4daab6" translate="yes" xml:space="preserve">
          <source>Notes, typically rendered to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">공허한 맥락에는 아무것도 없습니다 (분명히).</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">아무것도 기록되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fb6d9ec5289836c61476dab6f50fac2154944a" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. The following tags can be used to have large sets of symbols exported: &lt;code&gt;&quot;:Func&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt;, &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7b42ab74a17af97a37c506518ea42d6cc1e569" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. You must specify which methods to import, or use the ':ALL' tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2dc97487d39ef5241bb9dbe74fe894c19016958" translate="yes" xml:space="preserve">
          <source>Nothing is exported. Use fully qualified variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">여기서 너무 특이한 것은 없습니다. 사용 가능한 크로스 컴파일러가있는 경우이를 쉽게 수행 할 수 있습니다. Solaris x86을 대상으로 할 때 일반적인 구성 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">아무것도 작동하지 않습니다-죽습니다.</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">또한 개체가 처음 사용 된 줄에 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">&lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; 및 &lt;code&gt;grok_oct&lt;/code&gt; 함수 도 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="49ebd14076be592270a5d4f9b224fa4d4b89d099" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt;, and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">여기서 LEN은 10입니다. (플랫폼에 따라 다를 수 있습니다.) 문자열의 길이를 10 미만으로 확장하고 대체를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">&quot;private&quot;값이 인쇄되는 시점은 없습니다. $ var은 lexical () 함수의 블록 내에서만 해당 값을 가지며 호출 된 서브 루틴에서 숨겨지기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">두 매개 변수를 &lt;code&gt;globmap&lt;/code&gt; 하는 방법에 주목 하십시오. 가 &amp;lt;&amp;gt;로 구분 된 문자열 인 . 이것은 파일 글로브처럼 보이게하기 위해 수행됩니다-그것은 단지 구문 설탕이지만 문자열을 시각적으로 독특하게 만들고 싶을 때 편리 할 수 ​​있습니다. 묶는 &amp;lt;&amp;gt;는 선택 사항이므로 사용할 필요가 없습니다. 실제로 글로브 맵에서 가장 먼저 할 일은 이러한 구분 기호가 있으면 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 생성자 의 반환 값 이 &lt;code&gt;while&lt;/code&gt; 루프 에서 파일 핸들로 어떻게 사용되는지 확인하십시오 . 그게 소위</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">&quot;y&quot;가 발생하자마자 두 번째 대체가 일치하는 것을 중지했습니다. &lt;code&gt;*?&lt;/code&gt; 한정자는 효과적으로 정규식 엔진에 가능한 빨리 일치하는 것을 찾고 핫 포테이토 게임을 할 때와 마찬가지로 다음 라인에 제어를 전달하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">이 (프로토 타입이 지정되지 않은) 함수가 실제 스칼라 또는 배열로 전달되었는지 여부를 신경 쓰지 않는 방법에 주목하십시오. Perl은 모든 인수를 &lt;code&gt;@_&lt;/code&gt; 에서 하나의 크고 길고 평평한 매개 변수 목록으로 간주합니다 . 이것은 Perl의 간단한 인수 전달 스타일이 빛나는 영역입니다. &lt;code&gt;upcase()&lt;/code&gt; 함수는 변경하지 않고 완벽하게 잘 작동합니다 &lt;code&gt;upcase()&lt;/code&gt; 우리는이 같은 물건을 공급하는 경우에도 정의 :</target>
        </trans-unit>
        <trans-unit id="8e53ec417cfc4ffd2c3f588c8323f91d879ae5ac" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt;. This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9d5a5851dd2e8a235f599f76ec00c3eeb19104" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;&quot;*&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">&quot;hello&quot;는 Perl이 가장 바깥 쪽 &lt;code&gt;(?:)*&lt;/code&gt; :) * 의 여섯 번째 반복이 길이가 0 인 문자열과 일치하는 것을 볼 때 &lt;code&gt;*&lt;/code&gt; 를 중지하므로 한 번만 인쇄 됩니다 .</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">알 &lt;code&gt;Dump()&lt;/code&gt; , 상기 코드 (13)를 통해서만 소자 (10)를 출력한다. 다음 코드는 모든 요소를 ​​인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">파일 글로브 패턴 &lt;code&gt;*.tar.gz&lt;/code&gt; 가 &lt;code&gt;.tar.gz&lt;/code&gt; 파일 과 일치하는 데 사용 된 후 새 파일 이름을 작성할 수 있도록 대체적으로 유사한 정규식이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">기본 계층이없는 경우 입력시 변환을 수행하지 않는 기본 동작으로 인해 데이터를 반복적으로 인코딩하여 파일 확장을 유지하는 코드를 실수로 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 메소드가 사용 된 두 번 레코드 색인은 리터럴 값 자체가 아닌 &lt;code&gt;$i&lt;/code&gt; 변수를 사용하여 지정 되었습니다. &lt;code&gt;put&lt;/code&gt; 은 해당 매개 변수를 통해 삽입 된 행의 레코드 번호를 반환 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f8652fa23a6a85d8694e8c330d3634e47750ae09" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt;, rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">이 새로운 테스트 사례에서 round에 전달 된 인수는 스칼라 변수였습니다. 상수 또는 리터럴을 반올림 할 수 있는지 궁금 할 것입니다. 어떻게되는지 확인하려면 Mytest.t에 다음 줄을 임시로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">변수 &lt;code&gt;ax&lt;/code&gt; 를 정의해야합니다 . &lt;code&gt;ST&lt;/code&gt; 매크로가 존재하기를 기대 하기 때문 입니다. 우리가 XSUB에 있다면 &lt;code&gt;ax&lt;/code&gt; 는 이미 정의되어 있으므로 ax 를 정의 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="785ded97619f1dd92d03821ef64bfb7475388f4f" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt;. This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a57f1413b4aba3b4429663d2d0603ce91191839" translate="yes" xml:space="preserve">
          <source>Notice that most of the metacharacters lose their special meaning when they occur in a bracketed character class, except &lt;code&gt;&quot;^&quot;&lt;/code&gt; has a different meaning when it is at the beginning of such a class. And &lt;code&gt;&quot;-&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt; are metacharacters only at restricted positions within bracketed character classes; while &lt;code&gt;&quot;}&quot;&lt;/code&gt; is a metacharacter only when closing a special construct started by &lt;code&gt;&quot;{&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">레거시 코드 포인트 만있는 리터럴 (문자열 또는 정규식) 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">코어 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 이 잘리지 않고 반올림 될 수 있습니다. 이것이 의미하는 바는 핵심 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;gettimeofday()&lt;/code&gt; 및 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 보다 1 초 늦게 시간을보고 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="786dfe37f34edb4a05a168a69eef1c7edef1b6b6" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;time()&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;time()&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">최종 일치 는 &lt;code&gt;p&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 와 일치 하며 &lt;code&gt;\G&lt;/code&gt; 앵커가 없는 일치 는 수행합니다. 또한 최종 경기는 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 를 업데이트하지 않았습니다 . &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;/g&lt;/code&gt; 일치 에서만 업데이트됩니다 . 마지막 경기가 실제로 &lt;code&gt;p&lt;/code&gt; 와 일치했다면 아주 오래된 (-5.6.0 이전) 버전의 Perl을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6288f2ae31ab09194ff1161b00b4b9878a3f7850" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;q&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt;, which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;pos&lt;/code&gt;. &lt;code&gt;pos&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt;, it's a good bet that you're running an ancient (pre-5.6.0) version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">외부 괄호 유형이 변경되었으므로 액세스 구문도 변경되었습니다. C와 달리 펄에서는 배열과 참조를 자유롭게 교환 할 수 없기 때문입니다. $ ref_to_AoA는 배열에 대한 참조 인 반면 @AoA는 적절한 배열입니다. 마찬가지로 &lt;code&gt;$AoA[2]&lt;/code&gt; 는 배열이 아니라 배열 참조입니다. 그래서 어떻게 쓸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">프로그래머는 실제 rpcb_gettime () 함수를 호출하고 리턴 값을 인수 스택에 올바르게 배치하는 데 필요한 C 코드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">평평한 세계지도를 보면 결과 방향이 다소 놀랍습니다. 그러한지도 투영에서 큰 원은 가장 짧은 경로처럼 보이지 않지만 유럽이나 북미에서 아시아까지 가능한 가장 짧은 경로처럼 보입니다. 종종 극지방을 교차합니다. 일반적인 Mercator 투영은 큰 원을 직선으로 표시 하지 &lt;b&gt;않습니다&lt;/b&gt; . Mercator 투영의 직선은 일정한 베어링 선입니다.</target>
        </trans-unit>
        <trans-unit id="f84d61c644ea07e321b7e96f57efe6473acd064c" translate="yes" xml:space="preserve">
          <source>Notice that the standard utility methods of &lt;code&gt;Locale::Maketext&lt;/code&gt; are irremediably limited because they could not aim to do everything that could be expected from them in different languages, cultures and applications. So extending &lt;code&gt;numf&lt;/code&gt;, &lt;code&gt;quant&lt;/code&gt;, and &lt;code&gt;sprintf&lt;/code&gt; is natural as soon as your needs exceed what the standard ones do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">이는 &lt;code&gt;display_format&lt;/code&gt; 메소드 의 반환 값에도 영향을 미칩니다 . 목록 컨텍스트에서 전체 매개 변수 해시가 반환됩니다 (스타일 매개 변수 값만 반대). 목록 컨텍스트에서 &lt;code&gt;display_format&lt;/code&gt; 메소드를 호출 한 경우 이전 버전과의 비 호환 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">이 예는 참조 횟수면에서만 이전 예와 다릅니다. 우리는 덤프 다음 예,이 비교 &lt;code&gt;$b&lt;/code&gt; 대신 &lt;code&gt;$a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5817d7016f97dd4bc8025a72366ab7b19c39f5b7" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">우리는 &lt;code&gt;env&lt;/code&gt; 포인터를 사용하지 않습니다 . 일반적으로 최종 인수 로 &lt;code&gt;perl_parse&lt;/code&gt; 를 전달하면 &lt;code&gt;env&lt;/code&gt; here는 &lt;code&gt;NULL&lt;/code&gt; 로 대체 되므로 현재 환경이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="930214e71214bfe57e424495f1f5252084b336e6" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt;, which means that the current environment will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">알 때 &lt;code&gt;$z&lt;/code&gt; 아닌 0 &lt;code&gt;$rho_c&lt;/code&gt; 동일하지 &lt;code&gt;$rho_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a5cef6aa9527100171d0d0994226a5b838b3bc" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">알 때 &lt;code&gt;$z&lt;/code&gt; 아닌 0 &lt;code&gt;$rho_s&lt;/code&gt; 동일하지 &lt;code&gt;$rho_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01c82dfb0bcf881d438ecf1364082366f27c8820" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">당신은 문자열의 길이를 지정하기 위해 선택할 수있는 사항은 사용하여 할당 할 &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , 또는 &lt;code&gt;newSVpv&lt;/code&gt; 을 하거나 펄을 사용하여 길이를 계산할 수 있습니다 &lt;code&gt;sv_setpv&lt;/code&gt; 을 나에게 두 번째 인수로 0을 지정하여 &lt;code&gt;newSVpv&lt;/code&gt; . 그러나 Perl은 &lt;code&gt;strlen&lt;/code&gt; 을 사용하여 문자열 길이를 결정할 것입니다. strlen 을 사용 하면 문자열이 &lt;code&gt;NUL&lt;/code&gt; 문자로 끝나고 NUL을 포함하지 않는 문자열에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="8388abb49037aa7a9750fb22bcb53bb337bbb687" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt;, &lt;code&gt;newSVpvn&lt;/code&gt;, or &lt;code&gt;newSVpv&lt;/code&gt;, or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt;. Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt;, which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">통지 &lt;code&gt;OBJECT&lt;/code&gt; 의 속성을. MakeMaker는 다음 변수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">차리는 &lt;code&gt;_&lt;/code&gt; 위에서 &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; 다음은 &lt;code&gt;_&lt;/code&gt; 앞의 정보 캐시 마법 핸들이다 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; , 또는 파일 테스트한다.</target>
        </trans-unit>
        <trans-unit id="3649b7d5b5ec60ffba14ae21c7b1c2a9a411dd9a" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;int(-M _)&lt;/code&gt;: the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;lstat()&lt;/code&gt;, or filetest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memcpy&lt;/code&gt; 및 &lt;code&gt;memmove&lt;/code&gt; 에 사용 된 것과는 다른 &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Move&lt;/code&gt; 인수 순서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cfb16d57b3fc1899ca35729db416deb1a5fcf6d" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">마지막 두 개에 주목하십시오. undef 값이지만 정의 된 키가 있습니다!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">&quot;XXXXX&quot;로 주석 처리 된 두 줄에 주목하십시오. typemap 파일 (또는 섹션)의 첫 번째 부분을 확인하면 double이 T_DOUBLE 유형임을 알 수 있습니다. 타입 맵의 INPUT 부분에서 T_DOUBLE 인 인수는 루틴 SvNV를 호출하여 변수 arg에 할당 한 다음이를 double로 캐스팅 한 다음 변수 arg에 할당합니다. 마찬가지로, OUTPUT 섹션에서 arg가 최종 값을 갖 으면 sv_setnv 함수로 전달되어 호출 서브 루틴으로 다시 전달됩니다. 이 두 기능은 &lt;a href=&quot;perlguts&quot;&gt;perlguts에&lt;/a&gt; 설명되어 있습니다 . 나중에 인수 스택 섹션에서 &quot;ST (0)&quot;의 의미에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">두 번째 매개 변수로 GV_ADD를 사용하십시오. 이제 데이터 유형에 적합한 루틴을 사용하여 새 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">이 예제에서 공백을 확인하십시오. 이 구문에는 항상 &lt;code&gt;/x&lt;/code&gt; 수정자가 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="319e2b5eaf07860409d97b11c5611e8f5cc65281" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/xx&lt;/code&gt; modifier turned on within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd6270a12f8b7eb8c9c200a3723ca7a45c46729" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">&lt;code&gt;Perl_pp_add&lt;/code&gt; 가 아닌 &lt;code&gt;pp_add&lt;/code&gt; 사용하는 것에 주목 하십시오 . &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts의 내부 함수를보십시오&lt;/a&gt; . 중단 점이 있으면 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49e7942c0e9764eb733db50ae6c6f21e34cbe873" translate="yes" xml:space="preserve">
          <source>Notify an according IPv6 MTU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">알림은 DSN (배달 상태 알림)을 요청하는 데 사용되지만 SMTP / ESMTP 서비스는 버전 및 사이트의 SMTP 구성에 따라이 요청을 존중하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">주어진 모든 주소로 현재 메시지를 보내야한다는 것을 서버에 알립니다. 각 주소는 별도의 명령으로 서버에 전송됩니다. 주소를 보내면 오류가 발생하면 프로세스가 중단되고</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare는 File :: Spec :: Win32에서 File :: Spec 동작을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="f596d3f268eaea786d51ab55e3200ab8fc6af9a4" translate="yes" xml:space="preserve">
          <source>November 13, 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ef706a9203ebb1532a39a12c049758f080c8c3" translate="yes" xml:space="preserve">
          <source>November 16, 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0d9da26bf041d32a0675226f59b963b86e2fb7" translate="yes" xml:space="preserve">
          <source>November 2006</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">2007 년 11 월; 크리스토프 그로스 jean (CChristophe Grosjean) : cmpthese와 timestr이 스타일 인수와 일관되게 시간을 계산하도록하고, 기본값은 더 이상 'noc'가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">이제 &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; 은 항상 $ n을 더한 값에 20을 더한 반면 $ f2- &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; 은 항상 555를 더한 값에 $ n을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; 사용하면 상수 정규 표현식, 즉 런타임 변수 보간이없는 정규 표현식에서 새 이스케이프를 &lt;a href=&quot;functions/use&quot;&gt;사용할&lt;/a&gt; 수 있습니다. &lt;a href=&quot;overload&quot;&gt;overload에&lt;/a&gt; 설명되어 있듯이이 변환은 정규 표현식의 리터럴 부분에서만 작동합니다. 에 대한 &lt;code&gt;\Y|$re\Y|&lt;/code&gt; 이 정규 표현식의 변수 부분은 명시 적으로 변환되어야합니다 (그러나 &lt;code&gt;\Y|&lt;/code&gt; 의 특별한 의미가 $ re 내에서 활성화되어야 하는 경우에만 ).</target>
        </trans-unit>
        <trans-unit id="fade66a80437ba60181e3ddce42855f68a77521c" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;use customre&lt;/code&gt; enables the new escape in constant regular expressions,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01a23641a218b7388c86b594decd3175ef90f36" translate="yes" xml:space="preserve">
          <source>Now I can run my tests like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">이제 C 프로그램을 만들겠습니다.</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">이제 모든 다른 기능들이 독립적으로 존재하는 것으로 보입니다. red (), RED (), blue (), BLUE (), green () 등을 호출 할 수 있습니다.이 기술은 컴파일 시간과 메모리 사용을 절약하고 구문 검사가 발생하기 때문에 오류가 덜 발생합니다. 컴파일 시간. 익명 서브 루틴의 변수는 적절한 클로저를 작성하기 위해 어휘이어야합니다. 그것이 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 이유입니다 on 루프 반복 변수 .</target>
        </trans-unit>
        <trans-unit id="fabedd5297cac1df38e4fa79abf11492e74b2a01" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;my&lt;/code&gt; on the loop iteration variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">이제 당신이해야 할 일은 확인입니다.</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">이제 G_EVAL을 사용하는 예입니다. 아래는 2 개의 매개 변수의 차이를 계산하는 Perl 서브 루틴입니다. 이것이 부정적인 결과를 초래하면, 서브 루틴 호출</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">현재 Neil Bowers가 관리하고 있습니다 &amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">이제 몇 줄에 즉석 객체를 만듭니다 (백 슬래시 참고).</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">이제 Perl 서브 루틴을 대신 호출하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">이제 여부를 확인 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; 일부 사실이다 &lt;code&gt;$n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a01ad64127827e39a88ed3009004d810d71655" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;vec($read,$n,1)&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">이제 영리한 비트가 온다. 다만 소득과 우리의 원장 라인하지 지출, 우리가 말하고 싶어하지 않는 따라서 열 (46)에 끝낼 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 우리가 그 패턴을 &lt;b&gt;필요로&lt;/b&gt; 또 다른 12 개 문자를 찾기 위해; 그냥 &quot;남은 것이 있으면 가져 가라&quot;고 말할 것입니다. 정규 표현식에서 짐작할 수 있듯이 &lt;code&gt;*&lt;/code&gt; 는 &quot;남은 모든 것을 사용하십시오&quot;라는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="2aed8f2583a2025408738c1655ec69d76cbf4265" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;unpack&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3043847bd2200864abd83a13618a02dee8ec6266" translate="yes" xml:space="preserve">
          <source>Now commit your change locally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">이제이 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">이제 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">이제 지수가있는 부동 소수점 숫자를 고려하십시오. 여기서 중요한 것은</target>
        </trans-unit>
        <trans-unit id="6e69790285fa3d81bdaeedc9a045cae201d21c12" translate="yes" xml:space="preserve">
          <source>Now consider what the code looks like without &lt;code&gt;InputLength&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">이제 Mytest2.t 스크립트를 편집하고 테스트 수를 &quot;4&quot;로 변경하고 스크립트 끝에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">이제 Perl 서브 루틴에서 리턴 된 항목을 다루는 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">더 복잡한 무언가를 위해 : &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">$ 바즈이 같은 과부하되면 이제 다음 &lt;code&gt;$baz&lt;/code&gt; 실제 배열에 대한 참조를 유지 중간 어레이, 및 상기 액세스 해시 참조에 대한 참조이다. 액세스 해시의 tie () 객체는 실제 배열에 대한 참조에 대한 참조이므로</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">문자열의 시작 부분에 &lt;code&gt;U&lt;/code&gt; 가 표시 되면 출력 SV &lt;code&gt;cat&lt;/code&gt; 에 대해 &lt;code&gt;UTF8&lt;/code&gt; 플래그를 켭니다 .</target>
        </trans-unit>
        <trans-unit id="5914acd073f333e4c23a4d84f2aa14b4552e8013" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">이제 익명 서브 루틴의 임시 할당으로 인해 inner ()는 outer () 내에서만 호출 할 수 있습니다. 그러나 그렇게하면 outer가 호출 될 때 outer ()의 범위에서 어휘 변수 $ x에 정상적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">이제 정적으로 링크 된 실행 파일을 빌드 할 때입니다</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">이제 모든 Perl Mongers가 좋아하는 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="5afbbbcc6562eb3dd44ab3aeee5e6e877aac172d" translate="yes" xml:space="preserve">
          <source>Now it always returns &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">이제는 2 차원 배열처럼 보입니다!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">이제 데이터 구조를 인쇄 할 차례입니다. 어떻게 하시겠습니까? 글쎄, 당신이 요소 중 하나만 원한다면 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">이제 합법적 인 Perl 코드를 입력하면 즉시 평가됩니다. 또한 심볼 테이블을 검사하고, 스택 역 추적을 얻고, 변수 값을 확인하고, 중단 점을 설정하고, 일반적으로 심볼릭 디버거에서 발견되는 기타 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">이제 확장에 단일 숫자 인수를 입력으로 사용하고 숫자가 짝수이면 1을 리턴하고 숫자가 홀수이면 0을 리턴하는 서브 루틴을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">이제 쇼를 계속하자!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">이제 &lt;code&gt;pp_pack&lt;/code&gt; 을 살펴 봅시다 : 패턴을 &lt;code&gt;pat&lt;/code&gt; 에 넣은 다음 패턴을 반복하여 각 형식 문자를 &lt;code&gt;datum_type&lt;/code&gt; 으로 바꿉니다 . 그런 다음 가능한 각 형식 문자에 대해 패턴의 다른 인수 (필드 너비, 별표 등)를 삼켜 다음 청크 입력을 지정된 형식으로 변환하여 출력 SV &lt;code&gt;cat&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="72fe90f904deeeb9bda4270aff1109f958440f65" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt;: we take a pattern into &lt;code&gt;pat&lt;/code&gt;, and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt;. Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">이제 좀 더 복잡한 예를 만들어 봅시다. 이번에는 Perl 서브 루틴 &lt;code&gt;LeftString&lt;/code&gt; 을 호출하려고합니다. 이 문자열에는 문자열 ($ s)과 정수 ($ n)의 두 가지 매개 변수가 사용됩니다. 서브 루틴은 단순히 문자열의 첫 $ n 문자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a1cd28db828b3965b5fb8cb34a20f3c4db616851" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt;, which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf057ced369b422ce2c543343cfe6f097b71cc60" translate="yes" xml:space="preserve">
          <source>Now let's see what happens when you try to decode from ISO-2022-JP and the buffer ends in the middle of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">이제 더 어려운 패턴을 시도해 봅시다. 우리는 한정자를 추가 할 것이므로, 이제 &lt;code&gt;/foo+/&lt;/code&gt; 패턴이 있습니다. &lt;code&gt;regbranch()&lt;/code&gt; 가 &lt;code&gt;regpiece()&lt;/code&gt; 두 번 호출 한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="364c0b15409d7672a94bf5ecd988b5c8a1f0315d" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt;. We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cb79a776cb969edc30e88cc6131bd19fb97fb3" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl 5 Porters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">이제 Perl5 Porters가 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">이제 $ c의 숫자 값은 5입니다. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; $ c의 숫자 값은 13이됩니다. 모듈의 사용자를 격리시키기 위해 메소드를 추가하십시오</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">이제 배열과 해시 구문을 모두 사용하여 객체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">이제 스크립트의 마지막 줄을</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">이제 스크립트를 완성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">이제 이전과 동일한 단계를 수행하고 Makefile.PL 파일에서 Makefile을 생성하고 make를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">이제 프로세스 &quot;A&quot;는 데이터베이스를 업데이트하고 초기 버퍼에 보유 된 일부 데이터를 변경합니다. &quot;A&quot;프로세스가 종료되어 캐시 된 모든 데이터를 디스크로 플러시하고 데이터베이스 잠금을 해제합니다. 이 시점에서 디스크의 데이터베이스는 프로세스 &quot;A&quot;의 변경 사항을 올바르게 반영합니다.</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">이제 make를 다시 실행하여 새 공유 라이브러리를 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">이제 실행</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">이제 최상위 Makefile.PL에서 perl을 실행하십시오. 또한 mylib 디렉토리에 Makefile을 작성했습니다. make를 실행하고 mylib 디렉토리로 cd하고 make도 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">이제 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">이제 하나 이상의 인터프리터 인스턴스가 동시에 실행되고 있다고 가정합니다. 이것은 가능하지만 perl을 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 할 때 Configure 옵션 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 또는 -Dusethreads -Duseithreads 옵션을 사용한 경우에만 가능합니다 . 기본적으로 이러한 구성 옵션 중 하나를 사용하면 인터프리터 당 글로벌 변수 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 설정하여 철저한 정리가 자동으로 수행되고 인터프리터 변수가 올바르게 초기화됩니다. 두 개 이상의 인터프리터를 동시에 실행하지 않으려는 경우에도 위의 예와 같이 순차적으로 실행하려면 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 를 사용하여 perl을 빌드하는 것이 좋습니다. 그렇지 않으면 연속 실행간에 일부 인터프리터 변수가 올바르게 초기화되지 않아 응용 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1903abcbcbb8a74636f09d2f5f2bcae4b5c5eed" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49fb62e1176de7722979d95af388dc41f0ee3b3" translate="yes" xml:space="preserve">
          <source>Now switch back to blead and merge your smoke-me branch into it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">이제 현재 디렉토리를 살펴보십시오. 이렇게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="bee8b14e16d518df0acbce192d7aea4caa41e326" translate="yes" xml:space="preserve">
          <source>Now that I know how to subclass and replace TAP::Harness I can replace any other part of the harness. To do that I need to know which classes are responsible for which functionality. Here's a brief guided tour; the default class for each component is shown in parentheses. Normally any replacements I write will be subclasses of these default classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">이제 풀어가 존재하는 클래스 디자이너는 급 기능의 일부가 정말과 관련된 결정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 과 개체와 파괴되고있다. 주어진 클래스에 적합한 것은 내부 참조가 유지되는지 여부에 따라 넥타이와 관련되지 않은 메소드가 오브젝트에서 호출 될 수 있습니다. 그러나 대부분의 경우 DESTROY에 있었던 기능을 UNTIE 방법으로 옮기는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7a99ac155b6f06ce4dfb04db2128fc497e50d4a6" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;untie&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">이제 기본 require () 및 서브 루틴이 테스트되었으므로</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">&quot;기본&quot;메커니즘이 &lt;code&gt;Sys::Syslog&lt;/code&gt; 지원되고 기본적으로 선택 &lt;code&gt;setlogsock()&lt;/code&gt; 다른 메커니즘은 운영 체제에서 이식성이 떨어지기 때문에 setlogsock () 함수를 사용하지 않는 것이 좋습니다. 이 기능을 사용하는 모듈 및 프로그램, 특히화물 컬트 형식 &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; 의 작성자 는 특정 메커니즘 (예 : TCP 또는 UDP 등을 사용하여 원격에 연결하지 않는 한)에서 발생을 제거하는 것이 좋습니다. 주최자).</target>
        </trans-unit>
        <trans-unit id="d6e5bb6ea11f530904bdc5de7317a278720bcd2a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt;, are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">이제 Perl의 핵심을 &lt;a href=&quot;test/more&quot;&gt;테스트 했으므로 Test :: More를&lt;/a&gt; 사용할 수 있고 사용해야합니다. 테스트에서 전체 핵심 모듈 제품군을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ff55bc098331b9dd0a021350302b6152b1136b" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">스택에 공간이 &lt;code&gt;PUSHs&lt;/code&gt; 매크로를 사용하여 값을 푸시 할 수 있습니다 . 푸시 된 값은 종종 &quot;치명적&quot;이어야합니다 ( &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;참조 횟수 및 사망률 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="db9f415821b5ff335d6377b90972d196cfedc3a0" translate="yes" xml:space="preserve">
          <source>Now that we have everything up to date, we need to create a temporary new branch for these changes and switch into it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">이제 직장에서 &lt;code&gt;P&lt;/code&gt; 를 보았 으므로 &lt;code&gt;p&lt;/code&gt; 에 소용돌이를 줄 수도 있습니다 . 포인터를 패킹하기 위해 두 번째 템플릿 코드가 필요한 이유는 무엇입니까? 답은 &lt;code&gt;p&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 가 버퍼에서 가져온 주소에서 시작하여 null로 끝나는 문자열을 약속하며 데이터 항목이 반환되는 길이를 암시한다는 간단한 사실 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="845be3729f8e1471aa9c19871b5191d2af6f12bb" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">이제 우리는 &lt;code&gt;*foo{THING}&lt;/code&gt; 표기법 을 가지므로 , typeglobs는 여전히 새로운 파일과 디렉토리 핸들을 함수 안팎으로 전달해야하지만 파일 핸들 조작에 많이 사용되지는 않습니다. HANDLE이 이미 핸들로 사용 된 경우에만 &lt;code&gt;*HANDLE{IO}&lt;/code&gt; 작동 하기 때문 입니다. 다시 말해, &lt;code&gt;*FH&lt;/code&gt; 를 사용하여 새 기호 테이블 항목을 작성해야합니다. &lt;code&gt;*foo{THING}&lt;/code&gt; 은 할 수 없습니다. &lt;code&gt;*FH&lt;/code&gt; 경우 * FH를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f7be970c41cd87a6fd574ed69a37113f5eb82d1" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">이 패턴을 편리한 문자열로 저장 했으므로 다른 패턴의 일부로 사용하려는 유혹을 느낄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29c91f0a31611481726db8f6cd5987db898348a" translate="yes" xml:space="preserve">
          <source>Now that we know the two token types we want to look for in the parser, let's take the piece of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">이제 스레드의 기본 사항을 다루었으므로 이제 다음 주제 인 데이터를 살펴 보겠습니다. 스레딩은 스레드가 아닌 프로그램이 걱정할 필요가없는 데이터 액세스에 몇 가지 복잡한 문제를 야기합니다.</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">이제 문제가 무엇인지 알았으므로이를 피하기 위해 무엇을 할 수 있습니까? 선택적 UNTIE 방법을 도입하기 전에 유일한 유일한 방법은 good old &lt;code&gt;-w&lt;/code&gt; 플래그였습니다. untie ()를 호출하고 연결된 객체에 대한 유효한 참조가 여전히 존재하는 인스턴스를 발견합니다. 만약 근처에서이 위의 두 번째 스크립트 상단 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; 또는 실행 된 &lt;code&gt;-w&lt;/code&gt; 플래그, 펄이 경고 메시지를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="9771972202eb1f3782008cf8f55ca4ed0bc679ec" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;use warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c455331af53bbe930455abd94381aad022a312" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">bare 인수로 파일을 찾는 방법이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하다는 것을 이해 했으므로 배경 뒤에 약간의 추가 기능이 있습니다. 전에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; &quot;A의 모습을</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">bare 인수로 파일을 찾는 방법이 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하다는 것을 이해 했으므로 배경 뒤에 약간의 추가 기능이 있습니다. 전에 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; &quot;A의 모습을</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">이제 명령 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b566ef89971d6ba2da0e75e174d6b74566a53f9" translate="yes" xml:space="preserve">
          <source>Now the contents of the zip file looks like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@animals&lt;/code&gt; 의 요소가 단순히 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 목록의 일부가되기 때문에 출력에 요소 사이에 공백이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f6712df82bd0b409fccf382c7eb4775322c433e9" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">이제 출력은 &lt;code&gt;foo&lt;/code&gt; 가 호출자로부터 &lt;code&gt;@_&lt;/code&gt; 를 얻지 못함을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">이제 파싱 단계가 완료되었으며 완성 된 트리는 Perl 인터프리터가 프로그램을 실행하기 위해 수행해야하는 작업을 나타냅니다. 다음으로 Perl은 트리에서 드라 이런을 수행하여 최적화를 찾습니다. 이제 &lt;code&gt;3 + 4&lt;/code&gt; 와 같은 상수 표현식 이 계산되고 옵티마이 저는 여러 연산이 단일 연산으로 대체 될 수 있는지 확인합니다. 예를 들어, 변수 &lt;code&gt;$foo&lt;/code&gt; 를 가져 오기 위해 glob &lt;code&gt;*foo&lt;/code&gt; 를 잡고 스칼라 구성 요소를 보는 대신 옵티마이 저는 op 트리를 피킹하여 해당 스칼라를 직접 찾는 함수를 사용합니다. 주요 최적화는 &lt;code&gt;peep&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="81df9ba059e2ff0a47a803c9c1c7ea076906b2e7" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt;, instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">이제 rpcb_gettime () 함수를 다음 명령문으로 Perl에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">이제 생각 해봐</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">이제 Perl 파서와 개별 파일 간의 각 논리적 연결을</target>
        </trans-unit>
        <trans-unit id="c36ab80c850235a2a6535979a5e221cbafe139d7" translate="yes" xml:space="preserve">
          <source>Now to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">이제 입력</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">이제 기본 Perl이 &lt;code&gt;const char *&lt;/code&gt; 유형을 지원하지 않기 때문에 타입 맵을 만들어야합니다 . 위 함수 전에 XS 코드에 새로운 TYPEMAP 섹션을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">이제 첫 번째 ($ 키) 변수를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8697ceaf2dd16f4d4adec9ebfeb7ec483f31a8a6" translate="yes" xml:space="preserve">
          <source>Now we can inspect the change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">이제 'a'와 't'를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6585115684561f6afa96412beafcc752dc7c11" translate="yes" xml:space="preserve">
          <source>Now we can test bunches of dates by just adding them to &lt;code&gt;%ICal_Dates&lt;/code&gt;. Now that it's less work to test with more dates, you'll be inclined to just throw more in as you think of them. Only problem is, every time we add to that we have to keep adjusting the &lt;code&gt;use Test::More tests =&amp;gt; ##&lt;/code&gt; line. That can rapidly get annoying. There are ways to make this work better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">이제 다른 내장 함수와 마찬가지로 서브 루틴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">이제 특별한 경우가 있습니다. &lt;code&gt;EXACT&lt;/code&gt; regop는이 &lt;code&gt;regnext&lt;/code&gt; 일치하는 경우 다시 자신을 일치하도록 시도해야하기 때문입니다 0의를. &lt;code&gt;PLUS&lt;/code&gt; 의 regop는 실제 고장 처리 &lt;code&gt;EXACT&lt;/code&gt; regop를 적절히 작용합니다 (이 경우 6 regnode가는 &lt;code&gt;EXACT&lt;/code&gt; 번 적어도 일치하거나, 그렇지 않다면 실패).</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">이제 스크립트 실행 파일 ( &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ) 을 만들고 스크립트를 실행 하면 다음 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="612f354eccf60522636de9e810f79a1b463240fa" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;chmod +x hello&lt;/code&gt;), run the script and we should see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">이제 Perl에 명령 행 옵션을 전달하고 다음과 같이 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ddfe38df65672eb8cb8bb6b4c2a3925df733b91b" translate="yes" xml:space="preserve">
          <source>Now we read that file in paragraph mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">이제 다른 캐릭터를 건너 뛰고 다음 7 개의 캐릭터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">이제 우리는 서브 루틴으로 계속 진행할 것입니다. 이번에는 줄 번호가 아닌 서브 루틴 이름을 사용하고 그 다음에 익숙한 'v'를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">이제 &quot; &lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;을 실행하겠습니다 . 이렇게하면 실제 Makefile이 만들어져 필요합니다. 출력 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35f5a06d15d5037b074e44b9f8538d07cbd8815f" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt;&quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">이제 우리는 우리가 시작한 우주 사업을 올바르게 수행했는지 테스트 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">이제 우리는 마침내 갈 준비가되었습니다 : 우리는 Perl 바이트 코드를 컴파일했고 남은 것은 그것을 실행하는 것입니다. 실제 실행은 &lt;code&gt;runops_standard&lt;/code&gt; 함수에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">이제 실행할 때 perl은 선언되지 않은 3 개의 변수에 대해 불평하고 하나의 변수가 두 번 참조되므로 4 개의 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd8037c01a5003f5b294e5c2293670a0337f93e2" translate="yes" xml:space="preserve">
          <source>Now when you run, it's a little different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">이제 새 행을 추가 할 수 있습니다. 새 열을 추가하는 것은 어떻습니까? 행렬 만 다루는 경우 간단한 할당을 사용하는 것이 가장 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">이제 &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; 여부를 확인할 수 있습니다 . 처음에는 파란색을 모두 해시로 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="13e8faf4edbb7badf8e22509c8ca447a6e463db3" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt;. It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
