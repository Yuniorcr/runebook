<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">이제 Perl을 컴파일 할 수 있습니다. 유형:</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">이제 바이너리 배포판을 생성 할 수 있습니다. 이는 CPAN 분배 &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; 테스트를 실행하여 수행됩니다 . 파일 조정</target>
        </trans-unit>
        <trans-unit id="93e496fadabb1e64e6e7d67223c19456b5dbe7c9" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt;. Tune up the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">이제 파일 이름을 바꿀 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">이제 다음 (SDF) 명령으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fdb47077c25bbc7fd05ea6699ff777a03b6a0b4" translate="yes" xml:space="preserve">
          <source>Now you can switch back to blead locally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">이제 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 중 하나를 사용하여 해당 파일 핸들에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dad49068c95ec062280fac9c3dcad77dc06ce94c" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">이제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">이제 &lt;code&gt;$PI&lt;/code&gt; 변경할 수 없습니다. 아마도 좋은 일입니다. 이것은 상수 서브 루틴과 같지 않으며 컴파일 타임에 최적화됩니다. 상수 서브 루틴은 인수를 취하지 않고 상수 표현식을 리턴하도록 프로토 타입 된 것입니다. &lt;a href=&quot;perlsub&quot;&gt;이에&lt;/a&gt; 대한 자세한 내용 은 perlsub 를 참조하십시오 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma는 이러한 편리한 속기이다.</target>
        </trans-unit>
        <trans-unit id="c97546944079cddc1746ac13882c5e6cfa5ab3f9" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt;, which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;use constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">이제 $ is_tiny_prime [$ some_number]인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">이제 필요한 모든 것이 있습니다</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">이제 전체 POD 문서를 하나의 큰 파싱 트리로 만들었습니다. &lt;b&gt;-expand_seq&lt;/b&gt; 옵션을 사용하여 완전히 다른 종류의 객체를 삽입 하기 위해 &lt;b&gt;parse_text&lt;/b&gt; 를 사용할 수도 있습니다 . &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 그 이후에 그들과 어떻게해야할지 알 필요는 없습니다 . 그것은 당신의 코드에 있어야합니다. 또는 &lt;b&gt;Pod :: ParseTree&lt;/b&gt; 인터페이스를 준수하는 한 원하는 객체를 삽입 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">이제 해당 핸들에서 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 와 같은 함수를 사용할 수 있습니다 . 아마도 가장 일반적인 입력 기능은 연산자처럼 보이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="367c47e849864052497095e9f7fa487dd90eceb2" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;getc&lt;/code&gt;, and &lt;code&gt;sysread&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">이제 외부 브래킷 유형이 둥근 유형, 즉 괄호가되도록 매우주의해야합니다. @array에 할당하기 때문에 괄호가 필요합니다. 당신이 원한다면</target>
        </trans-unit>
        <trans-unit id="d66b8a1ad54810e72ec52858762c88f3380e16c6" translate="yes" xml:space="preserve">
          <source>Now you'll see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">이제 빌드 할 준비가되었습니다 :</target>
        </trans-unit>
        <trans-unit id="cb48a5248ec746855c13f0d7ab0feb804820903a" translate="yes" xml:space="preserve">
          <source>Now you're ready to run &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">이제 IO는 ASCII 파티션의 ASCII이고 EBCDIC 파티션의 EBCDIC입니다. 추가 가능성 은 PerlIO 설명서 ( &lt;code&gt;Encode::&lt;/code&gt; ! 제외)를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b95b8f4eb02584fba76319179b45221c640f17c" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt;!) for further possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">이제 &lt;code&gt;-h24&lt;/code&gt; 는 옵션 &lt;code&gt;h&lt;/code&gt; 를 &lt;code&gt;24&lt;/code&gt; 로 설정하지만 &lt;code&gt;-vxa&lt;/code&gt; 및 &lt;code&gt;-h24w80&lt;/code&gt; 과 같은 옵션 번들 은 오류로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="330db949eeb51ae2f426c6b4541a1ffbf72e90be" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt;, but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">이제 &lt;code&gt;-vax&lt;/code&gt; 는 &lt;code&gt;vax&lt;/code&gt; 옵션을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="3e294ef877a18e50d3cf43096be573f3ba73196e" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 핸들러로 무엇을하고 싶을까 : 어떤 클래스에서 어떤 키가 실패했는지 기록하고 죽을 수도 있습니다. 어쩌면 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 좋아하지 않고 대신 STDOUT (또는 어디에나)에 오류 메시지를 보내고 나서 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 을 보내려고합니다 .</target>
        </trans-unit>
        <trans-unit id="a8c9c99975917c3ed487322ad5c970c3faeddcbc" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;die&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">이제 최상위 레벨에는 참조 만 포함되어 있으므로 간단한 print () 함수로 배열을 인쇄하려고하면 다음과 같이보기에 좋지 않은 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">이제 이것을 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="d7ffbca375f24628b0da0f697f3844b6c5775889" translate="yes" xml:space="preserve">
          <source>Now, create a fork on GitHub to push your branch to, and add it as a remote if you haven't already, as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/working-with-forks&quot;&gt;https://help.github.com/en/articles/working-with-forks&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">이제 &lt;code&gt;[0-9]&lt;/code&gt; 조차도 여러 번 쓰는 것이 귀찮을 수 있으므로 키 입력을 줄이고 정규 표현식을 더 읽기 쉽게 만들기 위해 Perl은 아래와 같이 일반적인 문자 클래스에 대한 몇 가지 약어를 사용합니다. 유니 코드가 도입 된 이후로 &lt;code&gt;//a&lt;/code&gt; 수정자가 적용 되지 않는 한 이러한 문자 클래스는 ASCII 범위의 몇 문자 이상과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e2eacdfa4a021a03b4f7ed6c8878ca3eccdafc77" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">지금, 만약 &lt;code&gt;junk&lt;/code&gt; 우리가 추가하려는 문자열과 동일, 우리는 SV에서 직접 문자열을 잡을 수있다; &lt;code&gt;SvPVX&lt;/code&gt; 는 SV에서 PV의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">이제 바이트 순서가 다른 머신의 데이터를 패킹한다고 가정합니다. 먼저, 대상 머신의 데이터 유형이 실제로 얼마나 큰지 알아 내야합니다. long이 32 비트 너비이고 short가 16 비트 너비라고 가정 해 봅시다. 그런 다음 템플릿을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e966fc4eb896c9493f50919b32baf5ee748e75c" translate="yes" xml:space="preserve">
          <source>Now, inside of the &lt;code&gt;WriteMakeFile()&lt;/code&gt; function in your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">이제 이전 예제를 확장하여 매개 변수의 합계와 차이를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac0e50de65e6792eafd44dfb3d472e96b20f9034" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;Net::SMTP&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">지금, 꽤 많은 사람들이 Acme Transmogrifier를 가지고 있으며, 프로토콜을 처음부터 다시 이야기 할 무언가를 작성해야했습니다. 거의 확실하게 모듈로 만들고 싶을 것입니다. 당신이 결정하는 수준은 당신에게 달려 있습니다 : 당신은 &lt;a href=&quot;net/smtp&quot;&gt;Net :: SMTP&lt;/a&gt; 와 유사한 프로토콜 레벨 모듈을 원할 것입니다. 그런 다음 &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Send와&lt;/a&gt; 유사한 상위 레벨 모듈과 통신합니다 . 선택은 당신의 것이지만, 당신은 그 서버 프로토콜에 대한 모듈을 꺼내고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">이제 위의 줄을 작성한 직후에는 보통 ThisProject / I18N / en.pm 파일을 열고 즉시 항목을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">이제 make를 실행하면 다음과 같은 출력이 생성됩니다 (명확성을 위해 일부 긴 줄이 짧아졌고 일부 불필요한 줄이 삭제되었습니다).</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">이제 단일 문자 &lt;code&gt;/GX/&lt;/code&gt; 를 검색한다고 가정 하겠습니다 . Perl은 화성에 대해 알지 못하므로 &quot;I CVSGXX입니다!&quot;에서 2 바이트 &quot;GX&quot;를 찾을 수 있습니다. 문자열은 해당 문자가 없더라도 &quot;SG&quot;가 &quot;XX&quot;옆에 있기 때문에 실제 &quot;GX&quot;가 없기 때문입니다. 이것은 큰 문제입니다.</target>
        </trans-unit>
        <trans-unit id="3510dbe78a5971908a5d18e000554027edb2cb1f" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt;. Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">이제 XS에서 perlio 레이어를 사용한다고 가정합니다. perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; 함수를 예로 사용하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">이제 우리의 데이터가 파싱되었습니다. 우리가 지금하고 싶은 것은 수입과 지출을 모두 합한 것으로, 원장 끝에 또 다른 줄을 같은 형식으로 추가하여 수입과 지출 금액을 말합니다.</target>
        </trans-unit>
        <trans-unit id="b6104104e2da85f59a70d3eb8135a126533dc183" translate="yes" xml:space="preserve">
          <source>Now, the Russian quant method here is responsible not only for implementing the strange logic necessary for figuring out how Russian number-phrases impose case and number on their noun-phrases, but also for inflecting the Russian word for &quot;directory&quot;. How that inflection is to be carried out is no small issue, and among the solutions I've seen, some (like variations on a simple lookup in a hash where all possible forms are provided for all necessary words) are straightforward but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">이제 함수에 대한 다음 호출은 모두 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cfc8866cddcad33148adff8ad6715f9f23dc807f" translate="yes" xml:space="preserve">
          <source>Now, there's no particularly obvious way to store anything but strings in a gettext lexicon; so it looks like we just have to start over and make something better, from scratch. I call my shot at a gettext-replacement system &quot;Maketext&quot;, or, in CPAN terms, Locale::Maketext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">이제 명령 행에서 &lt;code&gt;--verbose&lt;/code&gt; 를 사용 하면 예상대로 &lt;code&gt;$verbose&lt;/code&gt; 가 활성화 됩니다. 그러나 &lt;code&gt;--noverbose&lt;/code&gt; 를 사용할 수도 있습니다 . 이 값은 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 &lt;code&gt;$verbose&lt;/code&gt; 를 비활성화 합니다. 적절한 기본값을 사용하여 프로그램은 &lt;code&gt;$verbose&lt;/code&gt; 가 기본적으로 false 인지 또는 &lt;code&gt;--noverbose&lt;/code&gt; 를 사용하여 비활성화 되었는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e3286afdf8a8f15ad325a81b0628c314540334" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt;, as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt;, which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt;. Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">스칼라 문맥에서 &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; 는 true 또는 false 값을 반환합니다. 그러나 목록 컨텍스트에서는 일치하는 값 목록 &lt;code&gt;($1,$2,$3)&lt;/code&gt; 반환합니다 . 따라서 코드를보다 간결하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c881bffc946b525469a86f23ed507e231ad46769" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt;. So we could write the code more compactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf36e6267baebdc3ed4fd5c4c6b178499170bce" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">이제 &quot;and&quot;를 대문자로 사용하지 않으려면 어떻게해야합니까? 그냥 사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;텍스트 : 자동 서식&lt;/a&gt; 및 다음 문제에 얻을. :)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">이제 우리가 한 일은 스크립트에서 내장 펄 디버거를 시작하는 것입니다. 실행 코드의 첫 번째 줄에서 중지되었으며 입력을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">자, 이것에 대해 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">널 AV 포인터.</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">널 CV 포인터.</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">널 HV 포인터.</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">널 SV 포인터. &lt;code&gt;PERL_CORE&lt;/code&gt; 가 정의 되면 더 이상 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">널 문자 포인터. &lt;code&gt;PERL_CORE&lt;/code&gt; 가 정의 되면 더 이상 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc5c9f306915d4135b8053056b0178c088e8651" translate="yes" xml:space="preserve">
          <source>Null picture in formline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4bd9c62d3ecb53b530fd1a90e4da66bcf3402d" translate="yes" xml:space="preserve">
          <source>Null realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebe00d5eb5dc6465abbd73f1052105fa12c1088" translate="yes" xml:space="preserve">
          <source>Nullav</source>
          <target state="translated">Nullav</target>
        </trans-unit>
        <trans-unit id="0f70fd3842939caf1b28e5e61343267fb7df7093" translate="yes" xml:space="preserve">
          <source>Nullch</source>
          <target state="translated">Nullch</target>
        </trans-unit>
        <trans-unit id="32ecb682e3f060838162e9bbbbf1d860a0d1dca5" translate="yes" xml:space="preserve">
          <source>Nullcv</source>
          <target state="translated">Nullcv</target>
        </trans-unit>
        <trans-unit id="e547450e00d976847c97a5b3855e227ed6ee122c" translate="yes" xml:space="preserve">
          <source>Nullhv</source>
          <target state="translated">Nullhv</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Nullops는 &lt;code&gt;ex-opname&lt;/code&gt; 으로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f59d50c5f13fde39f97b92afad489b0c203d91e4" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c3cf48b244deeb77cbf7fb2d31febc3616e04" translate="yes" xml:space="preserve">
          <source>Nullsv</source>
          <target state="translated">Nullsv</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">반복 횟수</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">저장할 줄 수?</target>
        </trans-unit>
        <trans-unit id="39678ab676a3f472a8537a68ada508040f950313" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">유효 자릿수 선행 0은 계산되지 않습니다. 숫자가 0이거나 뒤에 0이 있으면 숫자가 0이 아닌 숫자보다 큰 정확도를 가질 수 있습니다. 예를 들어, 123.456의 A는 6, 10203의 5, 123.0506의 7, 123.450000의 8, 0.000123의 3입니다.</target>
        </trans-unit>
        <trans-unit id="c5aadd077767ce8ba345b0317eb500c0c374d288" translate="yes" xml:space="preserve">
          <source>Number too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa074fe25a6265136343f6af71868d2eb3ffdf5" translate="yes" xml:space="preserve">
          <source>Number with no digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">사용 횟수는 부호없는 16 비트 정수로 저장되므로 65535를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">번호가 매겨진 캡처 콜백</target>
        </trans-unit>
        <trans-unit id="2f3ef08b1556d451a2f171bcd8cc5fa9d0a67578" translate="yes" xml:space="preserve">
          <source>Numbers containing a fractional or exponential part will always be represented as numeric (floating point) values, possibly at a loss of precision (in which case you might lose perfect roundtripping ability, but the JSON number will still be re-encoded as a JSON number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">숫자는 주위에 따옴표가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">엔디안과 너비</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">숫자 (괄호)는 속성과 일치하는 총 유니 코드 코드 포인트 수를 나타냅니다. 강조하기 위해 코드 포인트와 전혀 일치하지 않는 속성은 표 다음에 별도 섹션에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="34ed490a2fac8e8118b8b1dcb98a2f46ca2806fc" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For the entries that give the longest, most descriptive version of the property, the count is followed by a list of some of the code points matched by it. The list includes all the matched characters in the 0-255 range, enclosed in the familiar [brackets] the same as a regular expression bracketed character class. Following that, the next few higher matching ranges are also given. To avoid visual ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">160-255 범위의 숫자는 라틴 -1 문자를 나타냅니다 (유일한 의미로 유니 코드로 정의 됨). 255보다 큰 숫자는 유니 코드 문자를 나타내는 것으로 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">숫자 필드</target>
        </trans-unit>
        <trans-unit id="8c7c98efa8c2ec06026f0650448ebfec04745d0d" translate="yes" xml:space="preserve">
          <source>Numeric comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">숫자 변환</target>
        </trans-unit>
        <trans-unit id="c721f5217c35d940494ce8935e78185eea92c32c" translate="yes" xml:space="preserve">
          <source>Numeric format result too large</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">숫자 함수</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">숫자 리터럴은 다음 부동 소수점 또는 정수 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">숫자 연산자 및 숫자 변환</target>
        </trans-unit>
        <trans-unit id="44e5694a92fbb0b839eb3d472cdd4e3a72b88c8c" translate="yes" xml:space="preserve">
          <source>Numeric variables with more than one digit may not start with '0'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d013232ca01b901c06ddf5aa9483529f278d91" translate="yes" xml:space="preserve">
          <source>Numeric_Value</source>
          <target state="translated">Numeric_Value</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Numify는 인스턴스 데이터의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1930939e1cfe41540640ae63b0d1c9cd976b8003" translate="yes" xml:space="preserve">
          <source>NushuSources.txt</source>
          <target state="translated">NushuSources.txt</target>
        </trans-unit>
        <trans-unit id="785fb0c8fda67339daa5891e78532ef7046332eb" translate="yes" xml:space="preserve">
          <source>Nuts and bolts of testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-Perl Compiler 백엔드에 대한 일반 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f2e040017a2a32e5149e8541c71a3f6ab2be70d" translate="yes" xml:space="preserve">
          <source>OA_BASEOP</source>
          <target state="translated">OA_BASEOP</target>
        </trans-unit>
        <trans-unit id="a0232d9c77de9ad3ad30f960003fca0ebf21434a" translate="yes" xml:space="preserve">
          <source>OA_BINOP</source>
          <target state="translated">OA_BINOP</target>
        </trans-unit>
        <trans-unit id="dd4e2946f44fa938f47620909c47a03ec9907915" translate="yes" xml:space="preserve">
          <source>OA_COP</source>
          <target state="translated">OA_COP</target>
        </trans-unit>
        <trans-unit id="8bb6941ea27d2f4edcd36aa185a95c1934071dae" translate="yes" xml:space="preserve">
          <source>OA_LISTOP</source>
          <target state="translated">OA_LISTOP</target>
        </trans-unit>
        <trans-unit id="1f95f49a3cc0d9c9dce498b8fb55f7d434ffef98" translate="yes" xml:space="preserve">
          <source>OA_LOGOP</source>
          <target state="translated">OA_LOGOP</target>
        </trans-unit>
        <trans-unit id="080d4766c1c017ed91c21efdfd770542db5231ba" translate="yes" xml:space="preserve">
          <source>OA_LOOP</source>
          <target state="translated">OA_LOOP</target>
        </trans-unit>
        <trans-unit id="b82424ac68328551cd5b311d9b76afd01dc2b8ec" translate="yes" xml:space="preserve">
          <source>OA_PADOP</source>
          <target state="translated">OA_PADOP</target>
        </trans-unit>
        <trans-unit id="1c24597939e0dd807c389498cedbeb0fddd031c5" translate="yes" xml:space="preserve">
          <source>OA_PMOP</source>
          <target state="translated">OA_PMOP</target>
        </trans-unit>
        <trans-unit id="388be58f270e37e48cf5f4058c11eb99107d89f1" translate="yes" xml:space="preserve">
          <source>OA_PVOP_OR_SVOP</source>
          <target state="translated">OA_PVOP_OR_SVOP</target>
        </trans-unit>
        <trans-unit id="565cd3fb7a20fefb8a748b15fbc632d71f3b0236" translate="yes" xml:space="preserve">
          <source>OA_SVOP</source>
          <target state="translated">OA_SVOP</target>
        </trans-unit>
        <trans-unit id="6e405aaa77ee94bd8832317336e851e6173b598b" translate="yes" xml:space="preserve">
          <source>OA_UNOP</source>
          <target state="translated">OA_UNOP</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">목표 방법</target>
        </trans-unit>
        <trans-unit id="bb24863eee0d4bd1920af16c1ccee60c7f9c3be6" translate="yes" xml:space="preserve">
          <source>OBJECT SERIALISATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">목표 지향적 인 기초</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="05862bdb9f65a88577df4e19fea889c438e90640" translate="yes" xml:space="preserve">
          <source>ODBM_File</source>
          <target state="translated">ODBM_File</target>
        </trans-unit>
        <trans-unit id="7e05f5ed4d1b9fde9620b516a5a0c77a7eb29821" translate="yes" xml:space="preserve">
          <source>ODBM_File - Tied access to odbm files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdefafa72aee75553cdc6a69cd8b93613e4f45c" translate="yes" xml:space="preserve">
          <source>OFFSETS</source>
          <target state="translated">OFFSETS</target>
        </trans-unit>
        <trans-unit id="90916aa5c9b7aec2f126aa735cbb92f018d5530c" translate="yes" xml:space="preserve">
          <source>OFFSETSDBG</source>
          <target state="translated">OFFSETSDBG</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK (즉,이 시스템 종속 모듈은 다른 배포의 하위 디렉토리에 빌드되거나 CPAN :: Bundle에 종속 항목으로 나열되지만 기능은 현재 아키텍처에서 다른 방법으로 지원됩니다).</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">OK와 반대로</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">알았어, 시작이야.하지만 우주는 어떻게 된거 야? 우리는 &lt;code&gt;x&lt;/code&gt; 를 넣지 않습니까? 앞으로 건너 뛰지 않아야합니까? &lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; 의 내용을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="36f7ee24c9b6c25eb367d474e774055820afae57" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt;, didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt; says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">자, 우리의 데이터 중 일부를 다시 살펴 봅시다. 실제로 헤더와 편리한 눈금자를 포함하여 현재 위치를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">좋아, 총알을 물자 템플릿 코드 &lt;code&gt;x&lt;/code&gt; 를 삽입하여 올바른 정렬을 얻는 한 가지 방법은 다음과 같습니다 .리스트에서 해당 항목을 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f004dfa733000f32dac52f2362a807ead5a0ec9" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt;, which don't take a corresponding item from the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">마지막은 실제로 난독 화 된 펄 콘테스트 출품작입니다. :-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">다음은 무엇입니까? 날짜와 설명 사이에는 빈 열이 있습니다. 우리는 그것을 건너 뛰고 싶습니다. &lt;code&gt;x&lt;/code&gt; 우리가 그 중 하나를 할 수 있도록 템플릿 수단은, &quot;앞으로 건너 뛰기&quot;. 다음으로, 12에서 38 사이의 다른 문자 배치가 있습니다. 27 자 이상이므로 &lt;code&gt;A27&lt;/code&gt; 입니다. (펜스 포스트 오류를 ​​만들지 마십시오-26이 아닌 12와 38 사이에 27 문자가 있습니다. Count'em!)</target>
        </trans-unit>
        <trans-unit id="05a96155067c83cf8e468762a0e54175339f79a8" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt;. (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">좋아, 정규 표현식의 기본 사항을 알고 더 알고 싶습니다. 정규식을 일치시키는 것이 숲 속을 걷는 것과 유사하다면, Part 1에서 논의 된 도구는 우리가 항상 사용하는 topo map 및 나침반, 기본 도구와 유사합니다. 파트 2에있는 대부분의 도구는 플레어 건 및 위성 전화기와 유사합니다. 그들은 하이킹에 너무 자주 사용되지 않지만, 우리가 붙어있을 때, 그들은 귀중 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">확인. 이것이 C 부분입니다. 이제이 패치가 준비되기 전에 두 가지 추가 작업을 수행해야합니다. Perl의 동작을 변경 했으므로 해당 변경 사항을 문서화해야합니다. 또한 패치가 작동하고 라인 어딘가에 버그를 생성하지 않도록 회귀 테스트를 더 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">오래된 건물 지침</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">이전 펄 버전</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">한 단계 앞으로</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">한 단계 옆으로</target>
        </trans-unit>
        <trans-unit id="65b7fafd1d758275b2afd66a14ad17bf21acd2fc" translate="yes" xml:space="preserve">
          <source>ONESIDED LEXICONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">OO 펄</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl은 비교적 단순하며 Perl의 패키지 개념에 기반한 객체를 알고있는 참조를 사용하여 구현됩니다. 그러나 OO Perl은이 문서에서 다루지 않습니다. &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 및 &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">OO 시스템 요약</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">선택 시스템 호출에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">사용자 netrc 파일에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">OOP 스타일</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">OP 트리</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">OP 클래스 약어</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">OP 플래그 약어</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">OP 플래그는 공개 또는 비공개입니다. 공개 플래그는 각 opcode의 동작을 일관된 방식으로 변경하며 0 개 이상의 단일 문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4e1c899139139b6a62148bc5314166d68c3c0058" translate="yes" xml:space="preserve">
          <source>OP op_private flag definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">관련 클래스</target>
        </trans-unit>
        <trans-unit id="134d5bae173a0d828238edb09ac60f90d32a7d18" translate="yes" xml:space="preserve">
          <source>OPEN this, filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION은 LOCK_SH, LOCK_EX 또는 LOCK_UN 중 하나이며 LOCK_NB와 결합 될 수 있습니다. 이러한 상수는 일반적으로 1, 2, 8 및 4의 값이지만 &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈에서 개별적으로 또는 &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 태그를 사용하여 그룹으로 가져올 경우 기호 이름을 사용할 수 있습니다 . LOCK_SH는 공유 잠금을 요청하고 LOCK_EX는 독점 잠금을 요청하며 LOCK_UN은 이전에 요청 된 잠금을 해제합니다. LOCK_NB가 LOCK_SH 또는 LOCK_EX를 사용하여 비트 단위이거나 사용 된 경우, 잠금 대기를 차단하지 않고 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 즉시 리턴합니다. 반품 상태를 확인하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION은 LOCK_SH, LOCK_EX 또는 LOCK_UN 중 하나이며 LOCK_NB와 결합 될 수 있습니다. 이러한 상수는 일반적으로 1, 2, 8 및 4의 값이지만 &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈에서 개별적으로 또는 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 태그를 사용하여 그룹으로 가져올 경우 기호 이름을 사용할 수 있습니다 . LOCK_SH는 공유 잠금을 요청하고 LOCK_EX는 독점 잠금을 요청하며 LOCK_UN은 이전에 요청 된 잠금을 해제합니다. LOCK_NB가 LOCK_SH 또는 LOCK_EX를 사용하여 비트 단위이거나 사용 된 경우, 잠금 대기를 차단하지 않고 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 즉시 리턴합니다. 반품 상태를 확인하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="58928b6b598b49fbbad1c76c170db949cd86f725" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:flock&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">운영자 차이</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="06c49349926c115048c467e62819168f88084bea" translate="yes" xml:space="preserve">
          <source>OPTIMISE</source>
          <target state="translated">OPTIMISE</target>
        </trans-unit>
        <trans-unit id="4f728fb4e19e018dc7c2672b0908d6be76bddf1f" translate="yes" xml:space="preserve">
          <source>OPTIMISEM</source>
          <target state="translated">OPTIMISEM</target>
        </trans-unit>
        <trans-unit id="02ce66c3b2f62920ab55a0e848d4ded3f5f982b7" translate="yes" xml:space="preserve">
          <source>OPTIMIZE</source>
          <target state="translated">OPTIMIZE</target>
        </trans-unit>
        <trans-unit id="8a61db568f56cdf729bb2bcffb35bc1a208ff62c" translate="yes" xml:space="preserve">
          <source>OPTIONAL FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463186385d27ae21b6cfb79380a5979894ad32c0" translate="yes" xml:space="preserve">
          <source>OPTIONAL PARAMETERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">선택적인 술병 / 방법 오버라이드</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">옵션과 인수</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS는 &lt;code&gt;$z&lt;/code&gt; 객체를 만들 때 사용할 수있는 옵션으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS는 다음 옵션의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="443cfbc1735fa88324f99c052a719f69f770de00" translate="yes" xml:space="preserve">
          <source>OP_CLASS</source>
          <target state="translated">OP_CLASS</target>
        </trans-unit>
        <trans-unit id="257329c9527baa8930f69f20f88bd1b9492d9148" translate="yes" xml:space="preserve">
          <source>OP_DESC</source>
          <target state="translated">OP_DESC</target>
        </trans-unit>
        <trans-unit id="95a97252650f52a0edc590efc17643d272eecd14" translate="yes" xml:space="preserve">
          <source>OP_NAME</source>
          <target state="translated">OP_NAME</target>
        </trans-unit>
        <trans-unit id="664b383a7365636329fa816c917a23ae28c5aba2" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS</source>
          <target state="translated">OP_TYPE_IS</target>
        </trans-unit>
        <trans-unit id="745e8a6c1fc90c064d4d4edecae8bb1c615be59a" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS_OR_WAS</source>
          <target state="translated">OP_TYPE_IS_OR_WAS</target>
        </trans-unit>
        <trans-unit id="bf9f9c661a64325d7940c6088a152e09a3273a85" translate="yes" xml:space="preserve">
          <source>ORDER OF APPLICATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686fecd15046059a1461463f65cd5916d98af39b" translate="yes" xml:space="preserve">
          <source>ORIGMARK</source>
          <target state="translated">ORIGMARK</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">ORcpt는 RFC3461에 따른 SMTP DSN 확장의 일부이기도합니다. 메일을 처음 보낸 원래 수신자에게 전달하는 데 사용됩니다. DSN을 생성하는 시스템은이 주소를 사용하여 발신인에게 알립니다. 수신자가 메일 서버로 다시 작성되는지 알 수 없기 때문입니다. xtext 인코딩 된 RFC3461에 필요한 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">OS 문제</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">OS 조정 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">OS 레벨</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">OS 관련 참조</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="9b1d79b903ce0b8766b4e5764e59485f0c5a70da" translate="yes" xml:space="preserve">
          <source>OS/2 .INF file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS / 2 _.INF_ 파일</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS / 2는 OS / 2입니다</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">OS / 2 툴킷</target>
        </trans-unit>
        <trans-unit id="fd3c79c993342fdc4845e0000fd358e72448a4b9" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390은 &lt;code&gt;#!&lt;/code&gt; 릴리스 2.8 이상의 Shebang 트릭. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 백틱에 대한 호출 은 모든 S / 390 시스템에서 POSIX 쉘 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS / 390, z / OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="ce46010d8cbef8c9b0bbd999f8b39bd331eb9402" translate="yes" xml:space="preserve">
          <source>OS2::BootDrive()</source>
          <target state="translated">OS2::BootDrive()</target>
        </trans-unit>
        <trans-unit id="6b75ff49b64b08a5cbda19098841eaa70af4d838" translate="yes" xml:space="preserve">
          <source>OS2::SysInfo()</source>
          <target state="translated">OS2::SysInfo()</target>
        </trans-unit>
        <trans-unit id="aca5fea461e6f13c528c2c4f05a7be94b7faae70" translate="yes" xml:space="preserve">
          <source>OS2::get_control87()</source>
          <target state="translated">OS2::get_control87()</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="cb338bafdad45c9e72ba4f2b86d7dc19e8efe3a0" translate="yes" xml:space="preserve">
          <source>OTHER API EXPORTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea1e1d8de28e316e4bbdddc4c0f8d93bcafa453" translate="yes" xml:space="preserve">
          <source>OTHER API FUNCTIONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">다른 구성 요소</target>
        </trans-unit>
        <trans-unit id="f4819c79c3cf5d0855c9756e200236cb695ed79b" translate="yes" xml:space="preserve">
          <source>OTHER EXAMPLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">다른 시설</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="c89d68a8b80355c832f177abfb0d1dd9e08c42b5" translate="yes" xml:space="preserve">
          <source>OURSTASH</source>
          <target state="translated">OURSTASH</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">출력 팁</target>
        </trans-unit>
        <trans-unit id="cbbef8ce7e5bb98d49b97d0627758196498a036b" translate="yes" xml:space="preserve">
          <source>OUTSIDE</source>
          <target state="translated">OUTSIDE</target>
        </trans-unit>
        <trans-unit id="aed9198315d600f631cbfb4ab62949c42689f27b" translate="yes" xml:space="preserve">
          <source>OUTSIDE_SEQ</source>
          <target state="translated">OUTSIDE_SEQ</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">과장된 방법</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">대체 핵심 기능</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">수업 개요</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">객체 방법</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">객체 지향이 모든 문제에 대한 최상의 솔루션은 아닙니다. 에</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">객체 지향 인코더</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">객체 지향 시간 객체</target>
        </trans-unit>
        <trans-unit id="8a9d1904669ae5189957085d3ad744889ffa188e" translate="yes" xml:space="preserve">
          <source>Object Oriented/Tied Handle Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a2199d628852802c93c71acfcb62c9006d4a9" translate="yes" xml:space="preserve">
          <source>Object interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">AF_INET 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">AF_UNIX 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">소켓 통신을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">시스템 폴 호출에 대한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">객체 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="26b3504ec46d1edff4f4783df6ad8b24180e673c" translate="yes" xml:space="preserve">
          <source>Object property methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">객체 레지스트리는 클래스와 함께 사용하기 위해 객체가 초기화 될 때 가장 잘 수행됩니다. 이렇게하면 모든 객체와 초기화 된 모든 필드에 대해 가비지 수집 및 스레드 안전성이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">객체 상태 (즉, 객체가 축복받은 클래스)도 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8c7731a828adbc9c6710de9659455410072a19" translate="yes" xml:space="preserve">
          <source>Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef528339319411e5d4f89f3a15d4db11ad2cbd90" translate="yes" xml:space="preserve">
          <source>Object to represent a testing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbf11227dc99e33421481b03ca2f68bc9536a37" translate="yes" xml:space="preserve">
          <source>Object used by Test2::API under the hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">축복받은 대상; 변수가 아닙니다</target>
        </trans-unit>
        <trans-unit id="5bca7499b54d7016ce15937bcabd8353b693c22e" translate="yes" xml:space="preserve">
          <source>Objects based on the above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">POD 입력 단락, 명령 등을 나타내는 객체</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">애매-버퍼의 바이트 수를 설정합니다. 더 이상 사용되지 않습니다. PerlIO_canset_cnt ()가 true를 반환하는 경우에만 사용할 수 있습니다. 현재 카운트를 -1에서 -1보다 작게하기 위해 doio.c에서만 사용됩니다. 아마도 PerlIO_set_empty 또는 유사해야합니다. 이 호출은 포인터와 &quot;제한&quot;에서 &quot;count&quot;가 추론 된 경우 실제로 아무 작업도 수행하지 않을 수 있습니다. 이것을 사용하지 마십시오-PerlIO_set_ptrcnt ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">이전 버전과의 호환성 기능</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">더 이상 사용되지 않는 방법입니다. 버전 5.21부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">더 이상 사용되지 않습니다. 이전에이 코드와 일치하는 모든 코드 포인트가 &quot;Script = Common&quot;으로 이동되었습니다. 대신 &quot;Script_Extensions = Katakana&quot;또는 &quot;Script_Extensions = Hiragana&quot;(또는 둘 다)를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="a9002afd81f2bf4ce6e9b9a4e6ca0a84152afb47" translate="yes" xml:space="preserve">
          <source>Obsoleted as of Unicode 9.0, but previously provided a visual display of the standard variant sequences derived from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">서버에서 응답을 얻습니다. 성공하면 상태 코드의 최상위 숫자가 반환됩니다. 실패, 타임 아웃 등</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">모든 활성 뉴스 그룹에 대한 정보를 얻습니다. 결과는 키가 그룹 이름이고 각 값이 배열에 대한 참조 인 해시에 대한 참조입니다. 이 배열의 요소는 다음과 같습니다 .- 그룹의 마지막 기사 번호, 그룹의 첫 번째 기사 번호 및 그룹에 대한 정보 플래그.</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 의 속성을 확보하십시오 .</target>
        </trans-unit>
        <trans-unit id="7789255329d3ffd1b99a0a2cd58f6fb55a93559e" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">stdout의 속성을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">지정된 모든 메시지에 대한 헤더 필드 &lt;code&gt;HEADER&lt;/code&gt; 를 확보하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">의 시간을 확보 &lt;code&gt;HOST&lt;/code&gt; 경우, 또는 기본 호스트 &lt;code&gt;HOST&lt;/code&gt; 가 RFC867에 정의 된 프로토콜을 사용하여, 주어진하지 않거나 정의되지 않았습니다. 선택적 인수 &lt;code&gt;PROTOCOL&lt;/code&gt; 은 사용할 프로토콜 ( &lt;code&gt;tcp&lt;/code&gt; 또는 &lt;code&gt;udp&lt;/code&gt; ) 을 정의해야합니다 . 결과는 ASCII 문자열이거나</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">의 시간을 확보 &lt;code&gt;HOST&lt;/code&gt; 경우, 또는 기본 호스트 &lt;code&gt;HOST&lt;/code&gt; 가 RFC868에 정의 된 프로토콜을 사용하여, 주어진하지 않거나 정의되지 않았습니다. 선택적 인수 &lt;code&gt;PROTOCOL&lt;/code&gt; 은 사용할 프로토콜 ( &lt;code&gt;tcp&lt;/code&gt; 또는 &lt;code&gt;udp&lt;/code&gt; ) 을 정의해야합니다 . 결과는 time () 또는</target>
        </trans-unit>
        <trans-unit id="795eb623dba4761a659c021e4b42f3958e340aa1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be an ASCII string or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74c2d6b8c1d1a064d7e0d2a2f0c8de41a911ec1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be a time value in the same units as returned by time() or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66bf08929fd5d420bb4c2ec86a67bddae583922" translate="yes" xml:space="preserve">
          <source>Obtaining and installing libnet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">분명히 이들 중 첫 번째는 모든 ASCII 문자 플랫폼에서 &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; 이후 대부분의 ASCII 플랫폼을 CCSID 0037, 1047 또는 POSIX-BC EBCDIC 플랫폼과 구별하지 못합니다 . 그러나 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; 이고 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 은 오래된 Macintosh (ASCII 플랫폼)에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$is_ascii&lt;/code&gt; 때문에 두 번째 $ is_ascii 테스트는 문제를 일으 킵니다 .</target>
        </trans-unit>
        <trans-unit id="1d78b76872c5b56931c9b5c0301dbd8a6a7bb448" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; eq chr(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;chr(13)&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;chr(10)&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">분명히 이것은 서명되지 않은 long에 대한 포인터를 타입 캐스팅 할 수 있다고 가정하고, 그 반대의 경우도 자주 작동하지만 보편적 법으로 취해서는 안됩니다. -이제 우리는이 포인터를 가지게되었습니다. 다음 질문은 : 어떻게 잘 사용할 수 있습니까? 포인터가 필요한 C 함수를 호출해야합니다. read (2) 시스템 호출이 떠 오릅니다.</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">분명히 패치를 포함하는 버그가 가장 좋습니다. 원하는 경우 최신 버전의 익명 체크 아웃을 통해 출혈에 대해 패치를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">분명히, OS / 2 API 서명의 마지막 유형의 상황에서 die () ing으로 실패가 표시되면 사용자가 더 편리해야합니다. $ ^ E를 확인할 필요가 없다는 것을 알 수 있습니다. 문제가 발생했습니다. 그러나 어떤 이유로이 솔루션이 바람직하지 않은 경우, 해당 OS / 2 API 호출을 수행하기 전에 해당 코드가 $ ^ E를 0으로 재설정해야합니다. 따라서이 Perl 액세스 가능 함수의 호출자는 성공을 구별 할 수 있습니다. -but-0- 실패에서 값을 반환합니다. (오류를보고하는 다른 방법으로 undef를 반환 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">분명히 두 번째로 &lt;code&gt;complicated&lt;/code&gt; 호출 은 시간 낭비이며 반환 값을 저장하는 것은 공간 낭비입니다. 지정 &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; 것 &lt;code&gt;memoize&lt;/code&gt; 는 두 번째 전화가 첫 번째 통화로 채워진 스칼라 캐시를 사용되도록, 스칼라 및 목록 컨텍스트 값에 대한 동일한 캐시를 사용한다. &lt;code&gt;complicated&lt;/code&gt; 는 한 번만 호출되며 호출 컨텍스트에 관계없이 두 후속 호출 모두 캐시에서 &lt;code&gt;3&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">때때로 TIESCALAR, TIEHASH 등에 묶여있는 객체에 대한 참조를 전달하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">때때로 프로그래머는 함수가 별도의 상태 값 대신 실패한 경우 단순히 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 빈 목록 을 반환하려고 할 것 입니다. rpcb_gettime () 함수는이 상황을 제공합니다. 함수가 성공하면 시간을 반환하고 실패하면 undef를 반환하려고합니다. 다음 Perl 코드에서 $ timep의 값은 undef이거나 유효한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0ea7d0ab3870cda5bd5d012242ed94c158dde1fa" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;undef&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">때때로 어려운 노력 Attribute :: Handlers는 처리기에 전달하기 전에 데이터 인수 ( &lt;code&gt;$_[4]&lt;/code&gt; )를 사용 가능한 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f13c9786193661170bf181a99c76dd0d6705b9c3" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler get in the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">때로는 &lt;code&gt;/g&lt;/code&gt; 만 사용 하여 원하는 모든 변경 사항을 얻을 수 없습니다 . 일반적인 두 가지 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">8 진 탈출</target>
        </trans-unit>
        <trans-unit id="db84424f081d663bc203c1af1117e2bdc42e8773" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">대괄호로 묶은 문자 클래스 외부 에서 &lt;code&gt;\000&lt;/code&gt; 형식 의 8 진수 이스케이프는 이전 스타일 역 참조와 충돌 할 수 있습니다 (아래 &lt;a href=&quot;#Absolute-referencing&quot;&gt;절대 참조&lt;/a&gt; 참조). 둘 다 백 슬래시와 숫자로 구성됩니다. 따라서 Perl은 휴리스틱을 사용하여 역 참조인지 8 진 탈출인지를 결정해야합니다. Perl은 다음 규칙을 사용하여 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="87a50fff0e8349cdbe12625e1077c3ebe0fdfa7d" translate="yes" xml:space="preserve">
          <source>Octal number &amp;gt; 037777777777 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb34d0b5eb49bdff2904bd7acc2fa7d27c59806" translate="yes" xml:space="preserve">
          <source>Octal numbers are typically prefixed by &quot;0&quot;, but since leading zeros are stripped, these methods can not automatically recognize octal numbers, so use the constructor from_oct() to interpret octal strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af566741591251972e43e0d36356b0e06a29bb7" translate="yes" xml:space="preserve">
          <source>Odd name/value argument for subroutine '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bda02e37792920d152c41b584876b2e10eb3c5" translate="yes" xml:space="preserve">
          <source>Odd number of arguments for overload::constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399492c4df4e28b7b58d749dc69161eed60f95f9" translate="yes" xml:space="preserve">
          <source>Odd number of elements in anonymous hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065c34a675ace7837e8fdf7122c9899906bd6b6e" translate="yes" xml:space="preserve">
          <source>Odd number of elements in hash assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cc17f1e22c5e8c8c6d8e8b50d3e2d9acf218c8" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;cgi&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">물론 &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; 와 &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 가 더 많은 정보 를 알려줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">물론 &lt;code&gt;Moose&lt;/code&gt; 는 완벽하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">물론, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; 및 &lt;code&gt;string_vianame&lt;/code&gt; 은 물론 오버라이드 (override) 할 필요가있다.</target>
        </trans-unit>
        <trans-unit id="e69acfd1f99778b500da1a17ef29d78b995fb659" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt;, &lt;code&gt;viacode&lt;/code&gt;, and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">물론 여기에서도 Filter :: Simple은 필터를 적용하기 전에 내보내기를 사용하고 있음을 알아야합니다. 그것은 거의 문제가되지 않지만 그것에 대해 신경이 쓰이는 경우 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; 항상 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 앞에 오도록하여 작업이 올바르게 작동하도록 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4302a9cf5fbe5aa02395c1781d6a9233de7d01db" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;use base Exporter&lt;/code&gt; always precedes your &lt;code&gt;use Filter::Simple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">물론 &lt;code&gt;@ISA&lt;/code&gt; 에 &lt;code&gt;DynaLoader&lt;/code&gt; 만 포함 된 경우 &lt;code&gt;@ISA&lt;/code&gt; 할당 이 전혀 필요하지 않습니다 . 또한, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 대신에 이전 버전과 호환되는</target>
        </trans-unit>
        <trans-unit id="1eafec21d0ff2371b83827a03c0ee4872c0478b3" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt;, there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;our&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">물론 클래스 이름이 스칼라 인 경우 Perl도 올바른 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">물론 &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 지침을 따르기 만하면 다시 포맷 할 필요가 없습니다. 코드를 작성할 때 코드를 작성하는 습관은 버그를 예방하는 데 도움이됩니다. 편집자가이를 도와 줄 수 있습니다. emacs를위한 perl-mode 또는 새로운 cperl-mode는 대부분의 (전부는 아님) 코드에 대해 상당한 양의 도움말을 제공 할 수 있으며, 프로그래밍이 덜 된 편집기 일지라도 상당한 도움을 줄 수 있습니다. Tom Christiansen과 다른 많은 VI 사용자는 vi와 그 클론에서 다음 설정으로 맹세합니다.</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">물론, 예를 들어 &lt;code&gt;$obj + 1&lt;/code&gt; 과 같은 상황 에서 Perl은 (이 예제에서) numify 메소드 &lt;code&gt;'0+'&lt;/code&gt; 를 사용하여 &lt;code&gt;$obj&lt;/code&gt; 를 숫자 로 변환하는 대신 &lt;code&gt;+&lt;/code&gt; 의 &lt;code&gt;$obj&lt;/code&gt; 구현을 호출 합니다 (예외 : 어떤 방법이 제공되어 있지 않은 경우는 &lt;code&gt;'+'&lt;/code&gt; 및 &lt;a href=&quot;#fallback&quot;&gt;대체&lt;/a&gt; ) TRUE로 설정된다.</target>
        </trans-unit>
        <trans-unit id="e64305345caaad0c4dd212ba7ea682cb2c014fca" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt;, Perl will invoke &lt;code&gt;$obj&lt;/code&gt;'s implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt; is set to TRUE).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">물론 리터럴 문자열의 경우 문자열 비교 &lt;code&gt;$string eq 'bert'&lt;/code&gt; 를 쉽게 사용할 수 있으며 더 효율적입니다. &lt;code&gt;^...$&lt;/code&gt; 우리가 아래 더 강력한 정규 표현식 도구에 추가 할 때 정규 표현식은 정말 유용하게된다.</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">물론,이 모듈 저자의 겸손한 견해로 는 간단한 배열보다 기존 &lt;b&gt;Pod :: ParseTree&lt;/b&gt; 객체 를 사용하는 경향이 더 &lt;b&gt;큽니다&lt;/b&gt; . 그렇게하면 단락 및 시퀀스의 모든 항목이 모든 구문 분석 트리 노드에 대해 동일한 핵심 인터페이스에 응답합니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">물론 각 용도에 맞는 구분 기호 문자열을 선택하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">물론, 무시할지 여부를 결정하는 것은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">물론 C에서 직접 이러한 접착제 코드를 작성할 수 있습니다. 그러나 특히 여러 C 함수에 대한 접착제를 작성해야하거나 Perl 스택 분야 및 기타에 익숙하지 않은 경우에는 지루한 작업입니다. 아르카나. XS는 구출에 이르렀습니다.이 접착제 C 코드를 긴 손으로 쓰는 대신 더 간결한 속기를 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">물론, 테스트 # 1은 $ tests [0] 등입니다.</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">물론, 메모리를 절약하는 가장 좋은 방법은 처음에는 메모리를 낭비하지 않는 것입니다. 좋은 프로그래밍 방법은 다음과 같이 먼 길을 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">물론이</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">물론 이것은 기본 호출이 버퍼를 지원해야합니다. 위의 버퍼에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">물론 암호를 요구하는 사람에게 자신의 암호를 입력하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">물론 XSUB 내 에서 &lt;code&gt;sometype **&lt;/code&gt; C 배열 의 요소 수를 알지 &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; 의 반환 값 을 해독하기가 어렵습니다. 세부 사항은 모두 XS 작성자 (유형 맵 사용자)에게 달려 있기 때문에 몇 가지 솔루션이 있지만 그중에서도 특히 우아하지는 않습니다. 가장 일반적으로 보이는 해결책은 N + 1 포인터에 메모리를 할당 하고 반복을 용이하게하기 위해 &lt;code&gt;NULL&lt;/code&gt; 을 (N + 1)에 할당 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">물론, OS가 access ()를 구현하지 않으면 pragma는 무시됩니다. filetest pragma가 활성화 된 파일에서 &lt;code&gt;_&lt;/code&gt; 를 전혀 사용하지 않는 것이 가장 좋습니다 !</target>
        </trans-unit>
        <trans-unit id="abd96d1d300bf4e8daac5b50f895feff0cad5891" translate="yes" xml:space="preserve">
          <source>Of course, variables that are UTF-8 and are referred to in the string retain that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5481b8a258de1ea18c7a9b1b7f4086fab8bc96" translate="yes" xml:space="preserve">
          <source>Of course, you can also choose to import specific functions by name, as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">물론 이름을 갖기 위해 임시 배열이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">변환 중 문자열, 부울 또는 숫자 중 하나만 필요합니다. 각각은 다른 두 가지 중 하나에서 생성 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">이러한 속성 중 두 가지 중요한 속성은 Pattern_Syntax와 Pattern_White_Space입니다. 정규 표현식 패턴에서 인용해야 할 문자를 결정하기 위해 유니 코드에 의해 정확하게 설정되었습니다. 식별자에있을 수있는 문자에는 이러한 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">ISO 3166 유지 관리 기관의 공식 홈페이지.</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">최상위 도메인 이름의 공식 소스.</target>
        </trans-unit>
        <trans-unit id="3c0ccf7d9a2c2c9e1eedbe4cef2e4d0413088708" translate="yes" xml:space="preserve">
          <source>Offline sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b00389e2960ae2ee90ec24a50a5ce42fa29d6d" translate="yes" xml:space="preserve">
          <source>Offset outside string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">오프셋은 사전 &lt;code&gt;precomp&lt;/code&gt; 문자열 에서 오프셋하기 위해 &lt;code&gt;program&lt;/code&gt; 에서 오프셋 의 매핑을 유지 합니다. 이것은 ActiveState의 시각적 정규식 디버거에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">쉼표로 구분 된 값 목록과 여러 옵션이 허용되는 경우가 종종 있습니다. 이것은 Perl의 split () 및 join () 연산자를 사용하면 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">옵션에 대체 니모닉 이름을 제공하는 것이 사용자에게 친숙한 경우가 많습니다. 예를 들어 &lt;code&gt;--height&lt;/code&gt; 가 의 대체 이름이 될 수 &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 대체 이름은 옵션 막대에 세로 막대 &lt;code&gt;|&lt;/code&gt; 문자. 위 예제를 구현하려면</target>
        </trans-unit>
        <trans-unit id="7de86d17804fa632d98b8911860a7e7fb8a9bded" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--length&lt;/code&gt;. Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">더 많은 정보를 제공하는 구문 오류와 관련된 다른 오류 메시지가 종종 있습니다. (때로는 &lt;b&gt;-w&lt;/b&gt; 를 켜는 데 도움이됩니다 .) 오류 메시지 자체는 종종 포기하기로 결정했을 때 오류가 발생한 위치를 알려줍니다. Perl이 임의의 입력을 이해하는 데 능숙하기 때문에 실제 오류는이 전에 여러 토큰입니다. 때때로 줄 번호가 오해의 소지가있을 수 있으며, 블루 문에서 오류를 일으키는 원인을 알아내는 유일한 방법은 &lt;code&gt;perl -c&lt;/code&gt; 를 반복해서 호출 하여 오류가 사라 졌는지 확인하기 위해 매번 프로그램의 절반을 잘라내는 것입니다. 20 질문의 자동 제어 버전의 종류.</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">모든 사용자가 CPAN에서 볼 수있는 버전이기 때문에 기본 모듈 배포에서 $ VERSION을 수동으로 설정하려는 경우가 있으며이를 약간 사용자 정의 할 수도 있습니다. 그러나 dist에있는 다른 모든 모듈의 경우 $ VERSION은 실제로 부기입니다. 중요한 것은 모듈이 변경 될 때마다 올라가는 것입니다. 이것을 손으로하는 것은 고통스럽고 종종 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">흠. 그것은 효과가 없었습니다. 무슨 일이 있었는지 보자 :</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">아, 마지막 조언 하나 : &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; 를 가지고 가십시오 . 당신이 돌아올 때 우리는 그것을 잘 보여줄 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="6e84377d7eb2428d1c7c2ce684cd3d38c4564c15" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306452191398ef5d817db7561b984ed6863ccdd5" translate="yes" xml:space="preserve">
          <source>Ok event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40dabdf47b8a6942bfc67e5bc1a841348e34c6a" translate="yes" xml:space="preserve">
          <source>Ok events are generated whenever you run a test that produces a result. Examples are &lt;code&gt;ok()&lt;/code&gt;, and &lt;code&gt;is()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">그러나 데이터를 실제로보고 싶을 때 동적 변수는 무엇입니까? 사용하기 직전에?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">좋아, 그래서 그것은 특정 문서를 찾지 못했기 때문에 그리 흥미롭지 않습니다. 그러나 긴 응답은이 페이지에 맞지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">자, Test :: Builder 객체가 둘 이상있을 수 있으며 이것이 바로 그 방법입니다. Test :: Builder 기반 모듈을 테스트하는 경우 &lt;code&gt;new()&lt;/code&gt; 대신 이것을 사용할 수 있지만 그렇지 않으면 &lt;code&gt;new&lt;/code&gt; 를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="eaf90bfe09c59916d02cd27cf9c5113342a8704b" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a981471d54adab918cf9e98c713f3fa8b6a31b7" translate="yes" xml:space="preserve">
          <source>Okay, concision isn't a buzzword. But it should be, so I decree that as a new buzzword, &quot;concision&quot; means that simple common things should be expressible in very few lines (or maybe even just a few characters) of code -- call it a special case of &quot;making simple things easy and hard things possible&quot;, and see also the role it played in the MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">당신이 주장한다면 : &quot;내부 형식&quot;은 UTF-8이 아닌 utf8입니다. (다른 인코딩이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="c04bc9d828571306fd8ab607e050385638b7b499" translate="yes" xml:space="preserve">
          <source>Olaf Alders &amp;lt;olaf@wundersolutions.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">오래된 바이트 지향 프로그램은 적절한 경우 새 문자 지향 데이터 작업을 마술처럼 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">이전 바이트 지향 프로그램은 작업에 사용했던 이전 바이트 지향 데이터를 자발적으로 중단해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cdcb679c21ad16ffb1a74358af64068b9c8c43d4" translate="yes" xml:space="preserve">
          <source>Old package separator used in string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">새 실행 파일이 실행 중일 때 이전 perl 실행 파일이 시작되었습니다. 이전 실행 파일 (ouph!) 용으로 컴파일 된 확장이로드되었습니다. 이 경우 이전 실행 파일은 이전 perl DLL 대신 전달자 DLL을 가져 오므로 새 perl DLL과 연결됩니다. 직접 치명적이지는 않지만 새 실행 파일과 동일하게 작동합니다. 이것은 이전 실행 파일을 명시 적으로 시작하는 전체 목적을 능가합니다.</target>
        </trans-unit>
        <trans-unit id="fc1b9547dcacdd8deb0b3a992300248da0a808c5" translate="yes" xml:space="preserve">
          <source>Old versions need to directly access Test::Builder singleton hash elements. The latest version on CPAN will still do this on old Test::Builder, but will defer to &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt; on Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e1c2932ecab8fa2b7abd4c5ef42f132f0546a7" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but have a minor test name behavior that breaks with Test2. Old versions will no longer install because of this. The latest version on CPAN will install just fine. Upgrading is not required, but is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686b6b48ccfd93fda8d202b7ab00cb50bff77185" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but would not install because &lt;a href=&quot;Test::Aggregate&quot;&gt;Test::Aggregate&lt;/a&gt; was in the dependency chain. An upgrade should not be needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">구식 대 신식 블록 이름</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">오래된 문서 (및 일부 CPAN 모듈)는 특히 생성자에 대해이 구문을 권장하므로 여전히 야생에서 찾을 수 있습니다. 그러나 새 코드에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="74bfa7b0d7fbfaf100a04613f263acdd445ac2c9" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing  (space) or any character from the set &lt;code&gt;!#%&amp;amp;'()*;&amp;lt;=&amp;gt;?&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">VOS의 이전 릴리스 (OpenVOS 릴리스 17.0 이전)는 파일 이름을 32 자 이하로 제한하고 파일 이름이 &lt;code&gt;-&lt;/code&gt; 문자로 시작하는 것을 금지하고 파일 이름이 문자와 일치하는 문자를 포함하지 못하게합니다 &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">예를 들어, 오래된 번역가는 L &amp;lt;&amp;gt; 링크 주위에 단어를 추가하여 L &amp;lt; &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 가 &quot;Foo :: Bar 맨 페이지&quot;가 ​​될 수 있습니다. 따라서 번역 된 문서를 현명하게 읽으려면 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; 과 같은 것을 쓰면 안됩니다 . 대신 &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 를 작성하여 링크가 어떻게 나오는지 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="14a3863272e849d79d3bd80306df053765edc2b6" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt;, to control how the link comes out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">CPAN.pm의 이전 버전은 빌드 디렉토리에있는 모든 tarball의 원래 루트 디렉토리를 가졌습니다. 이제이 디렉토리 이름에 항상 임의의 문자가 추가됩니다. 왜 이렇게 되었습니까?</target>
        </trans-unit>
        <trans-unit id="0de4f0e8390c99f19bd133eee1f9e0b1e299d545" translate="yes" xml:space="preserve">
          <source>Older versions of perl may have security vulnerabilities, some of which are serious (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; and search &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=Perl&quot;&gt;CVEs&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">이 문서의 이전 버전 에서는 이러한 경우에 &lt;code&gt;void&lt;/code&gt; 반환 값 을 사용하는 것이 좋습니다 . 이것이 XSUB가 발생했을 때 이것이 segfaults로 이어질 수 있다는 것이 발견되었습니다</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="c1039769adff260cb2734954cd648c56f4365afe" translate="yes" xml:space="preserve">
          <source>Olivier Mengu&amp;eacute; &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">올리비에 멘그</target>
        </trans-unit>
        <trans-unit id="0aa942a536d7cded5f6fc6f8772142dfcfdb221f" translate="yes" xml:space="preserve">
          <source>Olivier Mengue &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">.xs 파일에서 &lt;code&gt;constant()&lt;/code&gt; 를 생략 하고 .pm 파일에서 해당하는 특수 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 생략 하십시오.</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">모든 자동로드 기능을 생략하십시오. 이것은 &lt;b&gt;-c&lt;/b&gt; 와 동일 하지만 .pm 파일에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; 문을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="0e2601b286234df74dc051d8e9fbf4262affc4dd" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;use AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">명확성이 손상되지 않는 한 중복 구두점을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">XS 부분을 생략하십시오. 스켈레톤 순수 Perl 모듈을 생성하는 데 사용됩니다. &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-f&lt;/code&gt; 는 내재적으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">자동 생성 된 스텁 POD 섹션을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">의 생성을 생략</target>
        </trans-unit>
        <trans-unit id="3b6794df4ab49e575f0969623fbbb9b4eead1f5f" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; section is equivalent to using an empty one, logically enough, so &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 섹션을 생략하는 것은 논리적으로 충분한 빈 섹션을 사용하는 것과 동일하므로 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 루프 맨 위에서 조건을 확인하기 위해 직접 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 섹션을 생략하는 것은 논리적으로 충분한 빈 섹션을 사용하는 것과 동일하므로 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 루프 맨 위에서 조건을 확인하기 위해 직접 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">첫 번째 인수 (입력 텍스트)를 생략하면 프로세스 &lt;code&gt;$_&lt;/code&gt; 대신됩니다. 두 번째 인수 (구분 기호 괄호)를 생략하면 &lt;code&gt;'{'&lt;/code&gt; 만 사용됨을 나타냅니다 . 세 번째 인수 (접두사 인수)를 생략하면 시작시 선택적 공백이 나타납니다. 네 번째 인수 (가장 바깥 쪽 구분 기호 괄호)를 생략하면 두 번째 인수의 값이 가장 바깥 쪽 구분 기호에 사용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="650eb97953ce5c6e07ebcb4164c35bedbbc7ac72" translate="yes" xml:space="preserve">
          <source>On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX) limit. On 32bit systems also strings between I32 and U32 (2G-4G). Since Storable 3.00 (not in perl5 core) we are able to store and retrieve these objects, even if perl5 itself is not able to handle them. These are strings longer then 4G, arrays with more then 2G elements and hashes with more then 2G elements. cperl forbids hashes with more than 2G elements, but this fail in cperl then. perl5 itself at least until 5.26 allows it, but cannot iterate over them. Note that creating those objects might cause out of memory exceptions by the operating system before perl has a chance to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">xlC를 사용하는 AIX 4.2에서는 다음을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">vac을 사용하는 AIX 4.3에서는 다음을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="eeac3c2c2feb8a620697ff4a8d972aa2a092d986" translate="yes" xml:space="preserve">
          <source>On AIX, is &lt;code&gt;.exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f8078cc0b8af6aad63b15eccc9063b75b69a03" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">ASCII 플랫폼에서 위 목록의 결과 문자는 완전한 ASCII 컨트롤 세트입니다. EBCDIC 플랫폼에서는 그렇지 않습니다. ASCII와 EBCDIC 플랫폼의 차이점에 대한 자세한 내용은 &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic의 운영자 차이점&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">ASCII로 인코딩 된 플랫폼에서 다음을 사용하여 인쇄 가능 세트 외부의 문자를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">DOS와 유사한 플랫폼에서 프로그램에 디렉토리 구분 기호가 포함되어 있지 않으면 PATH에서 검색하기 전에 현재 디렉토리에서 먼저 검색됩니다. 유닉스 플랫폼에서 프로그램은 PATH에서 엄격하게 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="2f93d8018989db4b239468fb46d0cdba5c2f0db5" translate="yes" xml:space="preserve">
          <source>On DOS/Windows like architectures where this layer is part of the defaults, it also acts like the &lt;code&gt;:perlio&lt;/code&gt; layer, and removing the CRLF translation (such as with &lt;code&gt;:raw&lt;/code&gt;) will only unset the CRLF translation flag. Since Perl 5.14, you can also apply another &lt;code&gt;:crlf&lt;/code&gt; layer later, such as when the CRLF translation must occur after an encoding layer. On other architectures, it is a mundane CRLF translation layer and can be added and removed normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">DOSISH 시스템에서 백 슬래시는 유효한 디렉토리 구분 문자입니다. 이 경우, GLOB_QUOTE를 통해 인용 문자로 백 슬래시를 사용하면 디렉토리 분리 자로 백 슬래시를 사용하는 데 방해가됩니다. 가장 간단하고 휴대하기 쉬운 솔루션은 디렉토리 구분 기호에 슬래시를 사용하고 인용에 백 슬래시를 사용하는 것입니다. 그러나이 시스템에서 &quot;일반적인 방법&quot;과 일치하지 않습니다. 따라서 사용자 기대에 대한 양보로 백 슬래시 (GLOB_QUOTE 하에서)는 glob 메타 문자 '[', ']', '{', '}', '-', '~'및 백 슬래시 자체 만 인용합니다. 다른 모든 백 슬래시는 변경되지 않은 채 통과합니다.</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">EBCDIC 플랫폼에서 라틴 1 문자 세트의 문자는 리터럴 UTF-EBCDIC 문자의 일부로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e55bcfcaea4d3f5091519d63553b94250f256406" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower than on ASCII. Prior to that, code points 2**31 and higher were simply unrepresentable, and a different, incompatible method was used to represent code points between 2**30 and 2**31 - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6112256ee63f46a5e15ec3716f73262824a70fb0" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, code points above 0x3FFF_FFFF have a different representation in Perl v5.24 than before, so any file containing these that was written before that version will require conversion before being readable by a later Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">v5.22 이전의 EBCDIC 플랫폼에서 &lt;code&gt;\N{U+...}&lt;/code&gt; 사용하면 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">EBCDIC 플랫폼에서 내부 유니 코드 인코딩 양식은 UTF-8 대신 UTF-EBCDIC입니다. 차이점은 ASCII 문자는 그대로 UTF-8로 인코딩한다는 점에서 UTF-8은 &quot;ASCII-safe&quot;이므로 UTF-EBCDIC는 &quot;EBCDIC-safe&quot;이며 모든 기본 문자 (모든 문자 포함)는 ASCII 등가 (예 : &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="69ff29e47116562e384d48eb5aae2111322261e8" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">Linux에서 perl v5.14.0부터 레거시 프로세스 이름은 &lt;code&gt;prctl(2)&lt;/code&gt; 로 설정되며 , perl이 4.000 이후로 수행 된 것처럼 &lt;code&gt;argv[0]&lt;/code&gt; 을 통해 POSIX 이름을 변경합니다 . 이제 ps, top 및 killall과 같은 레거시 프로세스 이름을 읽는 시스템 유틸리티는 &lt;code&gt;$0&lt;/code&gt; 할당 할 때 설정 한 이름을 인식합니다 . 제공하는 문자열은 16 바이트에서 잘립니다. 이는 Linux에서 부과하는 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="971443928989b7bee0ac0a568694348131be6843" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt;, in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt;. The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">MSWin32에서 각 스레드는 자체 환경 변수 집합을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">MSWin32에서 각 스레드는 고유 한 현재 작업 디렉토리 설정을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="23b53b159dd238a66ca7c109ea8e5776a37bac8e" translate="yes" xml:space="preserve">
          <source>On Mac OS X the file system encoding is always UTF-8 while the locale can otherwise be set up as normal for POSIX systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">Mac OS에서 $ no_file이 true이거나 후미 구분 기호 &quot;:&quot;가 없으면 경로의 마지막 부분은 파일 이름 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">Mac OS에서는 수행 할 작업이 없습니다. 주어진 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">OS / 390 또는 z / OS에서</target>
        </trans-unit>
        <trans-unit id="5637d80de5f3ae2f3a457607d81fcd5653f85175" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the &lt;a href=&quot;http://man.he.net/man1/iconv&quot;&gt;iconv(1)&lt;/a&gt; manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">임시 파일을 닫을 때 임시 파일이 자동으로 제거되는 OS에서이 함수를 호출하면 임시 디렉토리 (임시 파일을 포함 할 수 있음)를 제거하는 것 외에 다른 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">PA-RISC에서는 32 비트 응용 프로그램과 64 비트 응용 프로그램을위한 다른 컴파일러가 필요합니다. PA-RISC에서 32 비트 개체와 64 비트 개체는 혼합되지 않습니다. 기간. HP C-ANSI-C 또는 GNU gcc에는 다른 동작이 없습니다. 따라서 Oracle 64 비트와 같은 64 비트 라이브러리를 사용하기 위해 perl 바이너리가 필요한 경우 64 비트 perl을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9150346abbcb79f7b8cfc1b292f802424998448" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;&quot;MAKE&quot;&lt;/a&gt; parameter for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">POSIX 시스템에서 해당 프로그램은 GNU Make 일 것입니다. Microsoft Windows에서는 Microsoft NMake, DMake 또는 GNU Make입니다. 자세한 내용은 &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; 매개 변수 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="167592a5236c1f91d56ed9f91f8821eeb4df3832" translate="yes" xml:space="preserve">
          <source>On Perl 5.10 and above, using smart-match (&lt;code&gt;~~&lt;/code&gt;) with an &lt;code&gt;autodie::exception&lt;/code&gt; object will use &lt;code&gt;matches&lt;/code&gt; underneath. This module used to recommend using smart-match with the exception object on the left hand side, but in future Perls that is likely to stop working. The smart-match facility of this class should only be used with the exception object on the right hand side. Having the exception object on the right is both future-proof and portable to older Perls, back to 5.10. Beware that this facility can only be relied upon when it is certain that the exception object actually is an &lt;code&gt;autodie::exception&lt;/code&gt; object; it is no more capable than an explicit call to the &lt;code&gt;matches&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">5.7 이전의 Perl 버전에서는 255 이상의 값을 가진 유니 코드 문자 (예 : 람다 또는 엠 대시)를 전달할 수 없습니다. 이 모듈은 초기 Perl 버전에서 작동하지만 이러한 각 문자 대신 &quot;?&quot;가 표시됩니다. 라틴 -1 문자 (문자 160-255)는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">길에서</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">유닉스에서는 이러한 호출이 아무 효과가 없습니다. 다른 곳에서는 &quot;\ n&quot;을 CR, LF로 변경하고 특수한 텍스트 &quot;파일 끝&quot;표시기를 읽거나 읽을 때 표시 될 수 있습니다. 핸들에 IO를 수행 한 후 호출하는 효과는 구현에 따라 다릅니다. (이는 무시되거나 이미 버퍼링 된 데이터에 영향을 주거나 후속 데이터에만 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">유닉스에서는</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">기본적으로 VMS에서 펄이 종료 된 후에도 % ENV 해시에 대한 변경 사항이 유지됩니다. 동일한 프로세스에서 이후에 perl을 호출하면 일시적인 환경 설정을 실수로 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a7f6210c11a8722ba30917e3753a6ae39f636f9" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">VMS에서만 레코드 읽기가 PerlIO 레이어 및 연관된 버퍼링을 무시하므로 동일한 파일 핸들에서 레코드 및 비 레코드 읽기를 혼합해서는 안됩니다. 레코드 모드는 동일한 버퍼링 레이어가 두 모드에 모두 사용중인 경우에만 라인 모드와 혼합됩니다.</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">VMS 시스템에서 환경 변수에 연결된 어레이는 읽기 전용입니다. 무엇이든 변경하려고하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74564fe6ae7ff11070f358853ddf9ff8e6cf5db3" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;a href=&quot;perlfunc#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">VMS에서 perl은 &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 논리 이름 으로부터 UTC 오프셋을 결정합니다 . VMS 시대는 17-NOV-1858 00 : 00 : 00.00에 시작되었지만 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 으로의 호출 은 Unix와 마찬가지로 01-JAN-1970 00 : 00 : 00.00부터 오프셋을 계산하도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="06a156290eaf8bb336152c15b3a6a3f335cfb709" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt;, &lt;code&gt;$ENV{TERM}&lt;/code&gt;, &lt;code&gt;$ENV{PATH}&lt;/code&gt;, and &lt;code&gt;$ENV{USER}&lt;/code&gt;, are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">VMS에서 &lt;code&gt;%ENV&lt;/code&gt; 해시 의 일부 항목은 키가 이전에 존재하지 않은 경우 읽기에 사용될 때 동적으로 작성됩니다. 에 대한 값 &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; 및 &lt;code&gt;$ENV{USER}&lt;/code&gt; , 동적으로 생성되는 것으로 알려져있다. 동적으로 생성되는 특정 이름은 VMS의 C 라이브러리 버전에 따라 다를 수 있으며 문서화 된 것보다 더 많이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">볼륨 개념이있는 VMS에서 VMS 파일 스펙이 절대 UNIX 형식으로 변환되고 볼륨 정보가 투명하게 포함되므로이 필드는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">VOS에서 시간 값은 32 비트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">Win32에서 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 는 파일을 열어서 링크 수를 결정하고 하드 링크를 통해 변경되었을 수있는 속성을 업데이트해야합니다. &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; true 값으로 설정하면 이 작업을 수행하지 않아 stat () 속도가 빨라집니다 . (Win32)</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">Win32 플랫폼에서</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">Win32 포트에서만 Perl이 &quot;backtick&quot;명령 또는 system ()을 실행하기 위해 내부적으로 사용해야하는 대체 쉘로 설정 될 수 있습니다. WindowsNT의 경우 기본값은 &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; 이고 Windows95의 경우 &lt;code&gt;command.com /c&lt;/code&gt; 입니다. 값은 공백으로 분리 된 것으로 간주됩니다. 공백이나 백 슬래시와 같이 보호해야하는 모든 문자 앞에 다른 백 슬래시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">Win32에서이 릴리스 (5.14)의 기본값은 &quot;unix crlf&quot;입니다. Win32의 &quot;stdio&quot;에는 C 컴파일러의 버전과 공급 업체에 따라 다소 다른 Perl IO에 대한 여러 가지 버그 / 미스 기능이 있습니다. 자체 &lt;code&gt;crlf&lt;/code&gt; 레이어를 버퍼로 사용하면 이러한 문제를 피하고 일을 더 균일하게 만들 수 있습니다. &lt;code&gt;crlf&lt;/code&gt; 층도 버퍼링 CRLF로 변환을 제공한다.</target>
        </trans-unit>
        <trans-unit id="c5cad1f19297cc76fd2c0f0cbe96d6c8b8641a99" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.30) is &quot;:unix:crlf&quot;. Win32's &quot;:stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;:crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b57948ea68a275535d9745ad7c79b49f92a2345" translate="yes" xml:space="preserve">
          <source>On Win32, is &lt;code&gt;.def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">WinNT에서 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 은 파일의 사용자 및 그룹 ID를 변경할 수 있습니다. 보안 모델이 없기 때문에 Win9x에서 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f45342ed2b9a9fadda985a145ee379fe5a5018" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;chown()&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;chown()&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2723b9ca133f3aa539e50122b610714bafdb1670" translate="yes" xml:space="preserve">
          <source>On Windows NT 4 SP6 and later this function returns the following additional values: SPMAJOR, SPMINOR, SUITEMASK, PRODUCTTYPE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a917d2cc116f1698163f4d2d945df6a75555b19b" translate="yes" xml:space="preserve">
          <source>On Windows and DOS, this class will not modify any environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">Windows에서 URI가 네트워크 공유 인 경우이 값은 비어있을 수 있으며이 경우 'share'속성이 정의됩니다. 또한 '|'를 사용하는 볼륨 사양 ':'을 사용하도록 ':'을 읽을 때 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="98136ca8ec46fb8ca78cee1f5eedf07f7ec52018" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Errno&lt;/code&gt; also defines and conditionally exports all the Winsock error constants defined in your system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">Windows에서 &lt;code&gt;make_path&lt;/code&gt; 가이 경고를 표시하면 파일 시스템의 최대 경로 길이를 초과했음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windows에서는 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 간접 오브젝트 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 는 하나 이상의 요소가 있더라도 첫 번째 스폰이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windows에서는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 간접 오브젝트 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 는 하나 이상의 요소가 있더라도 첫 번째 스폰이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7e1ef63036ab0ac76882604ffa03e365a2cc3538" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;exec LIST&lt;/code&gt;, even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aceed2ebeb2b1d6033e61b3459bb2d4bb7870fd" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt; 모듈을 사용할 수 있습니다 . 영향을 줄 출력 파일 핸들에 대한 객체를 만든 후 &lt;code&gt;Cls&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">64 비트 &lt;code&gt;perl&lt;/code&gt; 에서는 실제로 오래 실행되는 프로젝트에 대해 더 큰 날짜를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1241860881c4ad85f6cc345b32d854e56c75ec64" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt;, you can get even larger dates for those really long running projects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df92a12e7efed4b5a0ee3432bfa643483f4e66b5" translate="yes" xml:space="preserve">
          <source>On a Perl built without &lt;code&gt;-DDEBUGGING&lt;/code&gt;, or when the &lt;code&gt;-Di&lt;/code&gt; command-line switch is not specified, or under taint, PerlIO_debug() is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">유닉스 계열 시스템에서 이러한 문서 파일은 일반적으로 맨 페이지로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">이진 문자열에서는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">새로 설치하는 경우 &quot;C : \ Windows CE Tools&quot;입니다. 파일 관리자에서 &quot;C : \ Windows CE Tools&quot;로 이동하여 디스크에 &quot;C : \ Windows CE Tools \ wce400 \ STANDARDSDK \ Include \ Armv4&quot;가 있는지 확인하십시오. 그렇지 않으면 SDKROOT를 &quot;C : \ Program Files \ Windows CE Tools&quot;로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">관련 메모에서 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 하는 경우 &lt;code&gt;*PUSH*&lt;/code&gt; 매크로가 로컬 변수 &lt;code&gt;TARG&lt;/code&gt; 를 사용할 수 있도록 변수 선언에 &lt;code&gt;dTARG&lt;/code&gt; 가 필요합니다 . &lt;code&gt;dTARGET&lt;/code&gt; 및 &lt;code&gt;dXSTARG&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75330f133f27aefde9a996a79a95540c06e5ca79" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt;. See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8ad329e5099ea252a3ca17c446006da287d9da" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; verb below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">성공적으로 일치하면 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 FALSE로 설정되고 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 마지막으로 실행 된 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 패턴 의 이름으로 설정됩니다 . 자세한 내용은 아래 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 동사에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">텍스트 문자열에서 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">MSWin32를 제외한 모든 플랫폼에서 현재 작업 디렉토리에 대한 설정은 모든 스레드간에 공유되므로 한 스레드에서 변경 (예 : &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; )하면 응용 프로그램의 모든 스레드에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="ab64dc72a66da50a5cd3f10fe53225e1e0e96f58" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;chdir()&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">릴리스 된 모든 Solaris (8, 9 및 10) 버전에서 다음 패키지가 설치되어 있는지 확인해야합니다 (이 정보는 Solaris FAQ에서 추출 됨).</target>
        </trans-unit>
        <trans-unit id="0adaab19e480042e586e12a800bf5b600ec97adc" translate="yes" xml:space="preserve">
          <source>On an exception during the execution of the request, the &lt;code&gt;status&lt;/code&gt; field will contain 599, and the &lt;code&gt;content&lt;/code&gt; field will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2b4cb070056fb4070c425608e71d9f9a08f8e3" translate="yes" xml:space="preserve">
          <source>On both platforms, ASCII and EBCDIC, &lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt; is set if Perl extended UTF-8 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">Win32, OS / 2, VMS 및 AIX와 같은 특정 플랫폼에서는 링커를 호출하기 전에 몇 가지 조치를 수행해야합니다. &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 모듈은이 작업을 수행, 동적 확장을위한 공유 라이브러리를 작성하는 동안 링커가 사용하는 파일을 작성. 작성된 파일 이름은 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="68f10a6e0b39851d70a2411f9d6927ec33bc1d28" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different in Windows. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">Windows와 같은 특정 플랫폼에서 stat ()에 의해 반환 된 모든 필드를 비교할 수있는 것은 아닙니다. 예를 들어 C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새 메시지 대기열을 만들 때 &lt;code&gt;FLAGS&lt;/code&gt; 를 사용하여 권한을 설정합니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새 세마포어 세트를 작성할 때 &lt;code&gt;FLAGS&lt;/code&gt; 는 권한을 설정하는 데 사용됩니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새로운 공유 메모리 세그먼트를 만들 때 &lt;code&gt;FLAGS&lt;/code&gt; 를 사용하여 권한을 설정합니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO 레이어 및 PerlIO의 루트 온 디맨드 로더 :: * 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">각 줄에는 같은 일을하는 두 가지 표현이 있습니다. 왼쪽 버전은 &lt;code&gt;@a&lt;/code&gt; 배열에서 작동합니다 . 오른쪽 버전은 &lt;code&gt;$aref&lt;/code&gt; 참조되는 배열에서 작동합니다 . 그들이 작동하는 어레이를 찾으면 두 버전 모두 어레이와 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8897d9218b422eeafd07a396a29ac11d0861b3d9" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt;. The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt;. Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">입국시</target>
        </trans-unit>
        <trans-unit id="5332f588a30c3ea7aadbd06e40cead0c170fd4cf" translate="yes" xml:space="preserve">
          <source>On entry &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;*len_p&lt;/code&gt; give the string to scan, &lt;code&gt;*flags&lt;/code&gt; gives conversion flags, and &lt;code&gt;result&lt;/code&gt; should be &lt;code&gt;NULL&lt;/code&gt; or a pointer to an NV. The scan stops at the end of the string, or at just before the first invalid character. Unless &lt;code&gt;PERL_SCAN_SILENT_ILLDIGIT&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt;, encountering an invalid character (except NUL) will also trigger a warning. On return &lt;code&gt;*len_p&lt;/code&gt; is set to the length of the scanned string, and &lt;code&gt;*flags&lt;/code&gt; gives output flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567461856d5e115d2b80a7fd737da1ad14817617" translate="yes" xml:space="preserve">
          <source>On entry, &lt;code&gt;pv&lt;/code&gt; points to the beginning of the string; &lt;code&gt;valptr&lt;/code&gt; points to a UV that will receive the converted value, if found; &lt;code&gt;endptr&lt;/code&gt; is either NULL or points to a variable that points to one byte beyond the point in &lt;code&gt;pv&lt;/code&gt; that this routine should examine. If &lt;code&gt;endptr&lt;/code&gt; is NULL, &lt;code&gt;pv&lt;/code&gt; is assumed to be NUL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bacb97a5d2d18dbb756caabc159aefdc9b27f2c" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; behaves just like &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt;: it returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a23d955ecebada1fa25792c21efad58d10123ee" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;$out&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 는 select (2)와 동일하게 작동합니다. -1을 반환하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! .</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하면 제거 할 수없는 파일이 표시되지 않습니다. 제거 할 수없는 파일을 알려면 한 번에 하나씩 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 는 select (2)와 동일하게 작동합니다. -1을 반환하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! .</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하면 제거 할 수없는 파일이 표시되지 않습니다. 제거 할 수없는 파일을 알려면 한 번에 하나씩 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">실패시 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴되고 &lt;code&gt;$@&lt;/code&gt; 에 실패 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="50989ddb0a8dea38dc2bf4fcec10e5e4fe7a2870" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;undef&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">실패시 $ decoder는 이제 오류 메시지를 포함하므로 전체 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2a12adff03571a4d3b5aeaef29c5800c5825559" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;fileLastError()&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0d12758631e756bc101c1b7dbd8f7f1bdeb657" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;regLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실패하면,이 모든 값 (나머지 텍스트 제외)은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65448e86201e7fdba6e3baaecf1b7bd6e213136d" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fcaac32326ffae83caa0ffe515456c5f51d0d" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">실패시 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 동사가 일치 실패와 관련이있는 경우 동사 패턴의 ARG 값으로 설정됩니다. 패턴의 ARG 부분이 생략 된 경우, &lt;code&gt;$REGERROR&lt;/code&gt; 는 마지막으로 실행 된 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 패턴 의 이름으로 설정 되거나,없는 경우 TRUE로 설정됩니다. 또한 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 FALSE로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">실패시, &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출은 정의되지 않은 값을 반환하고 아마도 &lt;code&gt;$!&lt;/code&gt; 파일을 묶을 수없는 이유를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d91548debf2b08e67d7bcf23bbc8c0787287ca77" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;tie&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">입력시, 지정된 문자 세트 및 인코딩에있을 것으로 예상되는 바이트를 Perl 문자열 데이터 (유니 코드 및 Perl의 내부 유니 코드 인코딩, UTF-8)로 변환합니다. 출력시, Perl 문자열 데이터를 지정된 문자 세트 및 인코딩으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="bbed2b20ba397a052877c8697b2b911fb1c6434c" translate="yes" xml:space="preserve">
          <source>On merging and rebasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31535bab82f01485bf978083451a0bfcdeb0cd1c" translate="yes" xml:space="preserve">
          <source>On modern Linux systems these are typically GDBM files, which are not portable across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">대부분의 Unix 플랫폼에서 &lt;code&gt;CHLD&lt;/code&gt; (때로는 &lt;code&gt;CLD&lt;/code&gt; 라고도 함 ) 신호는 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 값과 관련하여 특별한 동작을합니다 . 설정 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 에 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 부모 프로세스가 실패 할 때와 같은 플랫폼에서하는 좀비 프로세스를 생성하지 않는 효과가있다 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 자식 프로세스에 (즉, 자식 프로세스가 자동으로 수확된다). &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 가 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 로 설정된 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출 &lt;code&gt;-1&lt;/code&gt; 일반적 으로 이러한 플랫폼에서 -1이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="42dd9a903659956c4b893b1487852dbdc8ae83fe" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt;) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;wait()&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;wait()&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">대부분의 운영 체제에서 프로그램에 할당 된 메모리는 시스템으로 반환 될 수 없습니다. 그렇기 때문에 장기 실행 프로그램이 때때로 스스로 실행됩니다. 일부 운영 체제 (특히 대용량 메모리 할당에 mmap (2)를 사용하는 시스템)는 더 이상 사용되지 않는 메모리를 회수 할 수 있지만 이러한 시스템에서는 perl이 아닌 OS malloc을 사용하도록 perl을 구성하고 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ddf61a72a0a9ae32d8b7111f593a7bce6fa31c0" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;Thread::Queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">대부분의 시스템에서 스레드를 빈번하고 지속적으로 작성 및 제거하면 Perl 인터프리터의 메모리 사용량이 계속 증가 할 수 있습니다. 스레드를 시작한 다음 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 하는 것이 간단하지만 수명이 긴 응용 프로그램의 경우 스레드 풀을 유지 관리하고 &lt;a href=&quot;thread/queue&quot;&gt;대기열을&lt;/a&gt; 사용하여 필요한 작업에 재사용하는 것이 좋습니다 스레드에 보류중인 작업을 통지합니다. 이 모듈의 CPAN 배포는 간단한 예를 포함합니다 (</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">대부분의 시스템에서 수퍼 유저가 아닌 경우 파일의 소유권을 변경할 수는 없지만 그룹을 보조 그룹으로 변경할 수는 있습니다. 안전하지 않은 시스템에서는 이러한 제한이 완화 될 수 있지만 이는 이식 가능한 가정이 아닙니다. POSIX 시스템에서는 다음과 같은 방법으로이 조건을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55db381aabae41a989aa28b8f5a435f2f353e7d6" translate="yes" xml:space="preserve">
          <source>On multi-threaded builds on systems that do have per-thread locale operations, this function converts the thread it is running in to use the global locale. This is for code that has not yet or cannot be updated to handle multi-threaded locale operation. As long as only a single thread is so-converted, everything works fine, as all the other threads continue to ignore the global one, so only this thread looks at it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">최신 64 비트 버전의 OpenVMS에서 이제 프로세스 설정은 명령 행 인수의 대소 문자를 보존하기 위해 인용이 필요한지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">이전 버전의 perl에서는 POSIX 표준에서 공식적으로 지원하지 않는 음의 에포크 ( &lt;code&gt;time_t&lt;/code&gt; ) 값이 일부 시스템에서 작동하지 않는 것으로 알려져 있습니다. 여기에는 MacOS (pre-OSX) 및 Win32가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ddfc76c9171838788051ad1318da16d035f5b0fe" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt;) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">볼륨 개념이있는 운영 체제에서 file : //의 두 번째 요소는 파일의 볼륨 스펙으로 간주됩니다. 따라서 Win32에서이 루틴은 볼륨을 반환하고 다른 운영 체제에서는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">펄 버전 5.12.0 이상에서는 음의 에포크 값이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">5.12.0 이전의 perl 버전에서 실제로 처리 할 수있는 날짜 범위 는 주어진 플랫폼 의 &lt;code&gt;time_t&lt;/code&gt; (보통 부호있는 정수) 의 크기에 따라 다릅니다 . 현재 이것은 대부분의 시스템에서 32 비트이며 1901 년 12 월부터 2038 년 1 월까지의 대략적인 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">&lt;code&gt;need_prelink()&lt;/code&gt; 가 true를 반환하는 플랫폼에서는 &lt;code&gt;prelink()&lt;/code&gt; 가 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">중요한 플랫폼에서는 Storable 함수에 전달하는 설명자에서 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="393fb98f717dd89ac6a03e530e4afbcbe5a39830" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;binmode()&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">C99 이전의 컴파일러에서 &lt;code&gt;bool&lt;/code&gt; 은 &lt;code&gt;char&lt;/code&gt; 와 동등한 것으로 정의됩니다 . 따라서 더 큰 유형의 &lt;code&gt;bool&lt;/code&gt; 할당하는 것은 안전하지 않으며 잘릴 수 있습니다. &lt;code&gt;cBOOL&lt;/code&gt; 의 매크로 제대로 캐스팅 존재한다.</target>
        </trans-unit>
        <trans-unit id="96fc20ca3129c68549ac1ab95e6fa005be780a85" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt;. Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly; you may also find that using it is shorter and clearer than writing out the equivalent conditional expression longhand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">드문 경우이지만 데이터베이스 읽기와 같이 디코딩해야하는 인코딩 된 텍스트가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">리턴시 참조는 * some_hash typeglob에 의해 지정된 기호 테이블의 해시 슬롯을 겹쳐 씁니다. 변수를 명시 적으로 역 참조하는 것을 기억하고 싶지 않을 때 참조를 저렴하게 전달하는 다소 까다로운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">패턴 &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; 과 같은 간단한 그룹에서는 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; 와 같이 부정적인 미리보기로 비슷한 효과를 얻을 수 있습니다 . 이것은 1000000 &lt;code&gt;a&lt;/code&gt; 의 문자열에서 단지 4 배 느 렸습니다 .</target>
        </trans-unit>
        <trans-unit id="85475d75a07389a71a82f474a6904ca008087309" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative lookahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;&quot;a&quot;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">일부 운영 체제 (모두는 아님)에서 &lt;code&gt;$0&lt;/code&gt; 할당 하면 &lt;code&gt;ps&lt;/code&gt; 프로그램이 보는 인수 영역이 수정 됩니다. 일부 플랫폼 에서는 변경 사항을 확인 하기 위해 특별한 &lt;code&gt;ps&lt;/code&gt; 옵션이나 다른 &lt;code&gt;ps&lt;/code&gt; 를 사용해야 할 수도 있습니다 . &lt;code&gt;$0&lt;/code&gt; 수정하면 실행중인 프로그램을 숨기는 것보다 현재 프로그램 상태를 나타내는 방법으로 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">일부 OS의 경우. VERSION_SYM 대신 VERSION 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f9bf6c90ba9706d9e17b2321836d771bd8fd28" translate="yes" xml:space="preserve">
          <source>On some Unixes, &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; would block. This can be avoided if you always use &lt;code&gt;O_NONBLOCK&lt;/code&gt; on the socket. See &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; and &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">일부 유닉스에서는 select (2)가 사용할 수있는 데이터가 없어도 소켓 파일 디스크립터를 &quot;읽을 수있는 상태&quot;로보고 할 수 있으므로 이후의 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 차단됩니다. 소켓에서 항상 O_NONBLOCK을 사용하면 피할 수 있습니다. 자세한 내용은 select (2) 및 fcntl (2)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">일부 유닉스에서는 select (2)가 사용할 수있는 데이터가 없어도 소켓 파일 디스크립터를 &quot;읽을 수있는 상태&quot;로보고 할 수 있으므로 이후의 &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 차단됩니다. 소켓에서 항상 O_NONBLOCK을 사용하면 피할 수 있습니다. 자세한 내용은 select (2) 및 fcntl (2)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5313472f5f477e89baab3e33db4f6dd3bf9c900" translate="yes" xml:space="preserve">
          <source>On some older low-end devices -- think early 2.2 era -- some tests, particularly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">일부 구형 시스템에서는 시간을 계산하는 방법에 따라 요청한 것보다 최대 1 초 이하로 절전 모드로 전환 될 수 있습니다. 대부분의 최신 시스템은 항상 최대량을 사용합니다. 그러나 바쁜 멀티 태스킹 시스템에서 프로세스가 바로 예약되지 않았기 때문에 그보다 더 오래 잠자기 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">일부 운영 체제에서 특정 신호 핸들러는 리턴하기 전에 &quot;무엇을 수행&quot;해야합니다. 자식 프로세스가 완료되었음을 나타내는 CHLD 또는 CLD가 한 가지 예입니다. 일부 운영 체제에서 신호 핸들러는 완료된 하위 프로세스 를 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 것으로 예상됩니다 . 이러한 시스템에서는 지연된 신호 체계가 해당 신호에 대해 작동하지 않습니다 . &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 하지 않습니다 . 아직 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 하지 않은 하위 프로세스가 완료되었으므로 운영 체제가 신호를 다시 발행하므로 실패는 루프처럼 보입니다 .</target>
        </trans-unit>
        <trans-unit id="4baadfb850b3b420c9f511f27da50a1880c9c102" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;wait&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;wait&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;wait&lt;/code&gt;ed for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">Win32와 같은 일부 운영 체제에서는 재부팅이 발생할 때까지 설치가 불가능할 수 있습니다. 오래된 DLL을 제거해도 새로운 DLL을 사용하는 프로그램에는 영향을 미치지 않지만 재부팅 할 때까지 새 DLL을 제대로 설치할 수없는 경우 대기해야합니다. 패키지 변수</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">일부 운영 체제, 특히 Solaris 및 Unixware 에서 하위 프로세스에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 상위에서 열린 파일 핸들을 플러시하고 닫아 파일 핸들이 손상됩니다. 이러한 시스템에서는 대신 &lt;code&gt;_exit()&lt;/code&gt; 호출하는 것이 좋습니다. &lt;code&gt;_exit()&lt;/code&gt; 는 &lt;code&gt;POSIX&lt;/code&gt; 모듈을 통해 Perl에서 사용 가능 합니다. 이에 대한 자세한 내용은 시스템 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78cb1737975a62fce19002f1001d673ccd249508" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;exit()&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">일부 플랫폼 (특히 DOS와 같은 플랫폼)에서 쉘은 여러 줄 명령을 처리하지 못할 수 있으므로 문자열에 줄 바꿈을 넣으면 원하는 결과를 얻지 못할 수 있습니다. 쉘이 지원하는 경우 명령 구분 문자 (예 : &lt;code&gt;;&lt;/code&gt; 많은 Unix 쉘 및 &lt;code&gt;&amp;amp;&lt;/code&gt; Windows NT &lt;code&gt;cmd&lt;/code&gt; 쉘) 로 분리하여 여러 명령을 한 줄로 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">일부 플랫폼에서 Perl은 C 레벨 역 추적 (gdb와 같은 기호 디버거와 유사한) 검색을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f4483b458e9a6174b9a55320be46bd1995517e00" translate="yes" xml:space="preserve">
          <source>On some platforms inode numbers are of a type larger than perl knows how to handle as integer numerical values. If necessary, an inode number will be returned as a decimal string in order to preserve the entire value. If used in a numeric context, this will be converted to a floating-point numerical value, with rounding, a fate that is best avoided. Therefore, you should prefer to compare inode numbers using &lt;code&gt;eq&lt;/code&gt; rather than &lt;code&gt;==&lt;/code&gt;. &lt;code&gt;eq&lt;/code&gt; will work fine on inode numbers that are represented numerically, as well as those represented as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c255f8c4da0102268758efe747d09a122b8f3a63" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 인터프리터 레벨에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 이 에뮬레이션에는 Windows에서 실행되는 코드와 이식 가능한 코드에서 고려해야 할 kill과 관련된 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 인터프리터 레벨에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 실제 fork ()와 가능한 한 호환되도록 설계되었지만, 모든 의사 자식 &quot;프로세스&quot;가 이런 방식으로 생성 된 사실에서 나온 중요한 차이점이 있습니다. 운영 체제에 관한 한 실제 프로세스.</target>
        </trans-unit>
        <trans-unit id="acf7877caa8abc5986e73b196ee16707d5ded84d" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;. However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 Perl 인터프리터에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 &quot;Unix&quot;fork ()와 최대한 호환되도록 설계되었습니다. 그러나 이식성이 뛰어난 코드에서는 고려해야 할 한계가 있습니다. 자세한 내용은 &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 Perl 인터프리터에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 &quot;Unix&quot;fork ()와 최대한 호환되도록 설계되었습니다. 그러나 이식성이 뛰어난 코드에서는 고려해야 할 한계가 있습니다. 자세한 내용은 &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">일부 플랫폼에서 결과 버퍼가 너무 작은 경우 스레드 안전 라이브러리 인터페이스가 실패 할 수 있습니다 (예를 들어, 사용자 그룹 데이터베이스가 너무 클 수 있으며 재진입 인터페이스가 해당 데이터베이스의 전체 스냅 샷을 수행해야 할 수도 있음). Perl은 작은 버퍼로 시작하지만 결과가 맞을 때까지 계속 재 시도하고 결과 버퍼를 증가시킵니다. 보안이나 메모리 소비로 인해 무한한 증가하는 소리가 &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; 를 허용 된 최대 바이트 수로 정의하여 Perl을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24484214c7713626df068fed1666abc55fb655de" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;&quot;savesharedpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서이를 수행하지 않으려면 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; 와 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0080de19b8b9cfd716de6770d48e6fe48699a889" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;&quot;savesharedpvn&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; 과 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d4da91ee61a2307a1a8d5d2d26b5d850a91c43b4" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;&quot;savesharedsvpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서이를 수행하지 않으려면 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; 와 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">Windows NT와 같은 일부 플랫폼에서는 열린 파일을 링크 해제 할 수 없습니다 (파일을 먼저 닫아야합니다). 해당 플랫폼에서 실제 연결 해제는 프로그램이 종료되고 정상 상태가 반환 될 때까지 지연됩니다. 파일 핸들과 파일 이름이 동일한 것을 가리키고 있는지 확인하기 위해 여전히 검사가 수행됩니다 (그러나 지연 제거가 파일 핸들에 액세스 할 수 없기 때문에 종료 블록이 실행될 때가 아님).</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">일부 플랫폼에서는 파괴가 불가능할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5fad4eee060ffd46b78c54eef932b8d7ced75bff" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;a href=&quot;#-Dletters&quot;&gt;-Dp&lt;/a&gt; switch to Perl shows how the search progresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">일부 플랫폼에서는 Perl을 검색하는 동안 파일 이름에 접미사를 추가 할 수도 있습니다. 예를 들어 Win32 플랫폼에서 &quot;.bat&quot;및 &quot;.cmd&quot;접미사는 원래 이름을 찾지 못하면 이름이 해당 접미사 중 하나로 끝나지 않은 경우에 추가됩니다. &lt;b&gt;DEBUGGING을&lt;/b&gt; 켠 &lt;code&gt;DEBUGGING&lt;/code&gt; Perl을 컴파일 한 경우 &lt;b&gt;-Dp&lt;/b&gt; 스위치를 Perl로 사용 하면 검색 진행 방법이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="680d4319c3ebb1bf0096b308bc1e22323b5e0529" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">일부 시스템 (일반적으로 DOS 및 Windows 기반 시스템)에서 binmode ()는 텍스트 파일로 작업하지 않을 때 필요합니다. 이식성을 위해 항상 적절한 경우에는 사용하고, 적절하지 않은 경우에는 사용하지 않는 것이 좋습니다. 또한 사람들은 기본적으로 I / O를 바이트가 아닌 UTF8로 인코딩 된 유니 코드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfca44fbb2c1ebee7c90ad249ff37ac61a808901" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with &lt;code&gt;new_from_fd&lt;/code&gt;, or created with &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; from such an object, the &lt;a href=&quot;IO::Socket#protocol&quot;&gt;&quot;protocol&quot; in IO::Socket&lt;/a&gt;, &lt;a href=&quot;IO::Socket#sockdomain&quot;&gt;&quot;sockdomain&quot; in IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Socket#socktype&quot;&gt;&quot;socktype&quot; in IO::Socket&lt;/a&gt; methods may return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">일부 시스템에서 new_from_fd ()로 작성되거나 그러한 오브젝트에서 accept ()로 작성되는 IO :: Socket 오브젝트의 경우 protocol (), sockdomain () 및 socktype () 메소드가 undef를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈의 &lt;code&gt;strftime()&lt;/code&gt; 함수는 &lt;code&gt;%C&lt;/code&gt; 형식 을 사용하기 위해 비표준 방식으로 확장되어 때로는 &quot;세기&quot;라고 주장합니다. 대부분의 그러한 시스템에서 이것은 4 자리 연도의 처음 두 자리에 불과하므로 현재 세기 나 밀레니엄을 확실하게 결정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">일부 시스템에서는 협력 및 선점 스레드가 동시에 실행될 수 있습니다. (예를 들어, 실시간 우선 순위로 실행되는 스레드는 종종 협력 적으로 동작하지만, 일반 우선 순위로 실행되는 스레드는 선제 적으로 동작합니다.)</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">일부 시스템에서는 작은 따옴표를 큰 따옴표로 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">리스트 컨텍스트에서 성공하면 3 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">리스트 컨텍스트에서 성공하면 6 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f87025d22f7460aebebdbcf7b85259c2cc5a7d3a" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">성공하면 $ decoder는 &lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding에&lt;/a&gt; 문서화 된 객체입니다 . 이제이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">성공하면 자동 염색 형식의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="1e391581d76d0c24968f00549dd5c8fda5e3d997" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;system&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">HIGH 또는 MEDIUM 안전 수준 (예 : Win NT 또는 OS / 2)을 지원하지 않는 시스템에서는 수준을 변경하려는 시도가 무시됩니다. 예외를 제기하지 않고 무시하기로 결정하면 추가 테스트와 관련이없는 시스템에서 이러한 프로그램이 실패하지 않고이를 지원할 수있는 시스템에 대해 이식성이 높은 프로그램을 염두에두고 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">로케일이없는 시스템에서이 pragma는 &quot;C&quot;로케일 에서처럼 조작이 작동하도록합니다. 로케일 변경 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">파일 이름을 나타내는 문법이있는 시스템에서는 $ base 파일 이름을 무시합니다. 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">파일 이름을 나타내는 문법이있는 시스템에서는 &lt;code&gt;$base&lt;/code&gt; 파일 이름도 무시합니다 . 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="901b07c2e1b3c74e80e092e6a7bf36ca0bfb33ee" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, you may pass a filehandle or directory handle as the argument. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, passing handles raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04beca51e696b3f570d383d77ccd733902d428c1" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ad9738faaa35969ac19d2d964d2e11949f987b" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7ce7f23ab496e21c30f598c258278a01062849" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d6ffed6769b46e37f0d82df8acb444f49f35b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt;s are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 해당 플래그는 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 가 있는 새로 열린 모든 파일 설명자에 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 해당 플래그는 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 가 있는 새로 열린 모든 파일 설명자에 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="11350e333ae0f2472a99aa4945fb651bbd8808b9" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다 . &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다 . &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a9abf94cd4611a410ac6fca9a398911a42fa5c0" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc9058ec5b96236598bf0d8742f7fe61dd91e63f" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c803cb6cc476af479d34a3bc1112251dd81782" translate="yes" xml:space="preserve">
          <source>On systems that support a real &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, locks are inherited across &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; calls, whereas those that must resort to the more capricious &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function lose their locks, making it seriously harder to write servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">실제 flock (2)을 지원하는 시스템에서는 잠금이 fork () 호출에서 상속되는 반면, 더 변덕스러운 fcntl (2) 함수에 의존해야하는 잠금은 잠금을 잃어 서버를 작성하기가 훨씬 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">fchdir (2)를 지원하는 시스템에서는 파일 핸들 또는 디렉토리 핸들을 인수로 전달할 수 있습니다. fchdir (2)를 지원하지 않는 시스템에서 핸들을 전달하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchmod (2)를 지원하는 시스템에서는 파일간에 파일 핸들을 전달할 수 있습니다. fchmod (2)를 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchown (2)을 지원하는 시스템에서는 파일들 사이에 파일 핸들을 전달할 수 있습니다. fchown (2)을 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">futimes (2)를 지원하는 시스템에서는 파일간에 파일 핸들을 전달할 수 있습니다. futimes (2)를 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">이를 지원하는 시스템에서 이전 버전의 Perl은 % SIG 핸들러를 설치할 때 SA_RESTART 플래그를 사용했습니다. 이는 신호가 도착했을 때 다시 시작하지 않고 재시작 가능한 시스템 호출이 계속됨을 의미했습니다. 지연된 신호를 즉시 전달하기 위해 Perl 5.8.0 이상은</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">전통적으로 사용 가능한 &lt;b&gt;man&lt;/b&gt; 명령을 버린 시스템 에서 디버거는 &lt;b&gt;perldoc을&lt;/b&gt; 호출합니다 . 때때로이 결정은 재 시도적인 공급 업체로 인해 또는 진취적인 사용자에게보다 선의로 인해 올바르지 않습니다. 두 범주 중 하나에 해당하는 경우 $ DB :: doccmd 변수를 시스템의 Perl 문서를 볼 수있는 뷰어로 수동 설정하십시오. 이것은 rc 파일 또는 직접 할당을 통해 설정 될 수 있습니다. 우리는 여전히 다음 라인을 따라 뭔가의 실제 예를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">음의 에포크 값을 지원하는 시스템에서이 모듈은 에포크가 시작되기 전에 시스템의 최소 time_t 값을 줄인 날짜에 대처할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">파일 이름 길이가 제한된 시스템에서 서브 루틴에 해당하는 파일은 루틴 자체보다 짧은 이름을 가질 수 있습니다. 이로 인해 파일 이름이 충돌 할 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">네트워크 공유 개념 (현재 Windows 만 해당)이있는 시스템에서는 &lt;a href=&quot;file://&quot;&gt;file : ////&lt;/a&gt; url 에서 공유 이름을 반환합니다 . 다른 운영 체제에서는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4f2ea2521e9d2bed452fc1750b2f44d1e70008" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a file://// url. On other operating systems returns empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">볼륨 개념이있는 시스템에서 &lt;code&gt;$path&lt;/code&gt; 와 &lt;code&gt;$base&lt;/code&gt; 가 서로 다른 두 볼륨에있는 경우 두 경로를 확인하지 않고 대신 &lt;code&gt;$path&lt;/code&gt; 를 반환 합니다 . 이 모듈의 이전 버전은 &lt;code&gt;$base&lt;/code&gt; 볼륨을 무시 하여 시간의 일부 가비지 결과를 초래했습니다.</target>
        </trans-unit>
        <trans-unit id="7d73de0a58277977e444ac1cca08eacb14a895ab" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt;. Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt;, which resulted in garbage results part of the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890814a89a9eb1b787653006ab22422f5ccc270" translate="yes" xml:space="preserve">
          <source>On systems without locale support, or on typical single-threaded builds, or on platforms that do not support per-thread locale operations, this function does nothing. On such systems that do have locale support, only a locale global to the whole program is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">텍스트 필드에서 캐럿은 일종의 채우기 모드를 활성화합니다. 임의의 표현식 대신 제공된 값은 텍스트 문자열을 포함하는 스칼라 변수 여야합니다. Perl은 텍스트의 다음 부분을 필드에 넣은 후 다음에 변수를 참조 할 때 더 많은 텍스트를 인쇄 할 수 있도록 문자열의 앞면을 잘라냅니다. (예, 이것은 변수 자체가 write () 호출을 실행하는 동안 변경되고 복원되지 않음을 의미합니다.) 텍스트의 다음 부분은 원치 않는 줄 바꿈 알고리즘에 의해 결정됩니다. 캐리지 리턴 문자 ( &lt;code&gt;\r&lt;/code&gt; )를 사용하여 줄 바꿈을 강제 할 수 있습니다. 변수 &lt;code&gt;$:&lt;/code&gt; (영어 모듈을 사용하는 경우 $ FORMAT_LINE_BREAK_CHARACTERS)를 원하는 문자 목록으로 변경하여 구분할 수있는 문자를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c85b198c2a1ea3057ddf98fa6e2eafccce107220" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt;) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">AS / 400에서 PERL5가 라이브러리 목록에 있으면 Perl 스크립트를 CL 프로 시저로 랩핑하여 다음과 같이 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="16a3b552e4784bd03ff647bc0e4cf0bd441e7074" translate="yes" xml:space="preserve">
          <source>On the DSM management page start the Control Panel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124c561154829ad2caaa2d7dfa3f126afe450312" translate="yes" xml:space="preserve">
          <source>On the flip side, don't be tempted to prematurely declare a test incorrect just because you're having trouble finding the bug. Invalidating a test isn't something to be taken lightly, and don't use it as a cop out to avoid work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">주어진 프로그램에서 &lt;code&gt;program_name&lt;/code&gt; 으로 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="12dc585208a0e91c8b1cc0d400c475b21cd97b26" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">메인 프레임에서 Perl은 현재 &quot;OS / 390 용 Unix 시스템 서비스&quot;(이전의 OpenEdition), VM / ESA OpenEdition 또는 BS200 POSIX-BC 시스템 (BS2000은 Perl 5.6 이상에서 지원됨)에서 작동합니다. 자세한 내용은 &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; 을 참조하십시오. OS / 400의 경우 ASCII 기반 인 PASE에 대한 Perl 5.8.1 / 5.10.0 이상의 포트도 있습니다 (EBCDIC 기반 인 ILE와 반대) . &lt;a href=&quot;perlos400&quot;&gt;perlos400을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">스케일의 반대쪽 끝에서 다음과 같은 선언</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">반면에 다른 의미를 원하면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">반면에 실제로 배열 요소를 목록으로 취급하려면 Perl이 스칼라와 목록을 마술처럼 변환하지 않기 때문에 참조가 작동하는 방식을 살펴 봐야합니다. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">반면에 실제로 해시 요소를 목록으로 취급하려면 Perl이 스칼라와 목록을 마술처럼 변환하지 않기 때문에 참조가 작동하는 방식을 살펴 봐야합니다. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">반면 $ data가 너무 짧아 추측하기 어려운 경우가 아니라면 다양한 국가 표준 인코딩을 혼합하면 자동으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">반면에 때로는 이미 존재하는 모든 것을 클로버하고 싶을 때가 있습니다. 파일을 쓰기 전에 파일을 비우려면 쓰기 전용 모드로 파일을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">반면에 :</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">목록 연산자의 오른쪽에서 쉼표는 우선 순위가 매우 낮아서 쉼표로 구분 된 모든 표현식을 제어합니다. 우선 순위가 낮은 유일한 연산자는 논리 연산자 &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 이며 괄호없이 연산자를 나열하기위한 호출을 평가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd64949dc6542722891696f1747da1386b28ed4e" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt;, &lt;code&gt;&quot;or&quot;&lt;/code&gt;, and &lt;code&gt;&quot;not&quot;&lt;/code&gt;, which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c9d06262a8b8894dbad99cc8b7ff5cbcc3e919" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;&lt;/a&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;&quot;Newlines&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">이러한 플랫폼에서 EBCDIC 문자 세트는 일부 Perl 함수 (예 : &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; )에서 &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; 와같은 연산자를 사용하는 ASCII 상수ASCII 컴퓨터에 대한 소켓 인터페이스를 다루는 것은 말할 것도 없습니다 (&lt;a href=&quot;#Newlines&quot;&gt; Newlines&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 이 실제로 부울 (C ++, C99) 인 플랫폼 및 컴파일러에서는 캐스트를 잊어 버리기 쉽습니다. 당신은 강제 할 수 &lt;code&gt;bool&lt;/code&gt; 로 &lt;code&gt;char&lt;/code&gt; 함께 컴파일하여 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . 다음과 같은 방법으로 &lt;code&gt;Configure&lt;/code&gt; 를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba599ad520fca93f96bd6d59495057f2e3221a03" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt;. You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">스레드 빌드에서 패턴을 여러 스레드에서 사용할 수 있도록 정규 표현식을 복제해야 할 수도 있습니다. 이 루틴은 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;pprivate&lt;/code&gt; 구성원이 가리키는 개인 데이터의 복제를 처리해야합니다 . 사전 구성된 새 &lt;code&gt;regexp&lt;/code&gt; 구조를 인수로 호출하고 &lt;code&gt;pprivate&lt;/code&gt; 구성원은 &lt;b&gt;이전&lt;/b&gt; 개인 구조를 가리키며 사본을 구성하고 포인터를 리턴하는 것은이 루틴의 책임입니다. 이 루틴에 전달 된 필드).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f7d01cda50f9d06f5abacea7dcc3dcdce0e0aef" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e92c3a98c94fccb8ba5784670e12e223f435cc2" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called; see &lt;a href=&quot;#WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; for a more contained way to ensure that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">스레드되지 않은 빌드에서는이 필드가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb3efd91222592d2901cd1f317fee4fadb20e2bc" translate="yes" xml:space="preserve">
          <source>On versions of Perl before 5.26, activating taint mode will also remove the current directory (&quot;.&quot;) from the default value of &lt;code&gt;@INC&lt;/code&gt;. Since version 5.26, the current directory isn't included in &lt;code&gt;@INC&lt;/code&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">일단 &lt;code&gt;test_out&lt;/code&gt; 또는 &lt;code&gt;test_err&lt;/code&gt; (또는 &lt;code&gt;test_fail&lt;/code&gt; 또는 &lt;code&gt;test_diag&lt;/code&gt; 이 )가 호출 한 모든 추가 출력 &lt;a href=&quot;../builder&quot;&gt;테스트 :: 빌더&lt;/a&gt; 에 의해 캡처됩니다 &lt;a href=&quot;tester&quot;&gt;테스트 :: 빌더 :: 테스터&lt;/a&gt; . 즉 , &lt;code&gt;test_test&lt;/code&gt; 를 호출 할 때까지 일반적인 방식으로 일반 출력에 대해 추가 테스트를 수행 할 수 없습니다 (출력 파일 핸들을 수동으로 처리하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="083880b888c49c9dba31b5a1a1d83eae3051aea8" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt;) have been called, all further output from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;test_test&lt;/code&gt; 가 실행 되면 테스트 출력은 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 가 연결된 원래 파일 핸들로 다시 리디렉션 되고 (아마도 STDOUT 및 STDERR), 실행하는 추가 테스트가 정상적으로 작동하고 &lt;a href=&quot;../harness&quot;&gt;Test :: Harness에&lt;/a&gt; 대한 성공 / 오류가 발생 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6814624afd4c6e39f83bea80e53ce4d9099ae560" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">EOF가 감지되면 ( &lt;code&gt;$status&lt;/code&gt; 가 0 임) 필터는 소스 스트림에 추가 행을 삽입합니다. 이 추가 라인이 실행될 때 실제로 수행 된 대체 수를 인쇄합니다. 참고 &lt;code&gt;$status&lt;/code&gt; 설정되어 &lt;code&gt;1&lt;/code&gt; 이 경우.</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">Perl은 프로그램의 어느 곳에서나 이러한 변수 중 하나가 필요하다는 것을 알게되면 각각의 모든 패턴 일치에 변수를 제공합니다. 즉, 모든 패턴 일치에서 전체 문자열이 복사되어 일부는 $`로, 일부는 $ &amp;amp;로, 그리고 일부는 $ '로 복사됩니다. 따라서 벌칙과 패턴이 자주 일치하는 경우 벌칙이 가장 심각합니다. 가능하면 $ &amp;amp;, $ '및 $`를 피하십시오. 그러나 사용할 수없는 경우, 이미 사용한 후에는 가격을 이미 지불 했으므로 마음대로 사용하십시오. 일부 알고리즘은 정말 감사합니다. 5.005 릴리스에서 $ &amp;amp; 변수는 더 이상 다른 두 가지 방식과 같이 &quot;비싸지 않습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">기능, 구조 또는 모듈이 더 이상 사용되지 않는 것으로 표시되면 Perl 코어에서 제거 할 수 있습니다. 당연히, 우리는 우리가 &lt;b&gt;제거&lt;/b&gt; 했다고 말합니다&lt;b&gt;&lt;/b&gt; 이러한 것들을 . 모듈을 제거하면 더 이상 Perl과 함께 제공되지 않지만 CPAN에서 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0837f9cee9c8dc066f294cad80d931eedcddeed" translate="yes" xml:space="preserve">
          <source>Once a handle is open, its layers can be altered using &lt;code&gt;binmode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">그러나 모듈이 Perl 코어에 포함되면 Perl 유지 관리에 관련된 모든 사람은 원래 작성자가 명시 적으로 소유권을 포기하지 않는 한 해당 모듈이 여전히 원래 작성자의 자산임을 인식해야합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="fb8472b689cb77838766fd3ad6c514d183c9cd46" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">심판이 축복을 받으면 &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 핵심 모듈 의 &lt;code&gt;blessed&lt;/code&gt; 기능 으로 클래스 이름을 알 수 있습니다. 이 서브 루틴은 객체를 전달할 때 객체의 클래스를 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">스레드가 분리되면 결합되지 않을 수 있으며, 스레드가 생성하고 결합을 기다리는 경우 리턴 된 리턴 데이터가 유실됩니다.</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">할일 테스트가 성공하기 시작하면 간단히 블록 밖으로 이동하십시오. 블록이 비어 있으면 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">변수가 제거되면 변수를 지원하지 않는다는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">다시 한번, &lt;code&gt;module-starter&lt;/code&gt; 또는 &lt;code&gt;h2xs&lt;/code&gt; 가 모든 작업을 완료했습니다. 모듈을 다운로드하고 설치할 때 표시 되는 표준 &lt;code&gt;Makefile.PL&lt;/code&gt; 을 생성하며, &lt;code&gt;dist&lt;/code&gt; 대상 이있는 Makefile을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">승인되면 변경 사항이 &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; 를 구동하는 저장소 인 &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt; 에 병합됩니다. 다음 Perl 5 릴리스와 함께 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">명령 행에서 한 페이지 도움말 화면에 &lt;code&gt;h&lt;/code&gt; 를 입력 하십시오. 나머지는 설명이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">FILE *이라고하면</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">종료되면 더 이상 항목을 대기열에 넣을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6742558d45b013c0f52c3e462293464937a542ee" translate="yes" xml:space="preserve">
          <source>Once installed you may delete the temporary archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14db76a9667a7b9782c3a5e1dfcf95186773ac9a" translate="yes" xml:space="preserve">
          <source>Once it has created those helpers TAP::Harness starts running the tests. For each test it creates a new parser (TAP::Parser) which is responsible for running the test script and parsing its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">일단 매핑되면 &lt;code&gt;$string&lt;/code&gt; 을 다른 문자열처럼 취급 할 수 있습니다 . 데이터를 반드시로드 할 필요는 없으므로 mmap-ing이 매우 빠를 수 있으며 메모리 풋 프린트를 늘리지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">miniperl.exe 작성이 끝나면 NetWare 폴더에서 nmake를 실행하십시오. 이것은 NetWare 용 Perl 인터프리터를 다음과 같이 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="b72bd7ffb13635f0115e40bb684ebf6013fb4223" translate="yes" xml:space="preserve">
          <source>Once perl is installed you can read this document in the following way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">일단 선택하면 자릿수를 줄이지 않고 버전 체계를 고수하는 것이 중요합니다. 이는 FreeBSD 포트 시스템과 같은 &quot;다운 스트림&quot;패키지 프로그램이 다양한 방식으로 버전 번호를 해석하기 때문입니다. 버전 체계에서 자릿수를 변경하면 이러한 시스템을 혼동하여 모듈 버전이 잘못되어 분명히 나빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">MacOS Classic 용 Makefile 제작</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">일단 등록되면 이러한 후크를 끄는 메커니즘이 없으므로 필요한 경우 직접 수행해야합니다. &lt;code&gt;%^H&lt;/code&gt; 의 항목 이 가장 좋은 방법 일 수 있으므로 효과의 범위는 어휘 범위입니다. 그러나 &lt;code&gt;BhkDISABLE&lt;/code&gt; 및 &lt;code&gt;BhkENABLE&lt;/code&gt; 매크로를 사용하여 항목을 임시로 켜거나 끌 수도 있습니다. 또한 확장 프로그램이로드되기 전에 일반적으로 적어도 하나의 스코프가 열리므로 &lt;code&gt;start&lt;/code&gt; 과 일치하지 않는 &lt;code&gt;pre/post_end&lt;/code&gt; 쌍이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="6126376d608e0a08175eebdf21cea20073d31c49" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">문자열 시작시 'aaab'가 일치하고 &lt;code&gt;(*SKIP)&lt;/code&gt; 가 실행되면 다음 시작 지점은 &lt;code&gt;(*SKIP)&lt;/code&gt; 가 실행될 때 커서가 있던 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">AV가 작성되면 다음 조작이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">HV가 작성되면 다음 조작이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7b0782b5689e0608cbf6133cde75f1c5a3739fbd" translate="yes" xml:space="preserve">
          <source>Once the build is completed you need to create the DLL SIS file by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">필터링이 적용되면 각 자리 표시자를 해당 원래 구성 요소 ( &lt;code&gt;@components&lt;/code&gt; ) 로 바꾸어 원래 문자열, 정규 표현식, POD 등을 코드에 다시 삽입합니다 . 이는 &lt;code&gt;@components&lt;/code&gt; 변수가 필터 내에서 세 심하게 처리되어야 함을 의미합니다 . &lt;code&gt;@components&lt;/code&gt; 의 배열 저장 삽입 각 자리의 '백 번역 &quot; &lt;code&gt;$_&lt;/code&gt; 뿐만 아니라 자리 사이에 삽입 소스 코드. 플레이스 홀더 &lt;code&gt;@components&lt;/code&gt; 에서 변경되면 필터가 완료된 후 플레이스 홀더가 &lt;code&gt;$_&lt;/code&gt; 에서 제거 될 때 이와 유사하게 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd6cbdddebea04b989e355c0ed247c28cfea9f3d" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt;). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt;, as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt;, they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">첫 번째 줄이 처리되면 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">위에 나열된 매개 변수를 사용하여 일반 서버 소켓이 작성되면 서버는 새 클라이언트가 연결하기를 기다립니다. 서버는 &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 메소드를 차단하여 결국 원격 클라이언트로부터 양방향 연결을 승인합니다. (버퍼링을 피하려면이 핸들을 자동 플러시해야합니다.)</target>
        </trans-unit>
        <trans-unit id="f10049f7656078a8b871ef2357d99fe6e6157f3d" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;accept&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f78b2677c2893cae03c215c7f1cb2296b9c1aa" translate="yes" xml:space="preserve">
          <source>Once the headers have been installed, you can create a SIS for the PerlApp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">파서가 완료되면 종료 상태를 반환합니다. 파서가 실행 파일을 실행 한 경우 실행 파일의 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">파서가 완료되면 파싱 된 TAP의 버전 번호가 반환됩니다. 버전 번호는 TAP 버전 13에서 도입되었으므로 버전 번호가 없으면 버전 12로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">파서가 완료되면 대기 상태를 반환합니다. 파서가 실행 파일을 실행 한 경우 실행 파일의 대기 상태를 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 상태 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="58ee32eca6824b955eaf78744f8a028137e28ac5" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;exit&lt;/code&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">접두사 dthe가 가장 바깥쪽에있는 분리 문자 괄호가 인식되면 입력 텍스트를 단계별로 실행하고 다음 대안을 순서대로 시도하여 코드 블록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">프로그램이 달리 수행되고 Projname :: L10N :: en_us의 데이터 및 메소드를 통해 첫 번째 언어의 현지화가 제대로 작동하면 번역 할 데이터를 모을 수 있습니다. 첫 번째 언어 어휘가 _AUTO 어휘가 아닌 경우 어휘에 이미 명시 적으로 모든 메시지가 있습니다 (또는 $ lh-&amp;gt; maketext를 호출하여 예외 메시지가 표시되어 예외가 발생 함) ). 그러나 (권고 적으로) 게으르고 _AUTO 어휘집을 사용하고 있다면 지금까지 _AUTO가 당신을 위해 만든 모든 문구 목록을 작성해야합니다. 이러한 목록을 구성하는 방법은 매우 많습니다. 가장 간단한 방법은 &quot;maketext&quot;가 발생할 때마다 (또는 위 와 같이 래퍼를 호출하는 것) 소스를 단순히 grep하는 것입니다.다음 문구를 기록합니다. &lt;code&gt;pmt&lt;/code&gt; 함수), 다음 문구를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">참조가 $ aref 또는 $ href와 같은 변수에 저장되면이를 복사하거나 다른 스칼라 값과 동일하게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">프로그램의 크기가 결정되면 패턴은 다시 구문 분석되지만 이번에는 실제에 대한 것입니다. 이제 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 는 false이며 실제 구성이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c79022e55900699b84f2aa1eb3cdbe226323760" translate="yes" xml:space="preserve">
          <source>Once the socket has been connected to the peer, &lt;code&gt;connect&lt;/code&gt; will return true and the socket will now be ready to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba841c18d878724cf95fcf3049c21ef759f81a9" translate="yes" xml:space="preserve">
          <source>Once the source was patched, &lt;code&gt;./Configure&lt;/code&gt; and &lt;code&gt;make test_prep&lt;/code&gt; were called and completed successfully, enabling confirmation of the findings in RT #72414.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">이 작업이 완료되면 다음을 수행하여 확장을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">주어진 함수에 대해이 프로세스가 완료되면 프로세스가 정의되므로 이후 서브 루틴에 대한 호출은 AUTOLOAD 메커니즘을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">업로드 한 후에는 제작자 디렉토리에 눈에 띄지 않습니다. CPAN의 나머지 부분에 연결하려면 PAUSE의 &quot;이름 공간 등록&quot;으로 이동해야합니다. 등록되면 모듈이 CPAN의 모듈 별 및 범주 별 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">옛날 옛적에 C 코드는 BSD와 SysV에서 컴파일 할 수 있습니다. 일반적으로 쉽게 변환 할 수있는 코드는 다른 &lt;b&gt;플랫폼&lt;/b&gt; 에서 실행하기 때문에 &quot;쉽게&quot;원하는대로 정의 할 수 있습니다. 이동 주택이나 런던 브리지와 같이 충분히 노력하면 휴대용으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">옛날 옛적에, 나는 pstruct라는 프로그램을 작성했습니다. C 구조를 구문 분석하고 멤버 오프셋을 표시하려고 시도한 것은 perl 프로그램이었습니다. 이 기능은 바이너리 덤프를 보거나 커널을 파고 드는 사람들에게 특히 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">옛날 옛적에 MakeMaker는 MacOS Classic (MacPerl)에서 올바른 Makefile의 근사치를 생성 할 수있었습니다. 관리자가 없기 때문에 나머지 MakeMaker와 동기화되지 않아 몇 년 동안 작동하지 않았습니다. 수리 가능성이 거의 없기 때문에 MacOS Classic은 사라지고 코드가 시작하기가 어려워 유지 보수를 쉽게하기 위해 코드가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">옛날 옛적에,라는 도서관이 있었다</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">&lt;code&gt;$self&lt;/code&gt; 가 참조한 해시를 축복 한 후에는 메소드 호출을 시작할 수 있습니다. 이것은 객체 초기화를 자체적 인 별도의 방법으로 배치하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">개별 블록을 식별 할 수 있으면 중첩되도록하십시오. 그것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">참조가 있으면 다음 매크로를 사용하여 참조를 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8475608c1eecbfff6034af7fbbf89552dc6e6321" translate="yes" xml:space="preserve">
          <source>Once you have changed into the repository directory, you can inspect it. After a clone the repository will contain a single local branch, which will be the current branch as well, as indicated by the asterisk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">이 작업을 완료하면 Berkeley DB API 함수를 다음과 같이 &lt;b&gt;DB_File&lt;/b&gt; 메소드로 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">일단 그것을 켜면 PASE 껍질을 가져 와서 tarball을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">키 목록이 있으면 해시 요소를 처리하기 전에 해당 목록을 처리 할 수 ​​있습니다. 예를 들어, 키를 사전 순으로 처리 할 수 ​​있도록 키를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba888926fbbe98be022401817b7a70ac357c498" translate="yes" xml:space="preserve">
          <source>Once you have the toolchain set up properly, the only remaining hurdle is actually locating where in the device it was installed in. For example, CCTools installs its toolchain in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">이 코드를 얻은 후에는 두 번째 인수로</target>
        </trans-unit>
        <trans-unit id="1eb08c46cb14cd90ec6426a049fef10ebf7f995f" translate="yes" xml:space="preserve">
          <source>Once you have unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c09803658da900e84c748f878a847903987255" translate="yes" xml:space="preserve">
          <source>Once you have write access, you will need to modify the URL for the origin remote to enable pushing. Edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">이진 파일을 올바른 모드로 올바르게 열면 텍스트 파일에서 사용한 것과 동일한 Perl I / O 기능을 모두 사용할 수 있습니다. 그러나 고정 된 크기 사용하실 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 대신 가변 크기의 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 에 귀하의 의견을.</target>
        </trans-unit>
        <trans-unit id="23e5339b1fa0074bcbf688df51973daa79c9a799" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;read&lt;/code&gt; instead of the variable-sized &lt;code&gt;readline&lt;/code&gt; for your input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">후크 기능이 있으면 &lt;code&gt;BHK&lt;/code&gt; 가 필요합니다. 구조를 넣어야합니다. 일단 등록하면 해제 할 수있는 방법이 없으므로 정적으로 할당하는 것이 가장 좋습니다. 함수 포인터는 &lt;code&gt;BhkENTRY_set&lt;/code&gt; 매크로를 사용하여이 구조에 삽입해야하며 , 유효한 엔트리를 나타내는 플래그도 설정합니다. 어떤 이유로 &lt;code&gt;BHK&lt;/code&gt; 를 동적으로 할당해야하는 경우 시작하기 전에 BHK 를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">객체의 유형이 무엇인지 알면 객체가 속한 서브 클래스와 지원하는 메소드를 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">사용자 누적을 시작하면 버그 보고서가 전송됩니다. 운이 좋으면 패치도 보내 줄 것입니다. 소프트웨어 프로젝트를 유지하는 기쁨에 오신 것을 환영합니다 ...</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">이 작업을 수행 한 후에는 새 렌더링 스타일을 추가하고 콜백 루틴을 추가하여 (단순히 추가 된) 스타일에서 새 변수를 참조하는 경우 선택적으로 간결한 출력을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">여기에 완료되면 다음에 &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">실제로 원하는 옵션을 설정 한 후에는 다음 방법을 사용하여 특정 방식으로 포드 파일을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">이 작업을 완료하면 열기 모드의 인코딩 부분을 안전하게 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">모듈이 자체 테스트를 통과했음을 확인하면 (항상 확인하는 것이 좋습니다) &lt;code&gt;make dist&lt;/code&gt; 를 만들 수 있으며 Makefile은 업로드 할 준비가 된 모듈의 멋진 타르볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="43b912c28f1dbb1c2e7aca4c90fa70b6b6f3dc13" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make distcheck&lt;/code&gt; to make sure everything looks OK, followed by &lt;code&gt;make dist&lt;/code&gt;, and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9742159929b90169a3b9a1d6ff201b11bb8fe7b" translate="yes" xml:space="preserve">
          <source>Once you've finished writing your commit message and exited your editor, git will write your change to disk and tell you something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">NDK를 설치하고 장치를 설정했으면 장치와 크로스 컴파일 환경을 설정하기 만하면됩니다. Blackberry는 &lt;code&gt;bbndk-env.sh&lt;/code&gt; (종종 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; 와 같은 이름 의 스크립트)를 제공합니다. 이를 수행하는 데 사용할 수있는 . 그러나 약간의 걸림돌이 있습니다. 스크립트는 PATH를 수정하여 'gcc'또는 'ar'가 교차 컴파일 동등 물을 가리 키도록하여 빌드 프로세스를 방해합니다.</target>
        </trans-unit>
        <trans-unit id="0ecc1cbc4b8ed0cfb9b6e01c2a2f1591b2619c6e" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt;) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">프로그램 / 사이트 / 등을 현지화하면 원하는 모든 언어의 경우 결과를 라이브 또는 스크린 샷을 통해 번역자에게 보여주십시오. 승인 한 후에는 해당 언어의 다른 한 사람이 확인하도록 모든 노력을 기울이십시오. 이는 프로그래머 중 한 명이 번역을 수행 할 때 (또는 특히) 수행 할 때도 마찬가지입니다. 도메인 별 전문 용어 및 관련 개념의 양에 따라 일부 시스템은 다른 시스템보다 테스터를 찾기가 더 어려울 수 있습니다. &quot;메시지 삭제&quot;에 대한 번역을 승인하는지 여부를 알 수있는 사람을 찾는 것이 더 쉽습니다. XML 쿼리 도구의 인터페이스에서 &quot;속성 값&quot;에 대한 번역에 대한 정보를 제공 할 수있는 사람을 찾는 것보다 웹을 통한 전자 메일 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">이를 이해했다면 Perl을 C에 포함시키는 것은 쉽다.</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">배포판의 압축을 풀면 &quot;sh Configure&quot;를 실행하십시오 (Configure 옵션에 대한 자세한 설명은 INSTALL을 참조하십시오). os390에 대한 &quot;힌트&quot;파일이 있으며 대부분의 것들에 대한 올바른 값을 지정합니다. 주의해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">확장이 완료되고 모든 테스트를 통과 한 후에는 설치가 매우 간단합니다. &quot;make install&quot;을 실행하기 만하면됩니다. Perl이 설치된 디렉토리에 대한 쓰기 권한이 있거나 시스템 관리자에게 make를 실행하도록 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">하나의 추가 번역이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec03014fcac8a461acd2bab0b3f3f4c4647a9956" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure Perl code outside the lexical scope of &lt;code&gt;use locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3A-Numeric-Formatting&quot;&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">충돌이 발생한 영역 중 하나는 C 로캘과 관련이 있습니다. ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) perl은 한 가지 예외가 있으며 달리 언급하지 않는 한 프로그램이 환경에서 전달 된 로케일로 실행중인 기본 로케일을 설정합니다. 이는 프로그램이 변경하지 않는 한 기본 C가 &quot;C&quot;로캘 인 일반 C 언어 프로그램과의 중요한 차이점입니다. v5.20부터이 기본 로케일은 어휘 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 밖의 순수한 펄 코드에서 완전히 숨겨져 있습니다. 로케일POSIX 모듈에서 필요한 함수 호출을 제외하고는 필요합니다. 그러나 기본 로케일은 XS 코드에 노출되어 있으며 로케일에 따라 동작하는 모든 C 라이브러리 루틴에 영향을줍니다. XS 코드는 기본 로캘이 &quot;C&quot;라고 가정하지 않는 것이 좋습니다. 예외는있다 &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC의&lt;/a&gt; 로케일 범주, 우리가 문제의 보고서가 없었어요 반면에 예외 인 이유는, 그 경험은 XS 코드에 대한 문제가 될 수 있다는 것을 보여 주었다이다 &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;로케일 범주를&lt;/a&gt;. 그리고이 한 가지 범주가 문제가되는 이유는 소수점으로 사용되는 문자가 다를 수 있기 때문입니다. 많은 유럽 언어는 쉼표를 사용하는 반면 영어이므로 Perl은 점을 기대합니다 (U + 002E : FULL STOP). 많은 모듈이 점인 기수 문자 만 처리 할 수 ​​있으므로 perl이이를 시도합니다. Perl v5.20까지는 시작시 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로케일 로 설정하려고했습니다 . 어떤 은 XS 코드에 대해 로 합니다.&lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;&lt;/a&gt;그렇지 않으면 setlocale () 이 변경합니다. 이로 인해 일부 오류가 발생했습니다. 따라서 v5.22부터 perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 항상 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로 설정 하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">ASCII 기반 문자 집합과 EBCDIC 문자의 큰 차이점은 기본 순서로 정렬 할 때 문자의 상대적 위치입니다. 가장 큰 관심사는 대문자와 소문자, 숫자 및 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; )입니다. )입니다. ASCII 플랫폼에서 기본 정렬 순서는 숫자가 대문자 앞에오고 밑줄 앞에 소문자가옵니다. EBCDIC에서 밑줄이 먼저오고 소문자, 대문자 및 숫자가 마지막에옵니다. ASCII 기반 플랫폼에서 정렬 된 경우, 의사의 두 글자 약어는 드라이브의 두 글자 약어 앞에옵니다. 그건:</target>
        </trans-unit>
        <trans-unit id="4d27487c78325597c40568b8011491df0ed50a95" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">&quot;짧은&quot;이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">하나는 항상 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">&lt;code&gt;-D usethreads&lt;/code&gt; 옵션을 제공하여 스레드 지원을 사용하여 perl을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">$ Getopt :: Std :: OUTPUT_HELP_VERSION을 설정하여 메시지의 출력 파일 핸들을 변경할 수 있습니다. 스위치 문자열을 인수로 사용하여 help_mess () 및 version_mess () 함수를 호출 하여 &lt;code&gt;--help&lt;/code&gt; ( &lt;code&gt;Usage:&lt;/code&gt; 행 없이 ) 및 &lt;code&gt;--version&lt;/code&gt; 메시지를 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">해당 &lt;code&gt;Features&lt;/code&gt; 을 확인하여 현재로드 된 ReadLine 패키지가 이러한 방법을 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c393381162c37f504c3308b016602c8a38b83d3" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db862b22399f31abaed4d1d2c6d6ed9c25d9c230" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;a href=&quot;Data::Dumper&quot;&gt;&lt;code&gt;Data::Dumper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;storable&quot;&gt;&lt;code&gt;Storable&lt;/code&gt;&lt;/a&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">이 두 가지 문제를 두 가지 방법으로 우회 할 수 있습니다. 원시 바이너리 대신 항상 텍스트 형식으로 번호를 전송하고 저장하거나 &lt;code&gt;Data::Dumper&lt;/code&gt; 및 &lt;code&gt;Storable&lt;/code&gt; (Perl 5.8에 포함) 과 같은 모듈을 사용하는 것이 좋습니다. 모든 데이터를 텍스트로 유지하면 문제가 크게 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">RSX를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">예를 들어 EMX의 다른 부분을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">식별자 이름에는 유니 코드를 사용할 수 있지만 패키지 / 클래스 또는 서브 루틴 이름에는 유니 코드를 사용할 수 없습니다. Perl 5.8.0부터는 이에 대한 일부 제한된 기능이 존재하지만 이는 의도 한 것보다 우연한 것입니다. 상기 목적으로 유니 코드를 사용하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">이 문서를 다음 형식으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">숫자 반복 횟수를 대괄호로 묶인 템플리트 문자로 대체하여 반복 횟수에 대괄호로 묶인 템플리트의 압축 된 바이트 길이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">이것이 처리되지 않는 경우는 SvFAKE가 설정되지 않은 gv입니다. 후</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">여기에서 일반적인 디버깅 방법 중 하나는 몇 가지 print 문을 자유롭게 뿌리고 데이터를 인쇄하기 직전에 검사를 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">이 포트를 &lt;code&gt;Tk&lt;/code&gt; 와 같은 GUI 라이브러리와 함께 사용할 때 한 가지 일반적인 실수 는 Perl의 명령 행 창 열기 동작이 사라진다는 가정입니다. 그렇지 않습니다. 명령 행 창을 열지 않고 &lt;code&gt;perl&lt;/code&gt; 사본을 시작 하려면 설치 프로세스 중에 빌드 된 &lt;code&gt;wperl&lt;/code&gt; 실행 파일을 사용하십시오 . 사용법은 &lt;code&gt;-h&lt;/code&gt; 와 같은 옵션이 작동하지 않는다는 점을 제외하고 Windows의 일반 &lt;code&gt;perl&lt;/code&gt; 과 정확히 동일 합니다. 인쇄하려면 명령 행 창이 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">인수 앞에 &lt;code&gt;*&lt;/code&gt; 를 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 대체 하여이 정보를 &lt;b&gt;xsubpp&lt;/b&gt; 에 전달합니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 는 인수가 주소로 라이브러리 함수에 전달되어야 함을 의미합니다. 위의 두 기능은 다음과 같이 XSUB로 인증 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcbea60b30cb68b4498f395be71fe8caca1d66b2" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt;. &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">이를 사용 하여 특정 명령에 대한 &lt;b&gt;Pod :: Paragraphs&lt;/b&gt; 및 &lt;b&gt;Pod :: InteriorSequences의&lt;/b&gt; 서브 클래스 를 작성하고 구문 분석 트리에서 사용자 정의 노드 유형을 작성할 수 있습니다.&lt;b&gt;&lt;/b&gt; 각 사용자 지정 노드에&lt;b&gt; emit ()&lt;/b&gt; 메서드를 트리의 서브 클래스 객체. 그런 다음 원하는 순서대로 트리를 재귀 적으로 걸어서 어린이가 텍스트 문자열 인 경우 서식을 지정하거나 왼쪽 (오른쪽에서 오른쪽으로)을 처리하거나 경우에 따라 &lt;b&gt;emit ()&lt;/b&gt; 메서드를 호출 하면됩니다. 객체 / 참조.</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">표에서 &quot;ASCII- 범위 유니 코드&quot;레이블이 붙은 열에있는 하나의 대응 문자는 ASCII 문자 세트의 문자 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Perl 코드의 가장 일반적인 비트 중 하나는 &lt;b&gt; sendmail에&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="42325abeeacce413a34de5a75512b4be08cb249a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;PerlIO::via::QuotedPrint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">&lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint라는&lt;/a&gt; 하나의 예제 모듈 이 Perl 5.8.0에 포함되어 있으며 CPl 에서 더 많은 예제 모듈 (예 : &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64)을 사용할 수&lt;/a&gt; 있습니다. 예를 들어 PerlIO :: via :: StripHTML 모듈을 사용하면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">하나의 예외는 기본 스칼라 변수입니다. perl 5.14로 시작하면 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; 은 항상 $ _에서 모든 매직을 제거하여 서브 루틴에서 $ _를 안전하게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6c9b4252819413fc14053d624bb7bb0e0b2769" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;local($_)&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">하나의 시설, 하나의 우선 순위.</target>
        </trans-unit>
        <trans-unit id="c1af03124d01c283a40e813bb6152573293c3a58" translate="yes" xml:space="preserve">
          <source>One final point -- obviously &lt;code&gt;InputLength&lt;/code&gt; can only be used whenever you know the length of the compressed data beforehand, like here with a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Perl 5.14부터 사용 가능한 하나의 양식은 &lt;code&gt;\o{...}&lt;/code&gt; 와 유사 하며 점은 하나 이상의 8 진수를 나타냅니다. 모든 유니 코드 문자에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6706d7cc152004a9fcc100843796f293fa434aa5" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt;, where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">일반적으로 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">한 가지 좋은 이유는 이미 완료되고 잘 수행 된 다른 언어로 작성된 기존 응용 프로그램이 있거나 특정 작업 (예 : 프롤로그, 작성)을 위해 특별히 설계된 응용 프로그램 언어가있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">파일을 여는 방법을 보여 드리기 전에 마지막으로해야 할 일은 파일을 여는 것이 Perl에서 자동으로 잠기지 않는다는 것입니다. 잠그는 방법 은 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">한 쌍의 큰 따옴표 해석이 먼저 수행되지만 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; 말할 수 없습니다 . 이전 단락에서 설명한 간접 파일 핸들이기 때문입니다. (이전 버전의 Perl에서 프로그래머는 중괄호를 삽입하여 파일 이름 glob : &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 로 해석하도록 강요 했습니다. 요즘 내부 함수를 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; 로 직접 호출하는 것이 더 깨끗한 것으로 간주됩니다 . 처음에 그것을 수행하는 올바른 방법.) 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c5cfad95a16b5735e117bc2fe294d5a66682c4eb" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt;. These days, it's considered cleaner to call the internal function directly as &lt;code&gt;glob($foo)&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">모듈의 한 줄 설명. PPD 파일에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">한 번에 하나의 로그.</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">하나의 매크로가 주요 Perl 빌드 특징 인 MULTIPLICITY를 제어합니다. MULTIPLICITY 빌드에는 모든 인터프리터 상태를 패키지하는 C 구조가 있습니다. 다중화 가능 perls를 사용하면 PERL_IMPLICIT_CONTEXT도 일반적으로 정의되며 세 데이터 구조를 모두 나타내는 &quot;숨겨진&quot;첫 번째 인수를 전달할 수 있습니다. MULTIPLICITY는 멀티 스레드 perls를 가능하게합니다 (매크로 USE_ITHREADS와 관련된 ithreads 스레딩 모델 사용).</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">또한 pod 지시문을 사용하여 코드 섹션을 빠르게 주석 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">왜 우리가 위의 계산기를 상징적이라고 부르는지 궁금 할 것입니다. 그 이유는 표현식 값의 실제 계산이 값이 다음과 같이 될 때까지 연기되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">처음에는 Perl이 &lt;code&gt;cat&lt;/code&gt; &lt;code&gt;at&lt;/code&gt; 를 찾아서 거기에서 멈출 것이라고 추측 할 수도 있지만 첫 번째 수량 자에 가능한 가장 긴 문자열을 제공하지는 않습니다 &lt;code&gt;.*&lt;/code&gt; . 대신 첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 정규 표현식 일치를 유지하면서 가능한 한 많은 문자열을 가져옵니다. 이 예에서는 문자열에 &lt;code&gt;at&lt;/code&gt; 가있는 &lt;code&gt;at&lt;/code&gt; 시퀀스 가 있음을 의미 합니다. 여기에 설명 된 다른 중요한 원칙은 정규 표현식에 둘 이상의 요소가있을 때</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 는 &lt;code&gt;[\h\v]&lt;/code&gt; 와 같다고 생각할 수 있습니다 . 이것은 실제로 Perl v5.18부터는 사실이지만, 그 이전의 유일한 차이점은 수직 탭 ( &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; )이 &lt;code&gt;\s&lt;/code&gt; 와 일치하지 않았다는 점이었습니다 .</target>
        </trans-unit>
        <trans-unit id="032953fa379d00cbfc247f44c2a8260cf97dce47" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt;. This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt;) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">한 가지 더 있습니다. 화살표는 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">ASCII 인코딩이 포함 된 인쇄로 전달되는 스칼라 및 문자열에주의해야합니다. 이 문제가 발생하는 한 가지 일반적인 위치는 CGI 스크립트 작성을위한 MIME 유형 헤더의 출력입니다. 예를 들어, 많은 Perl 프로그래밍 안내서는 다음과 유사한 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">파일의 이름. 이 이름은 &lt;b&gt;디렉토리에&lt;/b&gt; 나열됩니다 . 파일을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서 사용 하여 &lt;b&gt;운영 체제&lt;/b&gt; 에 열려는 파일을 정확하게 알려주고 파일을 &lt;b&gt;filehandle&lt;/b&gt; 과 연결하면 파일 &lt;b&gt;핸들&lt;/b&gt; 을 닫을 때까지 해당 파일의 후속 ID가 프로그램에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="336da35cb3021da58e89132b50e38c873db1f14d" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;open&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">&lt;code&gt;Moo&lt;/code&gt; 의 가장 매력적인 기능 중 하나는 &lt;code&gt;Moose&lt;/code&gt; 와의 상호 운용성입니다 . 누군가 &lt;code&gt;Moo&lt;/code&gt; 클래스 또는 역할에서 &lt;code&gt;Moose&lt;/code&gt; 의 자체 검사 API 를 사용하려고 하면 &lt;code&gt;Moose&lt;/code&gt; 클래스 또는 역할 로 투명하게 팽창됩니다 . 따라서 &lt;code&gt;Moo&lt;/code&gt; 사용 코드를 &lt;code&gt;Moose&lt;/code&gt; 코드베이스에 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e12d82a19550be538457962eb8c1b445867682c" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt;'s most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt;. When someone tries to use &lt;code&gt;Moose&lt;/code&gt;'s introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt;-using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">HP 포팅 센터 URL 중 하나는 &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/입니다&lt;/a&gt; . 현재 사용 가능한 포트는 GNU gcc로 빌드되었습니다.</target>
        </trans-unit>
        <trans-unit id="886b780bbc161a993310017e62754b9a44143e58" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc. As porting modern GNU gcc is extremely hard on HP-UX, they are stuck at version gcc-4.2.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Perl의 내부 형식 중 하나는 UTF-8입니다. 불행히도 Perl은 비밀을 유지할 수 없으므로 모든 사람이 이에 대해 알고 있습니다. 그것이 많은 혼란의 근원입니다. 내부 형식은 알려지지 않은 인코딩이며 항상 명시 적으로 인코딩 및 디코딩해야한다고 가정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">데이터와 입력으로 얻는 것과 출력으로 끝나는 것 사이의 필터 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">해킹 중 하나는 Perl 시작시 부동 소수점 예외를 비활성화하는 것입니다 (EMX의 기본값과 동일). 이것은 main ()이 호출되기 전에 컴파일 타임 링크 DLL이 플래그를 변경하는 경우에만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perl에서 고대의 천년 전 소켓 코드의 주요 문제점 중 하나는 일부 상수에 하드 코딩 된 값을 사용하여 이식성이 심각하게 손상되었다는 것입니다. &lt;code&gt;$AF_INET = 2&lt;/code&gt; 명시 적으로 설정하는 것과 같은 코드를 본 적이 있다면 큰 문제가있는 것입니다. 탁월한 탁월한 접근 방식은 &lt;code&gt;Socket&lt;/code&gt; 모듈 을 사용하는 것입니다. 소켓 모듈은 필요한 다양한 상수 및 기능에 대한 액세스를보다 확실하게 부여합니다.</target>
        </trans-unit>
        <trans-unit id="3521b3f28c5fee40e9a650a969731031f1a61ee7" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt;, you know you're in for big trouble. An immeasurably superior approach is to use the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d34337bf348093d461254c9e13628f931676b" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Perl 5의 가장 중요한 새로운 기능 중 하나는 다차원 배열 및 중첩 해시와 같은 복잡한 데이터 구조를 관리하는 기능이었습니다. 이를 가능하게하기 위해 Perl 5는 'references'라는 기능을 도입했으며 Perl에서 복잡한 구조화 된 데이터를 관리하는 데 참조를 사용하는 것이 중요합니다. 불행히도, 배우기에는 많은 재미있는 구문이 있으며, 기본 매뉴얼 페이지를 따르기가 어려울 수 있습니다. 매뉴얼은 매우 완전하며, 사람들은 중요한 것이 무엇이고 무엇이 아닌지를 말하기가 어렵 기 때문에 문제를 발견하기도합니다.</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">필터와 관련된 문제 중 하나는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Perl을 강력하게 만드는 것 중 하나는 Perl 해커가 직면 한 문제에 대한 솔루션을 공유하려는 경향이 있다는 사실입니다. 따라서 귀하와 저는 같은 문제로 다시 싸울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">perlivp에서 사용하는 두 모듈 중 하나가 설치에 없습니다. 이것은 perlivp의 기능에 악영향을 미치기 때문에 심각한 오류입니다. 적절한 perl 설치를 수행하여이를 정정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cf9aca6d76537483035c3c858a1ba395bda4fb6" translate="yes" xml:space="preserve">
          <source>One of these is because that, contrary to the claims, Unicode is not completely locale insensitive. Turkish and some related languages have two types of &lt;code&gt;&quot;I&quot;&lt;/code&gt; characters. One is dotted in both upper- and lowercase, and the other is dotless in both cases. Unicode allows a locale to use either the Turkish rules, or the rules used in all other instances, where there is only one type of &lt;code&gt;&quot;I&quot;&lt;/code&gt;, which is dotless in the uppercase, and dotted in the lower. The perl core does not (yet) handle the Turkish case, and this message warns you of that. Instead, the &lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt; module allows you to mostly implement the Turkish casing rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">패턴의 나머지 또는 둘러싸는 패턴 그룹의 나머지 (있는 경우)에 대해 하나 이상의 내장 된 패턴 일치 수정자가 켜지거나 (앞에 &lt;code&gt;-&lt;/code&gt; 가 오는 경우 꺼짐) 하나 이상 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; 실행에 따라 하나 이상의 파일이 누락되었습니다 . 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="a650068eaca265c5b79bfe09b24d5cc755bb9020" translate="yes" xml:space="preserve">
          <source>One or more licenses that apply to some or all of the files in the distribution. If multiple licenses are listed, the distribution documentation should be consulted to clarify the interpretation of multiple licenses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">아래의 하나 이상의 수정자는 TEMPLATE의 특정 문자를 선택적으로 따를 수 있습니다 (두 번째 열에는 수정자가 유효한 문자가 나열 됨).</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">사용 가능한 방법과 루틴 및 기타 관련 정보를 자세히 설명하는 하나 이상의 섹션 또는 하위 섹션.</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 플래그가 허용 하는 또 다른 흥미로운 점 은 체인 대체입니다.</target>
        </trans-unit>
        <trans-unit id="494e3ba4d63dc7d4d1f0f89cdfe24cd0f1c04a4f" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;s///r&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">고려해야 할 또 다른 사항은 CV가 해제되지 않고 정의되지 않은 것일 수 있다는 것입니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . 이 경우 참조 &lt;code&gt;CvROOT&lt;/code&gt; 가 0에 도달하지 않았지만 여전히 패드와 CvROOT 등을 삭제합니다 . 다양한 어린이가 여전히이 정의되지 않은 CV를 가리키는 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 를 가질 수 있으므로 당분간 자체 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 를 유지 합니다. 어휘 범위의 체인은 끊어지지 않습니다. 예를 들어, 다음은 123을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="014675b4f1afe81572052832b23ba392c4d8e3a4" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;undef &amp;amp;foo&lt;/code&gt;. In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2da08b06ed54d7d3369e11557c08e9b0920593" translate="yes" xml:space="preserve">
          <source>One particularly interesting aspect is that if the op has no kids (i.e., &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) the op is freed and replaced with an entirely new one that references &lt;code&gt;*ARGV&lt;/code&gt; (lines 12-16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Windows 용 4NT 명령 쉘에서 특히 위험한 문제점 중 하나는 환경 변수 확장이 필요하다는 것을 나타내는 거의 항상 문자를 % 문자로 취급한다는 것입니다. 따라서이 쉘에서 인용 될 때에도 Perl이보고자하는 % 문자 (예 : 해시 변수)를 항상 두 배로 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">한 가지 가능성은 이러한 코드 포인트와 일치하는 항목을 정의되지 않은 것으로 취급하는 것입니다. 그러나 Perl에는 정의되지 않은 일치 개념이 없으므로이를 실패 또는 &lt;code&gt;FALSE&lt;/code&gt; 로 변환 합니다 . 이것은 펄이 v5.14부터 (이 코드 포인트를 사용하는 것이 일반적으로 신뢰할 수있게되었을 때) v5.18까지했던 것과 거의 같지 않습니다. 차이점은 Perl은 모든 &lt;code&gt;\p{}&lt;/code&gt; 일치를 실패로 처리했지만 모든 &lt;code&gt;\P{}&lt;/code&gt; 는 성공으로 일치 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fbed2ea5d12cf5ca5a7dda7729be8ef0a1f5a584" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt;. This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">이에 대한 한 가지 가능한 원인은 가져 오기가 수행되지 않은 상태 에서 &lt;b&gt;사용&lt;/b&gt; 또는 &lt;b&gt;가져 오기&lt;/b&gt; 를 &lt;b&gt;사용&lt;/b&gt; 하여 네임 스페이스로 상수를 가져 왔을 것으로 예상 되었기 때문입니다. 예를 들어 운영 체제가 특정 상수를 지원하지 않을 수 있습니다. 바라건대 상수에 대해 명시 적 가져 오기 목록을 사용했으면합니다. &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 및 &lt;a href=&quot;functions/import&quot;&gt;가져 오기&lt;/a&gt; 를 참조하십시오 . 명시 적 가져 오기 목록이이 오류를 조기에 발견했을 수도 있지만 운영 체제가 여전히 해당 상수를 지원하지 않는다는 사실을 자연스럽게 해결할 수는 없습니다. 기호 가져 오기 &lt;b&gt;사용&lt;/b&gt; 또는 &lt;b&gt;가져&lt;/b&gt; 오기 목록의 상수 또는이 오류가 발생한 행의 상수 이름에 오타가있을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="039c34047140e161ac3c3f3d67a00d920ec9253f" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7cfe9d2aa74b9a194cf633078d5ffa3af4a9c3" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use &lt;code&gt;Encode::decode('UTF-8', ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">가능한 원인 중 하나는 UTF-8에 있다고 생각했지만 그렇지 않은 데이터 (예 : 레거시 8 비트 데이터)에 대해 UTF8 플래그를 직접 설정했기 때문입니다. 이를 막기 위해 Encode :: decode_utf8을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">&quot;fail&quot;속성에 유용한 값 중 하나는 &quot;failure_handler_auto&quot;메소드 이름입니다. 이것은 Locale :: Maketext 클래스 자체에 정의 된 메소드입니다. 당신은 그것을 설정 :</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">항상 나타나는 한 가지 문제는 값이 목록 인 해시가 필요하다는 것입니다. 물론 펄에는 해시가 있지만 값은 스칼라 여야합니다. 그들은 목록이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4ad2adff47d9f54cd5e7bc6c9a916046c09e993" translate="yes" xml:space="preserve">
          <source>One problem with creating a zip archive directly from STDIN can be demonstrated by looking at the contents of the zip file, output.zip, that we have just created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b95f68790db1176c6962a262914d43124b34ed" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusing results in some cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">이것의 한 가지 문제는 예기치 않은 결과를 초래하고 어떤 경우에는 혼란스러운 결과를 초래한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">이 미완료의 한 가지 이유는 패키지 이름과 서브 루틴 이름을 모두 파일 및 디렉토리 이름에 매핑해야하기 때문에 파일 시스템의 유니 코드 기능이 중요 해지고 안타깝게도 휴대용 답변이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Perl이 이러한 상황에서 유니 코드의 역할을 해결하려고 시도하지 않는 한 가지 이유는 운영 체제 및 파일 시스템에 대한 답변이 크게 달라지기 때문입니다. 예를 들어, 파일 이름이 유니 코드로되어 있는지, 어떤 종류의 인코딩으로되어 있는지는 휴대용 개념이 아닙니다. &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 유사하게 &quot;명령 줄 인터페이스&quot;(및 그 중 어느 것)가 유니 코드를 얼마나 잘 처리합니까?</target>
        </trans-unit>
        <trans-unit id="19ce00dd1106586a8ff2ee123627cfb803c2703c" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">하나의 참조 횟수를 도난 당 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="670ea0271b09cb55acf778b559eb456bd6341e38" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dade105e4e2f60c0a165dad2f91b1cd7cbd6b9" translate="yes" xml:space="preserve">
          <source>One should write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">올바른 위치에 있는지 확인하는 간단한 방법 중 하나 는 펄이 라이브러리를 찾는 하드 코딩 된 &lt;code&gt;@INC&lt;/code&gt; 를 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40125cf7ac08509271fa2127b7fe01c46836ef0d" translate="yes" xml:space="preserve">
          <source>One solution for that could use &lt;code&gt;Number::Format&lt;/code&gt; like that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">문제에 대한 한 가지 해결책은 자동 업그레이드입니다. 이를 수행하는 쉬운 방법 은 pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; 및 &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2481b8adeee425ef556bd2bb817f713879888ab4" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c39e037892e8d1c938d57ac2c0beb9ba304a9c" translate="yes" xml:space="preserve">
          <source>One subtest fails due to the uncommon structure of the Synology file system. The file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">그러한 개념 중 하나는</target>
        </trans-unit>
        <trans-unit id="4c38cfb2cc0fa83015bbf2caee9f3438eaaff452" translate="yes" xml:space="preserve">
          <source>One such defect of standard &lt;code&gt;numf&lt;/code&gt; is to not be able to use a certain decimal precision. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757b7ae7bf4edf5a451dca67abbf950db74e0a2" translate="yes" xml:space="preserve">
          <source>One such sequence is &lt;code&gt;\b&lt;/code&gt;, which matches a boundary of some sort. &lt;code&gt;\b{wb}&lt;/code&gt; and a few others give specialized types of boundaries. (They are all described in detail starting at &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt;.) Note that these don't match characters, but the zero-width spaces between characters. They are an example of a &lt;a href=&quot;#Assertions&quot;&gt;zero-width assertion&lt;/a&gt;. Consider again,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Perl 포터가 주목해야 할 것은</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">문장 부호 문자의 EBCDIC 인코딩은 코드 페이지마다 다를 수 있으므로 한 번만 사용하면 안됩니다 (모듈이나 스크립트가 EBCDIC와 함께 작동한다고 소문되면 사람들은 모든 EBCDIC 문자와 함께 작동하기를 원할 것입니다) 세트).</target>
        </trans-unit>
        <trans-unit id="47095331b77aa8c0bd7b8cd8bf856b6f81ef9c2e" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, a stripped-down version the code which implements the addition operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">Perl 소스에 대해 알 수있는 한 가지는 매크로로 가득하다는 것입니다. 어떤 사람들은 매크로를 광범위하게 사용하는 것이 이해하기 가장 어려운 것이라고 말했고, 다른 사람들은 그것을 명확하게하는 데 도움을줍니다. 더하기 연산자를 구현하는 코드를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3d7413c1ef4de3f560bf3b6da33dd42dda59d66b" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">한 가지 트릭은 &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;파일&lt;/a&gt; 끝에서 시작되는 File :: ReadBackwards 를 사용 하는 것입니다. 이 모듈은 실제 파일 핸들을 감싸는 객체를 제공하므로 파일을 쉽게 이동할 수 있습니다. 필요한 지점에 도달하면 실제 파일 핸들을 가져 와서 정상적으로 작업 할 수 있습니다. 이 경우 마지막 줄의 끝에서 파일 위치를 가져 와서 해당 지점까지 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="867c8b371a8323be6dd9b1df9a9ab1f91f9da2fc" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits, including hexadecimal and binary digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd71d85a3c1d14096e3d0dd58527e3bd9ae1e0f0" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;PERLDOC_PAGER&lt;/code&gt; 의 유용한 값 중 하나 는 &lt;code&gt;less -+C -E&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16342fee4b1c5a929e46db4d5c80b063641a8ef3" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">내가 이것을 할 수있는 한 가지 방법은 대체 연산자와 이중 &lt;code&gt;/e&lt;/code&gt; 플래그를 포함합니다. 첫 번째 &lt;code&gt;/e&lt;/code&gt; 는 대체 측면에서 &lt;code&gt;$1&lt;/code&gt; 을 평가 하여 &lt;code&gt;$foo&lt;/code&gt; 로 바꿉니다 . 두 번째 / e는 &lt;code&gt;$foo&lt;/code&gt; 시작 하여 값으로 바꿉니다. 그런 다음 &lt;code&gt;$foo&lt;/code&gt; 는 'Fred'로 바뀌고 마침내 문자열에 남습니다.</target>
        </trans-unit>
        <trans-unit id="bec707f167a013990074f651461c1eabbee251f8" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt;. The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt;, then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">한 가지 방법은 반환 값을 목록으로 취급하고 그 안에 인덱스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">유니 코드 문자의 내부 인코딩 내부를 엿보는 방법 중 하나는 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; 을 사용하여 문자열 인코딩이 수행되는 모든 바이트를 가져 오거나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; UTF-8 인코딩의 바이트를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="77d927c43f13ed4bce0c8303d398089ab5954c32" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;unpack(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">이 시나리오에서 네임 스페이스 충돌을 피하는 한 가지 방법은 파일 이름을 보장 된 고유 패키지 이름으로 변환 한 다음 &lt;a href=&quot;functions/eval&quot;&gt;eval을&lt;/a&gt; 사용하여 해당 패키지로 코드를 컴파일하는 것 입니다. 아래 예에서 각 파일은 한 번만 컴파일됩니다. 또는 응용 프로그램이 더 이상 필요하지 않은 파일과 관련된 기호 테이블을 정리하도록 선택할 수 있습니다. 사용 &lt;a href=&quot;perlapi#call_argv&quot;&gt;perlapi에 call_argv을&lt;/a&gt; , 우리는 서브 루틴 호출 할 수 있습니다 &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; 파일에 살고 &lt;code&gt;persistent.pl&lt;/code&gt; 을 하고 인수로 파일 이름과 부울 정리 / 캐시 플래그를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="dd0896a1b110e7eaa3676883c702b6cfbe8bca14" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;&quot;call_argv&quot; in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 찾고자하는 곳 근처에 드문 전화를하는 것입니다. 예를 들어, 방법 전에 &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676f2533e9c53ebcfbdadc653fb856c314a5321b" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;study&lt;/code&gt; before your method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">Perl 데이터 구조에서 사용중인 메모리 양을 확인하는 한 가지 방법은 CPAN에서 Devel :: Size 모듈을 설치하는 것입니다. 특정 데이터 구조를 저장하는 데 필요한 최소 바이트 수를 제공합니다. size ()와 total_size ()의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">이 매크로 지옥을 피하는 한 가지 방법은 덤프 기능을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">기여할 수있는 한 가지 방법은 설치하는 각 모듈에 대한 테스트 결과를 보내는 것입니다. CPAN :: Reporter 모듈을 설치하면 CPAN 패키지에서 테스트를 실행할 때마다 테스트 보고서를 자동으로 생성하여 CPAN 테스터에게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">해결 방법 중 하나는 가능한 한 빨리 Test :: More (또는 다른 테스트 모듈)로드 전에 STDOUT 및 STDERR에 인코딩을 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">다음 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">하나의 라이너 명령 팁</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">리디렉션 또는 쉘 메타 문자가있는 단일 인수 시스템 () ( &lt;a href=&quot;functions/system&quot;&gt;시스템&lt;/a&gt; 참조 ), exec () ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조 );</target>
        </trans-unit>
        <trans-unit id="ed7881b6406ffe431f1d2534257a9ed284c28da6" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;), exec() (see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">컬리를 포함하여 한 줄에 한 줄 블록을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">단방향 가시성은 이러한 방화벽이 방화벽 내부의 사용자에게 보이지 않게하려고 함을 의미합니다. FTP 데이터 연결은 일반적으로 IP 주소를 원격 서버로 전송 한 후 리턴 연결을 수신하여 작성됩니다. 그러나 방화벽으로 인해 원격 서버가 사용자에게 연결할 수 없습니다. 이러한 유형의 방화벽의 경우 FTP 연결을 수동 모드로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8b6f242edd1b92d8a41abce051eb1d237af2a29" translate="yes" xml:space="preserve">
          <source>Only 'chunked' &lt;code&gt;Transfer-Encoding&lt;/code&gt; is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 기호 만 번역됩니다. 잠금 함수 등을위한 인수로 전달하려면 여전히 자신의 인수를 올바르게 압축해야합니다.</target>
        </trans-unit>
        <trans-unit id="67da903cfa08873440f868f7f70e613649689d61" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in &lt;code&gt;PL_op-&amp;gt;op_targ&lt;/code&gt;), wasting a name SV for them doesn't make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">Intel C ++ Compiler v12.1 만 테스트되었습니다. 다른 버전도 작동 할 것입니다. Visual C 대신 Intel C ++ Compiler를 사용하면 일부 CPAN XS 모듈에 필요한 C99 호환성의 이점이 있지만 GCC와 달리 Visual C 개체 코드 및 Visual C 디버깅 인프라와의 호환성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2928fa0640b76bf7cac1897ae55dedc071303baa" translate="yes" xml:space="preserve">
          <source>Only a few characters (all of them being ASCII punctuation characters) are metacharacters. The most commonly used one is a dot &lt;code&gt;&quot;.&quot;&lt;/code&gt;, which normally matches almost any character (including a dot itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">5.9 이상에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="30aa8b56cc2760e31377798957b93c84973ea0a2" translate="yes" xml:space="preserve">
          <source>Only certain operations (all originating outside Perl) should be affected, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">Perl 외부에서 시작된 특정 작업 만 다음과 같이 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="be338b7ec52f196b66facaa0396ba0dea14b732e" translate="yes" xml:space="preserve">
          <source>Only gives you a reader, no &lt;code&gt;set_foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc54816219df4139d06acf1bbc8f828314bd1c1" translate="yes" xml:space="preserve">
          <source>Only gives you a write (&lt;code&gt;set_foo&lt;/code&gt;), no &lt;code&gt;foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">&quot;소유자&quot;및 &quot;기타&quot;읽기 / 쓰기 액세스 변경에만 적합합니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">&quot;소유자&quot;읽기 / 쓰기 액세스, &quot;그룹&quot;및 &quot;기타&quot;비트 변경에만 적합합니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">중괄호 사이에는 16 진수 만 유효합니다. 유효하지 않은 문자가 발견되면 경고가 발행되고 중괄호 내의 유효하지 않은 문자 및 모든 후속 문자 (유효 또는 유효하지 않은 문자)는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 뒤에는 16 진수 만 유효합니다 . 경우 &lt;code&gt;\x&lt;/code&gt; 두 개 미만의 유효 숫자 뒤에, 유효한 숫자 제로 패딩 된 것이다. 이것은 &lt;code&gt;\x7&lt;/code&gt; 이 &lt;code&gt;\x07&lt;/code&gt; 로 해석되고 &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 고독이 &lt;code&gt;\x00&lt;/code&gt; 으로 해석 됨을 의미합니다 . 문자열 끝을 제외하고 유효한 숫자가 두 개 미만이면 경고가 표시됩니다. 경고에서 잘못된 문자는 무시되지만 이스케이프의 일부로 만 무시되며 문자열에서 후속 문자로 계속 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b0998a6fdfd5f4525206c6e0b3be59bf209f58a" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt;. When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt;, and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt;. Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">문자 (또는 밑줄)로 시작하는 식별자 만 패키지의 기호 테이블에 저장됩니다. $ _와 같은 모든 문장 부호 변수를 포함하여 다른 모든 기호는 패키지 &lt;code&gt;main&lt;/code&gt; 에 보관됩니다 . 또한 규정되지 않은 경우, STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC 및 SIG ID 는 내장 된 것 이외의 다른 용도로 사용되는 경우에도 패키지 &lt;code&gt;main&lt;/code&gt; 에 있어야 합니다. &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 라는 패키지가있는 경우 패턴 일치, 대체 또는 음역으로 해석되기 때문에 규정 된 형식의 식별자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5258552aeae790433b734336886e3f62b2ea5d9a" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt;, including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt;, even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;y&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">소켓에서만 구현됩니다. (Win32, VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">매우 초기 릴리스에서만; 의 하위 집합입니다</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">매우 드문 상황에서만 코드가 유니 코드 (기본 코드가 아닌) 코드 포인트를 처리해야합니다. 이 경우 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d353340ff172b5c39b6a28e69782441add5fac" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead. If you are not absolutely sure this is one of those cases, then assume it isn't and use plain &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">로그 오류 만 :</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">PADNAMEt_OUTER가 설정된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">내 / 우리의 가변 슬롯 만 유효한 이름을 얻습니다. 나머지는 컴파일 타임에 정적으로 할당되거나 해결되는 op 대상 / GV / 상수입니다. 이것들은 &quot;// 우리의 변수가 될 수있는 방식&quot; &quot;평가를 통해 런타임에 Perl 코드에서 조회 할 수있는 이름이 없습니다. &quot;name&quot;으로 검색 할 수없고 컴파일 타임 (일반적으로 PL_op-&amp;gt; op_targ에 있음)에 할당 된 인덱스로만 조회 할 수 있으므로 이름 SV를 낭비하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">VMS (경로의 파일과 디렉토리 부분간에 모호성이없는 경우) 및 AmigaOS (이 모듈의 구현 문제로 인해 &lt;code&gt;fileparse($path)&lt;/code&gt; 에서만 &lt;code&gt;dirname()&lt;/code&gt; 이 fileparse ($ path) 와 같이 작동 하여 $ dirs 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f431144993e10d84cbfadd9a3e65deba1582a5e" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt;, returning just the $dirs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">하나의 인코딩 만 허용됩니다. 인코딩이 다른 프로그램에서 모듈을 결합하면 실제로 하나만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">한 번에 하나의 타이머 만 계산할 수 있습니다. 각 호출은 이전 타이머를 비활성화하고 새 타이머를 시작하지 않고 이전 타이머를 취소하기 위해 인수 &lt;code&gt;0&lt;/code&gt; 을 제공 할 수 있습니다. 반환 된 값은 이전 타이머에 남아있는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">패키지 변수 (지역화 된 경우에도 전역 변수) 만 기호 참조에 표시됩니다. 어휘 변수 (my ()로 선언)는 기호 테이블에 없으므로이 메커니즘에는 보이지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">(값을 가져 오거나 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ) 읽기 액세스 만 함수를 호출합니다. 수정 액세스는 일반 해시에서와 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="52379b3e8ed9b5889624849f89178e4a78f9060a" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;exists&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">소켓에서만 신뢰할 수 있습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="3d6a8b56f94127e52f27217f818b2868b3bb285a" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;&quot;add_style&quot;&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;&quot;add_callback&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">이러한 스타일 중 일부만 표준 스타일에서 사용되며 다른 스타일은 optree 역학을 탐구 할 수 있도록 제공되며, 이를 사용 하는 새 스타일을 추가하려는 경우 (아래 &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; 참조) &lt;a href=&quot;#add_callback&quot;&gt;add_callback을&lt;/a&gt; 사용하여 새로운 것을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e48dbe443fdc8ea64a9d98b0d46ac35972125215" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Bzip2&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aad383963ab78287aafa9360d0376650b94059" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Lzma&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">유효한 POD 명령이 하나 이상 포함 된 텍스트 파일 만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f768ea168f773a1d4344405cac8e79c05d1cb7bc" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;&quot;\&quot;&lt;/code&gt; is always a metacharacter. The others are metacharacters just sometimes. The following tables lists all of them, summarizes their use, and gives the contexts where they are metacharacters. Outside those contexts or if prefixed by a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, they match their corresponding punctuation character. In some cases, their meaning varies depending on various pattern modifiers that alter the default behaviors. See &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">이 중 INPUT 부분 만 구현되며 (Perl to XSUB) 코어 또는 CPAN에 알려진 사용자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="71019c006a2a3164840206c64e5cdd82e48eb2b0" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; is considered. (This is important only if &lt;code&gt;&quot;S&quot;&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 에 대한 최상의 일치 만 고려됩니다. (이것은 &lt;code&gt;S&lt;/code&gt; 에 캡처 괄호가 있고 역 참조가 전체 정규 표현식의 다른 곳에서 사용되는 경우에만 중요합니다 .)</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">최신 런타임 (현재 &lt;code&gt;0.9d fix 03&lt;/code&gt; 만 지원됩니다 . Perl은 이전 버전의 EMX에서 실행될 수 있지만 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">수정 시간 만 업데이트됩니다. (VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="a5196d88a77f964c944cd0486d4d8632d3d224b8" translate="yes" xml:space="preserve">
          <source>Only the values for English are returned. &lt;code&gt;YESSTR&lt;/code&gt; and &lt;code&gt;NOSTR&lt;/code&gt; have been removed from POSIX 2008, and are retained here for backwards compatibility. Your platform's &lt;code&gt;nl_langinfo&lt;/code&gt; may not support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">최대 Perl 5.9.4</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">r-magic에서만 유효하며 MAGIC에 저장된 REGEX의 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">r-magic에서만 유효하며 정규 표현식을 생성 한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4b3937a0e7df666bbee5731bdcd7cfebd5a56b8" translate="yes" xml:space="preserve">
          <source>Only votes if $source is an array, or a scalar with newlines. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f39472d96fc49b5d83aad7e124fec307fa8f3" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977cc058c727306e27dd1d2114879e4b0b58691f" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a regular file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30aa9fef235074c84d54a1603c93e02bcc5a7db6" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like an executable file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">perl이 ithreads로 컴파일 된 경우에만.</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">거기에 매우 유용한 정보가 있습니다. 이것은 앞으로 나아갈 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">죄송합니다. 패턴 시작 부분에 공백이 있으면 어떻게해야합니까? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; 은 패턴에서 첫 번째 문자가 아니지만 &lt;code&gt;U&lt;/code&gt; 를 첫 번째 활성 문자로 사용합니다. 이 경우 공백을 볼 때 &lt;code&gt;pat&lt;/code&gt; 과 함께 &lt;code&gt;patcopy&lt;/code&gt; 를 진행 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fe3ce4b3ad2d706be60b57c6678f0db7ee5828e3" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;pack(&quot; U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63b9b9665fa74c8ca88979a5af8db7577060be" translate="yes" xml:space="preserve">
          <source>OpHAS_SIBLING</source>
          <target state="translated">OpHAS_SIBLING</target>
        </trans-unit>
        <trans-unit id="8df5fc95b743ffdf06c754aebef9648088f82a06" translate="yes" xml:space="preserve">
          <source>OpLASTSIB_set</source>
          <target state="translated">OpLASTSIB_set</target>
        </trans-unit>
        <trans-unit id="6a2ac06a5c16d049ff2c9de33162907d6eaa1974" translate="yes" xml:space="preserve">
          <source>OpMAYBESIB_set</source>
          <target state="translated">OpMAYBESIB_set</target>
        </trans-unit>
        <trans-unit id="95d54e30cf7a8a2ef55bbad2e9fb47bd84433509" translate="yes" xml:space="preserve">
          <source>OpMORESIB_set</source>
          <target state="translated">OpMORESIB_set</target>
        </trans-unit>
        <trans-unit id="ad6188b517e063a47318e5c2bad924c90d8e314e" translate="yes" xml:space="preserve">
          <source>OpSIBLING</source>
          <target state="translated">OpSIBLING</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Opcode-Perl 코드를 컴파일 할 때 명명 된 opcode를 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">오피 코드 기능</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">읽을 zip 파일에서 &quot;membername&quot;을여십시오.</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">/ dev / tty를 열고 TIOCNOTTY ioctl을 사용하십시오. 보다</target>
        </trans-unit>
        <trans-unit id="bc45a01f475e91b2d1ed078654549eddc2aa2632" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See &lt;a href=&quot;http://man.he.net/man1/tty&quot;&gt;tty(1)&lt;/a&gt; for details. Or better yet, you can just use the &lt;code&gt;POSIX::setsid()&lt;/code&gt; function, so you don't have to worry about process groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">V2R8 이후의 Open Edition (UNIX 시스템 서비스)은 #! / path / to / perl 스크립트 호출을 지원합니다. #!에 대한 쉘 / 커널 지원을 허용하는 V2R7 용 IBM의 PTF가 있습니다. V2R7 이전의 USS 릴리스는 #! 스크립트 호출 수단. V2R6 이하를 실행중인 경우 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="adcf2a78c9cad4950930fad20f18fb46173fc5ee" translate="yes" xml:space="preserve">
          <source>Open Perl IDE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE는 Windows 95 / 98 / NT / 2000에서 ActiveState의 ActivePerl 배포를 사용하여 Perl 스크립트를 작성하고 디버깅하기위한 통합 개발 환경입니다.</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">읽을 디렉토리를여십시오.</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">읽고 쓸 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">쓰기 위해 읽을 파일을 엽니 다. 이것은 Perl 파일 핸들이 아닌 파일 디스크립터를 리턴합니다. &lt;code&gt;POSIX::close&lt;/code&gt; 를 사용 하여 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">잘림과 함께 쓸 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">모드 0666으로 파일을 읽기 전용으로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">open2 ()를 사용하여 읽고 쓰는 프로세스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">open3 ()을 사용하여 읽기, 쓰기 및 오류 처리를위한 프로세스 열기</target>
        </trans-unit>
        <trans-unit id="3de25d7ff3a7f69d51ceb431d7513e0facbf39f4" translate="yes" xml:space="preserve">
          <source>Open a shell on the Synology using ssh and become root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e426002e74b080358a024e5f7a561b3384b60d" translate="yes" xml:space="preserve">
          <source>Open directory handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a5a34e79d6531a1ea990bc264a097033a1025e" translate="yes" xml:space="preserve">
          <source>Open filehandles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92666893f36170e45fd93845fbf133686bc20a39" translate="yes" xml:space="preserve">
          <source>Open handles to files, directories and network sockets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open은 성공하면 0이 아닌 값을 반환하고 그렇지 않으면 정의되지 않은 값을 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 것이 파이프와 관련된 경우 리턴 값은 서브 프로세스의 pid가됩니다.</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open은 성공하면 0이 아닌 값을 반환하고 그렇지 않으면 정의되지 않은 값을 반환합니다. &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 것이 파이프와 관련된 경우 리턴 값은 서브 프로세스의 pid가됩니다.</target>
        </trans-unit>
        <trans-unit id="f405ae83374967e27b5349888fde9a222df40df7" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;open&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open은 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; 를 호출 하여 테이블에 슬롯을 할당하고 &lt;code&gt;PerlIO_push&lt;/code&gt; 를 호출하여 열린 파일의 레이어 정보와 연결해야합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="6ae8476e410284d0c0ba1054077caf01d110fd6a" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt;. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b90a08dc8612f90c1076481f4ad779beb7a5f7e" translate="yes" xml:space="preserve">
          <source>Open the scalar handle on a new scalar, pointed to by SCALARREF. If no SCALARREF is given, a &quot;private&quot; scalar is created to hold the file data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">옵션 &lt;code&gt;ndelay&lt;/code&gt; 및 &lt;code&gt;pid&lt;/code&gt; 및 설비 &lt;code&gt;LOCAL0&lt;/code&gt; 으로 syslog 를여십시오 .</target>
        </trans-unit>
        <trans-unit id="8811a98a6a9653fddfc77b8259113c776713824a" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt;, and with facility &lt;code&gt;LOCAL0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">ithreads가있는 getprotobyname_r 및 getservbyname_r의 OpenBSD 코어 덤프</target>
        </trans-unit>
        <trans-unit id="64310839a246c6fc794d722f4304cd08f25d7b05" translate="yes" xml:space="preserve">
          <source>OpenVMS</source>
          <target state="translated">OpenVMS</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1 이상 및 모든 버전의 OpenVMS I64는 대소 문자 구분을 프로세스 설정으로 지원합니다 ( &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl은 현재 VMS에서 대 / 소문자 구분을 지원하지 않지만 향후에는 대소 문자를 &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; 수 있으므로 Perl 프로그램은 File :: Spec-&amp;gt; case_tolerant 메서드를 사용하여 &lt;code&gt;$^O&lt;/code&gt; 변수가 아닌 상태를 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f9ff604a4dd28e6202581dca695c5bed829ec062" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt;). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">이진 파일 열기</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">파이프 열기</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">읽을 텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">쓰기 위해 텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">버클리 DB 데이터베이스 파일 열기</target>
        </trans-unit>
        <trans-unit id="03b0ff1f775aaa0c11a96201f8ff9e088550422d" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into a command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af9988c3fefcdee028653737bea0a8e9c417094" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into an in-memory scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821c0d97ab3d21f2ce24f411389616d6c9dc3c0d" translate="yes" xml:space="preserve">
          <source>Opening a pipe for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1420eefdd30517effef954306a645ff5d1c69e" translate="yes" xml:space="preserve">
          <source>Opening a pipe for writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">프로세스를 열면 일부 플랫폼에서 출력 핸들이 자동으로 플러시되지 않습니다. (SunOS, Solaris, HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">열기 및 설정 기능</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">조건이 여러 줄에 걸쳐있을 때 &quot;if&quot;로 괄호를 열면; 그렇지 않으면 줄의 끝에 있어야합니다</target>
        </trans-unit>
        <trans-unit id="4ac11216b92d2f325685b22de245cded12e40d13" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을위한 열기 브래킷. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="626f042395527b903c8db8f898fdb1f1cdc87f96" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;&lt;a href=&quot;#PUTBACK&quot;&gt;&quot;PUTBACK&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백의 인수에 대한 여는 괄호. &lt;code&gt;PUTBACK&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31ad94341ea4379f427305bb05c070cf8053b4ad" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;&lt;a href=&quot;#FREETMPS&quot;&gt;&quot;FREETMPS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 임시 용 여는 괄호. &lt;code&gt;FREETMPS&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e132601e5a7953c8bcffa1c453157f71ea1d34e" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;&lt;a href=&quot;#LEAVE&quot;&gt;&quot;LEAVE&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 여는 괄호. &lt;code&gt;LEAVE&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">가능하면 키워드와 같은 줄에 곱슬 곱슬하게, 그렇지 않으면 줄을 서십시오.</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">stdio (일반적인 perl 파일 핸들)를 사용하는 경우 읽기 / 쓰기를위한 파일 열기는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="414a4a46ddb98d37ef4a18659fc5e836c58095fc" translate="yes" xml:space="preserve">
          <source>Opening in-memory files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">쓰기 전용 또는 추가 모드에서 데이터 파일을 여는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">추가 모드에서 &lt;code&gt;$output&lt;/code&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="96c4834766ebccdcd74e84c8bb745c2565822fc0" translate="yes" xml:space="preserve">
          <source>Opens a Perl file handle based on an already open Win32 native file handle [much like C's &lt;code&gt;fdopen()&lt;/code&gt; does with a file descriptor]. Returns a true value if the open operation succeeded. For failure, returns a false value and sets &lt;code&gt;$!&lt;/code&gt; [and possibly &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;] to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8372328aea71570194ef6ece0a3348d285cc61e1" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#telldir-DIRHANDLE&quot;&gt;&lt;code&gt;telldir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seekdir-DIRHANDLE%2CPOS&quot;&gt;&lt;code&gt;seekdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#rewinddir-DIRHANDLE&quot;&gt;&lt;code&gt;rewinddir&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#closedir-DIRHANDLE&quot;&gt;&lt;code&gt;closedir&lt;/code&gt;&lt;/a&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. Dirhandles are the same objects as filehandles; an I/O object can only be open as one of these handle types at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 로 처리 할 EXPR이라는 디렉토리를 엽니 다 . 성공하면 true를 반환합니다. DIRHANDLE은 값이 간접 dirhandle, 일반적으로 실제 dirhandle 이름으로 사용될 수있는 표현식 일 수 있습니다. DIRHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 변수에 새 익명 디렉토리에 대한 참조가 지정됩니다. 즉, 자동 활성화됩니다. DIRHANDLE에는 FILEHANDLE과 별개의 고유 네임 스페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 로 처리 할 EXPR이라는 디렉토리를 엽니 다 . 성공하면 true를 반환합니다. DIRHANDLE은 값이 간접 dirhandle, 일반적으로 실제 dirhandle 이름으로 사용될 수있는 표현식 일 수 있습니다. DIRHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 변수에 새 익명 디렉토리에 대한 참조가 지정됩니다. 즉, 자동 활성화됩니다. DIRHANDLE에는 FILEHANDLE과 별개의 고유 네임 스페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="249fc18914652625c802e629d561a8d541cf9f3e" translate="yes" xml:space="preserve">
          <source>Opens a file descriptor [&lt;code&gt;$ivFD&lt;/code&gt;] based on an already open Win32 native file handle, &lt;code&gt;$hNativeHandle&lt;/code&gt;. This just calls the Win32-specific C routine &lt;code&gt;_open_osfhandle()&lt;/code&gt; or Perl's &quot;improved&quot; version called &lt;code&gt;win32_open_osfhandle()&lt;/code&gt;. Prior to Perl5.005 and in Cygwin Perl, C's &lt;code&gt;_open_osfhandle()&lt;/code&gt; is called which will fail if &lt;code&gt;GetFileType($hNativeHandle)&lt;/code&gt; would return &lt;code&gt;FILE_TYPE_UNKNOWN&lt;/code&gt;. For Perl5.005 and later, &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; calls &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; from the Perl DLL which doesn't have this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2665f3d96f1b25c433ed44735df54d5716eb0ca" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">해당 시스템 호출과 같은 연결된 파이프 쌍을 엽니 다. 파이프 프로세스의 루프를 설정하면 매우주의하지 않으면 교착 상태가 발생할 수 있습니다. 또한 Perl의 파이프는 IO 버퍼링을 사용하므로 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. 응용 프로그램에 따라 각 명령 후에 WRITEHANDLE을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">지정된 종류의 소켓을 열고 파일 핸들 SOCKET에 연결합니다. DOMAIN, TYPE 및 PROTOCOL은 동일한 이름의 syscall과 동일하게 지정됩니다. 올바른 정의를 가져 오려면 먼저 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 사용해야 &lt;a href=&quot;functions/use&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">지정된 종류의 소켓을 열고 파일 핸들 SOCKET에 연결합니다. DOMAIN, TYPE 및 PROTOCOL은 동일한 이름의 syscall과 동일하게 지정됩니다. 올바른 정의를 가져 오려면 먼저 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 사용해야 &lt;a href=&quot;use&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd4febc0253215fa9b6c0a61a1123c275d66541f" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;use Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b29b07c25945e487dbff4de1e81a446b3bf071a" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and returns it. Domain, type, and protocol are specified the same as for the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">EXPR에서 제공 한 파일 이름을 가진 파일을 열고 FILEHANDLE과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">FILENAME에서 파일 이름을 지정한 파일을 열고 FILEHANDLE과 연결합니다. FILEHANDLE이 표현식 인 경우 해당 값은 원하는 실제 파일 핸들로 사용됩니다. 정의되지 않은 스칼라가 적절하게 자동 활성화됩니다. 이 함수는 기본 운영 체제를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b9ccea513e25adc54a594c4a2c7b7e82197b4e8" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; function with the parameters FILENAME, MODE, and PERMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">syslog를 엽니 다. 모든 메시지 앞에 &lt;code&gt;$ident&lt;/code&gt; 가 붙습니다. &lt;code&gt;$logopt&lt;/code&gt; 에는 아래와 같이 0 개 이상의 옵션이 포함되어 있습니다. &lt;code&gt;$facility&lt;/code&gt; 는보고 할 시스템 부분을 지정합니다 (예 : &lt;code&gt;LOG_USER&lt;/code&gt; 또는 &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : 잘 알려진 기능 목록 은 &lt;a href=&quot;#Facilities&quot;&gt;기능&lt;/a&gt; 참조 및 시스템에서 사용 가능한 기능은 &lt;code&gt;syslog(3)&lt;/code&gt; 문서 참조 ) . 유용한 링크도 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조&lt;/a&gt; 하십시오 . 기능은 문자열 또는 숫자 매크로로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67ac2c393c850f9198943cd6ad27b36c7d7a81b" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt;: see &lt;a href=&quot;#Facilities&quot;&gt;&quot;Facilities&quot;&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7ead7f438c26f4d24f0c5553cfa1b2b48237a8" translate="yes" xml:space="preserve">
          <source>Operand with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">해시에 대한 참조에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ac9fb6f30a90f215146103f81004effdabcea9ae" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for UTF-16 surrogate U+%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b576c5bb0b11a4350e3bf4fdc21259831b2084c" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for non-Unicode code point 0x%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671b8f2f76102a15b0bf4d4a39249d6ad4b4ece" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot;: no method found, %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">연산자가 오버로드 된 작업은 정확히 예상 한 인수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">연산자가 오버로드 된 작업은 인수를 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">운영자 이름 및 운영자 목록</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">연산자 우선 순위 및 연관성</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">연산자 연관성</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">연산자 구현 (값)은 서브 루틴, 서브 루틴에 대한 참조 또는 익명 서브 루틴 일 수 있습니다. 즉, &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; 호출 내에서 합법적 인 것 입니다. 문자열로 지정된 값은 메소드 이름으로 해석됩니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">연산자 이름은 일반적으로 enterloop, leaveloop, last, next, redo 등과 같은 작은 소문자입니다. 때로는 gv2cv, i_ncmp 및 ftsvtx와 같이 다소 암호입니다.</target>
        </trans-unit>
        <trans-unit id="0bc65caf3b0a75a378aedfadf66730c78a4537cf" translate="yes" xml:space="preserve">
          <source>Operator or semicolon missing before %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">연산자 우선 순위</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">연산자 우선 순위와 연관성은 수학에서와 비슷하게 Perl에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">연산자 태그는 연산자 그룹 (또는 세트)을 나타내는 데 사용할 수 있습니다. 태그 이름은 항상 콜론으로 시작합니다. Opcode 모듈은 여러 optag를 정의하며 사용자는 define_optag 함수를 사용하여 다른 optag를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093964ff1bd20f7f1bfa027cf984852f6646a0fc" translate="yes" xml:space="preserve">
          <source>Operator vs literal overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">파일 이름을 다루는 연산자가 예입니다.</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 와 같은 연산자는 인수를 부동 소수점 형식으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="004496b42fcc360f8e82fa5c56c3b096a2155421" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; force arguments to floating point format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1c419f9c87704707f20d16f008ba41b567fa7e" translate="yes" xml:space="preserve">
          <source>Operators which expect a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192b9459597426145afa81f1d9a3ad900bb8bd5d" translate="yes" xml:space="preserve">
          <source>Operators which expect an integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">chdir과 같은 작업은 구획의 코드뿐만 아니라 전체적으로 프로세스에 영향을 미칩니다. rand 및 srand와 같은 작전은 비슷하지만 더 미묘한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">펄 비트 벡터 연산자를 사용하여 옵셋을 조작 할 수 있습니다. (또는), ^ (xor) 및 ~ (negate / invert).</target>
        </trans-unit>
        <trans-unit id="0b7b13995f2b05a4fbd9b6bef85fdd40cc461955" translate="yes" xml:space="preserve">
          <source>OptiPerl</source>
          <target state="translated">OptiPerl</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl은 디버거 및 구문 강조 편집기를 포함하여 시뮬레이션 된 CGI 환경을 갖춘 Windows IDE입니다.</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">최적화 데이터; 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">최적화 플래그; 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="6bc76b02fc66f0ca691dc22aabcdcd333e409136" translate="yes" xml:space="preserve">
          <source>Optimization of regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">최적화 된 문은 '???'로 렌더링됩니다. 여기에는 모호한 것과 같이 컴파일 타임 부작용이있는 문장이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="40dbe8ccfe714d9a944d448d1c3b1b3c2bfff946" translate="yes" xml:space="preserve">
          <source>Optimizing</source>
          <target state="translated">Optimizing</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">더 이상 &lt;code&gt;p5p&lt;/code&gt; 에 대한 작업임을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="7d18d459b985af7984ff90200899087216246ead" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">옵션 형식</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">옵션 끈적임</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">옵션 단어는 공백이 아닌 쉼표로 구분되며 일반적인 컴파일러 백엔드 옵션 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">옵션, 인수, 매개 변수 및 구성 파일 처리</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">선택 사항-레이어를 제거하려고 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">선택 사항-하위 계층이 없으면 하위 계층이 열립니다. 존재하는 경우 숫자 파일 설명자를 전달하는 열기를 위해 계층을 푸시 한 후 호출됩니다. 이 기능은 하위 계층이 개방을 수행 한 다음 제어를 다시 얻는 쉬운 방법이 없으므로 변경 될 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
