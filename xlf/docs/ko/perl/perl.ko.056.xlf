<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="07ebecac9b2b06cf07f96beb0d4f2199e5361e7a" translate="yes" xml:space="preserve">
          <source>TARGLEN</source>
          <target state="translated">TARGLEN</target>
        </trans-unit>
        <trans-unit id="2bf1079e4526d76e12b857a04bc0e88e77c1a56e" translate="yes" xml:space="preserve">
          <source>TARGOFF</source>
          <target state="translated">TARGOFF</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC : 문자열 화 된 코드 참조를 제거하십시오. 렌더링 된 각 함수에 대해 '쿠키'를 제공하지만 사용 된 쿠키는 임의의 16 진수 주소가 아닌 1,2,3.이어야합니다. 또한 두 개의 다른 나무의 문자열 비교가 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC : 사용자 제공 기능이 사용자 요구에 적합한 배너를 생성하기위한 후크 포인트 (및이를 설정하는 옵션)입니다. concise.t에서 자연스럽게 사용할 수있는 렌더링 상태 변수는 사용자가 사용할 수 없으므로 이상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f544fb304c83e23652a63e1bb1b28f4fcc7f6ac0" translate="yes" xml:space="preserve">
          <source>TCP</source>
          <target state="translated">TCP</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">IO :: Socket을 사용하는 TCP 클라이언트</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">IO :: Socket이 포함 된 TCP 서버</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">기술 정보</target>
        </trans-unit>
        <trans-unit id="b91007f005fd5b0e0252dbeed42578d0d3ba8fe5" translate="yes" xml:space="preserve">
          <source>TELL this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a2096b23211f0508d184fe8003d9fb843bbdcd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9335e94443b7e72d405288dde6a7e324e2d4e0cd" translate="yes" xml:space="preserve">
          <source>TEMPLATE available since 0.23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">차 방법</target>
        </trans-unit>
        <trans-unit id="984816fd329622876e14907634264e6f332e9fb3" translate="yes" xml:space="preserve">
          <source>TEST</source>
          <target state="translated">TEST</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">CYGWIN에 대한 테스트</target>
        </trans-unit>
        <trans-unit id="6fc222312636989b4f87037a3c04ed0cc832a677" translate="yes" xml:space="preserve">
          <source>TEST RESULTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">테스트 상태</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">테스트 유형</target>
        </trans-unit>
        <trans-unit id="0aec4d9bc52ab96e424cd057a59cc45eff314107" translate="yes" xml:space="preserve">
          <source>TEST2</source>
          <target state="translated">TEST2</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">테스트 프레임 워크</target>
        </trans-unit>
        <trans-unit id="0653969b83ac74a5d20cdc9c4494d4702f2fe66a" translate="yes" xml:space="preserve">
          <source>TESTING YOUR TOOLS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bee02d2a52a6eefa52f8e6c1723494db5b275c5" translate="yes" xml:space="preserve">
          <source>TEST_REQUIRES</source>
          <target state="translated">TEST_REQUIRES</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">감사합니다</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">.netrc 파일</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API 인터페이스</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">CALL_ 기능</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">수학 :: BigInt API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">펄 인코딩 API</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">펄 모듈 라이브러리</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">질문</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">SYS :: SYSLOG의 규칙</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">본 소프트웨어는 상품성, 특정 목적에의 적합성 및 비 침해에 대한 보증을 포함하되 명시 적이든 묵시적이든 어떠한 종류의 보증없이 &quot;있는 그대로&quot;제공됩니다. 어떠한 경우에도 저자 또는 저작권 소유자는 계약, 불법 행위 또는 기타 행위, 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래로 인해 발생하는 모든 청구, 손해 또는 기타 책임에 대해 책임을지지 않습니다. 소프트웨어.</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">데이터 콘 클래스</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="07b9eb014428dfb38549744f146d6c3dde1b5ea1" translate="yes" xml:space="preserve">
          <source>THINGS THAT BREAK</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">찾아야 할 것들</target>
        </trans-unit>
        <trans-unit id="89f30bff95de115f49eea92211c4131dff22eee2" translate="yes" xml:space="preserve">
          <source>THIRD PARTY META-DATA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d962f5bb90637331652bdd7361911bfa4f11ec" translate="yes" xml:space="preserve">
          <source>THIS</source>
          <target state="translated">THIS</target>
        </trans-unit>
        <trans-unit id="1e38c114990518154ef0cedaa35a5bd37c0b3725" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">이 기능은 매우 특수한 환경에서만 사용해야합니다. 대신, &lt;b&gt;거의 모든 코드는 &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; 또는 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags를 사용해야&lt;/a&gt;&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2fe768b556edf71a7a7285e6d6bd4d94874718c9" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e7f9968d3c36f671d0b0a315ac2b0ae68ef3cb" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt;() rather than call this directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">이 기능은 매우 특수한 환경에서만 사용해야합니다. 대부분의 코드는 이것을 직접 호출하지 않고 &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; ()를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e500f259933ce04e81376b9418761e8b6b63ca4b" translate="yes" xml:space="preserve">
          <source>THIS IS A BUNDLED COPY OF HASHBASE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87fa10ba30f21359cbeb956cb3e89adeb5a0009" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">스레드 컨텍스트</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">스레드 신호</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">스레드 스택 크기</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">스레드 상태</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="7c9dadbfc59d969a1799e6be175b4787667674b0" translate="yes" xml:space="preserve">
          <source>TIEARRAY classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">Sie Verdoolaege의 TIEHANDLE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4347e3f18728473395d10013e97d93a913b225ef" translate="yes" xml:space="preserve">
          <source>TIEHANDLE classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d83af8a8f8d7e1fd18b5a0b52b5df410f197b9" translate="yes" xml:space="preserve">
          <source>TIEHASH</source>
          <target state="translated">TIEHASH</target>
        </trans-unit>
        <trans-unit id="114157a2500e26e12e9e4f96b1661f6f0fed2f32" translate="yes" xml:space="preserve">
          <source>TIEHASH classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5885b322f223d2e8e46e67617d8c4179f4469494" translate="yes" xml:space="preserve">
          <source>TIESCALAR classname, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">시간은</target>
        </trans-unit>
        <trans-unit id="cb08f6ca3aa0ce4fb2da7065815536bc05346689" translate="yes" xml:space="preserve">
          <source>TITLE specifies an optional window title. The default is &quot;Perl&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP 또는 TEMP</target>
        </trans-unit>
        <trans-unit id="502251190f55377c3e1679cff641b5206ebe43aa" translate="yes" xml:space="preserve">
          <source>TMPDIR flag available since 0.19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9767c08e2051436d891f79c96c59ac4496bdaece" translate="yes" xml:space="preserve">
          <source>TMTOWTDI</source>
          <target state="translated">TMTOWTDI</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">할 것</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">해야 할 일 (아마도)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="87460dd609011b471c790d7cefae22bfe0f0c49f" translate="yes" xml:space="preserve">
          <source>TODO TESTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">TODO all (대부분?) 접근 방법</target>
        </trans-unit>
        <trans-unit id="a5b8170989f597b07b48f468f60223ae453a6cc5" translate="yes" xml:space="preserve">
          <source>TODO intro... mention that events are supplied for implicits, like for missing &amp;gt;'s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b8285ed97f054a4aab1877c59b31a331177c3b" translate="yes" xml:space="preserve">
          <source>TODO plans</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO 테스트는 &lt;b&gt;실행 가능한 TODO 목록&lt;/b&gt; 을 유지 관리하기 위해 설계되었습니다 . 이 테스트는</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">TODO, &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd529f1aacfef198f05ec640f141ac5fe8d0a0d0" translate="yes" xml:space="preserve">
          <source>TODO...</source>
          <target state="translated">TODO...</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO : = extend 중 하나 또는 두 개를 가리킨 다음 Pod :: Simple :: Subclassing을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">TODO : 문서화</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">해야 할 일 : 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO : 샘플 포드 입력 및 HTML 출력의 모음? 아니면 일반적인 관용구?</target>
        </trans-unit>
        <trans-unit id="2804185099bb0257ffff9bf0a6b003ba897a8c8c" translate="yes" xml:space="preserve">
          <source>TOGGLES</source>
          <target state="translated">TOGGLES</target>
        </trans-unit>
        <trans-unit id="fbc5612fa4f39d021c8212de6294e10fc0eb4c60" translate="yes" xml:space="preserve">
          <source>TOPMARK</source>
          <target state="translated">TOPMARK</target>
        </trans-unit>
        <trans-unit id="1b219778d2536bb7cb3443c1e48b1cdc6ec5bbcd" translate="yes" xml:space="preserve">
          <source>TOP_GV</source>
          <target state="translated">TOP_GV</target>
        </trans-unit>
        <trans-unit id="028dc78f2472e443fde9354a9093737ec708fdc1" translate="yes" xml:space="preserve">
          <source>TOP_NAME</source>
          <target state="translated">TOP_NAME</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">총 결과</target>
        </trans-unit>
        <trans-unit id="e69a3c58feb4943f28d4f3916d734de76e706681" translate="yes" xml:space="preserve">
          <source>TR16 implies a method to extend UTF-EBCDIC to encode points up through &lt;code&gt;2 ** 31 - 1&lt;/code&gt;. Perl uses this method for code points up through &lt;code&gt;2 ** 30 - 1&lt;/code&gt;, but uses an incompatible method for larger ones, to enable it to handle much larger code points than otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">변환 형식</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">트리 기반 패싱</target>
        </trans-unit>
        <trans-unit id="8c6a137afc05b19ebfa9464a819fe4c729451ba3" translate="yes" xml:space="preserve">
          <source>TRIEC</source>
          <target state="translated">TRIEC</target>
        </trans-unit>
        <trans-unit id="4c899cd91fe33df0b8e34be446bc5d1535c00392" translate="yes" xml:space="preserve">
          <source>TRIEE</source>
          <target state="translated">TRIEE</target>
        </trans-unit>
        <trans-unit id="4e29af22b66831d0809f9ed161ff9fdacd21c3da" translate="yes" xml:space="preserve">
          <source>TRIEM</source>
          <target state="translated">TRIEM</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">삼각법 함수</target>
        </trans-unit>
        <trans-unit id="fddf1df7c30cac7908d10246256efd264ce7aa32" translate="yes" xml:space="preserve">
          <source>TRUE</source>
          <target state="translated">TRUE</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="fe62cb78f4ed9f61dd4406f0f3143d6f618cef25" translate="yes" xml:space="preserve">
          <source>TYPEMAPS</source>
          <target state="translated">TYPEMAPS</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="fcac4a88dd04636da037a74fcf1d813d6bb5c767" translate="yes" xml:space="preserve">
          <source>TYPES OF VERSION OBJECTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb5c671d380f7e563f1ea67cb13227761e097ff" translate="yes" xml:space="preserve">
          <source>T_ARRAY</source>
          <target state="translated">T_ARRAY</target>
        </trans-unit>
        <trans-unit id="5a44f0733ece8e94e30b4779d69997f4ee33c56f" translate="yes" xml:space="preserve">
          <source>T_AVREF</source>
          <target state="translated">T_AVREF</target>
        </trans-unit>
        <trans-unit id="20c8d07e48603a91f5ad0258a9d7260fecf703f4" translate="yes" xml:space="preserve">
          <source>T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="441dcc9bf7c8874857cd2f07add2544a7aa18348" translate="yes" xml:space="preserve">
          <source>T_BOOL</source>
          <target state="translated">T_BOOL</target>
        </trans-unit>
        <trans-unit id="c96681120818e54685540689763746057da6c711" translate="yes" xml:space="preserve">
          <source>T_CALLBACK</source>
          <target state="translated">T_CALLBACK</target>
        </trans-unit>
        <trans-unit id="1d4f3aa1dcbc52712656445982d93cb57df8eefd" translate="yes" xml:space="preserve">
          <source>T_CHAR</source>
          <target state="translated">T_CHAR</target>
        </trans-unit>
        <trans-unit id="619c206b9e7e1179f8c572c2e0bbd5418dcbcd9c" translate="yes" xml:space="preserve">
          <source>T_CVREF</source>
          <target state="translated">T_CVREF</target>
        </trans-unit>
        <trans-unit id="6bf16578ac0037942fb294227b378783d6417250" translate="yes" xml:space="preserve">
          <source>T_CVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_CVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="ebd5f4b2b2cdf44ca91f90320178cc872c0e09c7" translate="yes" xml:space="preserve">
          <source>T_DATAUNIT</source>
          <target state="translated">T_DATAUNIT</target>
        </trans-unit>
        <trans-unit id="fe14988da15a2d4fcafb4d4c3fdba996b1d3919b" translate="yes" xml:space="preserve">
          <source>T_DOUBLE</source>
          <target state="translated">T_DOUBLE</target>
        </trans-unit>
        <trans-unit id="fc54a411f035f09e5b26e9d5967f486a6331f42c" translate="yes" xml:space="preserve">
          <source>T_ENUM</source>
          <target state="translated">T_ENUM</target>
        </trans-unit>
        <trans-unit id="d9144dfb59c0a6e098f071eb27226d345bb3b9a3" translate="yes" xml:space="preserve">
          <source>T_FLOAT</source>
          <target state="translated">T_FLOAT</target>
        </trans-unit>
        <trans-unit id="a488a491ef416eedb274173547cc94600a1c1be9" translate="yes" xml:space="preserve">
          <source>T_HVREF</source>
          <target state="translated">T_HVREF</target>
        </trans-unit>
        <trans-unit id="e9eb1cfbb5a736f4b47a7fce8d35e124bff4c588" translate="yes" xml:space="preserve">
          <source>T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4baf8db3b4ede993cae1ba43114ca8ba3f059451" translate="yes" xml:space="preserve">
          <source>T_IN</source>
          <target state="translated">T_IN</target>
        </trans-unit>
        <trans-unit id="0d34ad725c5d489d88c10068319bbe41b1372c3f" translate="yes" xml:space="preserve">
          <source>T_INOUT</source>
          <target state="translated">T_INOUT</target>
        </trans-unit>
        <trans-unit id="c9ac30f3bfe7d2f1be494ab16cbb62e6b0281825" translate="yes" xml:space="preserve">
          <source>T_INT</source>
          <target state="translated">T_INT</target>
        </trans-unit>
        <trans-unit id="71be7a946c6f9c8f878e909304790177b9d9322d" translate="yes" xml:space="preserve">
          <source>T_IV</source>
          <target state="translated">T_IV</target>
        </trans-unit>
        <trans-unit id="eaf82e3c7e0aec5ed4944f8734b7934b5d7a9464" translate="yes" xml:space="preserve">
          <source>T_LONG</source>
          <target state="translated">T_LONG</target>
        </trans-unit>
        <trans-unit id="5b8224b3c1fe92d5bae70adacc8eac05fd9a5fda" translate="yes" xml:space="preserve">
          <source>T_NV</source>
          <target state="translated">T_NV</target>
        </trans-unit>
        <trans-unit id="a6b2c10bebc0632668de5a633339c42212334462" translate="yes" xml:space="preserve">
          <source>T_OPAQUE</source>
          <target state="translated">T_OPAQUE</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE는 단순 유형의 입력 및 출력을 지원합니다. 포인터가 허용되는 경우 T_OPAQUEPTR을 사용하여 이러한 바이트를 C로 다시 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d81bbcffee2d4d53636e0cfc38c1802b032ce1e" translate="yes" xml:space="preserve">
          <source>T_OPAQUEPTR</source>
          <target state="translated">T_OPAQUEPTR</target>
        </trans-unit>
        <trans-unit id="94ed49f0fcb197292e8b44f17a54e91c96dfd034" translate="yes" xml:space="preserve">
          <source>T_OUT</source>
          <target state="translated">T_OUT</target>
        </trans-unit>
        <trans-unit id="2a34e55dba9603dc2ed22d9cbacb17ec8fa3b7aa" translate="yes" xml:space="preserve">
          <source>T_PACKED</source>
          <target state="translated">T_PACKED</target>
        </trans-unit>
        <trans-unit id="57d9968b716d10e58d7663155b60bcfe636fd9da" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY</source>
          <target state="translated">T_PACKEDARRAY</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY는 T_PACKED와 유사합니다. 실제로 &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) 유형 맵은 동일하지만 &lt;code&gt;OUTPUT&lt;/code&gt; 유형 맵은 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 함수에 추가 인수를 전달 합니다. 이 세 번째 매개 변수는 출력에서 ​​요소 수를 나타내므로 함수가 C 배열을 깔끔하게 처리 할 수 ​​있습니다. 변수는 사용자가 선언해야하며 이름은 &lt;code&gt;count_$ntype&lt;/code&gt; 이어야합니다. 여기서 &lt;code&gt;$ntype&lt;/code&gt; ntype 은 위에서 설명한 정규화 된 C 유형 이름입니다. 함수의 서명은 위의 예와 &lt;code&gt;foo_t **&lt;/code&gt; 에 대한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1c906d78fc823a0e9f29368dd513ce8a5418cee5" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820d7c1bd9a291e980383d064a4e16d0aba0000" translate="yes" xml:space="preserve">
          <source>T_PTR</source>
          <target state="translated">T_PTR</target>
        </trans-unit>
        <trans-unit id="af1f6fafe92e003dd267b2be4f4b4ef95598f8ab" translate="yes" xml:space="preserve">
          <source>T_PTRDESC</source>
          <target state="translated">T_PTRDESC</target>
        </trans-unit>
        <trans-unit id="1dea827458dd7afc9afab55ca4ec0182c83a4fc4" translate="yes" xml:space="preserve">
          <source>T_PTROBJ</source>
          <target state="translated">T_PTROBJ</target>
        </trans-unit>
        <trans-unit id="1ee34e1644f9ab8be830a408f52ae4dc2849ef55" translate="yes" xml:space="preserve">
          <source>T_PTRREF</source>
          <target state="translated">T_PTRREF</target>
        </trans-unit>
        <trans-unit id="c8c1dc76ec8744f6cb9d9c795f9bfbc5484c1e4d" translate="yes" xml:space="preserve">
          <source>T_PV</source>
          <target state="translated">T_PV</target>
        </trans-unit>
        <trans-unit id="3a5d267dcac84a0b73c5ab78fe0237e26042a945" translate="yes" xml:space="preserve">
          <source>T_REFOBJ</source>
          <target state="translated">T_REFOBJ</target>
        </trans-unit>
        <trans-unit id="35b0d1f3ee1694c51f5d1834c393cb455273def0" translate="yes" xml:space="preserve">
          <source>T_REFREF</source>
          <target state="translated">T_REFREF</target>
        </trans-unit>
        <trans-unit id="784caeb6be6fa5307fa5f6a8479f73d2c2a7691b" translate="yes" xml:space="preserve">
          <source>T_REF_IV_PTR</source>
          <target state="translated">T_REF_IV_PTR</target>
        </trans-unit>
        <trans-unit id="b3253f9127be3bdfed118ec52937984abc7c698c" translate="yes" xml:space="preserve">
          <source>T_REF_IV_REF</source>
          <target state="translated">T_REF_IV_REF</target>
        </trans-unit>
        <trans-unit id="586e2f7a6caf54d31aba57fd6ffdf405333ef314" translate="yes" xml:space="preserve">
          <source>T_SHORT</source>
          <target state="translated">T_SHORT</target>
        </trans-unit>
        <trans-unit id="5e2b55747cebf0deadf14e37c20ac8ae0c863ea6" translate="yes" xml:space="preserve">
          <source>T_STDIO</source>
          <target state="translated">T_STDIO</target>
        </trans-unit>
        <trans-unit id="998ce6a132418997f012a8d95a08e955ec444167" translate="yes" xml:space="preserve">
          <source>T_SV</source>
          <target state="translated">T_SV</target>
        </trans-unit>
        <trans-unit id="f74fedb4d19c9aae5df1a9a2556f420561de423a" translate="yes" xml:space="preserve">
          <source>T_SVREF</source>
          <target state="translated">T_SVREF</target>
        </trans-unit>
        <trans-unit id="b31c4d98a369de70efd9e1e28b9897a696583da4" translate="yes" xml:space="preserve">
          <source>T_SVREF_FIXED</source>
          <target state="translated">T_SVREF_FIXED</target>
        </trans-unit>
        <trans-unit id="4512816ed0e7eedba9cb2a4f99052651f37fbd5b" translate="yes" xml:space="preserve">
          <source>T_SYSRET</source>
          <target state="translated">T_SYSRET</target>
        </trans-unit>
        <trans-unit id="fe86ffcf28dab8688bad0d5d6a6ff6be7af3bf8e" translate="yes" xml:space="preserve">
          <source>T_UV</source>
          <target state="translated">T_UV</target>
        </trans-unit>
        <trans-unit id="d8679fa31c93e6fb7cc082350054dc4f5ca62292" translate="yes" xml:space="preserve">
          <source>T_U_CHAR</source>
          <target state="translated">T_U_CHAR</target>
        </trans-unit>
        <trans-unit id="464c580d57f537b018efa810de5fcaf9cd86a995" translate="yes" xml:space="preserve">
          <source>T_U_INT</source>
          <target state="translated">T_U_INT</target>
        </trans-unit>
        <trans-unit id="1df30c0b01ecbd04a2bc7cb066c197a1ef8a203b" translate="yes" xml:space="preserve">
          <source>T_U_LONG</source>
          <target state="translated">T_U_LONG</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG은 표준 유형 맵에서 &lt;code&gt;U32&lt;/code&gt; 유형에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="11359764d9baa3629eadc5745b2516619c5dfc84" translate="yes" xml:space="preserve">
          <source>T_U_SHORT</source>
          <target state="translated">T_U_SHORT</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT는 표준 유형 맵에서 &lt;code&gt;U16&lt;/code&gt; 유형에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">16 진수로 정렬 된 표, 1047 순서로 정렬</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">태그 처리 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="c4acb5d65a0f18ccc12ec4e74dc4599e0548b6c1" translate="yes" xml:space="preserve">
          <source>Tag that should prefix/identify the main text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">휴먼 언어의 태그 및 이름</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">언어 식별을위한 태그</target>
        </trans-unit>
        <trans-unit id="3837bf859c22ab45640f5a47597c86d61ec1aac5" translate="yes" xml:space="preserve">
          <source>Tailoring is not maximum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd10fdbdba33897c84afb3ba431dd5441966417" translate="yes" xml:space="preserve">
          <source>Tailoring tags provided by &lt;code&gt;Unicode::Collate&lt;/code&gt; are allowed as long as they are not used for &lt;code&gt;locale&lt;/code&gt; support. Esp. the &lt;code&gt;table&lt;/code&gt; tag is always untailorable, since it is reserved for DUCET.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="translated">오염 모드</target>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="translated">SV를 오염시킵니다. 대신 &lt;code&gt;SvTAINTED_on&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="translated">오염 검사는 농장을 기르기위한 프로그램을 작성하지 않았다는 것을 신뢰하더라도 가장 유용합니다. 농장을 사용하지 않는 사람들이 농장을 속이려고하지 않도록 믿지 않아도됩니다. 이는 CGI 프로그램과 같이 다른 사람을 대신하여 실행 된 set-id 프로그램 및 프로그램에 유용한 일종의 보안 검사입니다.</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">오염 모드</target>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="translated">오염 모드와 @INC</target>
        </trans-unit>
        <trans-unit id="ca7cdb9c133f6b8c9e0adf757dd404ca3a0059a6" translate="yes" xml:space="preserve">
          <source>Taint mode is a funny thing. It's the globalest of all global features. Once you turn it on, it affects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="translated">패턴이 대소 문자를 구분하지 않고 ( &lt;code&gt;/i&lt;/code&gt; 를 통해) 일치하는 경우에도 오염이 발생할 수 있습니다 . 이 방법으로 일치시킬 모든 코드 포인트가 255보다 크고 유니 코드 규칙에서 256보다 작은 폴드가없는 경우는 예외입니다. Perl은 이러한 코드 포인트에 유니 코드 규칙 만 사용하기 때문에 이러한 작업은 수행되지 않습니다. 현재 로케일에 상관없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="translated">오염이 활성화되어 있고 현재 표현식에 대한 일부 입력이 오염 된 경우 (일반적으로 변수이지만 로케일 설정과 같은 암시 적 입력) SV를 오염시킵니다. &lt;code&gt;SvTAINT&lt;/code&gt; 는 이러한 오염을 표현의 출력에 비관적 인 방식으로 전파합니다. 즉, 어떤 입력이 어떤 입력에 의해 영향을 받는지 정확하게주의하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="094d515b3608fefc6759a36412cee467437417a5" translate="yes" xml:space="preserve">
          <source>Taiwan</source>
          <target state="translated">Taiwan</target>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="translated">대만 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="721a6538b5b10ed9a1dc1b3ba2e846c06156cf4e" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;&quot;Good Practices&quot;&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="translated">최신 Perl 코드에서 사용하려는 일부 변형에 대한 &lt;a href=&quot;#Good-Practices&quot;&gt;모범 사례&lt;/a&gt; 를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="ce0dca464ee27d4966793e761a9ad0e74805bf7a" translate="yes" xml:space="preserve">
          <source>Take a look at the line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0faa440c7d98bab2d9d32df3b6d3a1c7c9671be2" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">sprintf 스타일 형식 패턴과 인수 목록을 가져옵니다. 이들은 문자열 메시지를 생성하는 데 사용됩니다. 메시지가 개행 문자로 &lt;a href=&quot;#mess_sv&quot;&gt;끝나지 않으면 mess_sv에&lt;/a&gt; 설명 된대로 코드에서 현재 위치를 표시하여 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="translated">릴리스 된 모듈을 변경할 때는주의하십시오.</target>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="translated">패키지 이름 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 이 아직 정의되지 않았기 때문에이 함수를 단순 테스트 ( &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; 등)로 사용할 때주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef3657e7016525093062a8f4afb4bc9e87224179" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;if(blessed $ref)...&lt;/code&gt;) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="translated">쉼표로 구분 된 문자열을 다른 필드로 분할하려는 경우를 예로 들어 보겠습니다. 쉼표가 따옴표 안에 있으면 나누지 않아야하므로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; 사용할 수 없습니다 . 예를 들어 다음과 같은 데이터 라인을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ea9de05e3ee1ea164412af8fdd54572b6cc0c61" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;split(/,/)&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="translated">인터페이스를 재고하고 재 설계 할 기회를 가지십시오.</target>
        </trans-unit>
        <trans-unit id="38337f43effe3e61774eb1d00c750689a8d079b1" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to hook an op checker should typically look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9469ecd951c6dfc6bb0697f6f2439dea0638b6" translate="yes" xml:space="preserve">
          <source>Taken all together, XS code to install a keyword plugin should typically look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="translated">이 기능들을 종합하면 Perl의 정규 표현식을보다 읽기 쉽게 만들 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a4ea905801094be1d9ff65acd694844f81d1d62" translate="yes" xml:space="preserve">
          <source>Takes STRING and replaces all referenced environment variable names with their defined values. References to environment variables take the form &lt;code&gt;%VariableName%&lt;/code&gt;. Case is ignored when looking up the VariableName in the environment. If the variable is not found then the original &lt;code&gt;%VariableName%&lt;/code&gt; text is retained. Has the same effect as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_in6&lt;/code&gt; 구조를 취합니다 . 포트 번호, IPv6 주소를 나타내는 불투명 문자열, 범위 ID 및 플로우 레이블의 네 가지 요소 목록을 리턴합니다. inet_ntop ()을 사용하여 주소를 일반적인 문자열 형식으로 변환 할 수 있습니다. 구조가 &lt;code&gt;AF_INET6&lt;/code&gt; 주소를 나타내지 않으면 크로 킹 됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_in&lt;/code&gt; 구조를 취합니다 (pack_sockaddr_in (), getpeername () 또는 recv ()에 의해 리턴 됨). 포트와 IP 주소를 나타내는 불투명 문자열의 두 가지 요소 목록을 리턴합니다 (inet_ntoa ()를 사용하여 주소를 4 점 숫자 형식으로 변환 할 수 있음). 구조가 &lt;code&gt;AF_INET&lt;/code&gt; 주소를 나타내지 않으면 크로 킹 됩니다.</target>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="translated">&lt;code&gt;sockaddr_un&lt;/code&gt; 구조를 취합니다 (pack_sockaddr_un (), getpeername () 또는 recv ()에 의해 리턴 됨). 하나의 요소 (경로 이름)의 목록을 반환합니다. 구조가 &lt;code&gt;AF_UNIX&lt;/code&gt; 주소를 나타내지 않으면 크로 킹 됩니다.</target>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="translated">값 목록을 가져 와서 TEMPLATE에서 제공 한 규칙을 사용하여 문자열로 변환합니다. 결과 문자열은 변환 된 값의 연결입니다. 일반적으로 변환 된 각 값은 시스템 수준 표현처럼 보입니다. 예를 들어, 32 비트 시스템에서 정수는 4 바이트의 시퀀스로 표시 될 수 있으며 Perl에서는 4 자 길이의 문자열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9e5ca84b2f91280b89e01ed94d448f6437f46f" translate="yes" xml:space="preserve">
          <source>Takes a Perl file handle [like &lt;code&gt;STDIN&lt;/code&gt;] and returns the Win32 native file handle associated with it. See &lt;code&gt;FdGetOsFHandle&lt;/code&gt; for more information about Win32 native file handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777f296cd09b6af58dac04faade91e80e2f742c" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version by release date where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7b238435e86c0619ef99b46a51606dfb01c0fc" translate="yes" xml:space="preserve">
          <source>Takes a UTILITY name as an argument, returns the first perl version where that utility was removed from core. Returns undef if the given utility was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a15df0cc84f3e918f628b048394d65bbdcbb8c8" translate="yes" xml:space="preserve">
          <source>Takes a Win32 native file handle and returns a &lt;code&gt;FILE_TYPE_*&lt;/code&gt; constant indicating the type of the file opened on that handle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="translated">대상 경로와 선택적 기본 경로를 가져 와서 기본 경로에서 대상 경로로의 상대 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="translated">대상 경로를 가져오고 선택적 기본 경로는 기본 경로에서 대상 경로로의 상대 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="translated">파일 이름, 데이터로 가득 찬 스칼라 및 선택적으로 특정 옵션이있는 해시에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="translated">기능 목록을 인수로 취하고이를 찾지 못하면 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="translated">파일 이름 목록을 가져 와서 메모리 내 아카이브에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">모듈 이름을 인수로 사용하여 해당 모듈이 코어에서 제거 된 릴리스 날짜별로 첫 번째 perl 버전을 리턴합니다. 주어진 모듈이 코어에 없거나 코어에 남아 있으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="translated">모듈 이름을 인수로 사용하여 해당 모듈이 코어에서 제거 된 첫 번째 펄 버전을 반환합니다. 주어진 모듈이 코어에 없거나 코어에 남아 있으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="translated">배열 기본 $ [의 값인 숫자를 사용합니다. Perl 5.15.3 이상에서는 0이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cab02ff3e969b64dc6518292e8f9492855489a1" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Obsolete: cannot be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4a8a89e95ecb8b9eb4bb3b63296961b32f06d1" translate="yes" xml:space="preserve">
          <source>Takes a numeric mode to apply to each created directory (not modified by the current &lt;code&gt;umask&lt;/code&gt;). If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="translated">unpack_sockaddr_in () 또는 네트워크 순서로 IPv4 주소의 4 옥텟을 나타내는 v- 문자열에 의해 리턴되는 압축 2 진 주소 구조를 취하여 &lt;code&gt;d.d.d.d&lt;/code&gt; 형식의 문자열로 변환합니다. 여기서 &lt;code&gt;d&lt;/code&gt; 는 256보다 작은 숫자입니다. (인터넷 주소에 대한 사람이 읽을 수있는 일반적인 4 자리 숫자 표기법).</target>
        </trans-unit>
        <trans-unit id="85cecd3a3130634b28d9c069ebd221905ff6684f" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt;s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="translated">압축 소켓 주소를 취합니다 (pack_sockaddr_in (), pack_sockaddr_un () 또는 perl 내장 함수 getsockname () 및 getpeername ()에 의해 리턴 됨). 주소 패밀리 태그를 반환합니다. 이것은 &lt;code&gt;sockaddr_in&lt;/code&gt; 에 대한 &lt;code&gt;AF_INET&lt;/code&gt; 과 같은 &lt;code&gt;AF_*&lt;/code&gt; 상수 중 하나입니다. 주소 또는 &lt;code&gt;AF_UNIX&lt;/code&gt; A의 &lt;code&gt;sockaddr_un&lt;/code&gt; . 알 수없는 유형의 sockaddr에 사용할 압축 풀기를 알아내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00add5c8a4a149ed8051f75aa539f8eec919c737" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt;. It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace3db72b47fd10c721426b5e390e2e0c6f992fc" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition is a &quot;container&quot; partition that is supported under Win32, that is, whether it is an &quot;extended&quot; partition that can contain &quot;logical&quot; partitions. &lt;code&gt;$ivPartitonType&lt;/code&gt; is as for &lt;code&gt;IsRecognizedPartition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d61f271c3866d065bf72b7810d6f1c5dfb4bf3f" translate="yes" xml:space="preserve">
          <source>Takes a partition type and returns whether that partition type is supported under Win32. &lt;code&gt;$ivPartitonType&lt;/code&gt; is an integer value as from the operating system byte of a hard disk's DOS-compatible partition table [that is, a partition table for x86-based Win32, not, for example, one used with Windows NT for Alpha processors]. For example, the &lt;code&gt;PartitionType&lt;/code&gt; member of the &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fe4b00a1515bab6009cc465d438231923fa5fb" translate="yes" xml:space="preserve">
          <source>Takes a path string and returns an unsigned value with attribute flags. If it fails, it returns INVALID_FILE_ATTRIBUTES, otherwise it can be one or more of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="translated">파일 또는 dir에 대한 경로를 가져 와서이 파일을 라이브러리에 포함하지 않으려면 빈 문자열을 반환합니다. 그렇지 않으면 $ path를 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">펄 버전을 인수로 사용합니다. 해당 펄 버전이 존재하는 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 그렇지 않으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d9afb26d884d8b2dac4569e9ebf9cb1409e2dee" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Upon successful completion, returns a reference to a hash. Each element of that hash has a key which is the name of a module (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="translated">에 의해 생성 된 인용 된 정규 표현식을 취합니다. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 또는 정규 표현식을 나타내는 문자열 옵니다 .</target>
        </trans-unit>
        <trans-unit id="1da3bec748134b01442fc634b8967f8ffc71be4b" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;qr//&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="translated">Perl 값에 대한 참조를 가져와 참조 된 값을 적절한 B :: OP 파생 또는 B :: SV 파생 클래스의 개체로 바꿉니다. 다음과 같은 기능 외에도 &lt;code&gt;main_root&lt;/code&gt; , 이것은 내부 perl 데이터 구조에서 초기 &quot;핸들&quot;을 얻는 다른 방법으로 다른 액세스 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9bcf1191796c7d482572c3d5fd8f112b75e9de7" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt;, this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="translated">정규식을 인수로 사용하고 주어진 정규식과 일치하는 모듈 목록을 반환합니다. 정규식 만 제공되는 경우 모든 perl 버전의 모든 모듈에 적용됩니다. 선택적으로 정규식 검색을 제한하기 위해 perl 버전 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="translated">sprintf 스타일 형식 패턴과 일반 (비 SV) 인수를 사용하여 형식화 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="translated">호스트 이름 또는 IP 주소의 텍스트 표현을 제공하는 문자열을 취하여 pack_sockaddr_in ()에 전달하기에 적합한 압축 이진 주소 구조로 변환합니다. 확인할 수없는 호스트 이름을 전달한 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. . 멀티 홈 호스트 (주소가 둘 이상있는 호스트)의 경우 찾은 첫 번째 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5e03d93715b3e17db35edf143d3a334a6aaebce" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;undef&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223ad84fa206d265b475ea00fd86ad6d14a4bf08" translate="yes" xml:space="preserve">
          <source>Takes a string giving the path to the root directory of a file system [called a &quot;drive&quot; because every file system is assigned a &quot;drive letter&quot;] and returns an unsigned value indicating the type of drive the file system is on. The return value should be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="translated">공백으로 구분 된 값 목록이 포함 된 문자열을 가져옵니다. &quot;all&quot;및 &quot;none&quot;값은 다시 특별합니다. 여기에 배열 참조를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="translated">공백으로 구분 된 값 목록이 포함 된 문자열을 가져옵니다. &quot;all&quot;및 &quot;none&quot;값은 특별합니다. 여기에 배열 참조를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="translated">공백으로 구분 된 여러 값을 포함하는 문자열을 가져옵니다. &quot;all&quot;과 &quot;none&quot;이라는 특별한 값은 기대하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="translated">&lt;code&gt;ip_mreq&lt;/code&gt; 구조를 취합니다 . 두 요소의 목록을 리턴합니다. IPv4 멀티 캐스트 주소 및 인터페이스 주소</target>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="translated">&lt;code&gt;ip_mreq_source&lt;/code&gt; 구조를 취합니다 . 세 가지 요소의 목록을 반환합니다. IPv4 멀티 캐스트 주소, 소스 주소 및 인터페이스 주소</target>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="translated">걸린다 &lt;code&gt;ipv6_mreq&lt;/code&gt; 의 구조. 두 요소의 목록을 리턴합니다. IPv6 주소 및 인터페이스 번호</target>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv4 멀티 캐스트 주소와 선택적으로 인터페이스 주소 (또는 &lt;code&gt;INADDR_ANY&lt;/code&gt; )를 사용합니다. 인수로 &lt;code&gt;ip_mreq&lt;/code&gt; 구조를 리턴합니다 . &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; 및 &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; 와 함께 사용하기에 적합 sockopts .</target>
        </trans-unit>
        <trans-unit id="daef79d0571cfe13a97a3c30841461dc9af70aa5" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv4 멀티 캐스트 주소, 소스 주소 및 선택적으로 인터페이스 주소 (또는 &lt;code&gt;INADDR_ANY&lt;/code&gt; )를 사용합니다. 인수가 압축 된 &lt;code&gt;ip_mreq_source&lt;/code&gt; 구조를 리턴합니다 . &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; 및 &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts 와 함께 사용하기에 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="0e03de7d098eab496f44ea7920e441314209dd86" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt;). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="translated">IPv6 멀티 캐스트 주소와 인터페이스 번호를 사용합니다. 인수가 팩된 &lt;code&gt;ipv6_mreq&lt;/code&gt; 구조를 리턴합니다 . &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; 및 &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; 와 함께 사용하기에 적합 sockopts .</target>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="translated">주소 패밀리 (예 : &lt;code&gt;AF_INET&lt;/code&gt; 또는 &lt;code&gt;AF_INET6&lt;/code&gt; )와 해당 패밀리에있는 주소의 텍스트 표현을 포함하는 문자열을 가져와 이를 팩 바이너리 주소 구조로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7c090993da78e7530e8d560d6312459708f8366d" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt;) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="translated">주소 패밀리와 압축 이진 주소 구조를 가져 와서 사람이 읽을 수있는 주소의 텍스트 표현으로 변환합니다. 일반적으로 &lt;code&gt;AF_INET&lt;/code&gt; 의 경우 &lt;code&gt;d.d.d.d&lt;/code&gt; 형식 또는 &lt;code&gt;AF_INET6&lt;/code&gt; 의 경우 &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; 형식 .</target>
        </trans-unit>
        <trans-unit id="67141b039613b21f893d0875c6a0c29a2e6abaca" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="translated">항목 배열을 가져 와서 형식이 지정된 인수 목록으로 바꿉니다. 대부분의 경우 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="translated">경로를 인수로 받아서 절대 경로 인 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="translated">경로를 인수로 받아서 절대 경로 인 경우 true를 리턴합니다. 경로에 선행 &quot;:&quot;이 있으면 상대 경로입니다. 그렇지 않으면 경로에 콜론이 포함되어 있지 않은 경우 (예 : &quot;a&quot;와 같은 이름이 아닌 경우) 절대 경로입니다. 이 특정한 경우, 경로는 상대적인 것으로 간주됩니다 (즉, 파일 이름으로 간주됩니다). 명확하게 구별하려면 경로의 적절한 위치에 &quot;:&quot;을 사용하십시오. 특별한 경우 파일 이름 ''은 항상 절대적인 것으로 간주됩니다. File :: Spec :: Mac 버전 1.2에서는 더 이상 로컬 파일 시스템을 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="translated">디렉토리 이름과 정규식을 인수로 사용합니다. 디렉토리에서 정규식과 일치하는 모든 항목을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="translated">경로를 인수로 사용하고 절대 경로 인 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff1dec49488d5f7d1892eedad0ad929bfc6263b5" translate="yes" xml:space="preserve">
          <source>Takes named parameters: If &lt;code&gt;shallow&lt;/code&gt; is true, the clone will share the actual individual type/input/outputmap objects, but not share their storage. Use with caution. Without &lt;code&gt;shallow&lt;/code&gt;, the clone will be fully independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="translated">인수를 취하지 않고 환경 변수 PATH를 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="translated">논증하지 않습니다. 환경 변수 &lt;code&gt;PATH&lt;/code&gt; (또는 로컬 플랫폼과 동등한)를 목록으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="translated">하나의 인수 ( 'stdin'| 'stdout'| 'stderr')를 가져오고 오브젝트의 IoIFP가 이름이 인수로 전달 된 핸들과 동일한 경우 true를 리턴합니다. 즉, IoIFP ($ io) == PerlIO_stderr ()이면 $ io-&amp;gt; IsSTD ( 'stderr')는 true입니다.</target>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="translated">하나의 인수 인 파일 이름을 사용하고 인수가 perl 스크립트 일 가능성이있는 경우 파일 이름을 리턴합니다. MM_Unix에서는 읽을 수있는 일반 파일에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">하나의 인수, 경로 이름을 사용합니다. 해당 경로가 &lt;code&gt;AF_UNIX&lt;/code&gt; 로 채워진 &lt;code&gt;sockaddr_un&lt;/code&gt; 구조를 리턴합니다 . &lt;code&gt;PF_UNIX&lt;/code&gt; 의 경우 소켓의 경우이 구조는 일반적으로 bind (), connect () 및 send ()의 인수에 필요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="translated">하나의 인수를 취합니다 : &lt;code&gt;$type&lt;/code&gt; . 이 $ type의 클래스를 반환하거나 오류가있는 &lt;code&gt;croak&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f924ea1eb572a2d6d41c219191b1f7ad36177be9" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt;. Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt;s with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="translated">'Foo / Bar.pm'형식의 중첩 패키지 일 수있는 패키지 이름을 사용하고 슬래시를 &lt;code&gt;::&lt;/code&gt; 또는 맨 페이지 파일 이름에 안전한 다른 이름으로 바꿉니다 . 교체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="778216c494c51654f317b1afb524185f02d3ff50" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the &lt;code&gt;@ISA&lt;/code&gt; of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="translated">지정된 패키지의 @ISA가 변경된 경우 필요한 단계 (대부분 캐시 무효화)를 수행합니다. &lt;code&gt;setisa&lt;/code&gt; 매직에 의해 호출되며 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b306490f4adab44f2505affe31e89e35e98c934" translate="yes" xml:space="preserve">
          <source>Takes the object file as an argument, and returns the portion of compile command-line that will output to the specified object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="translated">포트 번호와 불투명 문자열 (inet_aton () 또는 v- 문자열로 반환)과 같은 두 개의 인수를 사용합니다. 반환이 &lt;code&gt;sockaddr_in&lt;/code&gt; 그 인수 구조는 포장 및 &lt;code&gt;AF_INET&lt;/code&gt; 에 가득 찼다. 인터넷 도메인 소켓의 경우,이 구조는 당신이 연결 ()) 바인딩 (에 인수해야하고, 송신 () 무엇 일반적이다.</target>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt; 두 가지 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55ed19e4eb2d24e5b863b8b237b5077e73ee7f56" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt;, &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="translated">포트 번호, 불투명 한 문자열 (inet_pton ()에 의해 리턴 된대로), 선택적으로 범위 ID 번호 및 선택적으로 플로우 레이블 번호 인 2-4 개의 인수를 사용합니다. &lt;code&gt;sockaddr_in6&lt;/code&gt; 을 리턴합니다.인수로 구조와 &lt;code&gt;AF_INET6&lt;/code&gt; 을 채워. pack_sockaddr_in의 IPv6의 당량 ().</target>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="translated">볼륨, 디렉토리 및 파일 부분을 가져와 전체 경로를 반환합니다. Mac OS에서는 $ volume, $ directory 및 $ file이 연결됩니다. 필요한 경우 ':'이 삽입됩니다. 각 부분에 빈 문자열을 전달할 수 있습니다. 모든 부분이 비어 있으면 빈 문자열이 반환됩니다. $ volume이 비어 있으면 결과는 ':'로 시작하는 상대 경로가됩니다. $ volume 및 $ directory가 비어 있으면 $ file에서 선행하는 &quot;:&quot;(있는 경우)가 제거되고 나머지가 리턴됩니다. $ file이 비어 있으면 결과 경로는 후행 ':'을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="translated">볼륨, 디렉토리 및 파일 부분을 가져와 전체 경로를 반환합니다. Unix에서는 $ volume이 무시되고 디렉토리와 파일이 연결됩니다. 필요한 경우 '/'가 삽입됩니다 (디렉토리 부분이 '/'로 시작하지 않아도 추가되지는 않음). 다른 OS에서는 $ volume이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="translated">볼륨, 디렉토리 및 파일 부분을 가져와 전체 경로를 반환합니다. 유닉스에서 $ volume은 무시되며 이것은 catfile ()과 같습니다. 다른 OS에서는 $ volume이 중요해집니다.</target>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="translated">볼륨, 디렉토리 및 파일 부분을 가져와 전체 경로를 반환합니다. Unix에서는 &lt;code&gt;$volume&lt;/code&gt; 이 무시되고 디렉토리와 파일이 연결됩니다. 필요한 경우 '/'가 삽입됩니다. 다른 OS에서는 &lt;code&gt;$volume&lt;/code&gt; 이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="translated">패턴, 일반적으로 &lt;b&gt;정규 표현식&lt;/b&gt; 을 가져 와서 패턴을 문자열에 대한 다양한 방법으로 시도하여 패턴을 적합하게 만드는 방법이 있는지 확인하십시오. 종종 파일에서 흥미로운 tidbit를 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="translated">열거 된 목록을 참조하는 것은 대괄호를 사용하는 것과 같지 않습니다. 대신 참조 목록을 만드는 것과 같습니다!</target>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="translated">공유 배열 및 해시의 요소를 참조한다고해서 요소가 자동으로 활성화되지는 않으며 존재하지 않는 인덱스 / 키로 공유 배열 / 해시를 슬라이스해도 요소가 자동으로 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="translated">Tanenbaum, Andrew S. 분산 운영 체제. 1995 년 Prentice Hall, ISBN 0-13-219908-4 (위대한 교과서).</target>
        </trans-unit>
        <trans-unit id="1dc610a84e3953106d973aac027936828f4fd583" translate="yes" xml:space="preserve">
          <source>TangutSources.txt</source>
          <target state="translated">TangutSources.txt</target>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="translated">타르 명령의 상세 수준 (없음 또는 v 또는 vv)?</target>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="translated">타르 매직 문자열-대부분의 사용자에게 유용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="translated">타르 버전 문자열-대부분의 사용자에게 유용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="translated">대상 &lt;code&gt;dist&lt;/code&gt; 는 분배 파일 세트를 준비합니다. 대상 &lt;code&gt;zipdist&lt;/code&gt; 는 &lt;code&gt;dist&lt;/code&gt; 와 동일하게 수행 되지만 추가로 배포 파일을 zip 아카이브로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="3775eca859de6dcfb4c426728c102c801b4a309a" translate="yes" xml:space="preserve">
          <source>Target of goto is too deeply nested</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="a84eec2edc9ad24f299c8e16c921ff89b0a72d34" translate="yes" xml:space="preserve">
          <source>Tatsuhiko Miyagawa &amp;lt;miyagawa@bulknews.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="translated">Tautologous 부울 연산자는 여전히 최적화 될 예정입니다. 쓰려고 유혹하지 마십시오</target>
        </trans-unit>
        <trans-unit id="b7381d80f99d092ee04058e78cf491f1a66d6d65" translate="yes" xml:space="preserve">
          <source>Technical note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="translated">기술적으로 함수 포인터와 데이터 포인터 간의 캐스트 캐스팅은 이식 가능하지 않으며 정의되지 않지만 실제로는 작동하는 것처럼 보이지만 FPTR2DPTR () 및 DPTR2FPTR () 매크로를 사용해야합니다. 때때로 당신은 또한 노조와 게임을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="translated">기술적으로 말하면 &lt;code&gt;$!&lt;/code&gt; 와 같은 변수에 추가 의미가 추가됩니다 . , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; 또는 &lt;code&gt;%SIG&lt;/code&gt; 또는 연결된 변수 그 변수들을 iddle 때 마법의 일이 일어납니다.</target>
        </trans-unit>
        <trans-unit id="37c0cdada9acbef172bbad2abeee43e9c265bf5f" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;%ENV&lt;/code&gt;, or &lt;code&gt;%SIG&lt;/code&gt;, or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e2f047cca74ccc3c9d17a9bfaad25ab5dfd70e" translate="yes" xml:space="preserve">
          <source>Technically, or mathematically, speaking, a character set encoded in such a CES that maps character by character may form a CCS. EUC is such an example. The CES of EUC is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bceeda0d1cb49658a382ae82742f6ea314f38047" translate="yes" xml:space="preserve">
          <source>Tell</source>
          <target state="translated">Tell</target>
        </trans-unit>
        <trans-unit id="36cdc28b89efb53a06a6917a07b767fb68103199" translate="yes" xml:space="preserve">
          <source>Tell all procs/threads it is time to be done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9278f94e7a82313efec40ca2dd22098d512b4425" translate="yes" xml:space="preserve">
          <source>Tell other processes and events that an event is pending. &lt;code&gt;$uniq_val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7dda96092209462b6b29c0664b9391938707a82" translate="yes" xml:space="preserve">
          <source>Tell other processes and threads there is a pending event. &lt;code&gt;$val&lt;/code&gt; should be a unique value no other thread/process will generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="translated">문법에 어떤 TAP 구문 버전을 지원할지 알려주십시오. 지원되는 가장 낮은 버전은 12입니다. 'TAP 버전'은 유효한 버전 12 구문이 아니지만 더 높은 버전 번호를 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="translated">테스트 통과 여부를 결정할 때 파서에게 테스트의 종료 상태를 무시하도록 지시하십시오. 일반적으로 종료 상태가 0이 아닌 테스트는 모든 개별 테스트를 통과하더라도 실패한 것으로 간주됩니다. 테스트 스크립트의 종료 값을 제어 할 수없는 경우이 옵션을 사용하여 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="translated">파서에게 출력이 어디로 가야하는지 알려주십시오. 이 경우 $ html 변수에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="translated">원격 서버에 내가 사용자 클라이언트가 아니라 다른 뉴스 서버라고 말하십시오.</target>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="translated">원격 서버에 EHLO 명령 (또는 EHLO가 실패한 경우 HELO)을 사용중인 메일 도메인을 알려주십시오. 이 메소드는 Net :: SMTP 오브젝트가 구성 될 때 자동으로 호출되므로 사용자는 일반적으로 수동으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="translated">서버에게 &lt;code&gt;FILE&lt;/code&gt; 이라는 파일 끝에 데이터를 추가하고 싶다고 알려주십시오 . 이 파일이 없으면 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8ff5b934cbf9d3fd05d80b879d5b2e694a3f82ae" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt;. If this file does not exist then create it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="translated">서버에게 다른 서버가 아니라 독자임을 알리십시오.</target>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="translated">파일을 저장할 서버를 알려주십시오. &lt;code&gt;FILE&lt;/code&gt; 은 만들어야하는 새 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="translated">수동 모드 (로 이동하려면 서버에게 &lt;code&gt;pasv&lt;/code&gt; IPv4의, &lt;code&gt;epsv&lt;/code&gt; IPv6에 대한). 서버가 청취중인 포트를 나타내는 텍스트를 리턴합니다.이 텍스트는 &lt;code&gt;port&lt;/code&gt; 또는 &lt;code&gt;eprt&lt;/code&gt; 메소드를 사용하여 다른 ftp 서버로 전송하기에 적합한 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="07221dbb3d1c9d6040ef943ff42c4107c54603a8" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;Email::Stuffer&quot;&gt;Email::Stuffer&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="translated">말하는 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;이메일 :: 발신자 :: 간단한&lt;/a&gt; 교통편 사용은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="translated">주어진 문자열을 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하고 SV * 결과를 반환하도록 Perl에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">SV에서 문자열 을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하도록 Perl에 지시 합니다. &lt;code&gt;call_sv&lt;/code&gt; 제외하고 call_sv와 동일한 플래그를 지원합니다 . &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="translated">문자열 인수로 명명 된 파일 을 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하도록 Perl에 지시 합니다 . Perl 코드 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; 과 유사합니다 . 심지어 그런 식으로 구현되었습니다. 대신 load_module 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1b1b082272b9bd4181468eabc6b8e44fc8fe6c64" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3df8e8a89eba38389eed572b608ff46f9135ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;eval&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt;, with the obvious exception of &lt;code&gt;G_EVAL&lt;/code&gt;. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ee5f386d4eccf5016f84f3d99b790dcda5f79" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;require&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;eval &quot;require '$file'&quot;&lt;/code&gt;. It's even implemented that way; consider using load_module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="translated">Test :: Builder에게 함수를 내 보낸 패키지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl 인터프리터에게 Perl 스크립트를 구문 분석하도록 지시합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fc8f2629186f20e45a65a6df178e8841854cf49" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. This performs most of the initialisation of a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af02c41897ccb1ab6624206547ff7270321f616" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run its main program. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl 인터프리터가 실행되도록 지시합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="translated">SV에게 double임을 알리고 다른 모든 OK 비트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="translated">SV에게 double이라고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="38d5abd50f24b07310ee29175bef33b4202c7809" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits, and leaves the UTF-8 status as it was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fe87231b97a4e4ddb62ec499c5ee8942eac05a" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other &lt;code&gt;OK&lt;/code&gt; bits. Will also turn off the UTF-8 status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="translated">SV에게 문자열임을 알리고 다른 모든 OK 비트를 비활성화하고 UTF-8 상태를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="translated">SV에게 문자열임을 알리고 다른 모든 OK 비트를 비활성화합니다. UTF-8 상태도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="translated">SV에게 문자열임을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="translated">SV에게 RV임을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6c3d42b807cb60d5c1d3b6f5a5dbefd19d80f738" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="translated">SV에게 정수임을 알리고 다른 모든 OK 비트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="translated">SV에게 정수임을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="32b076858cb529d5d1d166704ef6d15c34643322" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other &lt;code&gt;OK&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="translated">SV에 부호없는 정수임을 알리고 다른 모든 OK 비트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2f015ae08c2ba0f00c29151908ca6bc489974130" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="translated">SV에게 문자열 값을 찾기 위해 &lt;code&gt;ptr&lt;/code&gt; 을 사용하도록 지시합니다. &lt;code&gt;flags&lt;/code&gt; 가 0 인 &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 를 호출 하여 구현 되므로 'set'마술을 처리하지 않습니다. &lt;code&gt;sv_usepvn_flags&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f1684ac88b387a920693532449fce7adef04529" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;&lt;code&gt;Newx&lt;/code&gt;&lt;/a&gt;. It must be the start of a &lt;code&gt;Newx&lt;/code&gt;-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;&lt;code&gt;OOK&lt;/code&gt;&lt;/a&gt; and copy-on-write), and not be from a non-&lt;code&gt;Newx&lt;/code&gt; memory allocator like &lt;code&gt;malloc&lt;/code&gt;. The string length, &lt;code&gt;len&lt;/code&gt;, must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt;, so that pointer should not be freed or used by the programmer after giving it to &lt;code&gt;sv_usepvn&lt;/code&gt;, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="translated">SV에게 문자열 값을 찾기 위해 &lt;code&gt;ptr&lt;/code&gt; 을 사용하도록 지시합니다. 일반적으로 문자열은 SV 내부에 저장되지만 sv_usepvn을 사용하면 SV에서 외부 문자열을 사용할 수 있습니다. &lt;code&gt;ptr&lt;/code&gt; 에 의해 할당 된 메모리를 가리켜 야 &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;의 newx&lt;/a&gt; . 그것은 메모리의 newx - 에드 블록의 시작, 그리고 그것의 한가운데에 대한 포인터해야합니다 (조심 &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; 및 기록 중 복사)와 같은 비의 newx 메모리 할당에서하지 &lt;code&gt;malloc&lt;/code&gt; . 문자열 길이 &lt;code&gt;len&lt;/code&gt; 이 제공되어야합니다. 기본적으로이 함수는 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 메모리를 &lt;code&gt;Renew&lt;/code&gt; (즉, realloc, 이동)합니다 따라서 프로그래머가 sv_usepvn에 포인터를 제공 한 후 포인터를 해제하거나 사용해서는 안되며 해당 포인터 뒤에있는 포인터 (예 : ptr + 1)도 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fa94c122bdfc00ca551536773f45fe7b4444a81f" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="translated">명명 된 함수 (그러나 &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts의 내부 함수&lt;/a&gt; 참조 ) 또는 명명 된 소스 파일의 지정된 행에 도달하면 실행을 일시 중지하고 싶다고 디버거에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="translated">split 연산자가 대상 문자열을 문자로 분할하도록 지시합니다. 문자의 정의는 대상 문자열이 UTF-8 문자열인지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="translated">분할 연산자가 정규식 엔진을 호출하지 않고 대상 문자열을 줄 바꾸기 ( &lt;code&gt;\n&lt;/code&gt; ) 로 분할하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="7add2a85af4113fd669c82c4ee4e7afc64bec786" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt;) without invoking the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="translated">분할 연산자가 정규식 엔진을 호출하지 않고 공백에서 대상 문자열을 분할하도록 지시합니다. 공백 정의는 대상 문자열이 UTF-8 문자열인지와 RXf_PMf_LOCALE이 설정되어 있는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="translated">객체의 갱신 여부 및 횟수를 나타냅니다. 일부 모듈 은 값이 숫자가 아닌 경우 &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; 경고 에서 초기화되지 않은 값 사용을 방출 하므로 false 인 경우 0을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="fe08a0c4d36ed96cbb4447cc6f3eff3004614a0a" translate="yes" xml:space="preserve">
          <source>Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; 2001-2009.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7760f2328a8cb1216abc5d480c3f7c025535cee" translate="yes" xml:space="preserve">
          <source>Temp dir + Files concurrency model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="translated">템플릿 그룹화</target>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="translated">템플릿 코드 &lt;code&gt;P&lt;/code&gt; 는 &quot;고정 길이 문자열에 대한 포인터&quot;를 포장 할 것을 약속합니다. 이것이 우리가 원하는 것이 아닌가? 해보자:</target>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="translated">템플리트는 mkstemp ()에 필요한 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3d3a072632618e86894944ff55a4538808fd8ea6" translate="yes" xml:space="preserve">
          <source>Temporaries Stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="translated">적절한 플래그를 지워서 XOP 멤버를 일시적으로 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="translated">적절한 플래그를 지워서이 BHK 구조에서 항목을 일시적으로 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e7f1b0942dc03abbb9406810a4ca16b57247a87e" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag. &lt;code&gt;which&lt;/code&gt; is a preprocessor token indicating which entry to disable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="translated">로캘 문제를 일시적으로 수정</target>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="translated">분류 된 &lt;code&gt;CPAN.pm&lt;/code&gt; 구성 변수를 임시로 대체 하십시오.</target>
        </trans-unit>
        <trans-unit id="8d8d27f44975a51a83ee576661872ef78010f131" translate="yes" xml:space="preserve">
          <source>Temporary (no file directory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="translated">local ()을 통한 임시 값</target>
        </trans-unit>
        <trans-unit id="966d13f8587efdadd4d1a975aa3423e8769b72b3" translate="yes" xml:space="preserve">
          <source>Temporary delete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="translated">임시 파일 및 NFS</target>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="translated">실패하지 않는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ac69447a0c644cecd1c09f31f389b73f4febee" translate="yes" xml:space="preserve">
          <source>Tenon Machten</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="translated">언어 변호사가 저장 위치에 사용하는 용어 &lt;b&gt;변수&lt;/b&gt; 또는 &lt;b&gt;배열&lt;/b&gt; 요소 와 같은 새로운 &lt;b&gt;값&lt;/b&gt; 을 할당 할 수 있습니다 . &amp;ldquo;l&amp;rdquo;은 할당의 왼쪽과 같이 lvalue의 일반적인 위치 인&amp;ldquo;left&amp;rdquo;의 약어입니다. &lt;b&gt;lvaluable&lt;/b&gt; 기능 또는 발현이 값에서와 같이, 할당 될 수도있는 하나 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; ($ X) = 10 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3570ded95db6a210fa183ad2282d08a349916fef" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;pos($x) = 10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="translated">Term :: ANSIColor-ANSI 이스케이프 시퀀스를 사용한 컬러 화면 출력</target>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="translated">용어 :: ANSIColor는 색상을 얻는 데 사용되므로이 모듈을 사용하려면 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="translated">Term :: ANSIColor는 Perl 5.6.0에서 Perl에 처음 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="translated">Term :: Cap-Perl termcap 인터페이스</target>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="translated">용어 :: 완료-Perl 단어 완성 모듈</target>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="translated">Term :: ReadLine-다양한 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 패키지에 대한 Perl 인터페이스 . 실제 패키지가 없으면 기본 기능 대신 스텁을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="7113fd2a1763597777139799d4259876fd00d022" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;readline&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b36cab4785101b615f79c20885ccd2eda2f048" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into four types: ones that support only eight colors, ones that support sixteen, ones that support 256, and ones that support 24-bit color. This module provides the ANSI escape codes for all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), 16 through 255 (256-color), and true color (called direct-color by &lt;b&gt;xterm&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="translated">색상을 지원하는 터미널 에뮬레이터는 8 가지 색상 만 지원하는 색상, 16 개를 지원하는 색상, 256을 지원하는 색상으로 구분됩니다.이 모듈은 모두 ANSI 이스케이프 코드를 제공합니다. 이러한 색상을 ANSI 색상 0 ~ 7 (일반), 8 ~ 15 (16 색) 및 16 ~ 255 (256 색)라고합니다.</target>
        </trans-unit>
        <trans-unit id="06b99286ab352f9eeaab809a6a34ccd3528b3299" translate="yes" xml:space="preserve">
          <source>Terminal interface values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="translated">파서 사용을 종료합니다. 일반적으로 서브 클래스에서 사용 및 / 또는 재정의됩니다. 이로 인해 파서는 파기되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">압축 된 데이터 스트림을 종료하고 보류중인 압축 데이터를 &lt;code&gt;$output&lt;/code&gt; 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa7fbea2d0e607309e315ba46eefb556163b2c8" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="translated">용어 및 목록 연산자 (왼쪽)</target>
        </trans-unit>
        <trans-unit id="aadfdbce37d51dbb8148884093a756d6e68d99bd" translate="yes" xml:space="preserve">
          <source>Termux</source>
          <target state="translated">Termux</target>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="translated">C와 마찬가지로 삼항 &lt;code&gt;&quot;?:&quot;&lt;/code&gt; 는 조건부 연산자입니다. if-then-else와 매우 유사합니다. 앞의 인수가 &lt;code&gt;?&lt;/code&gt; true 인 경우 &lt;code&gt;:&lt;/code&gt; 앞에있는 인수 가 반환되고, 그렇지 않으면 &lt;code&gt;:&lt;/code&gt; 뒤에있는 인수 가 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="translated">테스트-테스트 스크립트 작성을위한 간단한 프레임 워크를 제공합니다</target>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="translated">테스트 상태 및 정보</target>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="translated">주어진 연산자, 라이브러리 또는 함수의 _all_ 동작을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="translated">모든 선택적 인수를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="translated">SV가 오염되었는지 테스트합니다. 대신 &lt;code&gt;SvTAINTED&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="translated">테스트 빌드 유틸리티 메소드</target>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="translated">테스트 제어</target>
        </trans-unit>
        <trans-unit id="5f7408dbafe0232db081d945ae171586f08aae05" translate="yes" xml:space="preserve">
          <source>Test files not found under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="translated">만기 시맨틱을위한 테스트</target>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="translated">파일 끝을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="translated">&amp;amp; Time :: HiRes :: d_hires_stat 값을 테스트하여 운영 체제가 1 초 미만의 파일 시간 소인을 지원하는지 여부를 찾으십시오. 0보다 큰 값은 예를 의미합니다. 불행히도 파일 시스템이 이러한 타임 스탬프를 지원하는지 여부를 알 수있는 쉬운 방법은 없습니다. 유닉스 파일 시스템은 종종 그러하다. NTFS는 그렇지 않습니다. FAT는 그렇지 않습니다 (FAT 타임 스탬프 입도는 &lt;b&gt;2&lt;/b&gt; 초입니다).</target>
        </trans-unit>
        <trans-unit id="feacda2f5709bb28aab0498393394934934708d7" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_utime to find out whether the operating system supports setting subsecond file timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d9cdf0f1500007619c451c5eaa7ecb15e59b66" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your &lt;code&gt;atof()&lt;/code&gt; doesn't grok them. Get-magic is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="translated">SV의 내용이 숫자 (또는 숫자)인지 테스트합니다. &lt;code&gt;Inf&lt;/code&gt; 와 &lt;code&gt;Infinity&lt;/code&gt; 는 숫자로 취급되므로 atof ()가 숫자가 아닌 경우에도 숫자가 아닌 경고를 발행하지 않습니다. Get-magic은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eff6484209621d4819416b73c20e645cef64569b" translate="yes" xml:space="preserve">
          <source>Test mode. Makes it possible to command perlbug from a pipe or file, for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="translated">시험 모드. 대상 주소의 기본값은 &lt;b&gt;perlbug-test@perl.org&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="translated">시험 명</target>
        </trans-unit>
        <trans-unit id="06b20000ce74a97fae877b75a137b770c99da787" translate="yes" xml:space="preserve">
          <source>Test numbers out of sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="translated">테스트 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="translated">테스트 결과는 호스트 시스템 및 Cygwin 구성에 따라 다릅니다. 일부 Cygwin 설정에서 테스트를 통과 할 수 있으면 항상 시도하고 설명 가능한 테스트 실패가 문서화됩니다. Perl은 모든 테스트를 통과 할 수 있지만 아래 나열된 이유 중 하나로 인해 일부 테스트가 실패 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="a10b429173c58a1c6dcb960c4e6c1c09b38479a1" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;TAP::Parser::Aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="translated">제공된 &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator에&lt;/a&gt; 테스트 결과가 추가됩니다 . 여러 세트의 테스트를 실행하기 위해 &lt;code&gt;aggregate_tests&lt;/code&gt; 테스트를 여러 번 호출 할 수 있습니다. 여러 &lt;code&gt;Test::Harness&lt;/code&gt; 인스턴스를 사용하여 결과를 단일 애그리 게이터로 전달하여 복잡한 테스트 스위트의 다른 부분을 다른 &lt;code&gt;TAP::Harness&lt;/code&gt; 설정을 사용하여 실행할 수 있습니다 . 예를 들어, 일부 테스트는 병렬로 실행해야하지만 다른 테스트는 병렬 실행에 적합하지 않은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="translated">다양한 컨텍스트 (부울, 스칼라, 목록, lvalue)에서 리턴 값을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="translated">테스트 스타일</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">테스트 스위트</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="translated">내장 된 테스트 수트</target>
        </trans-unit>
        <trans-unit id="166736fddcc4133d965dff627cc8b8b46442426f" translate="yes" xml:space="preserve">
          <source>Test that a &lt;code&gt;long double&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;. Takes no arguments - the test value is hard-wired into the function (as &quot;7&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fd920652142c713f4086b5b623b0b9e9398272" translate="yes" xml:space="preserve">
          <source>Test that a double-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8f9b4911bc55fcaaec09b2bda811ea7944f490" translate="yes" xml:space="preserve">
          <source>Test that a single-precision floating point number is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b615cea701e2b923c5f71779b58c9f119e965fa" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;IV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb28175623956ac2c7f684099558f1e73fc257b6" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;NV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb348ab3a2e878a4d2162fc950e38514289fa424" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;UV&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62afa7b2c53f556142fec29768d4906ba6d2d520" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;int&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3320bceb2035430c2e25314087b45b576a7104" translate="yes" xml:space="preserve">
          <source>Test that an &lt;code&gt;long&lt;/code&gt; is formatted correctly by &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8692c5f618e42142701d067170ebb338d0f048" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; (with length &lt;code&gt;len&lt;/code&gt;) doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to &lt;code&gt;ENOENT&lt;/code&gt;, optionally warn using the &lt;code&gt;syscalls&lt;/code&gt; category, and return FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="translated">주어진 &lt;code&gt;pv&lt;/code&gt; 에 내부 &lt;code&gt;NUL&lt;/code&gt; 문자가 포함되어 있지 않은지 테스트하십시오 . 그렇다면 &lt;code&gt;errno&lt;/code&gt; 를 ENOENT로 설정 하고 선택적으로 경고 한 후 FALSE를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="935dc1f2c1449831bdafed1f538dec539127ac6a" translate="yes" xml:space="preserve">
          <source>Test the manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="translated">Perl C API 테스트</target>
        </trans-unit>
        <trans-unit id="1cda04f681171086e794af0b5d23d5d5ea0b6cdd" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a2e1515505333499048cba86227c80971a3aef" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is greater than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7397a89d009fad58a08d3b40bff3d58047b11288" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a4b766ad17990b550cf6d6e46e8c56bae5a196" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if the first, &lt;code&gt;s1&lt;/code&gt;, is less than the second, &lt;code&gt;s2&lt;/code&gt;. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67520e6cf1cb4f8414cc48c33fe0e43d736ba00" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07ce0712b3cc2e909c79e8b8e4be508ac97e959" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d79dd5feda7353def275a91909ef78bf53ffc" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1fdf525381a678ac204c899e59ed1ee66b437b" translate="yes" xml:space="preserve">
          <source>Test two &lt;code&gt;NUL&lt;/code&gt;-terminated strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="translated">포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자 가 포함되어 있는지 확인하기 위해 두 개의 버퍼를 테스트 하십시오. &lt;code&gt;len&lt;/code&gt; 매개 변수는 비교할 바이트 수를 나타냅니다. 같으면 0을 리턴하고, 같지 않으면 0이 아닌 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="translated">포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자를 포함 할 수있는 두 개의 버퍼를 테스트하여 서로 다른지 확인하십시오. &lt;code&gt;len&lt;/code&gt; 매개 변수는 비교할 바이트 수를 나타냅니다. 같지 않으면 0을 리턴하고, 같으면 0을 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">두 문자열을 테스트하여 첫 번째 &lt;code&gt;s1&lt;/code&gt; 이 두 번째 &lt;code&gt;s2&lt;/code&gt; 보다 크거나 같은지 확인 하십시오 . true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">두 문자열을 테스트하여 첫 번째 &lt;code&gt;s1&lt;/code&gt; 이 두 번째 &lt;code&gt;s2&lt;/code&gt; 보다 큰지 확인 하십시오 . true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">두 문자열을 테스트하여 첫 번째 &lt;code&gt;s1&lt;/code&gt; 이 두 번째 &lt;code&gt;s2&lt;/code&gt; 보다 작거나 같은지 확인 하십시오 . true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="translated">두 문자열을 테스트하여 첫 번째 &lt;code&gt;s1&lt;/code&gt; 이 두 번째 &lt;code&gt;s2&lt;/code&gt; 보다 작은 지 확인 하십시오 . true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="translated">두 문자열이 서로 다른지 테스트하십시오. true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">두 문자열이 서로 다른지 테스트하십시오. &lt;code&gt;len&lt;/code&gt; 매개 변수는 비교 바이트 수를 나타냅니다. true 또는 false를 반환합니다. ( &lt;code&gt;strncmp&lt;/code&gt; 의 랩퍼 ).</target>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="translated">두 문자열이 동일한 지 테스트하십시오. true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="translated">두 문자열이 동일한 지 테스트하십시오. &lt;code&gt;len&lt;/code&gt; 매개 변수는 비교 바이트 수를 나타냅니다. true 또는 false를 반환합니다. ( &lt;code&gt;strncmp&lt;/code&gt; 의 랩퍼 ).</target>
        </trans-unit>
        <trans-unit id="5ea556cadafc54f605e5e63d55b8b6c8576ae334" translate="yes" xml:space="preserve">
          <source>Test your change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="2b84f621c0fd4ba8bd514c5c43ab9a897c8c014e" translate="yes" xml:space="preserve">
          <source>Test2</source>
          <target state="translated">Test2</target>
        </trans-unit>
        <trans-unit id="eda8c363c27f97460f067dbb6abdfc09dc29c0c8" translate="yes" xml:space="preserve">
          <source>Test2 - Framework for writing test tools that all work together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7914da6063f1d3eee08e8be56ecff6a038d13b7" translate="yes" xml:space="preserve">
          <source>Test2 based tools produce events which get passed through a processing system before being output by a formatter. This event system allows for rich plugin and extension support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398a86dff1e296880e5d0b4d74bd2ff1122d7b20" translate="yes" xml:space="preserve">
          <source>Test2 is a new testing framework produced by forking &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;, completely refactoring it, adding many new features and capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ec663be5e2702eeee07b6691bdb59dd7f152b6" translate="yes" xml:space="preserve">
          <source>Test2 support for forking and threading can be turned on using &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt;. Once turned on threading and forking operate sanely and work as one would expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c00e9e770edcdcec782d15abea07abe8e90329" translate="yes" xml:space="preserve">
          <source>Test2 uses an &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object to track filename, line number, and tool details. This object greatly simplifies tracking for where errors should be reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e285ff9d0222e729d45ac11b2fa114520dbd2f49" translate="yes" xml:space="preserve">
          <source>Test2::</source>
          <target state="translated">Test2::</target>
        </trans-unit>
        <trans-unit id="aed608f477d17069118048380cb834a46100702e" translate="yes" xml:space="preserve">
          <source>Test2::API</source>
          <target state="translated">Test2::API</target>
        </trans-unit>
        <trans-unit id="b64e44401f91aa4335033516e0e358ab2918bb91" translate="yes" xml:space="preserve">
          <source>Test2::API - Primary interface for writing Test2 based testing tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd3f4fa6597ae4905596818a71dd6f194f5a192" translate="yes" xml:space="preserve">
          <source>Test2::API::</source>
          <target state="translated">Test2::API::</target>
        </trans-unit>
        <trans-unit id="823aa9e1a97b79904e6a3b276b63d70ac1eaf933" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage</source>
          <target state="translated">Test2::API::Breakage</target>
        </trans-unit>
        <trans-unit id="0861d9570e8c51fbb90b7b320182f504e2357c33" translate="yes" xml:space="preserve">
          <source>Test2::API::Breakage - What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2ccf18a794e7b19dd498228e83500720827311" translate="yes" xml:space="preserve">
          <source>Test2::API::Context</source>
          <target state="translated">Test2::API::Context</target>
        </trans-unit>
        <trans-unit id="6392ed68dbc48f41c56e98e3b78066ea6fd6f6e7" translate="yes" xml:space="preserve">
          <source>Test2::API::Context - Object to represent a testing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8928930b42eb0f1f15f9f1786db57584d36450f7" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance</source>
          <target state="translated">Test2::API::Instance</target>
        </trans-unit>
        <trans-unit id="e9d71ad619dcb1f03cb3d047e079b7b873049690" translate="yes" xml:space="preserve">
          <source>Test2::API::Instance - Object used by Test2::API under the hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4ef69b915bbedef7a6aa2e3dfda1acb8e00023" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack</source>
          <target state="translated">Test2::API::Stack</target>
        </trans-unit>
        <trans-unit id="db39e7f918f59026c6ba1b1479540073a74dbe65" translate="yes" xml:space="preserve">
          <source>Test2::API::Stack - Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4066ca94daf4532238cf36f016b1d069a5ab7793" translate="yes" xml:space="preserve">
          <source>Test2::Bundle::</source>
          <target state="translated">Test2::Bundle::</target>
        </trans-unit>
        <trans-unit id="f57cc1ec8f9d37fc1b16d1973aeb44165f00421d" translate="yes" xml:space="preserve">
          <source>Test2::Event</source>
          <target state="translated">Test2::Event</target>
        </trans-unit>
        <trans-unit id="c7ab55a64912c0845c79bb212cfd817d09025066" translate="yes" xml:space="preserve">
          <source>Test2::Event - Base class for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a208964b54ed95543dd315c416ecedfe690fe40" translate="yes" xml:space="preserve">
          <source>Test2::Event::</source>
          <target state="translated">Test2::Event::</target>
        </trans-unit>
        <trans-unit id="222da9b43da2c10e075571dbaaecb7acb8971f5c" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail</source>
          <target state="translated">Test2::Event::Bail</target>
        </trans-unit>
        <trans-unit id="c6639f4ee1d50a38a83d0aa08dbfdceab90fd9da" translate="yes" xml:space="preserve">
          <source>Test2::Event::Bail - Bailout!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3e3ba5854331919870c8337d909e52e4a076b8" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag</source>
          <target state="translated">Test2::Event::Diag</target>
        </trans-unit>
        <trans-unit id="dccbb51341c8ea96ae5a977ee141eea8bc86dbe4" translate="yes" xml:space="preserve">
          <source>Test2::Event::Diag - Diag event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8ebae9408bcb7bc43915bb7a2b06de25a46dec" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding</source>
          <target state="translated">Test2::Event::Encoding</target>
        </trans-unit>
        <trans-unit id="38074f2997521b7c59670e4af13f02f3260f0037" translate="yes" xml:space="preserve">
          <source>Test2::Event::Encoding - Set the encoding for the output stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cdd65e18d257d6b093ce75ab07ea83b0a1f0f3" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception</source>
          <target state="translated">Test2::Event::Exception</target>
        </trans-unit>
        <trans-unit id="4701028ce3df2eea964013cdb647d8bf16f01e39" translate="yes" xml:space="preserve">
          <source>Test2::Event::Exception - Exception event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213b2187e0041e341c0be41fb190191567647040" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail</source>
          <target state="translated">Test2::Event::Fail</target>
        </trans-unit>
        <trans-unit id="aa94f0e56a9c0ead034b1b33c0cc1605dfbd21ef" translate="yes" xml:space="preserve">
          <source>Test2::Event::Fail - Event for a simple failed assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe59b86d85778b040125f222a3d01e10a712a40" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic</source>
          <target state="translated">Test2::Event::Generic</target>
        </trans-unit>
        <trans-unit id="dd44b53a7b2f21504f4c3cdcdd24bf5b428034bb" translate="yes" xml:space="preserve">
          <source>Test2::Event::Generic - Generic event type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5232466de0a182c8ac4368fe4af490d4cec125c5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note</source>
          <target state="translated">Test2::Event::Note</target>
        </trans-unit>
        <trans-unit id="2110f8724d8546b8c1bc6d82d78c7a0be5217629" translate="yes" xml:space="preserve">
          <source>Test2::Event::Note - Note event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413b4924db2b9633fc53631d16b5f8d56d2a8ec5" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok</source>
          <target state="translated">Test2::Event::Ok</target>
        </trans-unit>
        <trans-unit id="d26917c93a4a1ca59d02bfdcd1ca1e882315f897" translate="yes" xml:space="preserve">
          <source>Test2::Event::Ok - Ok event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8166088489a5bc91739c87f976810c6ecf6646a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass</source>
          <target state="translated">Test2::Event::Pass</target>
        </trans-unit>
        <trans-unit id="e2c3f6ccdfd606b354f26fb929f5aa4379851e17" translate="yes" xml:space="preserve">
          <source>Test2::Event::Pass - Event for a simple passing assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2baa0f71c7bde397357a6a05ab0a4b2170b6e32a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan</source>
          <target state="translated">Test2::Event::Plan</target>
        </trans-unit>
        <trans-unit id="333336f9de46850c8a8c5e170a7fcf9c57fb3486" translate="yes" xml:space="preserve">
          <source>Test2::Event::Plan - The event of a plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f279cfd9072e8f5890e09755a89a14ab46a9338" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip</source>
          <target state="translated">Test2::Event::Skip</target>
        </trans-unit>
        <trans-unit id="523d29ebe5be339549d30bbd996c98332c98058b" translate="yes" xml:space="preserve">
          <source>Test2::Event::Skip - Skip event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daedf830e1bee09f664aaa317a6afed11518990" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest</source>
          <target state="translated">Test2::Event::Subtest</target>
        </trans-unit>
        <trans-unit id="f8e158cbc6534e5249fe882a4e9a0da5cc30a140" translate="yes" xml:space="preserve">
          <source>Test2::Event::Subtest - Event for subtest types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb06c64fdc632db67dc9bffd6c588a6a624ce76a" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version</source>
          <target state="translated">Test2::Event::TAP::Version</target>
        </trans-unit>
        <trans-unit id="1c62f8d2de6366a8d87dd20fc3501e28352856dd" translate="yes" xml:space="preserve">
          <source>Test2::Event::TAP::Version - Event for TAP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbc479c6c5dbbd07debac51d2e47f71debe301b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2</source>
          <target state="translated">Test2::Event::V2</target>
        </trans-unit>
        <trans-unit id="5d24bd5feb73d8653a7b629d67988cafd589322b" translate="yes" xml:space="preserve">
          <source>Test2::Event::V2 - Second generation event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16dd367cf4872654a6dce5ce401595d087cd64a" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting</source>
          <target state="translated">Test2::Event::Waiting</target>
        </trans-unit>
        <trans-unit id="db005487809f2d8acd788bd2d2dc8b6a91556697" translate="yes" xml:space="preserve">
          <source>Test2::Event::Waiting - Tell all procs/threads it is time to be done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43b423903d35c0f3149a55b5aa7482144c6e821" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet</source>
          <target state="translated">Test2::EventFacet</target>
        </trans-unit>
        <trans-unit id="c11dcded6ce506a6e2d04a5f680ab6b7c80a91eb" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet - Base class for all event facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d94b66b18c3d8c49c0f173453f4e670dd80f895" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About</source>
          <target state="translated">Test2::EventFacet::About</target>
        </trans-unit>
        <trans-unit id="a7424501dd01bcb804f3da012e536a50271a2499" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::About - Facet with event details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7721bca6966ae188d61ed02c3583a52be94f3308" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty</source>
          <target state="translated">Test2::EventFacet::Amnesty</target>
        </trans-unit>
        <trans-unit id="75a05106886d311b44b3bdfccd8778e0c3f3f498" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Amnesty - Facet for assertion amnesty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0d1e162c4b6553c9b71ed64f5b8b1f9ed0917c" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert</source>
          <target state="translated">Test2::EventFacet::Assert</target>
        </trans-unit>
        <trans-unit id="7920cf94c19ae0f16a489d74a6da88912a69561f" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Assert - Facet representing an assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0154d814220406d368d99e18a174a4dddfb3bcd5" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control</source>
          <target state="translated">Test2::EventFacet::Control</target>
        </trans-unit>
        <trans-unit id="5bcc831f6a254f05cbb0f0fadb63ba1c90548e4a" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Control - Facet for hub actions and behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62ade42351eb9bb31e48e3b2e93713fe6baeef8" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error</source>
          <target state="translated">Test2::EventFacet::Error</target>
        </trans-unit>
        <trans-unit id="94ed284eb9c51ff089cc0a134463bf0d7a5d9b9b" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Error - Facet for errors that need to be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0f76e55accd6e82edf385f2c62f6f3fe2ff466" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub</source>
          <target state="translated">Test2::EventFacet::Hub</target>
        </trans-unit>
        <trans-unit id="ccf5d98be7eb2630ce4c2c621f114c26ae3ab3b1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Hub - Facet for the hubs an event passes through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ac4e48a99349567b0a89ac444d73d09d49cdd1" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info</source>
          <target state="translated">Test2::EventFacet::Info</target>
        </trans-unit>
        <trans-unit id="531a04a3d9a3002254fb82228c4742a0058169ae" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info - Facet for information a developer might care about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7657cf6e0d3cbe826429bd19cce6329342e8371e" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table</source>
          <target state="translated">Test2::EventFacet::Info::Table</target>
        </trans-unit>
        <trans-unit id="919c466811c6c1ce82b3d1a77373a5994bc4ad1d" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Info::Table - Intermediary representation of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e10762a18172dac09cb1485390bf5a8c468e654" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta</source>
          <target state="translated">Test2::EventFacet::Meta</target>
        </trans-unit>
        <trans-unit id="15764a4129b9ed520f0a3054a182ad077401eb37" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Meta - Facet for meta-data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ba28b1fef317b322342598dd7b5b1f2a0bfed2" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent</source>
          <target state="translated">Test2::EventFacet::Parent</target>
        </trans-unit>
        <trans-unit id="fc580dac3b702094a3a37054e781da56753a8202" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Parent - Facet for events contains other events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f017f4ef4b9f563bbf579d69dd0b07d01d083216" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan</source>
          <target state="translated">Test2::EventFacet::Plan</target>
        </trans-unit>
        <trans-unit id="1b853027bef935f244330f0dd4212616d550dd50" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Plan - Facet for setting the plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5beff3ccc1dfe7e21a8d1577127506388549038" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render</source>
          <target state="translated">Test2::EventFacet::Render</target>
        </trans-unit>
        <trans-unit id="8fdb0b599c005170ba486c3ab26ed301b039dad4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Render - Facet that dictates how to render an event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f454a15df1938741674595a2355fd8747d3246c4" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace</source>
          <target state="translated">Test2::EventFacet::Trace</target>
        </trans-unit>
        <trans-unit id="68b35a88e0341af14e6394c735722451fceca859" translate="yes" xml:space="preserve">
          <source>Test2::EventFacet::Trace - Debug information for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22810101357ee04450379aa51c30db96603d1bc0" translate="yes" xml:space="preserve">
          <source>Test2::Formatter</source>
          <target state="translated">Test2::Formatter</target>
        </trans-unit>
        <trans-unit id="24090f00c8f368b00c6a6e3049b282ad6483fd26" translate="yes" xml:space="preserve">
          <source>Test2::Formatter - Namespace for formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7ad9843e47802da1064f10a6ed0f941b4c6996" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::</source>
          <target state="translated">Test2::Formatter::</target>
        </trans-unit>
        <trans-unit id="d8aebf053e28ed7412794daf98128ef12f654d34" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP</source>
          <target state="translated">Test2::Formatter::TAP</target>
        </trans-unit>
        <trans-unit id="46b4d5b6e41ec7c63f10f2b81b8d25b6ad48c467" translate="yes" xml:space="preserve">
          <source>Test2::Formatter::TAP - Standard TAP formatter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec1636c628a393391f1bd9b891d1aac73f6842e" translate="yes" xml:space="preserve">
          <source>Test2::Hub</source>
          <target state="translated">Test2::Hub</target>
        </trans-unit>
        <trans-unit id="9ef2e13502d5f0974e131f5f83a726361d1b54dd" translate="yes" xml:space="preserve">
          <source>Test2::Hub - The conduit through which all events flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e83b628262986793f10b10b71b5803fa827b55" translate="yes" xml:space="preserve">
          <source>Test2::Hub::</source>
          <target state="translated">Test2::Hub::</target>
        </trans-unit>
        <trans-unit id="d987d21918e08ef541654a1bdfad5ccaedf59e4f" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor</source>
          <target state="translated">Test2::Hub::Interceptor</target>
        </trans-unit>
        <trans-unit id="259de78dc48b81a26c6c8f30e8cd739349d3c52a" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor - Hub used by interceptor to grab results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bfea7d0c04ab6a462bbac2592d6b16be7ef2d79" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator</source>
          <target state="translated">Test2::Hub::Interceptor::Terminator</target>
        </trans-unit>
        <trans-unit id="060da97eee8500d95c5711415f3dc7a4d015f4e9" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Interceptor::Terminator - Exception class used by Test2::Hub::Interceptor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3808bc674ba623811b11d43abef5d54200006dc8" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest</source>
          <target state="translated">Test2::Hub::Subtest</target>
        </trans-unit>
        <trans-unit id="daea2dc40ad5baee611aefac07d76a5653258a74" translate="yes" xml:space="preserve">
          <source>Test2::Hub::Subtest - Hub used by subtests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8f1da2d2d8e1dfdea6539c7c3b6cde2e255e80" translate="yes" xml:space="preserve">
          <source>Test2::IPC</source>
          <target state="translated">Test2::IPC</target>
        </trans-unit>
        <trans-unit id="259b7962c108b108b99848b7164604ace25b603c" translate="yes" xml:space="preserve">
          <source>Test2::IPC - Turn on IPC for threading or forking support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bae70236953a3ba88d368a2555897a3a683c900" translate="yes" xml:space="preserve">
          <source>Test2::IPC::</source>
          <target state="translated">Test2::IPC::</target>
        </trans-unit>
        <trans-unit id="2aa0e1ea9908aa1517ccfba9e9ebdec9f7fd42a9" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver</source>
          <target state="translated">Test2::IPC::Driver</target>
        </trans-unit>
        <trans-unit id="e89eb8d9a5b88689747eb6772d8891a3419ee002" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver - Base class for Test2 IPC drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa014e96987947baf8aa2b996530d5e78494607" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver has an &lt;code&gt;import()&lt;/code&gt; method. All drivers inherit this import method. This import method registers the driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6247baaa37b5aa0c0b858ebf17f525faa50a3a74" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::</source>
          <target state="translated">Test2::IPC::Driver::</target>
        </trans-unit>
        <trans-unit id="df1632079981d93c731c27fbf0953b8c0110780f" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files</source>
          <target state="translated">Test2::IPC::Driver::Files</target>
        </trans-unit>
        <trans-unit id="d766b8fd7d9bfdba9a657a1322fd6250e8131728" translate="yes" xml:space="preserve">
          <source>Test2::IPC::Driver::Files - Temp dir + Files concurrency model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b37bcccaea4a2ac8fe8762dc5b314baa0c51f3" translate="yes" xml:space="preserve">
          <source>Test2::Plugin::</source>
          <target state="translated">Test2::Plugin::</target>
        </trans-unit>
        <trans-unit id="d68f31cbce13d814ae88248b74be13195971bcb1" translate="yes" xml:space="preserve">
          <source>Test2::Require::</source>
          <target state="translated">Test2::Require::</target>
        </trans-unit>
        <trans-unit id="92e3f4464ca08722bdba5e6448503ce92bb9a7b7" translate="yes" xml:space="preserve">
          <source>Test2::Tools::</source>
          <target state="translated">Test2::Tools::</target>
        </trans-unit>
        <trans-unit id="9f1a4ef48602a8e2128f3a0e8099a06fc4b66142" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny</source>
          <target state="translated">Test2::Tools::Tiny</target>
        </trans-unit>
        <trans-unit id="79dcd377299ffd1fe20b0bcd73f822a0e9ace962" translate="yes" xml:space="preserve">
          <source>Test2::Tools::Tiny - Tiny set of tools for unfortunate souls who cannot use &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e2aa276cb0ac9a0d3011cd620cb67dae65f37b" translate="yes" xml:space="preserve">
          <source>Test2::Transition</source>
          <target state="translated">Test2::Transition</target>
        </trans-unit>
        <trans-unit id="c87fd265441b37b65c97051a7a8d33c3d3df3323" translate="yes" xml:space="preserve">
          <source>Test2::Transition - Transition notes when upgrading to Test2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e290a0acf731a8e4ae28c48d463af20b82b5a396" translate="yes" xml:space="preserve">
          <source>Test2::Util</source>
          <target state="translated">Test2::Util</target>
        </trans-unit>
        <trans-unit id="9916e2fd617bea077d82a5dd41a45672a41cb8fe" translate="yes" xml:space="preserve">
          <source>Test2::Util - Tools used by Test2 and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6eb9596151fedd72d3d41a6e72618282af596f" translate="yes" xml:space="preserve">
          <source>Test2::Util::</source>
          <target state="translated">Test2::Util::</target>
        </trans-unit>
        <trans-unit id="d73a9b09244115670914ff2509686dc192be586b" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta</source>
          <target state="translated">Test2::Util::ExternalMeta</target>
        </trans-unit>
        <trans-unit id="4ce376298fd6e6528e5f02c77d1d3b4e0a46cece" translate="yes" xml:space="preserve">
          <source>Test2::Util::ExternalMeta - Allow third party tools to safely attach meta-data to your instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7604014ee8769c4f1c915fbdad0d5f25e9283637" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy</source>
          <target state="translated">Test2::Util::Facets2Legacy</target>
        </trans-unit>
        <trans-unit id="8247e29b1a8250a4ea6c8a5f5a060d7f0399d878" translate="yes" xml:space="preserve">
          <source>Test2::Util::Facets2Legacy - Convert facet data to the legacy event API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0178a14e7a539df0e8eac67b9f265a91905f03e7" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase</source>
          <target state="translated">Test2::Util::HashBase</target>
        </trans-unit>
        <trans-unit id="e3d53ed10a22c3962563aa98b744234fa941f302" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase - Build hash based classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304c4e0ff5d5cb770757f774f08ee2ed78611096" translate="yes" xml:space="preserve">
          <source>Test2::Util::HashBase provides a function for retrieving a list of attributes for an Test2::Util::HashBase class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7257ba0ff26dcc04c2983cb8974045fd2c82f" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace</source>
          <target state="translated">Test2::Util::Trace</target>
        </trans-unit>
        <trans-unit id="30e52b1d2e0031f38bdbbe2f1f65a20ef1bbc1b0" translate="yes" xml:space="preserve">
          <source>Test2::Util::Trace - Legacy wrapper fro &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2534f8dc09bc938850916623cc51a245fb3b04e8" translate="yes" xml:space="preserve">
          <source>Test::Able</source>
          <target state="translated">Test::Able</target>
        </trans-unit>
        <trans-unit id="1136a495270cb45dd3267352c039b37399d8bfdd" translate="yes" xml:space="preserve">
          <source>Test::Aggregate</source>
          <target state="translated">Test::Aggregate</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="translated">Test :: Builder-테스트 라이브러리 구축을위한 백엔드</target>
        </trans-unit>
        <trans-unit id="5111b242105d59084cb31e09df1b0f811c5f66e6" translate="yes" xml:space="preserve">
          <source>Test::Builder assumed everything would end up as TAP. Test2 makes no such assumption. Test2 provides ways for you to specify alternative and custom formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="translated">Test :: Builder는 threads.pm이로드 된 경우에만 스레드를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="882498aa0deee0eaf2786e1c013e62fc64bca99d" translate="yes" xml:space="preserve">
          <source>Test::Builder only provided a handful of methods for generating lines of TAP. Test2 took inventory of everything people were doing with Test::Builder that required hacking it up. Test2 made public API functions for nearly all the desired functionality people didn't previously have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f281cea5cb958fbaba27c76fd1089904c4d2e8" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Event::Diag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e1fd996c21804da41e7fd365d9b5baae50ea4e" translate="yes" xml:space="preserve">
          <source>Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="79c6ceab8e308a67e42d8cf4c5b83ab3491afc98" translate="yes" xml:space="preserve">
          <source>Test::Builder1.5/2 conditionals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b68144843ad4490acc1cceea81edee533ae15a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Clutch</source>
          <target state="translated">Test::Builder::Clutch</target>
        </trans-unit>
        <trans-unit id="c2aadab602bd18d0f63c1096df14d2661c5c645e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter</source>
          <target state="translated">Test::Builder::Formatter</target>
        </trans-unit>
        <trans-unit id="b65d47cb23a2aae086b24a276b41605a5607bc8a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Formatter - Test::Builder subclass of Test2::Formatter::TAP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a921037b78151ec674b9e8b2042772f638e1ae3" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar</source>
          <target state="translated">Test::Builder::IO::Scalar</target>
        </trans-unit>
        <trans-unit id="8598b4873ed01a8a8a65021f790976f5909cde97" translate="yes" xml:space="preserve">
          <source>Test::Builder::IO::Scalar - A copy of IO::Scalar for Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="translated">Test :: Builder :: Module-테스트 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="translated">Test :: Builder :: Module은 &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; 의 서브 클래스이므로 모듈이 Exporter의 서브 클래스이기도합니다. @EXPORT, @EXPORT_OK 등은 모두 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="beddeafc2200fcc739f218f443081251d72a00e9" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">Test :: Builder :: Module은 &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; 와 동일한 기본 방식으로 작동 하여 계획을 설정하고 함수 및 변수 내보내기를 제어 하는 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 메소드를 제공 합니다. 이를 통해 모듈은 &lt;a href=&quot;../more&quot;&gt;Test :: More와&lt;/a&gt; 독립적으로 계획을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f6c2ece6f56adee6a05f3b497d85cec7b976b9a" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;import()&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="translated">Test :: Builder :: Module은 기본 Test :: Builder 객체를 얻는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="translated">Test :: Builder :: Tester-Test :: Builder로 빌드 된 테스트 슈트</target>
        </trans-unit>
        <trans-unit id="a5daa4b264c9be76b3e43bc5b6e1208a2a0f3088" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester does not handle plans well. It has never done anything special with plans. This means that plans from outside Test::Builder::Tester will effect Test::Builder::Tester, worse plans when using Test::Builder::Tester will effect overall testing. At this point there are no plans to fix this bug as people have come to depend on it, and Test::Builder::Tester is now discouraged in favor of &lt;code&gt;Test2::API::intercept()&lt;/code&gt;. See &lt;a href=&quot;https://github.com/Test-More/test-more/issues/667&quot;&gt;https://github.com/Test-More/test-more/issues/667&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test :: Builder :: Tester :: Color-Test :: Builder :: Tester에서 색상을 켭니다.</target>
        </trans-unit>
        <trans-unit id="53667487e4c182cc6c194b110fdd4bf8602e9ca2" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag</source>
          <target state="translated">Test::Builder::TodoDiag</target>
        </trans-unit>
        <trans-unit id="3002af054c03a9c23ba9d877d3c154ef71a2f214" translate="yes" xml:space="preserve">
          <source>Test::Builder::TodoDiag - Test::Builder subclass of Test2::Event::Diag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c62394a96db894e9826fa86cbfb9739d5ef32c0" translate="yes" xml:space="preserve">
          <source>Test::DBIx::Class::Schema</source>
          <target state="translated">Test::DBIx::Class::Schema</target>
        </trans-unit>
        <trans-unit id="5b5ccd27092122c879d215a96c52ebaf02aa4964" translate="yes" xml:space="preserve">
          <source>Test::Dist::VersionSync</source>
          <target state="translated">Test::Dist::VersionSync</target>
        </trans-unit>
        <trans-unit id="8c38eb7023c514bb86f58038021705c167c2100e" translate="yes" xml:space="preserve">
          <source>Test::Exception</source>
          <target state="translated">Test::Exception</target>
        </trans-unit>
        <trans-unit id="fa3770b25c372094da5ee1db5052ae09e83ef8c9" translate="yes" xml:space="preserve">
          <source>Test::FITesque</source>
          <target state="translated">Test::FITesque</target>
        </trans-unit>
        <trans-unit id="a7d826918b9640ee5aefda9817fc5812e0f756da" translate="yes" xml:space="preserve">
          <source>Test::Flatten</source>
          <target state="translated">Test::Flatten</target>
        </trans-unit>
        <trans-unit id="3a3efe85ae6b44923e15a1815a66c74e76451413" translate="yes" xml:space="preserve">
          <source>Test::Group</source>
          <target state="translated">Test::Group</target>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="translated">Test :: Harness-통계로 Perl 표준 테스트 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="468e0078216124f369b31903b11b8bc081cc36e2" translate="yes" xml:space="preserve">
          <source>Test::Harness is responsible for running test scripts, analysing their output and reporting success or failure. When I type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a7d2d4bb460e39ef11a61cdb53eb1618e9aac3" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond</source>
          <target state="translated">Test::Harness::Beyond</target>
        </trans-unit>
        <trans-unit id="710da8f3b5001dc747ab1add20a7485f6580ee6f" translate="yes" xml:space="preserve">
          <source>Test::Harness::Beyond - Beyond make test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a575600ccb79ef75baad46fa5507b8a5c4e30ec7" translate="yes" xml:space="preserve">
          <source>Test::Kit</source>
          <target state="translated">Test::Kit</target>
        </trans-unit>
        <trans-unit id="e0d9d27235388a3f369fc7bba1f8eedaa8e97fe0" translate="yes" xml:space="preserve">
          <source>Test::Modern</source>
          <target state="translated">Test::Modern</target>
        </trans-unit>
        <trans-unit id="192bb93f9defdd2612446bcb1a3d05713afa6106" translate="yes" xml:space="preserve">
          <source>Test::Module::Used</source>
          <target state="translated">Test::Module::Used</target>
        </trans-unit>
        <trans-unit id="ba56db031e8622af899875ba4ed0dd10651ade7c" translate="yes" xml:space="preserve">
          <source>Test::Moose::More</source>
          <target state="translated">Test::Moose::More</target>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="translated">Test :: More-테스트 스크립트 작성을위한 또 다른 프레임 워크</target>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="translated">Test :: More가로드되었습니다. 괜찮습니다 :</target>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="translated">경우 테스트 :: 자세히는 스레드 알고있을 것입니다 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 완료되었습니다</target>
        </trans-unit>
        <trans-unit id="196636e03a49e3d95a68eb5d1e772f5b446bf075" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;use threads&lt;/code&gt; has been done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="translated">테스트 : : 5.8.1보다 오래된 Perls와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8218b4a58d60c04b93980b51121cc27fdf92c29b" translate="yes" xml:space="preserve">
          <source>Test::More::Prefix</source>
          <target state="translated">Test::More::Prefix</target>
        </trans-unit>
        <trans-unit id="ec61f56547ff7cd28c4fd12d8d489f875c46dac9" translate="yes" xml:space="preserve">
          <source>Test::ParallelSubtest</source>
          <target state="translated">Test::ParallelSubtest</target>
        </trans-unit>
        <trans-unit id="b9283666c0f7ee8bee524021520b4a58fc6faf53" translate="yes" xml:space="preserve">
          <source>Test::Pretty</source>
          <target state="translated">Test::Pretty</target>
        </trans-unit>
        <trans-unit id="6b788f39836a6b433e5df6d0783c10c859e93117" translate="yes" xml:space="preserve">
          <source>Test::SharedFork</source>
          <target state="translated">Test::SharedFork</target>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="translated">Test :: Simple-테스트 작성을위한 기본 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="translated">Test :: Simple은 &lt;b&gt;명시 적&lt;/b&gt; 으로 perl 5.6.0까지 완전히 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="translated">Test :: Simple은 perl 5.8.1 이상에서 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="translated">Test :: Simple은 종료 코드에서 최대 254 개의 오류 만보고합니다. 이것이 문제라면 아마도 거대한 테스트 스크립트가있을 것입니다. 여러 파일로 분할하십시오. (그렇지 않으면 부호없는 짧은 정수를 종료 상태로 사용하는 것이 유닉스 사람들을 비난합니다).</target>
        </trans-unit>
        <trans-unit id="8aa960dec0e59265b42ae7c53ff6c2bb33cb537d" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="translated">Test :: 간단히 &quot;1..M&quot;형식으로 실행 된 테스트 수를 인쇄하여 시작합니다. 따라서 &quot;1..5&quot;는 5 개의 테스트를 실행한다는 의미입니다. 이 이상한 형식을 통해 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 무언가 잘못 될 경우를 대비하여 몇 개의 테스트를 계획하고 있는지 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dad41aad99148e817cb791ab1874c49f4dd7b526" translate="yes" xml:space="preserve">
          <source>Test::Tester</source>
          <target state="translated">Test::Tester</target>
        </trans-unit>
        <trans-unit id="8acb8c70dcb4cd96a3e80ad8c60dfdc954c732ae" translate="yes" xml:space="preserve">
          <source>Test::Tester - Ease testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c807179d1ac6c0d1012cd2c0455c92e0bc574a1" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture</source>
          <target state="translated">Test::Tester::Capture</target>
        </trans-unit>
        <trans-unit id="34d5b01db7ffd8049c2fce4af0432b62a248b560" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture - Help testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a458c6dc8e9ff30e8f733b126620031229080ac" translate="yes" xml:space="preserve">
          <source>Test::Tester::Capture is a cut down and hacked up version of Test::Builder. Test::Builder was written by chromatic &amp;lt;chromatic@wgz.org&amp;gt; and Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e02cff79037d04f0d5bb99326725d2ece3d0d2" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner</source>
          <target state="translated">Test::Tester::CaptureRunner</target>
        </trans-unit>
        <trans-unit id="91c101deb36c07d85cffc331897f08c9b07bf3e8" translate="yes" xml:space="preserve">
          <source>Test::Tester::CaptureRunner - Help testing test modules built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26dc9e7487fca0c9f4cffd8168312e798d0afc9" translate="yes" xml:space="preserve">
          <source>Test::Tutorial</source>
          <target state="translated">Test::Tutorial</target>
        </trans-unit>
        <trans-unit id="02f397dd5054f86d8966d3c1290f138f6ebe0f4c" translate="yes" xml:space="preserve">
          <source>Test::Tutorial - A tutorial about writing really basic tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a895a2ec6601bf0432d22dd921492b16b90ab206" translate="yes" xml:space="preserve">
          <source>Test::UseAllModules</source>
          <target state="translated">Test::UseAllModules</target>
        </trans-unit>
        <trans-unit id="bf429510e44f5fd6da7cc7782aa21fed2fafa3e5" translate="yes" xml:space="preserve">
          <source>Test::Wrapper</source>
          <target state="translated">Test::Wrapper</target>
        </trans-unit>
        <trans-unit id="2041e8b48dd73d1c03506e63605772b484021ff1" translate="yes" xml:space="preserve">
          <source>Test::use::ok</source>
          <target state="translated">Test::use::ok</target>
        </trans-unit>
        <trans-unit id="85de35d70454052811bfbba08699cf789b433ab6" translate="yes" xml:space="preserve">
          <source>Test::use::ok - Alternative to Test::More::use_ok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl로 이상 테스트</target>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl 테스트</target>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="translated">BS2000에서 펄 테스트</target>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="translated">DOS에서 Perl 테스트</target>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="translated">Tru64에서 Perl 테스트</target>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="translated">Windows에서 Perl 테스트</target>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="translated">깨진 로캘 ​​테스트</target>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="translated">부동 소수점 평등 또는 불평등을 정확하게 테스트하는 것은 좋은 생각이 아닙니다. 다음은 두 개의 부동 소수점 숫자가 특정 소수 자릿수와 같은지 비교하는 (상대적으로 비싼) 해결 방법입니다. 이 주제에 대한보다 강력한 처리는 Knuth, volume II를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="translated">기능을 테스트해야하는 경우 운영 체제 또는 버전 테스트</target>
        </trans-unit>
        <trans-unit id="2d25b81a3e33ddcbb9c9dc8657d0fadaaa4f4848" translate="yes" xml:space="preserve">
          <source>Testing lots of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="translated">테스트 결과 : &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fb7daa9466444fb2d40197eaff882519cbfe5af" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="translated">패치 테스트</target>
        </trans-unit>
        <trans-unit id="3d3998625037d01c3f0c18b46c8e2f6a0db08edf" translate="yes" xml:space="preserve">
          <source>Testing tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73860e29950984e7ebc73550412c5d939d1b2f02" translate="yes" xml:space="preserve">
          <source>Testing with taint mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="translated">테스트는 배포의 최상위 수준에서 실행됩니다. 따라서 테스트에서 ./lib를 참조하여 lib 디렉토리를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f8610f229cb8bffff5963f6ac85b8ed60c32307d" translate="yes" xml:space="preserve">
          <source>Tests break due to subtest indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="translated">기본 제어 구조, &lt;code&gt;if/else&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , 서브 루틴 등을 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="43a6cf885d16a46b82e0be5400cae40cc21567ca" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, subroutines, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="translated">Perl이 어떻게 구문 분석하고 컴파일하는지에 대한 기본 문제를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="translated">명령 행 인수를 포함하여 내장 IO 함수를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="translated">의 핵심 모듈에 대한 테스트</target>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="translated">종료 코드 및 PERL * 환경 변수 처리를 포함하여 perl이 실제로 실행되는 기능을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="translated">모듈 테스트</target>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="translated">다른 디렉토리에 맞지 않는 펄의 내장 함수를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="translated">펄의 내장 함수를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="translated">Perl의 메소드 해결 순서 구현을 테스트합니다 ( &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="translated">정규식 관련 기능 또는 동작을 테스트합니다. (이것들은 t / op에 살았었다).</target>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="translated">Perl의 절대 기본 기능을 테스트합니다. 여기에는 &lt;code&gt;if&lt;/code&gt; , 기본 파일 읽기 및 쓰기, 간단한 정규식 등이 포함됩니다. 이들은 테스트 스위트에서 먼저 실행되며 실패하면</target>
        </trans-unit>
        <trans-unit id="8ad550acb94fcd95cceafdb6277d5fdd95b24d49" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt;, basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="translated">유니 코드의 핵심 지원을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="translated">모듈 테스트가 여기에 있습니다. 각 테스트 파일 이름은 .t로 끝납니다. 그래서</target>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="translated">디렉토리가 존재하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="translated">파일이 존재하고 비어 있지 않은지 테스트합니다 (크기&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="translated">파일이 존재하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="translated">임의의 바이트 수가 유효한 UTF-8 문자로 시작하는지 테스트합니다. INVARIANT (예 : 비 EBCDIC 시스템의 ASCII) 문자는 유효한 UTF-8 문자입니다. UTF-8 문자의 실제 바이트 수는 유효하면 리턴되며 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="translated">SV가 RV인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="translated">소스 파일이 존재하고 비어 있지 않은지 테스트합니다 (크기&amp;gt; 0). 비어 있지 않으면 지정된 권한으로 지정된 대상에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="translated">두 개의 스레드 객체가 동일한 스레드인지 여부를 테스트합니다. 이것은보다 자연스러운 형태로 오버로드됩니다.</target>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="translated">실패한 테스트는 선택되지 않습니다. 가장 최근에 실패한 첫 번째 사용으로 모든 테스트를 실행하려면</target>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="translated">특정 신호가 포함되어 있는지 SigSet 객체를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="translated">다양한 일반적인 오류에 대해 소스 트리의 상태를 테스트합니다. 예를 들어, git log에 나열된 모든 사람이</target>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="translated">테스트는 찾은 순서대로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="98125dc77105eee722883e53962bb713d1532fbc" translate="yes" xml:space="preserve">
          <source>Texas</source>
          <target state="translated">Texas</target>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="translated">텍사스 인스트루먼트</target>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="translated">텍스트 필드</target>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="translated">__DATA__ 뒤의 텍스트는 파일 핸들 &lt;code&gt;PACKNAME::DATA&lt;/code&gt; 를 통해 읽을 수 있습니다 . 여기서 &lt;code&gt;PACKNAME&lt;/code&gt; 은 __DATA__ 토큰이 발견되었을 때의 패키지입니다. 파일 핸들은 __DATA__ 다음 줄을 가리키면서 열린 채로 있습니다. 프로그램은 읽기가 끝나면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; 를 &lt;a href=&quot;functions/close&quot;&gt;닫아야&lt;/a&gt; 합니다. (어떤 이유로 든 모듈을 다시로드하면 열려있는 상태로 파일 핸들이 누출되므로 닫는 것이 더 안전합니다.) __DATA__가 도입되기 전에 작성된 이전 스크립트와의 호환성을 위해 __END__는 최상위 스크립트에서 __DATA__처럼 작동하지만 파일에는 없습니다. &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ) 로 로드되고 &lt;code&gt;main::DATA&lt;/code&gt; 를 통해 파일의 나머지 내용에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3842cca55ef2d8dd670adcc834aa3853a804149a" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt;, where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;close DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; 문자에서 줄 끝까지의 텍스트 는 주석이며 무시됩니다. 문자열 또는 정규식 내부의 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 은 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="translated">숫자 코드 포인트로 정렬 된 텍스트는 합리적인 알파벳 순서를 따르지 않습니다. 텍스트 정렬에 UCA를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="translated">텍스트 문자열 (문자열)</target>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="translated">텍스트 모드 파일 핸들</target>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParser의 텍스트 토큰</target>
        </trans-unit>
        <trans-unit id="538841f5b8d0f8755431ba6c721b56da44fdedea" translate="yes" xml:space="preserve">
          <source>Text/Binary</source>
          <target state="translated">Text/Binary</target>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="translated">텍스트 :: Abbrev-abbrev-목록에서 약어 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="translated">Text :: Balanced-문자열에서 구분 된 텍스트 시퀀스를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="translated">Text :: ParseWords-텍스트를 토큰 배열 또는 배열 배열로 구문 분석</target>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">Text :: Tabs-unix expand (1) 및 unexpand (1)와 같은 탭 확장 및 확장 해제</target>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="translated">Text :: Tabs는 unix 유틸리티 expand (1) 및 unexpand (1)의 대부분을 수행합니다. 탭이있는 줄이 있으면 &lt;code&gt;expand&lt;/code&gt; 은 해당 탭을 적절한 수의 공백으로 바꿉니다. 탭이 있거나없는 행이 있으면 &lt;code&gt;unexpand&lt;/code&gt; 는 &lt;code&gt;unexpand -a&lt;/code&gt; 명령 과 같이 바이트를 절약 할 수있을 때 탭을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="translated">Text :: Tabs는 탭 ( &lt;code&gt;&quot;\t&quot;&lt;/code&gt; )과 결합 문자 ( &lt;code&gt;/\pM/&lt;/code&gt; ) 만 처리합니다. 백 스페이스 ( &lt;code&gt;&quot;\t&quot;&lt;/code&gt; )에 대해서는 거꾸로 계산하지 않거나 다른 비 인쇄 제어 문자 ( &lt;code&gt;/\pC/&lt;/code&gt; )를 생략 하거나 다른 영, 반 및 전각 문자를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b575607717c2ca75293a1a2f973ea2178607244e" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt;). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt;), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt;), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="translated">Text :: Wrap-간단한 단락을 만들기위한 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="f934f68f6305075635ab21032f0c6eb35d0fa39c" translate="yes" xml:space="preserve">
          <source>Thai encoding TCVN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b50e31a7e1337db9ecb0e2fcb6e65ca27f57df5" translate="yes" xml:space="preserve">
          <source>Thank you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="translated">(시간순으로) 감사합니다.</target>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="translated">Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin 및 Alan Burlison에게이 기사를 실제로 확인하고 연마하는 데 도움을 주셔서 감사합니다. Tom Christiansen이 소수 생성기를 다시 작성해 주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="624dc0ad0c4a285c56d022996d1083a11fac8944" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://he.net/&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://man.he.net/&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d197026943bb6167685c48d3d3074cfb2a40bd" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="translated">맨 페이지 링크에 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux 맨 페이지 온라인&lt;/a&gt; 사이트 를 사용할 수있는 권한을 부여한 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; 에 감사드립니다 .</target>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="translated">Perl 모듈 링크에 대한 사이트 사용 권한에 대해 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; 에 감사드립니다 .</target>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 와 &lt;code&gt;loc_lang&lt;/code&gt; 을 제안 해준 Chia-Liang Kao에게 감사합니다 .</target>
        </trans-unit>
        <trans-unit id="b1eb6da0d25f176736a52f5327efe1222256fcc7" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="translated">TTY의 Gerard Goossen에게 감사드립니다. 그의 프레젠테이션 &quot;UTF-8 in the wild&quot;(Dutch Perl Workshop 2006)은 저의 생각을 출판하고이 튜토리얼을 작성하도록 영감을주었습니다.</target>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="translated">perl과 다양한 방화벽 구성 간의 상호 작용에 대한 다음 단락에 기여한 Graham Barr에게 감사드립니다. 방화벽에 대한 자세한 내용은 함께 제공되는 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ae64bcb3e2de31c99abdd50b43bda8476faf81d" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="translated">&lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; 을 훌륭하게 작동시키는 데 도움을 준 James Mastros와 Martijn van der Streek에게 감사합니다 .</target>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="translated">Squirrel Consultancy의 Johan Vromans에게 감사드립니다. Amsterdam Perl Mongers 회의에서 그의 UTF-8이 울려 퍼지면서 쉽게 깨지지 않는 방식으로 Perl에서 문자 인코딩을 사용하는 방법을 찾기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="translated">명시적인 수입 작업을 해준 Jonas B. Nielsen에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="translated">이 모듈 작성을 제안한 Jos I. Boumans에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; 코드에 대한 Petya Kohts에게 감사합니다 .</target>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="translated">테스트 모듈을 사용해이 모듈을 시험해볼 수있게 해준 Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt;에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="translated">성능 향상에 대한 Richard Soderberg에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="translated">Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer 및 특히 Andrew Savige의 도움과 제안에 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="translated">이 모듈을 작성하고 코드 개선 및 보안 강화를위한 아이디어를 제공해야한다는 Tom Christiansen에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="translated">오버로드 덕분에 복잡한 숫자로 산술을 처리하는 것은 간단하고 거의 투명합니다.</target>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="translated">perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org 및 unicore@unicode.org 메일 링리스트를 읽어 주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="translated">여러 Perl IRC 채널에서 이런 종류의 것들에 대해 질문 한 사람들에게 감사하고 더 간단한 설명이 필요하다는 것을 끊임없이 상기시켜주었습니다.</target>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="translated">공개하기 전에이 문서를 검토 한 사람들에게 감사합니다. 벤자민 스미스, 얀-피터 코넷, 요한 브로 만 스, 루카스 마이, 나단 그레이.</target>
        </trans-unit>
        <trans-unit id="e2ecff3d05e183be8e4afb3075781b60cf077a08" translate="yes" xml:space="preserve">
          <source>Thanks to these efforts most encodings that come with Encode support PerlIO but that still leaves following encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="translated">구조체에 특정 필드가 존재한다는 것을</target>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="translated">필드의 서명, 크기 또는 유형이</target>
        </trans-unit>
        <trans-unit id="ba8c7890c4018f7372ea3dd0b44efd4aac702fe3" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="translated">말하자면, 이것에 접근하는 몇 가지 방법이 있습니다. Perl 5.10 이상에서 스마트 일치 연산자를 사용하여 항목이 배열 또는 해시에 포함되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="translated">즉, 우리는 Perl의 안정성과 보안을 중요하게 생각하며 Perl 릴리스를 지원하고 유지하기 위해 광범위한 Perl 커뮤니티와 오랫동안 계약을 맺지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="translated">이 블록은 다른 블록과 마찬가지로 적절한 블록이므로 더 복잡한 코드를 넣을 수 있습니다. 메시지를 다음 두 곳 중 하나로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="translated">이 빌드는 gcc-2.9-hppa-991112로 컴파일 된 대용량 파일을 지원하는 휴대용 hppa-1.1 멀티 스레드 빌드였습니다.</target>
        </trans-unit>
        <trans-unit id="a5173e93037f4e02bac658ae6058928a497347a4" translate="yes" xml:space="preserve">
          <source>That can be achieved by overriding &lt;code&gt;init&lt;/code&gt; in your class and working on the main lexicon with code like that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="translated">이는 버클리 DB 자체와 관련된 상황을 명확하게합니다. 무엇에 대한 &lt;b&gt;DB_File&lt;/b&gt; ? 위 인용문에 정의 된 동작은 매우 유용하므로 &lt;b&gt;DB_File이이를&lt;/b&gt; 준수합니다.</target>
        </trans-unit>
        <trans-unit id="e4e253e3979e75b31e42c03e2604d27318e57461" translate="yes" xml:space="preserve">
          <source>That does the same thing as the previous code. &lt;code&gt;ok()&lt;/code&gt; is the backbone of Perl testing, and we'll be using it instead of roll-your-own from here on. If &lt;code&gt;ok()&lt;/code&gt; gets a true value, the test passes. False, it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="translated">이 예제는 &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; 와 같은 것을 인쇄 합니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; 가 전체 왼쪽 피연산자 라는 사실을 무시하고 암시 적 으로 왼쪽에서 즉시 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 인용 하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="159d20ef613406bd732f05ac0e1faa07f34a47ec" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt;, because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;shift&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;time.shift&lt;/code&gt; is the entire left operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="translated">이 예에서는 &quot;개를 좋아합니다. 고양이를 좋아합니다&quot;라고 인쇄합니다. 원래 &lt;code&gt;$x&lt;/code&gt; 변수는 영향을받지 않았습니다. 대체의 전체 결과는 대신 &lt;code&gt;$y&lt;/code&gt; 저장됩니다 . 대체가 아무런 영향을 미치지 않으면 원래 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7278130041b031a5215a18d766074e98a320d921" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt;. If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="translated">이 명시 적 연관은 내장 된 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능 에 의해 만들어지며 일반적으로</target>
        </trans-unit>
        <trans-unit id="27b1cd2c668785cd9bb2dd2e3093b4e98220cdc9" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;bless&lt;/code&gt; function, which is typically used within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="translated">그 여분의 공간은 배열의 보간에서 비롯됩니다. 배열 요소 사이에 아무 것도 넣지 않으려면 큰 따옴표로 배열을 사용하지 마십시오. 인쇄하지 않고 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="translated">이 함수는 다음 명령문 중 하나를 사용하여 호출 할 수 있습니다. 다른 인수 목록을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="translated">그러면 각 단락마다 구문 분석 트리가 제공되므로 순서가 지정된 단락 목록 만 있으면됩니다. 객체 / 해시에서 자신을 데이터 요소로 유지할 수 있습니다. 가장 간단한 방법은 &lt;b&gt;parse_text를&lt;/b&gt; 호출 할 때마다 원하는 사용자 정의 &quot;옵션&quot;세트와 함께 array-ref를 사용하는 &lt;b&gt;것&lt;/b&gt; 입니다. 원하는 옵션 세트가 해시 &lt;code&gt;%options&lt;/code&gt; 의해 주어진다고 가정 해 봅시다 . 그런 다음 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="translated">켄 톰슨이 UTF-8을 발명했을 때 UTF-8이 처음 고안된 방식이기 때문에 역사적으로 Perl의 UTF-8 개념이었습니다. 그러나 적용 가능한 표준에 대한 이후 개정으로 인해 공식 UTF-8은 이제 그보다 엄격합니다. 예를 들어, 범위가 훨씬 좁아지고 (32 비트 또는 64 비트 대신 21 비트 만 포함하기 위해 0 .. 0x10_FFFF) 일부 문자 시퀀스 코드는 0이 아닌 31 비트 문자 코드 포인트 0xFDD0 .. 0xFDEF와 같이 일부 시퀀스는 허용되지 않습니다. 의 마지막 두 코드 포인트</target>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="translated">그것은 같은 효과가 있습니다</target>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="translated">그것은 C99 또는 C ++입니다. Perl은 C89입니다. //-comments를 사용하면 많은 C 컴파일러에서 자동으로 허용되지만 ANSI C89 엄격 성을 크랭크하면 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="translated">그것은 C99 또는 C ++입니다. 일부 C 컴파일러는 이것을 허용하지만 그렇게해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="translated">그것은 C99 또는 C ++입니다. 루프 변수의 범위를 제한하기 위해 C89에서도 그렇게하는 것이 정말 좋지만, 우리는 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7473aa8c2d92485250630b49f5d5752d8eea9b3d" translate="yes" xml:space="preserve">
          <source>That is all covered in the documentation for Locale::Maketext and the modules that come with it, available in CPAN. After having read this article, which covers the why's of Maketext, the documentation, which covers the how's of it, should be quite straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="translated">이 경우 EBCDIC에서 ASCII 로의 변환은 웹 서버에서 수행되기 때문입니다. 자세한 내용은 웹 서버 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="translated">그것은 정확히</target>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="translated">그것이가는 한 괜찮습니다. Perl 서브 루틴은 문자열로만 지정할 수 있지만 Perl은 서브 루틴 및 익명 서브 루틴에 대한 참조를 허용합니다. 여기가</target>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="translated">그것은 이것에 대한 짧은 것입니다 :</target>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="translated">즉, &quot;시작&quot;문자 다음에 여러 개의 &quot;계속&quot;문자가옵니다. Perl은 식별자의 모든 문자가 &lt;code&gt;\w&lt;/code&gt; 와도 일치 해야합니다 (일부 문제가 발생하지 않도록 방지). 그리고 Perl은 밑줄로 시작하는 식별자 이름을 추가로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="translated">즉, &lt;code&gt;'code...'&lt;/code&gt; 필터</target>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="translated">즉, 약 &lt;code&gt;1.571&lt;/code&gt; 의 실수 부와 약 &lt;code&gt;-1.317&lt;/code&gt; 의 허수 부를 갖는 복소수 입니다.</target>
        </trans-unit>
        <trans-unit id="482980394273a0467a584ab6d2a57dbf1c99aa5d" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="translated">즉, 첫 번째 문자가 숫자가 아닌 한 ASCII 범위의 모든 단어 문자입니다.</target>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="translated">즉, 둘 다 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbeb96e56e49bccd6548d94f7137868a0f109bb7" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="translated">즉, 가져 메인 심볼 테이블에서 항목을 한 다음의 스칼라 구성 요소를 보면 : &lt;code&gt;gvsv&lt;/code&gt; 을 ( &lt;code&gt;pp_gvsv&lt;/code&gt; 을 로 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3442fe5454be65a5f12295c4981af0a997452b8" translate="yes" xml:space="preserve">
          <source>That is, instead of writing this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="translated">즉, 단일 단락으로 구성된 영역을 만듭니다. &quot;formatname&quot;이 &quot;:&quot;로 시작하면 해당 단락은 일반 단락으로 취급됩니다. &quot;formatname&quot;인 경우</target>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="translated">즉, 지정한 inputdir 및 output dir에 대해 기본 옵션으로 변환을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="translated">That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</target>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="translated">즉, 항목들 사이에 단락들 사이와 같은 간격이 있어야합니다 (간격이 텍스트 줄의 전체 높이보다 작을 수도 있음). 이것은 &quot;Qui dolorem ipsum ...&quot;단락이 &quot;Quisquam Est&quot;항목에 적용되는지 또는 &quot;Neque&quot;, &quot;Porro&quot;및 &quot;3 가지 항목 모두에 적용되는지를 알아 내기 위해 텍스트 신호를 사용하도록 독자에게 남겨 둡니다. Quisquam Est &quot;. 이상적인 상황은 아니지만 실제로 작성자의 의도와 상반 될 수있는 서식 신호를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1e5a6f76070bd03364763274b3558ec3c231e14e" translate="yes" xml:space="preserve">
          <source>That is, they all produce the same event structure (for the most part), namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="translated">즉, 10에서 15 사이의 숫자를 얻으려면 0에서 5 사이의 난수를 원하고 10에 더할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="translated">즉, &quot;= for&quot;를 사용하면 하나의 단락에 해당하는 텍스트 (예 : &quot;= foo targetname text ...&quot;의 텍스트) 만 가질 수 있지만 &quot;= begin targetname&quot;... &quot;= end targetname&quot; 사이에 많은 양의 물건을 넣을 수 있습니다. &quot;= begin&quot;명령 뒤에 빈 줄이 있어야하고 &quot;= end&quot;명령 앞에 빈 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="translated">위의 마지막 테스트 줄에는 '2'대신 '3'이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="translated">조금 더 멋져 보인다. 하지만 우리는 그 이상한 템플릿을 분해해야합니다. 어디에서 빼냈어요?</target>
        </trans-unit>
        <trans-unit id="61626fcd66a349166c06495de786a6747ef2482c" translate="yes" xml:space="preserve">
          <source>That may be what you want, but if what you really want is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c566d34d221f1316f52ee4a141ea9a232b591ec1" translate="yes" xml:space="preserve">
          <source>That means all the gzip support has to be done by hand - in this case by creating a tied filehandle to deal with creating the gzip header and trailer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="translated">즉, 호스트 기능의 경우 주소가 이진으로, 순 함수의 경우 정규 perl 정수로 다시 나타납니다. 이것은 버그 인 것 같지만이를 처리하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="translated">즉, 객체의 상속 트리가 가장 먼저 순회되고 클래스의 결과 순서가 메소드가 호출되는 순서로 사용됩니다. 그러나이 시퀀스는 파생 클래스의 적절한 메서드를 모든 조상 클래스의 동일한 메서드보다 먼저 호출해야한다는 규칙을 적용하여 수정됩니다. 그렇기 때문에 위 예제에서 &lt;code&gt;X::foo&lt;/code&gt; 가 &lt;code&gt;D::foo&lt;/code&gt; 보다 먼저 호출 됩니다. 비록 &lt;code&gt;@B::ISA&lt;/code&gt; 에서 &lt;code&gt;D&lt;/code&gt; 가 &lt;code&gt;X&lt;/code&gt; 보다 먼저옵니다 .</target>
        </trans-unit>
        <trans-unit id="c5e47decd3f17a0dbcacce7016d0aedaa3f7c7e2" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt;, even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="translated">즉, 다른 옵션 (예 : cachesize)을 지정할 수 있으며 가변 길이 레코드의 경우 bval 기본값은 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 이고 고정 길이 레코드의 경우 공백이됩니다.</target>
        </trans-unit>
        <trans-unit id="7045c7edb73bdaec4db668503265f3c3aee4ce06" translate="yes" xml:space="preserve">
          <source>That means you can only use this function to look at or manipulate text before or after complete JSON objects, not while the parser is in the middle of parsing a JSON object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f3ac9162c57e4899c7d0b17b547a39f0dc6701" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces and the colon or equal sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccd6e36decb0fa14e4cd9ccfdb15ab74bfe0e9c" translate="yes" xml:space="preserve">
          <source>That means, for example, that you can freely add or remove white space adjacent to (but within) the braces without affecting the meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;Infinity&lt;/code&gt; 와 같은 IEEE 표기법을 올바르게 처리하지 않기 때문에이 방법이 가장 좋습니다 . 다른 경우에는 POSIX :: strtod () 함수를 호출하거나 정규 표현식으로 문자열을 검사하여 ( &lt;a href=&quot;perlre&quot;&gt;perlre에&lt;/a&gt; 설명 된대로) 문자열 데이터를 숫자로 사용할 수 있는지 여부를 결정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="translated">알고있는 것 외에 다른 필드는 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">이제 예상대로 구문 분석되지만 해당 상황에서 괄호를 사용하는 습관을 가져야합니다. 프로토 타입에 대한 자세한 내용은 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7cb196541b3b7a98e0a23cefd4f853e129fa465" translate="yes" xml:space="preserve">
          <source>That output isn't terribly descriptive, is it? When you have two tests you can figure out which one is #2, but what if you have 102 tests?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="translated">&lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; 를 인쇄합니다 . (예, 여전히의 가시성을 할 필요 해결되지 않은 문제입니다 &lt;code&gt;@_&lt;/code&gt; . 나는 잠시 동안 그 질문을 무시하고있다. (하지만 우리가 할 경우주의 &lt;code&gt;@_&lt;/code&gt; 어휘 범위, 그 익명 서브 루틴 (... 폐쇄와 같은 역할을 할 수 있습니다 이봐, 이건 작은리스 피쉬 소리 같니?</target>
        </trans-unit>
        <trans-unit id="b70a77bf7cab1beed053568dab5acfb8d2eb3eda" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt;. (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt;. I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="translated">밖으로 인쇄한다 : &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; 다음과 같이 반복 횟수와 반복 패턴을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="translated">이 문제는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 를 사용하여 수정됩니다 . &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러는 이제 호출하는 코드로이 켜집니다 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 매개 변수로 제대로 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . 이 함수 는 &lt;code&gt;&amp;amp;&lt;/code&gt; 스루 를 수행하여 수행 되므로 함수 호출은 &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdeebf2bdaf24e4c227b81d4e7ade3f1477fb5b" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;. It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="translated">INST_ARCHLIB, SITELIBEXP 및 PERL_ARCHLIB에서 찾을 수있는 모든 확장명이 링크 된 현재 디렉토리에 새 perl 바이너리가 생성됩니다. 이를 위해 MakeMaker는 UNIX에서 새로운 Makefile을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4fc05162b844f86aa42257bcfb3642341ec2e119" translate="yes" xml:space="preserve">
          <source>That sadly does not (yet) work on QorIQ. At the moment of writing, the supported architectures are armv5, armv7, mipsel, wl500g, x86_32, and x86_64. Check &lt;a href=&quot;https://pkg.entware.net/binaries/&quot;&gt;here&lt;/a&gt; for supported platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="translated">즉, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; 은 찾을 수 없기 때문에 오류를보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">즉, Perl 버전 5.14에서는 구문상의 편의를 위해 규칙에 예외가 도입되었습니다. 실험적인 배열 및 해시 컨테이너 함수 동작을 사용하면 배열 및 해시 참조를 구문 적으로 역 참조 된 것처럼 Perl에서 처리 할 수 ​​있습니다. 자세한 내용 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;은 perl5140delta&lt;/a&gt; 및 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc의 &lt;/a&gt;구문 향상을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="translated">즉, 잠재적 크래커의 삶을 어렵게 만들기 위해 취할 수있는 여러 단계가 있습니다. 가장 중요한 : 암호 해독 필터를 C로 작성하고 암호 해독 모듈을 Perl 바이너리에 정적으로 연결하십시오. 잠재적 크래커의 삶을 어렵게 만드는 추가 정보는 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="translated">즉, 특정 종류의 문제에 더 편리한 특정 문제 영역 전용의 작고 집중된 특수 목적 언어가 항상 존재합니다. 펄은 모든 사람들에게 모든 것을 주려고 노력하지만 다른 사람에게는 특별한 것이 아닙니다. 염두에 두는 특수 언어의 예로는 프롤로그 및 MATLAB이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="translated">동일한 루프가 슬라이스 작업으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="translated">두 번째 인수는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; 'd 정규 표현식 (종료 자 행과 일치하는 데 사용됨) 또는 정의 된 false 값 (종료 자 행을 찾지 않아야 함을 나타냄) 또는 해시 ( 이 경우 종료자는 키 &lt;code&gt;'terminator'&lt;/code&gt; 와 연관된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="75416fa5f847a38d5ad02218210c2358173e5f41" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;qr&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="translated">작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="translated">아마도 다음과 같이 간단하게 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="translated">FLAGS 의 &lt;code&gt;UTF8&lt;/code&gt; 플래그와 &lt;code&gt;PV&lt;/code&gt; 의 UTF-8 바이트 및 유니 코드 문자를 보여줍니다 . 이 문서 뒷부분의 &lt;code&gt;utf8::is_utf8()&lt;/code&gt; 함수에 대한 설명도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85f3321460ffe7c824d8d5e2118a4e8f2a1ba235" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt;. See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90310d92761cded68c459a20fa9fa044cf2b05ae" translate="yes" xml:space="preserve">
          <source>That speeds things up but I have to make a note of which tests are failing and make sure that I run those tests. Instead I can use prove's --state switch and have it keep track of failing tests for me. First I do a complete run of the test suite and tell prove to save the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f7e088596d63a221ae18b14ab5e5b19e9feddc" translate="yes" xml:space="preserve">
          <source>That stores a machine readable summary of the test run in a file called '.prove' in the current directory. If I have failures I can then run just the failing scripts like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="translated">이 구문은 작동하지 않습니다. &lt;code&gt;@a&lt;/code&gt; 또는 &lt;code&gt;%a&lt;/code&gt; 만 설정 하고 &lt;code&gt;@b&lt;/code&gt; 또는 &lt;code&gt;%b&lt;/code&gt; 지 웁니다 . 플러스 기능은 두 개의 별도의 배열이나 해시로 전달되지 않은 : 그것은 하나 개의 긴 목록을 가지고 &lt;code&gt;@_&lt;/code&gt; 언제나처럼.</target>
        </trans-unit>
        <trans-unit id="129289f49f37b2d5f60aa742ea447f8c63a26d22" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt;. Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt;, as always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="translated">그러면 레코드 구분 기호가 일시적으로 해제되고 블록 종료시 파일이 자동으로 닫힙니다. 파일이 이미 열려 있으면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="translated">필드가 특정 순서로</target>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="translated">sizeof (struct) 또는 정렬은 모든 곳에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="translated">이 세 번째 인수는 &lt;code&gt;$fh&lt;/code&gt; 파일 핸들 에서 데이터의 바이트 크기를 테스트하고 그 많은 바이트를 &lt;code&gt;$var&lt;/code&gt; 버퍼로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="949fbe166b991dbecc0e8400e8a8c343a056cb09" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38036119f27283dda19af4e5c3596941c97c5a13" translate="yes" xml:space="preserve">
          <source>That way, quant just has to chose which form it needs, without having to look up or generate anything. While possibly not optimal for Russian, this should work well for most other languages, where quantification is not as complicated an operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="translated">이는 비어 있지 않은 그룹을 두 레벨 이하의 일치하는 괄호와 효과적으로 일치시킵니다. 그러나 그러한 그룹이 없으면 긴 문자열에 사실상 영원히 걸릴 것입니다. 긴 문자열을 여러 개의 하위 문자열로 나누는 방법에는 여러 가지가 있기 때문입니다. 이것이 &lt;code&gt;(.+)+&lt;/code&gt; 가하는 일이고, &lt;code&gt;(.+)+&lt;/code&gt; 는 위 패턴의 하위 패턴과 유사합니다. 위의 패턴이 &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; ) 에서 몇 초 안에 불일치 를 감지하는 방법을 고려 하지만, 각 추가 문자가 이번에는 두 배가됩니다.이 지수 성능으로 인해 프로그램이 중단 된 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;20&lt;/code&gt; 과 &lt;code&gt;10&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e40934849066a98371a45c630d963f7be828b226" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="translated">인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="05490647754607e7eecb9c45fdd4f2b090c65042" translate="yes" xml:space="preserve">
          <source>That will run all tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="translated">그러면 사람의 개입없이 스크립트 &lt;b&gt;myprogram&lt;/b&gt; 을 실행하여 시작점과 종료 점이있는 콜 트리를 인쇄합니다. 참고 &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; 에 해당 &lt;code&gt;N f=2&lt;/code&gt; , 원래 옵션 고유 첫 글자가 단축 될 수 있음 (모듈러스 &lt;code&gt;Dump*&lt;/code&gt; 옵션). 그럼에도 불구하고 가독성과 향후 호환성을 위해 항상 전체를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b8798239553ae3afadcaa20b0a364d6ef25290e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt;, and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 는 탐욕스럽고 문자열 전체를 뒤섞 았기 때문에 전혀 작동하지 않습니다 . 로 &lt;code&gt;\d*&lt;/code&gt; 전체 정규 표현식이 성공적으로 일치 빈 문자열에 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6d51f1f160810f3ac3cc94b21320c749d1f295" translate="yes" xml:space="preserve">
          <source>That'll get you scolded on perl5-porters, so don't do that. Be Awesome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">그것은 조금 나아지지만, 우리는 여전히 마지막 열을 가지고 더 나아가 야합니다. 이 최대를 해결하는 쉬운 방법이있다 : 불행하게도, 우리가 얻을 수없는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 에 대한 우리의 필드를 마우스 오른쪽 단추로 정당화하지만, 우리가 얻을 수있는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와는 그것을 할 :</target>
        </trans-unit>
        <trans-unit id="28a77e110fbf943f3cd364152b5e3d00190d5f60" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;pack&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;sprintf&lt;/code&gt; to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="translated">그게 전부입니다. 우리는 완전성, 견고성 및 일반적인 미학을 위해 여기에 몇 가지 좋은 일을했기 때문에 실제로 모든 것이 있습니다. 더 간단한 TIESCALAR 클래스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="translated">그것이 꼭 필요한 전부입니다. 원하는 추가 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="translated">고정 된 데이터 구조를 선언하는 데는 모두 좋지만, 새 요소를 즉석에서 추가하거나 완전히 새로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="translated">동적 링크가있는 Unix 시스템에서해야 할 전부입니다. 대부분의 유닉스 시스템에는 동적 연결이 있습니다. 그렇지 않은 경우 또는 다른 이유로 정적으로 연결된 펄이 &lt;b&gt;있고&lt;/b&gt; 모듈에 컴파일이 필요한 경우 모듈을 포함하는 새로운 Perl 바이너리를 빌드해야합니다. 다시, 당신은 아마도 루트가되어야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="translated">그게 다야. ncftp 또는 ftp와 마찬가지로 다음과 같이 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="translated">그것은 자생입니다. 몇 가지 방법으로이 문제를 해결할 수 있습니다. 가장 쉬운 방법은 전원을 끄는 것입니다. 어휘 &lt;code&gt;autovivification&lt;/code&gt; pragma는 CPAN에서 사용할 수 있습니다. 이제 해시에 추가하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 는 탐욕 스러웠 기 때문에</target>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="translated">Perl이 변수를 암시 적으로 역 참조하지 않기 때문입니다. 참조가 참조하는 것을 얻으려면 &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; 과 같은 접두사 입력 표시기를 사용하여 직접 수행해야합니다 . 그렇지 후위 포인터 화살표처럼 &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , 또는 &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7a4a3776ff01d004644640252dd53fc3704e0e2" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt;, &lt;code&gt;@{$blah}&lt;/code&gt;, &lt;code&gt;@{$blah[$i]}&lt;/code&gt;, or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt;, &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt;, or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="translated">왜냐하면 5 개의 접두어 역 참조 자 ( &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) 에 대한 Perl의 우선 순위 규칙 이 접미사 첨자 괄호 또는 중괄호보다 더 밀접하게 바인딩 되기 때문입니다 ! 이것은 의심의 여지없이 C 또는 C ++ 프로그래머에게 큰 충격이 될 것입니다. C 또는 C ++ 프로그래머는 &lt;code&gt;*a[i]&lt;/code&gt; 를 사용 하여</target>
        </trans-unit>
        <trans-unit id="41187fe54a62e820e1df501181075a2f61202104" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt;) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="translated">이는 &lt;code&gt;$fh&lt;/code&gt; 를 &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; 과 같은 문자열로 취급 한 다음 패턴과 일치하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e5243109f1982ab10b2f341fa04b05232d301e22" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt;, then pattern matches against that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="translated">my ()는 컴파일 타임 선언보다 런타임 문에 가깝기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="translated">확실히 더 낫지 만 모든 정수의 길이와 이식성이 멀리 있는지 알아야합니다. 예를 들어, &lt;code&gt;2&lt;/code&gt; 보다는 &quot;짧은 길이&quot;라고 말하고 싶습니다. 그러나 이것은 적절한 팩 코드를 괄호 안에 넣어서 수행 할 수 있습니다 : &lt;code&gt;[s]&lt;/code&gt; . 우리가 할 수있는 최선의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3165047d193a37d5ff71109d566914086cc04dd" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt;, for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="translated">이전 방식보다 빠르고 깨끗하며 안전합니다. 물론 달러 기호를 사용할 필요는 없습니다. 대괄호 백분율 기호 등과 같이 자신 만의 체계를 사용하여 혼동을 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="translated">인터넷 도메인 클라이언트와 서버에는 문제가 없지만 로컬 통신은 어떻습니까? 동일한 설정을 사용할 수 있지만 때로는 원하지 않는 경우도 있습니다. 유닉스 도메인 소켓은 현재 호스트에 로컬이며 파이프를 구현하기 위해 내부적으로 자주 사용됩니다. 인터넷 도메인 소켓과 달리 Unix 도메인 소켓은 파일 시스템에 ls (1) 목록으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="translated">이것이 Perl이 프로그램을 위에서 아래로 구문 분석 한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="translated">그것이 작동하는 방식입니다. 꽤 간단합니다. 많은 Perl 프로그램과 마찬가지로 설명은 프로그램보다 훨씬 길다.</target>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="translated">이것이 &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; 함수가 전체적으로 작동하는 방식입니다. 그러나 기존의 핸들러 함수를 완전히 대체하지는 않습니다. 대신 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 의 사본을 가져 와서 자신의 함수 포인터를 지정하십시오. 핸들러 함수는 관심있는 키워드를 찾아서 처리해야합니다. 관심이없는 경우 저장된 플러그인 함수를 호출하여 수신 한 인수를 전달해야합니다. 따라서 &lt;code&gt;PL_keyword_plugin&lt;/code&gt; 은 실제로 처리기 함수 체인을 가리키며, 모두 키워드를 처리 할 수있는 기회를 가지며 체인의 마지막 함수 (Perl 코어에 내장) 만 일반적으로 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2b08fbd323cdcfc2a59e5f4cc2312d748230aa97" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="translated">그것이 참조를 만드는 것입니다. 이제는 참조를 사용하여 오랫동안 손실 된 데이터로 돌아가는 방법을 알고 싶어 할 것입니다. 몇 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="translated">그게 다야, 다시 잔디밭으로 돌아 왔어.</target>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="translated">스칼라에 배열을 할당하고 요소 수를 얻는 간단한 경우입니다. 그것이 당신이 정말로 진정으로 원하는 것이라면, 다음과 같이 좀 더 명시 적으로 생각하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="translated">그다지 도움이되지는 않지만 몇 가지 환영은 있지만 어떤 키가 키인지 어떤 값인지는 표시되지 않으며 나열된 배열 덤프 일뿐이며 특히이 경우에는 도움이되지 않습니다. 여기서 트릭 은 데이터 구조에 대한 &lt;b&gt;참조&lt;/b&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="translated">특히 효율적이지 않습니다. 사용하는 것이 더 공간 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="translated">거의 다됐다. 이제 쓰기</target>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="translated">라이브러리를 잊었거나 라이브러리 경로가 다르기 때문일 수 있습니다. 실제로 배포 할 시스템에 전체 배포를 구축 한 다음 &lt;code&gt;make install&lt;/code&gt; 을 입력 해야 합니다. 대부분의 다른 접근 방식은 실패로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="bd1f4414e3c5b98a871dc22bff9ce2a5552a8c42" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt;. Most other approaches are doomed to failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="translated">아래에 나와있는 프로그램에서 전화 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="translated">여기서는 Perl과 연결된 C / C ++ 루틴 간의 초기 접촉을 만들기 위해 글루 코드를 삽입 할 수 있습니다. 몇 가지를 살펴 보자</target>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="translated">그렇기 때문에 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 를 사용하면 직렬화 할 참조 목록을 제공 할 수 있습니다. 엔진은 다른 객체와 동일한 컨텍스트에서 직렬화되므로 공유 객체는 공유 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="translated">이것이 바로 '옵션'이라고 불리는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="2ebc0d199c8eb44a7ac92ea22e10498f30092a55" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;12.0&lt;/code&gt;; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt;. This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="translated">위의 &quot;*&quot;는 &lt;code&gt;1.1&lt;/code&gt; 또는 &lt;code&gt;4.0&lt;/code&gt; 과 같은 2 자리 유니 코드 버전 번호를 나타냅니다 . 또는 &quot;*&quot;는 &lt;code&gt;Unassigned&lt;/code&gt; 않을 수도 있습니다 . 이 속성은 버전 번호로 지정된 유니 코드 릴리스에서 최종 처리가 완료된 코드 포인트와 일치합니다. &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; 는 의미가 아직 할당되지 않은 코드 포인트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="translated">&quot;*&quot;문자는 완전한 입력 파일 이름으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="translated">&quot;*&quot;수량자는 &lt;code&gt;{0,}&lt;/code&gt; , &quot;+&quot;수량은 &lt;code&gt;{1,}&lt;/code&gt; , &quot;?&quot; &lt;code&gt;{0,1}&lt;/code&gt; 에 대한 수량 자 . n 및 m은 perl이 빌드 될 때 정의 된 사전 설정 한계보다 작은 음이 아닌 정수 값으로 제한됩니다. 이것은 가장 일반적인 플랫폼에서 일반적으로 32766입니다. 실제 한계는 다음과 같은 코드로 생성 된 오류 메시지에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="translated">이러한 식별자의 &quot;:&quot;은 단순히 &quot;결과가 일부 특수 대상에 대한 것이더라도 정상적으로 처리합니다&quot;를 의미합니다. 파서 API는 &quot;biblio&quot;를 대상 식별자로보고하고 &quot;:&quot;접두사가 있다고보고합니다. (또한 위의 &quot;html&quot;을 사용하여 &quot;html&quot;을 대상 식별자로보고하고</target>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="translated">&quot; &lt;code&gt;rules&lt;/code&gt; &quot;데이터 구조는 스케줄러의 핵심입니다. &quot;모든 테스트를 순차적으로 실행&quot;또는 &quot;이 다섯 가지 테스트를 제외한 모든 테스트를 병렬로 실행&quot;과 같은 간단한 규칙을 표현할 수 있습니다. 그러나 규칙 구조는 glob 스타일 패턴 일치 및 재귀 정의도 지원하므로 임의로 복잡한 패턴을 표현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ed0d091df98bc8db977a3f32a7cda06b5707b99" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt;&quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="translated">&quot;= 시작</target>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">은 &quot;= 항목 [텍스트] '단락이 일치하지 않아야 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt; 않으며 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb00107a8cd7306f310a4e41cd2188b092574511" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; or &lt;code&gt;m/\A=item\s+\*\s*\z/&lt;/code&gt;, nor should it match just &lt;code&gt;m/\A=item\s*\z/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="translated">&quot;= pod&quot;명령 자체는 아무 것도하지 않지만, 펄 (및 포드 포맷터)에게 포드 블록이 여기서 시작한다는 신호를 보냅니다. 포드 블록은</target>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="translated">&quot;영어&quot;연산자 ( &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; 및 &lt;code&gt;not&lt;/code&gt; 아님 )는 위와 같은 상황에서 목록 연산자보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="c776db1d67057122c329ee64bd76a151ecfea104" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt;) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="translated">&quot;MIT&quot;라이센스</target>
        </trans-unit>
        <trans-unit id="809b368cf33985ff1e068eaf70e57337041ab266" translate="yes" xml:space="preserve">
          <source>The &quot;Tree&quot; subsubsection in XML::Parser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="translated">&quot;U&quot;모드는 Python의 &quot;Universal Newlines&quot;개념을 기반으로하므로 처리 전에 DOS 및 Mac OS 줄 종결자가 내부적으로 UNIX 줄 바꾸기로 변환됩니다. 이는 여러 파일 시스템에서 동시에 작업 할 때 일관된 다이제스트 값을 보장합니다. &lt;b&gt;은 &quot;U&quot;모드의 영향 만 텍스트 파일&lt;/b&gt; , 즉 사람들은 펄의 통과</target>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="translated">&quot;유니 코드 버그&quot;</target>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="translated">&quot;액세스&quot;하위 pragma</target>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="translated">&quot;잘못된 인터프리터&quot;메시지는 펄이 아니라 쉘에서 온다. 실제 메시지는 플랫폼, 셸 및 로캘 설정에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">&quot;else if&quot;키워드는 Perl에서 &lt;code&gt;elsif&lt;/code&gt; 로 표시 됩니다. 더 없습니다 &lt;code&gt;elif&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; 중 하나는. &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; 구문 분석 하지만 사용하지 않는 것에 대해서만 경고합니다.</target>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="translated">&quot;else if&quot;키워드는 Perl에서 &lt;code&gt;elsif&lt;/code&gt; 로 표시 됩니다. 더 없습니다 &lt;code&gt;elif&lt;/code&gt; 또는 &lt;code&gt;else if&lt;/code&gt; 하나는. &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; 구문 분석 하지만 사용하지 않는 것에 대해서만 경고합니다.</target>
        </trans-unit>
        <trans-unit id="376964f7b7dc051fc5e877b839e65e771ea6ae93" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;elseif&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="translated">&quot;fail&quot;속성은 &lt;code&gt;fail_with&lt;/code&gt; 메소드를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f145fe55bdca7d5323b2fa4d4c3d2d68727a4e71" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;&quot;#&quot;&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="translated">의미 &quot;모든 당신이 할 수있는 잡아, 그리고 포기하지 않는 무엇이든 다시는&quot;여기서 첫눈에 간단한 많은 상황에서 바람직하다 &lt;code&gt;()*&lt;/code&gt; 올바른 해결책처럼 보인다. &lt;code&gt;#&lt;/code&gt; 으로 구분 된 주석과 선택적 (가로) 공백 이있는 텍스트를 구문 분석한다고 가정 합니다. 모양과 달리 &lt;code&gt;#[ \t]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c9200741055f798210ca5b9a02d181e70102c1" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has &lt;code&gt;SO_LINGER&lt;/code&gt; enabled with a zero timeout, then the peer's &lt;code&gt;close&lt;/code&gt; will generate a &lt;code&gt;RST&lt;/code&gt; segment. Upon receipt of that segment, the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, this method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="translated">&quot;대부분의 경우&quot;헤지는 로컬 TCP 상태 시스템 동작이 피어의 소켓 옵션에 따라 달라질 수 있기 때문입니다. 특히, 피어 소켓에서 시간 종료없이 SO_LINGER를 사용하도록 설정 한 경우 피어의 close ()는 로컬 TCP가 즉시 &lt;b&gt;CLOSED로&lt;/b&gt; 전환 되고 해당 상태에서 connected ()로 전환되는 RST 세그먼트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="191bee2290fcd83ba60b79d930b2194e317ac84f" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;a href=&quot;perlfunc#-X-FILEHANDLE&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="translated">&quot;노드 변경 타임 스탬프&quot;( &lt;code&gt;-C&lt;/code&gt; 파일 테스트)는 실제로 &quot;생성 타임 스탬프&quot;(유닉스가 아님) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="translated">Perl에서 제공하는 &quot;인터프리터 기반 스레드&quot;는 멀티 태스킹을위한 빠르고 가벼운 시스템이 아닙니다. 스레드는 오용하기 쉬운 방식으로 구현됩니다. 올바르게 사용하는 방법을 알거나 도움을 줄 수있는 사람은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="17303b20d10d9ca1d72a771659e0ed0ddf3d30b9" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that makes them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="translated">&quot;like&quot;코드 항목이 항상 정확한 표현은 아닙니다. 예를 들어, smartmatch 연산자는 가능할 때마다 단락되지만 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 은 그렇지 않습니다. 또한 스칼라 컨텍스트의 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 은 일치 횟수를 반환 하지만 &lt;code&gt;~~&lt;/code&gt; 는 true 또는 false 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ea890b70f56a5f9e0d36cf926a8647084d27520" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;grep&lt;/code&gt; does not. Also, &lt;code&gt;grep&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="translated">&quot;locked&quot;속성은 더 이상 사용되지 않으며 5.10.0 이상에서는 영향을 미치지 않습니다. 현재 제거 된 &quot;Perl 5.005 스레드&quot;의 일부로 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="translated">&quot;테스트 테스트&quot;단계는 일반적으로 설치 전에 Perl 확인 절차를 실행합니다. &quot;make test&quot;가 성공적으로 실행되는 동안에도 STDERR 메시지가 나타날 수 있습니다. 다음은 가장 일반적으로 나타나는 일부 이상에 대한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="translated">&quot;maketext&quot;메소드</target>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="translated">&quot;mro&quot;네임 스페이스는 일반적으로 메소드 분석 순서 및 메소드 캐싱을 처리하기위한 여러 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="translated">&lt;code&gt;BRANCH&lt;/code&gt; 를 제외한 모든 regops의 &quot;다음&quot;포인터는 연결을 구현합니다. 양쪽 끝에 &lt;code&gt;BRANCH&lt;/code&gt; 가 있는 &quot;다음&quot;포인터 는 두 가지 대안을 연결합니다. [여기서 우리는 미묘한 구문 의존성 중 하나를 가지고 있습니다 : 개별 &lt;code&gt;BRANCH&lt;/code&gt; (모음과는 대조적으로)는 연산자 우선 순위 때문에 어떤 것도 연결되지 않습니다.]</target>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="translated">&quot;p&quot;모드는 &quot;\ r \ r \ n&quot;을 단일 개행 문자로 취급한다는 점에서만 &quot;U&quot;와 다릅니다.이 기능은 DOS 줄 종결 자 앞에 추가 캐리지 리턴을 추가하는 레거시 응용 프로그램을 수용하도록 설계된 기발한 기능입니다. &quot;p&quot;모드는 더 깨끗하고 잘 확립 된 Universal Newlines 개념을 위해 결국 단계적으로 폐지 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="translated">&quot;prototype&quot;속성은 서브에서 프로토 타입을 지정하는 대체 수단입니다. 원하는 프로토 타입은 괄호 안에 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="translated">해시의 &quot;품질&quot;은 임의의 해시에 필요한 예상 수와 비교하여 모든 요소에 한 번 액세스하는 데 필요한 총 비교 수로 정의됩니다. 값이 100 %를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="translated">네임 스페이스의 &quot;루트&quot;(예 : &quot;main ::&quot;)가 다른 패키지로 변경되고 구획에서 평가 된 코드는 런타임 glob 조회 및 기타 트릭을 사용하더라도이 네임 스페이스 외부의 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="translated">&quot;상태 값&quot;이 &lt;code&gt;$?&lt;/code&gt; Perl 프로그램이 서브 프로세스의 성공적인 완료를 이식 가능하게 테스트 할 수 있도록 POSIX wait (5) 시맨틱과 유사한 방식으로 서브 프로세스의 실제 종료 상태에서 통합됩니다. 하위 8 비트 &lt;code&gt;$?&lt;/code&gt; 프로세스의 종료 상태가 예외에 의해 생성되었거나 생성되지 않았을 수 있으므로 VMS에서 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="translated">&quot;고유&quot;속성은 더 이상 사용되지 않으며 5.10.0 이상에서는 영향을 미치지 않습니다. 그것은의 단일 사본을 나타 내기 위해 사용되는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 변수는 프로그램이 멀티 인터프리터 환경에서 실행 될 일이되어야 모든 통역 사용할 수 있도록했다.</target>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="translated">&quot;사용 로케일&quot;프라 그마</target>
        </trans-unit>
        <trans-unit id="ec6d1363cbbe06a4225f4f4c8cb504676b9d9ab8" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; key has a reference to an AV as its value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="translated">#endif와 #else는 그 뒤에 주석이없는 것을 포팅 할 수 없습니다. 진행 상황을 문서화하려면 (특히 가지가 긴 경우에 특히 좋습니다) (C) 주석을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="translated">$ algorithm은 &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;와 같은 문자열입니다. 주어진 알고리즘의 구현을 위해 추가 인수가 생성자에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="translated">$ always_copy 매개 변수는 true 인 경우 파일이 변경되었는지 여부에 관계없이 파일을 업데이트하지만 정의 된 경우 파일을 변경 한 경우에만 복사되며, 정의되지 않은 경우 환경 변수 EU_INSTALL_ALWAYS_COPY는 다음과 같습니다. 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">$ buffer는 Storable 이미지이거나 처음 몇 바이트 여야합니다. $ buffer가 Storable 헤더로 시작하면 이미지를 설명하는 해시가 리턴되고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="78cacc3a4b41df98d6d490128b52baa4b5d2d0fc" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90557aa2dce112e348d655279a7a2af9b8d9198" translate="yes" xml:space="preserve">
          <source>The $chld_in filehandle will have autoflush turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">인수로 제공된 $ data는 다이제스트를 계산하는 메시지에 추가됩니다. 리턴 값은 $ md5 오브젝트 자체입니다.</target>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="translated">&quot;바&quot;가있는 $ f를 새로운 있어야한다 그것을 세 번에 추가 &lt;code&gt;$f&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 루프를 통해 새로운 어휘 변수를 매번 작성해야합니다. 예상되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9804e7c51be3b218136a0732d780cc554d28fa80" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;my $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="translated">$ filename 매개 변수는 die (), caller () 또는 디버거에 필요한 경우 Perl에서 함수의 소스 파일을 식별하는 데 사용됩니다. $ filename이 정의되지 않으면 &quot;DynaLoader&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="translated">dl_load_file 동작을 변경하는 $ flags 인수. 할당 된 비트 :</target>
        </trans-unit>
        <trans-unit id="533efbe36456ad5f0b2eb4a7940fb956d6dc8359" translate="yes" xml:space="preserve">
          <source>The $host argument can be omitted when specifying the &lt;code&gt;host&lt;/code&gt; option to new().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b2f35c340f46f849fe05ab2a263ba75176b401" translate="yes" xml:space="preserve">
          <source>The $input_filename_or_reference parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd706f4aac9bb23ac72e5f391e9438d3b6687fe7" translate="yes" xml:space="preserve">
          <source>The $io_handle is read until EOF and the content is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">EOF까지 $ io_handle을 읽고 내용은 다이제스트를 계산하는 메시지에 추가됩니다. 반환 값은 $ ctx 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="f48497c09ab813ab9f670545e1d053cf6b1c4105" translate="yes" xml:space="preserve">
          <source>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">EIO와 다이제스트를 계산하는 메시지에 내용이 추가 될 때까지 $ io_handle을 읽습니다. 리턴 값은 $ md5 오브젝트 자체입니다.</target>
        </trans-unit>
        <trans-unit id="73b7765fc89db094ffe9099cbf5e1b07621f5606" translate="yes" xml:space="preserve">
          <source>The $keep argument is a boolean flag. If true, then the tokens are split on the specified delimiter, but all other characters (including quotes and backslashes) are kept in the tokens. If $keep is false then the &amp;amp;*quotewords() functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp;amp;quotewords() tries to interpret these characters just like the Bourne shell). NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.</source>
          <target state="translated">$ keep 인수는 부울 플래그입니다. true이면 토큰이 지정된 구분 기호로 분할되지만 다른 모든 문자 (따옴표 및 백 슬래시 포함)는 토큰에 유지됩니다. $ keep이 false이면 &amp;amp; * quotewords () 함수는 백 슬래시로 이스케이프되지 않거나 작은 따옴표 안에 있지 않은 모든 따옴표와 백 슬래시를 제거합니다 (예 : &amp;amp; quotewords ()는 Bourne 쉘과 같이 이러한 문자를 해석하려고 시도합니다). NB : 이러한 의미는 Perl 5.000 ~ 5.004와 함께 제공되는이 모듈의 원래 버전과 크게 다릅니다. 추가 기능으로 $ keep은 키워드 &quot;구분자&quot;일 수 있으며, 이로 인해 함수는 따옴표 및 백 슬래시 문자를 보존 할뿐만 아니라 각 문자열의 분리 문자를 토큰 목록의 토큰으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4e5f5797e7dfa3a15e15f61203e30952d45673d5" translate="yes" xml:space="preserve">
          <source>The $members value returned by</source>
          <target state="translated">에 의해 반환 된 $ members 값</target>
        </trans-unit>
        <trans-unit id="83788be2ef337c14a7fbd0046f5c9a6c4208063c" translate="yes" xml:space="preserve">
          <source>The $output_filename_or_reference parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea59b84534455476bdc42448f750e6798f5fa6a2" translate="yes" xml:space="preserve">
          <source>The %result hash will be populated with the various keys/subhashes reflecting the install. Currently these keys and their structure are:</source>
          <target state="translated">% result 해시는 설치를 반영하는 다양한 키 / 서브 해시로 채워집니다. 현재 이러한 키와 그 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aad53f0657034b93e1e3cf8ea5f7f3e1670d20ff" translate="yes" xml:space="preserve">
          <source>The %s function is unimplemented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2003a4836fd23e3d85388f2cbd39901c6bc22d" translate="yes" xml:space="preserve">
          <source>The &amp;amp; Unary Operator</source>
          <target state="translated">&amp;amp; 단항 연산자</target>
        </trans-unit>
        <trans-unit id="ddb7807e2ac7fcb7b1862d48b33f4bdc45bd2c34" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem</source>
          <target state="translated">&amp;amp;&amp;amp; 문제</target>
        </trans-unit>
        <trans-unit id="4101646effcfa6c9b3723eeb19290b923da87717" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem.</source>
          <target state="translated">&amp;amp;&amp;amp; 문제.</target>
        </trans-unit>
        <trans-unit id="819c8af579e67bbf16b0d43d190eb1e52a12ff6c" translate="yes" xml:space="preserve">
          <source>The &amp;amp;nested_quotewords() and &amp;amp;quotewords() functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes. &amp;amp;quotewords() returns all of the tokens in a single long list, while &amp;amp;nested_quotewords() returns a list of token lists corresponding to the elements of @lines. &amp;amp;parse_line() does tokenizing on a single string. The &amp;amp;*quotewords() functions simply call &amp;amp;parse_line(), so if you're only splitting one line you can call &amp;amp;parse_line() directly and save a function call.</source>
          <target state="translated">&amp;amp; nested_quotewords () 및 &amp;amp; quotewords () 함수는 구분 기호 (정규 표현식 일 수 있음)와 행 목록을 승인 한 다음 해당 행을 인용 부호 안에 나타나는 구분 기호를 무시하고 단어 목록으로 나눕니다. &amp;amp; quotewords ()는 하나의 긴 목록에있는 모든 토큰을 리턴하고 &amp;amp; nested_quotewords ()는 @lines의 요소에 해당하는 토큰 목록을 리턴합니다. &amp;amp; parse_line ()은 단일 문자열에서 토큰 화를 수행합니다. &amp;amp; * quotewords () 함수는 단순히 &amp;amp; parse_line ()을 호출하므로 한 줄만 분할하는 경우 &amp;amp; parse_line ()을 직접 호출하고 함수 호출을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c87ced9da37d8df457e1116fcc0073fb1557eae" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">&amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c4f590c76222edc7a4139c10a801899ef6080952" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bf8f7c8c4159c0583c72496084082131f49306a" translate="yes" xml:space="preserve">
          <source>The &amp;lt;FH&amp;gt; construct is not the name of the filehandle, it is a readline operation on that handle. The data read is assigned to $_ only if the file read is the sole condition in a while loop:</source>
          <target state="translated">&amp;lt;FH&amp;gt; 구문은 파일 핸들의 이름이 아니며 해당 핸들에 대한 readline 작업입니다. 읽은 파일이 while 루프의 유일한 조건 인 경우에만 데이터 읽기가 $ _에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab73cfd3e43216b54a963f39932451a527bcc6a3" translate="yes" xml:space="preserve">
          <source>The '&lt;b&gt;-w&lt;/b&gt;' switch would have told us about this, had we used it at the start, and saved us a lot of trouble:</source>
          <target state="translated">' &lt;b&gt;-w&lt;/b&gt; '스위치는 이것에 대해 말했을 것이고, 처음에 사용했을 때 많은 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="bd6318c738360c72f699370e44631e5d478a985b" translate="yes" xml:space="preserve">
          <source>The 'array_base' feature</source>
          <target state="translated">'array_base'기능</target>
        </trans-unit>
        <trans-unit id="0d3b66a213047641035eea0c1bcf8c880d1b087a" translate="yes" xml:space="preserve">
          <source>The 'bitwise' feature</source>
          <target state="translated">'비트 단위'기능</target>
        </trans-unit>
        <trans-unit id="2376f82ab2d823fadd94b13d055e3e37926a8909" translate="yes" xml:space="preserve">
          <source>The 'blead' branch will become the next production release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5d26aebe5343fcb8365359fdfecbe6a1f9ce93" translate="yes" xml:space="preserve">
          <source>The 'bval' Option</source>
          <target state="translated">'bval'옵션</target>
        </trans-unit>
        <trans-unit id="e00309e30b37c032e9723d99c993712660e13d4a" translate="yes" xml:space="preserve">
          <source>The 'current_sub' feature</source>
          <target state="translated">'current_sub'기능</target>
        </trans-unit>
        <trans-unit id="6c052a5c9bdb1ba3c0df3df62a320e47a9bd25cd" translate="yes" xml:space="preserve">
          <source>The 'd' and the 'm' command normally only show you information they have in their in-memory database and thus will never connect to the internet. If you set the 'show_upload_date' variable to true, 'm' and 'd' will additionally show you the upload date of the module or distribution. Per default this feature is off because it may require a net connection to get at the upload date.</source>
          <target state="translated">'d'및 'm'명령은 일반적으로 인 메모리 데이터베이스에있는 정보 만 표시하므로 인터넷에 연결되지 않습니다. 'show_upload_date'변수를 true로 설정하면 'm'및 'd'에 모듈 또는 배포판의 업로드 날짜가 추가로 표시됩니다. 이 기능은 업로드 날짜에 인터넷 연결이 필요할 수 있으므로 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="509605357b02233eb13a519ed86bc5588e63f2bb" translate="yes" xml:space="preserve">
          <source>The 'declared_refs' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e825d609e1bdb12613a2765369452bfb2902c9" translate="yes" xml:space="preserve">
          <source>The 'fc' feature</source>
          <target state="translated">'fc'기능</target>
        </trans-unit>
        <trans-unit id="c532c19d0965a864c1673a10c98911020476e550" translate="yes" xml:space="preserve">
          <source>The 'hushed' flag has a global scope during compilation: the exit() or die() commands that are compiled after 'vmsish hushed' will be hushed when they are executed. Doing a &quot;no vmsish 'hushed'&quot; turns off the hushed flag.</source>
          <target state="translated">'hushed'플래그는 컴파일하는 동안 전역 범위를 갖습니다. 'vmsish hushed'이후에 컴파일 된 exit () 또는 die () 명령은 실행될 때 숨겨집니다. &quot;No vmsish 'hushed'&quot;를 수행하면 hushed 플래그가 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="f3c4a2190f41366ac81419b36b206c02ca25e77f" translate="yes" xml:space="preserve">
          <source>The 'indirect' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05575bbb92499cca81508b16233a4f48eaa12953" translate="yes" xml:space="preserve">
          <source>The 'info' facet is a list instead of a single item, any quantity of extra information can be attached to an event. Some information may be critical diagnostics, others may be simply commentary in nature, this is determined by the &lt;code&gt;debug&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf69940e6c70d26326135ebbe9700ea9cbaa2c64" translate="yes" xml:space="preserve">
          <source>The 'isa' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476d927d17a3d46a0ed772d0abdb4399c93a366e" translate="yes" xml:space="preserve">
          <source>The 'lexical_subs' feature</source>
          <target state="translated">'lexical_subs'기능</target>
        </trans-unit>
        <trans-unit id="d15b2cae0ecbb384e6a16c159b73754a15b73452" translate="yes" xml:space="preserve">
          <source>The 'postderef' and 'postderef_qq' features</source>
          <target state="translated">'postderef'및 'postderef_qq'기능</target>
        </trans-unit>
        <trans-unit id="032a279126f29bd2ca1a4d576f6688e5bd0a4721" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature allows the use of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt;. For example, it will make the following two statements equivalent:</source>
          <target state="translated">'postderef'기능을 사용하면 &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;접미사 역 참조 구문을&lt;/a&gt; 사용할 수 있습니다 . 예를 들어 다음 두 문장을 동일하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="be7e2c7e833c38213d25b7e41371f00fd6ae1cc7" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature was used in Perl 5.20 and Perl 5.22 to enable postfix dereference syntax outside double-quotish interpolations. In those versions, using it triggered the &lt;code&gt;experimental::postderef&lt;/code&gt; warning in the same way as the 'postderef_qq' feature did. As of Perl 5.24, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d578b5339ed54ec5db37c2e8106e846c9a1c704" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends the applicability of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt; so that postfix array and scalar dereference are available in double-quotish interpolations. For example, it makes the following two statements equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72039153ef5da3a0b8c844ea7ff1d46ddb7f3f43" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends this, for array and scalar dereference, to working inside of double-quotish interpolations.</source>
          <target state="translated">'postderef_qq'기능은 배열 및 스칼라 역 참조를 위해 이것을 이중 따옴표 내삽 내부에서 작업하도록 확장합니다.</target>
        </trans-unit>
        <trans-unit id="1856b511545a836fd1960f70b611782e60e03174" translate="yes" xml:space="preserve">
          <source>The 'refaliasing' feature</source>
          <target state="translated">'refaliasing'기능</target>
        </trans-unit>
        <trans-unit id="43acd92859b0081e26405b0092a9e001da38bcb0" translate="yes" xml:space="preserve">
          <source>The 'say' feature</source>
          <target state="translated">'say'기능</target>
        </trans-unit>
        <trans-unit id="48c11f3663366e7407088877b28bc4e952cd3e8c" translate="yes" xml:space="preserve">
          <source>The 'signatures' feature</source>
          <target state="translated">'서명'기능</target>
        </trans-unit>
        <trans-unit id="1ef5c6a6bc489a315173331d45afe7880d296d9b" translate="yes" xml:space="preserve">
          <source>The 'state' feature</source>
          <target state="translated">'상태'기능</target>
        </trans-unit>
        <trans-unit id="0202f826bf3e7b7586cfc812c13b1dfe89d2bf49" translate="yes" xml:space="preserve">
          <source>The 'switch' feature</source>
          <target state="translated">'스위치'기능</target>
        </trans-unit>
        <trans-unit id="7029a8b5bd568b6e4297fb88434b17a5f75b3a17" translate="yes" xml:space="preserve">
          <source>The 'unicode_eval' and 'evalbytes' features</source>
          <target state="translated">'unicode_eval'및 'evalbytes'기능</target>
        </trans-unit>
        <trans-unit id="e493b49d6dbbae3a5be3b8f2dff13d8ec26ef7db" translate="yes" xml:space="preserve">
          <source>The 'unicode_strings' feature</source>
          <target state="translated">'unicode_strings'기능</target>
        </trans-unit>
        <trans-unit id="5ea68e68d7d7c5a9842b2a6416db5968c04cbe4d" translate="yes" xml:space="preserve">
          <source>The 'unique' attribute may only be applied to 'our' variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6dd476d660cd451b4df840859a13759199b455" translate="yes" xml:space="preserve">
          <source>The (numeric) value of &lt;code&gt;$!&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfde022325aa7cfbc096171cf51353e9b32230c" translate="yes" xml:space="preserve">
          <source>The --state switch supports a number of options; for example to run failed tests first followed by all remaining tests ordered by the timestamps of the test scripts - and save the results - I can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f31ae17f71ba4abf6738dd8a78689f3b1ddbaf2" translate="yes" xml:space="preserve">
          <source>The -Dprefix option will install Perl in a directory parallel to the IBM AIX system Perl installation.</source>
          <target state="translated">-Dprefix 옵션은 IBM AIX 시스템 Perl 설치와 병렬 인 디렉토리에 Perl을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="b25fb323a909fad41c8f87bd91694a424a13934a" translate="yes" xml:space="preserve">
          <source>The -j switch enables parallel testing; the number that follows it is the maximum number of tests to run in parallel. Sometimes tests that pass when run sequentially will fail when run in parallel. For example if two different test scripts use the same temporary file or attempt to listen on the same socket I'll have problems running them in parallel. If I see unexpected failures I need to check my tests to work out which of them are trampling on the same resource and rename temporary files or add locks as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc3be0ef0e3e9886678cc868f1c296c736baaaa" translate="yes" xml:space="preserve">
          <source>The .c files will automatically be included in the list of files deleted by a make clean.</source>
          <target state="translated">.c 파일은 make clean에 의해 삭제 된 파일 목록에 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa1f52ae3c132b312829a1a099fb15cc4451f8a" translate="yes" xml:space="preserve">
          <source>The .i Targets</source>
          <target state="translated">.i 대상</target>
        </trans-unit>
        <trans-unit id="c5957baac4fddeea5c92174eefc52a682210436d" translate="yes" xml:space="preserve">
          <source>The .netrc file contains login and initialization information used by the auto-login process. It resides in the user's home directory. The following tokens are recognized; they may be separated by spaces, tabs, or new-lines:</source>
          <target state="translated">.netrc 파일에는 자동 로그인 프로세스에서 사용하는 로그인 및 초기화 정보가 포함되어 있습니다. 사용자의 홈 디렉토리에 있습니다. 다음 토큰이 인식됩니다. 공백, 탭 또는 줄 바꾸기로 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54f9e8c707fce1b5fb29121fecf5b3c5f6fb75cd" translate="yes" xml:space="preserve">
          <source>The .pm and .xs files contain the meat of the extension. The .xs file holds the C routines that make up the extension. The .pm file contains routines that tell Perl how to load your extension.</source>
          <target state="translated">.pm 및 .xs 파일에는 확장 기능이 포함되어 있습니다. .xs 파일에는 확장명을 구성하는 C 루틴이 있습니다. .pm 파일에는 Perl에게 확장을로드하는 방법을 알려주는 루틴이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2519bf881a43a692b68b1c0e909064ae51fbd0" translate="yes" xml:space="preserve">
          <source>The .pm file originally exported the name &lt;code&gt;TESTVAL&lt;/code&gt; in the &lt;code&gt;@EXPORT&lt;/code&gt; array. This could lead to name clashes. A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the &lt;code&gt;@EXPORT&lt;/code&gt; array. Alternately, if you don't mind using the &quot;fully qualified name&quot; of a variable, you could move most or all of the items from the &lt;code&gt;@EXPORT&lt;/code&gt; array into the &lt;code&gt;@EXPORT_OK&lt;/code&gt; array.</source>
          <target state="translated">.pm 파일은 원래 이름 &lt;code&gt;TESTVAL&lt;/code&gt; 을 내보냈습니다. &lt;code&gt;@EXPORT&lt;/code&gt; 배열 에서 을 . 이것은 이름 충돌로 이어질 수 있습니다. 경험상 #define이 사용자가 아닌 C 루틴 만 사용하는 경우 &lt;code&gt;@EXPORT&lt;/code&gt; 배열 에서 제거해야합니다 . 당신은 변수의 &quot;완전한 이름을&quot;사용 괜찮다면 다른 방법으로, 당신은에서 항목의 대부분 또는 모두 움직일 수 &lt;code&gt;@EXPORT&lt;/code&gt; 의 에 배열을 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2cd74e874774bfc3b88afdad1635f506f150f617" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;&quot;EXAMPLE 4&quot;&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ef13c3a85e7562d01716fd477e5df2797f8e0b" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-4&quot;&gt;예 4&lt;/a&gt; 의 .xs 파일 에는 몇 가지 새로운 요소가 포함되었습니다. 이러한 요소의 의미를 이해하려면 다음 줄에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="9a412534f9637df17d083fc0dd838ed8c9b7cead" translate="yes" xml:space="preserve">
          <source>The /usr/bin/perl is obvious (hopefully).</source>
          <target state="translated">/ usr / bin / perl은 명백합니다 (희망).</target>
        </trans-unit>
        <trans-unit id="ec5eb62e4999d20a060f6b13a5aef679a45b4eda" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;&quot;PadlistNAMES&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90c8fc76aaca137d93e66aec85f8cb2eec3fed5" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;.</source>
          <target state="translated">PADLIST의 0 번째 항목은 어휘에 대한 &quot;이름&quot;또는 &quot;정적 유형 정보&quot;를 나타내는 PADNAMELIST입니다. PADNAMELIST의 개별 요소는 PADNAME입니다. 향후 리팩토링으로 인해 PADNAMELIST가 PADLIST의 배열에 저장되지 않을 수 있으므로 의존하지 마십시오. &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0c98b5db329af061627f1088cd649948958ceb6" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt; . In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="translated">다음에 나오는 각 행의 버킷 수에 해당하는 1 행 또는 2 행의 숫자 &lt;code&gt;SMALLEST&lt;/code&gt; 와 &lt;code&gt;GREATEST&lt;/code&gt; . 첫 번째 행에서 버킷의 크기 (메모리 풋 프린트)는 2의 거듭 제곱이거나 가능하면 1 페이지 더 큽니다. 두 번째 행에서, 존재하는 경우, 버킷의 메모리 풋 프린트는 &quot;위&quot;의 두 버킷의 메모리 풋 프린트 사이에있다.</target>
        </trans-unit>
        <trans-unit id="2d14fecd7b938aa9c4e943161fbc2d01a94612f1" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt;. In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474f74fc74e6b97d1b22c49840ad80fdd2b7a470" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt; ) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) thereafter.</source>
          <target state="translated">1 인수의 캐쉬 아웃 형식은 쓰기 위해 파일을 엽니 다 ( &lt;code&gt;'&amp;gt;'&lt;/code&gt; 처음 사용할 '&amp;gt;' ) 하고 그 후에 ( &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; )를 추가 .</target>
        </trans-unit>
        <trans-unit id="4ff6ad6db51d63412b617f745958fc59e4fe98c5" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt;) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt;) thereafter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece20b2e43644dc279ab7b6d2adb512919e3c93c" translate="yes" xml:space="preserve">
          <source>The 13 variant characters</source>
          <target state="translated">13 개의 변형 문자</target>
        </trans-unit>
        <trans-unit id="a9393cb211cfe66570248ab99ec7632708f22fae" translate="yes" xml:space="preserve">
          <source>The 1st column is the op's sequence number, starting at 1, and is displayed in base 36 by default. Here they're purely linear; the sequences are very helpful when looking at code with loops and branches.</source>
          <target state="translated">첫 번째 열은 1부터 시작하여 op의 시퀀스 번호이며 기본적으로 기수 36에 표시됩니다. 여기는 순전히 선형입니다. 시퀀스는 루프와 분기가있는 코드를 볼 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="004f29b5a23df31b01d8aa7e1fc9952890ebb7d2" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="translated">2 인수 캐쉬 아웃 형식은 초기 및 후속 오프닝에 제공된 모드를 사용합니다. 3 인수 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 대한 대부분의 유효한 모드 가 지원됩니다. &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; 및 &lt;code&gt; '-|' &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="121cd9829212f2f550e8dcc8a4cb650149b4b147" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;open&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt;, &lt;code&gt;'+&amp;gt;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;+'&lt;/code&gt;, &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt;, &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ff8f169a4e9a0d5e765f1f57d4ab8242fb17bb" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="translated">256 색 제어 시퀀스는 &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html(256&lt;/a&gt; 색 검색)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6fefbc384a8139a82e087bfa8ca02dafb3d60bc" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55485ffff099decf688573c56761765b3767694a" translate="yes" xml:space="preserve">
          <source>The 7 bit version switches character set via escape sequence so it cannot form a CCS. Since this is more difficult to handle in programs than the 8 bit version, the 7 bit version is not very popular except for iso-2022-jp, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9651fbba2c1758272669624f504505a7394156" translate="yes" xml:space="preserve">
          <source>The 8 bit version can form a CCS. EUC and ISO-8859 are two examples thereof. Pre-5.6 perl could use them as string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d64a8cbca0fac7db1be3c3a959838f4d376e652" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It is a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81b42d9c2528e2e2cc53554ea82b10b2357c0c7" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It it a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="translated">: browse 태그는 : default 이후의 다음 단계를 나타냅니다. 그것은 : default ops의 상위 집합이며 : filesys_read : sys_db를 추가합니다. 스크립트가 시스템에 대한 더 많은 (아마도 민감한) 정보에 액세스 할 수 있지만 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="913829e3b140a41628c9596982f027a8f2285b7a" translate="yes" xml:space="preserve">
          <source>The :locale sub-pragma</source>
          <target state="translated">: locale 하위 pragma</target>
        </trans-unit>
        <trans-unit id="37c60296990ea34e90b8a450eb79515589ce29e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-%28Logical-characters%29&quot;&gt;&quot;Extended Grapheme Clusters (Logical characters)&quot;&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt;. It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;https://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85820f28213c3599595658668ce44deb0578d4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Extended Grapheme Clusters (Logical characters)&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="translated">위의 &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;확장 그래프 클러스터 (논리 문자)&lt;/a&gt; 섹션에서는 정식 분해에 대해 설명했습니다. 그러나 더 많은 문자가 다른 유형의 분해, &quot;호환 가능&quot;또는 &quot;비정규&quot;분해를가집니다. 이러한 분해를 형성하는 시퀀스는 사전 구성된 문자와 정식으로 동등한 것으로 간주되지 않습니다. 예를 들면 &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; 입니다. 보통 숫자 1과 다소 비슷하지만 정확히는 아닙니다. 숫자 1 로의 분해는 &quot;호환성&quot;분해, 특히 &quot;슈퍼&quot;분해로 불린다. 이러한 호환성 분해에는 여러 가지가 있습니다 ( &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44 참조)&lt;/a&gt; &quot;compat&quot;라는 이름을 포함하여 &quot;compat&quot; ).유니 코드가 선택한 다른 분해 범주에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f116e91479173f83f0ee6321a3113bbe8db276b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">&lt;a href=&quot;#crypt&quot;&gt;토굴&lt;/a&gt; 기능을 사용하면 정보 등을 얻을 수 없기 때문에없는 이상 모든 대량의 데이터를 해싱에 적합하다. 보다 강력한 알고리즘 은 &lt;a href=&quot;digest&quot;&gt;다이제스트&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58fb9e5b9c576e1ea7f2599e64e16265a4b03e77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d7d18b809428abc8ce2a93a95e7422c9de3745" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; function executes a system command</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
