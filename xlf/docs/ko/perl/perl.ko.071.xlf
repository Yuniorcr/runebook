<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;@message&lt;/code&gt; 로 경고 하지만 원래 테스트 함수가 호출 된 시점 ( &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ) 에서 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d24c39aea457b02505102a29c905de4cac82e99" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27a6644654593ac9e5d122b1155ff23752c8073" translate="yes" xml:space="preserve">
          <source>Washington</source>
          <target state="translated">Washington</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">웨인 톰슨</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">우리는 가장 최근의 두 가지 안정적인 릴리스 시리즈를 &quot;공식적으로&quot;지원합니다. 5.16.x 및 이전 버전은 현재 지원되지 않습니다. 5.22.0 릴리스부터는 아래에 설명 된대로 보안 업데이트를 제공하는 것 외에 Perl 5.18.x에 대한 &quot;공식적으로&quot;지원을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="6d4d00accf40364d9a03449bdf5ad7e154d1f316" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.26.x and earlier are now out of support. As of the release of 5.32.0, we will &quot;officially&quot; end support for Perl 5.28.x, other than providing security updates as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">우리는 이미 특별한 &lt;code&gt;@ISA&lt;/code&gt; 배열과 &lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; pragma에 대해 이야기했습니다 .</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">또한이 방법을 사용하여 모듈의 버전이 충분한 지 확인하는 것이 좋습니다. 내부 구현은 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈을 사용하여 여러 유형의 버전 번호가 올바르게 비교되도록합니다.</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">우리는 정규 표현식이 끝났으므로 끝났습니다! 문자열 &quot;abcde&quot;에서 'abcd'를 일치 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">끝났습니다!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">이 함수에서는 &lt;code&gt;hv_store&lt;/code&gt; 를 사용하여 키 아래에 새 스칼라를 저장하는 해시 작업을 하나만 수행합니다 . 해시는 HV * 포인터로 표시됩니다. 배열과 마찬가지로 XSUB에서 해시를 조작하는 기능은 Perl에서 사용할 수있는 기능을 미러링합니다. 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 및 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6308f6a80327169a668ffa81bc777a5db0a8f1" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt;. A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d6aa4a367d4b3962d66c4c93f795d417974b93" translate="yes" xml:space="preserve">
          <source>We are used to using the term (character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">우리는 반환 된 것에 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">우리는 매개 변수를 전달하지 않습니다</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">GNU make를 사용하여 perl을 빌드합니다. 우리는 네이티브 메이크를 한 번 시도해 보았습니다.</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">현재 영업 이익은 항상에 저장됩니다 우리는 또한이 조작을 덤프 할 수 &lt;code&gt;PL_op&lt;/code&gt; , 우리는 그것을 덤프 할 수 &lt;code&gt;Perl_op_dump&lt;/code&gt; . 이것은 우리에게 &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; 와 비슷한 결과를 줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6a951916387170e99fc981f4b1d58e4dc7bd8c60" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt;, and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt;. This'll give us similar output to CPAN module B::Debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">우리는 또한 사용할 수 있습니다 &lt;code&gt;@&lt;/code&gt; 0은 마지막 때 우리가 있었던 위치 인 상태, 오프셋 (offset)로 이동 &lt;code&gt;(&lt;/code&gt; 발생했습니다 :</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">또한 변수를 사용하여 객체로 축복받는 데이터 구조에 대한 참조를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 사용할 수도 있습니다 . 이 예에서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 의 검색 목록 에는 아무것도 포함되어 있지 않지만 &lt;code&gt;c&lt;/code&gt; 옵션은이를 보완하여 모든 것을 포함합니다. 대체 목록에는 아무 것도 포함되어 있지 않으므로 음역은 대체 작업을 수행하지 않기 때문에 거의 작동하지 않습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 옵션은 문자열에서 복제되고 연속 된 문자를 스쿼시하므로 문자가 옆에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bc5ebb55ff053059629cd57779115c15a2ccce5" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;tr///&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;tr///&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;s&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5deb5cdcf6e21e86d4cfa078a33ffd7c085ef4" translate="yes" xml:space="preserve">
          <source>We can ask autodie to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbd56817858a9e2d4db427c7f1f11d2cf2d4b00" translate="yes" xml:space="preserve">
          <source>We can combine the last 3 lines of the above like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">우리는 주장과 부정을 모두 사용하여 이것을 다룰 수 있습니다. 우리는 $ 1의 첫 부분 다음에 숫자와 &quot;123&quot;이 아닌 것을 따라야한다고 말할 것입니다. 미리보기는 너비가 0 인 표현입니다. 단지보기 만하고 일치하는 문자열을 사용하지는 않습니다. 따라서이 방식으로 다시 작성하면 예상 한 결과를 얻을 수 있습니다. 즉, 사례 5는 실패하지만 사례 6은 성공합니다.</target>
        </trans-unit>
        <trans-unit id="337b65de98d527cb6d5b86fba92bc577466c5413" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in &lt;code&gt;$1&lt;/code&gt; must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">위의 예를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">우리는 다른 방법으로 &lt;code&gt;@_&lt;/code&gt; 도 조작 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">다른 문자 스트링을 &lt;b&gt;대체&lt;/b&gt; 메타 문자 &lt;code&gt;'|'&lt;/code&gt; 와 일치시킬 수 있습니다 . 일치시키기 &lt;code&gt;dog&lt;/code&gt; 또는 &lt;code&gt;cat&lt;/code&gt; , 우리는 정규식 형성 &lt;code&gt;dog|cat&lt;/code&gt; . 이전과 마찬가지로 Perl은 문자열에서 가능한 한 빨리 정규식을 일치 시키려고 시도합니다. 각 캐릭터 위치에서 Perl은 먼저 첫 번째 대안 인 &lt;code&gt;dog&lt;/code&gt; 를 일치 시키려고 시도합니다 . 경우 &lt;code&gt;dog&lt;/code&gt; 일치하지 않는, 펄는 다음 대안을 다할 것입니다 &lt;code&gt;cat&lt;/code&gt; . 경우 &lt;code&gt;cat&lt;/code&gt; 중 하나와 일치하지 않는, 다음 경기는 실패하고 펄은 문자열의 다음 위치로 이동합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="d6a0febb21ee098abccab9c8a03b765fef08617d" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt;. To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt;, we form the regex &lt;code&gt;dog|cat&lt;/code&gt;. As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt;. If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt;. If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">욕심없는 정량자를 고려하여 위의 원칙 3을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">이제 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 를 사용 하여 SV를 조사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">자식 클래스에서 부모의 메서드를 재정의 할 수 있습니다. 그렇게해도 &lt;code&gt;SUPER&lt;/code&gt; 의사 클래스를 사용하여 부모 클래스의 메서드를 계속 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">콜론으로 시작하는 모든 줄에 또 다른 중단 점을 둘 수 있습니다. 우리는 서브 루틴에서 나오는 것처럼 17 번 줄을 사용하고 나중에 멈추고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">전역 파일 &lt;code&gt;$STR&lt;/code&gt; 변수를 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; 변수 에 할당하여 펄이 작업을 최적화하여 작업을 최적화하려고 시도하는 것을 피할 수 있도록 테스트 파일에 넣을 수 있습니다. 한 번만 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="3216d8a5e6dc84b8bbaa513843a9c89d95b551dc" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;my $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">슬라이스를 통한 루핑의 일부를 줄일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e5d25f7f85d18366ec3d6895017e423d452f3199" translate="yes" xml:space="preserve">
          <source>We can see on line 4 that our token type is &lt;code&gt;ASSIGNOP&lt;/code&gt; (&lt;code&gt;OPERATOR&lt;/code&gt; is a macro, defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1ace8b9cc4168efa6505ff7ef438700e9bd607" translate="yes" xml:space="preserve">
          <source>We cannot predict how long the database ping will take so we use Test::More's like() test to check that the diagnostic string is of the right form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a62faa91fec217313353690ec40805d724e81" translate="yes" xml:space="preserve">
          <source>We check for duplicate entries in the typemap, but do not check for missing &lt;code&gt;TYPEMAP&lt;/code&gt; entries for &lt;code&gt;INPUTMAP&lt;/code&gt; or &lt;code&gt;OUTPUTMAP&lt;/code&gt; entries since these might be hidden in a different typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">그래도 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 블록 에서 더 화려해질 수 있습니다 . 키를 비교하는 대신 키로 값을 계산하고 해당 값을 비교로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bcc7cd7b768900689b6b050ac1c7aac10dad46e" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;sort()&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">두 클래스 모두 &lt;code&gt;Machine&lt;/code&gt; 과 같은 공통 부모로부터 상속받을 수 있지만 모든 머신에 켜기 / 끄기 스위치가있는 것은 아닙니다. &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 라는 부모 클래스를 만들 수 는 있지만 매우 인위적입니다. 라디오와 컴퓨터는이 부모의 전문 분야가 아닙니다. 이 부모는 정말 우스운 창조물입니다.</target>
        </trans-unit>
        <trans-unit id="859c345eb5fe4bc62f73981c70642999b8e4b03c" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt;, but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt;, but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">압축 해제 템플릿 &lt;code&gt;'b12'&lt;/code&gt; 도 사용할 수있었습니다 . 마지막 4 비트는 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">CODE : 지시문이 아닌 PPCODE : 지시문을 사용하여이를 수행합니다. 이것은 &lt;b&gt;xsubpp&lt;/b&gt; 에게 우리가 인수 스택에 넣을 리턴 값을 관리 할 것이라고 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">아직 경험이 많지 않지만 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">패턴을 매치 연산자 (또는 정규 표현식에서 작동하는 다른 것)로 하드 코딩 할 필요가 없습니다. 나중에 사용하기 위해 패턴을 변수에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">인쇄를 직접 호출하는 대신 이것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">코드 동결시 공급 업체가 가장 최근에 지원되는 Perl 릴리스를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt; 를 가지고 평가하여 자신에게 적합한 OO 시스템을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6dd2243ed823c9d407fa450eaf7b53699b60af0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;, &lt;a href=&quot;Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">우리는 따옴표 'tom'=&amp;gt; ​​q (and jerry)를 수정하고 다시 실행합니다. 이번에는 예상 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">우리는 이미 기본 &lt;code&gt;/regexp/&lt;/code&gt; 및 임의의 분리 문자 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; 형태. 바인딩 연산자 &lt;code&gt;=~&lt;/code&gt; 와 부정 &lt;code&gt;!~&lt;/code&gt; 을 사용하여 문자열 일치를 테스트했습니다. 매칭 연산자와 관련하여 우리는 단일 라인 &lt;code&gt;//s&lt;/code&gt; , 다중 라인 &lt;code&gt;//m&lt;/code&gt; , 대소 문자를 구분하지 않는 &lt;code&gt;//i&lt;/code&gt; 및 확장 된 &lt;code&gt;//x&lt;/code&gt; 수정 자에 대해 논의했습니다 . 일치 연산자에 대해 알아야 할 사항이 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec0698febe8baf604343239295eca801edc1950" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;m!regexp!&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;/s&lt;/code&gt;, multi-line &lt;code&gt;/m&lt;/code&gt;, case-insensitive &lt;code&gt;/i&lt;/code&gt; and extended &lt;code&gt;/x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">BS2000 POSIX (아직)에 대해서는 nroff가 없으므로 설명서를 설치하는 동안 오류를 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">&lt;code&gt;PerlIO_puts()&lt;/code&gt; 는 &lt;code&gt;fputs()&lt;/code&gt; 와 반대로 인수가 있고 인수를 동일하게 유지하기 위해 &lt;code&gt;CODE&lt;/code&gt; 섹션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="094b6bf4440df57d740fc419f243cfd8a6cfc13d" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt;, and we want to keep the arguments the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">우리는 가능한 한 VMS 스타일과 Unix 스타일 파일 사양을 모두 Perl에 알리려고 노력했습니다. 명령 행과 스크립트에서 스타일을 사용하거나 둘 다 사용할 수 있지만 단일 파일 스펙 내에서 두 스타일을 결합 할 수는 없습니다. VMS Perl은 CRTL과 거의 같은 방식으로 Unix 경로 이름을 해석합니다 (</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">이 방법은 사용하지 않는 것이 좋습니다. 수행중인 작업을 알고 특히 PREFIX 동작이 필요한 경우에만 사용해야합니다. PREFIX 알고리즘은 복잡하며 시스템 설치 일치에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">가장 간단하고 설치 접두사의 예상 동작과 가장 가까운 install_base 메소드를 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">이 노트가 VMS에서 Perl 스크립트를 작성할 때 혼란과 수면 상실로부터 벗어날 수 있기를 바랍니다. 여기에 표시되어야 할 내용이 누락 된 경우 언제든지 vmsperl@perl.org로 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">--rules에 대한 자체 glob 스타일 패턴 일치를 구현합니다. 지원되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">우리는 우리 자신의 glob-style 패턴 매칭을 구현합니다. 지원하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">우리는 이것으로부터 &lt;code&gt;6&lt;/code&gt; 을 얻을 것이라는 것을 알고 있으므로 서브 루틴을 끝내 봅시다 :</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">우리는 이전에이 코드를 살펴 보았고, &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; 은 두 개의 &lt;code&gt;NV&lt;/code&gt; 를 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 배치 할 것이라고 준비 했습니다.</target>
        </trans-unit>
        <trans-unit id="5ca3334b72be201a6a79c8d27231d9f82fb916a8" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt;s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">바이너리 비 호환성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">이 XSUB에서 여러 배열을 조작합니다. 배열은 AV * 포인터로 내부적으로 표시됩니다. 배열 조작을위한 함수와 매크로는 Perl의 함수와 비슷합니다. &lt;code&gt;av_top_index&lt;/code&gt; 는 $ # array와 같이 AV *에서 가장 높은 인덱스를 반환합니다. &lt;code&gt;av_fetch&lt;/code&gt; 는 인덱스에서 주어진 스칼라 값을 배열에서 가져옵니다. &lt;code&gt;av_push&lt;/code&gt; 는 스칼라 값을 배열의 끝에 푸시하여 필요에 따라 배열을 자동으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">일반적인 대괄호로 된 클래스에서 합법적으로 사용되는 것이이 실험 구조 내에서 불법이 될 수 있도록 변경할 수 있습니다. 예를 들어, 하나의 제안은 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; 에서와 같이 동일한 문자의 인접 사용을 금지하는 것입니다 . 이러한 변경의 동기는 두 번째 &quot;a&quot;가 아무 것도 추가하지 않으므로이 사용법이 오타 일 가능성이 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f8e2edefd5e426a509917090b4bcf0d615987a3" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt;. The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">앞에서 언급 한 대부분의 Perl 객체는 후드 아래에서 해시로 구현됩니다. 캡슐화의 원리는 우리가 이것에 의존해서는 안된다는 것을 알려줍니다. 대신 접근 자 메서드를 사용하여 해당 해시의 데이터에 액세스해야합니다. 아래에서 권장하는 객체 시스템은 모두 접근 자 메서드 생성을 자동화합니다. 그중 하나를 사용하면 해시로 객체에 직접 액세스 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">앞서 여러 상속을 언급했습니다. 다중 상속의 주요 문제점은 메소드 분석이 크게 복잡하다는 것입니다. 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">읽어야 할 금액을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">이제 Perl을 컴파일하고 테스트 스위트를 통해 실행합니다. 우리의 새로운 테스트는 통과합니다!</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">이제 정규 표현식에서 문자 클래스 중에서 선택하는 방법을 알았습니다. 단어 나 문자열 중에서 선택하는 것은 어떻습니까? 이러한 선택은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">우리는 종종 상속 관계를 &lt;b&gt;부모-자식&lt;/b&gt; 또는 &lt;code&gt;superclass/subclass&lt;/code&gt; 관계라고합니다. 때때로 우리는 아이가가 가지고있는 말 &lt;b&gt;입니다-A&lt;/b&gt; 부모 클래스와의 관계.</target>
        </trans-unit>
        <trans-unit id="99514bb04979cf0a47e2cf2b143ea1390fb7e139" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass&lt;/code&gt;/&lt;code&gt;subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">우리는 Perl 자체의 핵심과 함께 배포 된 소프트웨어로 정의 된 Perl 코어가 우리 모두의 공동 프로젝트라는 것을 알고 있습니다. 때때로 스크립트, 모듈 또는 모듈 세트 (이하 간단히 &quot;모듈&quot;이라고 함)는 Perl과 함께 배포되어야하므로 Perl 자체의 올바른 기능에 매우 유용하고 / 또는 필수적으로 입증 될 것입니다. 핵심. 이것은 저자의 명시적인 동의 없이는 절대로 수행되어서는 안되며, 모든 부분에 대한 명확한 인식으로 모듈이 Perl 자체와 동일한 용어로 배포되고 있음을 의미합니다. 모듈 작성자는 모듈을 Perl 코어에 포함 시키면 모듈에 대한 제어력이 상실 될 수 있음을 인식해야합니다. 변경 사항은 짧은 통지로 또는 나머지 Perl과의 일관성을 위해 변경해야 할 수도 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">InfoZIP를 권장합니다 : &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">'-C'옵션을 사용하여 Archive :: Tar 1.66보다 오래된 ptar를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">여러 가지 이유로이 구문을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">우리는 당신만을 액세스를 통해 속성을하는 것이 좋습니다 &lt;b&gt;접근&lt;/b&gt; 방법. 각 속성의 값을 가져 오거나 설정할 수있는 메소드입니다. 앞에서 &lt;code&gt;print_info()&lt;/code&gt; 예제에서 &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; 를 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="3c3f8a0812714182851aed9fbbd140faf18d7041" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;$Package::VERSION&lt;/code&gt; 직접 보지 말고이 방법을 사용하여 다른 패키지 버전에 액세스하는 것이 좋습니다 . 보고있는 패키지가 &lt;code&gt;VERSION&lt;/code&gt; 메서드를 재정의했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6418d5ecc21157f156342ad6f603ad1e78f241b1" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt;. The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">우리는 참조가 정의되지 않은 경우 필요에 따라 참조가 발생한다고 말했지만 참조로 사용 된 값이 이미 정의 된 경우 어떻게되는지 말하지 않았지만</target>
        </trans-unit>
        <trans-unit id="66792931fda90822c58a9263a870978d6e867c09" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;'\'&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;']'&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;'$'&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;'\'&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">우리는 백 슬래시 필요로 자신을 표현 일반 문자와 특수 문자가 있다고 위의 섹션에서 본 &lt;code&gt;\&lt;/code&gt; 자신을 표현하기를. 문자 클래스에서도 마찬가지이지만 문자 클래스 내부의 일반 및 특수 문자 세트는 문자 클래스 외부의 문자와 다릅니다. 문자 클래스의 특수 문자는 &lt;code&gt;-]\^$&lt;/code&gt; (및 패턴 구분 기호는 무엇이든)입니다. &lt;code&gt;]&lt;/code&gt; 는 문자 클래스의 끝을 나타 내기 때문에 특별합니다. &lt;code&gt;$&lt;/code&gt; 는 스칼라 변수를 나타내므로 특별합니다. &lt;code&gt;\&lt;/code&gt; 는 위와 같이 이스케이프 시퀀스에 사용되므로 특별합니다. 특수 문자 &lt;code&gt;]$\&lt;/code&gt; 를 처리 하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">우리의 규범 보았다 &lt;code&gt;z&lt;/code&gt; 관찰되었다 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; 또한 알려진 원점까지의 거리로서 정의 하였다 :</target>
        </trans-unit>
        <trans-unit id="e2c4be4000d0f7dd961c043239fc9f3b3b2b02bf" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;abs(z)&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">아래에 접근 자의 &quot;입력&quot;형식 (예 : 접근자를 특정 값으로 설정하는 데 사용하는 구문)이 표시됩니다. 그러나 매개 변수없이 각 메소드를 호출하여 현재 값을 얻을 수도 있습니다. 예를 들어 &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; 은 contents_file 속성의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">우리는 &lt;code&gt;LocalPort&lt;/code&gt; 인수 에 로컬 포트를 지정했는데 , 클라이언트에서는하지 않았습니다. 서버가 될 서비스 이름 또는 포트 번호입니다. (유닉스에서 1024 미만의 포트는 수퍼 유저로 제한됩니다.)이 샘플에서는 포트 9000을 사용하지만 현재 시스템에서 사용하지 않는 모든 포트를 사용할 수 있습니다. 이미 사용중인 주소를 사용하려고하면 &quot;이미 사용중인 주소&quot;메시지가 나타납니다. 유닉스에서 &lt;code&gt;netstat -a&lt;/code&gt; 명령은 현재 서버에 어떤 서비스가 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; 중에도 여전히 몇 가지 오류가 발생했습니다 . 그들 중 일부는 들소를 사용한 결과입니다. 들소 인쇄</target>
        </trans-unit>
        <trans-unit id="caf05cb06344b1573e32848467a1dff2088a1df3" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt;. Some of them are the result of using bison. Bison prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">우리는 여전히 a2p.y에 일반 yacc를 사용합니다 !!! 두 버전을 구별하기 위해 byacc라는 소프트 링크를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">가능하면 git을 사용하는 것이 좋습니다. 그것은 당신의 삶과 우리의 삶을 더 쉽게 만들어 줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">이러한 시스템 중 하나를 사용하는 것이 좋습니다. 그것들 중 가장 작은 것조차도 많은 반복적 인 상용구를 제거합니다. Perl에서 클래스를 처음부터 새로 작성할 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">우리는이 용어가 너무 많은 것을 의미하기 때문에 피하는 경향이 있습니다. 이는 Perl의 &lt;code&gt;&amp;ndash;n&lt;/code&gt; 및 &lt;code&gt;&amp;ndash;p&lt;/code&gt; 플래그 와 같은 인수 자체 를 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에서 사용되는 &lt;code&gt;O_CREAT&lt;/code&gt; 및 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그 와 같은 단일 비트 표시기를 자주 사용 하지 않는 명령 줄 &lt;b&gt;스위치&lt;/b&gt; 를 의미 할 수 있습니다 . 때때로 특정 정규식 수정자를 지칭하기 위해 비공식적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3626274dd1f26da66510777516b4ddde9437ec" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;sysopen&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">그런 다음 다시 실행하기 전에 구문 검사를 수행합니다 (항상 좋은 생각).</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">&quot;거의&quot;라는 용어를 사용합니다. &lt;code&gt;:not_characters&lt;/code&gt; 도 범위 내에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 를 사용 합니다 . 이 형식은 v5.20 이상에서 유용하지 않으며 &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8로&lt;/a&gt; 완전히 설명되어 있지만 간단히 말해 Perl에 로케일 정의의 문자 부분 ( &lt;code&gt;LC_CTYPE&lt;/code&gt; 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; 범주)을 사용하지 않도록 지시 합니다. 대신 기본 문자 세트 (유니 코드로 확장)를 사용합니다. 이 매개 변수를 사용하는 경우 외부 문자 세트를 원시 / 유니 코드로 변환해야합니다 (이는 점점 인기있는 UTF-8 로케일 중 하나 인 경우에 이미 발생 함). 에 설명 된대로이 작업을 수행하는 편리한 방법이 &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8에&lt;/a&gt;있습니다.</target>
        </trans-unit>
        <trans-unit id="ff19ea46c35bfebd3ad06b673f58043424fd7951" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">'make check'중에 한 번의 실패로 즉시 설치 가능한 버전 1.2.4를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">우리는 잡을 수 있기를 원합니다</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">우리는 Perl이 앞으로 수십 년 동안 계속 성장하고 번창하기를 원하지만 사용자 커뮤니티를 희생 시키지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">우리는 목록 컨텍스트를 원했기 때문에 G_ARRAY가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8da0820534457147c458ba35d650b1d2014dcd98" translate="yes" xml:space="preserve">
          <source>We will accept 1.00 and 1.75 but not 0.50 or 2.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 명령을 통해 테스트 스크립트를 호출 할 것 입니다. 다음과 같은 출력이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bed8e3523336143bfae3d838324a0aad3e70112e" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt;&quot;. You should see output that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">Perl 개발 릴리스에 대한 보안 업데이트 나 버그 수정은 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">이제 최상위 최상위 Mytest2 파일을 만듭니다. Mytest2 위의 디렉토리로 변경하고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">우리는 모두 지난 수십 년 동안 우리가 저지른 실수를 저지르기를 원합니다. 우리가 만든 모든 디자인 오류로 생활하면 고통스런 정체가 발생할 수 있습니다. 우리의 실수를 풀면 매우 어렵습니다. 사용자에게 적극적으로 해를 끼치 지 않고 그렇게하는 것은 거의 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">참조 관리에 대한 구문을 본 후에 나중에이 도시 국가 문제로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="25d0051932de21aa64fc90927fc210fd1faca62f" translate="yes" xml:space="preserve">
          <source>We'll get to testing the contents of lists later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">우리는 Perlish처럼 보이는 변수의 의미를 조금만 알아볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">거기에 다른 문자열 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">먼저 출력을 살펴 보겠습니다. 이 구조가 이미 있다고 가정하면 어떻게 인쇄합니까?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">아래에서 Perl의 매크로를 고려할 때 더 까다로운 예를 볼 수 있습니다. &lt;code&gt;POPn&lt;/code&gt; 은 스택에서 최상위 SV의 NV (부동 소수점 값)를 제공합니다 : &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; . 그런 다음 코사인을 계산하고 결과를 NV로 다시 푸시합니다. &lt;code&gt;XPUSHn&lt;/code&gt; 의 &lt;code&gt;X&lt;/code&gt; 는 필요한 경우 스택을 확장해야 함을 의미합니다. 스택에서 하나 이상의 항목을 넣을 공간이 있다는 것을 알고 있기 때문에 여기서는 필요하지 않습니다. &lt;code&gt;XPUSH*&lt;/code&gt; 최소 보증 안전에 매크로.</target>
        </trans-unit>
        <trans-unit id="56f64cd868fbb648df894ffa687bba0fcd06f58c" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;cos($x)&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">' &lt;b&gt;c&lt;/b&gt; '를 사용하여 미리 설정된 중단 점으로 간단히 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">우리는 여기서 예제를 위해 &lt;code&gt;gdb&lt;/code&gt; 를 사용할 것이다 ; 원칙은 모든 디버거에 적용 되지만 (많은 벤더가 디버거 &lt;code&gt;dbx&lt;/code&gt; 라고 함 ) 사용중인 매뉴얼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="59bfed3e1550313113be0311ae2b9d42ec0cb5e3" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt;), but check the manual of the one you're using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">우리는 Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">우리는 Windows 외에도 Netware입니다.</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">우리는 Unix와 Cygwin입니다.</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">묶음 배열이있을 때 &lt;code&gt;PUSH&lt;/code&gt; 서브 루틴은 객체와 푸시 할 값을 수신합니다. 바로 여기에 &lt;code&gt;SvTIED_obj&lt;/code&gt; 로 검색된 묶인 객체가 있습니다 . 그리고 값, SV &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85ee9a622e2cfbf55a87677c4c0c5ab7baea463" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt;, and the value, the SV &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81984db06bb6ffc7cc8657839e60eed19d2e59d4" translate="yes" xml:space="preserve">
          <source>We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases. Does it work before 1970? After 2038? Before 1904? Do years after 10,000 give it trouble? Does it get leap years right? We could keep repeating the code above, or we could set up a little try/expect loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">여기서는 XS 모듈이 아닌 Perl 전용 모듈에 주로 중점을 둘 것입니다. XS 모듈은 다소 다른 목적을 제공하므로 배포하기 전에 다른 것들을 고려해야합니다. 접착하는 라이브러리의 인기, 다른 운영 체제로의 이식성 등. 그러나 모듈의 Perl 측 준비 및 패키징 및 배포에 대한 참고 사항은 XS 모듈에 순수 Perl 모듈과 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="017f7465d1bdb163c7a89743859d67e419fc8784" translate="yes" xml:space="preserve">
          <source>We've added more detail about what we're testing and the ICal string itself we're trying out to the name. So you get results like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">우리는 이미 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 사용하여 표준 출력으로 인쇄하는 방법을 보았습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 는 인쇄 할 파일 핸들을 지정하는 선택적 첫 번째 인수를 취할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86cb468eaa36ca78f91ded52784d1ac7c3b8af3" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;print()&lt;/code&gt;. However, &lt;code&gt;print()&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">또한 mylib 서브 디렉토리에 빌드 한 라이브러리에 대해 Perl에게 알려주었습니다. 이를 위해서는 &lt;code&gt;MYEXTLIB&lt;/code&gt; 변수를 WriteMakefile 호출에 추가하고 postamble 서브 루틴을 cd로 서브 디렉토리로 바꾸고 make를 실행해야했습니다. 라이브러리의 Makefile.PL은 조금 더 복잡하지만 과도하지는 않습니다. 다시 우리는 postamble 서브 루틴을 교체하여 자체 코드를 삽입했습니다. 이 코드는 여기에서 생성 될 라이브러리가 정적 아카이브 라이브러리 (동적으로로드 가능한 라이브러리가 아닌)임을 지정하고이를 빌드하기위한 명령을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">우리는 Perl의 스레딩 패키지의 핵심 부분을 다루었으며 이러한 도구를 사용하면 스레드 코드와 패키지를 작성하는 데 도움이 될 것입니다. 다른 곳에는 맞지 않는 몇 가지 유용한 작은 조각이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">우리는 수표 ( 'All OK'가 인쇄 된 곳)를지나 작업의 바로 직전에 멈췄습니다. 우리는 무슨 일이 일어나고 있는지 확인하기 위해 몇 가지 변수를 인쇄하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">우리는 Larry의 h2ph 번역기를 사용했지만 실제로 C가 아닌 cpp 심볼에서만 작동합니다. 내가 당신에게 제공하는 것은 모든 C 구조를 얻는 상징적 방법입니다. 나는 패키지와 기능면에서 그것들을 꾸 couch 다. 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">Makefile.PL을 일부 변경했습니다. 이 경우 확장의 공유 라이브러리 (이 경우 math 라이브러리 libm)에 링크 할 추가 라이브러리를 지정했습니다. 라이브러리의 모든 루틴을 호출 할 수있는 XSUB를 작성하는 방법에 대해서는 나중에 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">&lt;b&gt;strict&lt;/b&gt; 및 &lt;b&gt;-w&lt;/b&gt; 를 &lt;b&gt;사용&lt;/b&gt; 하여 올바른 코딩 방법을 권장하는 방법을 살펴 보았습니다 . perl 디버거 &lt;b&gt;perl -d 스크립트 이름&lt;/b&gt; 을 실행하여 &lt;b&gt;p&lt;/b&gt; 및 &lt;b&gt;x&lt;/b&gt; 명령을 사용 하여 perl 디버거 내에서 데이터를 검사 할 수 있습니다 . 코드를 살펴보고 &lt;b&gt;b로&lt;/b&gt; 중단 점을 설정 하고 &lt;b&gt;s&lt;/b&gt; 또는 &lt;b&gt;n을&lt;/b&gt; 사용하여 해당 코드를 단계별로 진행할 수 있습니다.&lt;b&gt;&lt;/b&gt; 진행할 수 있습니다.&lt;b&gt; c를&lt;/b&gt; 하고 &lt;b&gt;r&lt;/b&gt; 을 사용하여 하위에서 돌아올 수 있습니다 . 당신이 그것을 얻을 때 상당히 직관적 인 물건.</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">프레임 버퍼의 내용과 일치하도록 템플릿을 구성하는 데 어려움을 겪었습니다. 그렇지 않으면 우리는 정의되지 않은 값을 얻거나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 수 없습니다. 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 항목이 부족, 그것은 (팩 코드는 이렇게 말한다 때마다 제로를 강요하는) 널 (null) 문자열을 공급한다.</target>
        </trans-unit>
        <trans-unit id="f58946de758298d15363eecb7f69802745a7c62d" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;unpack&lt;/code&gt; could not unpack all. If &lt;code&gt;pack&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">우리는 이것을 TODO : 구문과 함께 작동 시키려고 노력했지만 보장되지는 않으며 사용도 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">우리는 유닉스 구문에 대한 Perl 라이브러리 모듈의 의존성을 최소화하려고 노력했지만 유닉스 시스템 용으로 작성된 일부 스크립트뿐만 아니라 이들 중 일부는 유닉스 구문을 사용해야 할 것입니다. '는 디렉토리 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">각 행의 필드를 쉽게 처리하기 위해 해시 슬라이스를 사용했습니다. 배열에 키를 저장하면 그룹으로 쉽게 조작하거나 &lt;code&gt;for&lt;/code&gt; 를 사용하여 반복 할 수 있습니다 . 또한 전역 변수를 사용하고 기호 참조를 사용하여 프로그램을 오염시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf3e9bec5bbd0148b6e7d79050e64cd6c33fa0da" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt;. It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3244b33262d5fd2e0388c2e8910db847842e8800" translate="yes" xml:space="preserve">
          <source>Weak references are not implemented in the version of perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">참조를 약화 : 이 RV에 &lt;code&gt;SvWEAKREF&lt;/code&gt; 플래그를 설정하십시오 . 참조 된 SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; 매직이 아직 없다면 마법을줍니다. 이 RV에 대한 역 참조를 해당 마술과 관련된 역 참조 배열로 푸시합니다. RV가 마법 인 경우 RV가 해제 된 후에 설정된 마법이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b546f1ca2e1f3276683dab2157d9406b01bfa5c" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on already-weak references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">약한 사람들은 uvar 마술을 부릅니다</target>
        </trans-unit>
        <trans-unit id="d99719368087fdb5886c0da04e1ec7aa5bb1e097" translate="yes" xml:space="preserve">
          <source>Web::Simple</source>
          <target state="translated">Web::Simple</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">지원되지 않는 인수를 제거하고 사용자에게 경고</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">주 번호</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">CJK 통합 표의 문자 가중치</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">JIS KANJI for Unicode :: Collate에 가중치 부여</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">데이터 정렬 요소 테이블에 따라 가중치가 달라질 수 있습니다. 그래서에 정의 된 가중치 보장 &lt;code&gt;entry&lt;/code&gt; 통해로드 된 조합 요소 테이블에있는 것과 일치 할 것이다 &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782d47b6879e710497644ef8bf508107805123e1" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">역순의 가중치; 전의. 프랑스어 수준 2 (분음 부호 순서) 생략하면 (또는 &lt;code&gt;$levelNumber&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이거나 &lt;code&gt;\@levelNumbers&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; ) 모든 레벨에서 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="07918c7bf0f5c02def4accb22b2496ee08472e26" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;), forwards at all the levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfee8775f2eb957a8724a08c2efd8dbdd2166cc" translate="yes" xml:space="preserve">
          <source>Well it may seem that way, but it does not. The verify method returns true if the command succeeded. If you pass verify an address which the server would normally have to forward to another machine, the command will succeed with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">음, 떨어져 베어에서 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , 당신은 특별히 그들을 치료하지 않아야합니다. (그렇지 않으면 Perl이 Win32 시스템에서 줄 끝을 변환 할 수 있기 때문에 binmode가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="48bbf4d297e0c1ca5f48035948fb4a98aa2511d6" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;binmode $fh&lt;/code&gt;, you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">글쎄, 같은 거대한 라이브러리에 동적으로 연결된 여러 실행 파일을 갖는 이점이 있지만 컴파일을 위해 추가 작업을 입증하지는 않습니다. 그 이유는 개발자에게는 복잡하지만 OS / 2에서 사용하는 매우 빠르고 사용자에게는 &quot;하드&quot;동적 연결이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">가능하다면 가장 최신이지만 확실히 &lt;code&gt;5.8.1&lt;/code&gt; 이상으로 업그레이드하십시오 . 학습서 및 FAQ는 최신 릴리스를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">아마 아닐 수도 있습니다. 어쨌든, 각 op에는 실제로 작업을 수행 할 함수를 규정하는 함수 포인터가 있습니다. 이 같은 일이 가능 -이 기능은 순서대로 다음 연산을 반환 &lt;code&gt;if&lt;/code&gt; 런타임에 동적으로 다음 연산을 선택한다. &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; 필요한 경우 신호 같은 것들을 실행을 중단 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d89d9b138049ae3cace1b14aa62a037a00f5fd6b" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">글쎄, 오늘날 Perl DLL은 다르게 컴파일 된 프로그램에서도 사용할 수 있어야합니다 ... REXX 스크립트에서 Perl 코드를 실행할 수 있다면 ( &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; 참조 ) 현재 해시 코드가 간과하는 상호 작용의 다른 측면이 있습니다 다르게 컴파일 된 주요 프로그램을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">글쎄, 사실 C의 배열과 완전히 같지는 않습니다. C는 필요에 따라 배열을 확장하는 방법을 모릅니다. 펄은 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">글쎄, 그건</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">글쎄, 하나의 명령을 보내고 하나의 답변을 원한다면 그것은 괜찮습니다.하지만 완전히 대화식으로 무언가를 설정하는 것은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">글쎄, 그 이유는 인접한 대괄호에서만 (사각형이든 곱슬이든) 포인터 참조 화살표를 생략 할 수 있기 때문입니다. 그러나 참조를 포함하는 스칼라 인 경우 첫 번째 경우에는 그렇게 할 수 없으므로 $ ref_to_AoA는 항상 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">글쎄, 이것은 읽기가 쉽지 않으며 유용한 설명서 ( &lt;b&gt;hh&lt;/b&gt; )를 사용하면 ' &lt;b&gt;x&lt;/b&gt; '명령이 유망 해 보입니다.</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">글쎄, 당신은 그것들을 동기화시킬 수는 있지만, 다른 사람이 작성한 수업을 항상 유지할 것이라는 보장은 없습니다. 게다가, 직렬화 후크는 객체의 속성 하나만 유지할 수 있으며, 이는 동일한 객체를 심도있게 복제하는 동안 발생하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">어쨌든 유니 코드 란 무엇인가?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">무엇 &lt;b&gt;입니다&lt;/b&gt; 어쨌든, 유니 코드?</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">무엇을 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 수행</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">무엇 &lt;code&gt;\n&lt;/code&gt; 대표하는 열려있는 파일의 종류에 따라 다릅니다. 일반적으로 &lt;code&gt;\012&lt;/code&gt; 나타내지 만 파일 구성 및 레코드 형식에 따라 &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; 일 수도 있고 아무것도 아닐 수도 있습니다 . &lt;code&gt;VMS::Stdio&lt;/code&gt; 모듈은 특별한에 대한 액세스 제공 &lt;code&gt;fopen()&lt;/code&gt; VMS에 특별한 속성을 가진 파일의 요구 사항.</target>
        </trans-unit>
        <trans-unit id="87fe5c683c90e3c088c772e3615a1786c72c1f86" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, &lt;code&gt;\015\012&lt;/code&gt;, &lt;code&gt;\000&lt;/code&gt;, &lt;code&gt;\040&lt;/code&gt;, or nothing depending on the file organization and record format. The &lt;a href=&quot;VMS::Stdio&quot;&gt;&lt;code&gt;VMS::Stdio&lt;/code&gt;&lt;/a&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">어떤 &lt;code&gt;\p{Digit}&lt;/code&gt; (따라서 수단 &lt;code&gt;\d&lt;/code&gt; 언더 제외 &lt;code&gt;/a&lt;/code&gt; 수정하는)이다 &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; 또는 동의어, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . 유니 코드 버전 4.1부터는 &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; 과 동일한 문자 세트입니다 . 그러나 유니 코드에는 이름이 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 인 비슷한 속성이 있으며 완전히 다른 문자 집합과 일치합니다. 이 문자는 &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; 또는 아래 첨자 와 같은 문자 이거나 10 자리가 모두없는 필기 시스템의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="7b5cbb478fdd2453286ebc21496037447f26240f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt;, or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt;. Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt;. But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b14251f22912eca5254f7b79c2a9d632504f9a" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;import&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d8154ba31035b162983151d8a78e2e2dc45b35" translate="yes" xml:space="preserve">
          <source>What Compression Types do IO::Compress::Zip &amp;amp; IO::Uncompress::Unzip support?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">어쨌든 스레드는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">수출하지 않을 것</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">어떤 스레드에 있습니까?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">어떤 스레드가 실행되고 있습니까?</target>
        </trans-unit>
        <trans-unit id="39c91a7f2718b3f82718fcf2f41024f714a5a84f" translate="yes" xml:space="preserve">
          <source>What Unix would call a &quot;character special file&quot;, that is, a device that works on character streams such as a printer port or a console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신이 보는 것은 당신이 얻는 것입니다. 일반적으로 화면에 나타나는 것이 Perl의 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 선언 과 같이 결과와 일치 할 때 사용됩니다 . 또한 3 개의 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서와 같이 모든 것이 표시된대로 정확하게 작동하기 때문에 마법의 반대를 의미하는 데에도 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="ed80ac1751c25893f1267129f7e46c8160dfe9c8" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">무언가를 기다려야 할 때 &lt;b&gt;프로세스&lt;/b&gt; 가 수행 하는 &lt;b&gt;작업&lt;/b&gt; : &quot;내 프로세스가 디스크 대기를 차단했습니다.&quot; 관련이없는 명사로서, &lt;b&gt;운영 체제&lt;/b&gt; 보다 크기가 큰 데이터 청크를 나타냅니다.&lt;b&gt;&lt;/b&gt; 가 처리하기 (대개 512 또는 8192와 같은 2의 거듭 제곱) 인 . 일반적으로 디스크 파일에서 가져 오거나 디스크 파일로 이동하는 데이터 청크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2467e6e88d448cacf4a87d364e42c63b7d44c7b4" translate="yes" xml:space="preserve">
          <source>What a Unicode property matches is never subject to locale rules, and if locale rules are not otherwise in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 를 구현하기 위해 앞서 살펴본 함수 인 &lt;code&gt;pp_add&lt;/code&gt; 는 어떻습니까 ? 연산자</target>
        </trans-unit>
        <trans-unit id="4f1dc37cecc054d5c9ec7a5642d37fabf7ece164" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt;, the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">이미지와 같은 이진 데이터는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">읽기-쓰기 모드는 어떻습니까? 텍스트 파일을 읽기 / 쓰기 모드로 여는 것이 원하는 작업을 수행 할 가능성이 없기 때문에 존재하지 않는 척해야합니다. 자세한 내용은 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">무엇에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 프라그?</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">[정보] 무엇 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 프라그?</target>
        </trans-unit>
        <trans-unit id="7033c56c28fec8ae85e45a62981e3d9e75105d87" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use bytes&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1190a2bf44048aa0cb955f799592720f84eed32" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use encoding&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">사용 바이트 pragma는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">사용 인코딩 pragma는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="9087ece8c32ed3f277ff1480139f31375b459572" translate="yes" xml:space="preserve">
          <source>What about v-strings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;decode_utf8&lt;/code&gt; 과 &lt;code&gt;encode_utf8&lt;/code&gt; 은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="eb35e14132d10d4b0ffea38066499e7c90c13f72" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">Perl 4, Perl 5 또는 Perl 6은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e6127384bd4c0a0328dc9c0ebe31629d55231702" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">이 $ @ % &amp;amp; * 문장 부호는 무엇이며 언제 사용해야하는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">decode_utf8과 encode_utf8은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="29ffaa3b6cfc90d26e4503a77c7175830b80edb8" translate="yes" xml:space="preserve">
          <source>What are hints?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9717f99f8d2c332a1631b34f3cf973229add73" translate="yes" xml:space="preserve">
          <source>What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">참조가 있으면 무엇을 할 수 있습니까? 스칼라 값이므로 스칼라로 저장하고 스칼라처럼 다시 가져올 수 있음을 알았습니다. 그것을 사용하는 두 가지 방법이 더 있습니다 :</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Perl은 어떤 문자 인코딩을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="b31fdc311186d7b04a093fc56872b567ad32984f" translate="yes" xml:space="preserve">
          <source>What distribution contains a particular module?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7467059fbc01c8f7e5073d6a60b1174890e226" translate="yes" xml:space="preserve">
          <source>What do you do with unsupported filetypes in an archive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">정말로 무엇을 알고 싶습니까? 파일 핸들 중 하나가 터미널에 연결되어 있는지 여부 만 알고 싶다면 &lt;code&gt;-t&lt;/code&gt; 파일 테스트를 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">당신은 &lt;code&gt;$x&lt;/code&gt; 가 무엇이라고 생각 합니까? 불행히도 그 대답은</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">&quot;Bareword 'DB_File'not allowed&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">&quot;잘못된 인수&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">&quot;나쁜 통역사&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="128188e5871787fd7e8d0d232b299acadbde54ca" translate="yes" xml:space="preserve">
          <source>What does &quot;wide character in subroutine entry&quot; mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">정규 표현식이 탐욕 스럽다는 것은 무엇을 의미합니까? 어떻게 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">정규 표현식에 이것이 무엇을 의미합니까? 정규 표현식 사용자는 Perl의 내부 문자열 표현에 대해 많이 알 필요가 없습니다. 그러나 그들은 1) 정규 표현식에서 유니 코드 문자를 표현하는 방법과 2) 일치하는 작업이 문자열이 바이트가 아닌 일련의 문자로 처리된다는 것을 알아야합니다. 1)에 대한 대답은 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; 보다 큰 유니 코드 문자 는 &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; 표기법을 사용하여 표현 된다는 것입니다 . 왜냐하면 중괄호없이 \ x hex는 255를 넘지 않기 때문입니다 (Perl 5.14에서 시작) 8 진 팬이라면 &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; 사용할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="975aae02ca21ed8ec96fd5f4735831339586ec7e" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;chr(255)&lt;/code&gt; are represented using the &lt;code&gt;\x{hex}&lt;/code&gt; notation, because &lt;code&gt;\x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fa5db720a03edc1fcba3370635f4d2d4adabe0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;&quot;PERLIO&quot; in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">이 기본 스택에있는 정확한 계층은 운영 체제, Perl 버전, Perl 컴파일 시간 구성 및 Perl 런타임 구성 등 많은 요소에 따라 다릅니다. 참조 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO&lt;/a&gt; , &lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrun에서은 PerlIO을&lt;/a&gt; 하고, &lt;a href=&quot;open&quot;&gt;개방형&lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">다음은 Perl 정규식의 고급 기능, 덜 사용 된 기능 또는 난해한 기능입니다. Part 2에서는 기본 사항에 익숙하고 고급 기능에 집중한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">다음은이 단계를 통한 자세한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">다음은 패키지 제작자가 코드의 미래를 인도하고 작업에 대한 통제력을 유지할 수있는 능력으로 정의 된 예술적 통제에 대한 진술입니다. 저자가 자신의 작업을 통제해야한다는 것은 인정이며,이 통제를 유지하는 것은 Perl 커뮤니티의 나머지 책임입니다. 이는 Perl 개발자로서 우리가 보유하고자하는 표준을 문서화하려는 시도입니다. 우리가 Perl 개발자로서 서로에게 빚진 존중에 대한 대략적인 지침을 작성하려는 시도입니다.</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">다음은 RSN 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">양식 피드로 출력되는 형식 기본값은 &lt;code&gt;\f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7f6f4d84ea57e45f2ca17815f8c029206bd9132" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">반환되는 내용은 몇 가지 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">정규 표현식에서 &lt;code&gt;\G&lt;/code&gt; 는 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">정규 표현식에서 \ G는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">반복하는 동안 해시에서 키를 추가하거나 제거하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="ff08f48f056287d25a3dc5672938a653f78c0ce3" translate="yes" xml:space="preserve">
          <source>What happens is that after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630083c407aaeb1fdb11b2f5b1e425a9f1a5879d" translate="yes" xml:space="preserve">
          <source>What happens when &lt;code&gt;JSON::PP&lt;/code&gt; encounters a Perl object depends on the &lt;code&gt;allow_blessed&lt;/code&gt;, &lt;code&gt;convert_blessed&lt;/code&gt;, &lt;code&gt;allow_tags&lt;/code&gt; and &lt;code&gt;allow_bignum&lt;/code&gt; settings, which are used in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">여기서 무슨 일이 있었습니까?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">무슨 일이 있었는지 &lt;code&gt;fred&lt;/code&gt; 는 &lt;code&gt;joe&lt;/code&gt; 에 속하는 &lt;code&gt;@_&lt;/code&gt; 배열에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="4495f64a5a5a99cc3a0b71199a99723a37e9ed87" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">디코딩하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">인코딩하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">어떤 인코딩이 사용되었는지 모르면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">FAQ에 내 질문에 대한 답변이 없으면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">C 콜백이 제공하는 인터페이스에 파일 핸들을 Perl 서브 루틴 맵핑에 허용하는 매개 변수가 없으면 어떻게됩니까? 비동기 I / O 패키지에서 콜백 함수는 다음 과 같은 &lt;code&gt;buffer&lt;/code&gt; 매개 변수 만 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">수입품</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">&quot;UTF8 플래그&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">/ o 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">&lt;code&gt;/o&lt;/code&gt; 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">C3 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3f1ecd4984feb033599a0b8b92a1a9741f5b5e8e" translate="yes" xml:space="preserve">
          <source>What is Module::Build and how does it relate to MakeMaker?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">Perl 6이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">펄이란?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">Plack과 PSGI는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="234e64d864b7e4e19b7d995b815d4db958366917" translate="yes" xml:space="preserve">
          <source>What is Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c878af8c7031f81a5ddca206fc60a5a12f9ad1d" translate="yes" xml:space="preserve">
          <source>What is Unicode, anyway?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">&quot;와이드 캐릭터&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">'레코드'란 무엇입니까? 기본적으로, 그 의미는 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 연산자 와 동일합니다 : &lt;code&gt;$/&lt;/code&gt; 끝나는 문자열 입니다. 아마도 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 입니다. (사소한 예외 : DOS 및 Win32 시스템에서 'record'는 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 끝나는 문자열 입니다.) &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call 에 &lt;code&gt;recsep&lt;/code&gt; 옵션 을 제공하여 &quot;record&quot;의 정의를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046dcad9c1b5d6658ae493e5f69f47ba914f7843" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt;, which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;.) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;tie&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">DBM 필터 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">JAPH 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">정규식 엔진이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">정규식이란 무엇입니까? 정규식은 단순히 패턴을 설명하는 문자열입니다. 요즘 패턴은 일반적으로 사용됩니다. 예는 &lt;code&gt;ls *.txt&lt;/code&gt; 또는 &lt;code&gt;dir *.*&lt;/code&gt; 와 같이 웹 페이지를 찾기 위해 검색 엔진에 입력 된 패턴과 디렉토리에 파일을 나열하는 데 사용되는 패턴 입니다. Perl에서 정규식으로 설명 된 패턴은 문자열을 검색하고 원하는 문자열 부분을 추출하며 검색 및 바꾸기 작업을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad1619062d7422922f56678f7cf58c8d2f19d36b" translate="yes" xml:space="preserve">
          <source>What is a regular expression? At its most basic, a regular expression is a template that is used to determine if a string has certain characteristics. The string is most often some text, such as a line, sentence, web page, or even a whole book, but less commonly it could be some binary data as well. Suppose we want to determine if the text in variable, &lt;code&gt;$var&lt;/code&gt; contains the sequence of characters &lt;code&gt;m u s h r o o m&lt;/code&gt; (blanks added for legibility). We can write in Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">&quot;IV&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="778b266015494167ffcfb5699798ca074f01e4ed" translate="yes" xml:space="preserve">
          <source>What is libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">여기서 의미하는 것은 &lt;code&gt;\N{...}&lt;/code&gt; 이스케이프가 일련의 코드 포인트이므로 명확하지 않으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">더 나쁜 것은, 일부 DLL은 _DLLInitTerm ()에있을 때 부동 소수점 플래그를 변경하는 것입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">Perl.com은 무엇입니까? 펄 몽 거스? pm.org? perl.org? cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">Socket.ph 란 무엇이며 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">&quot;state&quot;서브와 &quot;my&quot;서브의 차이점은 무엇입니까? &quot;my&quot;서브가 선언 될 때 실행이 블록에 들어갈 때마다 각 서브의 새 사본이 작성됩니다. &quot;상태&quot;서브 루틴은 포함 블록의 한 실행에서 다음 블록까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">$ array [1]와 @array [1]의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">: encoding과 : utf8의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; 과 &lt;code&gt;:utf8&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="aa686143aeb2276da66fe372809de6163adbd5d8" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">리스트와 배열의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">이 펄 진술은 무엇에 관한 것입니까? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 는 간단한 큰 따옴표로 묶인 문자열입니다. &lt;code&gt;World&lt;/code&gt; 는 정규식이며 &lt;code&gt;//&lt;/code&gt; 둘러싸는 &lt;code&gt;/World/&lt;/code&gt; 일치하는 문자열을 검색 할 펄을 알려줍니다. 연산자 &lt;code&gt;=~&lt;/code&gt; 는 문자열을 정규식 일치와 연결하고 정규식이 일치하면 true를, 정규식이 일치하지 않으면 false를 생성합니다. 이 경우 &lt;code&gt;World&lt;/code&gt; 는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 의 두 번째 단어와 일치 하므로 표현이 참입니다. 이와 같은 표현식은 조건부에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8288a589c4caf7bd2276d185a7bd5fbf595dc73f" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">가변 자살이란 무엇이며 어떻게 방지 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">가장 좋아하는 호출기 프로그램은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">가장 좋아하는 껍질은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7a785a8e58c6a9e20c1539582a1a9c97e125374e" translate="yes" xml:space="preserve">
          <source>What kind of stuff is contained in this distribution. Most things on CPAN are &lt;code&gt;module&lt;/code&gt;s (which can also mean a collection of modules), but some things are &lt;code&gt;script&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdeb97ea551b504f3da8bf43202e9fd344363cd" translate="yes" xml:space="preserve">
          <source>What kind of test? Possibilities include, skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">Perl 스레드는 어떤 종류의 스레드입니까?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">어떤 라이브러리를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">Perl을 지원하는 머신은 무엇입니까? 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f891fe8a2be3f1ffe86b5a80057ef4ca6da1223d" translate="yes" xml:space="preserve">
          <source>What machines support libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">Perl에는 어떤 메일 링리스트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">메소드를 특별하게 만드는 것은</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">이 모든 것을 중요한 것은 Exporter 모듈이 glob aliasing을 import / export 메커니즘으로 사용한다는 것입니다. 모듈에서 내 보낸 변수를 올바르게 현지화 할 수 있는지 여부는 내 보낸 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">좋은 패치를 만드는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">이 패스를 펄 개발자에게 흥미롭게 만드는 것은이 패스에서 일부 최적화가 수행 될 수 있다는 것입니다. 이것은 소위 &quot;체크 루틴&quot;에 의한 최적화입니다. 노드 이름과 해당 점검 루틴 간의 대응은</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Perl에 어떤 모듈과 확장이 있습니까? CPAN이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5eca61ede7bdc9f4a1c178015ba2713ba5ace84a" translate="yes" xml:space="preserve">
          <source>What modules does a particular distribution contain?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">Perl 버전과 함께 제공되는 모듈</target>
        </trans-unit>
        <trans-unit id="bbb49ac4107bc251bf787f21f8a88fe7e30321ce" translate="yes" xml:space="preserve">
          <source>What most people need to know (superclasses on top.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01351f5f724ad044096c916ace26f9169184a3" translate="yes" xml:space="preserve">
          <source>What other modules do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">다음은 어떤 레 포프입니까?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">성공적인 전략은 &lt;code&gt;reload cpan&lt;/code&gt; 과 디버깅 스위치 의 조합입니다 . 셸에서 실행하는 동안 새 디버그 문을 추가 한 다음 &lt;code&gt;reload cpan&lt;/code&gt; 하고 현재 컨텍스트를 잃지 않고 즉시 새 디버깅 메시지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">모듈로 무엇을 만들어야합니까?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">들어오는 데이터를 현재 프로세스에 더 적합한 형식으로 변환하기 위해 일부 도우미 &lt;b&gt;프로세스&lt;/b&gt; 가 수행 한 작업 종종 들어오는 &lt;b&gt;파이프로&lt;/b&gt; 수행됩니다 . &lt;b&gt;C 전 처리기&lt;/b&gt; 참조&lt;b&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">성공한 경우 프로그램 또는 함수가 반환하는 것 정확한 종료 코드가 중요하지 않은 프로그램의 경우이 섹션을 생략 할 수 있습니다. 표준에 따라 성공하면 0을, 실패하면 0이 아닌 값을 반환합니다. 항상 기능을 위해 존재해야합니다. 모듈의 경우 여기에서 모듈 인터페이스의 리턴 값을 요약하는 것이 유용하거나 모듈이 제공하는 각 기능 또는 메소드의 문서에서 리턴 값을 별도로 논의하는 것이 더 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">이것이하는 일은 새로운 바이너리 op를 만들고 많은 변수를 공급하는 것입니다. 변수는 토큰을 참조합니다. &lt;code&gt;$1&lt;/code&gt; 은 입력의 첫 번째 토큰이고 &lt;code&gt;$2&lt;/code&gt; 는 두 번째 토큰입니다 . 정규식 역 참조를 생각하십시오. &lt;code&gt;$$&lt;/code&gt; 는이 축소에서 반환 된 op입니다. 그래서 새로운 바이너리 연산자를 만들기 위해 &lt;code&gt;newBINOP&lt;/code&gt; 를 호출 합니다. &lt;code&gt;newBINOP&lt;/code&gt; 의 첫 번째 매개 변수 는</target>
        </trans-unit>
        <trans-unit id="b67434e808539a7f62532e0f74741a29eeb423fa" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt;, a function in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">이는 Perl 5.6.0 또는 5.6.1에서 실행되는 Storable 1.x로 작성된 데이터가 Unix 또는 Linux에서 64 비트 정수로 구성된 경우 기본적으로이 Storable이이를 읽지 않고 오류를 발생시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">이는 &lt;code&gt;/a&lt;/code&gt; 수정자가 적용 되지 않는 한 &lt;code&gt;\d&lt;/code&gt; 되지 않는 한 는 숫자 '0'- '9'뿐만 아니라 아랍어, Devanagari 및 다른 언어의 숫자와도 일치합니다. 이로 인해 약간의 혼란과 보안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="024bfa55bc6c90f99bae14081b1ca78d49501b2e" translate="yes" xml:space="preserve">
          <source>What this says is: &lt;code&gt;1..1&lt;/code&gt; &quot;I'm going to run one test.&quot; [1] &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed&quot;. And that's about all magic there is to testing. Your basic unit of testing is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URL에서 &quot;1 / crontab&quot;다음에 넣을 내용 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URL에서 &quot;Foo % 3a % 3aBar&quot;다음에 넣을 내용. 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">제목의 앞뒤에 넣을 내용. 값은 이미 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">Perl 버전과 함께 제공된 유틸리티</target>
        </trans-unit>
        <trans-unit id="41d1f562b44341deaff0802951db706e407b9e33" translate="yes" xml:space="preserve">
          <source>What version of Perl you are running?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">이 기억 덩어리에 무엇이 있었습니까? 숫자, 문자 또는 둘의 혼합? 우리는 ASCII (또는 유사) 인코딩을 사용하는 컴퓨터를 사용하는 것을 가정하면 16 진수 값을 범위 &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; 는 대문자 및 표시 &lt;code&gt;0x20&lt;/code&gt; 인코딩 공간을. 그래서 우리는 그것이 타블로이드처럼 읽을 수있는 텍스트 조각이라고 가정 할 수 있습니다. 그러나 다른 사람들은 ASCII 테이블을 잡고 그 첫 학년의 느낌을 재현해야 할 것입니다. 템플릿 코드 &lt;code&gt;H&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 풀면 바이트 시퀀스의 내용이 일반적인 16 진 표기법으로 변환 된다는 점에 유의하십시오 . &quot;시퀀스&quot;는 수량을 나타내는 아주 모호한 표시이므로 &lt;code&gt;H&lt;/code&gt; 반복 카운트가 뒤 따르지 않는 한 16 진 숫자 하나만 변환하도록 정의되었습니다. 반복 횟수 별표는 남아있는 모든 것을 사용하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0db88274915aa193b8762de0b1150e4497a2898f" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;unpack&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">실제로해야 할 일은 필드의 너비를 넓히는 것입니다. &lt;code&gt;A&lt;/code&gt; 형식 패드, 그래서 우리는 다음과 같이 우리의 필드를 줄을 추가 공간을 사용할 수있는 공간이있는 모든 존재 자 :</target>
        </trans-unit>
        <trans-unit id="b18ad647190599dbc6f89a0be950252c58677d5e" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt;, &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt;, &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt;, and &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">지금까지 설명한 것은 &lt;code&gt;\p{...}&lt;/code&gt; 문자 클래스 의 단일 형식입니다 . 또한 복합 형태가있을 수 있습니다. 이는 &lt;code&gt;\p{name=value}&lt;/code&gt; 또는 &lt;code&gt;\p{name:value}&lt;/code&gt; 와 같습니다 (등호와 콜론은 서로 바꿔 사용할 수 있습니다). 이들은 단일 형태보다 더 일반적이며 실제로 대부분의 단일 형태는 일반적인 복합 형태에 대한 Perl 정의 단축키입니다. 예를 들어, 이전 단락의 스크립트 예제는 &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; 및 &lt;code&gt;\P{script=balinese}&lt;/code&gt; 와 동일하게 작성할 수 있습니다 (대소 문자는 사이에 관계없는 &lt;code&gt;{}&lt;/code&gt; 바지 멜빵). 복합 형식을 사용할 필요는 없지만 때로는 필요할 수 있으며,이를 사용하면 코드를 이해하기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">누군가가 당신이 훌륭한 매뉴얼을 읽어야한다고 생각할 때 들리는 것.</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">당신이 할 수있는 일은 그러한 문자열의 UTF-8 표현의 MD5 체크섬을 계산하는 것입니다. encode_utf8 () 함수를 통해 문자열을 필터링하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">유 전적으로 또는 다른 방식으로 조상으로부터 얻는 것. 만약 당신이 &lt;b&gt;수업이&lt;/b&gt; 된다면, 당신의 조상을 &lt;b&gt;기본 수업&lt;/b&gt; 이라고 하고, 당신의 후손을 &lt;b&gt;파생 수업&lt;/b&gt; 이라고 합니다. &lt;b&gt;단일 상속&lt;/b&gt; 및 &lt;b&gt;다중 상속을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">&lt;code&gt;Perl++&lt;/code&gt; 두 번 할 때 얻는 것 . 한 번만하면 머리카락이 말립니다. 샴푸를하려면 8 번 증량해야합니다. 오히려 헹구고 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">아마 당신이 원하는 것은 이것입니다 :</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">대신 사용하고 싶은 것은 :</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">MakeMaker 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">SV에 실제로 저장된 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">폐쇄 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">확장이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl의 내용</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">이름이 뭐야?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">새로운 소식은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl에없는 것</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">그 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 무엇입니까 ? 자, 서브 루틴에 대한 인수는 우리에게 &lt;code&gt;@_&lt;/code&gt; 이라는 특수 배열로 사용할 수 있습니다 (자세한 내용은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 함수 의 기본 인수는 &lt;code&gt;@_&lt;/code&gt; 입니다. 그래서 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 첫 번째 항목을 인수 목록에서 벗어나 &lt;code&gt;$logmessage&lt;/code&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f547a820f19e246c5a238efacc444f158add7954" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;shift&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;shift&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt;. So &lt;code&gt;my $logmessage = shift;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">해시와 함께 &quot;삭제&quot;와 &quot;언더 프&quot;의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">&quot;perl&quot;과 &quot;Perl&quot;의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 과 &lt;code&gt;utf8&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="80de415750b641663470a45e8ab912ba377dfdef" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">UTF-8과 utf8의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">&amp;amp; foo와 foo ()로 함수를 호출하는 것의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">딥 바인딩과 얕은 바인딩의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">다이나믹 (정적) 범위 지정의 차이점은 무엇입니까? local ()과 my () 사이?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">요구와 사용의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="623db2e6cf92d9577f09035416d4d1ab6a554bc6" translate="yes" xml:space="preserve">
          <source>What's the minimum perl version required to run Archive::Tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6475c25e2b2e180b098b671e2a15d671e687b92e" translate="yes" xml:space="preserve">
          <source>What's this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cf3a0e365c639b428e364b59520ed78e55a70c" translate="yes" xml:space="preserve">
          <source>What's wrong the with gettext-using code like this...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">* -w * 및 $ ^ W의 문제점</target>
        </trans-unit>
        <trans-unit id="0d7b30ea762ee4ef5180cde544a82675165a0f09" translate="yes" xml:space="preserve">
          <source>What's wrong with -w and $^W</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 및 &lt;code&gt;$^W&lt;/code&gt; 의 문제점</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">항상 &quot;$ vars&quot;를 인용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">빈 공간에서 백틱을 사용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">빈 공간에서 grep을 사용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">참조가 무엇이든, 이름이 있거나 없을 수 있습니다. 일반적인 참조 유형에는 스칼라, 배열, 해시 및 서브 루틴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">RE 엔진에서 일어나는 일이 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에서 더 잘 논의 될 수 있지만, 연속성을 위해 여기에서 그렇게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1858f2d67aca21222e3d2c00cfe67bcfdc61e6f3" translate="yes" xml:space="preserve">
          <source>Whatever the distribution configured with on the releaser's machine at release time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">참조로 수행하려는 작업이 무엇이든 관계없이 &lt;b&gt;규칙 1 사용에&lt;/b&gt; 참조 방법이 나와 있습니다. 일반 배열 또는 해시와 동일한 작업을 수행하기 위해 작성한 Perl 코드를 작성한 다음 배열 또는 해시 이름을 &lt;code&gt;{$reference}&lt;/code&gt; 로 바꾸십시오 . &quot;내가 가진 모든 것이 참조 일 때 어떻게 배열을 반복합니까?&quot; 배열을 반복하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b5090b0a0f33f56f40ebfa24d96ae2ad1f9f57a8" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt;. &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">&quot; &lt;code&gt;::&lt;/code&gt; &quot;가 이름에 없으면 &quot; &lt;code&gt;Encode::&lt;/code&gt; &quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8cc9e35707e78514053d0fbc759ccaa1c9412305" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt;&quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt;&quot; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">$ data가 있으면 인스턴스 데이터를 $ data로 설정하고 객체 자체를 반환합니다. 그렇지 않으면 현재 인스턴스 데이터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">$ encoding을 생략하면 $ data가 이미 utf8에 있거나 그렇지 않으면 &quot;&quot;(빈 문자열) 인 경우 기본값은 utf8입니다.</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">$ encoding이 있으면 인스턴스 인코딩을 $ encoding으로 설정하고 객체 자체를 반환합니다. 그렇지 않으면 현재 인스턴스 인코딩이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">$ walker는 호출 될 때 제공된 서브 루틴을 순회하고 현재 스타일을 사용하여 렌더링합니다. 나중에 여러 가지 방법으로 스타일을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">'make clean'또는 이와 유사한 것을 실행하면 $ (FIRST_MAKEFILE)이이 위치에 백업됩니다.</target>
        </trans-unit>
        <trans-unit id="0abdf7ca0a208a27b487c4c9ab6758614a97566c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; had a host option, this host will be used. Without &lt;code&gt;$host&lt;/code&gt; argument, all hosts are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e0d783eb05bd44a60d48045d09e1ab76b77d53" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a194e79d9bd84bd7e1d0517e4cb70b910eba34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (but not &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect, &lt;code&gt;sort LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7a9b507455bc0f46d9bdf6728d0f728b33492c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, when &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; subsequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">때 &lt;b&gt;--compat-버전&lt;/b&gt; ( &lt;b&gt;-b&lt;/b&gt; ) 존재 생성 된 테스트는 사용 &lt;code&gt;Test::More&lt;/code&gt; 보다는 &lt;code&gt;Test&lt;/code&gt; 5.6.2 이전 버전의 기본이된다. &lt;code&gt;Test::More&lt;/code&gt; 가 생성 된 &lt;code&gt;Makefile.PL&lt;/code&gt; 의 PREREQ_PM에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c72e13c5aa4ae0a2cebdd6d17deca3e4c332c7a" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d44d0dc017c71b0f6cb1ffd43c417d3ee2ebe5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;S&quot;&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;&quot;T&quot;&lt;/code&gt; can match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때, &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 스칼라 문맥 (즉, 파일 소리내어 먹는다 모드), 그리고 빈 파일을 읽을 때, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때, &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 스칼라 문맥 (즉, 파일 소리내어 먹는다 모드), 그리고 빈 파일을 읽을 때, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="a000e25ad164b5a4e8e6e794f33b40196ef9e9c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, any existing callback will be removed and &lt;code&gt;decode&lt;/code&gt; will not change the deserialised hash in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cdec40a0b802970de3c22418f7ef1894e05ac3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is specified, it will be called from &lt;code&gt;decode&lt;/code&gt; each time it decodes a JSON object. The only argument is a reference to the newly-created hash. If the code references returns a single scalar (which need not be a reference), this value (or rather a copy of it) is inserted into the deserialised data structure. If it returns an empty list (NOTE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">때 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 압축 파일 / 버퍼 매핑하고 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 비 압축 후 단일 파일 / 버퍼이다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 입력 파일 / 버퍼의 각에서 모든 비 압축 데이터의 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 파일 / 버퍼 및 매핑 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 단일 파일 / 입력 파일을 버퍼 / 버퍼에 저장한다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 압축 데이터 스트림으로 연결된 일련.</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">때 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 파일 / 버퍼 매핑하고 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 단일 파일 / 입력 파일을 버퍼 / 버퍼는 각각에 저장됩니다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 별개의 항목으로.</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">때 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; fileglob 문자열입니다, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 또한 fileglob 문자열이어야합니다. 다른 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d2909a9438238d7274c21eee7293fc99c88b23e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;&lt;code&gt;${^UNICODE}&lt;/code&gt;&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;&lt;code&gt;-C&lt;/code&gt;&quot; in perlrun&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">때 &lt;code&gt;${^UNICODE}&lt;/code&gt; (v5.8.2에서 사용할 수있는 시작)이 존재하고 제로가 아닌,이 옵션은 완전히 무시됩니다. 자세한 내용 &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;은 perlvar의 $ {^ UNICODE}&lt;/a&gt; 및 &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;perlrun의 -C&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 의 인수가 쉘에 의해 간접적으로 실행될 때 , 결과 및 리턴 코드는 단점이 있습니다. 자세한 내용 &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;은 perlop&lt;/a&gt; 및 &lt;a href=&quot;#exec&quot;&gt;exec의 &lt;/a&gt;`STRING`을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (하지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과에, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 현재 정렬 로케일에 따라 목록을 정렬합니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; 지정은 주어진 플래그는 자동으로 어휘 범위의 끝까지 모든 정규 표현식에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 perl은 정규식을 컴파일하고 사용할 때 디버깅 메시지를 생성합니다. 출력은 실행하여 얻어진 것과 동일하다 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 으로 사용이 가능한 펄 인터프리터 &lt;b&gt;- 닥터의&lt;/b&gt; 스위치. 경기의 복잡성에 따라 상당히 방대한 수 있습니다. &lt;code&gt;debug&lt;/code&gt; 대신 &lt;code&gt;debugcolor&lt;/code&gt; 를 사용하면 터미널 캡 컬러 시퀀스를 이해하는 터미널에서 화려한 디스플레이를 얻는 데 사용할 수있는 출력 형식을 사용할 수 있습니다. 세트 &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; 의 쉼표로 구분 된 목록에 &lt;code&gt;termcap&lt;/code&gt; 특성에 / 문자열을 강조 표시 사용에 온 / 오프 파트 포인트 사전합니다. 추가 정보를 참조하십시오 .&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;perldebug에서 정규 표현식 디버깅을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 적용하는 정규 표현식을 포함 할 수 있습니다 &lt;code&gt;(?{ ... })&lt;/code&gt; 제로 폭 주장하고 &lt;code&gt;(??{ ... })&lt;/code&gt; 연기 변수 보간에서 유래 표현식보다는가 게재 말 그대로 정규 표현식 내에서. 잠재적 인 보안 위험이 있으므로 일반적으로 허용되지 않습니다. 이 pragma는 오염 된 데이터에서 정규식을 가져올 때 무시됩니다. 즉, 오염 된 정규식에서는 평가가 항상 허용되지 않습니다. 참조 &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(? {코드}) perlre에서&lt;/a&gt; 와 &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;perlre에 (?? {코드})를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 정규식 패턴을 컴파일 할 때보 다 엄격한 검사가 적용됩니다. 이로 인해 다른 것보다 많은 경고가 발생하고 경고 만하는 것이 아니라 치명적일 수 있습니다. 이것의 목적은 컴파일 타임에 합법적이지만 프로그래머의 실제 의도가 아닐 수있는 합리적인 가능성을 발견하고보고하는 것입니다. 그러면 해당 범위 내 에서 &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 경고 범주 가 자동으로 켜집니다 (아직없는 경우).</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; 유효하고, 오염 된 문자열이 정규 표현식의 대상 (리스트 문맥에서 m // 조작자 반품 값) 정규식 메모리는 오염되어있다. 이 기능은 오염 된 데이터에 대한 정규 표현식 작업이 안전한 하위 문자열을 추출하기위한 것이 아니라 다른 변환을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 의 인수가 쉘에 의해 간접적으로 실행될 때 , 결과 및 리턴 코드는 단점이 있습니다. 자세한 내용 &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;은 perlop&lt;/a&gt; 및 &lt;a href=&quot;exec&quot;&gt;exec의 &lt;/a&gt;`STRING`을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (하지만 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과에, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 현재 정렬 로케일에 따라 목록을 정렬합니다. &lt;a href=&quot;../perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">때 &lt;code&gt;Append&lt;/code&gt; 지정하고 true로 설정되어, 그것은 것입니다</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutout&lt;/code&gt; 가 지정되지 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 는 입력 버퍼를 압축 해제하여 모든 그것을 작성하는 압축되지 않은 데이터를 기록하는데 걸리는만큼 메모리로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutout&lt;/code&gt; 가 지정되지 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 그것이 입력 버퍼를 압축 해제하여 생성 된 모든 압축 데이터를 기록하는데 걸리는만큼 메모리로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 이 사용 되면 사용 된 출력 버퍼의 크기는 16k 또는 &lt;code&gt;$output&lt;/code&gt; 이미 할당 된 메모리 양 중 더 큰 것입니다. 사용 가능한 출력 크기를 예측하는 것은 까다롭기 때문에 정확한 출력 버퍼 크기를 얻는 데 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="378bab7c46fb87434a4a31e87bab949c33fee48d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 이 사용 되면 사용 된 출력 버퍼의 크기는 &lt;code&gt;Bufsize&lt;/code&gt; 옵션 의 값 이거나 &lt;code&gt;$output&lt;/code&gt; 이미 할당 된 메모리 양 중 큰 값입니다. 사용 가능한 출력 크기를 예측하는 것은 까다롭기 때문에 정확한 출력 버퍼 크기를 얻는 데 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e109cef898586b284816d1d609f442757d09d9a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3a312e83feddf95b646900a17ece38db487898" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3F&quot;&gt;&quot;$?&quot;&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;die&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 가 활성화 되면 (아래 &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; 참조) 기본 VMS 종료 상태 값은 &lt;code&gt;$!&lt;/code&gt; 또는 &lt;code&gt;$?&lt;/code&gt; 또는 Perl 및 GNV 패키지를 포함하여 C로 작성된 다른 프로그램에서 유효 원래 값을 디코딩 할 수있는 방식으로 &lt;code&gt;$^E&lt;/code&gt; 또는 Unix 값 255로 인코딩됩니다. 의 정상적인 비 VMS의 동작에 따라 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 중 하나의 경우 &lt;code&gt;$!&lt;/code&gt; 또는 &lt;code&gt;$?&lt;/code&gt; 0이 아닌 경우 해당 값 중 하나가 기본 VMS 상태 값으로 인코딩됩니다. Unix 상태 값이 모두 0이고 &lt;code&gt;$^E&lt;/code&gt; 값이 ERROR 또는 SEVERE_ERROR 심각도 중 하나 인 경우 &lt;code&gt;$^E&lt;/code&gt; 값은 그대로 종료 코드로 사용됩니다. 위의 어느 것도 적용되지 않으면 Unix 값 255는 기본 VMS 종료 상태 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">때 &lt;code&gt;S&lt;/code&gt; 가 일치시킬 수 있습니다, 그것은 단지 때보다 더 나은 일치 &lt;code&gt;T&lt;/code&gt; 는 일치 할 수는.</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">때 &lt;code&gt;Strict&lt;/code&gt; 사용할 수있는 다음과 같은 동작이 치안을한다 :</target>
        </trans-unit>
        <trans-unit id="db687c97fb2b33423a8768bd320e4711c5ad7257" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Time::Local&lt;/code&gt; was first written, it was a common practice to represent years as a two-digit value like &lt;code&gt;99&lt;/code&gt; for &lt;code&gt;1999&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;2001&lt;/code&gt;. This caused all sorts of problems (google &quot;Y2K problem&quot; if you're very young) and developers eventually realized that this was a terrible idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22의 값이 무시 될 수있는 범위를 벗어난의 중량. &lt;code&gt;table&lt;/code&gt; 이나 &lt;code&gt;entry&lt;/code&gt; 을 사용할 수 있지만 범위를 벗어난 값이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="a8376390a3e85be3e6ac52a52161522985c10ab7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allow_bignum&lt;/code&gt; is enabled, big integer values and any numeric values will be converted into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects respectively, without becoming string scalars or losing precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 모듈 을 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 때 , 모듈의 파일을 찾을 수 없으면 죽지 않고 다른 오류로 죽습니다. 이 후 기본 클래스가 비어 있고 기호가 없으면 &lt;code&gt;base&lt;/code&gt; 이 죽습니다. 이것은 자신과 동일한 파일의 클래스에서 상속 할 때 유용하지만 파일 이름이 다음과 같이 기본 모듈 이름과 일치하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7e10e7af3fdfd7341808494145f96d758dfe5848" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;require&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801ac03d31183f16ba294ce4fa7c937f1f41d11" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dynamic_config&lt;/code&gt; is true, it is an error to presume that the prerequisites given in distribution metadata will have any relationship whatsoever to the actual prerequisites of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;follow&lt;/code&gt; 또는 &lt;code&gt;follow_fast&lt;/code&gt; 이 적용되고, 또한이 &lt;code&gt;$File::Find::fullname&lt;/code&gt; . 이 함수는 &lt;code&gt;bydepth&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;$File::Find::prune&lt;/code&gt; 을 설정 하여 트리를 프룬 ( prune) 할 수 있습니다. &lt;code&gt;follow&lt;/code&gt; 또는 &lt;code&gt;follow_fast&lt;/code&gt; 가 지정 되지 않은 경우 호환성 이유로 (find.pl, find2perl) 다음 전역을 사용할 수 있습니다. &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; 및 &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e21f0f2ae6a786fecac14190bdb286ef45b2801" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt;. The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt;, &lt;code&gt;$File::Find::topdev&lt;/code&gt;, &lt;code&gt;$File::Find::topino&lt;/code&gt;, &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">빈 매개 변수 목록으로 &lt;code&gt;get_handle&lt;/code&gt; 을 호출 하면 마술이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">하위 디렉토리의 파일 삭제에서 &lt;code&gt;remove_tree&lt;/code&gt; 가 리턴 되면 , 점검 한 상위 디렉토리가 원래 디렉토리가 아닌 것으로 확인되었습니다. 이것은 악의적 인 활동의 표시로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">배열, 해시, 배열 참조 또는 해시 참조에서 &lt;code&gt;share&lt;/code&gt; 를 사용 하면 포함 된 모든 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">때 &lt;code&gt;test_test&lt;/code&gt; 가 호출되고 출력이 테스트를 생성하면 선언하는 것을 일치하지 않음을, &lt;code&gt;test_test&lt;/code&gt; 는 두 개의 충돌 버전을 보여주는 디버그 정보를 인쇄합니다. 이 출력 자체는 디버그 정보이므로 출력의 어느 부분이 &lt;code&gt;test_test&lt;/code&gt; 에서 왔고 어느 부분이 원래 테스트의 원래 출력 인지 혼동 될 수 있습니다 . 또한 출력이 비슷해 보이지만 줄 끝에서 불필요한 공백과 같은 것을 발견하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="100cf02e094db7d3754b0f2bd62e72f796e0a652" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; is specified, the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e437612ab773128746c34ed5e2418f0d2432e87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebug&lt;/a&gt; for additional info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdd2a4a70c97e6482142a6afb44a0c24ab7f2c4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;(?{ code })&quot; in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;&quot;(??{ code })&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8ac1a2fdcf9c532880e4f21577de40d0e705a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d597df9736b57e5c279970bfb89c7002422580" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea81caddf6f1e1e3901216d09988417e561f49ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;utf8&lt;/code&gt; is disabled (the default), then &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; generate and expect Unicode strings, that is, characters with high ordinal Unicode values (&amp;gt; 255) will be encoded as such characters, and likewise such characters are decoded as-is, no changes to them will be done, except &quot;(re-)interpreting&quot; them as Unicode codepoints or Unicode characters, respectively (to Perl, these are the same thing in strings unless you do funny/weird/dumb stuff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">BE 또는 LE가 인코딩 이름으로 명시 적으로 언급되면 BOM은 단순히 일반 문자 (ZERO WIDTH NO-BREAK SPACE)로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="68ea7ed2b7146d8c990e48756af545235a644f6f" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">decode () 중에 BE 또는 LE가 생략되면 BOM이 문자열의 시작 부분에 있는지 확인합니다. 하나가 발견되면 엔디안은 BOM이 말하는 것으로 설정됩니다. BOM이 없으면 루틴이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">encode () 중에 BE 또는 LE가 생략되면 BOM이 앞에 붙은 BE 인코딩 문자열을 리턴합니다. 따라서 전체 텍스트 파일을 인코딩하려는 경우 전체 텍스트를 한 줄에 한 번에 encode ()하거나 파일이 아닌 각 줄에 BOM이 추가되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">CPAN이 실행될 때 환경 변수 PERL5_CPAN_IS_RUNNING을 실행중인 프로세스의 ID로 설정합니다. 또한 이전 버전의 Module :: Install에서 발생할 수있는 런 어웨이 프로세스를 방지하기 위해 PERL5_CPANPLUS_IS_RUNNING을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm이 PERL5LIB를 통해 @INC를 확장하면 추가 된 디렉토리 목록 (또는 추가 된 디렉토리 수의 요약)을 인쇄합니다. 이 메시지를 받으려면 'v'를 선택하고 메시지를 표시하지 않으려면 '없음'을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm이 일부 선택적 기능에 필요한 모듈을로드하면 일반적으로 모듈 이름 및 버전에 대해보고합니다. 이 메시지를 받으려면 'v'를 선택하고 메시지를 표시하지 않으려면 '없음'을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">CPAN.pm이 tar 명령을 사용하는 경우, 자세한 표시를 위해 어떤 스위치를 사용해야합니까? 조용한 작동을 위해서는 '없음', 파일 이름 목록은 'v', 전체 목록은 'vv'를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">Configure가 확장에 대해 물어볼 때 IO와 Fcntl을 제안하고 데이터베이스 처리를 원할 경우 SDBM_File 또는 GDBM_File (이에 대해 gdbm을 설치해야 함)을 제안합니다. POSIX 확장을 사용하려면 (이것이 기본값 임), 사용자의 스택 크기가</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">Democritus가 불가분의 물질에&amp;ldquo;원자&amp;rdquo;라는 단어를 썼을 때, 그는 말 그대로자를 수없는 것을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">G_KEEPERR을 사용하면 호출 된 코드의 모든 오류가 평소와 같이 호출을 종료하고 오류가 호출을 넘어 전파되지는 않지만 (G_EVAL의 경우와 같이) &lt;code&gt;$@&lt;/code&gt; 로 들어 가지 않습니다 . 대신 오류 앞에 &quot;\ t (in cleanup)&quot;이라는 문자열이 접두어로 경고로 변환됩니다. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않고&lt;/a&gt; 비활성화 할 수 있습니다 . 오류가 없으면 &lt;code&gt;$@&lt;/code&gt; 는 지워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd0879b5780d10481d395ff78c94006ad9de4758" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt;. Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;no warnings 'misc'&lt;/code&gt;. If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">하나의 명령으로 번들 또는 여러 모듈을 설치할 때 추적 할 출력이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">CPAN의 쉘을 실행할 때, &lt;code&gt;/etc/inputrc&lt;/code&gt; (또는 &lt;code&gt;~/.inputrc&lt;/code&gt; )에 관한 오류 메시지가 나타납니다. ) 파일 .</target>
        </trans-unit>
        <trans-unit id="cc4c433cebf4d4f4606a91e341dbbd967898b31d" translate="yes" xml:space="preserve">
          <source>When I run my tests TAP::Harness creates a scheduler (TAP::Parser::Scheduler) to work out the running order for the tests, an aggregator (TAP::Parser::Aggregator) to collect and analyse the test results and a formatter (TAP::Formatter::Console) to display those results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712f9e473dcc2ba74a4ec66b73d3e2f5bccede0e" translate="yes" xml:space="preserve">
          <source>When I run prove it processes its arguments, figures out which test scripts to run and then passes control to TAP::Harness to run the tests, parse, analyse and present the results. By subclassing TAP::Harness I can customise many aspects of the test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1064c03f1fc4073f4165a39d84f0e0127c6dd155" translate="yes" xml:space="preserve">
          <source>When I tell prove to save state it writes a file called '.prove' ('_prove' on Windows) in the current directory. It's a YAML document so it's quite easy to write tools of your own that work on the saved test state - but the format isn't officially documented so it might change without (much) warning in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">스크립트를 실행하려고 할 때이 메시지가 나타납니다. 무슨 뜻인가요?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">I / O, 예를 들어 &quot;읽기&quot;가 요청되면 요청은 Perl에서 먼저 각 계층의 &quot;읽기&quot;기능을 사용하여 스택 아래로 내려간 다음 맨 아래에 운영 체제 서비스에서 입력이 요청됩니다. 스택을 반환하고 마침내 Perl 데이터로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Memoize가 항목이 이미 캐시에 있는지 확인해야하는 경우 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; 호출 합니다. &lt;code&gt;key&lt;/code&gt; 는 정규화 된 함수 인수입니다. 키가 캐시에 없거나 키가 만료 된 경우 MyExpirePolicy :: EXISTS는 0을, 만료되지 않은 값이 캐시에 있으면 1을 반환해야합니다. 그것은해야한다</target>
        </trans-unit>
        <trans-unit id="de4b7c34cbf176c69c5c8a01cb2f47a2ef49c9de" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt;. &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">Perl 5.12 이상에서 줄임표 문이 발견되면 오류없이이를 구문 분석하지만 실제로 실행하려고하면 Perl 텍스트가 &lt;code&gt;Unimplemented&lt;/code&gt; 텍스트와 함께 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="5b63aa2881910e0e5509ac7fb04463269b672b02" translate="yes" xml:space="preserve">
          <source>When Perl 5.6.0 was released, the decision was made to provide a transformation between the old-style decimal versions and new-style dotted-decimal versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">Perl은 정규식을 컴파일 할 때 괄호를 메모리 일치의 시작으로 취급합니다. 닫는 괄호를 찾지 못하면 다음과 같이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">Perl이 $ netconf에 의해 참조 된 객체를 파기하면 제공된 XSUB DESTROY 함수로 객체를 보냅니다. Perl은이 오브젝트가 Perl 오브젝트가 아닌 C 구조 체인지 판별 할 수없고 상관하지 않습니다. 이런 의미에서 getnetconfigent () XSUB에 의해 작성된 오브젝트와 일반 Perl 서브 루틴에 의해 작성된 오브젝트 사이에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="954a1b48bf7dbf510303237ceeb967daf1def196" translate="yes" xml:space="preserve">
          <source>When Perl encounters a wildcard subpattern, (see &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;), it suspends compilation of the main pattern, compiles the subpattern, and then matches that against all legal possibilities to determine the actual code points the subpattern matches. After that it adds these to the main pattern, and continues its compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">Perl이 확장과 데이터를 교환 할 때 확장은 UTF8 플래그를 이해하고 그에 따라 작동해야합니다. 확장 프로그램이 해당 플래그를 인식하지 못하면 확장 기능이 잘못 플래그 된 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4850373be99ff07c49bae45c8a4c6f5b91630080" translate="yes" xml:space="preserve">
          <source>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT로 Perl을 빌드 할 때 Perl API에서 함수를 호출하는 확장은 어떻게 든 초기 컨텍스트 인수를 전달해야합니다. 핵심은 PERL_IMPLICIT_CONTEXT를 사용하여 Perl을 빌드하지 않았을 때 확장 프로그램이 여전히 컴파일되는 방식으로 작성해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT를 설정하는 옵션없이 Perl을 빌드하면 인터프리터의 컨텍스트를 포함하는 첫 번째 인수가 없습니다. pTHX_ 매크로에서 밑줄은 다른 인수가 뒤에 오므로 매크로 확장에 컨텍스트 인수 뒤에 쉼표가 필요함을 나타냅니다. PERL_IMPLICIT_CONTEXT가 정의되어 있지 않으면 pTHX_는 무시되고 서브 루틴은 추가 인수를 취하도록 프로토 타입되지 않습니다. 밑줄이없는 매크로 형식은 추가 명시 적 인수가 없을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">Perl이 플랫폼 용으로 컴파일 될 때, 모든 문자를보고 플랫폼이 사용하는 EBCDIC 문자 세트를 추측하고 해당 플랫폼에 따라 자체 조정됩니다. 플랫폼이 Perl이 알고있는 세 가지 중 하나가 아닌 문자 세트를 사용하는 경우 Perl은 컴파일에 실패하거나 실수로 세 가지 중 하나를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">Perl이 ithread를 사용하도록 구성되면 재진입이 아닌 버전보다 재진입 라이브러리 호출을 사용합니다. 버전 3.7 이상 에서 OpenBSD의 &lt;code&gt;getprotobyname_r&lt;/code&gt; 및 &lt;code&gt;getservbyname_r&lt;/code&gt; 함수 에는 호환되지 않으므로 이러한 함수를 호출하기 전에 리턴 구조체 에서 &lt;code&gt;bzero&lt;/code&gt; 를 수행하지 않고 호출 될 때 SEGV가 발생 합니다. 현재 Perl은이 문제를 올바르게 처리해야합니다. 오래된 스레드 Perls (5.8.6 이하)가이 문제에 부딪치게됩니다. OpenBSD 3.7 이상에서 스레드 Perl을 실행하려면 최소한 Perl 5.8.7로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">Perl이 &quot;이진 데이터&quot;를 처리 할 때 프로그래머는 Perl이 &quot;순차 바이트&quot;를 처리하기를 원합니다. 이것은 Perl에게 문제가되지 않습니다 : 바이트는 256 개의 가능한 값을 가지기 때문에 Perl의 훨씬 더 큰 &quot;논리적 특성&quot;에 쉽게 맞습니다.</target>
        </trans-unit>
        <trans-unit id="317f1e48aa507068045f8759d8c8badef1389fb8" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Perl이 &lt;b&gt;-d&lt;/b&gt; 스위치 와 함께 디버깅 모드에서 실행될 때이 GV에는 디버그중인 서브의 이름을 보유하는 SV가 포함됩니다. 이것은 Perl의 $ DB :: sub 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsingle&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a3d6fd090f13b8b7228c62f6dd0eea36d1d1e84" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;-d&lt;/b&gt; 스위치를 사용하여 Perl이 디버깅 모드에서 실행될 때이 SV는 부울이 서브 스텝 단일 단계인지 여부를 표시합니다. 모든 단계 후에 단일 스테핑이 자동으로 켜집니다. 이것은 Perl의 $ DB :: single 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsub&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">Perl이 &lt;b&gt;-Do&lt;/b&gt; 스위치 또는 이와 동등한 것으로 실행되면 과부하는 진단 메시지를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="0c8a95fea35938379cf32ffa88d674c595c3842a" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system with &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; enabled, a wild card directory name of &lt;code&gt;[...]&lt;/code&gt; cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied &quot;.dir;1&quot; removed, and a trailing &lt;code&gt;.&lt;/code&gt; character indicating a null extension will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba82f7be76137263de4d2fc5ab0c4a2f7bd88ccf" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, &lt;code&gt;./.../&lt;/code&gt;, will be converted to &lt;code&gt;[.^.^.^.]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180489f22e9451652052bb264b159682d8729956" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the &lt;code&gt;?&lt;/code&gt; character will be converted to a &lt;code&gt;%&lt;/code&gt; character, if a conversion is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207a022d8cbd197e2ed92d3189e5fa31c10891e3" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, the following &lt;code&gt;DECC$&lt;/code&gt; feature settings will control how the filename is converted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">Perl은 메소드를 검색 할 때 검색을 캐시하여 나중에 메소드를 호출 할 때 다시 검색 할 필요가 없도록합니다. 클래스의 부모 클래스를 변경하거나 클래스에 서브 루틴을 추가하면 해당 클래스의 캐시가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; 볼 때 ; .pm 접미사가있는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd 확장자 와 동일한 이름을 가진 파일을 검색합니다 . 해당 파일을 찾을 수 없으면 Perl은 치명적인 오류로 사망합니다. 기본 검색 경로는 &lt;code&gt;@INC&lt;/code&gt; 배열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8000e169764f8e2a593f5f0dac76f4976f5abd8f" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;use extension;&lt;/code&gt;, it searches for a file with the same name as the &lt;code&gt;use&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733cf2ae6a9ab4b9666de0ca99b049c5b762772" translate="yes" xml:space="preserve">
          <source>When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">예를 들어 Pod :: Simple에 &quot;= head1 Hi there&quot;가 표시되면 기본적으로 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">STDERR이 연결되면 PRINT 메소드가 호출되어 경고 및 오류 메시지를 발행합니다. 이 기능은 호출 중에 일시적으로 비활성화되므로 재귀 루프를 시작하지 않고 PRINT 내에서 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;__WARN__&lt;/code&gt; 및 &lt;code&gt;__DIE__&lt;/code&gt; 핸들러 와 마찬가지로 STDERR의 PRINT 메소드는 파서 오류를보고하기 위해 호출 될 수 있으므로 &lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvar의 % SIG에&lt;/a&gt; 언급 된 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22d03f9253db06fc5a737726d6333d6b64f0247b" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;warn()&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">Storable croak이 발생 하면 &lt;code&gt;Log::Agent&lt;/code&gt; 패키지 에서 &lt;code&gt;logcroak()&lt;/code&gt; 루틴을 통해 오류를보고합니다 ( 사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="b63f06de34cfd6fe1d49dc6c54c0e1ae5c2131fc" translate="yes" xml:space="preserve">
          <source>When Storable throws the &quot;Max. recursion depth with nested structures exceeded&quot; error we are already out of stack space. Unfortunately on some earlier perl versions cleaning up a recursive data structure recurses into the free calls, which will lead to stack overflows in the cleanup. This data structure is not properly cleaned up then, it will only be destroyed during global destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dc1e20be879a4646c74d93b6d6dde474c28168" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">UTF-8이 표준 소스 형식이되면이 pragma는 효과적으로 작동하지 않습니다. 용어 뒤에 오는 편의상</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">유니 코드가 발생하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">유니 코드 규칙이 적용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">유니 코드가 처음 고안되었을 때, 모든 세계 문자는 16 비트 단어를 사용하여 표현 될 수 있다고 생각되었습니다. 즉 , &lt;code&gt;0x0000&lt;/code&gt; 에서 &lt;code&gt;0xFFFF&lt;/code&gt; 까지 최대 &lt;code&gt;0x10000&lt;/code&gt; (또는 65,536)자가 필요합니다 . 이것은 곧 잘못된 것으로 판명되었으며, 유니 코드 2.0 (1996 년 7 월)부터 유니 코드는 최대 21 비트 ( &lt;code&gt;0x10FFFF&lt;/code&gt; ) 까지 정의되었으며, 유니 코드 3.1 (2001 년 3 월)은 &lt;code&gt;0xFFFF&lt;/code&gt; 이상의 첫 문자를 정의했습니다 . 첫 &lt;code&gt;0x10000&lt;/code&gt; 문자는</target>
        </trans-unit>
        <trans-unit id="235280477a8ab02cc7856eb55d9945ecaf55e478" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt;. This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt;), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt;. The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31ae8f51bc97ba41c3c0ff630526d3a83b94c44" translate="yes" xml:space="preserve">
          <source>When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">때 &lt;code&gt;SelectSaver&lt;/code&gt; 파괴되어, 그것이 만들 때 선택된 파일 핸들을 다시 선택한다.</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 때 문장이 또한 올바른 표현이다 (이 블록의 마지막 문장이 때, 예를 들어), 그것을 평가 :</target>
        </trans-unit>
        <trans-unit id="a06437bb92809b351f6a5100b5739a7e2454e5a6" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (&lt;code&gt;CvSLABBED&lt;/code&gt;), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and &lt;code&gt;CvROOT&lt;/code&gt; attached, it has finished its job, so it can forget the slab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">CV의 슬래브 (CvSLABBED)에 참조 카운트가 있으면 해제해야합니다. (따라서 두 개의 CV가 동일한 슬래브에서 참조 횟수를 가져서는 안됩니다.) CV는 컴파일하는 동안 슬래브 만 참조하면됩니다. 컴파일되고 CvROOT가 연결되면 작업이 완료되므로 슬래브를 잊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">DST 변경으로 인해 로케일 시계가 한 시간 앞으로 건너 뛰면 존재하지 않는 한 시간 분량의 현지 시간이 있습니다. &quot;유럽 / 파리&quot;시간대의 경우에도 현지 시계가 2001-03-25 01:59:59에서 2001-03-25 03:00:00으로 급증했습니다.</target>
        </trans-unit>
        <trans-unit id="711842f215653a7ad792c5b86c0dd5c2fc228aee" translate="yes" xml:space="preserve">
          <source>When a L&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34b3c17b138dcee1edbc75a046c702f3a8b9a07" translate="yes" xml:space="preserve">
          <source>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b5f7b3a10fd426ef30c3ec83c6b8baa679be4" translate="yes" xml:space="preserve">
          <source>When a block is preceded by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, or &lt;code&gt;UNITCHECK&lt;/code&gt;, then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">블록이 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;UNITCHECK&lt;/code&gt; 와 같은 컴파일 단계 키워드 앞에 오면 블록은 해당 실행 단계 중에 만 실행됩니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">클래스에 부모가 여러 개인 경우 메서드 조회 순서가 더 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">클래스가 다른 클래스에서 상속되면 부모 클래스에 정의 된 모든 메서드를 자식 클래스에서 사용할 수 있습니다. 자체 클래스에 정의되어 있지 않은 객체에서 메소드를 호출하려고 시도하면 Perl은 상위 클래스에서 해당 메소드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">쉼표로 구분 된 서브 루틴 이름 목록이 옵션으로 제공되면 Showlex는 해당 서브 루틴에 사용 된 어휘 변수를 인쇄합니다. 그렇지 않으면 파일에서 파일 범위 어휘를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">표현식에 상수가 사용되면 Perl은 컴파일 타임에 해당 값으로 바꾸고 표현식을 더 최적화 할 수 있습니다. 특히 &lt;code&gt;if (CONSTANT)&lt;/code&gt; 블록의 모든 코드 는 상수가 false 인 경우 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">컴파일 트리의 일부에 대한 컨텍스트가 알려지면 트리를 통해 전파됩니다. 이때 컨텍스트에는 void, boolean, scalar, list 및 lvalue와 같은 5 개의 값 (런타임 컨텍스트의 경우 2 대신)이있을 수 있습니다. 패스 1과 달리이 패스는 위에서 아래로 처리됩니다. 노드의 컨텍스트는 해당 자식의 컨텍스트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">핵심 함수가 다른 함수를 호출하면 컨텍스트를 전달해야합니다. 일반적으로 매크로를 통해 숨겨집니다. &lt;code&gt;sv_setiv&lt;/code&gt; 를 고려 하십시오 . 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="89bb7cb6afe2aeb318bc31219fdbcf9684114fa1" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt;. It expands into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">사전이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">이 머신에서 CPAN :: Reporter가 이미 분배를 테스트 한 경우 CPAN은 테스트 단계를 건너 뛰고 대신 테스트 보고서 히스토리에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">파일이 열리면 텍스트 또는 이진 모드입니다. 텍스트 모드에서 파일은 CR / LF / Ctrl-Z로 변환됩니다. Cygwin에서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 의 기본 모드 는 파일의 기본이되는 마운트 모드에 의해 결정됩니다. &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt; ()를 참조하십시오 . Perl은 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 함수를 제공하여 텍스트로 취급 될 파일에 바이너리 모드를 설정합니다. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 으로 &lt;code&gt;O_TEXT&lt;/code&gt; 다른 바이너리로 처리 될 파일에 플래그 세트 텍스트 모드 :</target>
        </trans-unit>
        <trans-unit id="77b5bb5939b31598184beb720f013a6b65e23bf1" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;open()&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;&quot;Cygwin::is_binmount&quot;&lt;/a&gt;(). Perl provides a &lt;code&gt;binmode()&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;sysopen()&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">핸들이 열리면 문자열 값에서 get bytes를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">키워드를 처리 할 때 플러그인 함수 는 구문 분석 된 코드를 나타내는 &lt;code&gt;OP&lt;/code&gt; 구조 트리를 작성해야합니다 . 트리의 루트는 &lt;code&gt;*op_ptr&lt;/code&gt; 에 저장되어야합니다 . :이 함수는 다음 구문 분석되었음을 구조의 구문 역할을 나타내는 정수를 반환 &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; 을 가 완전한 문장 경우, 또는 &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; 가 표현됩니다. 명령문 구조는 표현식 내에서 사용할 수 없습니다 ( &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK을 통한 경우 제외). 및 유사한 ) 표현식은 완전한 명령문이 아닙니다 (최소한 세미콜론이 필요함).</target>
        </trans-unit>
        <trans-unit id="a9174fe1323f2a0785f91a3ab7751748b2c8cde0" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt;. The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;do BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">키워드를 처리 할 때 플러그인 기능에 (컴파일 타임) 부작용이있을 수 있습니다. &lt;code&gt;%^H&lt;/code&gt; 수정할 수 있습니다 하고 함수를 정의하는 등의 작업을 수행 할 수 있습니다. 일반적으로 부작용이 처리기의 주요 목적인 경우 일반 컴파일에 포함될 연산을 생성하지 않습니다. 이 경우 여전히 op 트리를 제공해야하지만 단일 null op를 생성하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="96150c30b3160f65ac137db96b6444cc4c0b5dee" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt;, define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d37ded835c420c7b9a32e56975a37c7bb1fd7d" translate="yes" xml:space="preserve">
          <source>When a lexical var hasn't yet been introduced, it already exists from the perspective of duplicate declarations, but not for variable lookups, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">라인이 렌더링 될 때 올바른 형식 스펙이 복사되고 다음 항목에 대해 스캔됩니다. 렌더링 된 각 opcode에 대해 데이터가 대체되고 기본 들여 쓰기와 같은 다른 조작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a843fab343a403fdde443c4b37520ec7d2e838fc" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">일치가 실패하고 다른 동사가 일치 실패에 관여하지 않고 사용할 고유 이름을 제공하지 않는 한 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 가장 최근에 실행 된 이름 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 으로 설정됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="24e6f28f32721a0addc83e91cf8c10e71bc456ee" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; that was involved in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">일치에 성공하면 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 일치와 가장 최근에 실행 된 이름 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">모듈이 다른 모듈을 'build_requires'전제 조건으로 선언하면 이는 다른 모듈이 모듈을 빌드하거나 테스트하는 데 필요하지만 영구적으로 설치할 필요는 없음을 의미합니다. 이 경우 다른 모듈을 설치하거나 'build_dir'디렉토리에 보관하여 일시적으로 만 사용할 수 있습니다. 설치하면 향후 설치 시간이 절약되지만 펄 설치는 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">새 언어를 인코딩 할 때 유니 코드는 일반적으로 해당 문자에 대해 할당되지 않은 연속 코드 포인트 &lt;code&gt;block&lt;/code&gt; 을 선택합니다 . 지금까지 이러한 블록의 코드 포인트 수는 항상 16으로 균등하게 나눠졌습니다. 현재 필요하지 않은 블록의 추가 요소는 향후 성장을 위해 할당되지 않은 상태로 남아 있습니다. 그러나 이후 릴리스에서 사용 가능한 추가 코드 포인트보다 더 많은 코드 포인트가 필요한 경우가 있었으며 새 블록이 오버 플로우를 처리하기 위해 초기 블록에 인접하지 않은 다른 곳에 할당해야했습니다. 따라서 &quot;블록&quot;이 적절한 조직 주체가 아니기 때문에 &lt;code&gt;Script&lt;/code&gt; 속성이 만들어졌습니다. (나중에 개선 된 스크립트 속성 인 &lt;code&gt;Script_Extensions&lt;/code&gt; 도 추가되었습니다.오버 플로우 블록에있는 해당 코드 포인트는 여전히 원래 스크립트와 동일한 스크립트를 가질 수 있습니다. 스크립트 개념은 자연 언어와 더 밀접한 관련이 있습니다. &lt;code&gt;Latin&lt;/code&gt; 스크립트, &lt;code&gt;Greek&lt;/code&gt; 스크립트 등이 있습니다. 수학 기호와 같이 여러 스크립트에서 사용되는 문자에 대한 &lt;code&gt;Common&lt;/code&gt; 과 같은 몇 가지 인공 스크립트 가 있습니다. 스크립트는 일반적으로 여러 블록의 다양한 부분에 걸쳐 있습니다. 스크립트에 대한 자세한 정보 &lt;a href=&quot;perlunicode#Scripts&quot;&gt;는 perlunicode의&lt;/a&gt; 스크립트를 참조하십시오.. 블록으로 나누기는 존재하지만 거의 완전히 우연입니다. 캐릭터가 어떻게 할당되었고 여전히 할당되었는지에 대한 인공물입니다. 유니 코드는 실제로 언어를 인코딩하는 것이 아니라 언어를 작성하는 시스템 (그들의 스크립트)과 하나의 스크립트를 여러 언어로 사용할 수 있으며, 유니 코드도 사물을 인코딩합니다. &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; 과 같은 기호와 같은 언어에 관한 것이 아닙니다 .)</target>
        </trans-unit>
        <trans-unit id="f7bd752f648e1f1f371051489dc3b8a7639c7fc7" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principle, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">패키지가 컴파일되면 다음과 같은 줄</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">perl 스크립트가 $ 0에 값을 할당하면 perl 런타임은 perl_parse ()에 전달 된 argv가 가리키는 메모리를 업데이트하고 다음과 같은 API 함수를 호출하여이 값이 &quot;ps&quot;에 의해보고 된 프로그램 이름으로 표시되도록 시도합니다. 가능한 경우 setproctitle (). 이 동작은 perl을 임베드 할 때 적합하지 않을 수 있으며 perl_parse ()가 호출되기 전에 변수 &lt;code&gt;PL_origalen&lt;/code&gt; 에 값 &lt;code&gt;1&lt;/code&gt; 을 지정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">정규 표현식이 여러 가지 방법으로 문자열과 일치 할 수있는 경우 위의 원칙을 사용하여 정규 표현식과 일치하는 방법을 예측할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">정규 표현식이 컴파일되면 &lt;code&gt;engine&lt;/code&gt; 필드가 적절한 구조를 가리 키도록 설정되어 사용되어야 할 때 Perl은 올바른 루틴을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">신호가 전달되면 (예 : control-C에서 SIGINT) 운영 체제는 다음과 같은 IO 작업으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">공백과 더하기 부호가 한 번에 플래그로 제공되면 더하기 부호가 양수 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="545ab55cd7ca990a06b2c4cf5e80c654c6ee269f" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, the space is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74001a7284f9d1373e15b508cdd1efa8fda60fc2" translate="yes" xml:space="preserve">
          <source>When a user-defined subroutine is wrapped by &lt;code&gt;autodie&lt;/code&gt;, it will use hints if they are available, and otherwise reverts to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3497a2701b51a3e1bca0e706937a383957b3a809" translate="yes" xml:space="preserve">
          <source>When a value is returned from a thread through a &lt;code&gt;join&lt;/code&gt; operation, the value and everything that it references is copied across to the joining thread, in much the same way that values are copied upon thread creation. This works fine for most kinds of value, including arrays, hashes, and subroutines. The copying recurses through array elements, reference scalars, variables closed over by subroutines, and other kinds of reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">변수가 묶여 있으면 TIESCALAR, TIEARRAY 또는 TIEHASH 함수의 반환 값인 객체와 연결됩니다. 이 객체에는 일반적으로 하나의 참조, 즉 묶인 변수의 암시 적 참조 만 있습니다. untie ()가 호출되면 해당 참조가 삭제됩니다. 그런 다음 위의 첫 번째 예에서와 같이 객체의 소멸자 (DESTROY)가 호출되는데, 이는 더 이상 유효한 참조가없는 객체에 대해 정상입니다. 따라서 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">&quot;uvar&quot;매직이 있는 &lt;code&gt;SV&lt;/code&gt; 에 약한 레퍼런스가 저장 되면 레퍼런스가 오래 된 후에 &lt;code&gt;set&lt;/code&gt; 매직이 호출됩니다. 이 후크는 참조 된 오브젝트와 연관된 추가 가비지 콜렉션 활동을 트리거하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">모든 파서가 소진되면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4475cbc9efc3f925a7d535afa9908fb989684e90" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ffe1c99de4f1b7f522c65bdd9eecb591a526c" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9420e774841a86eb3869701949ed03c728fe1309" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; enabled function fails, it generates an &lt;code&gt;autodie::exception&lt;/code&gt; object. This can be interrogated to determine further information about the error that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">배열 또는 배열 슬라이스가 큰 따옴표로 묶인 문자열 또는 &lt;code&gt;/.../&lt;/code&gt; 와 같은 유사한 컨텍스트로 보간 될 때 해당 요소는이 값으로 구분됩니다. 기본값은 공백입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cef7d16c561803c2f66d1c8d9b2d86bf2638f56" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt;, its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ada78738410600725bc97a1fe2d577a540f0ef9" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">속성 목록이 선언에 있으면 속성 'modify'핸들러가 적절한 패키지 (또는 @ISA 상속 트리)에 있는지 확인합니다. 마찬가지로, &lt;code&gt;attributes::get&lt;/code&gt; 이 유효한 참조에서 호출되면 적절한 속성 'fetch'핸들러를 검사합니다. 참조 &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 방법 &quot;적절한 패키지&quot;결정의 작품을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 의 요소를 읽을 때</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">소자의 경우 &lt;code&gt;%ENV&lt;/code&gt; 설정되어 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 판독되는 경우와 같이, 요소가 조회되고,이 발견되는 경우, 그것은 삭제된다. (CRTL &lt;code&gt;environ&lt;/code&gt; 배열 에서 &quot;삭제 된&quot;항목 은 빈 문자열로 설정됩니다.) &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;%ENV&lt;/code&gt; 에서 요소를 제거하는 것과 비슷한 효과가 있지만 요소를 삭제 한 후 요소를 찾으려고 시도하는 다른 시도가 있습니다. 따라서 내부 모드 논리 이름 또는 다른 위치의 이름은 방금 삭제 한 논리 이름을 대체합니다. 두 경우 모두 PERL_ENV_TABLES를 검색 한 첫 번째 값만 변경됩니다. 현재 % ENV를 통해 검색 목록 논리 이름을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c072f9ffbeb43d95b6bbc690c50b27ac90e561f" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;delete&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 의 요소가 정의 된 문자열로 설정되면 첫 번째 변환의 위치에서 해당 정의가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">어떤 이유로 설치에 실패한 후 오류 조건을 수정 한 후 다시 시도하면 CPAN.pm은 모듈 설치를 거부하고 &lt;code&gt;Already tried without success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">정의되지 않은 레이어 'foo'가 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 사양 에서 발견되면 C 코드는 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="40fb6d5dfd2c6aa613f88a6e49dba73d8dca4cc3" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">&quot;::: lib ::&quot;와 같은 updir 경로가 인수로 전달되면 올라갈 디렉토리의 수가 올바르게 처리되어 필요한 경우 선행 또는 후행 콜론을 제거하지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">대문자와 소문자가 모두 테이블에 존재하는 경우 대문자는 일반적으로 일종의 복합 유형 (목록 또는 해시)을 나타내는 데 사용되고 소문자는 해당 복합 유형의 요소를 나타내는 데 사용됩니다. 일부 내부 코드는이 사례 관계를 사용합니다. 그러나 'v'와 'V'(vec 및 v-string)는 전혀 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">작은 대문자를 사용할지 여부는 다소 까다로울 수 있으며 Pod :: Man이 꼭 맞지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">다음 명령 행에 적용될 때 :</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">압축 형식을 자동 감지하는 경우 &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; 모듈을 사용하여 lzma_alone 컨텐츠를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">압축 형식을 자동 감지하는 경우 &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; 모듈을 사용하여 raw-deflate (RFC 1951) 컨텐츠를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c2cde96752e55bde69311a35423f2dcc59f8d7b" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, this option can be used to turn on verbosity during the selection process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884ba24d0a86a83e3adb2e1fb93cb3394961f06" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, turn on the use of the external ping via Net::Ping::External. This is recommended in the case the local network has a transparent proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fe69040aadcae108c71d87a32f8d5b0102ff6a" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">두시 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 가 동시에 사용되며, 정규 표현식은 시작과 문자열, 즉, 정규 표현식은 전체 문자열과 일치의 끝을 모두 일치해야합니다. 치다</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">A와 P가 모두 정의되지 않은 경우 숫자를 나눌 때 대체 정확도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">64 비트 모듈을 빌드 할 때는 연결된 외부 라이브러리 및 프레임 워크가 64 비트 지원을 제공해야합니다. 그렇지 않은 경우 모듈 빌드는 성공한 것으로 보이지만 모듈을 사용하려고하면 런타임이 동적으로 나타납니다. 연결 오류 및 후속 테스트 실패 &lt;code&gt;file&lt;/code&gt; 을 사용 하여 라이브러리가 지원하는 아키텍처를 발견 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">Perl을 빌드 할 때 아직 아무것도 설치되지 않았으므로 항상 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">기호 링크가 활성화 된 ODS-5 볼륨에 구축 된 경우 Perl은 파일 시스템 및 CRTL (일반적으로 64 비트 OpenVMS v8.3 이상)에서 필수 지원을 사용할 수있는 경우 기본적으로 기호 링크를 지원합니다. VMS에서 심볼릭 링크로 작업 할 때주의해야 할 몇 가지 제한 사항과주의 사항이 있습니다. 특히, 유효한 기호 링크의 대상은 Unix 스타일 경로로 표현되어야하며 POSIX 루트에서 볼 수있는 볼륨에 존재해야합니다 ( DCL 도움말 의 &lt;code&gt;SHOW ROOT&lt;/code&gt; 명령 참조 ). 심볼릭 링크 기능 및 요구 사항에 대한 자세한 내용은 OpenVMS v8.3 이상과 함께 제공되는 CRTL 설명서의 12 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">번들링이 적용되는 경우 단일 문자 옵션에서도 대소 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">시간 또는 날짜 모듈의 테스트와 같은 특정 시간을 계산할 때 에포크에 대한 오프셋을 계산하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">스레드에서 호출 될 때 이는 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 와 같이 작동합니다 (즉, 종료 상태 코드는 무시됩니다).</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">에서 호출 될 때</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 &lt;code&gt;strtod&lt;/code&gt; 는 구문 분석 된 숫자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 &lt;code&gt;strtol&lt;/code&gt; 은 구문 분석 된 숫자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">리스트 컨텍스트에서 호출되면 열린 파일에 대한 파일 핸들과 파일 이름이 반환됩니다. 이것은 적절한 템플릿을 생성 한 후 mkstemp ()를 호출함으로써 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 임시 파일의 전체 이름 (경로 포함)을 리턴합니다 (mktemp () 사용). 유일한 점검은 파일이 아직 존재하지 않지만 해당 조건이 계속 적용된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">목록 컨텍스트의 해시에서 호출되면 해시의 다음 요소에 대한 키와 값으로 구성된 2 요소 목록을 리턴합니다. Perl 5.12 이상에서만 배열의 다음 요소에 대한 색인과 값을 리턴하므로이를 반복 할 수 있습니다. 이전 Perls는이를 구문 오류로 간주합니다. 스칼라 컨텍스트에서 호출되면 해시의 키 (값이 아님) 또는 배열의 인덱스 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">포트 번호로 호출하면 ping에 사용되는 포트 번호는 에코 포트를 사용하지 않고 $ port_number로 설정됩니다. 또한 특정 포트에 액세스 할 수있는 경우에만 ping이 성공적인 응답을 리턴하도록하는 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; 을 호출하는 효과 가 있습니다. 이 함수는 &lt;code&gt;ping()&lt;/code&gt; 이 연결할 포트 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bb2e5aa5eca539163667dc50950bd9be7faf4a0e" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to &lt;code&gt;$port_number&lt;/code&gt; rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; will connect to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">복합 형식으로 표현할 수없는 Perl 확장명 인 특성으로 호출하면이 함수는 현재 두 가지 가능한 값만 있으므로 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2e2733df3349090a28007f289ac824ddf07cc93b" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;undef&lt;/code&gt;, as the only two possible values are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">&lt;code&gt;Mksymlists&lt;/code&gt; 를 호출 할 때는 항상 NAME 속성을 지정해야합니다. 대부분의 경우 이것이 필요한 전부입니다. 그러나 비정상적인 확장의 경우 다른 속성을 사용하여 추가 정보를 링커에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b982cff05e80c95f9bd4378e83247343baa2a1" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt;, one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af437b4f9240cadad3ac33b8f68ddc8397121022" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;open&lt;/code&gt; with three or more arguments, the second argument -- labeled MODE here -- defines the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">언어를 선택할 때는 언어, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;환경&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;문화&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;지역 사회의&lt;/a&gt; 영향을 받아야 합니다.</target>
        </trans-unit>
        <trans-unit id="951b540f9fcad327b03714e446667ac4225ce0b0" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">새 솔트를 선택할 때 문자 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 나오는 임의의 2 문자열을 만듭니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). 이 문자 집합은 권장 사항입니다. 솔트에 허용되는 문자는 시스템의 크립 라이브러리에만 의존하며 Perl은 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 허용 하는 솔트를 제한 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">새 솔트를 선택할 때 문자 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 나오는 임의의 2 문자열을 만듭니다 (예 : &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). 이 문자 집합은 권장 사항입니다. 솔트에 허용되는 문자는 시스템의 크립 라이브러리에만 의존하며 Perl은 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 허용 하는 솔트를 제한 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e49bb7c565d73664ea0f3cf904e4a0b82673adbe" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt;). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; accepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45013cd9275f891a2dc688887309ce7d0907108" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple assignment to &lt;code&gt;state&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt;) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to &lt;code&gt;state&lt;/code&gt; declarations where the left hand side of the assignment involves any parentheses is currently undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">변수 선언과 결합하면 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 변수에 대한 간단한 스칼라 할당 ( &lt;code&gt;state $x = 42&lt;/code&gt; )은 처음으로 만 실행됩니다. 그러한 진술이 이후에 평가 될 때, 할당은 무시된다. 비-스칼라 변수에 대한 이러한 종류의 할당 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; 를 비교할 때는 문자열 비교 연산자를 &lt;b&gt;적극 권장&lt;/b&gt; 합니다. 이진 부동 소수점 표현의 고유 제한으로 인해 일부 아키텍처에서 일부 숫자에 대한 잘못된 비교가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63ec10981e83d5b4bca0c38c0d5eae2039c39d3" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt;, numeric comparison operators should be used, but the variable should be stringified first to avoid issues where its original numeric value is inaccurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db1f7efa45a9d6174eb5b40e9d8d8f3e843e34" translate="yes" xml:space="preserve">
          <source>When compiled within the scope of &lt;code&gt;use locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier), this construct assumes that the execution-time locale will be a UTF-8 one, and the generated pattern always uses Unicode rules. What gets matched or not thus isn't dependent on the actual runtime locale, so tainting is not enabled. But a &lt;code&gt;locale&lt;/code&gt; category warning is raised if the runtime locale turns out to not be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">Tru64에서 Perl을 컴파일 할 때 (컴파일러 릴리스에 따라) 다음과 같은 두 가지 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. AIX는 기본적으로 AIX와 함께 ANSI 호환 C 컴파일러를 제공하지 않지만 AIX 용 바이너리 gcc 빌드는 널리 사용 가능합니다. gcc 버전도 AIX와 함께 제공되는 AIX Toolbox에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. AIX는 기본적으로 AIX와 함께 ANSI 호환 C- 컴파일러를 제공하지 않지만 AIX 용 바이너리 gcc 빌드는 널리 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. 모든 HP-UX 시스템과 함께 제공되는 C 컴파일러는 새 커널을 빌드하는 데만 사용해야하는 K &amp;amp; R 컴파일러입니다.</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">PASE에서 컴파일 할 때는 &quot;oslevel&quot;명령이 없습니다. 따라서 PASE 런타임 버전이 지원하는 AIX 레벨을 에코하는 &quot;oslevel&quot;이라는 스크립트를 작성할 수 있습니다. 확실하지 않은 경우 설명서를 참조하거나 &quot;4.3.3.0&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">문자열을 보완 할 때 모든 문자에 256 미만의 서수 값이있는 경우 해당 문자열도 보완합니다. 그러나 그렇지 않은 경우 모든 문자는 아키텍처에 따라 32 비트 또는 64 비트 보수로 표시됩니다. 예를 들어, 32 비트 시스템 에서 &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; 이고 &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 64 입니다.</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">번들로 구성하면 단일 문자 옵션은 대소 문자를 구분하고 긴 옵션은 대소 문자를 구분하지 않습니다. 단일 문자 옵션과 대소 문자를 구분하지 않으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0832ec483e29be38d2d70bb452597a0c3e196f7f" translate="yes" xml:space="preserve">
          <source>When converting POD source from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">Symbian 또는 Series 60 또는 Series 80 또는 Series 90 용 API (Application Programming Interface)를 작성 및 확장 할 때 API 이름에 상표, 등록 상표 또는 상표 이름을 사용하지 않는 것이 좋습니다. 대신 개발자는 기존 (C ++ 또는 Java) 공용 구성 요소 및 API 명명에 기반하여 API 명명을 기본으로 고려해야하며, 새로운 API의 프로그래밍 언어 규칙에 따라 적절하게 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e1a716be153bacd455cdea13693b585d200816e" translate="yes" xml:space="preserve">
          <source>When data are cleaned and standardized, missing or invalid fields will be replaced with sensible defaults when possible. This may be lossy or imprecise. For example, some badly structured META.yml files on CPAN have prerequisite modules listed as both keys and values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">C 구조를 다룰 때 하나 하나 선택해야 &lt;b&gt;T_PTROBJ&lt;/b&gt; 또는 &lt;b&gt;T_PTRREF을&lt;/b&gt; XS를 유형. 두 유형 모두 복잡한 객체에 대한 포인터를 처리하도록 설계되었습니다. T_PTRREF 타입은 Perl 객체가 축복받지 못하게하는 반면 T_PTROBJ 타입은 객체가 축복 될 것을 요구합니다. T_PTROBJ를 사용하면 XSUB가 Perl 개체가 예상 형식인지 확인하려고 시도하기 때문에 형식 검사 형식을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 파일 (이진 모드의 텍스트 파일)을 다룰 때는 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 를 사용하기 전에 $ /를 파일 형식에 적절한 값으로 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2eed87ac3725b6497a344941a7436efeb6e56a3" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; to the appropriate value for your file format before using &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">참조를 다룰 때는주의해서 다루어야합니다. &lt;code&gt;INIT:&lt;/code&gt; 블록은 제 1 케이스 경로에 연결된 변수이다 SvGETMAGIC (경로)를 호출한다. 그런 다음 &lt;code&gt;SvROK&lt;/code&gt; 가 true를 반환 하는지 확인하여 경로가 유효한 참조임을 나타냅니다. &lt;code&gt;SvROK&lt;/code&gt; 를 확인 하면 연결된 변수에서 FETCH가 트리거되지 않습니다. 그런 다음 경로에서 참조하는 객체가 &lt;code&gt;SvRV&lt;/code&gt; 를 사용하여 경로를 참조하고 &lt;code&gt;SvTYPE&lt;/code&gt; 을 사용하여 해당 유형을 검색 하는 배열 인지 확인합니다. 추가 테스트로서 경로를 참조하는 배열이 비어 있지 않은지 확인합니다. &lt;code&gt;av_top_index&lt;/code&gt; 를 않은지 확인합니다.함수 (배열이 비어 있으면 -1을 반환). XSRETURN_UNDEF 매크로는 XSUB를 중단하고이 세 가지 조건이 모두 충족되지 않을 때마다 정의되지 않은 값을 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">8 비트 문자 세트를 사용하여 표현할 수없는 문자를 포함하는 문자열을 처리 할 때 perl은 허용 가능한 유니 코드 UTF-8 인코딩 버전 인 내부 표현을 사용합니다 [2]. 단일 바이트를 사용하여 ASCII 문자 세트의 문자를 나타내며 다른 모든 문자의 경우 2 바이트 이상의 시퀀스를 사용합니다. UTF-8과 perl의 인코딩 utf8 사이의 관계에 대한 자세한 정보는 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 를 참조하십시오 . 차이점은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">#!를 사용하는 스크립트를 디버깅 할 때 따라서 일반적으로 $ PATH에 있으며 -S 옵션을 사용하면 perl이 $ PATH를 검색하므로 경로 또는 &lt;code&gt;which $scriptname&lt;/code&gt; 을 입력 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="defb50e120fb7902c1ad7735f710efb52d461bf8" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c091d3205ab1a4db30cd1f652d642a63585b86ed" translate="yes" xml:space="preserve">
          <source>When defined, remove the legacy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd1aac87a1a4ead57eced3127ad85f26b16823a" translate="yes" xml:space="preserve">
          <source>When defining hints, you can either supply both &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; keywords,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">여러 상수를 정의 할 때 동일한 선언에 정의 된 다른 상수의 값을 사용할 수 없습니다. 호출 패키지는 해당 그룹 내에서 상수를 알지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ffb15fb0d6730c3726c9bf86322c62258c95b95a" translate="yes" xml:space="preserve">
          <source>When deleting a definition, this bit causes each &lt;code&gt;$sTargetPath&lt;/code&gt; to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then &lt;code&gt;$sTargetPath&lt;/code&gt; only needs to match a prefix of the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777270f296102b587f7b9de510c0b0ddda1bbd9" translate="yes" xml:space="preserve">
          <source>When describing the merge commit, explain the purpose of the branch, and keep in mind that this description will probably be used by the eventual release engineer when reviewing the next perldelta document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9045da0fde8e0464c72a9687c675b21416ee8e" translate="yes" xml:space="preserve">
          <source>When designing Maketext, I chose to plan its main features in terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">Perl과 C 라이브러리 사이의 인터페이스를 설계 할 때 C에서 XS 로의 직접적인 변환 (예 : &lt;code&gt;h2xs -x&lt;/code&gt; 작성 )으로 충분합니다. 그러나, 특히 C 함수가 매개 변수 중 하나를 수정하거나 실패 대역을 리턴 할 때 ( &quot;음수 리턴 값은 실패&quot;와 같이) 인터페이스가 C와 매우 유사하고 때로는 직관적이지 않은 경우가 있습니다. 프로그래머가보다 Perl과 유사한 인터페이스를 작성하려는 경우 다음 전략이 인터페이스의 더 중요한 부분을 식별하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2910d5c8edb2a11952d853cabc19faa12f6ab8" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt;) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">대화 형 및 / 또는 장기 실행 가능한 응용 프로그램을 개발할 때는 새로운 통역사를 여러 번 할당하고 구성하는 대신 영구 통역사를 유지하는 것이 좋습니다. 가장 큰 이유는 속도입니다. Perl은 한 번만 메모리에로드되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fbc30eeb77b449fcef99048d57b0caf5a9160153" translate="yes" xml:space="preserve">
          <source>When do I use SKIP vs. TODO?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">XS / Symbian C ++ 프로그래밍을 수행 할 때는 먼저 Symbian 헤더, 표준 C / POSIX 헤더, Perl 헤더 및 마지막으로 모든 애플리케이션 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">CPAN에서 다운로드 할 때 파일 을 &lt;code&gt;.tar.gz&lt;/code&gt; 대신 &lt;code&gt;.tgz&lt;/code&gt; 확장자로 저장하십시오 . 파일 이름의 다른 모든 마침표는 밑줄로 바꿔야합니다. 예를 들어, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; 로 다운로드해야합니다 &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Perl이 각 필터를 호출하면 &lt;code&gt;$_&lt;/code&gt; 의 로컬 사본에 필터링 할 키 또는 값이 포함됩니다. 필터링은 &lt;code&gt;$_&lt;/code&gt; 의 내용을 수정하여 수행됩니다 . 필터의 리턴 코드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="37bc6f2fee508f42f859a937c741e1314dc47c4d" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt;. The return code from the filter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">임베드 된 코드가 수량화되면, 성공적인 일치는 수량 자의 일치 된 각 반복마다 코드를 한 번 호출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">평가할 때 typeglob는 파일 핸들, 형식 또는 서브 루틴을 포함하여 해당 이름의 모든 오브젝트를 나타내는 스칼라 값을 생성합니다. 할당되면 언급 된 이름이 &lt;code&gt;*&lt;/code&gt; 값이 할당 된 것을 가리 킵니다 . 예:</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">의사 프로세스 내에서 exec ()를 호출하면 외부 프로세스가 리턴 된 후에도 DESTROY 메소드 및 END 블록이 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">프로그램 실행이 서브 루틴 호출에 도달하면 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="e34ca66c0a813d790613eb9e5cc3ba8d52f5c3fa" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">프로그램 실행에서 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용하여 비 XS 서브 루틴을 입력하고 0x80 비트가 &lt;code&gt;$^P&lt;/code&gt; 설정 되면 &lt;code&gt;$DB::sub&lt;/code&gt; 가 입력 된 서브 루틴의 이름을 보유하면서 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="46697cf78f9bb3bd5dc8972ced50ec3e3d6c90ea" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;goto&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt;, a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the subroutine being entered. The call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; does not replace the &lt;code&gt;goto&lt;/code&gt;; the requested subroutine will still be entered once &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; has returned. &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the subroutine being entered, if it has one. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the subroutine being entered. Unlike when &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is called, it is not guaranteed that &lt;code&gt;$DB::sub&lt;/code&gt; can be used as a reference to operate on the subroutine being entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">종료 코드가 0이 아닌 경우 메시지 상자가 나타나고 그렇지 않으면 콘솔이 닫히므로 출력을 보려면 프로그램에서 상태 0의 종료를 잡아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3c5ccbe8b2049e627d85f2a9ec69ec19650c45" translate="yes" xml:space="preserve">
          <source>When false the information is not considered critical and may not be rendered in less-verbose modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">필드 해시를 사용하는 경우 기본 구조는 동일하게 유지됩니다. 각 어휘 해시는 필드 해시가됩니다. 접근 자 메소드에서 &lt;code&gt;refaddr&lt;/code&gt; 에 대한 호출을 생략 할 수 있습니다. DESTROY 및 CLONE 메소드는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">실행할 프로그램을 찾을 때 Perl은 먼저 &lt;code&gt;PATH&lt;/code&gt; 에서 실행 파일을 찾도록 OS에 요청합니다 (OS / 2는 확장을 추가합니다)</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">완료되면 &lt;code&gt;$input&lt;/code&gt; 이 완전히 처리됩니다 (오류가 없다고 가정). 수축이 성공하면 수축 된 데이터를 &lt;code&gt;$output&lt;/code&gt; 쓰고 상태 값 &lt;code&gt;Z_OK&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="98115fd081a8900c4523336f3adbeaa8265d8ece" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcfed4a8d779393f6607570b9bb7471da1de1d1" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is actually a flow control statement rather than a function. If there is a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; statement (which is similar to the C &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCK이 뒤 따르면 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 실제로 함수가 아닌 플로우 제어 명령문입니다. BLOCK에 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK이 첨부 된 경우 (일반적으로 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;foreach&lt;/code&gt; ), C 의 &lt;code&gt;for&lt;/code&gt; 루프 의 세 번째 부분과 같이 조건부가 다시 평가되기 직전에 항상 실행 됩니다. 루프가 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 (C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 문과 유사 함)을 통해 계속 된 경우에도 루프 변수를 증가시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCK이 뒤 따르면 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 실제로 함수가 아닌 플로우 제어 명령문입니다. BLOCK에 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK이 첨부 된 경우 (일반적으로 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;foreach&lt;/code&gt; ), C 의 &lt;code&gt;for&lt;/code&gt; 루프 의 세 번째 부분과 같이 조건부가 다시 평가되기 직전에 항상 실행 됩니다. 루프가 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 (C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 문과 유사 함)을 통해 계속 된 경우에도 루프 변수를 증가시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">XS 소스 파일 내의 함수를 패키지로 분리해야하는 경우 PACKAGE 키워드를 사용해야합니다. 이 키워드는 MODULE 키워드와 함께 사용되며 사용될 때 바로 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">현지 시간이 모호한 경우 timelocal () 함수는 항상 에포크를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">PPCODE 섹션으로 출력 매개 변수를 처리 할 때 'set'마술을 올바르게 처리하십시오. 'set'마술에 대한 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bd61549e044c4efead59e04ed6605311709e2f3" translate="yes" xml:space="preserve">
          <source>When in doubt, before you do anything else, check your status and read it carefully, many questions are answered directly by the git status output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">확실하지 않으면 괄호로 묶으십시오. 최소한 &lt;b&gt;vi&lt;/b&gt; 의 % 키에서 일부 빈약 한 schmuck이 바운스되도록 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">의심 &lt;b&gt;스러운 경우 a2p를&lt;/b&gt; 통해 &lt;b&gt;awk&lt;/b&gt; 구문을 실행하고 그것이 무엇을 제공하는지 확인하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">의심스러운 경우 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; 로 호출되면 다음 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; 로 호출되면 다음 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">단일 문자열을 사용하여 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는 문자열을 구문 분석 옵션의 이름으로 취급하고 해당하는 경우 해당 값을 반환합니다 ( 없는 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 ).</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">여러 인수로 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는이를 키 / 값 쌍으로 처리하고 지정된 구문 분석 옵션 이름이 지정된 값으로 설정됩니다. 지정되지 않은 구문 분석 옵션은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">추가 인수없이 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는 모든 현재 구문 분석 옵션의 해시 테이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">매개 변수와 함께 호출되면 다음이 승인되고 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">부울은 언제 부울이 아닌가?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">단독으로 나타나면 시퀀스 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 및 Posix 문자 클래스가 ASCII 범위에서만 일치합니다. 따라서 그들은 5.6 이전의 유니 코드 이전의 의미로 되돌아갑니다. &lt;code&gt;/a&lt;/code&gt; 아래 에서 &lt;code&gt;\d&lt;/code&gt; 항상 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 부터 &lt;code&gt;&quot;9&quot;&lt;/code&gt; 까지 의 숫자를 정확하게 의미합니다 . &lt;code&gt;\s&lt;/code&gt; 는 다섯 개의 문자 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 를 의미하며 세로 탭 Perl v5.18에서 시작합니다. &lt;code&gt;\w&lt;/code&gt; 는 63자를 의미합니다. &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; 마찬가지로 &lt;code&gt;[[:print:]]&lt;/code&gt; 와 같은 모든 Posix 클래스 는 적절한 ASCII 범위 문자 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1727801b4e8e5e0fc9f27e13c40d768e93c5839d" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt;; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt;, and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e96b083a5b2fe4b1dd3f7bbb3653cb24d7adf0" translate="yes" xml:space="preserve">
          <source>When it comes to altering the behaviour of the test harness there's more than one way to do it. Which way is best depends on my requirements. In general if I only want to observe test execution without changing the harness' behaviour (for example to log test results to a database) I choose callbacks. If I want to make the harness behave differently subclassing gives me more control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">시공간 트레이드 오프와 관련하여 Perl은 거의 항상 문제가 발생했을 때 메모리를 버리는 것을 선호합니다. Perl의 스칼라는 C의 문자열보다 많은 메모리를 사용하고 배열은 그 이상을 사용하며 해시는 훨씬 더 많이 사용합니다. 아직해야 할 일이 많지만 최근 릴리스에서는 이러한 문제가 해결되었습니다. 예를 들어 5.004부터 중복 해시 키는이를 사용하는 모든 해시간에 공유되므로 재 할당 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 에서 경고를 트리거하는 정의되지 않은 변수에 대해서는 경고를 오류로 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4053c4973cee39e429495f57f5734c7c3b59da1" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;use warnings&lt;/code&gt;, you can promote the warning to an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">수렴하면 다음과 같은 기능적 변형이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">시작되면 디버거는 rc 파일을 읽습니다 (</target>
        </trans-unit>
        <trans-unit id="ab2f1658320564cc0ad685bee8d4cc13fa19d54b" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">항목이 지정된 해시 버킷에 충돌하면 체인에 저장된 순서를 Perl 5.18에서 더 이상 예측할 수 없습니다. 이것은 충돌을 관찰하기 어렵게하는 의도가있다. PERL_PERTURB_KEYS 환경 변수를 사용하여이 동작을 무시할 수 있습니다 . &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun의 PERL_PERTURB_KEYS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">로딩 할 때 &lt;a href=&quot;threads/shared&quot;&gt;스레드가 :: 공유&lt;/a&gt; , 당신은해야한다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 당신이 전에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . ( 다른 방법으로 &lt;code&gt;threads&lt;/code&gt; 를 수행하면 스레드 에서 경고가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="ad743799b7c94d4ac0b3c71cf0ab2ce52219a004" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541e2da58c9337557a4530af689d0206150a39ea" translate="yes" xml:space="preserve">
          <source>When local patches are applied with smoke testing, the test driver will automatically request regeneration of certain tables after the patches are applied. The Synology supplied Perl 5.8.6 (at least on the DS413) &lt;b&gt;is NOT capable&lt;/b&gt; of generating these tables. It will generate opcodes with bogus values, causing the build to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">를 찾을 때 &lt;code&gt;DBD::Oracle&lt;/code&gt; 검색 경로를 기준으로, 우리는 찾아야한다</target>
        </trans-unit>
        <trans-unit id="e429da2f9f9d1870d8a34d9bf7c8fc15e19b17ad" translate="yes" xml:space="preserve">
          <source>When matching files are extracted, ignore the directory path from the archive and write to the current directory using the basename of the file from the archive. Beware: if two matching files in the archive have the same basename, the second file extracted will overwrite the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeb796371e192f654f19b82f3385e933e7f2600" translate="yes" xml:space="preserve">
          <source>When moving backward it will not move before &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3206ee6854b0880fdd3279a57398bcb52c78786" translate="yes" xml:space="preserve">
          <source>When moving forward it will not move beyond &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">모듈 이름을 지정할 때 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="52dec4ed188cfa5b52a02969dbe527c5dc433e3b" translate="yes" xml:space="preserve">
          <source>When no BOM is found, Encode 2.76 and blow croaked. Since Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode Standard version 8.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">옵션에 대상을 지정하지 않으면 GetOptions는 결과 값을 &lt;code&gt;opt_&lt;/code&gt; 라는 전역 변수에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우이 변수가 가리키는 함수는 해당 OP를 인수로 사용하여 OP를 해제 할 때마다 호출됩니다. 이를 통해 확장은 OP에 로컬로 연결된 추가 속성을 해제 할 수 있습니다. 또한 먼저 부모 OP와 그 이후의 아이들을 위해 해고해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff599e171f439dd0c6a6547247e21662b9941e75" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt;, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">0이 아닌 경우이 옵션을 사용하면 bzip2는 압축 해제에 걸리는 시간을 늘리는 대신 메모리를 적게 사용하는 압축 해제 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ddf8b539ea05fcfe6aec1dc58d559038d4a8742" translate="yes" xml:space="preserve">
          <source>When not using &lt;code&gt;\o{...}&lt;/code&gt;, you wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. The resolution is as indicated, with all but the last digit treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">open ()에 명시적인 레이어 목록 (3 개 인수 구문 사용)이 제공되면이 pragma를 사용하여 선언 된 목록을 재정의합니다. 레이어 이름에 대해 open ()에 단일 콜론 (:)을 부여하여이 pragma를 재정의하고 기본값 ( &lt;code&gt;:raw&lt;/code&gt; , Windows의 경우 &lt;code&gt;:crlf&lt;/code&gt; )을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34ab00add652f226c09c30c65ec7e49ad76d8a0" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default as detailed in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">쓰기 위해 열면 파일의 빈 부분에 NULL (0x00) 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">파일을 열 때 요청이 실패한 경우 계속하지 않는 것이 좋습니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 . &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 원하는 작업을 수행하지 않더라도 (예를 들어 CGI 스크립트에서 적절한 오류 메시지를 형식화하려는 경우 (그러나 해당 문제를 해결하는 데 도움이되는 모듈이있는 경우)) 항상 파일 열기에서 반환 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">파일을 열 때 요청이 실패한 경우 계속하지 않는 것이 좋습니다. 따라서 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 . &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 원하는 작업을 수행하지 않더라도 (예를 들어 CGI 스크립트에서 적절한 오류 메시지를 형식화하려는 경우 (그러나 해당 문제를 해결하는 데 도움이되는 모듈이있는 경우)) 항상 파일 열기에서 반환 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="162aabd310aabb9968a3811cefafecae90daf2da" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;open&lt;/code&gt; is frequently used with &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. Even if you want your code to do something other than &lt;code&gt;die&lt;/code&gt; on a failed open, you should still always check the return value from opening a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892216513454a34d10fa999d477dbcc5ddbab374" translate="yes" xml:space="preserve">
          <source>When opening a handle, it will be opened with any layers specified explicitly in the open() call (or the platform defaults, if specified as a colon with no following layers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">단일 해시 참조를 전달하면 &lt;b&gt;parseopts&lt;/b&gt; 는 해당 해시를 사용하여 기존 구문 분석 옵션을 완전히 재설정하면 모든 이전 구문 분석 옵션 값이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">perl이 어휘 범위 (예 : 평가 본문, 필수 파일, 서브 루틴 본문, 루프 본문 또는 조건부 블록)를 제공하는 블록 구성을 구문 분석하기 시작하면 &lt;code&gt;$^H&lt;/code&gt; 의 기존 값 은 저장되지만 값은 변경되지 않습니다. 블록 컴파일이 완료되면 저장된 값을 다시 얻습니다. 값이 저장 및 복원되는 지점 사이에서 BEGIN 블록 내에서 실행되는 코드는 &lt;code&gt;$^H&lt;/code&gt; 값을 자유롭게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae5f7f62c62b7d34f56ec3574375a08840be5dee" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">펄이 &lt;code&gt;addop&lt;/code&gt; 과 같은 것을 실행하면 결과가 다음 연산에 어떻게 전달됩니까? 대답은 스택을 사용하는 것입니다. 펄은 현재 작업중인 것들을 저장할 수있는 스택을 가지고 있으며 여기서 가장 중요한 3 가지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0ad42676f2cea160c10d6e67d7270b962893b05d" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt;, how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">perl은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 표현식을 실행할 때 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 호출을 C 런타임 라이브러리에서 변환 한 다음 운영 체제 커널로 변환합니다. 펄은 &lt;code&gt;$!&lt;/code&gt; 이러한 호출 중 하나가 실패하면 C 라이브러리의 &lt;code&gt;errno&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="36c7954ee59f65366eedb8f27e4e9a6ca8de87ae" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;eval()&lt;/code&gt; expression, it translates the &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce54f632d505238352e1c6b81e21cf7c3c75f1" translate="yes" xml:space="preserve">
          <source>When perl is built with debugging enabled, there is a second part to this stack storing human-readable string names describing the type of stack context. Each push operation saves the name as well as the height of the save stack, and each pop operation checks the topmost name with what is expected, causing an assertion failure if the name does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">Perl이 메모리 풋 프린트 디버깅을 지원하도록 컴파일되면 (기본적으로 Perl의 malloc () 사용) Devel :: Peek는이 API에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">perl이 ithread를 사용하도록 구성되면 재진입이 아닌 버전보다 재진입 라이브러리 호출을 사용합니다. 4.5 이전 버전 의 FreeBSD의 &lt;code&gt;readdir_r&lt;/code&gt; 함수에는 큰 디렉토리를 읽을 때 SEGV를 유발할 수 있는 버그 가 있습니다. FreeBSD 4.6에 통합 된 FreeBSD libc 용 패치가 있습니다 ( &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">이 옵션이 있으면 입력 파일 / 버퍼에서 읽은 압축 바이트 수가 &lt;code&gt;$size&lt;/code&gt; 됩니다. 이 옵션은 압축 된 데이터 스트림 바로 뒤에 유용한 데이터가 있고 압축 된 데이터 스트림의 정확한 길이를 미리 알고있는 상황에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="000c8ae4987a475c6136e4e54de88628f059caa6" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt;. This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">여러 가지 다른 해석이있을 수있는 무언가가 제시 될 때 Perl은 &lt;b&gt;DWIM&lt;/b&gt; ( &quot;무엇을 의미합니까?&quot;) 원칙을 사용하여 가장 가능성있는 해석을 선택합니다. 이 전략은 매우 성공적이기 때문에 Perl 프로그래머는 종종 자신이 작성한 내용의 모호성을 의심하지 않습니다. 그러나 때때로 Perl의 개념은 저자가 정직하게 의미 한 것과 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">인쇄시 복소수는 일반적으로 직교 스타일로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">메시지가 표시되면 변경 사항을 요약 한 주제를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">항목을 &lt;code&gt;%^H&lt;/code&gt; 넣을 때 다른 해시 사용자와의 충돌을 피하기 위해 사용할 키에 관한 규칙이 있습니다. 모듈은 모듈 이름 (기본 패키지 이름)과 &quot;/&quot;문자로 시작하는 키만 사용해야합니다. 예를 들어, &lt;code&gt;Foo::Bar&lt;/code&gt; 모듈 은 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 와 같은 키를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a9430143108ce24dc19010d3dec0a88276a16a9" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt;, in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">파일 또는 파일 핸들에서 읽을 때는 읽기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0711f567d0b9b4a99904ebf4ffdf5f0a6e3dd27c" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;\n&lt;/code&gt;, but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">소켓에서 읽을 때 기본 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; 는 &lt;code&gt;\n&lt;/code&gt; 이지만 강력한 소켓 코드는 줄 끝으로 &lt;code&gt;\012&lt;/code&gt; 또는 &lt;code&gt;\015\012&lt;/code&gt; 로 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: AnyInflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: AnyUncompress는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Bunzip2는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Gunzip은 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Inflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: RawInflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Unzip은 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">참조하면 &lt;code&gt;$!&lt;/code&gt; C &lt;code&gt;errno&lt;/code&gt; 정수 변수 의 현재 값을 검색합니다 . 만약 &lt;code&gt;$!&lt;/code&gt; 숫자 값이 할당되면 해당 값은 &lt;code&gt;errno&lt;/code&gt; 에 저장됩니다 . 문자열로 참조 될 때 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; 에 해당하는 시스템 오류 문자열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="f4a6f2c4dbed65f11dd2dadedd0a40b92fb0de8b" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt;. When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">E &amp;lt;n&amp;gt; 숫자 코드를 사용하여 문자를 참조 할 때 32-126 범위의 숫자는 잘 알려진 US-ASCII 문자 (유일한 의미로 유니 코드로 정의 됨)를 나타내며 모든 포드 포맷터가 충실하게 렌더링해야합니다. . 개행에 대한 리터럴 바이트 순서 (ASCII 13, ASCII 13)를 제외하고 E &amp;lt;&amp;gt; 숫자가 0-31 및 127-159 범위에있는 문자는 리터럴 또는 E &amp;lt;번호&amp;gt; 코드로 사용하지 않아야합니다. 10 또는 ASCII 10) 및 탭 (ASCII 9).</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">새로운 범주의 경고를 등록 할 때 다음과 같이 warnings :: register에 더 많은 이름을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">디렉토리 트리를 제거 할 때 각 파일을 검사하여 파일을 삭제할지 여부를 결정하려면 (또는 큰 면봉 만 남겨 두어야 함),</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">주석을 허용하는 형식 (예 : 일반 텍스트 이외의 형식)으로 포드를 렌더링 할 때 포드 포맷터는 이름 및 버전 번호를 식별하는 주석 텍스트와 처리하는 데 사용중인 모든 모듈의 이름 및 버전 번호를 삽입해야합니다. 포드. 최소 예 :</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">두 가지 종류의 하이픈 (-)이있는 형식으로 포드를 렌더링 할 때, 하나는 끊지 않는 하이픈이고 다른 하나는 분리 할 수있는 하이픈입니다 ( &quot;객체 지향&quot;에서와 같이 &quot;개체-&quot;로 여러 줄로 나눌 수 있음) , 개행, &quot;중심&quot;), 포맷터는 일반적으로 &quot;-&quot;를 중단되지 않는 하이픈으로 변환하는 것이 권장되지만 휴리스틱을 적용하여 이들 중 일부를 끊는 하이픈으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">버그를보고 할 때 다음 점검표를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">버그 / 문제보고시 가능한 많은 정보를 포함하십시오. 거의 모든 설정이 다르기 때문에 문제를 재현하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">글로벌 DLL에 대한 요청을 해결할 때 이미로드 된 특정 DLL 테이블은 (효과적으로) 무시됩니다. 또한 특정 DLL은</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">C 배열을 Perl로 리턴 할 때 XS 기록기는 배열의 요소 수를 포함하는 &lt;code&gt;size_$var&lt;/code&gt; 이라는 정수 변수를 제공해야합니다 . 리턴 인수 스택에 몇 개의 요소를 푸시해야하는지 결정하는 데 사용됩니다. Perl은 루틴이 호출 될 때 스택에 몇 개의 인수가 있는지 알고 있으므로 입력시 필요하지 않습니다. 일반적으로이 변수는 &lt;code&gt;size_RETVAL&lt;/code&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="977e07d16b270182693f540dd1711d684d80c08a" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">널이 아닌 결과를 리턴 할 때 리턴 유형이 관련됩니다. AV 인 경우 AV의 요소는이 항목을 가리키는 약한 참조 RV입니다. 다른 유형이라면 항목 자체는 약한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">숫자를 반올림 할 때 다른 '스타일'또는 '종류'의 반올림이 가능합니다. (Math :: Round에서와 같이 임의의 반올림은 구현되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">실행될 때이 출력이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">스크립트를 실행하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">실행시 &lt;code&gt;perl Makefile.PL&lt;/code&gt; , 환경 변수 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; 는 의 전체 경로 설정 &lt;code&gt;Makefile.PL&lt;/code&gt; 실행되고있다. 이렇게하면 최신 버전의 Module :: Install을 사용하여 런 어웨이 프로세스를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89350694f65316ce98eae1ce7d3a0891e9c042c8" translate="yes" xml:space="preserve">
          <source>When running as the superuser, don't attempt drop privileges for security. This option is implied with &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04666da2a46dba8c376f71b404386c5bd13c8146" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was specified, neither PERL5LIB nor &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is consulted. The program should instead say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">프로그램이 setuid 또는 setgid를 실행 중이거나 &lt;b&gt;-T&lt;/b&gt; 또는 &lt;b&gt;-t&lt;/b&gt; 스위치가 지정되어 있기 때문에 오염 검사를 실행할 때 PERL5LIB 또는 PERLLIB는 참조되지 않습니다. 프로그램은 대신 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">이 프로그램을 실행할 때 &lt;code&gt;STDOUT&lt;/code&gt; 을 경로 재지 정하여 다음 테스트 실행에서 출력이 올바른지 확인하고 시스템 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용 하여 전체 런타임을 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="206d7f06e0a05581fe8e0f140b59c4f2ebd75b9b" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;time&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">Eunice에서 실행할 때이 변수에는 쉘 스크립트를 쉘에서 실행할 수 있도록 쉘 스크립트를 적절한 형식의 텍스트 파일로 변환하는 명령이 포함됩니다. 다른 시스템에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e969971baf41c84189fecb4a510a18aaa7b43b6a" translate="yes" xml:space="preserve">
          <source>When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6a46b32d19b77f807e82e4b0a5dbfd16227ea7" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;&quot;Unsafe signals&quot;&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">안전 신호가 적용되면 (기본 동작- 자세한 내용 은 &lt;a href=&quot;#Unsafe-signals&quot;&gt;안전하지 않은 신호&lt;/a&gt; 참조) 개별 스레드에서 신호를 보내고 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">결과에 만족하면 &lt;code&gt;installcmd&lt;/code&gt; 대상을 다시 실행하십시오 . 이제 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; 를 &lt;code&gt;perl.exe&lt;/code&gt; 로 복사 하고 다른 OMF 빌드 실행 파일 인 &lt;code&gt;perl__.exe&lt;/code&gt; 를 설치할 수 있습니다. 사용 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3274597eb7d5805f670851614bcfbd7d2f840a5" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt;, and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">소스를 저장할 때 서브 루틴을 생성하지 않는 에바를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">소스를 저장할 때 컴파일되지 않은 소스를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">단일 문자 분리 문자를 검색 할 때 이스케이프 분리 문자와 &lt;code&gt;\\&lt;/code&gt; 는 건너 뜁니다. 예를 들어, 종료 &lt;code&gt;/&lt;/code&gt; 를 검색하는 동안 &lt;code&gt;\\&lt;/code&gt; 와 &lt;code&gt;\/&lt;/code&gt; 조합 은 건너 뜁니다. 분리 문자가 브라케팅 인 경우 중첩 쌍도 건너 뜁니다. 폐쇄를 검색하는 동안, 예를 들어 &lt;code&gt;]&lt;/code&gt; 개구와 쌍 &lt;code&gt;[&lt;/code&gt; 의 조합 &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; 및 &lt;code&gt;\[&lt;/code&gt; 모두 생략하고, 중첩되어 &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 은 물론 생략된다. 그러나 백 슬래시가 구분 기호로 사용되는 경우 ( &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; )를 건너 뜁니다. 끝을 검색하는 동안 분리 문자 또는 다른 백 슬래시를 이스케이프 처리하는 백 슬래시는 제거됩니다 (정확하게 말하면 안전한 위치로 복사되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="15bd46317800c6a271d171bbf86328e23d6c92d4" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;qq\\&lt;/code&gt; and &lt;code&gt;tr\\\&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680861791c99e55f56913fa6b0dc2bd7ba150950" translate="yes" xml:space="preserve">
          <source>When sending an initial request to the security email address, please don't Cc any other parties, because if they reply to all, the reply will generate yet another new ticket. Once you have received an initial reply with a &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; ticket number in the headline, it's okay to Cc subsequent replies to third parties: all emails to the perl5-security-report address with the ticket number in the subject line will be added to the ticket; without it, a new ticket will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">로 설정하면 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 다음 횡단 키는 무작위됩니다. 해시가 키 순서에 삽입 될 때마다 임의의 방식으로 변경됩니다. PERL_HASH_SEED가 지정된 경우에도 다음 프로그램 실행에서 순서를 반복하지 못할 수 있습니다. 이것은 perl의 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">로 설정하면 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 다음 해시에 삽입 키는 변화에 키 순서를 야기하지만, 프로그램 실행에 프로그램 실행에서 반복하는 방법으로합니다.</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">true 값으로 설정하면 &lt;code&gt;remove_tree&lt;/code&gt; 가 VMS에 대한 삭제 권한과 같이 파일을 삭제하는 데 필요한 권한이없는 프로세스의 파일을 건너 뜁니다. 즉, 코드는 파일 권한을 변경하려고 시도하지 않습니다. 따라서 프로세스가 중단되면 파일 시스템 객체가 더 허용 가능한 모드로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">true로 설정하면 초기에 지정된 디렉토리를 제외한 모든 파일과 서브 디렉토리가 제거됩니다. 응용 프로그램의 스크래치 디렉토리를 정리할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a98ff16a4db26e40074379a02c1ac4736cef2e29" translate="yes" xml:space="preserve">
          <source>When set to true (default is false) this will reject any facets where a facet class cannot be found. Normally facets without classes are assumed to be custom and are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">설정하면 Data :: Dumper는 자체가 아닌 단일 값을 명령문이 아닌 원자 / 항으로 방출합니다. 이는 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">설정하면 네트워크 시간 초과 (초 단위)를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">설정하면 문자열 값을 나타내는 데 큰 따옴표를 사용할 수 있습니다. 공백 이외의 공백은 &lt;code&gt;[\n\t\r]&lt;/code&gt; 되고 &quot;안전하지 않은&quot;문자는 백 슬래시되며 인쇄 할 수없는 문자는 인용 된 8 진 정수로 출력됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9d1d9ef1336068db5d1ba9928d2591d51c52c62c" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt;, &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">언제 디코딩 또는 인코딩해야합니까?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">언제 Perl에서 프로그램해서는 안되나요?</target>
        </trans-unit>
        <trans-unit id="ab11b33195a0de9ef0d3f4bb14477223addc7e28" translate="yes" xml:space="preserve">
          <source>When some mandatory fields are missing or invalid, the conversion will attempt to provide a sensible default or will fill them with a value of 'unknown'. For example a missing or unrecognized &lt;code&gt;license&lt;/code&gt; field will result in a &lt;code&gt;license&lt;/code&gt; field of 'unknown'. Fields that may get an 'unknown' include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">무언가가 다른 것에 포함되어있을 때, 특히 놀라운 것으로 여겨 질 때 :&amp;ldquo;저는 완전한 Perl 인터프리터를 편집기에 내장했습니다!&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">정규 표현식에 대해 말할 때 소스 코드 형식과 내부 형식을 구별해야합니다. 이 문서에서는 텍스트, 소스 코드 형식, 내부 표현을 말할 때 &quot;프로그램&quot;이라는 용어를 사용할 때 &quot;패턴&quot;이라는 용어를 사용합니다. 이들은 용어에 해당합니다</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">모듈에 지정된 경우 (현지화 됨)</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">스크립트를 직접 시작할 때 Perl은 &lt;b&gt;-S&lt;/b&gt; 명령 행 옵션으로 지정된 스크립트를 검색 할 때와 동일한 알고리즘을 사용 합니다. 현재 디렉토리를 찾은 후 다음 순서의 추가 된 확장자를 사용하여 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 구성 요소를 찾습니다. : 연장 없음,</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">복식을 네트워크 순서로 저장하면 해당 값이 텍스트로 저장됩니다. 그러나 무한대 및 &quot;숫자가 아님&quot;과 같은 숫자가 아닌 부동 소수점 값이 nstore () / retrieve () 쌍을 통과 할 것으로 예상해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4e11b655699381504305f7887609ab8d634e504a" translate="yes" xml:space="preserve">
          <source>When stringified, &lt;code&gt;autodie::exception::system&lt;/code&gt; objects currently use the message generated by &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85058aaefb4d2e0a77cba44540a9a1fa5a2d7ef7" translate="yes" xml:space="preserve">
          <source>When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">응용 프로그램을 테스트 할 때 테스트 환경에서 일반적으로 외부 모듈에서 제공하는 기능을 제공해야하는 경우가 종종 있습니다. 이 외부 모듈을로드 된 것으로 표시하기 위해 수동으로 &lt;code&gt;%INC&lt;/code&gt; 를 뭉치기보다는 펄에 의해로드되지 않으려는 대신이 모듈은 모듈을로드 및 / 또는 언로드 된 것으로 표시하는 매우 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2ecf844cc9f858984bae81698225ab3522c9600d" translate="yes" xml:space="preserve">
          <source>When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event: &quot;I just LOVE hot apple pie!&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">해당 문자열이 대괄호 표기법에서 실제 Perl 하위로 컴파일되면 기본적으로 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">% o 변환에 # 플래그와 정밀도가 주어지면 선행 &quot;0&quot;에 필요한 경우 정밀도가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="aa880a320400827152fdc9bea63191360399d514" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag is set, the CV takes responsibility for freeing the slab. If &lt;code&gt;CvROOT&lt;/code&gt; is not set when the CV is freed or undeffed, it is assumed that a compilation error has occurred, so the op slab is traversed and all the ops are freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;all&lt;/code&gt; 매개 변수를 생략 또는 거짓되고, 그 해시 연결 요소는 관련된 해시 키의 이름으로 정의 좌측의 버퍼의 내용이 될 것이다. 즉, 묶인 해시는 &lt;code&gt;%+&lt;/code&gt; 로 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="b92065de5607bb0c7a77a48e1cfce97eed7a26ac" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;all&lt;/code&gt; 매개 변수를 제공하고, 그 연결된 해시 요소 이름 관련된 해시 키와 동일한 각 캡쳐 버퍼의 내용을 나열 어레이 심판 것이다. 이러한 버퍼 중 어느 것도 일치하지 않으면 해당 배열 참조의 내용은 해당 이름을 가진 캡처 버퍼 가있는만큼 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값이됩니다. 즉, 묶인 해시는 &lt;code&gt;%-&lt;/code&gt; 로 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="7e2197c6d3b3d6c61f6564ab44ac2b44c0344d23" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;undef&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">때 &lt;code&gt;exUnix2&lt;/code&gt; 의 옵션이 존재는 로컬 헤더 압축 (ID는 &quot;UX는&quot;임) Unix2 추가 필드의 생성을 트리거 할 것이다. &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 로 채워집니다 . 중앙의 zip 헤더에 빈 Unix2 추가 필드도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0db2965770fe8514e3fb9dd21cb17bd93496e99e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">때 &lt;code&gt;exUnixN&lt;/code&gt; 의 옵션이 존재는 로컬 및 중앙 압축 헤더 (ID는 &quot;UX&quot;임) UnixN 추가 필드의 생성을 트리거 할 것이다. &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 로 채워집니다 . UID 및 GID는 32 비트 정수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f94a510aaa8dc7a162e9738895fa3812cc690de5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">때 &lt;code&gt;frame&lt;/code&gt; 옵션을 설정, 디버거는 다른 스타일에서 서브 루틴을 입력 (선택적 종료) 인쇄 할 것이다. &lt;a href=&quot;perldebguts&quot;&gt;이것들에&lt;/a&gt; 대한 엄청나게 긴 예는 perldebguts 를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">CPAN 모듈을 처음 사용하는 경우 구성 대화 상자에서 몇 가지 사이트 별 옵션을 결정하려고합니다. 대화 상자의 결과는 CPAN / Config.pm 파일 의 해시 참조 &lt;code&gt; $CPAN::Config &lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">CPAN 쉘이 look 명령을 통해 서브 쉘에 들어가면 환경 CPAN_SHELL_LEVEL을 1로 설정하거나 이미 설정된 경우 해당 변수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">CPAN 쉘이 시작되면 일반적으로 실행중인 버전과 readline 지원 상태를 포함하는 인사말 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">SV를 읽거나 쓸 때 &lt;code&gt;uf_val&lt;/code&gt; 또는 &lt;code&gt;uf_set&lt;/code&gt; 함수는 &lt;code&gt;uf_index&lt;/code&gt; 를 첫 번째 인수로 사용하고 SV에 대한 포인터를 두 번째로 사용하여 호출됩니다 . &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 매직 을 추가하는 방법의 간단한 예 는 다음과 같습니다. ufuncs 구조는 sv_magic에 의해 복사되므로 스택에 안전하게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Storable 엔진이 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 후크 루틴을 찾지 못하면 패키지를 동적으로 요구하여 (축복 된 패키지 이름 사용) 클래스를로드 한 다음 조회를 다시 시도합니다. 그때 후크를 찾을 수 없으면 엔진이 삐걱 거립니다 동일한 파일에 여러 클래스를 정의하면이 메커니즘이 실패하지만 &lt;a href=&quot;perlmod&quot;&gt;perlmod가&lt;/a&gt; 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d71b47dffe6d13e95919a44f8b1aab3c74c9a2ad" translate="yes" xml:space="preserve">
          <source>When the Windows and Arm DLLs are built do not be scared by a very long messages whizzing by: it is the &quot;export freeze&quot; phase where the whole (rather large) API of Perl is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">자식의 실제 VMS 종료 상태가 오류 인 경우 내부적으로 &lt;code&gt;$!&lt;/code&gt; 오류 메시지를 테스트하는 Perl 스크립트가 VMS 메시지 대신 예상되는 Unix 스타일 오류 메시지를 볼 수 있도록 value가 해당 오류에 가장 가까운 Unix errno 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">인수가 시스템 셸을 통해 실행되면 결과에 문제가 생길 수 있습니다. 자세한 내용 &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;은 perlop의`STRING`을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca28137b7d4a24f80f2a308158da006f7dc35dce" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">인수가 시스템 셸을 통해 실행되면 결과에 문제가 생길 수 있습니다. 자세한 내용 &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;은 perlop의`STRING`을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="7a639b80ea13083bb656ad3ace22f1641521ba99" translate="yes" xml:space="preserve">
          <source>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569274b14b45a92ddaed7462d32bdd3f4354e2b9" translate="yes" xml:space="preserve">
          <source>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ba3a0afa8ccd6c06c8d4acfe9a1d04b1ddc937" translate="yes" xml:space="preserve">
          <source>When the build environment has been set up, building and testing Perl is straightforward. The only thing you need to do is download the sources as usual, and add a file Policy.sh as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ca0edd57c85a2b69cd25fb457d6653721de135" translate="yes" xml:space="preserve">
          <source>When the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">클래스가 &lt;code&gt;/i&lt;/code&gt; 일치 규칙에서 대소 문자를 구분하지 않고 클래스 내부에서 명시 적으로 언급 된 문자가 유니 코드 규칙에서 대소 문자없이 여러 문자 시퀀스를 일치시키는 경우 클래스도 해당 순서와 일치합니다. 예를 들어, 유니 코드 문자 말한다 &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 는 시퀀스와 일치해야 &lt;code&gt;ss&lt;/code&gt; 아래에 &lt;code&gt;/i&lt;/code&gt; 규칙. 그러므로,</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">코드가 2 개 또는 3 개의 운영 체제에서만 실행될 경우 해당 특정 시스템의 차이점 만 고려해야합니다. 중요한 것은 코드가 실행될 위치를 결정하고 신중하게 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">구성 변수 ftp_passive가 설정되면 환경 변수 FTP_PASSIVE가이 값으로 설정된 상태에서 모든 다운로드가 실행됩니다. Net :: FTP 및 LWP 기반 연결 모두에 영향을 미치므로 일반적으로 좋은 생각입니다. 이 환경 변수 세트로 cpan 쉘을 시작하면 동일한 효과를 얻을 수 있습니다. Net :: FTP 단독의 경우 libnetcfg를 실행하여 항상 수동 모드를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c69bf3ddadf947bad50c1663c482207ed7bb54" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;dbi&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">데이터베이스에 UTF-8 만 포함 된 경우 래퍼 함수 또는 메소드는 모든 &lt;code&gt;fetchrow_array&lt;/code&gt; 및 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 호출 을 대체하는 편리한 방법 입니다. 랩퍼 기능을 사용하면 데이터베이스 드라이버의 향후 개선 사항에보다 쉽게 ​​적응할 수 있습니다. 이 글을 쓰는 시점 (2012 년 1 월)에 DBI는 UTF-8 데이터를 처리하는 표준화 된 방법이 없습니다. 체크하시기 바랍니다 &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI 문서를&lt;/a&gt; 그 여전히 해당하는 경우 확인합니다.</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">프로그램 실행이 중단 점을 보유 할 수있는 지점에 도달 하면 변수 &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; 또는 &lt;code&gt;$DB::signal&lt;/code&gt; 가 true 인 경우 &lt;code&gt;DB::DB()&lt;/code&gt; 서브 루틴이 호출됩니다. . 이러한 변수는 아니다 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; izable. 이 기능은 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; 이 (가 ) 아닌 경우 호출 된 함수를 포함하여 &lt;code&gt;DB::DB()&lt;/code&gt; 내부에서 실행할 때 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="203a255f166a15d5d314005ac0db0ee5bd633f84" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt;, &lt;code&gt;$DB::single&lt;/code&gt;, or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;local&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt;, including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">파일이</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">처리중인 파일이 작을 때는 어떤 방식 으로든 중요하지 않지만 더 커지기 시작하면 큰 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42ad95e8f7eb1ea8f7a7febcc136ac0e51ac7e9" translate="yes" xml:space="preserve">
          <source>When the first bad commit is isolated, &lt;code&gt;git bisect&lt;/code&gt; will tell you so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc397f7438e86b99c564236153e8faa95f5c6e3" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbrlen&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f6d7004331625d3362cc91973ffa26e2885b63" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar, the code point contained in the scalar second parameter is converted into a multi-byte string and stored into the first parameter scalar. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. The return value is the number of bytes stored; or negative if the code point isn't representable in the current locale. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;wctomb&lt;/code&gt; and &lt;code&gt;wcrtomb&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67993cdc0054c70b8cf1f3b164eab66d68fabca" translate="yes" xml:space="preserve">
          <source>When the hash is tied dispatches through to the SCALAR method, otherwise returns a mortal SV containing the number of keys in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">내부 서브 루틴이 호출되면, 외부 서브 루틴에 대한 * first * 호출 이전과 그 동안 외부 서브 루틴의 어휘 서브 루틴 값이 표시됩니다. 이 경우, 외부 서브 루틴에 대한 첫 번째 호출이 완료된 후, 내부 및 외부 서브 루틴은 더 이상 어휘 서브 루틴에 대한 공통 값을 공유하지 않습니다. 즉, 더 이상 공유되지 않습니다. 어휘 서브 루틴이 주변 범위에 선언 된 어휘 변수에 액세스하는 경우 특히 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">내부 서브 루틴이 호출되면 외부 서브 루틴에 대한 * first * 호출 이전과 호출 동안의 외부 서브 루틴 변수 값이 표시됩니다. 이 경우, 외부 서브 루틴에 대한 첫 번째 호출이 완료된 후 내부 및 외부 서브 루틴은 더 이상 변수의 공통 값을 공유하지 않습니다. 즉, 변수가 더 이상 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">객체에 대한 마지막 참조가 사라지면 객체가 파괴됩니다. 어휘 스칼라에 저장된 오브젝트에 대한 참조가 하나만있는 경우 해당 스칼라가 범위를 벗어나면 오브젝트가 삭제됩니다. 패키지 전역에 개체를 저장하면 프로그램이 종료 될 때까지 해당 개체가 범위를 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 통화의 일부로 레이어를 푸시하면 &lt;code&gt;PUSHED&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="01a59251b1866e239efdc75d52f126badadf6773" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;open&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">계층을 푸시하면 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; 의 현재 값 이 저장되어 Encode 메서드 encode () 및 decode ()를 호출 할 때 CHECK 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">lib 모듈이 처음로드되면 @INC의 현재 값을 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; 배열에 기록합니다 . @INC를 그 값으로 복원하려면 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9f47c78a4b7c6bf48658f90ad7bb90a6f2c2f03" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt;. To restore @INC to that value you can say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">일치가 실행되면 정규식의 첫 부분 ( &lt;code&gt;\b(foo)&lt;/code&gt; )은 문자열의 시작 부분에서 가능한 일치를 찾고 &quot;Foo&quot;를 사용하여 $ 1을로드합니다. 그러나 일치하는 엔진이 $ 1에 저장 한 &quot;Foo&quot;뒤에 공백이 없다는 것을 알게 되 자마자 실수를 인식하고 잠정적으로 일치 한 위치에서 한 문자를 다시 시작합니다. 이번에는 다음 번 &quot;foo&quot;가 나타날 때까지 계속 진행됩니다. 완전한 정규 표현식이 이번에는 일치하고 &quot;table follows foo&quot;의 예상 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="59438c31be63ed00a2828de2f2dbb82ccfc7a3c2" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt;) finds a possible match right at the beginning of the string, and loads up &lt;code&gt;$1&lt;/code&gt; with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in &lt;code&gt;$1&lt;/code&gt;, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a3d6c13049ca137ffa9c8c06a835f3079e4b4a" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &lt;a href=&quot;#unlink1&quot;&gt;unlink1&lt;/a&gt;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">객체가 범위를 벗어나면 소멸자가 호출됩니다. 이 소멸자는 파일을 연결 해제하려고 시도합니다 (L을 사용하여</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">최적화 기준이 충족되면 일치를 수행하기 위해 &lt;code&gt;reg_try()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">출력이 파일 이름 인 경우 압축 된 데이터를 쓰기 전에 파일의 내용을 자릅니다. 출력이 파일 핸들 인 경우 위치가 변경되지 않습니다. 출력이 버퍼 인 경우 압축 된 데이터가 출력되기 전에 지워집니다.</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">출력이 파일 이름 인 경우 압축되지 않은 데이터를 쓰기 전에 파일의 내용을 자릅니다. 출력이 파일 핸들 인 경우 위치가 변경되지 않습니다. 출력이 버퍼 인 경우 압축되지 않은 데이터가 출력되기 전에 지워집니다.</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">프로그램이 종료되면 표준 텍스트 필터링 유틸리티를 사용하여 출력을 검사하고 정렬 할 수 있습니다. 다음과 같은 것이 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">스크립트가 종료되고 생성 된 일부 값을 변경하려는 경우</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">스크립트가 종료되면 프로파일 러는 프로파일 러 도구를 사용하여 보고서로 전환 할 수있는 프로파일 정보 데이터베이스를 작성합니다. 자세한 내용은 &amp;lt;perlperf&amp;gt;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd423c011519f7f605565c27b285e9b7433164a6" translate="yes" xml:space="preserve">
          <source>When the second parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mbtowc&lt;/code&gt; and &lt;code&gt;mbrtowc&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">문자열에 코드 포인트 &lt;code&gt;\N{...}&lt;/code&gt; 이라는 유니 코드가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">문자열에 유니 코드 전용 코드 포인트가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="dff4dc2cfa7ab4f3143ca1c8cea9659a2fba0df1" translate="yes" xml:space="preserve">
          <source>When the string has been upgraded to UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">문자열이 유니 코드로 표시된 외부 소스에서 온 경우</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">오염 모드 ( &lt;code&gt;-T&lt;/code&gt; )가 적용되면 &quot;.&quot; &lt;code&gt;@INC&lt;/code&gt; 에서 디렉토리가 제거되고 환경 변수 &lt;code&gt;PERL5LIB&lt;/code&gt; 및 &lt;code&gt;PERLLIB&lt;/code&gt; 는 Perl에 의해 무시됩니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 설명 된대로 &lt;code&gt;-I&lt;/code&gt; 명령 행 옵션을 사용하여 프로그램 외부에서 &lt;code&gt;@INC&lt;/code&gt; 를 조정할 수 있습니다 . 두 환경 변수는 가려져 무시되므로 프로그램을 실행하는 사용자는 설정 여부를 알지 못하는 반면 &lt;code&gt;-I&lt;/code&gt; 옵션은 명확하게 표시되므로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e34514e5e3372fed96ae586191867c70ca14aae4" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt;) is in effect, the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">테스트 파일이 완료되면 요약을 함께 출력합니다.</target>
        </trans-unit>
        <trans-unit id="5d3ce74817cdede8942c8b771dd9c729dbff5404" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; was only available when the &lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt;&lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature&lt;/a&gt; was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCK이 없으면 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 동적으로 동봉하는 &lt;code&gt;foreach&lt;/code&gt; 를 반복 하거나 &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; 어휘 동봉을 종료하는 대신 현재 &lt;code&gt;when&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 블록을 통과하는 함수입니다 . Perl 5.14 이하에서는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능이 활성화 된 경우에만 이 형태의 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있었습니다. 자세한 내용 &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 &lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;기능&lt;/a&gt; 및 스위치 문 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCK이 없으면 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 동적으로 동봉하는 &lt;code&gt;foreach&lt;/code&gt; 를 반복 하거나 &lt;code&gt;given&lt;/code&gt; 어휘 동봉을 종료하는 대신 현재 &lt;code&gt;when&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 블록을 통과하는 함수입니다 . Perl 5.14 이하에서는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능이 활성화 된 경우에만 이 형태의 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있었습니다. 자세한 내용 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 &lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 및 스위치 문 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">메소드가없는 경우 메소드 이름을 인코딩 이름으로 사용하고 인스턴스를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">이들이 다른 패턴에 임베드되면 괄호 나 외부 패턴에 어떤 수정자가 적용되는지에 관계없이 일치하는 항목이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc5872b9a322af5576c1ac03e71331c1716252c8" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern. If you fail to compile the subcomponents, you can get some nasty surprises. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1810832e010e811c7366d9b862298011ff2e0aa6" translate="yes" xml:space="preserve">
          <source>When this bit is set, &lt;code&gt;$sNewName&lt;/code&gt; can be &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt;] to indicate that &lt;code&gt;$sOldName&lt;/code&gt; should be deleted during the next boot rather than renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">이 코드가 실행되면 출력이 없습니다. 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">이 코드가 실행되면 &lt;code&gt;Derived&lt;/code&gt; 객체 인 &lt;code&gt;$b&lt;/code&gt; 만 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9309453554803d7d3570d025f7e35cec80cda5d1" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt;, will generate a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">이 코드가 &lt;b&gt;-w&lt;/b&gt; 플래그 와 함께 실행 되면 &lt;code&gt;$a&lt;/code&gt; 행에 대해 &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 경고가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2388e2ced3b75ec3bd369e3152eae13dfe498282" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">이 형식의 pragma를 사용하는 경우 로케일의 문자가 아닌 부분 만 Perl에 의해 사용됩니다 (예 : &lt;code&gt;LC_NUMERIC&lt;/code&gt; ) . Perl은 작동하는 모든 문자를 유니 코드 (실제로 플랫폼의 기본 문자 세트 (ASCII 또는 EBCDIC)와 유니 코드)로 변환했다고 가정합니다. 파일의 데이터의 경우 다음을 지정하여 편리하게 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="db1567ebb35e094978d64dee42e25f3b2f3257aa" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt;. Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">이 함수가 호출되면</target>
        </trans-unit>
        <trans-unit id="e9e65ea3d452091e9942f0f5039cb9a617322586" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_checker&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_checker_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_checker&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_checker_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_checker&lt;/code&gt; is called. If &lt;code&gt;new_checker&lt;/code&gt; decides not to do anything special with an op that it is given (which is the usual case for most uses of op check hooking), it must chain the check function referenced by &lt;code&gt;*old_checker_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4ee6516decf05e05dd9bd8fd17984cd79424b" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_plugin&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_plugin_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_plugin&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_plugin_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_plugin&lt;/code&gt; is called. If &lt;code&gt;new_plugin&lt;/code&gt; decides not to do anything special with the identifier that it is given (which is the usual case for most calls to a keyword plugin), it must chain the plugin function referenced by &lt;code&gt;*old_plugin_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa02f2fe554bd2a9b6a103fe9beb89d9b4e4476" translate="yes" xml:space="preserve">
          <source>When this happens, you can just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">이로 설정하면 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; 자동적로부터 유도 될 &lt;code&gt;O_FILES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="447329d526fb82114543e70fb22d4772337fe346" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4611cd8d92449087862ca322a574ebe794802885" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, multiple XS files may be placed under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">이것이 참이면 CPAN은 PERL_MM_USE_DEFAULT를 참 값으로 설정합니다. 이로 인해 ExtUtils :: MakeMaker (및 호환 가능) 프롬프트가 멈추지 않고 기본값을 사용하여 질문에 대한 프롬프트를 표시합니다. 또한 NONINTERACTIVE_TESTING을 실제 값으로 설정하여 분배가 사용자와 상호 작용하지 않아야 함을 더 일반적으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="e48ad08805e823db4cab572ed48a495b3413c960" translate="yes" xml:space="preserve">
          <source>When this option is set to true AND the zip archive being read has the &quot;Language Encoding Flag&quot; (EFS) set, the member name is assumed to be encoded in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">여전히 local ()을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">OO를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="7fe9c30c4e2d69806274da4a183bd0637abe22d6" translate="yes" xml:space="preserve">
          <source>When true the entire test should be skipped. This is usually paired with an explanation in the &lt;code&gt;details&lt;/code&gt; field, and a &lt;code&gt;control&lt;/code&gt; facet that has &lt;code&gt;terminate&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">true 인 경우이 매개 변수는 gzip 헤더에서 FLG.FHCRC 비트를 1로 설정하고 CRC16 필드 자체를 제외하고 CRC16 헤더 필드를 전체 gzip 헤더의 CRC로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">true 인 경우 'cpansign -s'를 통해 'make distdir'중에 distdir에서 SIGNATURE 파일의 MANIFEST 생성 및 추가를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">true 인 경우 &lt;code&gt;perllocal&lt;/code&gt; 에 설치를 추가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ff5bff80188d068a00e6b218733a6d5345f2c3a2" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">true 인 경우 'make distdir'중에 META.yml 및 META.json 모듈 메타 데이터 파일의 MANIFEST에 대한 생성 및 추가를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">true 인 경우 'perl Makefile.PL'동안 MYMETA.yml 및 MYMETA.json 모듈 메타 데이터 파일 생성을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">true 인 경우 설치를위한 &lt;code&gt;packlist&lt;/code&gt; 파일 쓰기를 억제 합니다.</target>
        </trans-unit>
        <trans-unit id="72af2071def396f7be81fd1ce806195fb7b786b5" translate="yes" xml:space="preserve">
          <source>When true, the tempdir used by the IPC driver will not be deleted when the test is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">스택을 설명하려고 할 때, 대부분의 컴퓨터 과학 교과서는 스프링 식 카페테리아 판 열에 대해 무언가를 혼동합니다. 스택에 마지막으로 밀었던 것은 가장 먼저 터지는 것입니다. 그것은 우리의 목적을 위해 할 것입니다 : 당신의 C 프로그램은 어떤 인수를 &quot;펄 스택&quot;에 밀어 넣고, 마술이 일어나는 동안 눈을 감은 다음, 스택에서 펄 서브 루틴의 반환 값인 결과를냅니다.</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">핸들을 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 때 첫 번째로 묶을 인수 는 별표로 시작해야합니다. 따라서 STDOUT을 묶는 경우 &lt;code&gt;*STDOUT&lt;/code&gt; 을 사용하십시오 . 이를 스칼라 변수 (예 &lt;code&gt;$handle&lt;/code&gt; 지정한 경우 &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; 은 내부 &lt;code&gt;$handle&lt;/code&gt; 이 아닌 스칼라 변수 $ handle을 묶 습니다.</target>
        </trans-unit>
        <trans-unit id="db73b1d8c34ba44728cad3d2b1f319f02e5b59fc" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;tie&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt;. If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt;, use &lt;code&gt;*$handle&lt;/code&gt;. &lt;code&gt;tie $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt;, not the handle inside it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ae376ab632badfb7a32a894228e134f3e11c" translate="yes" xml:space="preserve">
          <source>When uncompressing with &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt;, it will automatically detect if the zip file is zip64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">클래스 메소드 ( &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , 때로는 정적 메소드라고도 함)로 사용될 경우 &lt;code&gt;isa&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="1f0c66833fbe6e1b03af60ec0fe15b9334c1979b" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt;, sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75a54bcbf3526f0df59166b3d1ecbeabab7eb5" translate="yes" xml:space="preserve">
          <source>When used as a class method the &lt;code&gt;\%facet_data&lt;/code&gt; argument is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">필터로 사용될 때 다음과 같이 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">인스턴스 또는 클래스 메소드 ( &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ) 로 사용될 경우 &lt;code&gt;isa&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="0c835a1bdea740af7b69e93efd47e9739cc62c50" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt;), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee80d9e31f7273254ea3de17e8c9cb461c0c08a0" translate="yes" xml:space="preserve">
          <source>When used as an object method the &lt;code&gt;\%facet_data&lt;/code&gt; argument may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac020145ba791bbcde686e21207104ab4efac0" translate="yes" xml:space="preserve">
          <source>When used as methods, all these subroutines call &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt;. The default &lt;code&gt;facet_data()&lt;/code&gt; method in &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; relies on the legacy methods this module emulates in order to work. As a result of this it is very easy to create infinite recursion bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">이와 같이 사용하면 옵션과 가능한 값이 &lt;code&gt;@myopts&lt;/code&gt; 에서 제거되고 전역 &lt;code&gt;@ARGV&lt;/code&gt; 는 전혀 손대지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80c8f7c123cd2630d333f7d9131c53ccb92cec1a" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">이렇게 사용하면 :</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">해시 요소에서 사용될 때 키가 해시에 있는지 여부가 아니라 값이 정의되었는지 여부를 알려줍니다. 사용은 &lt;a href=&quot;#exists&quot;&gt;존재&lt;/a&gt; 후자의 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="3ea5744253b0aebebea0a675efdda097478c50c9" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; for the latter purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">해시 요소에서 사용될 때 키가 해시에 있는지 여부가 아니라 값이 정의되었는지 여부를 알려줍니다. 사용은 &lt;a href=&quot;exists&quot;&gt;존재&lt;/a&gt; 후자의 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">배열 또는 해시의 요소에서 사용되는 경우 &lt;code&gt;is_shared&lt;/code&gt; 는 지정된 요소가 공유 배열 또는 해시에 속하는지 확인합니다. 해당 요소의 내용을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">Perl 목록을 C로 전달하는 데 사용될 때 XS 작성기는 목록을 보유하는 데 필요한 메모리를 할당하는 함수 (배열 유형의 이름을 지정하지만 'Ptr'이 '*'로 대체 됨)를 제공해야합니다. 포인터가 반환되어야합니다. 함수에서 나갈 때 메모리를 해제하는 것은 XS 작성기에 달려 있습니다. &lt;code&gt;ix_$var&lt;/code&gt; 변수 는 새 배열의 요소 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">와 함께 사용하는 경우 &lt;code&gt;.&lt;/code&gt; 반복 횟수는 다음과 같이 값 오프셋을 계산할 시작 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 와 함께 사용될 때 반복 횟수는 가장 안쪽 &lt;code&gt;()&lt;/code&gt; 그룹 의 시작부터 오프셋을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="452ac7244192f1d1049652316194fb25f11bd124" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt;, the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">함께 사용하면 &lt;code&gt;Z&lt;/code&gt; 하는 &lt;code&gt;*&lt;/code&gt; 결과 문자열이 항목 자체의 바이트 길이보다 한 바이트 이상 항상 있도록 반복 횟수로는, 뒤에 널 바이트를 추가로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">클래스 메소드와 함께 사용하면 문제가 더욱 악화됩니다. Perl에서는 서브 루틴 이름을 베어 워드로 작성할 수 있으므로 Perl은 메소드 뒤의 베어 워드가 클래스 이름인지 서브 루틴 이름인지 추측해야합니다. 즉, Perl은 구문을 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;또는 &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 로 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">명령 행 옵션과 함께 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">userelocatableinc가 true 인 경우,이 변수는 설치시 perl 2 진을 복사해야하는 위치를 설치시 모든 런타임 재배치 가능 경로로 계산합니다. 사용하면 binexp의 원래 값으로 초기화되고 binexp는</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 그룹 에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 사용하면 모든 하위 그룹을 포함하여 바이트 순서 수정자를 허용하는 그룹 내의 모든 유형에 영향을줍니다. 다른 모든 유형에서는 자동으로 무시됩니다. 이미 바이트 순서 수정 자 접미어가있는 그룹 내에서 바이트 순서를 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;Exporter&lt;/code&gt; 기준으로 &lt;code&gt;strict&lt;/code&gt; 및 &lt;code&gt;warnings&lt;/code&gt; 프라 그마는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 키워드는 패키지 변수 선언 할 필요가 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">&lt;code&gt;IPC::Open3&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 을 사용할 때 &lt;code&gt;command&lt;/code&gt; 인수 로 문자열을 제공하면 적절하게 이스케이프 된 것으로 간주됩니다. &lt;code&gt;QUOTE&lt;/code&gt; 상수를 사용하여 이식 가능한 인용 문자로 사용할 수 있습니다 (위 참조). 그러나 배열 참조를 제공하는 경우 특수 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; 사용할 때 &lt;code&gt;command&lt;/code&gt; 인수 로 문자열을 제공 하면 문자열이 공백으로 분할되어 명령의 개별 요소를 판별합니다. 이것은 일반적으로 의미하는 바를 수행하지만 파일이나 명령에 공백이 있으면 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">사용자 서브 루틴과 함께 &lt;code&gt;autodie&lt;/code&gt; 또는 &lt;code&gt;Fatal&lt;/code&gt; 을 사용할 때 해당 서브 루틴 선언은 &lt;code&gt;Fatal&lt;/code&gt; 또는 &lt;code&gt;autodie&lt;/code&gt; 를 처음 사용하기 전에 나타나 거나 모듈에서 내 보내야 합니다. 다른 사용자 서브 루틴에서 &lt;code&gt;Fatal&lt;/code&gt; 또는 &lt;code&gt;autodie&lt;/code&gt; 를 사용하려고 하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;fd_retrieve&lt;/code&gt; 를 사용하면 연관된 &lt;code&gt;store_fd&lt;/code&gt; 당 하나의 오브젝트 (즉, 하나의 재귀 트리)로 오브젝트가 순서대로 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">GCC를 사용할 때, 해당 항목은 MakeMaker가 먼저 &lt;code&gt;$Config{libpth}&lt;/code&gt; 의해 지정된 모든 위치에서 &lt;code&gt;libgl.a&lt;/code&gt; ( &lt;code&gt;gl.a&lt;/code&gt; )를 찾도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">Module :: Build를 사용할 때 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">PUSHCOLOR, POPCOLOR 및 LOCALCOLOR를 사용할 때 상수 사이에 쉼표를 사용하지 않는 것이 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">Term :: ReadLine을 사용할 때 입력을 CPAN.pm의 출력에 대해 두드러 지도록 장식품을 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">Unix 또는 MSDOS 구문을 사용 하는 경우 &lt;code&gt;fileparse()&lt;/code&gt; 작동 방식과 약간 다른 &lt;code&gt;dirname(1)&lt;/code&gt; 쉘 함수를 에뮬레이트 합니다. 마지막 레벨이 명확하게 디렉토리 인 경우에도 파일 경로의 마지막 레벨을 제외한 모든 레벨을 리턴합니다. 실제로 디렉토리 부분을 반환하지 않고 단순히 파일 경로에 대해 &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; 처럼 작동하는 경로를 한 단계 높이고 있습니다.</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">GCC 이외의 컴파일러를 사용하는 경우 위 항목은 &lt;code&gt;gl.lib&lt;/code&gt; ( libgl.lib가 뒤 &lt;code&gt;libgl.lib&lt;/code&gt; )를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">인라인 수정 자에 대해 &lt;code&gt;(?:)&lt;/code&gt; 구문을 지원하지 않는 사용자 정의 엔진을 사용하는 경우 제공된 패턴에 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 문자열을 지정하는 것이 가장 좋습니다 . 다음과 같은 경우에는 원하지 않는 패턴이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">시그니처를 사용하는 경우 시그니처 의 어휘 변수 외에도 특수 배열 변수 &lt;code&gt;@_&lt;/code&gt; 에서 인수를 계속 사용할 수 있습니다 . 인수에 액세스하는 두 가지 방법 사이에 차이가있다 : &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">&lt;code&gt;call_argv&lt;/code&gt; 를 제외한 이러한 루틴을 사용하는 경우 프로그래머는 Perl 스택을 조작해야합니다. 여기에는 다음과 같은 매크로 및 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">미리보기 어설 션과 부정을 사용할 때이 모든 것이 더욱 까다로워 질 수 있습니다. &quot;123&quot;이 아닌 숫자가 아닌 일련의 시퀀스를 찾고 싶다고 상상해보십시오. 다음과 같이 쓰려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">OS / 390에서 perl을 사용할 때 EBCDIC 및 ASCII 문자 세트가 다르다는 것을 명심하십시오. 이러한 문자 세트 문제에 대한 자세한 내용은 perlebcdic.pod를 참조하십시오. EBCDIC에서 다르게 동작 할 수있는 Perl 내장 함수는 perlport.pod 문서에도 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">perldoc을 &lt;code&gt;-m&lt;/code&gt; 모드 (디스플레이 모듈 소스 코드) 로 사용하는 경우 &lt;code&gt;perldoc&lt;/code&gt; 은 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 에 설정된 페이저를 사용하려고 시도합니다 . 이 명령에 유용한 설정은 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 에서 선호하는 편집기 입니다. (나를 판단하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">&quot;syn&quot;프로토콜을 사용할 때이 방법을 사용하여 원격 호스트의 도달 가능성을 판별하십시오. 이 메소드는 ping ()이 호출 된 횟수만큼 호출됩니다. 각 호출은 TCP ACK와 함께 제공된 호스트 (ping ()에 전달됨)를 반환합니다. 호스트가 리턴되는 순서는 반드시 ping () 메소드를 사용하여 SYN 큐된 순서와 반드시 같을 필요는 없습니다. TCP ACK가 수신되기 전에 시간 초과에 도달하거나 원격 호스트가 시도한 포트에서 수신 대기하지 않으면 TCP 연결이 설정되지 않고 ack ()이 undef를 반환합니다. 목록 컨텍스트에서 호스트, ack 시간 및 점으로 구분 된 IP 문자열이 호스트 대신 반환됩니다. 선택적 $ host 인수가 지정되면 리턴 값은 해당 호스트에만 관련됩니다.syn 이외의 프로토콜을 사용하는 경우이 호출은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 프로토 타입을 사용할 때 함수는 인수가 허용 가능한 유형인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">Borland 컴파일러를 사용할 때 두 번째 항목은 &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; 로 반환되고 MakeMaker 는 &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; 를 링커 명령 줄의 올바른 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">SAM의 GUI 버전을 사용하는 경우 커널 구성 아이콘을 클릭 한 다음 구성 가능한 매개 변수 아이콘을 클릭하십시오. 아래로 스크롤하여 maxdsiz 줄을 선택하십시오. 조치 메뉴에서 구성 가능한 매개 변수 수정 항목을 선택하십시오. 새 수식을 수식 / 값 상자에 삽입하십시오. 그런 다음 지침에 따라 커널을 다시 빌드하고 시스템을 재부팅하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">Visual C 컴파일러를 사용할 때 두 번째 항목은 &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">상수를 사용할 때 각 인쇄 라인의 끝에 &lt;code&gt;, RESET&lt;/code&gt; 을 추가하지 않아도되는 경우 $ Term :: ANSIColor :: AUTORESET을 true로 설정할 수 있습니다. 그러면 상수 다음에 쉼표가 없으면 디스플레이 모드가 자동으로 재설정됩니다. 즉, 해당 변수 세트를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">이 컴파일러를 사용하여 Perl을 빌드 할 때 -Aa 플래그가 config.sh 파일의 cpprun 및 cppstdin 변수에 추가되어 있는지 확인해야합니다 (아래 64 비트 perl 섹션 참조). 최신 버전의 Perl 분배를 사용중인 경우이 플래그가 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">기존 다이제스트 문자열을 확인할 때 다이제스트를 소금으로 사용해야합니다 (예 : &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). 다이제스트를 만드는 데 사용 된 SALT는 다이제스트의 일부로 표시됩니다. 이렇게하면 crypt ()가 다이제스트와 동일한 소금으로 새 문자열을 해시합니다. 이를 통해 코드가 표준 &lt;a href=&quot;crypt&quot;&gt;암호화&lt;/a&gt; 및보다 이국적인 구현과 함께 작동 할 수 있습니다 . 다시 말해, 반환 된 문자열 자체와 SALT 바이트 수에 대해서는 아무 것도 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">기존 다이제스트 문자열을 확인할 때 다이제스트를 소금으로 사용해야합니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). 다이제스트를 만드는 데 사용 된 SALT는 다이제스트의 일부로 표시됩니다. 이렇게하면 crypt ()가 다이제스트와 동일한 소금으로 새 문자열을 해시합니다. 이를 통해 코드가 표준 &lt;a href=&quot;#crypt&quot;&gt;암호화&lt;/a&gt; 및보다 이국적인 구현과 함께 작동 할 수 있습니다 . 다시 말해, 반환 된 문자열 자체와 SALT 바이트 수에 대해서는 아무 것도 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">우리가 무언가를 축복 할 때, 우리는 그 것에 대한 언급을 포함하는 변수를 축복하지 않으며, 변수가 저장하는 참조를 축복하지도 않습니다. 우리는 변수가 말하는 것을 축복하고 있습니다 (때때로</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">변수에 대해 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 이라고 부르면 실제로 변수가 참조하는 기본 데이터 구조를 축복하는 것입니다. 우리는 참조 자체 나 그 참조를 포함하는 변수를 축복하지 않습니다. 이것이 &lt;code&gt;blessed( $bar )&lt;/code&gt; 대한 두 번째 호출이 false를 반환 하는 이유 입니다. 이 시점에서 &lt;code&gt;$bar&lt;/code&gt; 는 더 이상 객체에 대한 참조를 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">우리가 메서드 호출을 할 때, 방법의 펄 주선 &lt;b&gt;invocant는&lt;/b&gt; 첫 번째 인수로 전달합니다. &lt;b&gt;옹호자&lt;/b&gt; 는 화살의 왼쪽에있는 물건의 멋진 이름입니다. 호출자는 클래스 이름 또는 오브젝트 일 수 있습니다. 메소드에 추가 인수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">아래에서 &quot;Mac OS&quot;라고하면 Mac OS 7, 8 및 9를 의미하며</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">호출자에게 반환 될 값을 스택에 배치하려면 &quot;XPUSH&quot;로 시작하는 일련의 매크로를 사용합니다. 스택에 정수, 부호없는 정수, 복식, 문자열 및 Perl 스칼라를 배치하기위한 5 가지 버전이 있습니다. 이 예에서는 스택에 Perl 스칼라를 배치했습니다. 실제로 이것은 여러 값을 반환하는 데 사용할 수있는 유일한 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">&lt;code&gt;$columns&lt;/code&gt; 보다 긴 단어 가 발견 되면 단어 가 분리됩니다. &lt;code&gt;wrap()&lt;/code&gt; 은 &lt;code&gt;$columns&lt;/code&gt; 열에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 추가합니다 . &lt;code&gt;$huge&lt;/code&gt; 를 'die'또는 'overflow' 로 설정하면이 동작을 무시할 수 있습니다 . 'die'로 설정하면 큰 단어로 인해 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. '오버플로'로 설정하면 큰 단어가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">DBM 필터를 작성할 때</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">일반적인 소비를 위해 Perl 확장을 작성할 때 확장은 시스템에서 사용 가능한 버전과 다른 Perl 버전과 함께 사용될 것으로 예상해야합니다. 이 문서를 읽고 있으므로 컴퓨터의 Perl 버전은 5.005 이상일 수 있지만 확장 사용자에게는 더 오래된 버전이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">UTF-8 문자열에 문자 UV를 쓸 때 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 아닌 경우 &lt;b&gt;항상 &lt;/b&gt; &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 을 사용 하십시오 . 이 경우 &lt;code&gt;*s = uv&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">gzip 파일을 작성할 때이 인터페이스는</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">파일 또는 파일 핸들에 쓸 때는 파일에 쓰기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">때를</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">용의자 목록에 만족하면 이제</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">완료되면 XS 모듈 설치 프로세스는 &quot;perllocal&quot;정보에 perl 바이너리가 교체되었음을 알리는 정보와 설치된 모듈을 추가합니다. 다음 명령을 사용하여 언제든지이 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">GNU C 컴파일러 (gcc)를 사용하려고하는데 아직 gcc가없는 경우 소스에서 직접 빌드 할 수 있습니다 (예 : &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) 또는 HP 포팅 센터 ( &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search)&lt;/a&gt; 또는 &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http&lt;/a&gt; ( http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search= 검색) 에서 사전 빌드 된 바이너리를 가져옵니다. : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r1002_usen_c-001_title_r0001 과 동일하기 때문에 여러 패키지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">UCM 파일을 수동으로 작성하는 경우, 처음부터 직접 작성하지 않고 ascii.ucm 또는 기존 인코딩과 가까운 인코딩을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">테스트 결과에 만족하면 확장을위한 빌드 C 라이브러리를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">당신이 확실 몇 하위 디렉토리가 실패로 이어질 것을 때, 당신은 추가 할 수 있습니다 &lt;code&gt;-j4&lt;/code&gt; 에 옵션을 &lt;code&gt;make&lt;/code&gt; 이미 완성 된 빌드 서브 디렉토리를 건너 뛰는 속도를.</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">&quot;스트림&quot;프로토콜을 사용하는 경우이 호출은 tcp 소켓을 미리 엽니 다. 연결을 만들 때 다른 시간 초과를 제공하거나 첫 번째 핑에서 연결을 설정하는 오버 헤드를 제거하려는 경우에만이 작업을 수행하면됩니다. &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 호출하지 않으면 &lt;code&gt;ping()&lt;/code&gt; 처음 호출 할 때 연결이 자동으로 열립니다 . 이 호출은 스트림 이외의 프로토콜을 사용하는 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">모듈을 빌드 할 때 Perl에게 모듈을 설치할 위치를 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">인수와 함께 &lt;code&gt;bar&lt;/code&gt; 를 호출하면 &lt;code&gt;foo&lt;/code&gt; 가 동일한 &lt;code&gt;@_&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">메소드를 호출하면 화살표의 왼쪽에있는 것이 메소드의 첫 번째 인수로 전달됩니다. 즉 , &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 호출 하면 &lt;code&gt;new()&lt;/code&gt; 메서드는 첫 번째 인수로 문자열 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 를 받습니다 . &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; 호출 하면 &lt;code&gt;$fred&lt;/code&gt; 변수가 &lt;code&gt;speak()&lt;/code&gt; 의 첫 번째 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">&lt;b&gt;값&lt;/b&gt; 을 복사 할 때 &lt;b&gt;값&lt;/b&gt; 을 변경할 때 [체스에서 이국적인 전당포를 잡는 작전에서와 같이 프랑스어에서 &quot;통과 중&quot;.</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">mathemagical 객체를 chop ()하면 문자열로 승격되고 mathemagical 속성이 손실됩니다. 다른 작업에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">레거시 데이터와 유니 코드를 결합 할 때 레거시 데이터를 유니 코드로 업그레이드해야합니다. 일반적으로 레거시 데이터는 ISO 8859-1 (또는 해당되는 경우 EBCDIC) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">지도를 만들 때 안전하게 왕복 여행을해야합니다. 즉, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; 는 &lt;code&gt;|0&lt;/code&gt; 으로 표시된 모든 문자를 나타냅니다 . 확인하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">위에 표시된 방법을 사용하여 &lt;code&gt;PI&lt;/code&gt; 와 같은 상수를 선언하면 스크립트가 실행되는 각 컴퓨터는 사용할 수있는만큼의 정확도를 가질 수 있습니다. 또한 프로그램이 읽기 쉽고, 유지 보수 (정확하게 유지) 될 가능성이 높으며, &lt;code&gt;3.14195&lt;/code&gt; 라는 방정식을 아무도 보지 못했기 때문에 우주 탐사선을 잘못된 행성에 보낼 가능성이 훨씬 낮 습니다 .</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">해독 할 때 (=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">디코딩 할 때 잘못된 문자에 대해 &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; 가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 객체에서 $ parser-&amp;gt; get_token을 수행하면 이 클래스의 객체를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 에서 $ parser-&amp;gt; get_token을 수행하면 이 클래스의 객체를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 에서 $ parser-&amp;gt; get_token을 수행하면 Pod :: Simple :: PullParserToken 서브 클래스의 객체를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">open ()을 수행하고 배포 할 추가 PerlIO 레이어를 지정하면 지정한 레이어가 이미 존재하는 기본 스택 위에 &quot;푸시&quot;됩니다. 이를 확인하는 한 가지 방법은 &quot;운영 체제가 왼쪽에 있고&quot;및 &quot;Perl이 오른쪽에 있다는 것&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">그렇게 할 때 환경이 EBCDIC이 아닌 경우 최소한 &lt;b&gt;U0000&lt;/b&gt; ~ &lt;b&gt;U0020&lt;/b&gt; 을 그대로 두십시오 .</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">이 작업을 수행하면 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 유형 과 자체 PP 기능 의 &lt;code&gt;op_ppaddr&lt;/code&gt; 로 op를 작성하여 일반 Perl op를 사용자 정의 op로 대체 하십시오. 이것은 XS 코드로 정의되어야하며 &lt;code&gt;pp_*.c&lt;/code&gt; 의 PP ops와 같아야합니다 . 귀하는 op가 스택에서 적절한 수의 값을 가져 오는지 확인해야하며 필요한 경우 스택 표시를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">인코딩 할 때 UTF-8 문자열 만 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">이 스크립트를 실행하면 Perl은 파일의 소스 스트림을 작성합니다. 파서는 파일에서 행을 처리하기 전에 소스 스트림은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">데이터 구조에 대한 사용자 정의 인쇄를 작성하는 데 &lt;a href=&quot;dumpvalue&quot;&gt;지치면&lt;/a&gt; 표준 Dumpvalue 또는 &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; 모듈을 볼 수 있습니다. 전자는 Perl 디버거가 사용하는 것이고 후자는 파싱 가능한 Perl 코드를 생성합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Module :: Build가 설치되어 있고 모듈에 Makefile.PL과 Build.PL이 함께 제공되는 경우 우선 순위는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Term :: ANSIColor를 설치 한 경우 일반 CPAN.pm 출력, 경고, 디버깅 출력 및 설치중인 모듈의 출력간에 시각적 차이가 있도록 색상 화 된 출력을 켤 수 있습니다. Term :: ANSIColor 모듈을 실험 한 후 원하는 색상을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">당신이있을 때 &lt;code&gt;$normalized&lt;/code&gt; 문자열과 &lt;code&gt;$unnormalized&lt;/code&gt; 를 다음 문자열을, 간단한 연결은 잘못된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">중복 된 항목이 있으면 '| 1'또는 '| 3'으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">.xs 파일에 XSUB에 대한 인수를 나열하면 &lt;b&gt;xsubpp&lt;/b&gt; 에게 인수 스택 중 어느 인수에 해당하는 인수인지 (즉, 첫 번째 인수는 첫 번째 인수 등) &lt;b&gt;xsubpp&lt;/b&gt; 에 알려줍니다 . 기능이 예상하는 순서대로 나열하지 않으면 재해를 초대합니다.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">스크립트를 실행 가능하게하면 명령으로 사용 가능하게하기 위해 시스템은 스크립트의 #!에서 스위치를 perl로 전달합니다. 선. Perl은 setuid (또는 setgid) 스크립트에 제공된 명령 행 스위치가 실제로 #!에 설정된 명령 행 스위치와 일치하는지 확인합니다. 선. 일부 유닉스 및 유닉스 계열 환경은 #! 이러한 시스템 에서는 &lt;code&gt;-w -U&lt;/code&gt; 대신 &lt;code&gt;-wU&lt;/code&gt; 와 같은 것을 사용해야 할 수도 있습니다. 이 문제는 #! 및 setuid 또는 setgid 스크립트를 지원하는 Unix 또는 Unix와 유사한 환경에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">내장을 재정의하는 경우 대체는 내장 네이티브 구문과 일치해야합니다 (가능한 경우). 적합한 프로토 타입을 사용하여이를 달성 할 수 있습니다. 재정의 가능한 내장의 프로토 타입을 가져 오려면 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; 함수를 사용 하십시오 ( &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">이 변수를 교체 할 때는 이전에 설치했을 가능성이있는 후크를 저장하고 자신의 내부에서 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Makefile.PL을 실행하면 Makefile이 만들어집니다. 그것이 MakeMaker의 핵심입니다. Makefile.PL은 ExtUtils :: MakeMaker를로드하고 WriteMakefile () 함수를 실행하여 Makefile을 생성하는 간단한 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Perl 스크립트를 실행할 때 다른 스크립트가 스크립트를 실행 중이고 다른 오류 메시지가 출력 될 수 있습니다. 스크립트는 자체 경고 및 오류 메시지를 표시 할 수 있습니다. 대부분의 경우 누가 무엇을 말했는지 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 내용이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">&quot;make test&quot;라고 말하면 Perl은</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">메일 및 웹 페이지에 &lt;code&gt;charset=gb2312&lt;/code&gt; 가 표시되면 실제로 &lt;code&gt;euc-cn&lt;/code&gt; 인코딩을 의미 합니다. 이를 해결하기 위해 &lt;code&gt;gb2312&lt;/code&gt; 는 &lt;code&gt;euc-cn&lt;/code&gt; 에 별명으로 지정됩니다 . 실제로 의미가있는 경우 &lt;code&gt;gb2312-raw&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">메일 및 웹 페이지에 &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; 이 표시되면 실제로는 &quot;cp949&quot;인코딩을 의미합니다. 이를 해결하기 위해 다음과 같은 별명이 설정됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
