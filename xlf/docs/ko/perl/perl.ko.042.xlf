<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="0a4bec64b36dddd2d05eab7e4c0c50161f28ee85" translate="yes" xml:space="preserve">
          <source>Jungshik Shin's Hangul FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393e8d148b7c32a4801ca4b9adac481fc7a1b559" translate="yes" xml:space="preserve">
          <source>Junk on end of regexp in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3e3f9c72e3b6a4486ec8a37b16219f4828a4df" translate="yes" xml:space="preserve">
          <source>Just a quick hint here for all those CGI programmers who can't figure out how on earth to get past that 'waiting for input' prompt, when running their CGI script from the command-line, try something like this:</source>
          <target state="translated">명령 행에서 CGI 스크립트를 실행할 때 '입력 대기 중'프롬프트를 벗어나는 방법을 알 수없는 모든 CGI 프로그래머에게 간단한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33892714232f2855fd91a542cad5d54aa9bb7133" translate="yes" xml:space="preserve">
          <source>Just as P5P collectively maintains the codebase, we collectively maintain the documentation. Writing a particular bit of documentation doesn't give an author control of the future of that documentation. At the same time, just as source code changes should match the style of their surrounding blocks, so should documentation changes.</source>
          <target state="translated">P5P가 공동으로 코드베이스를 유지 관리하는 것처럼 문서를 유지 관리합니다. 특정 문서를 작성한다고해서 해당 문서의 미래를 제어 할 수있는 것은 아닙니다. 동시에, 소스 코드 변경이 주변 블록의 스타일과 일치해야하는 것처럼 문서 변경도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0aaf4ef0c9b344d1374053d108e2052e07431e98" translate="yes" xml:space="preserve">
          <source>Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything that the interpreter knows about itself and pass it around, so too are there plans to allow the interpreter to bundle up everything it knows about the environment it's running on. This is enabled with the PERL_IMPLICIT_SYS macro. Currently it only works with USE_ITHREADS on Windows.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT가 인터프리터가 알고있는 모든 것을 묶고 전달할 수있는 방법을 제공하는 것처럼 인터프리터가 실행중인 환경에 대해 알고있는 모든 것을 번들로 묶을 계획도 있습니다. PERL_IMPLICIT_SYS 매크로를 사용하여 활성화됩니다. 현재는 Windows의 USE_ITHREADS에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62e8906be80151cd95246c62df9e4761d5bc2332" translate="yes" xml:space="preserve">
          <source>Just as above, but maps from characters (like &quot;\xE9&quot;, lowercase e-acute) to characters (like &quot;e&quot;).</source>
          <target state="translated">위와 마찬가지로 문자 (예 : &quot;\ xE9&quot;, 소문자 e-acute)에서 문자 (예 : &quot;e&quot;)로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="f1702c1674bbdf9cb3b7adf0315e4e20270cbf30" translate="yes" xml:space="preserve">
          <source>Just as in all regular expressions, the pattern can be built up by including variables that are interpolated at regex compilation time. But its best to compile each sub-component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b1550eae10318438b9e4b01a4b0de0c550fc87" translate="yes" xml:space="preserve">
          <source>Just as in all regular expressions, the pattern can be built up by including variables that are interpolated at regex compilation time. Care must be taken to ensure that you are getting what you expect. For example:</source>
          <target state="translated">모든 정규식과 마찬가지로 정규식 컴파일 타임에 보간되는 변수를 포함시켜 패턴을 만들 수 있습니다. 기대하는 바를 얻도록주의를 기울여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe8a855ccb8465e6e734bba6c85f798237a3ef83" translate="yes" xml:space="preserve">
          <source>Just as in the previous regexp, the first quantifier &lt;code&gt;.??&lt;/code&gt; can match earliest at position &lt;code&gt;'a'&lt;/code&gt; , so it does. The second quantifier is greedy, so it matches &lt;code&gt;mm&lt;/code&gt; , and the third matches the rest of the string.</source>
          <target state="translated">이전 정규 표현식에서와 마찬가지로 첫 번째 수량자는 &lt;code&gt;.??&lt;/code&gt; &lt;code&gt;'a'&lt;/code&gt; 위치에서 가장 빨리 일치 할 수 있습니다 . 두 번째 수량자는 욕심이 많으므로 &lt;code&gt;mm&lt;/code&gt; 과 일치하고 세 번째 수량자는 나머지 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b429e6fea7e7282b4255020ad5026d4f3fb6bfbd" translate="yes" xml:space="preserve">
          <source>Just as in the previous regexp, the first quantifier &lt;code&gt;.??&lt;/code&gt; can match earliest at position &lt;code&gt;'a'&lt;/code&gt;, so it does. The second quantifier is greedy, so it matches &lt;code&gt;mm&lt;/code&gt;, and the third matches the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54aa745852ee956f0149292237b30dcf7a75e890" translate="yes" xml:space="preserve">
          <source>Just as in the shell, a backslashed bareword following the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; means the same thing as a single-quoted string does:</source>
          <target state="translated">쉘에서와 같이 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 뒤에 오는 백 슬래시 베어 워드 는 작은 따옴표로 묶인 문자열과 동일한 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="faebd7db1f892818770103ce78accf7713eb730f" translate="yes" xml:space="preserve">
          <source>Just as numeric comparisons can be autogenerated from the method for &lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; , string comparisons can be autogenerated from that for &lt;code&gt;'cmp'&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; 의 메소드에서 숫자 비교를 자동 생성 할 수있는 것처럼 &lt;code&gt;'cmp'&lt;/code&gt; 의 문자열 비교를 자동으로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f4705ec7dd0e75b639ef6323350a11dcee5bb4b" translate="yes" xml:space="preserve">
          <source>Just as numeric comparisons can be autogenerated from the method for &lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt;, string comparisons can be autogenerated from that for &lt;code&gt;'cmp'&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df19f323bb6b48a43ad85680dc0529bf785f1c3" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen when you &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; a list. Further examples of this can be found in &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;Safe Pipe Opens in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 목록 을 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 할 때 쉘 이스케이프가 발생하지 않습니다 . 이에 대한 추가 예는 &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;perlipc의 Safe Pipe Opens에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51995d8ca4bbd6f67f0a4012d50abbc2aa87fe84" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;system()&lt;/code&gt;, no shell escapes happen when you &lt;code&gt;exec()&lt;/code&gt; a list. Further examples of this can be found in &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;&quot;Safe Pipe Opens&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e255de21718ad7422221bd6f42f8ec7acc85a6f3" translate="yes" xml:space="preserve">
          <source>Just as with any Perl subroutine, all of the arguments passed in &lt;code&gt;@_&lt;/code&gt; are aliases to the original argument. This includes the object itself. If you assign directly to &lt;code&gt;$_[0]&lt;/code&gt; you will change the contents of the variable that holds the reference to the object. We recommend that you don't do this unless you know exactly what you're doing.</source>
          <target state="translated">Perl 서브 루틴과 마찬가지로, &lt;code&gt;@_&lt;/code&gt; 에 전달 된 모든 인수 는 원래 인수의 별명입니다. 여기에는 객체 자체가 포함됩니다. &lt;code&gt;$_[0]&lt;/code&gt; 에 직접 할당 하면 객체에 대한 참조를 보유한 변수의 내용이 변경됩니다. 수행중인 작업을 정확히 알지 않는 한이 작업을 수행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fccd05d91f9ee0d9fbbfbf38723d03e8a7c74f00" translate="yes" xml:space="preserve">
          <source>Just as with any signal, you can use &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; to retrieve the installed signal handler (or, rather, the signal action).</source>
          <target state="translated">모든 신호와 마찬가지로 &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; 을 사용하여 설치된 신호 처리기 (또는 신호 동작)를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dd23c5eb258d91db69b09a02592a51973f21dd6" translate="yes" xml:space="preserve">
          <source>Just as with any signal, you can use &lt;code&gt;sigaction($rtsig, undef, $oa)&lt;/code&gt; to retrieve the installed signal handler (or, rather, the signal action).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc08a9e71893fc4c8e0aca93a96bf0beab842b5" translate="yes" xml:space="preserve">
          <source>Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE, this doesn't mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.</source>
          <target state="translated">어휘 변수가 둘러싸는 블록, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE에 대해 어휘 적으로 (정적으로 호출 됨) 범위를 지정 한다고해서 함수 내에서 C 정적처럼 작동한다는 의미는 아닙니다. 일반적으로 C auto와 비슷하지만 암시 적 가비지 콜렉션과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="78056aba9593d70f12e87925bcfaacc1a8ab6644" translate="yes" xml:space="preserve">
          <source>Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt; FILE, this doesn't mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c499a655f030c92a71b95e9b2689970ea91b8a" translate="yes" xml:space="preserve">
          <source>Just because you</source>
          <target state="translated">당신 때문에</target>
        </trans-unit>
        <trans-unit id="109e6f9598b8183bb06ce69968e5c56fc8392a6f" translate="yes" xml:space="preserve">
          <source>Just before HP took over Compaq, some systems were renamed. the link that contained the explanation is dead, so here's a short summary:</source>
          <target state="translated">HP가 Compaq을 인수하기 직전에 일부 시스템의 이름이 변경되었습니다. 설명이 포함 된 링크가 죽었으므로 여기에 간단한 요약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a3cd456f36493a47889dab1eae3ee74e772ac3" translate="yes" xml:space="preserve">
          <source>Just before removing a directory (after having successfully removed everything it contained), &lt;code&gt;remove_tree&lt;/code&gt; attempted to set the permissions on the directory to ensure it could be removed and failed. Program execution continues, but the directory may possibly not be deleted.</source>
          <target state="translated">디렉토리를 제거하기 직전에 (포함 된 모든 것을 성공적으로 제거한 후) &lt;code&gt;remove_tree&lt;/code&gt; 는 디렉토리에 대한 권한을 설정하여 디렉토리가 제거되고 실패 할 수 있도록 시도했습니다. 프로그램 실행은 계속되지만 디렉토리가 삭제되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d4933b209ef20fa5fe691ade0680077d951e65e" translate="yes" xml:space="preserve">
          <source>Just do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cff4cf2ef85b7a7babbfc6ed8ae94ad00cf8c95" translate="yes" xml:space="preserve">
          <source>Just don't forget that you have to put a semicolon on the end to finish the statement, as Perl doesn't know you're not going to try to do this:</source>
          <target state="translated">Perl은 당신이 이것을 시도하지 않을 것이라는 것을 알지 못하기 때문에 문장을 완성하기 위해 세미콜론을 끝내야한다는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="328525052fa36f8cc3be7cbb9e20c8b29808d7e3" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;, Dotted-Decimal Versions can be used as &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6d762627d70bbe10fa5260237267dabf212dd8" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, but implicitly appends a newline at the end of the LIST instead of any value &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; might have. To use FILEHANDLE without a LIST to print the contents of &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to it, you must use a bareword filehandle like &lt;code&gt;FH&lt;/code&gt;, not an indirect one like &lt;code&gt;$fh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfcdab4ac1e20695bdf62962cb38182d5e54e17" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;$^E&lt;/code&gt;, in a numeric context &lt;code&gt;fileLastError()&lt;/code&gt; returns the numeric error value while in a string context it returns a text description of the error [actually it returns a Perl scalar that contains both values so &lt;code&gt;$x= fileLastError()&lt;/code&gt; causes &lt;code&gt;$x&lt;/code&gt; to give different values in string vs. numeric contexts].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3dbf5e42e97a50f069394cda4a6442ac1d1765" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 처럼 , 암묵적으로 줄 바꿈을 추가합니다. &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 단순히의 약어입니다 &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . LIST없이 FILEHANDLE을 사용하여 &lt;code&gt;$_&lt;/code&gt; 의 내용을 인쇄하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="602502b6c9a3a727e615412b86a9aecefaaebcdb" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 처럼 , 암묵적으로 줄 바꿈을 추가합니다. &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 단순히의 약어입니다 &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . LIST없이 FILEHANDLE을 사용하여 &lt;code&gt;$_&lt;/code&gt; 의 내용을 인쇄하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="841a87198bd8d5b2b617ad09071d079bbef63265" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;SAVEFREESV&lt;/code&gt; , but mortalizes &lt;code&gt;sv&lt;/code&gt; at the end of the current scope instead of decrementing its reference count. This usually has the effect of keeping &lt;code&gt;sv&lt;/code&gt; alive until the statement that called the currently live scope has finished executing.</source>
          <target state="translated">&lt;code&gt;SAVEFREESV&lt;/code&gt; 와 마찬가지로 참조 수를 줄이지 않고 현재 범위의 끝에서 &lt;code&gt;sv&lt;/code&gt; 을 필사 화 합니다. 이는 일반적으로 현재 라이브 범위라고하는 명령문이 실행을 완료 할 때까지 &lt;code&gt;sv&lt;/code&gt; 를 활성 상태로 유지하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8849097832f945b1a9937bcaa379e174bc86623" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;SAVEFREESV&lt;/code&gt;, but mortalizes &lt;code&gt;sv&lt;/code&gt; at the end of the current scope instead of decrementing its reference count. This usually has the effect of keeping &lt;code&gt;sv&lt;/code&gt; alive until the statement that called the currently live scope has finished executing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bed5460b2b3b0cfc33630f1100fa2264399cf7" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;my $f; $f = sub { $f-&amp;gt;() }&lt;/code&gt;, this example leaks memory. The name &lt;code&gt;baz&lt;/code&gt; is a reference to the subroutine, and the subroutine uses the name &lt;code&gt;baz&lt;/code&gt;; they keep each other alive (see &lt;a href=&quot;perlref#Circular-References&quot;&gt;&quot;Circular References&quot; in perlref&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdee811de63331b1e390b9478886674b8221df6d" translate="yes" xml:space="preserve">
          <source>Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example</source>
          <target state="translated">교대와 마찬가지로 정량자는 역 추적에 취약합니다. 다음은 예제의 단계별 분석입니다.</target>
        </trans-unit>
        <trans-unit id="24cfeb3771fb43ef585a2f529448474ab41a12a3" translate="yes" xml:space="preserve">
          <source>Just like capa, but only uses a cache from the last time we asked the server, so as to avoid asking more than once.</source>
          <target state="translated">capa와 마찬가지로 서버에 마지막으로 요청한 시간부터 캐시를 사용하므로 두 번 이상 묻지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c07daab474d2a24a41bbf91648b44cb45c039da4" translate="yes" xml:space="preserve">
          <source>Just like have_compiler but for C++ instead of C.</source>
          <target state="translated">have_compiler와 마찬가지로 C 대신 C ++ 용</target>
        </trans-unit>
        <trans-unit id="1ed1a130170978e2a4e7086c7c7306a25c8e7b33" translate="yes" xml:space="preserve">
          <source>Just like special scalars and arrays, there are also special hashes. The most well known of these is &lt;code&gt;%ENV&lt;/code&gt; which contains environment variables. Read all about it (and other special variables) in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">특수 스칼라 및 배열과 마찬가지로 특수 해시도 있습니다. 이들 중 가장 잘 알려진 것은 환경 변수를 포함하는 &lt;code&gt;%ENV&lt;/code&gt; 입니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에서 그것에 대해 (및 다른 특수 변수)를 모두 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="19b37fcf66fa778fbd1b5d5fc50d7060df9d05e7" translate="yes" xml:space="preserve">
          <source>Just like the &quot;strict&quot; pragma any of these categories can be combined</source>
          <target state="translated">&quot;엄격한&quot;pragma와 마찬가지로 이러한 범주 중 하나를 결합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82e865fa7feb693e6080cbf3d25a874d28e9c584" translate="yes" xml:space="preserve">
          <source>Just pressing Enter will do the most recent operation again - it's a blessing when stepping through miles of source code.</source>
          <target state="translated">Enter 키를 누르면 가장 최근의 작업이 다시 수행됩니다. 수 마일의 소스 코드를 단계별로 실행할 때 축복입니다.</target>
        </trans-unit>
        <trans-unit id="fe244a50fe6aded057e3eae12f0a93027edb2381" translate="yes" xml:space="preserve">
          <source>Just say:</source>
          <target state="translated">그냥 말해:</target>
        </trans-unit>
        <trans-unit id="d8c1011fd0f056428d5a8834a2c765887dde0f8b" translate="yes" xml:space="preserve">
          <source>Just set the integer value of the top stack entry to its negation.</source>
          <target state="translated">최상위 스택 항목의 정수 값을 부정으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c7727ca967ac9b4f317d7c673ab3882351fa9d9d" translate="yes" xml:space="preserve">
          <source>Just simple slots for storing information about the line and the file the link was encountered in. Has to be filled in manually.</source>
          <target state="translated">링크 및 링크가 발생한 파일에 대한 정보를 저장하기위한 간단한 슬롯. 수동으로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="375852fdf41d2722bd019bb571f919722e750515" translate="yes" xml:space="preserve">
          <source>Just the Pod, the whole Pod, and nothing but the Pod</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1d3328e0f08111bb8c2f1b7ffdbdee9651e208" translate="yes" xml:space="preserve">
          <source>Just to show that C programmers can write C in any programming language, if you prefer a more C-like solution, the following script makes the substitution have the same case, letter by letter, as the original. (It also happens to run about 240% slower than the Perlish solution runs.) If the substitution has more characters than the string being substituted, the case of the last character is used for the rest of the substitution.</source>
          <target state="translated">C 프로그래머가 모든 프로그래밍 언어로 C를 작성할 수 있음을 보여주기 위해 C와 같은 솔루션을 선호하는 경우 다음 스크립트는 대소 문자를 대소 문자로 대치합니다. (또한 Perlish 솔루션이 실행하는 것보다 약 240 % 느리게 실행됩니다.) 대체에 대체되는 문자열보다 많은 문자가있는 경우 마지막 대체 문자는 마지막 대체 문자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a091e09bfa339a10150c33a9aaadd4282459277" translate="yes" xml:space="preserve">
          <source>Just what it says, you're missing that file. MakeMaker uses it to determine if perl has been rebuilt since the Makefile was made. It's a bit of a bug that it halts installation.</source>
          <target state="translated">그 내용대로 파일이 없습니다. MakeMaker는이를 사용하여 Makefile이 작성된 이후에 perl이 재 빌드되었는지 판별합니다. 설치를 중단시키는 것은 약간의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="66d19ca0f4158063f6e062dbc4b43cb2360ddc04" translate="yes" xml:space="preserve">
          <source>KEY/VALUE PAIR LIST FUNCTIONS</source>
          <target state="translated">키 / 값 쌍 목록 기능</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="1294e49f760a91150a0bb4a9bd6180f089f5052a" translate="yes" xml:space="preserve">
          <source>KEYWORDS</source>
          <target state="translated">KEYWORDS</target>
        </trans-unit>
        <trans-unit id="d873371555253b7c518cf82fe5be999156ffe1fc" translate="yes" xml:space="preserve">
          <source>KNOWN BUGS</source>
          <target state="translated">알려진 버그</target>
        </trans-unit>
        <trans-unit id="d7d37390d4b0162eaa199e8a40421a0fd151d9d4" translate="yes" xml:space="preserve">
          <source>KNOWN ISSUES</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="49f7d6b044c08905cf6f12f8a90c2d7d80dd7870" translate="yes" xml:space="preserve">
          <source>KNOWN PROBLEMS</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="2e6715471399a1b1ebfdc7f8ec81f013da1993a0" translate="yes" xml:space="preserve">
          <source>KOI8 - De Facto Standard for the Cyrillic world</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bf874c052800335db296f8df012e4b563dd5c2" translate="yes" xml:space="preserve">
          <source>KS_C_5601-1987</source>
          <target state="translated">KS_C_5601-1987</target>
        </trans-unit>
        <trans-unit id="48303ff2b3e9c6f3ad91c4b4cea1dcbc0a240594" translate="yes" xml:space="preserve">
          <source>Kansas</source>
          <target state="translated">Kansas</target>
        </trans-unit>
        <trans-unit id="ff0775fcc23b465723521876b29263b74199fe74" translate="yes" xml:space="preserve">
          <source>Karen Etheridge</source>
          <target state="translated">카렌에 터리 지</target>
        </trans-unit>
        <trans-unit id="3270844f69bfa9c56dba2d6c3b4cb338e5e7c9e1" translate="yes" xml:space="preserve">
          <source>Karen Etheridge &amp;lt;ether@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbc3244d892d46238fd249e292072bf980c75ba" translate="yes" xml:space="preserve">
          <source>Karl Williamson &lt;code&gt;khw@cpan.org&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6587b068c21cd74b421d84d8dd8d104ffb717b74" translate="yes" xml:space="preserve">
          <source>Kawai,Takanori provides a Japanese translation of a very old version of this manpage at &lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&lt;/a&gt;</source>
          <target state="translated">Kawai, Takanori는 &lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&lt;/a&gt; 에서이 맨 페이지의 매우 오래된 버전의 일본어 번역을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2f36b6bb1852c24392fb3ee9a2879da24eb0750d" translate="yes" xml:space="preserve">
          <source>Kazakhstan</source>
          <target state="translated">Kazakhstan</target>
        </trans-unit>
        <trans-unit id="dcff63b147198a52939742818ee2ef592a205e7e" translate="yes" xml:space="preserve">
          <source>Keep features/concepts as orthogonal as possible.</source>
          <target state="translated">기능 / 개념을 가능한 한 직교하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8e7b10c1d652b6b04a656b434f5b39616ccf1a50" translate="yes" xml:space="preserve">
          <source>Keep hacking until the tests pass.</source>
          <target state="translated">테스트가 통과 될 때까지 해킹을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="af7d72158e7608d9c4b48305b5171ef45c75b0c8" translate="yes" xml:space="preserve">
          <source>Keep in mind that</source>
          <target state="translated">명심하십시오</target>
        </trans-unit>
        <trans-unit id="ed0120a6a4cb952cfa71da323a4afdbfcf12e27d" translate="yes" xml:space="preserve">
          <source>Keep in mind that even if you think your code is not locale-aware, it may call a C library function that is. Hopefully the man page for such a function will indicate that dependency, but the documentation is imperfect.</source>
          <target state="translated">코드가 로캘을 인식하지 않는다고 생각하더라도 C 라이브러리 함수를 호출 할 수 있습니다. 바라건대 그러한 기능에 대한 매뉴얼 페이지가 의존성을 나타내지 만 문서는 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="6b2fabd086693247681cb8a1ee02495591d5c9f6" translate="yes" xml:space="preserve">
          <source>Keep in mind that even if you think your code is not locale-aware, it may call a library function that is. Hopefully the man page for such a function will indicate that dependency, but the documentation is imperfect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f6615f078bb4d01730cb8fac56589317fa9a58" translate="yes" xml:space="preserve">
          <source>Keep in mind that only the first several &quot;odd-numbered&quot; buckets are used, so the information on size of the &quot;odd-numbered&quot; buckets which are not used is probably meaningless.</source>
          <target state="translated">처음 몇 개의 &quot;홀수 번호&quot;버킷 만 사용되므로 사용하지 않은 &quot;홀수 번호&quot;버킷의 크기에 대한 정보는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ef95230ae4c52baacdb1c4884acabd7049d178c" translate="yes" xml:space="preserve">
          <source>Keep in mind that these compiler and linker settings will also be used when building CPAN modules. For XS modules to be compiled as a universal binary, any libraries it links to must also be universal binaries. The system libraries that Apple includes with the 10.4u SDK are all universal, but user-installed libraries may need to be re-installed as universal binaries.</source>
          <target state="translated">CPAN 모듈을 빌드 할 때 이러한 컴파일러 및 링커 설정도 사용됩니다. XS 모듈을 범용 바이너리로 컴파일하려면 링크 된 모든 라이브러리도 범용 바이너리 여야합니다. Apple에 10.4u SDK에 포함 된 시스템 라이브러리는 모두 범용이지만 사용자 설치 라이브러리는 범용 바이너리로 다시 설치해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eeeda7b97916fa01cabcb38bff49279f0e6a0bb" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always supply</source>
          <target state="translated">당신은 항상 공급할 수 있다는 것을 명심하십시오</target>
        </trans-unit>
        <trans-unit id="64a46910748217f86efd6627ba753bed01e58a81" translate="yes" xml:space="preserve">
          <source>Keep info about source lines on which a subroutine is defined.</source>
          <target state="translated">서브 루틴이 정의 된 소스 라인에 대한 정보를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f47e40b91fc5362642fcbe01770e5ce787e6ccdc" translate="yes" xml:space="preserve">
          <source>Keep it fast, simple, and useful.</source>
          <target state="translated">빠르고 간단하며 유용하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="a180636219ad9f73429c85412c6186e17a5910d6" translate="yes" xml:space="preserve">
          <source>Keep it open and exciting to use/patch/advocate Perl everywhere.</source>
          <target state="translated">어디서나 Perl을 사용 / 패치 / 옹호 할 수 있도록 개방적이고 흥미 진진합니다.</target>
        </trans-unit>
        <trans-unit id="c51474355aad094e34cfbd22e2141d08f6d33f4f" translate="yes" xml:space="preserve">
          <source>Keep more files open than the system permits</source>
          <target state="translated">시스템이 허용하는 것보다 많은 파일을 열어 둡니다</target>
        </trans-unit>
        <trans-unit id="14b49f2a3e5ec0e1cdb997e3d03cb485633984fa" translate="yes" xml:space="preserve">
          <source>Keep sets of symbol names palatable to the VMS linker</source>
          <target state="translated">심볼 이름 세트를 VMS 링커에 표시 가능하게 유지</target>
        </trans-unit>
        <trans-unit id="35e8f597cb9e9a9f82f4e1bd085531a453e9fc6c" translate="yes" xml:space="preserve">
          <source>Keep statics grouped into bins based on request sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a15ca125f2b3af86ad1584e6c4e2aafb908eae" translate="yes" xml:space="preserve">
          <source>Keep your documentation near the code it documents (&quot;inline&quot; documentation). Include POD for a given method right above that method's subroutine. This makes it easier to keep the documentation up to date, and avoids having to document each piece of code twice (once in POD and once in comments).</source>
          <target state="translated">문서를 코드와 가까운 곳에 보관하십시오 ( &quot;인라인&quot;문서). 해당 메소드의 서브 루틴 바로 위에 제공된 메소드에 대한 POD를 포함하십시오. 이를 통해 문서를보다 쉽게 ​​최신 상태로 유지할 수 있으며 각 코드 조각을 두 번 (POD에 한 번, 주석에 한 번) 문서화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="76d3b7f70d495b2b8a3270d608b55e23f648e0ce" translate="yes" xml:space="preserve">
          <source>Keeping track of the highest cached record. This would allow reads-in-a-row to skip the cache lookup faster (if reading from 1..N with empty cache at start, the last cached value will be always N-1).</source>
          <target state="translated">가장 높은 캐시 된 레코드를 추적합니다. 이렇게하면 행 읽기가 캐시 조회를 더 빨리 건너 뛸 수 있습니다 (시작시 빈 캐시가있는 1..N에서 읽는 경우 마지막 캐시 된 값은 항상 N-1 임).</target>
        </trans-unit>
        <trans-unit id="4c7c7465de1db7f41ca1d8bdef4219bff0d7c120" translate="yes" xml:space="preserve">
          <source>Ken Williams &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">켄 윌리엄스 &amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ad60c49c47f2bac654c72d8e78538a479b9e1298" translate="yes" xml:space="preserve">
          <source>Ken Williams &amp;lt;kwilliams@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6eb55c5e49157861d18ebcd27f647197104aae7" translate="yes" xml:space="preserve">
          <source>Ken Williams wrote the original CPAN Meta Spec (also known as the &quot;META.yml spec&quot;) in 2003 and maintained it through several revisions with input from various members of the community. In 2005, Randy Sims redrafted it from HTML to POD for the version 1.2 release. Ken continued to maintain the spec through version 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd59a29e35516d1b9c3ad5018ade24ad931f61e" translate="yes" xml:space="preserve">
          <source>Ken Williams, &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">켄 윌리엄스, &amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0d1222a0218c97e36123b63438f7b4e4edcb6a3e" translate="yes" xml:space="preserve">
          <source>Ken Williams, kwilliams@cpan.org</source>
          <target state="translated">켄 윌리엄스, kwilliams@cpan.org</target>
        </trans-unit>
        <trans-unit id="a1b34f9f925d8a7063c51b6911f446a276179b5f" translate="yes" xml:space="preserve">
          <source>Kenichi Ishigaki &amp;lt;ishigaki@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c191406f2405d085c884671d550970ada2c6b1" translate="yes" xml:space="preserve">
          <source>Kenichi Ishigaki, &amp;lt;ishigaki[at]cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0c77223410ec7a299fe0a1261f164a0c42279d" translate="yes" xml:space="preserve">
          <source>Kenneth Albanowski (&amp;lt;kjahds@kjahds.com&amp;gt;), subsequently</source>
          <target state="translated">케네스 알바 노프 스키 (Kenneth Albanowski) (&amp;lt;kjahds@kjahds.com&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="653197d7093377e03793ff947a865bba7483d32a" translate="yes" xml:space="preserve">
          <source>Kent Fredric &amp;lt;kentfredric@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8469bfeb77eb9b1deeb56784d6fba56dcad80b56" translate="yes" xml:space="preserve">
          <source>Kent Fredric &amp;lt;kentnl@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ee2290090510397bed2e3bc84d4a991ae891b5" translate="yes" xml:space="preserve">
          <source>Kephra</source>
          <target state="translated">Kephra</target>
        </trans-unit>
        <trans-unit id="348f36b3e5bbe51567b4fb414536380d7187542b" translate="yes" xml:space="preserve">
          <source>Kernel threads are the next step in thread evolution. The OS knows about kernel threads, and makes allowances for them. The main difference between a kernel thread and a user-mode thread is blocking. With kernel threads, things that block a single thread don't block other threads. This is not the case with user-mode threads, where the kernel blocks at the process level and not the thread level.</source>
          <target state="translated">커널 스레드는 스레드 진화의 다음 단계입니다. OS는 커널 스레드를 알고 있으며이를 허용합니다. 커널 스레드와 사용자 모드 스레드의 주요 차이점은 차단입니다. 커널 스레드에서 단일 스레드를 차단하는 것은 다른 스레드를 차단하지 않습니다. 커널이 스레드 수준이 아닌 프로세스 수준에서 차단되는 사용자 모드 스레드의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259173b7d729d8dc6a66caf8b3aace35a75e8f99" translate="yes" xml:space="preserve">
          <source>Kevin Ryde</source>
          <target state="translated">케빈 라이드</target>
        </trans-unit>
        <trans-unit id="ae72a3031e0506a2cc9019c8072a580c048ea952" translate="yes" xml:space="preserve">
          <source>Kevin Ryde &amp;lt;user42@zip.com.au&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a297e34f70da8957366c0d560c60295f4ab16d2a" translate="yes" xml:space="preserve">
          <source>Key feature milestones include:</source>
          <target state="translated">주요 기능 이정표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc06e1d8824d5b7cbd20d018550616dba1eeb7a3" translate="yes" xml:space="preserve">
          <source>Key naming</source>
          <target state="translated">키 명명</target>
        </trans-unit>
        <trans-unit id="a3bc13a9d5bc9bf56b75f62ed64233e64f24fdcc" translate="yes" xml:space="preserve">
          <source>Key value pairs from the right hash are merged to the left hash. Key collisions are only allowed if their values are the same. This merge function will recurse into nested hash refs following the same merge rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c71372d5d9156fb958ad05c3a06f64214fe7926" translate="yes" xml:space="preserve">
          <source>Key/Value Hash Slices</source>
          <target state="translated">키 / 값 해시 슬라이스</target>
        </trans-unit>
        <trans-unit id="0a8746998a05aa11ad9c2dab8f6c1868e6458dab" translate="yes" xml:space="preserve">
          <source>Key/value pairs are extra information about the module. Fields include:</source>
          <target state="translated">키 / 값 쌍은 모듈에 대한 추가 정보입니다. 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6662c40bac78a8fe5e23219b77087fbe7647cb15" translate="yes" xml:space="preserve">
          <source>Keyboard</source>
          <target state="translated">Keyboard</target>
        </trans-unit>
        <trans-unit id="26057b24ccfdf1266160f8baf076207f8248b2c2" translate="yes" xml:space="preserve">
          <source>Keyed on perl version this contains ISO formatted versions of the release dates, as gleaned from &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlhist&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlist&lt;/a&gt; 에서 얻은이 버전에는 perlist 에서 얻은 ISO 형식의 릴리스 날짜가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96d27593b7b7961c5ceaead578c38d771573f7f6" translate="yes" xml:space="preserve">
          <source>Keyed on perl version this contains ISO formatted versions of the release dates, as gleaned from &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlhist&quot;&gt;perlhist&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d923b20fce2535a3664621e531ef080ff7f9cd6a" translate="yes" xml:space="preserve">
          <source>Keys that are removed and used by run_subtest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8db1e0c3088ee11dfc93f5419a78c6f0fd5645" translate="yes" xml:space="preserve">
          <source>Keywords related to Perl modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60139b7db3e9d2b51751c4b82ebfa525574e434a" translate="yes" xml:space="preserve">
          <source>Keywords related to classes and object-orientation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c704cf16aa5b97aad8158132dfa370f5b954af" translate="yes" xml:space="preserve">
          <source>Keywords related to scoping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a3090a3a955be7eca29e8ad0e959206c052266" translate="yes" xml:space="preserve">
          <source>Keywords related to the control flow of your Perl program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac519cac59842ef7ce692b39ea336e75df75601a" translate="yes" xml:space="preserve">
          <source>Killing the parent process</source>
          <target state="translated">부모 프로세스 종료</target>
        </trans-unit>
        <trans-unit id="76e63bc788196f0fc365bdd0b40b720b363e2116" translate="yes" xml:space="preserve">
          <source>Kirrily &quot;Skud&quot; Robert &amp;lt;skud@cpan.org&amp;gt;</source>
          <target state="translated">Kirrily &quot;Skud&quot;Robert &amp;lt;skud@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="132f84c02455b94d400579a7b40a518ce274e293" translate="yes" xml:space="preserve">
          <source>Know what you're testing. Read the docs, and the source.</source>
          <target state="translated">무엇을 테스트하고 있는지 알고 있습니다. 문서와 소스를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="90303445974fa3fe293cc60d64eaeca6bb4d14c9" translate="yes" xml:space="preserve">
          <source>Known Problems</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="eb6d28effd6acc1d20ab0115a46d456361c67007" translate="yes" xml:space="preserve">
          <source>Known Problems with Perl on Hurd</source>
          <target state="translated">Perl on Hurd의 알려진 문제점</target>
        </trans-unit>
        <trans-unit id="2e89de469fa00e2ab9c34571ade9b38ab1c2cab2" translate="yes" xml:space="preserve">
          <source>Known broken in version 0.07. Apparently works fine in 0.06 though. Patch has been submitted to fix the issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d461ba80b969b65622127de6110a76e9ec3b7a" translate="yes" xml:space="preserve">
          <source>Known broken in versions: 1.0.9 and older</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35d4f63dc3fe926a9db173d1f73bb17b3726246" translate="yes" xml:space="preserve">
          <source>Known problems</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="773f5eaba0582fa827eb62a803e54c124b33061b" translate="yes" xml:space="preserve">
          <source>Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):</source>
          <target state="translated">5.8.0에서 깨지는 것으로 알려져 있지만 5.6.1 및 5.7.2를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="140071254cfb3eb18c0425b733d34c90893547ed" translate="yes" xml:space="preserve">
          <source>Komodo</source>
          <target state="translated">Komodo</target>
        </trans-unit>
        <trans-unit id="cf8178f760b75a0d75931dde9fe9ac37025b060d" translate="yes" xml:space="preserve">
          <source>Korean Encodings</source>
          <target state="translated">한국어 인코딩</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="c142a9ba26a24e1b73db61760826e298c4c0ddcb" translate="yes" xml:space="preserve">
          <source>L [abw]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5009766b33ae437bdfad28ba25b247aa809447e" translate="yes" xml:space="preserve">
          <source>LANGUAGE CLASS HIERARCHIES</source>
          <target state="translated">언어 클래스 계층 구조</target>
        </trans-unit>
        <trans-unit id="306bdaf58d73ea39af3b1402b65b299e6a4795ee" translate="yes" xml:space="preserve">
          <source>LAST UPDATE</source>
          <target state="translated">마지막 업데이트</target>
        </trans-unit>
        <trans-unit id="aeec63655fed08c1f334fcc126280614a35bdd93" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER SHARP S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27af00b4882cabde6c2deac4be8c6e592a196d2a" translate="yes" xml:space="preserve">
          <source>LATIN SMALL LETTER LONG S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f956ece64434b3c753877daa6b0151c6f7f8ddbc" translate="yes" xml:space="preserve">
          <source>LATIN1_TO_NATIVE</source>
          <target state="translated">LATIN1_TO_NATIVE</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="f7314006ff40a8dc21e31c8bdeffdcf14d801b8d" translate="yes" xml:space="preserve">
          <source>LD</source>
          <target state="translated">LD</target>
        </trans-unit>
        <trans-unit id="90ca2bc5ab4dabeeb219828932780cc0dfc4ed8f" translate="yes" xml:space="preserve">
          <source>LDDLFLAGS</source>
          <target state="translated">LDDLFLAGS</target>
        </trans-unit>
        <trans-unit id="931f97ed06ff46676353746b763aa77d0db02597" translate="yes" xml:space="preserve">
          <source>LDFROM</source>
          <target state="translated">LDFROM</target>
        </trans-unit>
        <trans-unit id="7c53807c1836659b4436f686a99f72b3f7ea4a20" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS and LD_RUN_PATH are always empty (this may change in future).</source>
          <target state="translated">LDLOADLIBS와 EXTRALIBS는 Win32에서 항상 동일하며 BSLOADLIBS와 LD_RUN_PATH는 항상 비어 있습니다 (향후 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="27d827eb4792696500b4c73ad4ddf3c959ae3870" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and LD_RUN_PATH</source>
          <target state="translated">LDLOADLIBS 및 LD_RUN_PATH</target>
        </trans-unit>
        <trans-unit id="1635e0d5ca894812009c83cf6cdbe20b68728252" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS contains both the libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; and the CRTLs, if any, specified in Config.pm. EXTRALIBS contains just those libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; . BSLOADLIBS and LD_RUN_PATH are always empty.</source>
          <target state="translated">LDLOADLIBS에는 &lt;code&gt;$potential_libs&lt;/code&gt; 기반으로 찾은 라이브러리 와 Config.pm에 지정된 CRTL이 포함되어 있습니다 . EXTRALIBS는 &lt;code&gt;$potential_libs&lt;/code&gt; 기반으로 찾은 라이브러리 만 포함 합니다. BSLOADLIBS 및 LD_RUN_PATH는 항상 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f16bd8ecb3686b81b8608aa7cbe6a0280958ee3" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS contains both the libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; and the CRTLs, if any, specified in Config.pm. EXTRALIBS contains just those libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt;. BSLOADLIBS and LD_RUN_PATH are always empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256f68025172870d1f3c1210b89212eca54d2c93" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS's default is changed to $Config{libs}.</source>
          <target state="translated">LDLOADLIBS의 기본값은 $ Config {libs}로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="31a999d2e445df6d94c2d10d2f899c4b7a408247" translate="yes" xml:space="preserve">
          <source>LD_LIBRARY_PATH</source>
          <target state="translated">LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="a79d4f252799bf618ff38cdfc040adec85827f0f" translate="yes" xml:space="preserve">
          <source>LEAVE</source>
          <target state="translated">LEAVE</target>
        </trans-unit>
        <trans-unit id="9492fe99bfc78ed50462f6bcf892cde2a90aadb5" translate="yes" xml:space="preserve">
          <source>LEAVE_SRC</source>
          <target state="translated">LEAVE_SRC</target>
        </trans-unit>
        <trans-unit id="4d725158342230fd771b20f0bfaa69c6356a93a2" translate="yes" xml:space="preserve">
          <source>LEAVE_with_name</source>
          <target state="translated">LEAVE_with_name</target>
        </trans-unit>
        <trans-unit id="38a42fd39e3bbdd76ba2dba65bea762f7aea0428" translate="yes" xml:space="preserve">
          <source>LEGACY</source>
          <target state="translated">LEGACY</target>
        </trans-unit>
        <trans-unit id="93eefcbd1b5574d386a865e095b07bc538e3663b" translate="yes" xml:space="preserve">
          <source>LEGACY API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1a39d7d1db940985ed14aca646db0082b3b567" translate="yes" xml:space="preserve">
          <source>LEGACY SUPPORT METHODS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bfcddc6a90029e35325994614f31d2dd6cb263" translate="yes" xml:space="preserve">
          <source>LEN</source>
          <target state="translated">LEN</target>
        </trans-unit>
        <trans-unit id="8753fd6c3b8da3cc6d317b80329ed3b40b2aa912" translate="yes" xml:space="preserve">
          <source>LETTERS</source>
          <target state="translated">LETTERS</target>
        </trans-unit>
        <trans-unit id="f481cc60f17adbd0734ec4396c3eec7ff4f97ae1" translate="yes" xml:space="preserve">
          <source>LEVEL</source>
          <target state="translated">LEVEL</target>
        </trans-unit>
        <trans-unit id="fb391320cf8346ac5c53b8c936b575054a4cdd50" translate="yes" xml:space="preserve">
          <source>LIB</source>
          <target state="translated">LIB</target>
        </trans-unit>
        <trans-unit id="8ebe6b4ea1f79cdf5a0cfe5997e4373110b1513a" translate="yes" xml:space="preserve">
          <source>LIB should only be set at &lt;code&gt;perl Makefile.PL&lt;/code&gt; time but is allowed as a MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB and INSTALLSITELIB to that value regardless any explicit setting of those arguments (or of PREFIX). INSTALLARCHLIB and INSTALLSITEARCH are set to the corresponding architecture subdirectory.</source>
          <target state="translated">LIB는 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 시간 에만 설정해야 하지만 MakeMaker 인수로 허용됩니다. 인수 (또는 PREFIX)의 명시적인 설정에 관계없이 INSTALLPRIVLIB 및 INSTALLSITELIB를 모두 해당 값으로 설정하는 효과가 있습니다. INSTALLARCHLIB 및 INSTALLSITEARCH는 해당 아키텍처 서브 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8788c623d0db3031e8b87cadf67d1df4c5a2fb41" translate="yes" xml:space="preserve">
          <source>LIBPERL_A</source>
          <target state="translated">LIBPERL_A</target>
        </trans-unit>
        <trans-unit id="00484abc2f0a64aaebb7808382f0c80f8b800d94" translate="yes" xml:space="preserve">
          <source>LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL, NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION</source>
          <target state="translated">LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL, NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION</target>
        </trans-unit>
        <trans-unit id="ceb9c454e341a6406ce1dfc1e42b2e34632e5126" translate="yes" xml:space="preserve">
          <source>LIBS</source>
          <target state="translated">LIBS</target>
        </trans-unit>
        <trans-unit id="6e0ad2b047414107e8ce2f294fa40d216b5b68f9" translate="yes" xml:space="preserve">
          <source>LICENCE</source>
          <target state="translated">LICENCE</target>
        </trans-unit>
        <trans-unit id="0417c3cd20e5957970bf6e0315ba11993f41a4ef" translate="yes" xml:space="preserve">
          <source>LICENCE AND COPYRIGHT</source>
          <target state="translated">라이센스 및 저작권</target>
        </trans-unit>
        <trans-unit id="0398ccd0f49298b10a3d76a47800d2ebecd49859" translate="yes" xml:space="preserve">
          <source>LICENSE</source>
          <target state="translated">LICENSE</target>
        </trans-unit>
        <trans-unit id="4935e8e440452679bb6e8677598051c98309501a" translate="yes" xml:space="preserve">
          <source>LIFO</source>
          <target state="translated">LIFO</target>
        </trans-unit>
        <trans-unit id="00e15f5838907cd7e1d4b00639d57748e292cb00" translate="yes" xml:space="preserve">
          <source>LIGHTWEIGHT CALLBACKS</source>
          <target state="translated">경량 콜백</target>
        </trans-unit>
        <trans-unit id="6a872fa8c01524148478fdbe5a27dd0a23bde93f" translate="yes" xml:space="preserve">
          <source>LIKELY</source>
          <target state="translated">LIKELY</target>
        </trans-unit>
        <trans-unit id="929a3a64284b80f705b148843a13caea7da8d500" translate="yes" xml:space="preserve">
          <source>LIMITATIONS</source>
          <target state="translated">LIMITATIONS</target>
        </trans-unit>
        <trans-unit id="e0e14c87e0e2d089b660f73f34d498e64b436810" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of *-x*</source>
          <target state="translated">* -x *의 한계</target>
        </trans-unit>
        <trans-unit id="3850674ed5ef7e98d02bcb7884ce26a4ad1f0c16" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of -x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582303292e0d9bb459bbce59d367e726e77b22ef" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-x의&lt;/b&gt; 한계&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83fa9b97f00ca753b1e5690c43dd3d3361c9665b" translate="yes" xml:space="preserve">
          <source>LIMITS</source>
          <target state="translated">LIMITS</target>
        </trans-unit>
        <trans-unit id="528a45acf62927f5e3020d13509848f28121f5ca" translate="yes" xml:space="preserve">
          <source>LINE</source>
          <target state="translated">LINE</target>
        </trans-unit>
        <trans-unit id="0d7f037733ef398e4fa6caee3e4a76955c742eba" translate="yes" xml:space="preserve">
          <source>LINES</source>
          <target state="translated">LINES</target>
        </trans-unit>
        <trans-unit id="245f22e09d9e6429d729e76e192f663a73a52190" translate="yes" xml:space="preserve">
          <source>LINES_LEFT</source>
          <target state="translated">LINES_LEFT</target>
        </trans-unit>
        <trans-unit id="5a777a56deb32bdeb14873f18eb176dd79982214" translate="yes" xml:space="preserve">
          <source>LINKLIST</source>
          <target state="translated">LINKLIST</target>
        </trans-unit>
        <trans-unit id="2868dce7325577845cbfb4e0cec3533ac2b747a5" translate="yes" xml:space="preserve">
          <source>LINKTYPE</source>
          <target state="translated">LINKTYPE</target>
        </trans-unit>
        <trans-unit id="735cf1665d0fd36f4865e4bc7439abe369572e04" translate="yes" xml:space="preserve">
          <source>LIST</source>
          <target state="translated">LIST</target>
        </trans-unit>
        <trans-unit id="ec269b52cf8883c42dea5c960c258385e031be48" translate="yes" xml:space="preserve">
          <source>LIST DATA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c717fe4bbb26a57f5091a39f5ae5c04c8ba67f80" translate="yes" xml:space="preserve">
          <source>LIST OF LANGUAGES</source>
          <target state="translated">언어 목록</target>
        </trans-unit>
        <trans-unit id="7de1e2b32d16e9fef7b2a9299320e7f3351fbed7" translate="yes" xml:space="preserve">
          <source>LIST OF UTILITIES</source>
          <target state="translated">유틸리티 목록</target>
        </trans-unit>
        <trans-unit id="567a6688f397cbb26479212b5e88b04513465d6e" translate="yes" xml:space="preserve">
          <source>LIST-REDUCTION FUNCTIONS</source>
          <target state="translated">목록 감소 기능</target>
        </trans-unit>
        <trans-unit id="143295635a11822b74bfc416ad32ab68ac277469" translate="yes" xml:space="preserve">
          <source>LISTENING FOR EVENTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79350be1daad6ac703bf5442efacc2b70bd2d6d8" translate="yes" xml:space="preserve">
          <source>LISTs do automatic interpolation of sublists. That is, when a LIST is evaluated, each element of the list is evaluated in list context, and the resulting list value is interpolated into LIST just as if each individual element were a member of LIST. Thus arrays and hashes lose their identity in a LIST--the list</source>
          <target state="translated">LIST는 서브리스트의 자동 보간을 수행합니다. 즉, LIST가 평가 될 때,리스트의 각 요소는리스트 컨텍스트에서 평가되고, 결과적인리스트 값은 각각의 개별 요소가 LIST의 멤버 인 것처럼 LIST에 보간됩니다. 따라서 배열과 해시는 LIST (목록)에서 ID를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="755d87179ae52e75a5bb95a78c2b37c1c06b5cfe" translate="yes" xml:space="preserve">
          <source>LNM$FILE_DEV</source>
          <target state="translated">LNM$FILE_DEV</target>
        </trans-unit>
        <trans-unit id="6747cb39338593bcc94d449a6ee06b08744bc3ce" translate="yes" xml:space="preserve">
          <source>LOADING DRIVERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b95b1479e9e1e6747637c53ec6e7b5b14710300" translate="yes" xml:space="preserve">
          <source>LOCALE</source>
          <target state="translated">LOCALE</target>
        </trans-unit>
        <trans-unit id="ff495344ff0fb9c5d5d9ca658b1dad0e61447a28" translate="yes" xml:space="preserve">
          <source>LOCALE CATEGORIES</source>
          <target state="translated">지역 카테고리</target>
        </trans-unit>
        <trans-unit id="169a463b713e3988d9c565945a1d24d03d787111" translate="yes" xml:space="preserve">
          <source>LOCALE PROBLEMS</source>
          <target state="translated">지역 문제</target>
        </trans-unit>
        <trans-unit id="075620a74284e72caa558c43e5ac902b3bd47d6f" translate="yes" xml:space="preserve">
          <source>LOGDIR</source>
          <target state="translated">LOGDIR</target>
        </trans-unit>
        <trans-unit id="39f15a969419d44e933dbe07a4c0bebe3f003b8b" translate="yes" xml:space="preserve">
          <source>LOGGING</source>
          <target state="translated">LOGGING</target>
        </trans-unit>
        <trans-unit id="95b6b6c48c6cb1e24e041085cc38cb73e88d737e" translate="yes" xml:space="preserve">
          <source>LOOSE MATCHES</source>
          <target state="translated">느슨한 경기</target>
        </trans-unit>
        <trans-unit id="7c472534c424a35d726eafe69cf1b120cf34c7c5" translate="yes" xml:space="preserve">
          <source>LPT1</source>
          <target state="translated">LPT1</target>
        </trans-unit>
        <trans-unit id="4d71de40d2ab4755f078c64dc10f3df863c7dc76" translate="yes" xml:space="preserve">
          <source>LPT2</source>
          <target state="translated">LPT2</target>
        </trans-unit>
        <trans-unit id="dd4d7e2da6df8d44c6d4b3d53b6a80f8f29324f4" translate="yes" xml:space="preserve">
          <source>LVRET</source>
          <target state="translated">LVRET</target>
        </trans-unit>
        <trans-unit id="18cd8d5a0349b94405db9dec7298507ccea49b05" translate="yes" xml:space="preserve">
          <source>LaTeX docs</source>
          <target state="translated">LaTeX 문서</target>
        </trans-unit>
        <trans-unit id="a1b829eae747d240a349da9f0a9a29b98303f5a9" translate="yes" xml:space="preserve">
          <source>Label not found for &quot;last %s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f82157ea2c43397258b632846b3564c599e77f" translate="yes" xml:space="preserve">
          <source>Label not found for &quot;next %s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a081b428c42101382e62175975723a17e6430c" translate="yes" xml:space="preserve">
          <source>Label not found for &quot;redo %s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f308ee988ef0e728f295587e6cbde4a2216497cd" translate="yes" xml:space="preserve">
          <source>Lancaster Concensus: &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md&quot;&gt;https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="f70518aa15c2b8187c80ac13806c15fba56111e6" translate="yes" xml:space="preserve">
          <source>Language Classes</source>
          <target state="translated">언어 수업</target>
        </trans-unit>
        <trans-unit id="cfb711d350591217fd017e0b7ddd59e362322862" translate="yes" xml:space="preserve">
          <source>Language Extensions and Documentation Tools</source>
          <target state="translated">언어 확장 및 설명서 도구</target>
        </trans-unit>
        <trans-unit id="6bd54d34369f11dcd172dcc70f872fcab4fd9483" translate="yes" xml:space="preserve">
          <source>Language Handle Attributes and Internals</source>
          <target state="translated">언어 핸들 속성 및 내부</target>
        </trans-unit>
        <trans-unit id="c91e4f4c0ce2f8eae1ea5e261c4add9fa7392039" translate="yes" xml:space="preserve">
          <source>Language Specs</source>
          <target state="translated">언어 사양</target>
        </trans-unit>
        <trans-unit id="f9d8878de4ae46e5debd26f638420ea68be31544" translate="yes" xml:space="preserve">
          <source>Language classes are what YourProjClass-&amp;gt;get_handle will try to load. It will look for them by taking each language-tag (&lt;b&gt;skipping&lt;/b&gt; it if it doesn't look like a language-tag or locale-tag!), turning it to all lowercase, turning dashes to underscores, and appending it to YourProjClass . &quot;::&quot;. So this:</source>
          <target state="translated">언어 클래스는 YourProjClass-&amp;gt; get_handle이로드하려고하는 것입니다. 각 언어 태그를 가져 와서 ( 언어 태그 나 로케일 태그처럼 보이지 않으면 &lt;b&gt;생략&lt;/b&gt; ), 모든 소문자로 바꾸고 대시를 밑줄로 바꾸고 YourProjClass에 추가하여 찾습니다. &quot;::&quot;. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="747c3b7de1d3c3e77b9c7320590e8b1ede8c25e3" translate="yes" xml:space="preserve">
          <source>Language classes may derive from other language classes (although they should have &quot;use</source>
          <target state="translated">언어 수업은 다른 언어 수업에서 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e10c58f87505ae028c597e6cc528cbbe1058b2" translate="yes" xml:space="preserve">
          <source>Language tags are a formalism, described in RFC 3066 (obsoleting 1766), for declaring what language form (language and possibly dialect) a given chunk of information is in.</source>
          <target state="translated">언어 태그는 RFC 3066 (구식 1766)에 설명 된 형식으로, 주어진 정보 덩어리에 어떤 언어 형식 (언어 및 가능한 방언)을 선언하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="97e909840ec23e6aa4c68a221630c55bfbbb900a" translate="yes" xml:space="preserve">
          <source>Language tags are not case-sensitive. en-US, en-us, En-Us, etc., are all the same tag, and denote the same language.</source>
          <target state="translated">언어 태그는 대소 문자를 구분하지 않습니다. en-US, en-us, En-Us 등은 모두 동일한 태그이며 동일한 언어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2041c3756bf5afe1a1cc3301a6ebbbd4f47a0037" translate="yes" xml:space="preserve">
          <source>Language tags are not country codes. In fact, they are often distinct codes, as with language tag ja for Japanese, and ISO 3166 country code &lt;code&gt;.jp&lt;/code&gt; for Japan.</source>
          <target state="translated">언어 태그는 국가 코드가 아닙니다. 실제로는 일본어의 경우 언어 태그 ja 및 일본의 경우 ISO 3166 국가 코드 &lt;code&gt;.jp&lt;/code&gt; 와 같이 종종 고유 코드 입니다.</target>
        </trans-unit>
        <trans-unit id="6108174a71e0210309b5a122717007cd6591f45e" translate="yes" xml:space="preserve">
          <source>Language tags are not for computer languages.</source>
          <target state="translated">언어 태그는 컴퓨터 언어를위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6368278c82dd6595f994cb8b61fde8b578ee7f10" translate="yes" xml:space="preserve">
          <source>Language tags are not locale IDs. A locale ID is written with a &quot;_&quot; instead of a &quot;-&quot;, (almost?) always matches &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">언어 태그는 로캘 ID가 아닙니다. 로케일 ID가 작성되는 &quot;_&quot;대신에 &quot;-&quot;(? 거의) 항상 일치하는 &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="c3a10dc31440ea548103f890434cb5dc0e0cf98f" translate="yes" xml:space="preserve">
          <source>Language tags are not locale IDs. A locale ID is written with a &quot;_&quot; instead of a &quot;-&quot;, (almost?) always matches &lt;code&gt;m/^\w\w_\w\w\b/&lt;/code&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8edaa0c28ca3e32511fbcd5b5f49058ccc534792" translate="yes" xml:space="preserve">
          <source>Language-Specific</source>
          <target state="translated">Language-Specific</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">대용량 파일 지원</target>
        </trans-unit>
        <trans-unit id="cfd4c46c9150c3e9cafc48d2cf89b769398b7ba2" translate="yes" xml:space="preserve">
          <source>Large language group.</source>
          <target state="translated">큰 언어 그룹.</target>
        </trans-unit>
        <trans-unit id="68cb5c276851e088e954a75127561094108d7ebb" translate="yes" xml:space="preserve">
          <source>Large numbers of other programmers will be using your code modules.</source>
          <target state="translated">많은 다른 프로그래머들이 코드 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aed9d519447abe0e1e87e2be7e3184966a86c56b" translate="yes" xml:space="preserve">
          <source>Larger increments or decrements are handy in those cases where a thread needs to check out or return a number of resources at once.</source>
          <target state="translated">스레드가 한 번에 많은 자원을 체크 아웃하거나 리턴해야하는 경우 더 큰 증가 또는 감소가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="fd62837b713bdee00d46e7ce620e1a597b3acf56" translate="yes" xml:space="preserve">
          <source>Larry Wall</source>
          <target state="translated">래리 벽</target>
        </trans-unit>
        <trans-unit id="d125a04b7cfbc6bf9a0d7e4500f4ff8af7def2b3" translate="yes" xml:space="preserve">
          <source>Larry Wall &amp;lt;larry@wall.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9800616a976bc743bc49de05b3ff6a81a8fed2bf" translate="yes" xml:space="preserve">
          <source>Larry Wall &amp;lt;larry@wall.org&amp;gt;, with the help of oodles of other folks.</source>
          <target state="translated">래리 월 &amp;lt;larry@wall.org&amp;gt;, 다른 사람들의 국수의 도움으로.</target>
        </trans-unit>
        <trans-unit id="50431f0b84e94e89d59726aa67764d4b5cb64130" translate="yes" xml:space="preserve">
          <source>Larry Wall and others</source>
          <target state="translated">래리 벽 및 기타</target>
        </trans-unit>
        <trans-unit id="0fb4b4d75483396b0cb6c4053090cf1353b0f053" translate="yes" xml:space="preserve">
          <source>Larry Wall designed the elegant inherited bootstrap mechanism and implemented the first Perl 5 dynamic loader using it.</source>
          <target state="translated">Larry Wall은 우아한 상속 부트 스트랩 메커니즘을 설계하고이를 사용하여 최초의 Perl 5 동적 로더를 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="49cef125f502490a3eaa452e5063337afd4e5415" translate="yes" xml:space="preserve">
          <source>Larry Wall, Sean M. Burke</source>
          <target state="translated">래리 월, 숀 엠 버크</target>
        </trans-unit>
        <trans-unit id="cad8518108cca44400e2368862a0f1a16bff95c7" translate="yes" xml:space="preserve">
          <source>Larry has his reasons for each of these things, but he doesn't claim that everyone else's mind works the same as his does.</source>
          <target state="translated">래리는 이런 것들에 대한 이유가 있지만 다른 사람의 마음이 자신의 생각과 동일하게 작동한다고 주장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e11f8268af6857ace69f95b629b0d80778d0d6d" translate="yes" xml:space="preserve">
          <source>Larry is allowed to change his mind about any matter at a later date, regardless of whether he previously invoked Rule 1.</source>
          <target state="translated">Larry는 이전에 규칙 1을 호출했는지 여부에 관계없이 나중에 모든 사안에 대해 마음을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d699c187f5eebff127e90268deebe55f0277f7" translate="yes" xml:space="preserve">
          <source>Larry is always by definition right about how Perl should behave. This means he has final veto power on the core functionality.</source>
          <target state="translated">래리는 펄이 어떻게 행동해야하는지에 대해 정의상 항상 권리입니다. 이것은 그가 핵심 기능에 대한 최종 거부권을 가지고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="91247cb31b4e3f24a173a3ed4edb3fbe905e9dfa" translate="yes" xml:space="preserve">
          <source>Larry said &quot;Although the Perl Slogan is</source>
          <target state="translated">래리는 &quot;펄 슬로건은</target>
        </trans-unit>
        <trans-unit id="8840809999231d8845f9dcc8eb994457fd02a531" translate="yes" xml:space="preserve">
          <source>Larry sees Perl development along the lines of the US government: there's the Legislature (the porters), the Executive branch (the -pumpking), and the Supreme Court (Larry). The legislature can discuss and submit patches to the executive branch all they like, but the executive branch is free to veto them. Rarely, the Supreme Court will side with the executive branch over the legislature, or the legislature over the executive branch. Mostly, however, the legislature and the executive branch are supposed to get along and work out their differences without impeachment or court cases.</source>
          <target state="translated">Larry는 미국 정부에 따라 Perl의 발전을 봅니다. 입법부 (포터), 행정부 (펌핑) 및 대법원 (래리)이 있습니다. 입법부는 원하는대로 행정부와 논의하고 패치를 제출할 수 있지만 행정부는 자유롭게 거부 할 수 있습니다. 드물게 대법원은 입법부 상무부 또는 입법부 상원과 나란히있을 것입니다. 그러나 대부분 입법부와 행정부는 탄핵이나 법정 사건없이 그 차이를 해결하고 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae001311ff213d6955f7360f41d0eb019566259e" translate="yes" xml:space="preserve">
          <source>Lars Dieckow &amp;lt;daxim@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c4e4485ad3dbbdb5b5dd2e9dedc2315a7311d5" translate="yes" xml:space="preserve">
          <source>Last Changed</source>
          <target state="translated">마지막 변경</target>
        </trans-unit>
        <trans-unit id="1210639f474f0d343df95007771fdc202b411de7" translate="yes" xml:space="preserve">
          <source>Last In, First Out. See also &lt;b&gt;FIFO&lt;/b&gt;. A LIFO is usually called a &lt;b&gt;stack&lt;/b&gt;.</source>
          <target state="translated">후입 선출법. &lt;b&gt;FIFO&lt;/b&gt; 도 참조하십시오 . LIFO는 일반적으로 &lt;b&gt;스택&lt;/b&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="40830c73142a53064766f6ffa38ec5fccd97ec73" translate="yes" xml:space="preserve">
          <source>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</source>
          <target state="translated">최종 업데이트 : 1999 년 10 월 29 일 금요일 22:50:30 +0200</target>
        </trans-unit>
        <trans-unit id="f1e5fc7462efd81797093d9980b1aa8171197971" translate="yes" xml:space="preserve">
          <source>Last but not least, here are various tips for safer coding. See also &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt; for libc/stdio replacements one should use.</source>
          <target state="translated">마지막으로 안전한 코딩을위한 다양한 팁이 있습니다. &lt;a href=&quot;perlclib&quot;&gt;사용해야&lt;/a&gt; 하는 libc / stdio 대체에 대해서는 perlclib 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dceffa1b326ba5ef1523c69acacd202e09a06fa6" translate="yes" xml:space="preserve">
          <source>Last modified 2013-04-29.</source>
          <target state="translated">마지막 수정 2013-04-29.</target>
        </trans-unit>
        <trans-unit id="5c3f1c04106319751d7e999882c029924d60d858" translate="yes" xml:space="preserve">
          <source>Last revised 14-Feb-1996, for Perl 5.002.</source>
          <target state="translated">Perl 5.002를 위해 1996 년 2 월 14 일 최종 개정.</target>
        </trans-unit>
        <trans-unit id="c3eb2ac9f32e61251e1875ad9708ab6315be2573" translate="yes" xml:space="preserve">
          <source>Last revised 8-Oct-2010, for Perl 5.13.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c838bd278b91a142d60ea0e71aa5a59ad40e1552" translate="yes" xml:space="preserve">
          <source>Last update: 2008-10-29</source>
          <target state="translated">최종 업데이트 : 2008-10-29</target>
        </trans-unit>
        <trans-unit id="fc7ec2c58f8d11214b25d3966287144f54470cfe" translate="yes" xml:space="preserve">
          <source>Last update: Tue Apr 26 18:30:55 MDT 2011</source>
          <target state="translated">마지막 업데이트 : 4 월 26 일 화요일 18:30:55 MDT 2011</target>
        </trans-unit>
        <trans-unit id="fedbd273e34471c334909a9855d4fede2b18756d" translate="yes" xml:space="preserve">
          <source>Last updated for perl 5.23.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25a330cf94331e783b24031686ddd1e4f1da4ff" translate="yes" xml:space="preserve">
          <source>Last updated: 07 October 2014</source>
          <target state="translated">최종 업데이트 : 2014 년 10 월 7 일</target>
        </trans-unit>
        <trans-unit id="e1651fd9e16da0fb6683f8baa5303f215ef932af" translate="yes" xml:space="preserve">
          <source>Last updated: 2012-02-08</source>
          <target state="translated">최종 업데이트 : 2012-02-08</target>
        </trans-unit>
        <trans-unit id="f1b2c64ff3a41edcd2ecadfbbdf23ab6e9aa3f07" translate="yes" xml:space="preserve">
          <source>Last updated: 30 April 2019</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152779e4c8b9d8d930bb573d8f364d8d186f33dd" translate="yes" xml:space="preserve">
          <source>Lastly, the</source>
          <target state="translated">마지막으로</target>
        </trans-unit>
        <trans-unit id="4d407485e169287b1c2aa3f4a4b85bc45bed7a87" translate="yes" xml:space="preserve">
          <source>Lastly, there is a special method for working under &lt;b&gt;-T&lt;/b&gt; and setuid/gid scripts:</source>
          <target state="translated">마지막으로 &lt;b&gt;-T&lt;/b&gt; 및 setuid / gid 스크립트 에서 작업하기위한 특별한 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202e6182477b0bfd7c1ee15e20cf42a59755cdd1" translate="yes" xml:space="preserve">
          <source>Laszlo Molnar,</source>
          <target state="translated">라즐로 몰 나르,</target>
        </trans-unit>
        <trans-unit id="526c6b8794fab24bec118be16f23def6a69bab1c" translate="yes" xml:space="preserve">
          <source>Lately, ignoring or actively opposing compatibility with earlier versions of Perl has come into vogue. Sometimes, a change is proposed which wants to usurp syntax which previously had another meaning. Sometimes, a change wants to improve previously-crazy semantics.</source>
          <target state="translated">최근에는 이전 버전의 Perl과의 호환성을 무시하거나 적극적으로 반대하고 있습니다. 때로는 이전에 다른 의미를 가진 구문을 빼내려는 변경이 제안되기도합니다. 때때로, 변화는 이전에 미친 의미론을 개선하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="36e7725e6d39280db73b49ece64538b8d66586a2" translate="yes" xml:space="preserve">
          <source>Later in the life of the object the methods may be queries with get() method and set() method (which accept multiple arguments).</source>
          <target state="translated">나중에 객체의 수명에서 메소드는 get () 메소드 및 set () 메소드를 사용하는 쿼리 일 수 있습니다 (여러 인수를 허용 함).</target>
        </trans-unit>
        <trans-unit id="6e71bb4c4e3671df8bee4472c56c5267f4268f7f" translate="yes" xml:space="preserve">
          <source>Later invocations of coloralias() with the same ALIAS will override earlier aliases. There is no way to remove an alias.</source>
          <target state="translated">동일한 ALIAS를 사용한 coloralias ()의 이후 호출은 이전 별명을 대체합니다. 별명을 제거 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c58245493d9e35fde84415d863d1963037986377" translate="yes" xml:space="preserve">
          <source>Later on, we'll pass this to Configure through -Dtargetenv</source>
          <target state="translated">나중에 -Dtargetenv를 통해 구성으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f8e3805b10e4c4f4b08c327d5a5b182642f7a406" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http://search.cpan.org/search?module=threads&lt;/a&gt;</source>
          <target state="translated">CPAN 의 최신 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 버전 : &lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http://search.cpan.org/search?module=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab352e5ac1e025a34124fd8091aaf11aba38a34e" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; on CPAN: &lt;a href=&quot;https://metacpan.org/pod/threads&quot;&gt;https://metacpan.org/pod/threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dfbb7924a9e791a0e250e51336f5378e1751eb" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http://search.cpan.org/search?module=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">최신 버전의 &lt;a href=&quot;threads/shared&quot;&gt;스레드 :: 공유&lt;/a&gt; CPAN : &lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http://search.cpan.org/search?module=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9dd3a57a43ed9b942b39841e2da67e396eb27a54" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; on CPAN: &lt;a href=&quot;https://metacpan.org/pod/threads::shared&quot;&gt;https://metacpan.org/pod/threads::shared&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e8cec14c4a568ca92f36bd23fabb426a1d8b2d" translate="yes" xml:space="preserve">
          <source>Latin 1 (ISO 8859-1)</source>
          <target state="translated">라틴어 1 (ISO 8859-1)</target>
        </trans-unit>
        <trans-unit id="c5f5bb3b350774d7cda57104c55fb6c82b7ae7d9" translate="yes" xml:space="preserve">
          <source>Latvia</source>
          <target state="translated">Latvia</target>
        </trans-unit>
        <trans-unit id="35bde1b1448a3634844f710f6f0c19bb97cc5c1e" translate="yes" xml:space="preserve">
          <source>Laundering and Detecting Tainted Data</source>
          <target state="translated">오염 된 데이터의 세탁 및 탐지</target>
        </trans-unit>
        <trans-unit id="467f628abddb4dcd106efd4dcaeb617681eb8f7d" translate="yes" xml:space="preserve">
          <source>Layer allows buffer snooping.</source>
          <target state="translated">레이어는 버퍼 스누핑을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cb8d6c688037b3d7cd03ae365bbe000a64676df9" translate="yes" xml:space="preserve">
          <source>Layer can translate between &quot;\n&quot; and CRLF line ends.</source>
          <target state="translated">레이어는 &quot;\ n&quot;과 CRLF 줄 끝 사이를 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12b05c07cab44e1c8dc0e859b671ac3d7cccd05" translate="yes" xml:space="preserve">
          <source>Layer is line buffered. Write data should be passed to next layer down whenever a &quot;\n&quot; is seen. Any data beyond the &quot;\n&quot; should then be processed.</source>
          <target state="translated">레이어가 라인 버퍼링됩니다. &quot;\ n&quot;이 표시 될 때마다 쓰기 데이터가 다음 계층으로 전달되어야합니다. 그런 다음 &quot;\ n&quot;이외의 모든 데이터를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="63a50a8c52a6d0d048f4fa59a33a9d88e95e80ac" translate="yes" xml:space="preserve">
          <source>Layer is performing Win32-like &quot;\n&quot; mapped to CR,LF for output and CR,LF mapped to &quot;\n&quot; for input. Normally the provided &quot;crlf&quot; layer is the only layer that need bother about this. &lt;code&gt;PerlIO_binmode()&lt;/code&gt; will mess with this flag rather than add/remove layers if the &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; bit is set for the layers class.</source>
          <target state="translated">레이어가 출력에 대해서는 CR, LF에 매핑 된 Win32와 유사한 &quot;\ n&quot;을 수행하고 입력에 대해서는 &quot;\ n&quot;에 매핑 된 CR, LF를 수행합니다. 일반적으로 제공된 &quot;crlf&quot;레이어는 이에 대해 신경 쓰는 유일한 레이어입니다. &lt;code&gt;PerlIO_binmode()&lt;/code&gt; 비트가 레이어 클래스에 대해 설정된 경우 PerlIO_binmode () 는 레이어를 추가 / 제거하지 않고이 플래그를 엉망으로 &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb03ef93aa3ad216c22ac53a17958f564d0c42cd" translate="yes" xml:space="preserve">
          <source>Layer is unbuffered - i.e. write to next layer down should occur for each write to this layer.</source>
          <target state="translated">레이어는 버퍼링되지 않습니다. 즉,이 레이어에 쓸 때마다 다음 레이어에 쓰기가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f3401294ca5c3ec99fdd44fd405f62db10c762f" translate="yes" xml:space="preserve">
          <source>Layer which calls &lt;code&gt;fread&lt;/code&gt; , &lt;code&gt;fwrite&lt;/code&gt; and &lt;code&gt;fseek&lt;/code&gt; /&lt;code&gt;ftell&lt;/code&gt; etc. Note that as this is &quot;real&quot; stdio it will ignore any layers beneath it and go straight to the operating system via the C library as usual.</source>
          <target state="translated">&lt;code&gt;fread&lt;/code&gt; , &lt;code&gt;fwrite&lt;/code&gt; 및 &lt;code&gt;fseek&lt;/code&gt; / &lt;code&gt;ftell&lt;/code&gt; 등 을 호출하는 레이어. 이것은 &quot;실제&quot;stdio이므로 그 아래의 모든 레이어를 무시하고 평소와 같이 C 라이브러리를 통해 운영 체제로 바로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="433c9dfe2472dbf21d6a258158fca98f65d2907f" translate="yes" xml:space="preserve">
          <source>Layer which calls &lt;code&gt;fread&lt;/code&gt;, &lt;code&gt;fwrite&lt;/code&gt; and &lt;code&gt;fseek&lt;/code&gt;/&lt;code&gt;ftell&lt;/code&gt; etc. Note that as this is &quot;real&quot; stdio it will ignore any layers beneath it and go straight to the operating system via the C library as usual. This layer implements both low level IO and buffering, but is rarely used on modern architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f055f18aeadcf43179462eaf15e54d98e16c8b02" translate="yes" xml:space="preserve">
          <source>Layers</source>
          <target state="translated">Layers</target>
        </trans-unit>
        <trans-unit id="1657b47a449f7c4cf8948737db9fde6acf3a60e8" translate="yes" xml:space="preserve">
          <source>Layers are specified with a leading colon by convention. You can specify a stack of multiple layers as a space-separated string. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more information on the available layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff9f300fa7d1bbc3f849481cc645ec702a3625b" translate="yes" xml:space="preserve">
          <source>Layers can be made available by extension modules. When an unknown layer is encountered the PerlIO code will perform the equivalent of :</source>
          <target state="translated">확장 모듈로 레이어를 사용할 수 있습니다. 알 수없는 레이어가 발견되면 PerlIO 코드는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0e3178f7991d7264f18bf3f06ccf8bf03e08f4f6" translate="yes" xml:space="preserve">
          <source>Layers in action.</source>
          <target state="translated">실제 레이어.</target>
        </trans-unit>
        <trans-unit id="90a85751546d30690f93cf14e09e26b8d8de391b" translate="yes" xml:space="preserve">
          <source>Layers it makes sense to include in the PERLIO environment variable are briefly summarized below. For more details see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;.</source>
          <target state="translated">PERLIO 환경 변수에 포함하는 것이 적합한 계층은 아래에 간략하게 요약되어 있습니다. 자세한 내용은 &lt;a href=&quot;perlio&quot;&gt;PerlIO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69114be10292080f3d4afeef56cf245603257cc6" translate="yes" xml:space="preserve">
          <source>Layers vs Disciplines</source>
          <target state="translated">레이어 대 분야</target>
        </trans-unit>
        <trans-unit id="a41c1d3ed9255c2fe23288b7c102a2dc110d982d" translate="yes" xml:space="preserve">
          <source>Lazy people and beginners may now stop reading the manual.</source>
          <target state="translated">게으른 사람들과 초보자는 이제 매뉴얼 읽기를 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f359f1580c6817c9a64d72d3882cfe9dcbaef9" translate="yes" xml:space="preserve">
          <source>Le Sergent, T. and B. Berthomieu. &quot;Incremental MultiThreaded Garbage Collection on Virtually Shared Memory Architectures&quot; in Memory Management: Proc. of the International Workshop IWMM 92, St. Malo, France, September 1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN 3540-55940-X (real-life thread applications).</source>
          <target state="translated">Le Sergent, T. 및 B. Berthomieu. 메모리 관리 : Proc. &quot;가상 공유 메모리 아키텍처의 증분 다중 스레드 가비지 콜렉션&quot; 국제 워크숍 IWMM 92, 1992 년 9 월, 프랑스 생 말로, 이브 베 커스 및 자크 코헨, eds. Springer, 1992, ISBN 3540-55940-X (실제 스레드 응용 프로그램).</target>
        </trans-unit>
        <trans-unit id="bd162d2f93cdcba4f68be85d18fd26ee09a12efb" translate="yes" xml:space="preserve">
          <source>Leading and trailing colons can be used together if you need positional parameter values without the names. Note that in the case below, the &lt;code&gt;PERL_API&lt;/code&gt; params are returned in alphabetical order.</source>
          <target state="translated">이름없이 위치 매개 변수 값이 필요한 경우 선행 및 후행 콜론을 함께 사용할 수 있습니다. 아래의 경우 &lt;code&gt;PERL_API&lt;/code&gt; 매개 변수는 알파벳 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21aea14ed2f508e6237030730dc68ea8c248a0f7" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14de4e5c4a9c26aff3dbb9f05745a468eb0274d0" translate="yes" xml:space="preserve">
          <source>Leading and trailing zeros are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46907cff7c02a850b549a727a75b341cfa614b27" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19eb901d0541a10b461432e6635be906ecd8d19" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">선행 공백은 소수점과 같이 뒤에 오는 숫자가 아니기 때문에 경고없이 무시됩니다. &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 는 음이 아닌 정수 또는 부동 소수점이 아닌 음이 아닌 정수만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fb2634197a046f8fbd1bb749b3d21bb890485f5f" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">선행 공백은 소수점과 같이 뒤에 오는 숫자가 아니기 때문에 경고없이 무시됩니다. &lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 는 음이 아닌 정수 또는 부동 소수점이 아닌 음이 아닌 정수만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ba3f4ebacb603a1ffae736f19b872df26ac931b0" translate="yes" xml:space="preserve">
          <source>Learn Perl and rewrite it. Seriously, there's no simple converter. Things that are awkward to do in the shell are easy to do in Perl, and this very awkwardness is what would make a shell-&amp;gt;perl converter nigh-on impossible to write. By rewriting it, you'll think about what you're really trying to do, and hopefully will escape the shell's pipeline datastream paradigm, which while convenient for some matters, causes many inefficiencies.</source>
          <target state="translated">Perl을 배우고 다시 작성하십시오. 정말로 간단한 변환기는 없습니다. 쉘에서 어색한 것들이 Perl에서하기 쉽다. 그리고이 매우 어색한 것은 쉘-&amp;gt; 펄 변환기를 거의 쓸 수 없게 만드는 것이다. 다시 작성하면 실제로 수행하려는 작업에 대해 생각하고 일부 문제에 편리하지만 많은 비 효율성을 유발하는 셸의 파이프 라인 데이터 스트림 패러다임을 피할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4dd0a48cec0f53000c96d709bef9efb450bae6d8" translate="yes" xml:space="preserve">
          <source>Leaving out the Notify option usually defaults an SMTP service to its default behavior equivalent to ['FAILURE'] notifications only, but again this may be dependent upon your site's SMTP configuration.</source>
          <target state="translated">알림 옵션을 제외하면 일반적으로 SMTP 서비스는 기본적으로 [ 'FAILURE'] 알림과 동등한 기본 동작으로 기본 설정되지만 사이트의 SMTP 구성에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c7551b205677232e62bc969aaaea5621b25584" translate="yes" xml:space="preserve">
          <source>Lee Johnson &amp;lt;notfadeaway at btinternet dot com&amp;gt;</source>
          <target state="translated">이 존슨 &amp;lt;btinternet 닷 컴에서 사라지지 않음&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b6a5edc3102ea975638e0ce2bb8f6982f95bead8" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, creating a new string:</source>
          <target state="translated">임의의 문자로 왼쪽 및 오른쪽 패딩, 새 문자열 생성 :</target>
        </trans-unit>
        <trans-unit id="7f1c7df67c81bb16bff18c751738160fab5ff982" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, modifying &lt;code&gt;$text&lt;/code&gt; directly:</source>
          <target state="translated">&lt;code&gt;$text&lt;/code&gt; 직접 수정하여 모든 문자로 왼쪽 및 오른쪽 패딩 :</target>
        </trans-unit>
        <trans-unit id="af98dcfaae79ce4ac9aa9fbbe9635687fe2fe178" translate="yes" xml:space="preserve">
          <source>Left offset from pos() to start match at.</source>
          <target state="translated">일치를 시작할 pos ()에서 왼쪽 오프셋.</target>
        </trans-unit>
        <trans-unit id="32ff2067f2a9f0deffe08043bfbad0999ed3babf" translate="yes" xml:space="preserve">
          <source>LeftString</source>
          <target state="translated">LeftString</target>
        </trans-unit>
        <trans-unit id="fb74bcaf76999b5ef8dae81b1022d842c093fe10" translate="yes" xml:space="preserve">
          <source>Legacy</source>
          <target state="translated">Legacy</target>
        </trans-unit>
        <trans-unit id="177a7c67030b56d701d66da14735a0847871d1fb" translate="yes" xml:space="preserve">
          <source>Legacy Character Sets</source>
          <target state="translated">레거시 문자 세트</target>
        </trans-unit>
        <trans-unit id="45890076a74f7ba49cb141341bf0a665659f9168" translate="yes" xml:space="preserve">
          <source>Legacy Encodings</source>
          <target state="translated">레거시 인코딩</target>
        </trans-unit>
        <trans-unit id="ca20c7f742784eaf8c9542c65094bd868679305e" translate="yes" xml:space="preserve">
          <source>Legacy multi byte EBCDIC code pages XXX.</source>
          <target state="translated">레거시 멀티 바이트 EBCDIC 코드 페이지 XXX.</target>
        </trans-unit>
        <trans-unit id="7d1f21ee00bf8431c5da8e1a72603db078d1e391" translate="yes" xml:space="preserve">
          <source>Legacy usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632363f7b0b4709b3208536a8ec83f44895c04cc" translate="yes" xml:space="preserve">
          <source>Legacy wrapper fro &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14ba2ec2e45438ad3facc4d4b02bd06eedc0c59" translate="yes" xml:space="preserve">
          <source>Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond &lt;code&gt;U+FFFF&lt;/code&gt; , because it does not use surrogates. UCS-4 is a 32-bit encoding, functionally identical to UTF-32 (the difference being that UCS-4 forbids neither surrogates nor code points larger than &lt;code&gt;0x10_FFFF&lt;/code&gt; ).</source>
          <target state="translated">ISO 10646 표준에 의해 정의 된 레거시 고정 너비 인코딩 UCS-2는 16 비트 인코딩입니다. UTF-16과 달리 UCS-2는 대리자를 사용하지 않기 때문에 &lt;code&gt;U+FFFF&lt;/code&gt; 이상으로 확장 할 수 없습니다. UCS-4는 기능적으로 UTF-32와 동일한 32 비트 인코딩입니다 (UCS-4가 &lt;code&gt;0x10_FFFF&lt;/code&gt; 보다 큰 대리 나 코드 포인트를 금지하지 않는다는 차이점 ).</target>
        </trans-unit>
        <trans-unit id="3b6664ed1e448ada62088f03c80e41e23a96a928" translate="yes" xml:space="preserve">
          <source>Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond &lt;code&gt;U+FFFF&lt;/code&gt;, because it does not use surrogates. UCS-4 is a 32-bit encoding, functionally identical to UTF-32 (the difference being that UCS-4 forbids neither surrogates nor code points larger than &lt;code&gt;0x10_FFFF&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bd3b0c39f79b172b2c117ae638fd62dd4f1072" translate="yes" xml:space="preserve">
          <source>Legacy, this is currently a no-op that returns 0;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a83ae1dc6e4e324ce120afa5a8e7b91193b805" translate="yes" xml:space="preserve">
          <source>Legal &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs that match no characters</source>
          <target state="translated">문자와 일치하지 않는 유효한 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 구문</target>
        </trans-unit>
        <trans-unit id="b01926f0986a11c72cf140417a7b70c5868b0797" translate="yes" xml:space="preserve">
          <source>Legal \p{} and \P{} constructs that match no characters</source>
          <target state="translated">문자와 일치하지 않는 유효한 \ p {} 및 \ P {} 구문</target>
        </trans-unit>
        <trans-unit id="8b37e0171cc1c8f695fff30ed31b832cbddee2f1" translate="yes" xml:space="preserve">
          <source>Legend of characters above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f35de278fd2499acf694739f13d5aa76297107" translate="yes" xml:space="preserve">
          <source>Leif Eriksen &amp;lt;leif dot eriksen at bigpond dot com&amp;gt;</source>
          <target state="translated">Leif Eriksen &amp;lt;빅폰 닷 컴의 Leif Dot eriksen&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6115881c5ecab4a82072aab1fbcafeaf5ae5a302" translate="yes" xml:space="preserve">
          <source>Length of the name.</source>
          <target state="translated">이름의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1deb1eed10d40a0d45e6e2d30e54152b66733959" translate="yes" xml:space="preserve">
          <source>Length to truncate the argument list when the &lt;code&gt;frame&lt;/code&gt; option's bit 4 is set.</source>
          <target state="translated">&lt;code&gt;frame&lt;/code&gt; 옵션의 비트 4가 설정된 경우 인수 목록을자를 길이 입니다.</target>
        </trans-unit>
        <trans-unit id="1d1a91bdc1315d2ef3c37c514f4e0b41950b2992" translate="yes" xml:space="preserve">
          <source>Lengths and Widths</source>
          <target state="translated">길이와 폭</target>
        </trans-unit>
        <trans-unit id="d32b0b56fe2109af2e400ced24b899e2e7e6bed2" translate="yes" xml:space="preserve">
          <source>Leon Timmermans &amp;lt;fawaka@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4d25e02c52538201b9cb795664e476bf2e16bc" translate="yes" xml:space="preserve">
          <source>Leon Timmermans &amp;lt;leont@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c763c85942db32f81cf9ff36bb94bec3c42bb459" translate="yes" xml:space="preserve">
          <source>Let Perldoc check Pod for errors</source>
          <target state="translated">Perldoc에서 포드에 오류가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="236e4f11c45d6dc4aeeb3e3ee19570b2cee88f0e" translate="yes" xml:space="preserve">
          <source>Let Perldoc convert Pod to nroff</source>
          <target state="translated">Perldoc가 포드를 nroff로 변환하게하십시오</target>
        </trans-unit>
        <trans-unit id="974a4ac3dfc20423e93f62bd6d7257d2efff060e" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as ... Pod!</source>
          <target state="translated">Perldoc가 포드를 ... 포드로 렌더링하도록하십시오!</target>
        </trans-unit>
        <trans-unit id="89789b71272a03c7a7d2242762bf736542d90944" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as RTF</source>
          <target state="translated">Perldoc가 포드를 RTF로 렌더링하도록하십시오</target>
        </trans-unit>
        <trans-unit id="a09176a65c16f1ea87e512ddbd1ebf583706c4be" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as XML</source>
          <target state="translated">Perldoc가 포드를 XML로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="9dd1bef5afa3543070a44bc3e67a86b4a5626d33" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as man pages</source>
          <target state="translated">Perldoc가 포드를 맨 페이지로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="cb573ad7df52482623e8e613fdbfbc5f59abce18" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as plaintext</source>
          <target state="translated">Perldoc가 포드를 일반 텍스트로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="d279d6ba36fcd7e038b9dea67ba4516a9df60977" translate="yes" xml:space="preserve">
          <source>Let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">Perldoc이 Tk :: Pod를 사용하여 포드를 렌더링하게하십시오.</target>
        </trans-unit>
        <trans-unit id="757e98b6ce9386f0fb646f3598168b1185dc8359" translate="yes" xml:space="preserve">
          <source>Let it be noted that the flakiness of indirect filehandles is not related to whether they're strings, typeglobs, objects, or anything else. It's the syntax of the fundamental operators. Playing the object game doesn't help you at all here.</source>
          <target state="translated">간접 파일 핸들의 단점은 문자열, 타입 글로브, 객체 또는 다른 것과 관련이 없습니다. 기본 연산자의 구문입니다. 객체 게임을하는 것이 전혀 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fe958b2a6ee1393677c318cb2bd2d9b92f2cd48" translate="yes" xml:space="preserve">
          <source>Let it be stressed that</source>
          <target state="translated">그것을 강조하자</target>
        </trans-unit>
        <trans-unit id="b48514691c5b46e8297541220211ccc8b070316c" translate="yes" xml:space="preserve">
          <source>Let the index expire after how many days?</source>
          <target state="translated">며칠 후에 색인이 만료되도록 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="c1338ab2b041d88118e285278d063d0f4210f6e9" translate="yes" xml:space="preserve">
          <source>Let us now discuss Unicode character classes, most usually called &quot;character properties&quot;. These are represented by the &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; escape sequence. The negation of this is &lt;code&gt;\P{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;. For example, to match lower and uppercase characters,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6104cb2c1f6570ab357e214a9780db2e76a15675" translate="yes" xml:space="preserve">
          <source>Let us now discuss Unicode character classes, most usually called &quot;character properties&quot;. These are represented by the &lt;code&gt;\p{name}&lt;/code&gt; escape sequence. Closely associated is the &lt;code&gt;\P{name}&lt;/code&gt; property, which is the negation of the &lt;code&gt;\p{name}&lt;/code&gt; one. For example, to match lower and uppercase characters,</source>
          <target state="translated">이제 가장 일반적으로 &quot;문자 속성&quot;이라고하는 유니 코드 문자 클래스에 대해 설명하겠습니다. 이는 &lt;code&gt;\p{name}&lt;/code&gt; 이스케이프 시퀀스로 표시됩니다. 밀접하게 연관되어 &lt;code&gt;\P{name}&lt;/code&gt; 의 부정 인 속성 &lt;code&gt;\p{name}&lt;/code&gt; 하나. 예를 들어 소문자와 대문자를 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="d5b865b005185fbf91c141118661a5d11906d96e" translate="yes" xml:space="preserve">
          <source>Let's also fix the MANIFEST file so that it accurately reflects the contents of our extension. The single line that says &quot;mylib&quot; should be replaced by the following three lines:</source>
          <target state="translated">MANIFEST 파일을 수정하여 확장 내용을 정확하게 반영 해 봅시다. &quot;mylib&quot;라고 표시된 한 줄은 다음 세 줄로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="f577dbeceee6187e31fa08c5d2d55b7b25ccea26" translate="yes" xml:space="preserve">
          <source>Let's assume that we have a package &lt;code&gt;Cool::Foo&lt;/code&gt; , which includes &lt;code&gt;Cool::Foo&lt;/code&gt; and &lt;code&gt;Cool::Bar&lt;/code&gt; modules each having a separate XS file. First we use the following</source>
          <target state="translated">하자 우리가 패키지가 있다고 가정 &lt;code&gt;Cool::Foo&lt;/code&gt; 포함 &lt;code&gt;Cool::Foo&lt;/code&gt; 와 &lt;code&gt;Cool::Bar&lt;/code&gt; 각각 별도의 XS 파일을 가진 모듈. 먼저 우리는 다음을 사용합니다</target>
        </trans-unit>
        <trans-unit id="f9cbac3ad4b48c1f15258c105ba2e7521b56e827" translate="yes" xml:space="preserve">
          <source>Let's assume that we have a package &lt;code&gt;Cool::Foo&lt;/code&gt;, which includes &lt;code&gt;Cool::Foo&lt;/code&gt; and &lt;code&gt;Cool::Bar&lt;/code&gt; modules each having a separate XS file. First we use the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0ca95dec9c2d9636bc8d5032b2d5f394a81699" translate="yes" xml:space="preserve">
          <source>Let's begin by looking a simple scalar which is holding a string.</source>
          <target state="translated">문자열을 보유하고있는 간단한 스칼라를 살펴 보는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b81e7623e4177f0bbf011b090062ef49e50b2" translate="yes" xml:space="preserve">
          <source>Let's consider how different regexps would match &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; :</source>
          <target state="translated">다른 정규 표현식이 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 와 어떻게 일치하는지 고려해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6aca9f9e3f0c9c3d03f0d9c58efc7677ff8a8ff8" translate="yes" xml:space="preserve">
          <source>Let's consider how different regexps would match &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df805a589a3384de86f5cf73ad97a197cc80b2b6" translate="yes" xml:space="preserve">
          <source>Let's consider what happens when the filtered code includes another module with use:</source>
          <target state="translated">필터링 된 코드에 사용중인 다른 모듈이 포함 된 경우 어떻게되는지 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="ae779227ca7a97ab41c0486c107dd88686a00384" translate="yes" xml:space="preserve">
          <source>Let's create a TCP server on &lt;code&gt;localhost:3333&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bb45ed6a20ca29516eecb8c27b4f1a78faa8d9" translate="yes" xml:space="preserve">
          <source>Let's edit the .xs file by adding this to the end of the file:</source>
          <target state="translated">파일 끝에 이것을 추가하여 .xs 파일을 편집 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f7e0018c031b17ac0ce35fd9db664c3f00e8a38b" translate="yes" xml:space="preserve">
          <source>Let's examine the cogs of this byte mill, one by one. There's the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; call, creating the items we intend to stuff into the &lt;code&gt;$env&lt;/code&gt; buffer: to each key (in &lt;code&gt;$_&lt;/code&gt; ) it adds the &lt;code&gt;=&lt;/code&gt; separator and the hash entry value. Each triplet is packed with the template code sequence &lt;code&gt;A*A*Z*&lt;/code&gt; that is repeated according to the number of keys. (Yes, that's what the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function returns in scalar context.) To get the very last null byte, we add a &lt;code&gt;0&lt;/code&gt; at the end of the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; list, to be packed with &lt;code&gt;C&lt;/code&gt; . (Attentive readers may have noticed that we could have omitted the 0.)</source>
          <target state="translated">이 바이트 밀의 톱니를 하나씩 살펴 보겠습니다. &lt;code&gt;$env&lt;/code&gt; 버퍼에 넣을 항목을 만드는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 호출 이 있습니다 . &lt;code&gt;$_&lt;/code&gt; 있는 각 키 에 &lt;code&gt;=&lt;/code&gt; 구분 기호와 해시 항목 값을 추가합니다 . 각 삼중 항 에는 키 수에 따라 반복되는 템플릿 코드 시퀀스 &lt;code&gt;A*A*Z*&lt;/code&gt; 가 포함되어 있습니다. (예, 이것이 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 함수가 반환하는 것입니다.) 마지막 null 바이트를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 목록 끝에 &lt;code&gt;0&lt;/code&gt; 을 추가하여 &lt;code&gt;C&lt;/code&gt; 로 압축 합니다. (주의를 기울이는 독자는 우리가 0을 생략했을 수 있음을 알았을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="03dd34b9bc34d0893db5fe1238852061dbc9990c" translate="yes" xml:space="preserve">
          <source>Let's examine the cogs of this byte mill, one by one. There's the &lt;code&gt;map&lt;/code&gt; call, creating the items we intend to stuff into the &lt;code&gt;$env&lt;/code&gt; buffer: to each key (in &lt;code&gt;$_&lt;/code&gt;) it adds the &lt;code&gt;=&lt;/code&gt; separator and the hash entry value. Each triplet is packed with the template code sequence &lt;code&gt;A*A*Z*&lt;/code&gt; that is repeated according to the number of keys. (Yes, that's what the &lt;code&gt;keys&lt;/code&gt; function returns in scalar context.) To get the very last null byte, we add a &lt;code&gt;0&lt;/code&gt; at the end of the &lt;code&gt;pack&lt;/code&gt; list, to be packed with &lt;code&gt;C&lt;/code&gt;. (Attentive readers may have noticed that we could have omitted the 0.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e554ae494be1d13390f7359c0d05574c54b38a5" translate="yes" xml:space="preserve">
          <source>Let's examine the whole implementation, for practice:</source>
          <target state="translated">실습을 위해 전체 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cb0a55a99d6403d9b27402fcdfbf4d6ed2e005f9" translate="yes" xml:space="preserve">
          <source>Let's explore this feature a little more. We'll begin with the equivalent of</source>
          <target state="translated">이 기능을 조금 더 살펴 보겠습니다. 우리는</target>
        </trans-unit>
        <trans-unit id="ebfb13b002928ab00b844746320f412762e65aa3" translate="yes" xml:space="preserve">
          <source>Let's give it a try:</source>
          <target state="translated">시도해 보자.</target>
        </trans-unit>
        <trans-unit id="4e14ae2cc2c4249d7ae1307778537f0e17717e46" translate="yes" xml:space="preserve">
          <source>Let's have a look at how Perl sees &lt;code&gt;$a = $b + $c&lt;/code&gt; :</source>
          <target state="translated">Perl이 &lt;code&gt;$a = $b + $c&lt;/code&gt; 보는 방법을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="6bcf594dd87bbdba596aaad50a05456d93f5c880" translate="yes" xml:space="preserve">
          <source>Let's have a look at how Perl sees &lt;code&gt;$a = $b + $c&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e928f3f516e4f40543bf011e7476bdaffeba6904" translate="yes" xml:space="preserve">
          <source>Let's look at another TCP client. This one connects to the TCP &quot;time&quot; service on a number of different machines and shows how far their clocks differ from the system on which it's being run:</source>
          <target state="translated">다른 TCP 클라이언트를 봅시다. 이것은 여러 다른 머신의 TCP &quot;시간&quot;서비스에 연결되며 클럭이 실행되는 시스템과 얼마나 다른지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0bfde5091a0fdc4b1dcc0dd94b94093ffcfd6f13" translate="yes" xml:space="preserve">
          <source>Let's look at each in turn, using as an example a tie class for scalars that allows the user to do something like:</source>
          <target state="translated">사용자가 다음과 같은 작업을 수행 할 수있는 스칼라의 타이 클래스를 예로 사용하여 각각을 차례로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8c38883dc5f76f55aab6aa025aff159c68fa3911" translate="yes" xml:space="preserve">
          <source>Let's look at each of these possible constructs in detail. There are separate sections on each of the following:</source>
          <target state="translated">가능한 각 구성을 자세히 살펴 보겠습니다. 다음 각각에 별도의 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad30ae9725c85002b6831ea9730f9076d479a5c8" translate="yes" xml:space="preserve">
          <source>Let's look at each of these principles in depth.</source>
          <target state="translated">이러한 각 원칙을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="176db7a51355c5004c1f239aa8667a05811318e4" translate="yes" xml:space="preserve">
          <source>Let's look at the example above, but with minimal quantifiers:</source>
          <target state="translated">위의 예를 살펴 보지만 최소한의 수량 자만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="44d6bf690bfe89fee660e282315649dfc02c909f" translate="yes" xml:space="preserve">
          <source>Let's make a quick object and x-plode it, first we'll start the debugger: it wants some form of input from STDIN, so we give it something non-committal, a zero:</source>
          <target state="translated">빠른 객체를 만들고 x-plode 해봅시다. 먼저 디버거를 시작하겠습니다 : STDIN에서 어떤 형태의 입력을 원하므로 커밋되지 않은 0을 부여합니다 :</target>
        </trans-unit>
        <trans-unit id="8c36a08a96367b239dd26ec1d8f04af50262a733" translate="yes" xml:space="preserve">
          <source>Let's say you'd like your Perl program to process data stored in a nearby directory called &lt;code&gt;unsorted&lt;/code&gt;, which contains a number of textfiles. You'd also like your program to sort all the contents from these files into a single, alphabetically sorted list of unique lines before it starts processing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af4365a6067ebec1d91261e67cfd455affae6b4" translate="yes" xml:space="preserve">
          <source>Let's say your application is a server that will occasionally run Perl code from some arbitrary file. Your server has no way of knowing what code it's going to run. Very dangerous.</source>
          <target state="translated">응용 프로그램이 임의의 파일에서 때때로 Perl 코드를 실행하는 서버라고 가정 해 봅시다. 서버는 어떤 코드를 실행할지 알 수 없습니다. 매우 위험한.</target>
        </trans-unit>
        <trans-unit id="4d890463be6280c78f6b7f6a985632f09c2fa90e" translate="yes" xml:space="preserve">
          <source>Let's see a quick example of how all this is useful.</source>
          <target state="translated">이 모든 것이 어떻게 유용한 지에 대한 간단한 예를 보자.</target>
        </trans-unit>
        <trans-unit id="e32a2ed9f3b04c47c03460e3d9853725a7d0f999" translate="yes" xml:space="preserve">
          <source>Let's see what &lt;code&gt;Benchmark&lt;/code&gt; makes of this:</source>
          <target state="translated">&lt;code&gt;Benchmark&lt;/code&gt; 가 무엇을하는지 보자 :</target>
        </trans-unit>
        <trans-unit id="405776f1b44151a8af53d3cf919e2d8b537db4ed" translate="yes" xml:space="preserve">
          <source>Let's start in the middle, at line 4. This is a BINOP, a binary operator, which is at location &lt;code&gt;0x8179828&lt;/code&gt; . The specific operator in question is &lt;code&gt;sassign&lt;/code&gt; - scalar assignment - and you can find the code which implements it in the function &lt;code&gt;pp_sassign&lt;/code&gt; in</source>
          <target state="translated">4 행에서 중간에서 시작합시다. 이것은 0x8179828 위치에있는 이진 연산자 인 &lt;code&gt;0x8179828&lt;/code&gt; 입니다. 해당 특정 연산자는 &lt;code&gt;sassign&lt;/code&gt; - 스칼라 할당 &lt;code&gt;pp_sassign&lt;/code&gt; in 함수에서이를 구현하는 코드를 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c82eef57c73c123759da862922f036bf0665286b" translate="yes" xml:space="preserve">
          <source>Let's start in the middle, at line 4. This is a BINOP, a binary operator, which is at location &lt;code&gt;0x8179828&lt;/code&gt;. The specific operator in question is &lt;code&gt;sassign&lt;/code&gt; - scalar assignment - and you can find the code which implements it in the function &lt;code&gt;pp_sassign&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1d4b156d0cb946936473b6a08e0d57dc7fd23f" translate="yes" xml:space="preserve">
          <source>Let's start with the second line. It says that the uppercase of code point 97 is 65; or &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; == &quot;A&quot;. But the line is for the entire range of code points 97 through 122. To get the mapping for any code point in this range, you take the offset it has from the beginning code point of the range, and add that to the mapping for that first code point. So, the mapping for 122 (&quot;z&quot;) is derived by taking the offset of 122 from 97 (=25) and adding that to 65, yielding 90 (&quot;z&quot;). Likewise for everything in between.</source>
          <target state="translated">두 번째 줄부터 시작하겠습니다. 코드 포인트 97의 대문자는 65라고 말합니다. 또는 &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; == &quot;A&quot;. 그러나이 줄은 코드 범위 97에서 122까지의 전체 범위에 해당합니다.이 범위의 코드 포인트에 대한 매핑을 가져 오려면 범위의 시작 코드 포인트에서 오프셋을 가져 와서 해당 매핑에 매핑에 추가합니다. 첫 번째 코드 포인트. 따라서 122 ( &quot;z&quot;)에 대한 매핑은 97 (= 25)에서 122의 오프셋을 가져 와서 65에 추가하여 90 ( &quot;z&quot;)을 생성하여 파생됩니다. 그 사이의 모든 것에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="283878194b8e2d4159d246c8407adfc9545545e1" translate="yes" xml:space="preserve">
          <source>Let's start with the second line. It says that the uppercase of code point 97 is 65; or &lt;code&gt;uc(&quot;a&quot;)&lt;/code&gt; == &quot;A&quot;. But the line is for the entire range of code points 97 through 122. To get the mapping for any code point in this range, you take the offset it has from the beginning code point of the range, and add that to the mapping for that first code point. So, the mapping for 122 (&quot;z&quot;) is derived by taking the offset of 122 from 97 (=25) and adding that to 65, yielding 90 (&quot;z&quot;). Likewise for everything in between.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0880854fa8770ea11a4efe4579463972aa5ae537" translate="yes" xml:space="preserve">
          <source>Let's suppose you have some weird Martian encoding where pairs of ASCII uppercase letters encode single Martian letters (i.e. the two bytes &quot;CV&quot; make a single Martian letter, as do the two bytes &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;, etc.). Other bytes represent single characters, just like ASCII.</source>
          <target state="translated">ASCII 대문자 쌍이 단일 Martian 문자를 인코딩하는 이상한 Martian 인코딩이 있다고 가정합니다 (예 : 2 바이트 &quot;CV&quot;는 2 바이트 &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;등의 단일 Martian 문자를 만듭니다) ). 다른 바이트는 ASCII처럼 단일 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f09fe13c85ec276cd87ab04a04d40aac9612c6e" translate="yes" xml:space="preserve">
          <source>Let's suppose you've got to read in a data file like this:</source>
          <target state="translated">다음과 같은 데이터 파일을 읽어야한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2f7c544be1b70356d2951611060b9932dadf6ea2" translate="yes" xml:space="preserve">
          <source>Let's take a look at a portion of the .c file created for our extension. The file name is Mytest.c:</source>
          <target state="translated">확장을 위해 생성 된 .c 파일의 일부를 살펴 보겠습니다. 파일 이름은 Mytest.c입니다.</target>
        </trans-unit>
        <trans-unit id="ce5f83676281dd1446f1a5a503aee374bc369bcc" translate="yes" xml:space="preserve">
          <source>Let's take a look at the same program using a different profiler: &lt;code&gt;Devel::Profiler&lt;/code&gt; , a drop-in Perl-only replacement for &lt;code&gt;Devel::DProf&lt;/code&gt; . The usage is very slightly different in that instead of using the special &lt;code&gt;-d:&lt;/code&gt; flag, you pull &lt;code&gt;Devel::Profiler&lt;/code&gt; in directly as a module using &lt;code&gt;-M&lt;/code&gt; .</source>
          <target state="translated">다른 프로파일 러 &lt;code&gt;Devel::Profiler&lt;/code&gt; 사용하여 동일한 프로그램을 살펴 보자 : &lt;code&gt;Devel::DProf&lt;/code&gt; 펄 전용 드롭 인 . 특수한 &lt;code&gt;-d:&lt;/code&gt; 플래그 를 사용하는 대신 &lt;code&gt;-M&lt;/code&gt; 을 사용하여 &lt;code&gt;Devel::Profiler&lt;/code&gt; 를 모듈로 직접 가져 오는 사용법이 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="51d206f459af5ffe821cbc3901dfba71c7b8ef1d" translate="yes" xml:space="preserve">
          <source>Let's take a look at the same program using a different profiler: &lt;code&gt;Devel::Profiler&lt;/code&gt;, a drop-in Perl-only replacement for &lt;code&gt;Devel::DProf&lt;/code&gt;. The usage is very slightly different in that instead of using the special &lt;code&gt;-d:&lt;/code&gt; flag, you pull &lt;code&gt;Devel::Profiler&lt;/code&gt; in directly as a module using &lt;code&gt;-M&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230698ed5211b94950bbc39ebf4a2cd8603f3243" translate="yes" xml:space="preserve">
          <source>Let's take a simple patch from start to finish.</source>
          <target state="translated">처음부터 끝까지 간단한 패치를 보자.</target>
        </trans-unit>
        <trans-unit id="2b003d41c47da4c513944208b256541b446c8a71" translate="yes" xml:space="preserve">
          <source>Let's take an example of manipulating a PV, from &lt;code&gt;sv_catpvn&lt;/code&gt; , in</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 에서 PV를 조작하는 예제를 보자 .</target>
        </trans-unit>
        <trans-unit id="f81a1d5166b525293109d732fb53d9a2e8fb4f86" translate="yes" xml:space="preserve">
          <source>Let's take an example of manipulating a PV, from &lt;code&gt;sv_catpvn&lt;/code&gt;, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3c67f07cd4da0245ca6a99400a337a71fe4ec4" translate="yes" xml:space="preserve">
          <source>Let's take an example. Suppose you're reading in data from a local format into a hash-of-hashes in Perl, turning that into a tree, walking the tree and then piping each node to an Acme Transmogrifier Server.</source>
          <target state="translated">예를 들어 봅시다. 로컬 형식에서 Perl의 해시 해시로 데이터를 읽고이를 트리로 바꾸고 나무를 걷은 다음 각 노드를 Acme Transmogrifier Server에 파이프한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="08e16151674f7f96adbcc23b02310179ef6623cd" translate="yes" xml:space="preserve">
          <source>Let's take the following test directory structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39fd63d744cf93b2616319a85e2d2154efb3e45" translate="yes" xml:space="preserve">
          <source>Let's you write:</source>
          <target state="translated">작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="2f17a5ca119319a7ec877e7a949710676dc887eb" translate="yes" xml:space="preserve">
          <source>Level 1 - Basic Unicode Support</source>
          <target state="translated">레벨 1-기본 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="0de802e5c110593513199ad6be14e0d3e4934cee" translate="yes" xml:space="preserve">
          <source>Level 2 - Extended Unicode Support</source>
          <target state="translated">레벨 2-확장 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="bddac528f4922054293682b3a34528809353679b" translate="yes" xml:space="preserve">
          <source>Level 3 - Tailored Support</source>
          <target state="translated">레벨 3-맞춤형 지원</target>
        </trans-unit>
        <trans-unit id="af642ef849c39f332561002d12526780f4e80e2e" translate="yes" xml:space="preserve">
          <source>Level of verbosity. By default, the debugger leaves your exceptions and warnings alone, because altering them can break correctly running programs. It will attempt to print a message when uncaught INT, BUS, or SEGV signals arrive. (But see the mention of signals in &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b7cf7750bfaac558f7db0f6b00074662dc6814" translate="yes" xml:space="preserve">
          <source>Level of verbosity. By default, the debugger leaves your exceptions and warnings alone, because altering them can break correctly running programs. It will attempt to print a message when uncaught INT, BUS, or SEGV signals arrive. (But see the mention of signals in &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below.)</source>
          <target state="translated">자세한 수준. 기본적으로 디버거는 예외 및 경고를 변경하면 올바르게 실행중인 프로그램이 중단 될 수 있으므로 예외 및 경고 만 남겨 둡니다. 포착되지 않은 INT, BUS 또는 SEGV 신호가 도착하면 메시지 인쇄를 시도합니다. (하지만 아래 &lt;a href=&quot;#BUGS&quot;&gt;버그에&lt;/a&gt; 대한 신호 언급을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="dd4d01b82f363523e943497a1acd58ad122c1d74" translate="yes" xml:space="preserve">
          <source>Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written introduction to threads).</source>
          <target state="translated">Lewis, Bill 및 Daniel J. Berg. Pthread를 이용한 멀티 스레드 프로그래밍. 1997 년 Prentice Hall, ISBN 0-13-443698-9 (잘 작성된 쓰레드 소개).</target>
        </trans-unit>
        <trans-unit id="0130807d4961ca028150a643b43fa9d3af268eec" translate="yes" xml:space="preserve">
          <source>Lexer interface</source>
          <target state="translated">Lexer 인터페이스</target>
        </trans-unit>
        <trans-unit id="7c46e8b2c6a1b67615cc4a28b1803b6611e259c0" translate="yes" xml:space="preserve">
          <source>Lexical (my) variables declared in scopes external to a subroutine appear in code2ref output text as package variables. This is a tricky problem, as perl has no native facility for referring to a lexical variable defined within a different scope, although &lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt; is a good start.</source>
          <target state="translated">서브 루틴 외부의 범위에서 선언 된 어휘 (my) 변수는 code2ref 출력 텍스트에 패키지 변수로 나타납니다. 펄에는 다른 범위 내에서 정의 된 어휘 변수를 참조 할 기본 기능이 없기 때문에 까다로운 문제이지만 &lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt; 가 좋은 출발입니다.</target>
        </trans-unit>
        <trans-unit id="2a2592394276034b7da48f012e3e1835635e7937" translate="yes" xml:space="preserve">
          <source>Lexical (my) variables declared in scopes external to a subroutine appear in coderef2text output text as package variables. This is a tricky problem, as perl has no native facility for referring to a lexical variable defined within a different scope, although &lt;a href=&quot;padwalker&quot;&gt;PadWalker&lt;/a&gt; is a good start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21795cace48f4382f41c503a0895c632d1557532" translate="yes" xml:space="preserve">
          <source>Lexical Subroutines</source>
          <target state="translated">어휘 서브 루틴</target>
        </trans-unit>
        <trans-unit id="91090443b78c24e5208fa0b7749049adce1d8581" translate="yes" xml:space="preserve">
          <source>Lexical effect</source>
          <target state="translated">어휘 효과</target>
        </trans-unit>
        <trans-unit id="10e46358434f33f5da4b481844bfbc427a1eaf46" translate="yes" xml:space="preserve">
          <source>Lexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too. Thus in the loop</source>
          <target state="translated">제어 구조의 어휘 범위는 제어 블록을 구분하는 괄호로 정확하게 구속되지 않습니다. 제어 표현식도 해당 범위의 일부입니다. 따라서 루프에서</target>
        </trans-unit>
        <trans-unit id="c32019b3ed41f9870148e7d8a8bcc91664cf5db8" translate="yes" xml:space="preserve">
          <source>Lexical subroutines are only available under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'lexical_subs'&lt;/code&gt; pragma, which produces a warning unless the &quot;experimental::lexical_subs&quot; warnings category is disabled.</source>
          <target state="translated">어휘 서브 루틴은 &quot;experimental :: lexical_subs&quot;경고 범주를 사용하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'lexical_subs'&lt;/code&gt; 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63259d01172ac59370a7ece5661c26923725e28e" translate="yes" xml:space="preserve">
          <source>Lexical variable introduced (declared with my()) for the first time.</source>
          <target state="translated">처음으로 소개 된 어휘 변수 (my ()로 선언)</target>
        </trans-unit>
        <trans-unit id="6bec4b7b4f94bd2a84719ee4041560ade2de4cd8" translate="yes" xml:space="preserve">
          <source>Lexical variables (declared with &quot;my&quot;) are not visible within a format unless the format is declared within the scope of the lexical variable.</source>
          <target state="translated">형식이 어휘 변수의 범위 내에서 선언되지 않으면 어휘 변수 ( &quot;my&quot;로 선언 됨)는 형식 내에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56e8fa65a6460263a21b0d0b067830070ec69c2a" translate="yes" xml:space="preserve">
          <source>Lexical warnings get around these limitations by allowing finer control over where warnings can or can't be tripped.</source>
          <target state="translated">어휘 경고는 경고가 넘어 질 수있는 곳과 그렇지 못한 곳을보다 세밀하게 제어 할 수있게함으로써 이러한 한계를 극복합니다.</target>
        </trans-unit>
        <trans-unit id="dfa37e8913139b1f0a81171648bb039460ba6c8c" translate="yes" xml:space="preserve">
          <source>Lexically control overloading</source>
          <target state="translated">사전에 과부하 제어</target>
        </trans-unit>
        <trans-unit id="d71329c73390ebdefc7d3045a64e73de047c01c2" translate="yes" xml:space="preserve">
          <source>Lexing code (whether in the Perl core or not) moves this pointer past the characters that it consumes. It is also expected to perform some bookkeeping whenever a newline character is consumed. This movement can be more conveniently performed by the function &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt;, which handles newlines appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23a9b3c648b4ba0282c9679b9e53d7ed27aaf5d" translate="yes" xml:space="preserve">
          <source>Lexing code (whether in the Perl core or not) moves this pointer past the characters that it consumes. It is also expected to perform some bookkeeping whenever a newline character is consumed. This movement can be more conveniently performed by the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;, which handles newlines appropriately.</source>
          <target state="translated">렉싱 코드 (Perl 코어의 유무에 관계없이)는이 포인터를 소비하는 문자를 지나서 이동시킵니다. 또한 개행 문자가 사용될 때마다 약간의 부기를 수행해야합니다. 이 이동은 개행을 적절히 처리하는 &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; 함수로보다 편리하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50c4503eb10cb7055e83f0b77d0c54ba198cb8a3" translate="yes" xml:space="preserve">
          <source>Lexing code attempted to stuff non-Latin-1 character into Latin-1 input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec3fbd307e04ea0a0267363d68414b3f6becd30" translate="yes" xml:space="preserve">
          <source>Lexing code internal error (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdf2fc886297cee27c73397601ff4f39103c78d" translate="yes" xml:space="preserve">
          <source>Libnet Frequently Asked Questions</source>
          <target state="translated">Libnet 자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="e99e9a5a6c267649059fa8147d50e8a56d55d8c3" translate="yes" xml:space="preserve">
          <source>Libraries using &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; for custom warning categories generally don't expect &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; to be fatal and can wind up in an unexpected state as a result. For XS modules issuing categorized warnings, such unanticipated exceptions could also expose memory leak bugs.</source>
          <target state="translated">사용자 정의 경고 범주에 &lt;a href=&quot;#FUNCTIONS&quot;&gt;대해 warnings :: warn&lt;/a&gt; 을 사용하는 라이브러리는 일반적으로 &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings :: warn&lt;/a&gt; 이 치명적일 것으로 예상하지 않으며 결과적으로 예기치 않은 상태가 될 수 있습니다. 분류 된 경고를 발행하는 XS 모듈의 경우 예상치 못한 예외로 인해 메모리 누수 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfd43d16e8972c230e7e22188720b2bf73e76c5" translate="yes" xml:space="preserve">
          <source>Library ... not found</source>
          <target state="translated">라이브러리 ... 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="51ac812d4d63215ce6bab6ff80843a9768d50aa3" translate="yes" xml:space="preserve">
          <source>Library modules should not in general export built-in names like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; as part of their default &lt;code&gt;@EXPORT&lt;/code&gt; list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to &lt;code&gt;@EXPORT_OK&lt;/code&gt; , then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say</source>
          <target state="translated">라이브러리 모듈은 일반적으로 기본 &lt;code&gt;@EXPORT&lt;/code&gt; 목록의 일부로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 과 같은 내장 이름을 내 보내면 안됩니다. 다른 사람의 네임 스페이스로 몰래 들어가 의미가 예기치 않게 변경 될 수 있기 때문입니다. 대신 모듈이 해당 이름을 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 에 추가 하면 사용자가 이름을 명시 적으로 가져올 수 있지만 내재적으로 가져올 수는 없습니다. 즉, 그들은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ad8c903818c8a82f08facfa60cb87854b48f3251" translate="yes" xml:space="preserve">
          <source>Library modules should not in general export built-in names like &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;chdir&lt;/code&gt; as part of their default &lt;code&gt;@EXPORT&lt;/code&gt; list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to &lt;code&gt;@EXPORT_OK&lt;/code&gt;, then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189f5ddd187269a52ad75ba078f7fedb0f60d5fe" translate="yes" xml:space="preserve">
          <source>License String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8774f0e51de54365d13b10f234f9f0ab4b4c7b6" translate="yes" xml:space="preserve">
          <source>License is also granted to make and use derivative works provided that such works are identified as &quot;derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing the derived work.</source>
          <target state="translated">파생 된 저작물을 언급하거나 언급하는 모든 자료에서 그러한 저작물이 &quot;RSA Data Security, Inc. MD5 Message-Digest Algorithm에서 파생 된&quot;것으로 식별되는 경우 파생 저작물을 만들고 사용할 수있는 라이센스도 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb9dc902cb98efd9bae2b4a142dce7fcd9e3bb0" translate="yes" xml:space="preserve">
          <source>License to copy and use this software is granted provided that it is identified as the &quot;RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing this software or this function.</source>
          <target state="translated">이 소프트웨어 또는이 기능을 언급하거나 언급하는 모든 자료에서 &quot;RSA Data Security, Inc. MD5 메시지 다이제스트 알고리즘&quot;으로 식별되는 경우이 소프트웨어를 복사하고 사용할 수있는 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="5924fd52bf49a8494e3d053dc865b25bbec5c6e6" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU General Public License version 1 or later, or the Artistic License.</source>
          <target state="translated">GNU General Public License 버전 1 이상 또는 Artistic License에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="aa636d64869928622347b0ebd93665113e78146c" translate="yes" xml:space="preserve">
          <source>Licensing</source>
          <target state="translated">Licensing</target>
        </trans-unit>
        <trans-unit id="d5b616805cf9bfc9158dfb054c59875ea327a760" translate="yes" xml:space="preserve">
          <source>Life is not quite so transparent, however, when working with legacy encodings, I/O, and certain special cases:</source>
          <target state="translated">그러나 레거시 인코딩, I / O 및 특정 특수한 경우로 작업 할 때 인생은 그리 투명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab3a00d7b8ef92b4d6db8938fdc867c976af1617" translate="yes" xml:space="preserve">
          <source>Lifetime of the parent process and pseudo-processes</source>
          <target state="translated">부모 프로세스 및 의사 프로세스의 수명</target>
        </trans-unit>
        <trans-unit id="cb79da38fbc832bc4294ccc8e4bcfcc8a2555134" translate="yes" xml:space="preserve">
          <source>Lightweight and lvalue version of &lt;code&gt;PAD_SV&lt;/code&gt; . Get or set the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad. Unlike &lt;code&gt;PAD_SV&lt;/code&gt; , does not print diagnostics with -DX. For internal use only.</source>
          <target state="translated">&lt;code&gt;PAD_SV&lt;/code&gt; 의 경량 및 lvalue 버전 . 현재 패드 에서 오프셋 &lt;code&gt;po&lt;/code&gt; 의 값을 가져 오거나 설정합니다 . &lt;code&gt;PAD_SV&lt;/code&gt; 와 달리 -DX로 진단을 인쇄하지 않습니다. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="3fd57349d3d10bcc5e3acd29d060e929880bc515" translate="yes" xml:space="preserve">
          <source>Lightweight and lvalue version of &lt;code&gt;PAD_SV&lt;/code&gt;. Get or set the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad. Unlike &lt;code&gt;PAD_SV&lt;/code&gt;, does not print diagnostics with -DX. For internal use only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="c9df7c5b0e2428587b12f5f968c72b403b65e631" translate="yes" xml:space="preserve">
          <source>Like &quot;@*&quot;, this is a variable-width field. The value supplied must be a scalar variable. Perl puts the first line (up to the first &quot;\n&quot;) of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. The variable will</source>
          <target state="translated">&quot;@ *&quot;와 마찬가지로이 필드는 가변 너비 필드입니다. 제공된 값은 스칼라 변수 여야합니다. Perl은 텍스트의 첫 번째 줄 (첫 번째 &quot;\ n&quot;까지)을 필드에 넣은 후 다음에 변수를 참조 할 때 더 많은 텍스트를 인쇄 할 수 있도록 문자열 앞을 잘라냅니다. 변수는</target>
        </trans-unit>
        <trans-unit id="9e4b27dce39ce4f15c0298254855f383991ad517" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt;, but taint checks will issue warnings rather than fatal errors. These warnings can now be controlled normally with &lt;code&gt;no warnings qw(taint)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6efdf3c36a1c3613481963e9128916b7b900006" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#__FILE__&quot;&gt;&lt;code&gt;__FILE__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__LINE__&quot;&gt;&lt;code&gt;__LINE__&lt;/code&gt;&lt;/a&gt;, the filename and line number returned here may be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f94085fda091b1e0d2fbb00f475b7933a977348" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt;, the result may be an intermediate decomposition whose components are also decomposable. Use &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c138d511965d3d204a9ae2bc98753a226047b504" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, the result may be an intermediate decomposition whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; , 그 결과는 그 요소도 분해되어 중간 분해 될 수있다. 한 번에 최종 분해를 얻으려면 &lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="266742b9f67b4fe1a275417eb72b7a676513b96c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;&quot;cop_hints_fetch_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94306a359339162936c27f41ca5369637110def5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;&quot;cop_hints_fetch_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d50417de331ddcfae6353b7aa1bfeeddd25071" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;&quot;cop_hints_fetch_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de5fd7897751225569f609d59202b32bba6024a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e492b6f65de514837e38acf884d2920be6c9c8e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2de1e66c1756b6fab3c6fdb05cde4f4f25568233" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4a253dd8613cfeb35cd85cfbea8043b7c360540b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;&quot;cophh_delete_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af63bad15b32edbd28ac2c10d2108aae562c31" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;&quot;cophh_delete_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5b198e7e3473ff35bff47623cd4e88330d3954" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;&quot;cophh_delete_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de93912de0e72db38bde2b8e898d77fc9dc7395b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f93afb3b500f705910109bc574d7e2b47ae58fd" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bc8a6b9daffa5d612ad332627c80e1cbcfc7c28" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9cc1810855d64e33ce9ec26c456a64df0b593a05" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;&quot;cophh_fetch_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5cc8f19c22d392b66740ab20d62583c9f0b5cc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;&quot;cophh_fetch_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3304e82e703cb693b770c7a91db4e251a771c7ab" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;&quot;cophh_fetch_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf7282f7430d0c1f55fb04bc9095993eb65be76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b5ef552d2079e488edcf076c50da8cfc2edf287e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d820027a36b428c792671f4c8e4ee5300a7823f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d743c06e3451a81c72518baf7f72a34f8bfafe8d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;&quot;cophh_store_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3d816bbaf79a909295b456cf4eb6930c147304" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;&quot;cophh_store_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0b3ccbd7b43691247d71e63bb360cc3249f86a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;&quot;cophh_store_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c1cef4e16a8379b39bb25b20396ecc27808f0b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8b72f1ae998c27a3bc7952f2e79a7833ed58822" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d6eb33ec672f221ab14ac8aaae5ee9923295a95" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58ca9ffe0ac8e2dd6af7ebd2c0acbcec2c0d7145" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; allows you to lie to a program about its name if you use the &lt;code&gt;system PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada44e107259fa024a8f358c79e51c738af229c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but lacks a flags parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54abf6089eca44394b7d1690bb3d38c0b82d3b35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but lacks a flags parameter.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 유사 하지만 플래그 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d0651cf67afe661baee2be32bf57a134f79be82" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; .</source>
          <target state="translated">추천 &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; 또는 ( &quot;utf8ness 실패&quot;의 경우) 장애의 위치를 저장하지만 위치 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; 에서 ( &quot;utf8ness 성공&quot;의 경우) &lt;code&gt;ep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4826c3546aa34ea2d0524b77459a729065bbf15b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt;() but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; , and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; .</source>
          <target state="translated">추천 &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; ()하지만 저장 ( &quot;utf8ness 실패&quot;의 경우) 실패의 위치 또는 위치 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; 에서 ( &quot;utf8ness 성공&quot;의 경우) &lt;code&gt;ep&lt;/code&gt; 및 UTF-8 인코딩 된 문자의 개수 에서 &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4004ca168e21bab8a364acb13202ffa9c080d1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df9351141888ffdcb4847144fedfdb9527ae3f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="84cb2c197de2f7ed274dcc28b904a10591e12927" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#memEQ&quot;&gt;&quot;memEQ&quot;&lt;/a&gt;, but the second string is a literal enclosed in double quotes, &lt;code&gt;l1&lt;/code&gt; gives the number of bytes in &lt;code&gt;s1&lt;/code&gt;. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3235e7d6c4a5e5829587587808c18e328cb540d6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#memNE&quot;&gt;&quot;memNE&quot;&lt;/a&gt;, but the second string is a literal enclosed in double quotes, &lt;code&gt;l1&lt;/code&gt; gives the number of bytes in &lt;code&gt;s1&lt;/code&gt;. Returns zero if non-equal, or zero if non-equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8418e841d048f747af15fb53b44957357d83e046" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nextafter&quot;&gt;&quot;nextafter&quot;&lt;/a&gt;, but potentially more accurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855a9fc9268cf7c56dbfa870587e398be59edc5f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt;, but potentially more accurate.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt; 하지만 잠재적으로 더 정확한.</target>
        </trans-unit>
        <trans-unit id="0b2228c60a5736c212cccec834eca9e330073dae" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nexttoward&quot;&gt;&quot;nexttoward&quot;&lt;/a&gt;, but potentially less accurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3abb505c749731ad1d3986f391df84d9a744972" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt;, but potentially less accurate.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt; 하지만, 잠재적으로 덜 정확.</target>
        </trans-unit>
        <trans-unit id="014996f423e4b3ba0964db2cda0c7b80baa25ee8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;&quot;refcounted_he_fetch_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d8988dd3bbcc7667d93d474b90133547c697bf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;&quot;refcounted_he_fetch_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b66ec47b251b957cd7b2fb7f4d9c455c7a47ef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;&quot;refcounted_he_fetch_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b06f3c6974466e0dcb566dbe47f6fad84aa5a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 펄 스칼라 걸립니다.</target>
        </trans-unit>
        <trans-unit id="23a489d2aec93a2d851cb278177881615d6f059f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="401a90792585ceca6e1448d38f3a439e9e9ccb83" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d7b205ac37d25afe008f83aeca2addd7bbdc67d3" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;&quot;refcounted_he_new_pvn&quot;&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf2aa2fcc789bbf185be046592fbdbb502d45ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;&quot;refcounted_he_new_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349abc807ca4a5e1b628b9c96aba7c6b34dcba3" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;&quot;refcounted_he_new_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046451b0d57dcef450722c52bfda2597acd52bb7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt; refcounted_he_new_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 펄 스칼라 걸립니다.</target>
        </trans-unit>
        <trans-unit id="6a998ebee49893ba076a8800f452b0183aae9a49" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="65d696e7d641f983cc3e14984e6670f40737f36e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt; refcounted_he_new_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 NUL 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ee6b83a5c63efaa127609c27748de883a7f6ea1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#remainder&quot;&gt;&quot;remainder&quot;&lt;/a&gt; but also returns the low-order bits of the quotient (n) [C99]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a963885aaf0f61482fbaede4f9fc78877a13624a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#remainder&quot;&gt;remainder&lt;/a&gt; but also returns the low-order bits of the quotient (n) [C99]</source>
          <target state="translated">&lt;a href=&quot;#remainder&quot;&gt;나머지&lt;/a&gt; 처럼 하지만 몫 (n)의 하위 비트도 반환합니다 [C99]</target>
        </trans-unit>
        <trans-unit id="684022cdfa09a338010e59568f2b520d497d9055" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#round&quot;&gt;&quot;round&quot;&lt;/a&gt;, but as integer, as opposed to floating point [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5282dab906515d5042c87772d3d7af38dc7d497" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;, but as integer, as opposed to floating point [C99].</source>
          <target state="translated">&lt;a href=&quot;#round&quot;&gt;라운드&lt;/a&gt; 처럼 ,하지만 정수로 부동 소수점 [C99]에 반대했다.</target>
        </trans-unit>
        <trans-unit id="5ca6b661daea1fb2637dc5c26cdc951e025782cb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#setpayload&quot;&gt;&quot;setpayload&quot;&lt;/a&gt; but also makes the NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13069e76221341c8aade28e20a2776be321b753c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#strtod&quot;&gt;&quot;strtod&quot;&lt;/a&gt; but for long doubles. Defined only if the system supports long doubles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05cbd07aa430b94f88ef1127d9cc3feb4a35b92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt; but for long doubles. Defined only if the system supports long doubles.</source>
          <target state="translated">&lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt; 처럼 하지만 긴 복식. 시스템이 긴 복식을 지원하는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d85e8e0de6544839fe7d3c4073f5a3d09bc76d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_pv&quot;&gt;&quot;sv_does_pv&quot;&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f5fd00ec8eac8e99d9f1474911e3920a009bb9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt; 와 비슷 하지만 &lt;code&gt;flags&lt;/code&gt; 하지 않습니다 매개 변수를 사용 .</target>
        </trans-unit>
        <trans-unit id="5ff8c36e121f1fd60e63b43a1210b091d9a7c4d4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;&quot;sv_does_sv&quot;&lt;/a&gt;, but takes a nul-terminated string instead of an SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4661a4afd9ad32e2ec4db3ef6fa0574da2c1a43" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;&quot;sv_does_sv&quot;&lt;/a&gt;, but takes a string/length pair instead of an SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad65fa317ddd80710d2963974312eb533dd0432b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a nul-terminated string instead of an SV.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt; 처럼 하지만 SV 대신 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aa34ede2432b39dab6d8a29f4520f696d8b17636" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a string/length pair instead of an SV.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt; 처럼 하지만 SV 대신 문자열 / 길이 쌍을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8055d83feddf7b95aa6c67e74cf6d04e1a0e5710" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt;. Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt;. This is the numeric version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b51c5f83e0f401b76b918dc53d982582a6c6707" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt;. Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt;. This is the string version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0b144d9f1c5c01a2bcc227e28eeb2d1477818c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;like()&lt;/code&gt;. Checks if $thing matches the given &lt;code&gt;$regex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499b3623d431ec18655cbbc9fbf8897411d047d8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;unlike()&lt;/code&gt;. Checks if $thing &lt;b&gt;does not match&lt;/b&gt; the given &lt;code&gt;$regex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0270db3e4b83c7917acde896050328f249d7140a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;isnt()&lt;/code&gt; 처럼 . 경우 확인 &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . 이것은 숫자 버전입니다.</target>
        </trans-unit>
        <trans-unit id="a5f74c54ee73f3446f105290901ca9cf61ea643a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the string version.</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;isnt()&lt;/code&gt; 처럼 . &lt;code&gt;$got ne $dont_expect&lt;/code&gt; 인지 확인합니다 . 이것은 문자열 버전입니다.</target>
        </trans-unit>
        <trans-unit id="9693737cd3c58d515bd81ab55ef59b90671ceaba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;like()&lt;/code&gt; . Checks if $thing matches the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;more&quot;&gt;테스트 :: 자세히&lt;/a&gt; 의 &lt;code&gt;like()&lt;/code&gt; . $ thing이 주어진 &lt;code&gt;$regex&lt;/code&gt; 와 일치하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="348be5230ca4cb8628d5a3ede0642c968809d567" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;unlike()&lt;/code&gt; . Checks if $thing &lt;b&gt;does not match&lt;/b&gt; the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;more&quot;&gt;테스트 :: 자세히&lt;/a&gt; 의 &lt;code&gt;unlike()&lt;/code&gt; . $ thing &lt;b&gt;이&lt;/b&gt; 주어진 &lt;code&gt;$regex&lt;/code&gt; &lt;b&gt;와 일치하지 않는지&lt;/b&gt; 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="75959408f273f7b39d4c26886da9ddb8ba9ee269" translate="yes" xml:space="preserve">
          <source>Like &lt;b&gt;-T&lt;/b&gt;, but taint checks will issue warnings rather than fatal errors. These warnings can now be controlled normally with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
qw(taint)&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;b&gt;-T&lt;/b&gt; ,하지만 더러운 검사 경고보다는 치명적인 오류를 발행합니다. 이러한 경고는 이제 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(taint)&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 정상적으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19d3972f6bfa689ac944e15f05e77cbb13096271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; , the &lt;code&gt;extract_bracketed&lt;/code&gt; function takes up to three optional scalar arguments: a string to extract from, a delimiter specifier, and a prefix pattern. As before, a missing prefix defaults to optional whitespace and a missing text defaults to &lt;code&gt;$_&lt;/code&gt; . However, a missing delimiter specifier defaults to &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; (see below).</source>
          <target state="translated">마찬가지로 &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; 는 &lt;code&gt;extract_bracketed&lt;/code&gt; 문자열 구분 기호 지정자에서 추출하고, 접두사 패턴 : 함수는 세 개의 선택적 스칼라 인수를 차지한다. 이전과 같이 누락 된 접두어의 기본값은 선택적인 공백이며 누락 된 텍스트의 기본값은 &lt;code&gt;$_&lt;/code&gt; 입니다. 그러나 구분 기호 지정자가 없으면 기본값은 &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; 입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8d7efc2799c6c0aeefd629283955bc733e276d0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt;, the &lt;code&gt;extract_bracketed&lt;/code&gt; function takes up to three optional scalar arguments: a string to extract from, a delimiter specifier, and a prefix pattern. As before, a missing prefix defaults to optional whitespace and a missing text defaults to &lt;code&gt;$_&lt;/code&gt;. However, a missing delimiter specifier defaults to &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8638e9c741c1e67ac1a4fb8957038d6a39847eb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the</source>
          <target state="translated">추천 &lt;code&gt;:i&lt;/code&gt; , 값이 생략되면,</target>
        </trans-unit>
        <trans-unit id="6c3eb9fc5ff253146a577da27d5894ba1dc92861" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the current value for the option will be incremented.</source>
          <target state="translated">&lt;code&gt;:i&lt;/code&gt; 와 유사 하지만 값을 생략하면 옵션의 현재 값이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="e917fcd099f7bf9447127b4c6b34e7b279996d9c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt;, but if the value is omitted, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9edf6df4e0a9dec710ce6226ae54af4b423720" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt;, but if the value is omitted, the current value for the option will be incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72498a7bf2cc1e79678e63ab406b0c7a1e1f22d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN&quot;&gt;&quot;ckWARN&quot;&lt;/a&gt;&lt;/code&gt;, but for use if and only if the warning category is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e4e8837fe47e35448f28c70d5f0b43b109c2e8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN&quot;&gt;&quot;ckWARN&quot;&lt;/a&gt;&lt;/code&gt;, but takes two warnings categories as input, and returns TRUE if either is enabled. If either category is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;, instead use the &lt;a href=&quot;#ckWARN2_d&quot;&gt;&quot;ckWARN2_d&quot;&lt;/a&gt; macro. The categories must be completely independent, one may not be subclassed from the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419e26b6ee286b6d83d0487c5a57940285a7f404" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN2&quot;&gt;&quot;ckWARN2&quot;&lt;/a&gt;&lt;/code&gt;, but for use if and only if either warning category is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0b75aa92dfd27a10af7448f298956a33a06201" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN2&quot;&gt;&quot;ckWARN2&quot;&lt;/a&gt;&lt;/code&gt;, but takes three warnings categories as input, and returns TRUE if any is enabled. If any of the categories is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;, instead use the &lt;a href=&quot;#ckWARN3_d&quot;&gt;&quot;ckWARN3_d&quot;&lt;/a&gt; macro. The categories must be completely independent, one may not be subclassed from any other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2f4ea75511cd5867b17de10a3c9cc97f03000e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN3&quot;&gt;&quot;ckWARN3&quot;&lt;/a&gt;&lt;/code&gt;, but for use if and only if any of the warning categories is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea073c6d4d2f3be717fe763a8236d2fa3983dd14" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN3&quot;&gt;&quot;ckWARN3&quot;&lt;/a&gt;&lt;/code&gt;, but takes four warnings categories as input, and returns TRUE if any is enabled. If any of the categories is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;, instead use the &lt;a href=&quot;#ckWARN4_d&quot;&gt;&quot;ckWARN4_d&quot;&lt;/a&gt; macro. The categories must be completely independent, one may not be subclassed from any other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7a6a2e8726ab7252364cc04fd4ea666ebc8c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ckWARN4&quot;&gt;&quot;ckWARN4&quot;&lt;/a&gt;&lt;/code&gt;, but for use if and only if any of the warning categories is by default enabled even if not within the scope of &lt;code&gt;use warnings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6b184b57730c77a791a10594697539485e24b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer, and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d139eda757264428ce8d6faad0998e0c3769736" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5271b223e0f3ecc184afda4eb4579d5e8c1de58c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer, and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cbb5f193b52a523e82c581210653da96c02968" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3fe020358fe6e2a30b7f3e56ff293f970a16478" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_fixed_width_buf_flags&quot;&gt;&quot;is_utf8_fixed_width_buf_flags&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure in the &lt;code&gt;ep&lt;/code&gt; pointer. If the function returns TRUE, &lt;code&gt;*ep&lt;/code&gt; will point to the beginning of any partial character at the end of the buffer; if there is no partial character &lt;code&gt;*ep&lt;/code&gt; will contain &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184619f40e2d3b96236b99f26b9009ae016b50d2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_fixed_width_buf_loc_flags&quot;&gt;&quot;is_utf8_fixed_width_buf_loc_flags&quot;&lt;/a&gt;&lt;/code&gt; but stores the number of complete, valid characters found in the &lt;code&gt;el&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7227ef07854b8cfd22e221bfeaf5dae02357c44a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_invariant_string&quot;&gt;&quot;is_utf8_invariant_string&quot;&lt;/a&gt;&lt;/code&gt; but upon failure, stores the location of the first UTF-8 variant character in the &lt;code&gt;ep&lt;/code&gt; pointer; if all characters are UTF-8 invariant, this function does not change the contents of &lt;code&gt;*ep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86cd12bd56f8c4d5a287a0fc3cdf7a1222db664" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer, and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff1a503be987f0032effdacb189b36936341632" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfc892fe53ef825e8f87599d3f0987cfffdb6bdb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer, and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c58aaf9e5b4c34db9f382e35942b79704f88a22" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;s&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac14a2fc2052bfda8c74ae275ad47bc11891894" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char&quot;&gt;&quot;is_utf8_valid_partial_char&quot;&lt;/a&gt;&lt;/code&gt;, it returns a boolean giving whether or not the input is a valid UTF-8 encoded partial character, but it takes an extra parameter, &lt;code&gt;flags&lt;/code&gt;, which can further restrict which code points are considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ae8be3d24ca6a297e15b0d7fafe2dba59e2100" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#ninstr&quot;&gt;&quot;ninstr&quot;&lt;/a&gt;&lt;/code&gt;, but instead finds the final (rightmost) occurrence of a sequence of bytes within another sequence, returning &lt;code&gt;NULL&lt;/code&gt; if there is no such occurrence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ec6b1469cf896b7423c3e7e32f92d207da0b8f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 사용자가 사용하는 경우 그 이름에 대한 프로그램에게 거짓말을 할 수 있도록 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문을. 다시 한 번 &lt;a href=&quot;exec&quot;&gt;exec를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53ce9db24e9d8151cb0d5ad673fbb551695d8498" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 사용자가 사용하는 경우 그 이름에 대한 프로그램에게 거짓말을 할 수 있도록 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문을. 다시 한 번 &lt;a href=&quot;#exec&quot;&gt;exec를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c07f470d836169d71198d296d47952ad2947c4f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; creates a lexical alias to the package subroutine of the same name.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; 처럼 , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 는 같은 이름의 패키지 서브 루틴에 어휘 별명을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="71fcf0aeb3b2b8b93c5a529ba638d8c163bace8e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, but should only be called when it is known that the next character in the input UTF-8 string &lt;code&gt;s&lt;/code&gt; is well-formed (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bfeaa61a4310c58029cc704a58399ca890239c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;=&lt;/code&gt; , but designates the argument as optional. If omitted, an empty string will be assigned to string values options, and the value zero to numeric options.</source>
          <target state="translated">마찬가지로 &lt;code&gt;=&lt;/code&gt; 하지만 옵션으로 인수를 지정합니다. 생략하면 빈 문자열이 문자열 값 옵션에 지정되고 값 0은 숫자 옵션에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ede365bb483e8de4140eea3631854060b2e0a3c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;=&lt;/code&gt;, but designates the argument as optional. If omitted, an empty string will be assigned to string values options, and the value zero to numeric options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a58c5a4f4c388955ace0d1b2c081730bec782ab" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ARRAY&lt;/code&gt; , but takes an index as an argument to get only one element, rather than a list of all of them.</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 와 유사 하지만 색인을 인수로 사용하여 모든 요소 목록이 아닌 하나의 요소 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f172ba9b7b9b3d5863cfacf3230b6e0158d82632" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ARRAY&lt;/code&gt;, but takes an index as an argument to get only one element, rather than a list of all of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904d0219765a58ae524cd174247fe80e59898174" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is currently called with no parameters other than the invocant package name, although that may change. Similarly, to allow for future expansion, the return value should be a single &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; value.</source>
          <target state="translated">마찬가지로 &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; 는 그 변경 될 수 있지만 현재 invocant 패키지 이름이 아닌 매개 변수없이 호출된다. 마찬가지로 향후 확장을 위해 반환 값은 단일 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 값 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f940b8493916ee3f27829022bc4c4a8f402337a1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;CLONE&lt;/code&gt;, &lt;code&gt;CLONE_SKIP&lt;/code&gt; is currently called with no parameters other than the invocant package name, although that may change. Similarly, to allow for future expansion, the return value should be a single &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712167b0cb1cf028d5ac0a7f89ae0f319bb50f60" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Copy&lt;/code&gt; but returns &lt;code&gt;dest&lt;/code&gt;. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400aa1515ac06a94cb93b93ac9f5493878616d4c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Copy&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Copy&lt;/code&gt; 하지만 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="14537197538893226d82efeb48b7a358e65846d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Moose&lt;/code&gt; , &lt;code&gt;Class::Accessor&lt;/code&gt; generates accessor methods and a constructor for your class.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Moose&lt;/code&gt; , &lt;code&gt;Class::Accessor&lt;/code&gt; 접근 방법과 클래스의 생성자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="41aea6605b986b34eea2def3a336d7bee9c15525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Moose&lt;/code&gt;, &lt;code&gt;Class::Accessor&lt;/code&gt; generates accessor methods and a constructor for your class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1911709504f680e61bf78568c4b6d9d06b0561" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Move&lt;/code&gt; but returns &lt;code&gt;dest&lt;/code&gt;. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc10814cde731762cb07a8de6fded71423754dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Move&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Move&lt;/code&gt; 하지만 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63bea6acc9be28a6d3cb950aea732759df8ac57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvIV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvIV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f72df42d4357277ebaaa7626ab2ec8434c74b44" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvNV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">마찬가지로 &lt;code&gt;SvNV&lt;/code&gt; 하지만 마법을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f987f68efd96052a6b0a92226467d6e95b9160b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d5b21bddc458bd8cbfcd7db407bfa101b7f02dfa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVbyte&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="020487c29dd87ab0c92e767efba3c8f41b9bfcc7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a5a0c092212799a2ed1d29176de9f03d368894bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVutf8&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="728e33d136e3d988de2e0baba97a509be6c9c1b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f644bfac194a0b755578b81e47d7586566e4504" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't set a length variable.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 같지만 길이 변수를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="153041f77422ab93c76bcbcf6550af4c15800fa0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but will force the SV into containing a string (&lt;code&gt;SvPOK&lt;/code&gt; ), and only a string (&lt;code&gt;SvPOK_only&lt;/code&gt; ), by hook or by crook. You need force if you are going to update the &lt;code&gt;SvPVX&lt;/code&gt; directly. Processes get magic.</source>
          <target state="translated">추천 &lt;code&gt;SvPV&lt;/code&gt; 있지만 문자열 (SV 함유으로 강제 &lt;code&gt;SvPOK&lt;/code&gt; 를 )에서만 문자열 ( &lt;code&gt;SvPOK_only&lt;/code&gt; ) 수단을 써서. &lt;code&gt;SvPVX&lt;/code&gt; 를 직접 업데이트하려면 힘이 필요 합니다. 프로세스는 마법을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d21fc8eebda239f78f40ff861ae346674bc44746" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but will force the SV into containing a string (&lt;code&gt;SvPOK&lt;/code&gt;), and only a string (&lt;code&gt;SvPOK_only&lt;/code&gt;), by hook or by crook. You need force if you are going to update the &lt;code&gt;SvPVX&lt;/code&gt; directly. Processes get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349b9b0f215cc3428bdddf241602ce0c2e78c72b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to UTF-8 first if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94d5ef1f314f46efc3bd3d45f2affc66f0be81f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to UTF-8 first if necessary. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once; use the more efficient &lt;code&gt;SvPVutf8&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826e9ea9cb83ae3e7f9096a1ec17389c37388921" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to byte representation first if necessary. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once; use the more efficient &lt;code&gt;SvPVbyte&lt;/code&gt; otherwise. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141f76de6b791c79da422cfe3133860c38f0a7b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to byte representation first if necessary. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d303190c56047f26fce52e3043032426e788042e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 유사 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e339b69da0fc6099ae5122846dd6d16329909d09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte_force&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 유사 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVbyte_force&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e41cb5a5972955c89d4da04933a8a79726a21b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="85dee70f70d9f59dd1fd504ab0aa00e6dc082a6e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8_force&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVutf8_force&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed49f80c2155ad585761ac04bf59edd4a6a0831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but doesn't process get magic.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 처리하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="de31ac38b3310b9f71eaea9b2b9823bca2371b5b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to UTF-8 first if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef89cf67971528e31aab7836397b698e7ac2bf5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to UTF-8 first if necessary. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once; use the more efficient &lt;code&gt;SvPVutf8_force&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64af48e8fcfd9300a6f250966560fbb0e199baa6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to byte representation first if necessary. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once; use the more efficient &lt;code&gt;SvPVbyte_force&lt;/code&gt; otherwise. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a9095d2fee3653ae330358ffc4695a81e6b02f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to byte representation first if necessary. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cf6163858835eb56fc5636d4aa26add2cda002" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt;, but doesn't process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd41cfed5f0aafc487ed8b935e2fe00690512ae4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">마찬가지로 &lt;code&gt;SvPV_nolen&lt;/code&gt; 하지만 개종자 먼저 필요한 경우 바이트 표현으로 SV.</target>
        </trans-unit>
        <trans-unit id="569d8ee3b9025e7d46c4e22dc014e9293f09b9cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_nolen&lt;/code&gt; 과 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c6ed04996a1df68aa8ad7cc1586c48a5135a6669" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvPV_nolen&lt;/code&gt; 과 같지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84b7cb4480c3132c8864625842015ea55fab81e1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to UTF-8 first if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa0a4e5ab6512583ca715ed04c79ddb474737cc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt;, but converts &lt;code&gt;sv&lt;/code&gt; to byte representation first if necessary. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a865431f8a7ccfcbc629a801cbd5a4e318acecb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVbyte&lt;/code&gt;, but does not process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cce88bb70d307b5b0e2ee525ca3357c9496281e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVbyte&lt;/code&gt;, but when &lt;code&gt;sv&lt;/code&gt; is undef, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fb5185aac038bc23863cae1034fcc526a2af60" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVbyte_or_null&lt;/code&gt;, but does not process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a2791b53267404eb74d9bbda43c3aea418ea86" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVutf8&lt;/code&gt;, but does not process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406f4865185c362d6a5d331cd6d62f6ed4d4d970" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVutf8&lt;/code&gt;, but when &lt;code&gt;sv&lt;/code&gt; is undef, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf879f0e51a10965057e3cd31f489e3ff76dc7b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPVutf8_or_null&lt;/code&gt;, but does not process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab106c9006a177a2bcf08f263e2472e6c9b25246" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">&lt;code&gt;SvSetSV&lt;/code&gt; 와 비슷 하지만 나중에 필요한 마술을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="18661798a6626e7bf7cdbb46868b189d21d7ee00" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV&lt;/code&gt;, but does any set magic required afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388de52bdbcc28141b225f26cb9f3fe2e05660c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">&lt;code&gt;SvSetSV_nosteal&lt;/code&gt; 과 비슷 하지만 나중에 필요한 마술을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0ed8a9070212dcdaecafb195378164bb65737213" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV_nosteal&lt;/code&gt;, but does any set magic required afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a27275be863ed7ef192a76ef76e83185d113390" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvUV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvUV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c145fe31e7a9856cfd103483b939c0b69292c062" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Zero&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Zero&lt;/code&gt; 그러나 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e95906df0f28c9ef1e7b84894c91761f182cafd1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;_to_bin()&lt;/code&gt; but with a '0b' prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293678ff919e37219d0e5d9a7fb067403eb39d97" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;_to_hex()&lt;/code&gt; but with a '0x' prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c679af24785cdf880157af3d3d87fd5d4c630443" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;_to_oct()&lt;/code&gt; but with a '0' prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a30913145132e032417d97e9d5716e5d07e3a09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the body of the article.</source>
          <target state="translated">&lt;code&gt;article&lt;/code&gt; 와 유사 하지만 기사 본문 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dbf2edb5cf6acda874d56c0ec8d6a027b38ecd7b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the headers for the article.</source>
          <target state="translated">&lt;code&gt;article&lt;/code&gt; 와 유사 하지만 기사 의 헤더 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="698d6282638ff97d91804a4f1cf2ced815c09a43" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cond_wait&lt;/code&gt; , this function may take a shared, &lt;b&gt;locked&lt;/b&gt; variable as an additional parameter; in this case the first parameter is an &lt;b&gt;unlocked&lt;/b&gt; condition variable protected by a distinct lock variable.</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 와 마찬가지로이 함수는 공유 &lt;b&gt;잠금&lt;/b&gt; 변수를 추가 매개 변수로 사용할 수 있습니다 . 이 경우 첫 번째 매개 변수는 고유 한 잠금 변수로 보호되는 &lt;b&gt;잠금 해제&lt;/b&gt; 조건 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c585c7b6a19c2570f8a734ae16123cf56bb4a904" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cond_wait&lt;/code&gt;, this function may take a shared, &lt;b&gt;locked&lt;/b&gt; variable as an additional parameter; in this case the first parameter is an &lt;b&gt;unlocked&lt;/b&gt; condition variable protected by a distinct lock variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58a5c550c804eb437e5a9f29a412c2a917db541" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;copy&lt;/code&gt; , &lt;code&gt;rmscopy&lt;/code&gt; returns 1 on success. If an error occurs, it sets &lt;code&gt;$!&lt;/code&gt; , deletes the output file, and returns 0.</source>
          <target state="translated">마찬가지로 &lt;code&gt;copy&lt;/code&gt; , &lt;code&gt;rmscopy&lt;/code&gt; 성공 수익률 1. 에러가 발생하면 &lt;code&gt;$!&lt;/code&gt; 출력 파일을 삭제하고 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09aa3572893f32ca36724882d530f081b2c921bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;rmscopy&lt;/code&gt; returns 1 on success. If an error occurs, it sets &lt;code&gt;$!&lt;/code&gt;, deletes the output file, and returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62662a2fcd9593969fecb7744ceb2295a389997a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , but it prints to the &lt;code&gt;output()&lt;/code&gt; handle so it will not normally be seen by the user except in verbose mode.</source>
          <target state="translated">마찬가지로 &lt;code&gt;diag()&lt;/code&gt; , 그러나로 인쇄 &lt;code&gt;output()&lt;/code&gt; 가 통상 모드의 상세를 제외하고는 사용자가 볼 수없는 있도록 손잡이.</target>
        </trans-unit>
        <trans-unit id="983d206f2bed9edbbc722e7d5cdb62e2a06346c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , except the message will not be seen when the test is run in a harness. It will only be visible in the verbose TAP stream.</source>
          <target state="translated">&lt;code&gt;diag()&lt;/code&gt; 와 같이 테스트가 하네스에서 실행될 때 메시지가 표시되지 않는 것을 제외하고. 자세한 TAP 스트림에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ef0020e2af04e6653b9cacfc8060419afe5437" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt;, but it prints to the &lt;code&gt;output()&lt;/code&gt; handle so it will not normally be seen by the user except in verbose mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538ead19e35b8089406067731ca6a5943e4b5625" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt;, except the message will not be seen when the test is run in a harness. It will only be visible in the verbose TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca575f5cd45b0a03fd8f03890b4f05a0793bc86" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;gv_stashpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;gv_stashpvn&lt;/code&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8691e2305cbe58536b7649210914f3f94532f0e6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;gv_stashpvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a99146718e4827b551f9b9e65221a90a0c6896f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_fetch&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;hv_fetch&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="912f545edccc3d2ff98e523743c3a82e5bacfc8d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_fetch&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b54ec87ed43945667a5780ba1140342cbc85083" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_store&lt;/code&gt; , but takes a literal string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">&lt;code&gt;hv_store&lt;/code&gt; 와 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하고 해시 매개 변수를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="1d2d05d84f4bcf370e8da5d7a89dc98a3d07cfd1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_store&lt;/code&gt;, but takes a literal string instead of a string/length pair and omits the hash parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cafedf7339223e94c98617ca5452de6e823831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;is_regexp&lt;/code&gt; this function will not be confused by overloading or blessing of the object.</source>
          <target state="translated">&lt;code&gt;is_regexp&lt;/code&gt; 와 마찬가지로이 함수는 객체의 과부 하나 축복으로 인해 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec33eb3b85c09c1867b94d4c5d38b36ea16437ca" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;newSVpvn&lt;/code&gt; 과 비슷 하지만 리터럴이 필요합니다 &lt;code&gt;NUL&lt;/code&gt; 문자열 / 길이 쌍 대신 NUL 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1133f5bdbc277f0a43759c96e6e4a136a1b3e3c6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6def24d08af466796e4eeead658a36b729d71197" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;newSVpvn_flags&lt;/code&gt; 와 비슷 하지만 리터럴 &lt;code&gt;NUL&lt;/code&gt; 을 사용합니다. 문자열 / 길이 쌍 대신 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="abd374fbe3d53f171a59b273311808bb8110bbbb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_flags&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c507c68363b1af9c5557f4eef915d6b55b26a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">마찬가지로 &lt;code&gt;newSVpvn_share&lt;/code&gt; 하지만이 소요 &lt;code&gt;NUL&lt;/code&gt; 을 문자열 / 길이 쌍 대신 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3dd80874ef095a04d51bc5aa179476376e4130b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">&lt;code&gt;newSVpvn_share&lt;/code&gt; 와 비슷 하지만 리터럴 &lt;code&gt;NUL&lt;/code&gt; 을 사용합니다. 문자열 / 길이 쌍 대신 문자열을 사용하고 해시 매개 변수를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="d6eb188b6893f815d9a8bdb27b5ac56dcb122551" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt;, but takes a &lt;code&gt;NUL&lt;/code&gt;-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49fe9b556cc6794a2516353379f67e130b7ce84" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt;, but takes a literal string instead of a string/length pair and omits the hash parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40e017fad124c7546ce8fa47f9cf471e202cba4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVsv&lt;/code&gt; but does not process get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11236bc0b511fb5ce2d7100079100494df2e3d25" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;our $variable&lt;/code&gt;, &lt;code&gt;our sub&lt;/code&gt; creates a lexical alias to the package subroutine of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a38afce596ffe8e2f194c11ba3be9d30f3333" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pasv_xfer&lt;/code&gt; but the file is stored on the remote server using the STOU command.</source>
          <target state="translated">&lt;code&gt;pasv_xfer&lt;/code&gt; 처럼 하지만 파일은 STOU 명령을 사용하여 원격 서버에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7fdced39cfee983640cff74a2b9f6b6a909daee3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;require_ok&lt;/code&gt; , but it will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; the $module in question and only loads modules, not files.</source>
          <target state="translated">&lt;code&gt;require_ok&lt;/code&gt; 와 유사 하지만 문제의 $ module을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하고 파일이 아닌 모듈 만로드합니다.</target>
        </trans-unit>
        <trans-unit id="8aa98318e2c42a18d337bece9c82948798cd16dd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;require_ok&lt;/code&gt;, but it will &lt;code&gt;use&lt;/code&gt; the $module in question and only loads modules, not files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85e64ea446b94b53e6b0a98b79acffa9e65509e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;savepvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;savepvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab6359be0dee3e4a9294e68cf9fca3c1e4336929" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;savepvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f07f68a2d9761eca21ebc3401a1a91fade1e35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;skip()&lt;/code&gt; , only it will declare the test as failing and TODO. Similar to</source>
          <target state="translated">&lt;code&gt;skip()&lt;/code&gt; 과 같이 테스트 만 실패하고 TODO로 선언합니다. 비슷하다</target>
        </trans-unit>
        <trans-unit id="3b33b5f95e762241c8de2a57e4c85b1137e8f8d8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;skip()&lt;/code&gt;, only it will declare the test as failing and TODO. Similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb9b95fcba79da2d66d4cd56bc634f774dac146" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;summary()&lt;/code&gt; , but with a lot more detail.</source>
          <target state="translated">마찬가지로 &lt;code&gt;summary()&lt;/code&gt; 하지만, 더 많은 세부 사항.</target>
        </trans-unit>
        <trans-unit id="8ab77eb4986ee757a37bdc02456676abd72f396c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;summary()&lt;/code&gt;, but with a lot more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc85a8c4d9155e4879660bb0fb6db949fdb86fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_2pv()&lt;/code&gt; , but doesn't return the length too. You should usually use the macro wrapper &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; instead.</source>
          <target state="translated">마찬가지로 &lt;code&gt;sv_2pv()&lt;/code&gt; ,하지만 너무 길이를 반환하지 않습니다. 일반적으로 매크로 래퍼 &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f1750e6fee439d6a5d7c30bcaadc82f4b76654a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_2pv()&lt;/code&gt;, but doesn't return the length too. You should usually use the macro wrapper &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28ad4ddf0b006c6eedf3f81dcaf16c9a74e085e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="74ec50e9ddcc0b0b4bd0d08a497824bb0da8c599" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catpv&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbe6953fefa65c174375eefeb7061a1d8d28d608" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96301ae15c375b77c0b44d75ba25e64a78136a72" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d094247c032470d6a00c5c42225cd27f4c338e8b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvf&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbd5c1c6aa34bdcc67b11a771b5ad797b082fb9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="52a1bc2daa3eca49de27291192d60d01346616bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1e9ddae012626cb7e4439d9980907c822af4371b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a2180c80e256d3412ef812a310798be5ad6256e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b542066a6f682efb528d954086e468e249dbea7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56485c39e91b575f9eb207ecfc300725f3983593" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_flags&lt;/code&gt; 와 유사 하지만 문자열 / 길이 쌍 대신 리터럴 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b8dc77061b45695e2a25d3d8ac47661d896a65ef" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_flags&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f05c96d8dfa46b087685cde4a872c91ee4af9a0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_mg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fade09434f240ea70c6ba8138d1c0f20965adbe6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_mg&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d239fc60878c8dca9fcf1e90342df6ee45eef1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9553515af5d9ec9e4a899f2411b3c5de81d5b4ad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_nomg&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fccee46cd5a2dbdef0b3ef34ed13318240c0cba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catsv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4126df4d71505019e5bb56c7d0ec65e860e57dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catsv&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e282341ebef2e50ac8d4be165f9aa0f02c29868c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb27b8554deaad725f9af3d8c8e7188da8e9d19b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_copypv&lt;/code&gt;, but doesn't invoke get magic first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e046d3517a7992d7d1e0d29443cd29e124206320" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_mortalcopy&lt;/code&gt;, but the extra &lt;code&gt;flags&lt;/code&gt; are passed to the &lt;code&gt;sv_setsv_flags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d38cbaa11df45cfca68f415fbd38548adbd2370" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setiv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setiv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="123ae4a5c669f8bb24b8cf176b2e86ba9cbfc11d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setiv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5a47bbf6d640fdec1cfafd760bfcac50991da5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setnv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setnv&lt;/code&gt; 처럼 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5eccffc67f571a8b3181f46b612067a5e6120f2c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setnv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50840cdec742cb9632278831faf80f40688dc0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c985c9690a312c499374407655b6ef9ec2e3e6e4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56d7c6489caae9851ec3dcbcf0456ce3751a5c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e2888cf79b645f5b449d1b4c6efb91b8ec3971c7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvf&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0fa3335ee153a3cf62cbff610e08349e8ad4b2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpviv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpviv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8d6dbd83d6e02627b8bee537343e41f6ed49077f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpviv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60536ff4b89cb5040f19feec4be6721d10632d63" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="550ac76e7931e655b1382b031643a9cb5f52950b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setpvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="481f4a0f0ab1f9f4574bd5faf772b821ede1d4a1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0931cea12270dd86a07ee0a9b6ee1091a8ce19a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4532add555cdc643bf47f76523943ddddd111761" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setpvn_mg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1d27898179a76dbb0e01036ba711d50a1c17a52f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn_mg&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ab2d21a73ed79e392dc24ffd68bc21b0539241" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setref_pvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setref_pvn&lt;/code&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9100e36266ee96c2294edf8f453c2726c48b65aa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setref_pvn&lt;/code&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2af716b65ba49b4f611a8f9a63df24afbfd34e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setsv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="029cf42c4714d829664184f54a69a5ea13d859b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_setsv&lt;/code&gt; 처럼 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45071495c613f505020d1cfedfcf720566ba6c27" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae58ef52e0fd2638f20a33b2c2ee3d70d45b7c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setuv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setuv&lt;/code&gt; 와 마찬가지로 'set'마법도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6cf4c4e06956eb2dfc680c6ee569d41126786590" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setuv&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc41b001c50d7d45a00cf8022d9c1f06a67020a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_usepvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_usepvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="00375d68772b5a6b2aa4d91a6b9d96252b296a38" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_usepvn&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48c5ccb5f58e5511c541b8f7b2bd77d2574234d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_utf8_downgrade&lt;/code&gt;, but does not process get magic on &lt;code&gt;sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19779d3638b6a1460d46c2178e7d9265d9957c6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_utf8_downgrade&lt;/code&gt;, but with additional &lt;code&gt;flags&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, processes get magic on &lt;code&gt;sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca37005148896df7fa5618334163dda55501b5e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_utf8_upgrade&lt;/code&gt;, but doesn't do magic on &lt;code&gt;sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4a9fe99bea434f521ad5e3db444369a722ea86" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt;, but has an additional parameter &lt;code&gt;extra&lt;/code&gt;, which is the number of unused bytes the string of &lt;code&gt;sv&lt;/code&gt; is guaranteed to have free after it upon return. This allows the caller to reserve extra space that it intends to fill, to avoid extra grows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4287363f537b02349404ef50aa3650a2da519053" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vcatpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="07a25ef8f06b26f172176af25178325ccea0a52b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vcatpvf&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14adf015575fe99f6c00f91da82a21970e20b8bd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vsetpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_vsetpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c99a7a12d3c14e8e4681f2d062967a1eb814fa0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vsetpvf&lt;/code&gt;, but also handles 'set' magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b383c55580a503d9f345eddab42a79557f296499" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;system&lt;/code&gt;, backticks put the child process exit code in &lt;code&gt;$?&lt;/code&gt;. If you'd like to manually inspect failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ce5b4a9c5792e4e3d807965bc2f0706dc489a6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;todo()&lt;/code&gt; but only returns the value of &lt;code&gt;$TODO&lt;/code&gt; ignoring &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;code&gt;todo()&lt;/code&gt; 만 값 반환 &lt;code&gt;$TODO&lt;/code&gt; 무시 &lt;code&gt;todo_start()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56964d94313ff89750dbfac18fe4fbc021ee2504" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;todo()&lt;/code&gt; but only returns the value of &lt;code&gt;$TODO&lt;/code&gt; ignoring &lt;code&gt;todo_start()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c255f9b56f3d7d5035702059d9768bd0f276412" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;warnings::enabled&lt;/code&gt;, but $level specifies the exact call frame, 0 being the immediate caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908551960f131fd786c42f778071d30b61bb4476" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;warnings::fatal_enabled&lt;/code&gt;, but $level specifies the exact call frame, 0 being the immediate caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a7a76c841e5f7c9a4c21b318b86a7b486c96e50" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;warnings::warn&lt;/code&gt;, but $level specifies the exact call frame, 0 being the immediate caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2a4468163a8d06d15e520d4c62bc8d67e5d7bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;warnings::warnif&lt;/code&gt;, but $level specifies the exact call frame, 0 being the immediate caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824220de4c99cc183f3e468cfbca9236675ff6fd" translate="yes" xml:space="preserve">
          <source>Like C, Perl does a certain amount of expression evaluation at compile time whenever it determines that all arguments to an operator are static and have no side effects. In particular, string concatenation happens at compile time between literals that don't do variable substitution. Backslash interpolation also happens at compile time. You can say</source>
          <target state="translated">C와 마찬가지로 Perl은 연산자에 대한 모든 인수가 정적이며 부작용이없는 것으로 판별 될 때마다 컴파일시 특정 양의 표현식 평가를 수행합니다. 특히 문자열 연결은 변수 대체를 수행하지 않는 리터럴 사이에서 컴파일 타임에 발생합니다. 백 슬래시 보간도 컴파일 타임에 발생합니다. 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13593327ac22cf57826e7691f4f7f418be9cc890" translate="yes" xml:space="preserve">
          <source>Like CPAN::Bundle::inst_file, but returns the $VERSION</source>
          <target state="translated">CPAN :: Bundle :: inst_file과 유사하지만 $ VERSION을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="180b470a6637521531543b80ac419cbc37898af4" translate="yes" xml:space="preserve">
          <source>Like Open3 but without STDERR capture.</source>
          <target state="translated">STDERR 캡처는 없지만 Open3과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2a63fd6efd31d5a247539ef7d4f8ae9b22c58256" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the site install locations.</source>
          <target state="translated">PERLPREFIX와 유사하지만 사이트 설치 위치에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="991d27f54f9be6d1ccfe86b4d87c281614bb46a9" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the vendor install locations.</source>
          <target state="translated">PERLPREFIX와 유사하지만 공급 업체 설치 위치에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3763cf6a811e93d689892e612d95e5287de00f17" translate="yes" xml:space="preserve">
          <source>Like PERLRUN, except it uses FULLPERL.</source>
          <target state="translated">FULLPERL을 사용한다는 점을 제외하고 PERLRUN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dff3350726fa7fbd1b6410bcef4d0a73c7217e0" translate="yes" xml:space="preserve">
          <source>Like PERLRUNINST, except it uses FULLPERL.</source>
          <target state="translated">PERLRUNINST와 마찬가지로 FULLPERL을 사용한다는 점만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5841126e64b3c89df76665c26ca814c87d8e1ffb" translate="yes" xml:space="preserve">
          <source>Like PREFIX, it sets several INSTALL* attributes at once. Unlike PREFIX it is easy to predict where the module will end up. The installation pattern looks like this:</source>
          <target state="translated">PREFIX와 마찬가지로 여러 INSTALL * 속성을 한 번에 설정합니다. PREFIX와 달리 모듈의 위치를 ​​쉽게 예측할 수 있습니다. 설치 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3eac640353c06a496dbb32cf64186b352fd16578" translate="yes" xml:space="preserve">
          <source>Like T_REFREF, except it does strict type checking (inheritance is not supported).</source>
          <target state="translated">T_REFREF와 마찬가지로 엄격한 유형 검사를 수행합니다 (상속은 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="b94e5c472f080d505351ce0495c57a8957e2a984" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got == $expected&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">Test :: More 's &lt;code&gt;is()&lt;/code&gt; 처럼 . &lt;code&gt;$got == $expected&lt;/code&gt; 인지 확인합니다 . 이것은 숫자 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cc96ef3fc2347f9c271af1895e169a768a31a74a" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got eq $expected&lt;/code&gt; . This is the string version.</source>
          <target state="translated">Test :: More 's &lt;code&gt;is()&lt;/code&gt; 처럼 . &lt;code&gt;$got eq $expected&lt;/code&gt; 인지 확인합니다 . 이것은 문자열 버전입니다.</target>
        </trans-unit>
        <trans-unit id="17f62623a10758c4c3b6761435cb5075609a1791" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt;. Checks if &lt;code&gt;$got == $expected&lt;/code&gt;. This is the numeric version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9447f392d01121cd67915dc61b0ec4cea9fd56" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt;. Checks if &lt;code&gt;$got eq $expected&lt;/code&gt;. This is the string version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f7c9b4de7f16b968c9df459ba87fa3286f45be" translate="yes" xml:space="preserve">
          <source>Like UTF-8, UTF-16 is a variable-width encoding, but where UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code points occupy either 2 or 4 bytes in UTF-16: code points &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; are stored in a single 16-bit unit, and code points &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; in two 16-bit units. The latter case is using</source>
          <target state="translated">UTF-8과 마찬가지로 UTF-16은 가변 너비 인코딩이지만 UTF-8이 8 비트 코드 단위를 사용하는 경우 UTF-16은 16 비트 코드 단위를 사용합니다. 모든 코드 포인트는 UTF-16에서 2 또는 4 바이트를 차지합니다. 코드 포인트 &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; 는 단일 16 비트 단위로 저장되고 코드 포인트 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 는 2 개의 16 비트로 저장됩니다. 단위. 후자의 경우는</target>
        </trans-unit>
        <trans-unit id="8dbb04c45e23e298185620fabadd06b7455bdd6a" translate="yes" xml:space="preserve">
          <source>Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is ASCII-safe. This means that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">UTF-8과 마찬가지로 EBCDIC 안전하지만 UTF-8은 ASCII 안전 방식입니다. 이는 모든 기본 문자 (예 : &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; 와 같은 ASCII 문자를 가진 모든 문자를 포함 함 ,</target>
        </trans-unit>
        <trans-unit id="e6170cafe214afdbb40c4ffbbff65c6aeebd0ba1" translate="yes" xml:space="preserve">
          <source>Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is ASCII-safe. This means that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6834a3fade58397a1a46bf4fd2e951ded5a49d5e" translate="yes" xml:space="preserve">
          <source>Like a forked process, but without &lt;b&gt;fork&lt;/b&gt;&amp;rsquo;s inherent memory protection. A thread is lighter weight than a full process, in that a process could have multiple threads running around in it, all fighting over the same process&amp;rsquo;s memory space unless steps are taken to protect threads from one another.</source>
          <target state="translated">포크 프로세스와 같지만 &lt;b&gt;포크&lt;/b&gt; 의 고유 메모리 보호 기능은 없습니다. 스레드는 전체 프로세스보다 가볍습니다. 프로세스에서 여러 스레드가 실행될 수 있기 때문에 스레드를 서로 보호하기위한 단계가 수행되지 않는 한 모든 프로세스가 동일한 프로세스의 메모리 공간에서 싸우게됩니다.</target>
        </trans-unit>
        <trans-unit id="78469c56db0b66e6f31da051cfaed2326cdc6d30" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, &lt;a href=&quot;#length-EXPR&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;length(Encode::encode('UTF-8', EXPR))&lt;/code&gt; (you'll have to &lt;code&gt;use Encode&lt;/code&gt; first). See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2266dcab58f5b4cb8dc0bb09fd899c041599a2" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">모든 Perl 문자 연산과 마찬가지로 length ()는 일반적으로 물리 바이트가 아닌 논리 문자를 처리합니다. UTF-8로 인코딩 된 문자열이 차지하는 바이트 수는 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; 먼저 사용해야 함 ). &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78626057c138b9f0db027cda4d5b95c4d7adde63" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">모든 Perl 문자 연산과 마찬가지로 length ()는 일반적으로 물리 바이트가 아닌 논리 문자를 처리합니다. UTF-8로 인코딩 된 문자열이 차지하는 바이트 수는 &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; 먼저 사용해야 함 ). &lt;a href=&quot;../encode&quot;&gt;인코딩&lt;/a&gt; 및 &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b262f2d7a83664abc258a4d3c715339214f8a1b0" translate="yes" xml:space="preserve">
          <source>Like chapters in many books, all top-level Perl source files (along with a few others here and there) begin with an epigrammatic inscription that alludes, indirectly and metaphorically, to the material you're about to read.</source>
          <target state="translated">많은 서적의 장들처럼, 모든 최상위 레벨 Perl 소스 파일 (여기서 나 다른 것들과 함께)은 읽고 자하는 자료를 간접적으로 그리고 은유 적으로 암시하는 비유적인 비문으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c0d2dcb20ae20f18b840f20ba286a29e5869333a" translate="yes" xml:space="preserve">
          <source>Like config_sh() but returns, as a list, only the config entries who's names match the $regex.</source>
          <target state="translated">config_sh ()와 비슷하지만 이름을 가진 구성 항목 만 $ regex와 일치하는 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f227f0321acaa416e145c904a4d8ec45847b8d64" translate="yes" xml:space="preserve">
          <source>Like expand, but returns objects of the appropriate type, i.e. CPAN::Bundle objects for bundles, CPAN::Module objects for modules, and CPAN::Distribution objects for distributions. Note: it does not expand to CPAN::Author objects.</source>
          <target state="translated">확장과 유사하지만 적절한 유형의 오브젝트 (예 : 번들의 경우 CPAN :: Bundle 오브젝트, 모듈의 경우 CPAN :: Module 오브젝트 및 분배의 CPAN :: Distribution 오브젝트)를 리턴합니다. 참고 : CPAN :: Author 오브젝트로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7987e14ecfb530ef395d93bea0916098ba25cf44" translate="yes" xml:space="preserve">
          <source>Like many OO interfaces, the new() method is used to initialize version objects. If two arguments are passed to &lt;code&gt;new()&lt;/code&gt;, the &lt;b&gt;second&lt;/b&gt; one will be used as if it were prefixed with &quot;v&quot;. This is to support historical use of the &lt;code&gt;qw&lt;/code&gt; operator with the CVS variable $Revision, which is automatically incremented by CVS every time the file is committed to the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f385d834d0c261050be5f51ac316a9238769d175" translate="yes" xml:space="preserve">
          <source>Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; keywords, or generated on the fly using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.</source>
          <target state="translated">많은 언어와 마찬가지로 Perl은 사용자 정의 서브 루틴을 제공합니다. 이것들은 메인 프로그램의 어느 위치 에나 있거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 키워드 를 통해 다른 파일에서로드 되거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 anonymous 서브 루틴을 사용하여 즉시 생성 될 수 있습니다 . 이름이나 CODE 참조를 포함하는 변수를 사용하여 함수를 간접적으로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa955621946321cd50075e261d09e1a7c92c1f08" translate="yes" xml:space="preserve">
          <source>Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; keywords, or generated on the fly using &lt;code&gt;eval&lt;/code&gt; or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff1e677a357242f787d00ffe6b33170f4a5ab49" translate="yes" xml:space="preserve">
          <source>Like most routines, returns a true value if successful and a false value [and sets &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;regLastError()&lt;/code&gt;] on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bb042c0a5ea5166342c8b0ad6d2f8a2141fbc4" translate="yes" xml:space="preserve">
          <source>Like octal escapes, there are two forms of hexadecimal escapes, but both start with the sequence &lt;code&gt;\x&lt;/code&gt; . This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.</source>
          <target state="translated">8 진 이스케이프와 같이 16 진 이스케이프에는 두 가지 형태가 있지만 모두 &lt;code&gt;\x&lt;/code&gt; 시퀀스로 시작합니다 . 그 뒤에 숫자를 형성하는 정확히 두 개의 16 진 숫자 또는 중괄호로 둘러싸인 16 진수의 임의 길이가옵니다. 16 진수는 표현하려는 문자의 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="8a3985e9eb051df5a5554fc58d279011c3ff1a77" translate="yes" xml:space="preserve">
          <source>Like octal escapes, there are two forms of hexadecimal escapes, but both start with the sequence &lt;code&gt;\x&lt;/code&gt;. This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea93e43cdaa94011eb7f20af4624fc89df3b75e2" translate="yes" xml:space="preserve">
          <source>Like other pragmas (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , for example), features have a lexical effect. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; will only make the feature &quot;foo&quot; available from that point to the end of the enclosing block.</source>
          <target state="translated">다른 pragma와 마찬가지로 ( 예 : &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; ) 피처는 어휘 효과가 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; 만을 포함하는 블록의 끝까지를 가리키는에서 사용할 수있는 기능 &quot;foo는&quot;을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="60f22d4af04544396e97c0fdb822358710ad0090" translate="yes" xml:space="preserve">
          <source>Like other pragmas (&lt;code&gt;use strict&lt;/code&gt;, for example), features have a lexical effect. &lt;code&gt;use feature qw(foo)&lt;/code&gt; will only make the feature &quot;foo&quot; available from that point to the end of the enclosing block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e331233743ae8af2fc425fe1e46364f44f02fcf9" translate="yes" xml:space="preserve">
          <source>Like property names, there is typically at least a short name for each such property-value, and a long name. If you know any name of the property-value (which you can get by &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt;, you can use &lt;code&gt;prop_value_aliases&lt;/code&gt;() to get the long name (when called in scalar context), or a list of all the names, with the short name in the 0th element, the long name in the next element, and any other synonyms in the remaining elements, in no particular order, except that any all-numeric synonyms will be last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84dcad78456fba45a7cd86383d5b5d51df6ab7d" translate="yes" xml:space="preserve">
          <source>Like property names, there is typically at least a short name for each such property-value, and a long name. If you know any name of the property-value (which you can get by &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt;, you can use &lt;code&gt;prop_value_aliases&lt;/code&gt; () to get the long name (when called in scalar context), or a list of all the names, with the short name in the 0th element, the long name in the next element, and any other synonyms in the remaining elements, in no particular order, except that any all-numeric synonyms will be last.</source>
          <target state="translated">속성 이름과 마찬가지로 일반적으로 이러한 각 속성 값의 짧은 이름과 긴 이름이 있습니다. &lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()로&lt;/a&gt; 얻을 수있는 특성 값의 이름을 알고 있으면 &lt;code&gt;prop_value_aliases&lt;/code&gt; ()를 사용 하여 긴 이름 (스칼라 컨텍스트에서 호출 될 때) 또는 짧은 이름을 가진 모든 이름 목록을 가져올 수 있습니다. 모든 숫자의 동의어가 마지막이라는 것을 제외하고는 0 번째 요소의 이름, 다음 요소의 긴 이름 및 나머지 요소의 다른 동의어는 특별한 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="199b34f10e1b7c8e7aa443166b2eaa7617b87f12" translate="yes" xml:space="preserve">
          <source>Like sv_copypv, but doesn't invoke get magic first.</source>
          <target state="translated">sv_copypv와 비슷하지만 먼저 마법을 얻지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fa3c089315a35ab69068f31035a53de1242b1f4a" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade, but doesn't do magic on &lt;code&gt;sv&lt;/code&gt; .</source>
          <target state="translated">sv_utf8_upgrade와 비슷하지만 &lt;code&gt;sv&lt;/code&gt; 에서는 마술을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="491235f5863c419144ac401911f4034bbb235829" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade_flags, but has an additional parameter &lt;code&gt;extra&lt;/code&gt; , which is the number of unused bytes the string of 'sv' is guaranteed to have free after it upon return. This allows the caller to reserve extra space that it intends to fill, to avoid extra grows.</source>
          <target state="translated">sv_utf8_upgrade_flags와 유사하지만 추가 매개 변수 &lt;code&gt;extra&lt;/code&gt; 가 있습니다 .이 매개 변수 는 사용되지 않은 바이트 수이며 'sv'문자열은 반환 후 여유 공간을 갖습니다. 이를 통해 발신자는 추가 증가를 피하기 위해 채울 추가 공간을 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b473e807de38ef5585564f3999d8d88c0c2f9ac9" translate="yes" xml:space="preserve">
          <source>Like the</source>
          <target state="translated">처럼</target>
        </trans-unit>
        <trans-unit id="1ec8b78d751f8503bdfc1aa5c17c2c7732f46241" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#%28%3Fadlupimnsx-imnsx%29&quot;&gt;&quot;(?adlupimnsx-imnsx)&quot;&lt;/a&gt; construct, &lt;code&gt;aa&lt;/code&gt; and &lt;code&gt;&quot;a&quot;&lt;/code&gt; override each other, as do &lt;code&gt;xx&lt;/code&gt; and &lt;code&gt;&quot;x&quot;&lt;/code&gt;. They are not additive. So, doing something like &lt;code&gt;(?xx-x:foo)&lt;/code&gt; turns off all &lt;code&gt;&quot;x&quot;&lt;/code&gt; behavior for matching &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e09e117230303a3e7e1540483add81bffa29662" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode properties&lt;/a&gt;, most of the POSIX properties match the same regardless of whether case-insensitive (&lt;code&gt;/i&lt;/code&gt;) matching is in effect or not. The two exceptions are &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;. Under &lt;code&gt;/i&lt;/code&gt;, they each match the union of &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Unicode-Properties&quot;&gt;유니 코드 속성&lt;/a&gt; 과 마찬가지로 대부분의 POSIX 속성 은 대 &lt;code&gt;/i&lt;/code&gt; 소문자를 구분하지 않는 ( / i ) 일치 여부에 관계없이 동일하게 일치합니다 . 두 가지 예외는 &lt;code&gt;[:upper:]&lt;/code&gt; 및 &lt;code&gt;[:lower:]&lt;/code&gt; 입니다. 아래에서 &lt;code&gt;/i&lt;/code&gt; 의, 그들은 각각의 일치 노조 &lt;code&gt;[:upper:]&lt;/code&gt; 와 &lt;code&gt;[:lower:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56e82ac0ce55d077dfdc075b06ddac56ad8fd05e" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, if a &lt;code&gt;readline&lt;/code&gt; expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a &lt;code&gt;readline&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readline&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf3175a68d636ecf9925b34e6ff6a44a156b660" translate="yes" xml:space="preserve">
          <source>Like the existing DBM Filter functionality, this module arranges for the &lt;code&gt;$_&lt;/code&gt; variable to be populated with the key or value that a filter will check. This usually means that most DBM filters tend to be very short.</source>
          <target state="translated">기존 DBM 필터 기능과 마찬가지로이 모듈은 &lt;code&gt;$_&lt;/code&gt; 변수가 필터에서 확인할 키 또는 값으로 채워지도록 정렬합니다 . 이것은 대개 대부분의 DBM 필터가 매우 짧은 경향이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2aa9d0e9009ba5b1538c8cb1249a579d95be7bcd" translate="yes" xml:space="preserve">
          <source>Like the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in &lt;code&gt;@a&lt;/code&gt; and made &lt;code&gt;@b&lt;/code&gt; empty. See &lt;a href=&quot;#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot;&lt;/a&gt; for alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cce6c08fa97ca0be477f0721fb283a52d10b11" translate="yes" xml:space="preserve">
          <source>Like the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in &lt;code&gt;@a&lt;/code&gt; and made &lt;code&gt;@b&lt;/code&gt; empty. See &lt;a href=&quot;#Pass-by-Reference&quot;&gt;Pass by Reference&lt;/a&gt; for alternatives.</source>
          <target state="translated">병합 된 수신 매개 변수 목록과 마찬가지로 반환 목록도 반환시 병합됩니다. 따라서 여기에서 관리 한 모든 것은 &lt;code&gt;@a&lt;/code&gt; 에 모든 것을 저장 하고 &lt;code&gt;@b&lt;/code&gt; 를 비워 두었 습니다. 대안 &lt;a href=&quot;#Pass-by-Reference&quot;&gt;은 참조로 전달&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="afd075e21a0c597db0ab2821856e88ceb5961fd6" translate="yes" xml:space="preserve">
          <source>Like the normal &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, except it reports according to your &lt;code&gt;level()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;level()&lt;/code&gt; 에 따라보고하는 것을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8d1f3b5af74d0fcd2065711ea1d65ad1437e3ca2" translate="yes" xml:space="preserve">
          <source>Like the normal &lt;code&gt;caller()&lt;/code&gt;, except it reports according to your &lt;code&gt;level()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d2b0ec03adb313bc91ba8220b07bc1ab800f57" translate="yes" xml:space="preserve">
          <source>Like the other methods, the input parameter is not checked for validity. &lt;code&gt;undef&lt;/code&gt; or containing non-digits has the same effect as 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200195811a3c205ce0d87247b5aab2a0a4c65d8e" translate="yes" xml:space="preserve">
          <source>Like their AV counterparts, &lt;code&gt;hv_clear&lt;/code&gt; deletes all the entries in the hash table but does not actually delete the hash table. The &lt;code&gt;hv_undef&lt;/code&gt; deletes both the entries and the hash table itself.</source>
          <target state="translated">AV 대응 물과 마찬가지로 &lt;code&gt;hv_clear&lt;/code&gt; 는 해시 테이블의 모든 항목을 삭제하지만 실제로 해시 테이블은 삭제하지 않습니다. &lt;code&gt;hv_undef&lt;/code&gt; 는 항목 및 해시 테이블 자체를 모두 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e82abff5c6c10139b1928c82bbe909480a69e24a" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl binary that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄 바이너리에 대해 발생했을 가능성이 있습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5195e8e0970c4f356d29e2dc5df49c188d971cda" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl library tree that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄 라이브러리 트리에서 발생할 수 있습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a2da7a5f3225b97435c319fa8a430eb74f8dc5d" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄이 발생할 가능성이 높습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="fc78654c95e5eb9c78fd54cff382380c29359dd7" translate="yes" xml:space="preserve">
          <source>Likely you forgot the &lt;code&gt;/x&lt;/code&gt; modifier or there was a typo in the pattern. For example, did you really mean to match a form-feed? If so, all the ASCII vertical space control characters are representable by escape sequences which won't present such a jarring appearance as your pattern does when displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87358f4e2ddd3816d7f56b79a06ec5e87b2b467" translate="yes" xml:space="preserve">
          <source>Likely, you should use this only for debugging anyway.</source>
          <target state="translated">어쨌든 디버깅을 위해서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e2ad79894aa707c67ca50ba4a61384758d0873a" translate="yes" xml:space="preserve">
          <source>Likewise on all other OS levels. Then execute the following command, and fill in its choices</source>
          <target state="translated">다른 모든 OS 수준에서도 마찬가지입니다. 그런 다음 다음 명령을 실행하고 선택을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="907735ad554b354d50508dedc314aa895182b86c" translate="yes" xml:space="preserve">
          <source>Likewise the call in:</source>
          <target state="translated">마찬가지로 전화 :</target>
        </trans-unit>
        <trans-unit id="65ed6c9aec28bb7eb33858993a0680b4d9a0419f" translate="yes" xml:space="preserve">
          <source>Likewise,</source>
          <target state="translated">Likewise,</target>
        </trans-unit>
        <trans-unit id="c02c1537f9374adb04ab89c0867bc362683b8992" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; passes the LIST to the corresponding splice command.</source>
          <target state="translated">마찬가지로, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; 는 해당 splice 명령에 LIST를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="886e8885f96bc8b4a5e209980f534b6f61eacaf4" translate="yes" xml:space="preserve">
          <source>Likewise, Filter::Simple is also smart enough to Do The Right Thing if you use Exporter:</source>
          <target state="translated">마찬가지로 Filter :: Simple은 Exporter를 사용하는 경우 올바른 일을 할만 큼 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="160bda2110bdb1f3a950ddf5accf544eb0786069" translate="yes" xml:space="preserve">
          <source>Likewise, declaring any variables with the &lt;code&gt;:Loud&lt;/code&gt; attribute within the package:</source>
          <target state="translated">마찬가지로 패키지 내에서 &lt;code&gt;:Loud&lt;/code&gt; 속성을 사용하여 변수를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="84a02ce9b38a8238dd6e99f162e9536e66631ce0" translate="yes" xml:space="preserve">
          <source>Likewise, install &quot;iPKGui Beta&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6adecc01f3598897c4c9f089b3d20664151e435" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; formats pack a string that's that many bits long. Each such format generates 1 bit of the result. These are typically followed by a repeat count like &lt;code&gt;B8&lt;/code&gt; or &lt;code&gt;B64&lt;/code&gt; .</source>
          <target state="translated">마찬가지로, &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 형식은 많은 비트 길이의 문자열을 묶습니다. 이러한 각 형식은 1 비트의 결과를 생성합니다. 이들은 일반적으로 &lt;code&gt;B8&lt;/code&gt; 또는 &lt;code&gt;B64&lt;/code&gt; 와 같은 반복 횟수를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="0a9dd269cb5956c09af91c5ffea1e001451d2341" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; formats pack a string that's that many bits long. Each such format generates 1 bit of the result. These are typically followed by a repeat count like &lt;code&gt;B8&lt;/code&gt; or &lt;code&gt;B64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e8f9ee995abe8e9c9ec7e9aaf53f3578e6a6e8" translate="yes" xml:space="preserve">
          <source>Likewise, there is no public API to read values from the temporaries stack. Instead. the macros &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;code&gt;FREETPMS&lt;/code&gt; are used. The &lt;code&gt;SAVETMPS&lt;/code&gt; macro establishes the base levels of the temporaries stack, by capturing the current value of &lt;code&gt;PL_tmps_ix&lt;/code&gt; into &lt;code&gt;PL_tmps_floor&lt;/code&gt; and saving the previous value to the save stack. Thereafter, whenever &lt;code&gt;FREETMPS&lt;/code&gt; is invoked all of the temporaries that have been pushed since that level are reclaimed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cbdf24c8a85f92cd82aa3a094249d6de02bf8f" translate="yes" xml:space="preserve">
          <source>Likewise, to create a class hierarchy in which every initializer inherited by a new object is invoked:</source>
          <target state="translated">마찬가지로, 새 객체에 의해 상속 된 모든 이니셜 라이저가 호출되는 클래스 계층 구조를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b2d941fa8901c396508e50ff7018851261440d12" translate="yes" xml:space="preserve">
          <source>Likewise, when using the &lt;a href=&quot;autosplit&quot;&gt;&lt;code&gt;AutoSplit&lt;/code&gt;&lt;/a&gt; module, try to keep your functions to 8.3 naming and case-insensitive conventions; or, at the least, make it so the resulting files have a unique (case-insensitively) first 8 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bd46189954c3a64d496328cd96089f6f4f9542" translate="yes" xml:space="preserve">
          <source>Likewise, when using the &lt;code&gt;AutoSplit&lt;/code&gt; module, try to keep your functions to 8.3 naming and case-insensitive conventions; or, at the least, make it so the resulting files have a unique (case-insensitively) first 8 characters.</source>
          <target state="translated">마찬가지로, &lt;code&gt;AutoSplit&lt;/code&gt; 모듈을 사용할 때는 함수의 이름을 8.3 이름과 대소 문자를 구분하지 않는 규칙으로 유지하십시오. 또는 결과 파일에 고유 한 (대소 문자를 구분하지 않는) 처음 8자를 갖도록하십시오.</target>
        </trans-unit>
        <trans-unit id="622e4bdf3675a214ecc2d659e2770e558df61e8a" translate="yes" xml:space="preserve">
          <source>Limit on the value of Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73edeb8158f532278a32208dcd47fe3a3d7f86f" translate="yes" xml:space="preserve">
          <source>Limit recursion depth to N levels when dumping structures. Negative values are interpreted as infinity. Default: infinity.</source>
          <target state="translated">구조물을 덤프 할 때 재귀 깊이를 N 수준으로 제한하십시오. 음수 값은 무한대로 해석됩니다. 기본값 : 무한대.</target>
        </trans-unit>
        <trans-unit id="2d1726e76688b7950a8162233fc1e17657b1edf0" translate="yes" xml:space="preserve">
          <source>Limitation with regard to &lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; 에 대한 제한</target>
        </trans-unit>
        <trans-unit id="55330d97525455296ae0e4b51ff25bb7abdac5c6" translate="yes" xml:space="preserve">
          <source>Limitation with regard to _</source>
          <target state="translated">_에 대한 제한</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b39570022e2b6b41ec90b798a2544b51d29caf01" translate="yes" xml:space="preserve">
          <source>Limitations of Perl under AmigaOS 4.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e092ad529e2081e851e343be794f7609f24237" translate="yes" xml:space="preserve">
          <source>Limits of time_t</source>
          <target state="translated">time_t의 한계</target>
        </trans-unit>
        <trans-unit id="6234e2f414d2b26733b9fd769dba962a7fcc3692" translate="yes" xml:space="preserve">
          <source>Limits on Numbers of Open Files on Solaris.</source>
          <target state="translated">Solaris에서 열린 파일 수에 대한 제한.</target>
        </trans-unit>
        <trans-unit id="a139366c419ef510c76cf49f4a191349fd578640" translate="yes" xml:space="preserve">
          <source>Line 1 is a macro, and its definition is dependent on your operating system. Line 3 references &lt;code&gt;PL_do_undump&lt;/code&gt; , a global variable - all global variables in Perl start with &lt;code&gt;PL_&lt;/code&gt; . This tells you whether the current running program was created with the &lt;code&gt;-u&lt;/code&gt; flag to perl and then</source>
          <target state="translated">1 행은 매크로이며 그 정의는 운영 체제에 따라 다릅니다. 3 행 은 전역 변수 인 &lt;code&gt;PL_do_undump&lt;/code&gt; 를 참조 합니다. Perl의 모든 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 로 시작 합니다. 이것은 현재 실행중인 프로그램이 &lt;code&gt;-u&lt;/code&gt; 플래그를 사용하여 perl 로 작성된 후 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0b0e9f3f9db20ac76f95740a88474a1af455f6f4" translate="yes" xml:space="preserve">
          <source>Line 1 is a macro, and its definition is dependent on your operating system. Line 3 references &lt;code&gt;PL_do_undump&lt;/code&gt;, a global variable - all global variables in Perl start with &lt;code&gt;PL_&lt;/code&gt;. This tells you whether the current running program was created with the &lt;code&gt;-u&lt;/code&gt; flag to perl and then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d4d7a9a244a3d12dfe7fb244172b4a39165816" translate="yes" xml:space="preserve">
          <source>Line 1 tells us we're looking at an SV which lives at &lt;code&gt;0xa04ecbc&lt;/code&gt; in memory. SVs themselves are very simple structures, but they contain a pointer to a more complex structure. In this case, it's a PV, a structure which holds a string value, at location &lt;code&gt;0xa041450&lt;/code&gt; . Line 2 is the reference count; there are no other references to this data, so it's 1.</source>
          <target state="translated">1 행 은 메모리 에 &lt;code&gt;0xa04ecbc&lt;/code&gt; 에 있는 SV를보고 있다고 알려줍니다 . SV 자체는 매우 간단한 구조이지만 더 복잡한 구조에 대한 포인터를 포함합니다. 이 경우, 위치 &lt;code&gt;0xa041450&lt;/code&gt; 에서 문자열 값을 보유하는 구조 인 PV 입니다. 2 행은 참조 횟수입니다. 이 데이터에 대한 다른 참조는 없으므로 1입니다.</target>
        </trans-unit>
        <trans-unit id="8257e528d7a56dcca4db122b50b35bdc95c95709" translate="yes" xml:space="preserve">
          <source>Line 1 tells us we're looking at an SV which lives at &lt;code&gt;0xa04ecbc&lt;/code&gt; in memory. SVs themselves are very simple structures, but they contain a pointer to a more complex structure. In this case, it's a PV, a structure which holds a string value, at location &lt;code&gt;0xa041450&lt;/code&gt;. Line 2 is the reference count; there are no other references to this data, so it's 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852a5525bd0666646b8baf89f18138582eb7fb29" translate="yes" xml:space="preserve">
          <source>Line 1, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; , includes and installs the &lt;code&gt;cpp&lt;/code&gt; filter module. All source filters work this way. The use statement is compiled and executed at compile time, before any more of the file is read, and it attaches the cpp filter to the source stream behind the scenes. Now the data flow looks like this:</source>
          <target state="translated">1 행 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하고 &lt;code&gt;cpp&lt;/code&gt; 필터 모듈을 포함하고 설치합니다 . 모든 소스 필터는이 방식으로 작동합니다. use 문은 더 많은 파일을 읽기 전에 컴파일 타임에 컴파일 및 실행되며 cpp 필터를 장면 뒤의 소스 스트림에 첨부합니다. 이제 데이터 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d80c9fd96dedf73af4c56122f85ab0c0aa067ae" translate="yes" xml:space="preserve">
          <source>Line 1, &lt;code&gt;use Filter::cpp&lt;/code&gt;, includes and installs the &lt;code&gt;cpp&lt;/code&gt; filter module. All source filters work this way. The use statement is compiled and executed at compile time, before any more of the file is read, and it attaches the cpp filter to the source stream behind the scenes. Now the data flow looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe884af42f04d28c78e5fe62707a6228b47c52d" translate="yes" xml:space="preserve">
          <source>Line 10 does the actual catenation: the &lt;code&gt;Move&lt;/code&gt; macro moves a chunk of memory around: we move the string &lt;code&gt;ptr&lt;/code&gt; to the end of the PV - that's the start of the PV plus its current length. We're moving &lt;code&gt;len&lt;/code&gt; bytes of type &lt;code&gt;char&lt;/code&gt; . After doing so, we need to tell Perl we've extended the string, by altering &lt;code&gt;CUR&lt;/code&gt; to reflect the new length. &lt;code&gt;SvEND&lt;/code&gt; is a macro which gives us the end of the string, so that needs to be a &lt;code&gt;&quot;\0&quot;&lt;/code&gt; .</source>
          <target state="translated">10 행은 실제 연결을 수행합니다. &lt;code&gt;Move&lt;/code&gt; 매크로는 메모리를 움직입니다. 문자열 &lt;code&gt;ptr&lt;/code&gt; 을 PV의 끝으로 이동합니다. 즉 PV의 시작에 현재 길이를 더한 값입니다. &lt;code&gt;char&lt;/code&gt; 유형의 &lt;code&gt;len&lt;/code&gt; 바이트를 이동 합니다. 그렇게 한 후 , 새로운 길이를 반영하도록 &lt;code&gt;CUR&lt;/code&gt; 을 변경하여 Perl에게 문자열을 확장했다고 알려야 합니다. &lt;code&gt;SvEND&lt;/code&gt; 는 문자열의 끝을 알려주는 매크로이므로 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="343b8ed5119a25daa7a642907594c94fca594fc8" translate="yes" xml:space="preserve">
          <source>Line 10 does the actual catenation: the &lt;code&gt;Move&lt;/code&gt; macro moves a chunk of memory around: we move the string &lt;code&gt;ptr&lt;/code&gt; to the end of the PV - that's the start of the PV plus its current length. We're moving &lt;code&gt;len&lt;/code&gt; bytes of type &lt;code&gt;char&lt;/code&gt;. After doing so, we need to tell Perl we've extended the string, by altering &lt;code&gt;CUR&lt;/code&gt; to reflect the new length. &lt;code&gt;SvEND&lt;/code&gt; is a macro which gives us the end of the string, so that needs to be a &lt;code&gt;&quot;\0&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ce4818db70a98f47c9e31ba9a951fb125f8128" translate="yes" xml:space="preserve">
          <source>Line 10 is the null op: this does exactly nothing. What is that doing there? If you see the null op, it's a sign that something has been optimized away after parsing. As we mentioned in &lt;a href=&quot;#Optimization&quot;&gt;&quot;Optimization&quot;&lt;/a&gt;, the optimization stage sometimes converts two operations into one, for example when fetching a scalar variable. When this happens, instead of rewriting the op tree and cleaning up the dangling pointers, it's easier just to replace the redundant operation with the null op. Originally, the tree would have looked like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7912d365642f9e0b2b596d940dc9036620ccc8" translate="yes" xml:space="preserve">
          <source>Line 10 is the null op: this does exactly nothing. What is that doing there? If you see the null op, it's a sign that something has been optimized away after parsing. As we mentioned in &lt;a href=&quot;#Optimization&quot;&gt;Optimization&lt;/a&gt;, the optimization stage sometimes converts two operations into one, for example when fetching a scalar variable. When this happens, instead of rewriting the op tree and cleaning up the dangling pointers, it's easier just to replace the redundant operation with the null op. Originally, the tree would have looked like this:</source>
          <target state="translated">라인 10은 널 연산입니다. 정확히 아무것도하지 않습니다. 저기서 뭐하는거야? null op가 표시되면 구문 분석 후 무언가가 최적화되었다는 신호입니다. 우리가 언급했듯이&lt;a href=&quot;#Optimization&quot;&gt; Optimization&lt;/a&gt; 에서 최적화 단계는 때로는 두 개의 연산을 하나의 스칼라 변수를 가져올 때 하나로 변환합니다. 이 경우 op 트리를 다시 작성하고 매달려있는 포인터를 정리하는 대신 중복 작업을 null op로 바꾸는 것이 더 쉽습니다. 원래 나무는 다음과 같았습니다.</target>
        </trans-unit>
        <trans-unit id="264f13994058273b1e958110b35aba9f84b7d3f9" translate="yes" xml:space="preserve">
          <source>Line 13 manipulates the flags; since we've changed the PV, any IV or NV values will no longer be valid: if we have &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; we don't want to use the old IV of 10. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; is a special UTF-8-aware version of &lt;code&gt;SvPOK_only&lt;/code&gt; , a macro which turns off the IOK and NOK flags and turns on POK. The final &lt;code&gt;SvTAINT&lt;/code&gt; is a macro which launders tainted data if taint mode is turned on.</source>
          <target state="translated">13 행은 플래그를 조작합니다. PV를 변경 했으므로 IV 또는 NV 값은 더 이상 유효하지 않습니다. &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; 이전 IV IV 10을 사용하고 싶지 않습니다. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; 은 특수 UTF-8 인식 버전의 &lt;code&gt;SvPOK_only&lt;/code&gt; 버전으로 , IOK 및 NOK 플래그를 끄고 POK를 켜는 매크로입니다. 마지막 &lt;code&gt;SvTAINT&lt;/code&gt; 는 오염 모드가 켜져있는 경우 오염 된 데이터를 세탁 하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="f14c02821009fa7c46a173af60df4534a9b06517" translate="yes" xml:space="preserve">
          <source>Line 13 manipulates the flags; since we've changed the PV, any IV or NV values will no longer be valid: if we have &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; we don't want to use the old IV of 10. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; is a special UTF-8-aware version of &lt;code&gt;SvPOK_only&lt;/code&gt;, a macro which turns off the IOK and NOK flags and turns on POK. The final &lt;code&gt;SvTAINT&lt;/code&gt; is a macro which launders tainted data if taint mode is turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755dd87e19fd3ba2af902fab337428ef967e0ea8" translate="yes" xml:space="preserve">
          <source>Line 3 are the flags for this SV - it's OK to use it as a PV, it's a read-only SV (because it's a constant) and the data is a PV internally. Next we've got the contents of the string, starting at location &lt;code&gt;0xa0484e0&lt;/code&gt; .</source>
          <target state="translated">3 번 라인은이 SV의 플래그입니다. PV로 사용하는 것이 좋습니다. 상수이기 때문에 읽기 전용 SV이며 데이터는 내부적으로 PV입니다. 다음으로 위치에서 시작하여 문자열의 내용을 얻었습니다. &lt;code&gt;0xa0484e0&lt;/code&gt; 습니다 .</target>
        </trans-unit>
        <trans-unit id="c6d733118bea452010f0639494cd9d297ac988a2" translate="yes" xml:space="preserve">
          <source>Line 3 are the flags for this SV - it's OK to use it as a PV, it's a read-only SV (because it's a constant) and the data is a PV internally. Next we've got the contents of the string, starting at location &lt;code&gt;0xa0484e0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40714861418609c0c173cdb387c1235ef584feb6" translate="yes" xml:space="preserve">
          <source>Line 4 calls a function in</source>
          <target state="translated">라인 4는 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b40e00c673cb8c91399cf977ab21f4560a36a721" translate="yes" xml:space="preserve">
          <source>Line 4 checks what type of token we are expecting. &lt;code&gt;Aop&lt;/code&gt; returns a token. If you search for &lt;code&gt;Aop&lt;/code&gt; elsewhere in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce643cab9a4e3c9a722892a06301bcddec99baf" translate="yes" xml:space="preserve">
          <source>Line 5 gives us the current length of the string - note that this does &lt;b&gt;not&lt;/b&gt; include the null terminator. Line 6 is not the length of the string, but the length of the currently allocated buffer; as the string grows, Perl automatically extends the available storage via a routine called &lt;code&gt;SvGROW&lt;/code&gt; .</source>
          <target state="translated">5 행은 현재 문자열 길이를 나타 냅니다. 여기에는 null 종결자가 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 6 행은 문자열의 길이가 아니라 현재 할당 된 버퍼의 길이입니다. 문자열이 커지면 Perl은 &lt;code&gt;SvGROW&lt;/code&gt; 라는 루틴을 통해 사용 가능한 스토리지를 자동으로 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="379de365d1a548a0387a33346f31194909c467b1" translate="yes" xml:space="preserve">
          <source>Line 5 gives us the current length of the string - note that this does &lt;b&gt;not&lt;/b&gt; include the null terminator. Line 6 is not the length of the string, but the length of the currently allocated buffer; as the string grows, Perl automatically extends the available storage via a routine called &lt;code&gt;SvGROW&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e801a645ef8652f9762283242a90486b96636e4b" translate="yes" xml:space="preserve">
          <source>Line 5 is another variable declaration - all variable declarations start with &lt;code&gt;d&lt;/code&gt; - which pops from the top of the argument stack two NVs (hence &lt;code&gt;nn&lt;/code&gt; ) and puts them into the variables &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt; , hence the &lt;code&gt;rl&lt;/code&gt; . These are the two operands to the addition operator. Next, we call &lt;code&gt;SETn&lt;/code&gt; to set the NV of the return value to the result of adding the two values. This done, we return - the &lt;code&gt;RETURN&lt;/code&gt; macro makes sure that our return value is properly handled, and we pass the next operator to run back to the main run loop.</source>
          <target state="translated">5 번째 줄은 또 다른 변수 선언입니다. 모든 변수 선언은 &lt;code&gt;d&lt;/code&gt; 로 시작 합니다. 인수의 상단에서 두 개의 NV (따라서 &lt;code&gt;nn&lt;/code&gt; ) 가 튀어 나와서 &lt;code&gt;right&lt;/code&gt; 과 &lt;code&gt;left&lt;/code&gt; 의 변수에 들어가 므로 &lt;code&gt;rl&lt;/code&gt; 입니다. 이들은 더하기 연산자에 대한 두 피연산자입니다. 다음으로 &lt;code&gt;SETn&lt;/code&gt; 을 호출 하여 반환 값의 NV를 두 값을 더한 결과로 설정합니다. 이 완료, 우리는 반환- &lt;code&gt;RETURN&lt;/code&gt; 매크로는 우리의 반환 값이 제대로 처리되었는지 확인합니다, 우리는 다시 메인 실행 루프 실행 다음 연산자를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9ab0a06fa26dc1e693bbb46194cc19123ec14b86" translate="yes" xml:space="preserve">
          <source>Line 6 installs the city name into the appropriate array. &lt;code&gt;$table{$country}&lt;/code&gt; now holds a reference to the array of cities seen in that country so far. Line 6 is exactly like</source>
          <target state="translated">6 행은 도시 이름을 적절한 배열에 설치합니다. &lt;code&gt;$table{$country}&lt;/code&gt; 지금까지 해당 국가에서 본 여러 도시에 대한 참조를 보유합니다. 6 호선은 정확히</target>
        </trans-unit>
        <trans-unit id="c2ba84f7598874c7f48acd427ca1d636fc55bdcd" translate="yes" xml:space="preserve">
          <source>Line 6 is another variable declaration - all variable declarations start with &lt;code&gt;d&lt;/code&gt; - which pops from the top of the argument stack two NVs (hence &lt;code&gt;nn&lt;/code&gt;) and puts them into the variables &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt;, hence the &lt;code&gt;rl&lt;/code&gt;. These are the two operands to the addition operator. Next, we call &lt;code&gt;SETn&lt;/code&gt; to set the NV of the return value to the result of adding the two values. This done, we return - the &lt;code&gt;RETURN&lt;/code&gt; macro makes sure that our return value is properly handled, and we pass the next operator to run back to the main run loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48a3eb6c3c3e42eae96423913fd8ffbda526837" translate="yes" xml:space="preserve">
          <source>Line Buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfe50eaa50ff37a3814f18a6020ab1131445d28" translate="yes" xml:space="preserve">
          <source>Line Listing Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62686b06fae48d96cf870eba5c52faaa0c94ec93" translate="yes" xml:space="preserve">
          <source>Line number that will be executed next.</source>
          <target state="translated">다음에 실행될 라인 번호.</target>
        </trans-unit>
        <trans-unit id="4c2e43f7c549f47cf9031361a83c442a60f08003" translate="yes" xml:space="preserve">
          <source>Line up corresponding items vertically.</source>
          <target state="translated">해당 항목을 세로로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="90a0a22c457fd80684a0398fb72051a69780b70d" translate="yes" xml:space="preserve">
          <source>Line up corresponding things vertically, especially if it'd be too long to fit on one line anyway.</source>
          <target state="translated">특히 어쨌든 한 줄에 맞추기에는 너무 길면 해당하는 것을 세로로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="fddad56552c576f0323dae03070effe7302ccb5f" translate="yes" xml:space="preserve">
          <source>Line up your transliterations when it makes sense:</source>
          <target state="translated">음역이 의미가있는 경우 음역을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4dd6f945e5b458504f42d21fe69947944476c20f" translate="yes" xml:space="preserve">
          <source>Line wrapping to form simple paragraphs</source>
          <target state="translated">간단한 단락을 형성하는 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="3c31b396df21c211f23a01f3c792334d1e4f696c" translate="yes" xml:space="preserve">
          <source>Line-by-line debugging. Causes &lt;code&gt;DB::DB()&lt;/code&gt; subroutine to be called for each statement executed. Also causes saving source code lines (like 0x400).</source>
          <target state="translated">라인 별 디버깅. 원인 &lt;code&gt;DB::DB()&lt;/code&gt; 서브 루틴이 실행 각 문이라고합니다. 또한 0x400과 같은 소스 코드 행을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4a4c07d14ccbabaacd2cac3e3e1dcd6526decdb6" translate="yes" xml:space="preserve">
          <source>Lines 2-4 acquire a city and country name. Line 5 looks to see if the country is already present as a key in the hash. If it's not, the program uses the &lt;code&gt;[]&lt;/code&gt; notation (&lt;a href=&quot;#Make-Rule-2&quot;&gt;&lt;b&gt;Make Rule 2&lt;/b&gt;&lt;/a&gt;) to manufacture a new, empty anonymous array of cities, and installs a reference to it into the hash under the appropriate key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6544069544ff400a2f96a13aacecf88aefcebba3" translate="yes" xml:space="preserve">
          <source>Lines 2-4 acquire a city and country name. Line 5 looks to see if the country is already present as a key in the hash. If it's not, the program uses the &lt;code&gt;[]&lt;/code&gt; notation (&lt;b&gt;Make Rule 2&lt;/b&gt;) to manufacture a new, empty anonymous array of cities, and installs a reference to it into the hash under the appropriate key.</source>
          <target state="translated">2-4 행은 도시와 국가 이름을 얻습니다. 5 행은 국가가 이미 해시의 키로 존재하는지 확인합니다. 그렇지 않은 경우 프로그램은 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용합니다 ( &lt;b&gt;규칙 2 작성).&lt;/b&gt; )을 비어있는 새 익명의 도시 배열을 작성하고 해당 키 아래의 해시에 참조를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="f9204249863f9ef26ff51a8eb193e8408a39e90b" translate="yes" xml:space="preserve">
          <source>Lines 2-7 are responsible for building the structure in the first place. Here they are again:</source>
          <target state="translated">2-7 행은 처음에 구조를 짓는 책임이 있습니다. 여기 다시 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de6cda1578fd7d9e7a9658f2b0c6b2f1938e7d0c" translate="yes" xml:space="preserve">
          <source>Lines are wrapped at &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; columns (default value: 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; should be set to the full width of your output device. In fact, every resulting line will have length of no more than &lt;code&gt;$columns - 1&lt;/code&gt; .</source>
          <target state="translated">줄은 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 열에 래핑됩니다 (기본값 : 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 는 출력 장치의 전체 너비로 설정해야합니다. 실제로 모든 결과 행의 길이는 &lt;code&gt;$columns - 1&lt;/code&gt; 이하 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="bdd8be9ac7f4d3de35a2d0dba7d82ca50f5c0336" translate="yes" xml:space="preserve">
          <source>Lines are wrapped at &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; columns (default value: 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; should be set to the full width of your output device. In fact, every resulting line will have length of no more than &lt;code&gt;$columns - 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b80c81ac338346fa6d5a46950a43da0e9261d9f" translate="yes" xml:space="preserve">
          <source>Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="translated">Unicode :: Collate를 통한 DUCET의 언어 조정</target>
        </trans-unit>
        <trans-unit id="911361fa28ffec535144574ef716816f8b8cd069" translate="yes" xml:space="preserve">
          <source>Link count not updated because hard links are not quite that hard (They are sort of half-way between hard and soft links). (AmigaOS)</source>
          <target state="translated">하드 링크는 그렇게 어렵지 않기 때문에 링크 수는 업데이트되지 않습니다 (하드 링크와 소프트 링크 사이의 중간 정도입니다). (AmigaOS)</target>
        </trans-unit>
        <trans-unit id="1bd9f440f54676f1bb94923dc077847ab746b4ad" translate="yes" xml:space="preserve">
          <source>Link dynamic extensions with AddressSanitizer. You must manually specify &lt;code&gt;-shared&lt;/code&gt; because using &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; will prevent Configure from setting a default value for &lt;code&gt;lddlflags&lt;/code&gt; , which usually contains &lt;code&gt;-shared&lt;/code&gt; (at least on Linux).</source>
          <target state="translated">동적 확장을 AddressSanitizer와 연결하십시오. &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; 를 사용하면 Configure에서 &lt;code&gt;lddlflags&lt;/code&gt; 의 기본값을 설정하지 못하게 되므로 수동으로 &lt;code&gt;-shared&lt;/code&gt; 를 지정해야합니다. 일반적으로 &lt;code&gt;-shared&lt;/code&gt; 를 포함합니다 (적어도 Linux에서는).</target>
        </trans-unit>
        <trans-unit id="8e4a85ad0592eae3d98b608b03a13168bab41ac1" translate="yes" xml:space="preserve">
          <source>Link dynamic extensions with AddressSanitizer. You must manually specify &lt;code&gt;-shared&lt;/code&gt; because using &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; will prevent Configure from setting a default value for &lt;code&gt;lddlflags&lt;/code&gt;, which usually contains &lt;code&gt;-shared&lt;/code&gt; (at least on Linux).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f974c23cae7ac7ab09ab4582a91560c7102a2b" translate="yes" xml:space="preserve">
          <source>Link the perl executable with AddressSanitizer.</source>
          <target state="translated">Perl 실행 파일을 AddressSanitizer와 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="41c90512ffda6347e72f72d0a6f190da9ca1b80a" translate="yes" xml:space="preserve">
          <source>Link this text to that manual page. E.g., &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를 해당 매뉴얼 페이지에 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da1dd85543ffc6fef88aec54ac7001cdb21f6577" translate="yes" xml:space="preserve">
          <source>Link this text to that section in that manual page. E.g., &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를 해당 매뉴얼 페이지의 해당 섹션에 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a893b38edbd5af20fcd220578252e31f67b32a6" translate="yes" xml:space="preserve">
          <source>Link this text to that section in this manual page. E.g., &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를이 매뉴얼 페이지의 해당 섹션에 연결하십시오. 예 : &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a75b0dcbc63f378ca4b7ba049d880c48c223d9a" translate="yes" xml:space="preserve">
          <source>Link to a Perl manual page (e.g., &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ). Note that &lt;code&gt;name&lt;/code&gt; should not contain spaces. This syntax is also occasionally used for references to Unix man pages, as in &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Perl 매뉴얼 페이지에 링크하십시오 (예 : &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ). 주의 &lt;code&gt;name&lt;/code&gt; 에 공백이 포함되지 않아야합니다. 이 구문은 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 에서처럼 Unix 매뉴얼 페이지에 대한 참조에도 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8989d4395dabd5c3aa39385b5b23f283a370aec" translate="yes" xml:space="preserve">
          <source>Link to a Perl manual page (e.g., &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt;). Note that &lt;code&gt;name&lt;/code&gt; should not contain spaces. This syntax is also occasionally used for references to Unix man pages, as in &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebcbb26d8410e15ec0a3bf942439d1fa6f0dc0e" translate="yes" xml:space="preserve">
          <source>Link to a section in other manual page. E.g., &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">다른 매뉴얼 페이지의 섹션으로 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4be78347858c96ca4af009ad12e83b583efec3" translate="yes" xml:space="preserve">
          <source>Link to a section in this manual page. E.g., &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 매뉴얼 페이지의 섹션으로 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c060793b58b5034337a483732320e10661d5f930" translate="yes" xml:space="preserve">
          <source>Linker Problems in Irix</source>
          <target state="translated">Irix의 링커 문제</target>
        </trans-unit>
        <trans-unit id="91ca4118a066d9e15d3000d362f4707600eb85a4" translate="yes" xml:space="preserve">
          <source>Linking with C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632c0116497fe7ec21df3b6015a06dceee2c2e46" translate="yes" xml:space="preserve">
          <source>Links to an absolute URL. For example, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">절대 URL에 연결합니다. 예를 들어 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70dabca050ab89452a19f7ca28b4c05e928c7006" translate="yes" xml:space="preserve">
          <source>Links to an absolute URL. For example, &lt;code&gt;L&amp;lt;http://www.perl.org/&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;The Perl Home Page|http://www.perl.org/&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="83bd0efc45cc0fd69905b50d3c8ace24dff4bd31" translate="yes" xml:space="preserve">
          <source>Linux (x86, ARM, IA64)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec4f23be8f3036b01885e23831c9d8422f8e25f" translate="yes" xml:space="preserve">
          <source>Linux Magazine</source>
          <target state="translated">리눅스 매거진</target>
        </trans-unit>
        <trans-unit id="2187306118c639d0411d3a1f0eea679c435e121f" translate="yes" xml:space="preserve">
          <source>Linux-specific shortcuts to specify the &lt;code&gt;O_NONBLOCK&lt;/code&gt; and &lt;code&gt;FD_CLOEXEC&lt;/code&gt; flags during a &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; 호출 중에 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 및 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그 를 지정하기위한 Linux 특정 단축키 .</target>
        </trans-unit>
        <trans-unit id="27bd3b3373ebdc99eec5274a7f58493e52c3e65c" translate="yes" xml:space="preserve">
          <source>Linux-specific shortcuts to specify the &lt;code&gt;O_NONBLOCK&lt;/code&gt; and &lt;code&gt;FD_CLOEXEC&lt;/code&gt; flags during a &lt;code&gt;socket(2)&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaedd94529deff9e35130dfc5ae5796d73c29a7" translate="yes" xml:space="preserve">
          <source>LinuxThreads is now obsolete on Linux, and caching &lt;code&gt;getpid()&lt;/code&gt; like this made embedding perl unnecessarily complex (since you'd have to manually update the value of $$), so now &lt;code&gt;$$&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; will always return the same values as the underlying C library.</source>
          <target state="translated">LinuxThreads는 이제 Linux에서 더 이상 사용되지 않으며, 이와 같이 &lt;code&gt;getpid()&lt;/code&gt; 캐싱 하면 perl을 불필요하게 복잡하게 만들 수 있습니다 ($ $$의 값을 수동으로 업데이트해야하기 때문에) 이제 &lt;code&gt;$$&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 는 항상 같은 값을 반환합니다 기본 C 라이브러리</target>
        </trans-unit>
        <trans-unit id="dc8491ab221544187737048d61360d36010b4180" translate="yes" xml:space="preserve">
          <source>LinuxThreads is now obsolete on Linux, and caching &lt;code&gt;getpid()&lt;/code&gt; like this made embedding perl unnecessarily complex (since you'd have to manually update the value of $$), so now &lt;code&gt;$$&lt;/code&gt; and &lt;code&gt;getppid()&lt;/code&gt; will always return the same values as the underlying C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="29c9d470de128561132f93d1517a546cc93f2ef7" translate="yes" xml:space="preserve">
          <source>List (default all) actions, breakpoints and watch expressions</source>
          <target state="translated">작업, 중단 점 및 감시 식 나열 (기본 전체)</target>
        </trans-unit>
        <trans-unit id="4f52dc39b8b924455cea92e15110632fa2352d9b" translate="yes" xml:space="preserve">
          <source>List &lt;code&gt;incr+1&lt;/code&gt; lines starting at &lt;code&gt;min&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 에서 시작하는 &lt;code&gt;incr+1&lt;/code&gt; 줄을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="1e2df285394e85b16a4d8402b790e30140168156" translate="yes" xml:space="preserve">
          <source>List &lt;code&gt;incr+1&lt;/code&gt; lines starting at &lt;code&gt;min&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605938e2092b0e1418a4f6b86421f6d6aadd1b04" translate="yes" xml:space="preserve">
          <source>List Operators (Rightward)</source>
          <target state="translated">연산자 목록 (오른쪽)</target>
        </trans-unit>
        <trans-unit id="ea9c7040ec8c47c48d227dc0186264691d25d357" translate="yes" xml:space="preserve">
          <source>List a single line.</source>
          <target state="translated">한 줄을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="43aa9239459d3ee11976e9110444e7fe09843446" translate="yes" xml:space="preserve">
          <source>List all build directories of distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;install_tested&lt;/code&gt; .</source>
          <target state="translated">성공적으로 테스트되었지만 아직 설치되지 않은 배포판의 모든 빌드 디렉토리를 나열하십시오. &lt;code&gt;install_tested&lt;/code&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5da3c7994a3d61d34d9ca024ec7ac9503eb70a17" translate="yes" xml:space="preserve">
          <source>List all installed modules with their versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370cf490cd3daa93894252ec5158b9c077c837f2" translate="yes" xml:space="preserve">
          <source>List assignment in scalar context returns the number of elements produced by the expression on the right side of the assignment:</source>
          <target state="translated">스칼라 컨텍스트의 목록 할당은 할당의 오른쪽에있는 표현식으로 생성 된 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="45a5a84ab7f0560a41223626f7533a814734e050" translate="yes" xml:space="preserve">
          <source>List constants</source>
          <target state="translated">상수 목록</target>
        </trans-unit>
        <trans-unit id="55d8dbd99ddbc695154ff187f15da85365e9e00f" translate="yes" xml:space="preserve">
          <source>List constants are lists, not arrays. To index or slice them, they must be placed in parentheses.</source>
          <target state="translated">리스트 상수는 배열이 아니라리스트입니다. 색인을 작성하거나 슬라이스하려면 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9230863aaf9811a194bc857bc0390c6326f13d9" translate="yes" xml:space="preserve">
          <source>List constants are not inlined unless you are using Perl v5.20 or higher. In v5.20 or higher, they are still not read-only, but that may change in future versions.</source>
          <target state="translated">Perl v5.20 이상을 사용하지 않으면 목록 상수가 인라인되지 않습니다. v5.20 이상에서는 여전히 읽기 전용이 아니지만 향후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9c4f2773006f355714dc08c4a64f23012ee969" translate="yes" xml:space="preserve">
          <source>List directories as they are searched</source>
          <target state="translated">검색된 디렉토리 나열</target>
        </trans-unit>
        <trans-unit id="0865484d5c94ce11961bf51a22181df567484e88" translate="yes" xml:space="preserve">
          <source>List first window of lines from subroutine.</source>
          <target state="translated">서브 루틴의 첫 번째 라인 창을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="31c6b16c6806f38a9abbe22903640ceb79a76b77" translate="yes" xml:space="preserve">
          <source>List form of piped open not implemented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ff7a57a5555c3820cb313b589ff3e43f5801b3" translate="yes" xml:space="preserve">
          <source>List lines &lt;code&gt;min&lt;/code&gt; through &lt;code&gt;max&lt;/code&gt; . &lt;code&gt;l -&lt;/code&gt; is synonymous to &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 행 부터 &lt;code&gt;max&lt;/code&gt; 행 까지 나열하십시오 . &lt;code&gt;l -&lt;/code&gt; 에 동의어이다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6413580d4bb0dff3a638f87f617274c7d3fa5ba" translate="yes" xml:space="preserve">
          <source>List lines &lt;code&gt;min&lt;/code&gt; through &lt;code&gt;max&lt;/code&gt;. &lt;code&gt;l -&lt;/code&gt; is synonymous to &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2f29a334d30972bc8a9045f68baae0dc3ec6d8" translate="yes" xml:space="preserve">
          <source>List next window of lines.</source>
          <target state="translated">다음 줄 창을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">의 목록</target>
        </trans-unit>
        <trans-unit id="f96221500e5dff9b2e5b2d0d52441200d3fe59bd" translate="yes" xml:space="preserve">
          <source>List of CHECK values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2bf307cdc3add3b560b3cf9c6d9638160226a" translate="yes" xml:space="preserve">
          <source>List of _CHECK_ values</source>
          <target state="translated">_CHECK_ 값 목록</target>
        </trans-unit>
        <trans-unit id="3fbb95646db607d6a530d90010130a90b221c352" translate="yes" xml:space="preserve">
          <source>List of four elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e3128876d62127f71da94d3596564663a283a7" translate="yes" xml:space="preserve">
          <source>List of handlers that have been registered.</source>
          <target state="translated">등록 된 핸들러 목록입니다.</target>
        </trans-unit>
        <trans-unit id="942be8ea6b09c5850208d901ada25608760abbb7" translate="yes" xml:space="preserve">
          <source>List of libraries that need to be linked with when linking a perl binary which includes this extension. Only those libraries that actually exist are included. These are written to a file and used when linking perl.</source>
          <target state="translated">이 확장을 포함하는 perl 바이너리를 링크 할 때 링크되어야하는 라이브러리 목록. 실제로 존재하는 라이브러리 만 포함됩니다. 이것들은 파일에 쓰여지고 perl을 연결할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="25c88a0a5acb1948d9832032688b4c20061ebe55" translate="yes" xml:space="preserve">
          <source>List of lines in currently loaded file.</source>
          <target state="translated">현재로드 된 파일의 행 목록</target>
        </trans-unit>
        <trans-unit id="e2c751f0916c7f646852ece1bcfc81eae8d05b8f" translate="yes" xml:space="preserve">
          <source>List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long string or an array containing all object files, e.g. &quot;tkpBind.o tkpButton.o tkpCanvas.o&quot; or [&quot;tkpBind.o&quot;, &quot;tkpButton.o&quot;, &quot;tkpCanvas.o&quot;]</source>
          <target state="translated">객체 파일 목록의 기본값은 '$ (BASEEXT) $ (OBJ_EXT)'이지만 긴 문자열이거나 모든 객체 파일을 포함하는 배열 일 수 있습니다 (예 : &quot;tkpBind.o tkpButton.o tkpCanvas.o&quot;또는 [ &quot;tkpBind.o) &quot;,&quot;tkpButton.o &quot;,&quot;tkpCanvas.o &quot;]</target>
        </trans-unit>
        <trans-unit id="5c1db3ac864f059bce7875da034cf8c723ca64e1" translate="yes" xml:space="preserve">
          <source>List of those libraries that are needed but can be linked in dynamically at run time on this platform. SunOS/Solaris does not need this because ld records the information (from LDLOADLIBS) into the object file. This list is used to create a .bs (bootstrap) file.</source>
          <target state="translated">이 플랫폼에서 필요하지만 런타임에 동적으로 링크 될 수있는 라이브러리 목록. ld는 LDLOADLIBS의 정보를 객체 파일에 기록하므로 SunOS / Solaris는이를 필요로하지 않습니다. 이 목록은 .bs (부트 스트랩) 파일을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a0cf49d555f62d3d4e052b6541ec31f30e51960" translate="yes" xml:space="preserve">
          <source>List of those libraries which can or must be linked into the shared library when created using ld. These may be static or dynamic libraries. LD_RUN_PATH is a colon separated list of the directories in LDLOADLIBS. It is passed as an environment variable to the process that links the shared library.</source>
          <target state="translated">ld를 사용하여 작성 될 때 공유 라이브러리에 링크 될 수 있거나 링크되어야하는 라이브러리 목록. 이들은 정적 또는 동적 라이브러리 일 수 있습니다. LD_RUN_PATH는 LDLOADLIBS에있는 콜론으로 구분 된 디렉토리 목록입니다. 공유 라이브러리를 링크하는 프로세스에 환경 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ebae2310224ffad36ada7ef466a7460f111ae936" translate="yes" xml:space="preserve">
          <source>List of three arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be97ad6178a15f3564cecdb6dad31b0f188dfe5e" translate="yes" xml:space="preserve">
          <source>List of three elements. Second is an array reference; third is a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc4309268bf3b8e9ff25ca0646ecdbee8a86829" translate="yes" xml:space="preserve">
          <source>List of two elements: &lt;code&gt;typemap&lt;/code&gt; element from &lt;code&gt;%args&lt;/code&gt;; current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2868b38546ebc5d5d8fcc48449cbafe99e0ffc2a" translate="yes" xml:space="preserve">
          <source>List out all pre-prompt Perl command actions.</source>
          <target state="translated">모든 사전 프롬프트 Perl 명령 조치를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b2fda16ba9c5deaf514c003911417714fab1f6a2" translate="yes" xml:space="preserve">
          <source>List out post-prompt Perl command actions.</source>
          <target state="translated">프롬프트 후 Perl 명령 조치를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b85c9a7b9160438294dae5b78f69ab7f0a89edb4" translate="yes" xml:space="preserve">
          <source>List out pre-prompt debugger commands.</source>
          <target state="translated">사전 프롬프트 디버거 명령을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c433826fb0a01d3298adbd1cec75ac79e366fe70" translate="yes" xml:space="preserve">
          <source>List previous window of lines.</source>
          <target state="translated">이전 줄 창을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6828bea1ce4a116f7cab52f1ff715d22eb63c991" translate="yes" xml:space="preserve">
          <source>List subroutine names [not] matching the regex.</source>
          <target state="translated">정규식과 일치하지 않는 서브 루틴 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="080ba82727d1a06b5322db16c03b125c4027029d" translate="yes" xml:space="preserve">
          <source>List the modules by the specified authors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d9bedea128205ac0ccf6ba46b2275b7e0355dc" translate="yes" xml:space="preserve">
          <source>List value constructors</source>
          <target state="translated">값 생성자</target>
        </trans-unit>
        <trans-unit id="3b83ab8a9c9e9daa0f3c240465a14ac3cfec98b6" translate="yes" xml:space="preserve">
          <source>List values are denoted by separating individual values by commas (and enclosing the list in parentheses where precedence requires it):</source>
          <target state="translated">목록 값은 개별 값을 쉼표로 구분하여 표시합니다 (우선 순위가 필요한 경우 목록을 괄호로 묶음).</target>
        </trans-unit>
        <trans-unit id="9c332d7d437db4bb1a089aef08dedde1d03aa848" translate="yes" xml:space="preserve">
          <source>List values in scalar context</source>
          <target state="translated">스칼라 컨텍스트에서 값 나열</target>
        </trans-unit>
        <trans-unit id="3e21f245885fcb8d2afb9ad390e31a12b2893368" translate="yes" xml:space="preserve">
          <source>List which methods may be called on the result of the evaluated expression. The expression may evaluated to a reference to a blessed object, or to a package name.</source>
          <target state="translated">평가 된 표현식의 결과에서 호출 할 수있는 메소드를 나열하십시오. 이 표현은 복된 대상 또는 패키지 이름에 대한 참조로 평가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8403bab2922ebc2678fad6cf5cb327231181154" translate="yes" xml:space="preserve">
          <source>List::Util</source>
          <target state="translated">List::Util</target>
        </trans-unit>
        <trans-unit id="0553bce08d5ad663737a32d66e461a6fde4d42cc" translate="yes" xml:space="preserve">
          <source>List::Util - A selection of general-utility list subroutines</source>
          <target state="translated">List :: Util-일반 유틸리티 목록 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="e6ae9327a79eb9d0433ed0271e4debca709ad198" translate="yes" xml:space="preserve">
          <source>List::Util::XS</source>
          <target state="translated">List::Util::XS</target>
        </trans-unit>
        <trans-unit id="6a577f2f652a9865e261b6b1b9108f10eb35a6b7" translate="yes" xml:space="preserve">
          <source>List::Util::XS - Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List :: Util :: XS-List :: Util이 C 컴파일러로 컴파일되었는지 표시</target>
        </trans-unit>
        <trans-unit id="577f684095ccbc8608cf104c7d53ed608fc27e62" translate="yes" xml:space="preserve">
          <source>Listed below are functions that are either completely unimplemented or else have been implemented differently on various platforms. Following each description will be, in parentheses, a list of platforms that the description applies to.</source>
          <target state="translated">아래에는 완전히 구현되지 않았거나 다양한 플랫폼에서 다르게 구현 된 기능이 나열되어 있습니다. 각 설명 다음에는 설명이 적용되는 플랫폼 목록이 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4785b15f1934e1c153e7966e7a875d6c72382735" translate="yes" xml:space="preserve">
          <source>Listed below are functions that are either completely unimplemented or else have been implemented differently on various platforms. Preceding each description will be, in parentheses, a list of platforms that the description applies to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="484fc3879bbb2d1bc964407cad68611698ffceb6" translate="yes" xml:space="preserve">
          <source>Listen =&amp;gt; INT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dea679b659a4bf77b36d5e329bc16ce43947db3" translate="yes" xml:space="preserve">
          <source>Listen should be an integer value or left unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2100cb1ce0771ebf5c66d34af2b3109940abd61" translate="yes" xml:space="preserve">
          <source>Listing available encodings</source>
          <target state="translated">사용 가능한 인코딩 나열</target>
        </trans-unit>
        <trans-unit id="0827ddb4ed49430cfb1658042c94b816fe2859f3" translate="yes" xml:space="preserve">
          <source>Lists all available encodings, one per line, in case-insensitive order. Note that only the canonical names are listed; many aliases exist. For example, the names are case-insensitive, and many standard and common aliases work, such as &quot;latin1&quot; for &quot;ISO-8859-1&quot;, or &quot;ibm850&quot; instead of &quot;cp850&quot;, or &quot;winlatin1&quot; for &quot;cp1252&quot;. See &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt; for a full discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd09e23888b88d8b373ca4d91ed87f3200a2d3a8" translate="yes" xml:space="preserve">
          <source>Lists all available encodings, one per line, in case-insensitive order. Note that only the canonical names are listed; many aliases exist. For example, the names are case-insensitive, and many standard and common aliases work, such as &quot;latin1&quot; for &quot;ISO-8859-1&quot;, or &quot;ibm850&quot; instead of &quot;cp850&quot;, or &quot;winlatin1&quot; for &quot;cp1252&quot;. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for a full discussion.</source>
          <target state="translated">대 / 소문자를 구분하지 않고 사용 가능한 모든 인코딩을 한 줄에 하나씩 나열합니다. 표준 이름 만 나열됩니다. 많은 별칭이 존재합니다. 예를 들어, 이름은 대소 문자를 구분하지 않으며 &quot;ISO-8859-1&quot;의 경우 &quot;latin1&quot;또는 &quot;cp850&quot;대신 &quot;ibm850&quot;또는 &quot;cp1252&quot;의 &quot;winlatin1&quot;과 같은 많은 표준 및 공통 별명이 작동합니다. . 자세한 내용은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4e9b933aa47588e5dca2e5d37752f783428eced" translate="yes" xml:space="preserve">
          <source>Lists known issues and incompatibilities; &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">알려진 문제와 비 호환성을 나열합니다. &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="974b5b0f1238cd291d1764b895cc33d03520382a" translate="yes" xml:space="preserve">
          <source>Lists known issues and incompatibilities; &lt;code&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b97602e24bdf80cc94582bec0e02d773290ecc" translate="yes" xml:space="preserve">
          <source>Lists may be assigned to only when each element of the list is itself legal to assign to:</source>
          <target state="translated">목록의 각 요소가 다음과 같이 합법적 인 경우에만 목록을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a2888cd48d3f7aa2e98cd01aee025fae061e84" translate="yes" xml:space="preserve">
          <source>Literal ASCII TAB characters are now allowed in strings (and treated as &lt;code&gt;\t&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0213917f82ae95d80bb5989c7abf1f8ddda65a97" translate="yes" xml:space="preserve">
          <source>Literal conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527da73e406ed03ebcb72acc86b11111c4a02fcb" translate="yes" xml:space="preserve">
          <source>Literal uses of &lt;code&gt;{&lt;/code&gt; were deprecated in Perl 5.20, and some uses of it started to give deprecation warnings since. These cases were made fatal in Perl 5.26. Due to an oversight, not all cases of a use of a literal &lt;code&gt;{&lt;/code&gt; got a deprecation warning. Some cases started warning in Perl 5.26, and were made fatal in Perl 5.30. Other cases started in Perl 5.28, and were made fatal in 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5147c26642d830ab230197606d4cf605ea045572" translate="yes" xml:space="preserve">
          <source>Literal vertical space in [] is illegal except under /x in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a788cee27d549015a0786732c662e05cdd7567" translate="yes" xml:space="preserve">
          <source>Lithuania</source>
          <target state="translated">Lithuania</target>
        </trans-unit>
        <trans-unit id="91575e88330ca0a393b09df24c2f9572b830580f" translate="yes" xml:space="preserve">
          <source>Ll</source>
          <target state="translated">Ll</target>
        </trans-unit>
        <trans-unit id="ddcb77ff769ea54ca622848f6bedd4004fa4f4fa" translate="yes" xml:space="preserve">
          <source>Load</source>
          <target state="translated">Load</target>
        </trans-unit>
        <trans-unit id="7006eb18a426109e42c387f4ebcfd765f549c2c8" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;local::lib&lt;/code&gt; (think like &lt;code&gt;-I&lt;/code&gt; for loading lib paths). Too bad &lt;code&gt;-l&lt;/code&gt; was already taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec750aae1f96446e6d4c2da3ed090454e5eb47c" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;&quot;MATH LIBRARY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb2a396182dae27999fc6c1e32de77266a8eaa5" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt;.</source>
          <target state="translated">다른 수학 라이브러리를로드하십시오 ( &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="97f3b50d057eea8062f2d58a28647a93d5cccf56" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#Math-Library&quot;&gt;&quot;Math Library&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a359a67f4a6d92b34e91186041854ab36b846b" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#Math-Library&quot;&gt;Math Library&lt;/a&gt;.</source>
          <target state="translated">다른 math 라이브러리를로드하십시오 ( &lt;a href=&quot;#Math-Library&quot;&gt;Math Library&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="26c9c83eb2148dde20d87505b058099c18e18cdd" translate="yes" xml:space="preserve">
          <source>Load a harness replacement class.</source>
          <target state="translated">하네스 교체 등급을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="3ab8a70aafed206e446c89069a6d6fa487286375" translate="yes" xml:space="preserve">
          <source>Load functions only on demand</source>
          <target state="translated">요청시에만 기능로드</target>
        </trans-unit>
        <trans-unit id="1a6bf14720b01e30066247880d6ebc3b8752469c" translate="yes" xml:space="preserve">
          <source>Load subroutines only on demand</source>
          <target state="translated">요청시에만 서브 루틴로드</target>
        </trans-unit>
        <trans-unit id="d792f29bac65ac823df5b7bb2984ae1cc96bc863" translate="yes" xml:space="preserve">
          <source>Load the C Fcntl.h defines</source>
          <target state="translated">C Fcntl.h 정의로드</target>
        </trans-unit>
        <trans-unit id="41ca4f17e3678d8fa4513a23c57b7eb4caf19350" translate="yes" xml:space="preserve">
          <source>Load the file that has the CPAN configuration data. This should have the same format as the standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240fa313380982dac95b53cefb0c75077c026845" translate="yes" xml:space="preserve">
          <source>Load the state from a file</source>
          <target state="translated">파일에서 상태로드</target>
        </trans-unit>
        <trans-unit id="15cac79f7c6e29d135cac8ed345f5ee74ad107b9" translate="yes" xml:space="preserve">
          <source>Load various IO modules</source>
          <target state="translated">다양한 IO 모듈로드</target>
        </trans-unit>
        <trans-unit id="59ee7110b16f2ee9279e975045a71b3b2753da6e" translate="yes" xml:space="preserve">
          <source>LoadFile</source>
          <target state="translated">LoadFile</target>
        </trans-unit>
        <trans-unit id="9cd272bfb77c57c025d780a7adea2d2f4a39e607" translate="yes" xml:space="preserve">
          <source>Loading DLLs and ordinals in DLLs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9030f4b47aa2abda4199dcc7ac6f1cb72c9d6947" translate="yes" xml:space="preserve">
          <source>Loads &lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt;, instantiates an object, and dumps it as an embeddable typemap for use directly in your XS file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478aa4ede7f109d8fe9ce74fc47e542819bd58d3" translate="yes" xml:space="preserve">
          <source>Loads Perl library from &lt;code&gt;$exedir/../dll/lib/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$exedir/../dll/lib/&lt;/code&gt; 에서 Perl 라이브러리를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="7a90cb96849f4ba39ef789f1926fb83b5216a75c" translate="yes" xml:space="preserve">
          <source>Loads a dynamic link library into memory and returns its module handle. This handle can be used with Win32::GetProcAddress() and Win32::FreeLibrary(). This function is deprecated. Use the Win32::API module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5210c4cd9f4652e7e267673947f320fe973e2f" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions to the specified package.</source>
          <target state="translated">지정된 모듈을로드하고 기본 기능을 지정된 패키지로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="27e6bb733433394f480bba5733da627a3f3f2045" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions.</source>
          <target state="translated">지정된 모듈을로드하고 기본 기능을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0912e26f46f2862f9bc8f741f795bbefe5ccdd67" translate="yes" xml:space="preserve">
          <source>Loads a specified module to the specified package.</source>
          <target state="translated">지정된 모듈을 지정된 패키지로로드합니다.</target>
        </trans-unit>
        <trans-unit id="6ec299bdf7d010c1eee08526d7bd0161603d96f6" translate="yes" xml:space="preserve">
          <source>Loads a specified module.</source>
          <target state="translated">지정된 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="e32cb3524fbd8048df24f387ab1d261efd4fc528" translate="yes" xml:space="preserve">
          <source>Loads the DLL LIBRARYNAME and calls the function DllRegisterServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb5e0e921899c7d9aa0924124cdcb6c8851e055" translate="yes" xml:space="preserve">
          <source>Loads the DLL LIBRARYNAME and calls the function DllUnregisterServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194a22a082c50fda80d3d163aa9acda90d655677" translate="yes" xml:space="preserve">
          <source>Loads the handler classes defined in &lt;a href=&quot;#config&quot;&gt;&quot;config&quot;&lt;/a&gt;. For example, given a config:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a312f5b131e98b974541ced8733bc202310a2a5" translate="yes" xml:space="preserve">
          <source>Loads the handler classes defined in &lt;a href=&quot;#config&quot;&gt;config&lt;/a&gt;. For example, given a config:</source>
          <target state="translated">&lt;a href=&quot;#config&quot;&gt;config에&lt;/a&gt; 정의 된 핸들러 클래스를로드합니다 . 예를 들어, 구성이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="2288e3df6687abb6b74ab409c03ac48535ed3150" translate="yes" xml:space="preserve">
          <source>Loads the module whose name is pointed to by the string part of &lt;code&gt;name&lt;/code&gt;. Note that the actual module name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead of &quot;Foo/Bar.pm&quot;. ver, if specified and not NULL, provides version semantics similar to &lt;code&gt;use Foo::Bar VERSION&lt;/code&gt;. The optional trailing arguments can be used to specify arguments to the module's &lt;code&gt;import()&lt;/code&gt; method, similar to &lt;code&gt;use Foo::Bar VERSION LIST&lt;/code&gt;; their precise handling depends on the flags. The flags argument is a bitwise-ORed collection of any of &lt;code&gt;PERL_LOADMOD_DENY&lt;/code&gt;, &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt;, or &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; (or 0 for no flags).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6dda1ab28094112405a17ad65b1a4c1c089d63" translate="yes" xml:space="preserve">
          <source>Loads the module whose name is pointed to by the string part of name. Note that the actual module name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead of &quot;Foo/Bar.pm&quot;. flags can be any of PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS (or 0 for no flags). ver, if specified and not NULL, provides version semantics similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; . The optional trailing SV* arguments can be used to specify arguments to the module's import() method, similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; . They must be terminated with a final NULL pointer. Note that this list can only be omitted when the PERL_LOADMOD_NOIMPORT flag has been used. Otherwise at least a single NULL pointer to designate the default import list is required.</source>
          <target state="translated">name의 문자열 부분에서 이름이 가리키는 모듈을로드합니다. 파일 이름이 아닌 실제 모듈 이름을 지정해야합니다. 예 : &quot;Foo / Bar.pm&quot;대신 &quot;Foo :: Bar&quot; 플래그는 PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT 또는 PERL_LOADMOD_IMPORT_OPS (또는 플래그가없는 경우 0) 중 하나 일 수 있습니다. ver은 NULL이 아닌 지정되면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 유사한 버전 의미를 제공합니다 . 선택적 후행 SV * 인수는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 유사하게 모듈의 import () 메소드에 인수를 지정하는 데 사용할 수 있습니다 . 최종 NULL 포인터로 종료해야합니다. PERL_LOADMOD_NOIMPORT 플래그가 사용 된 경우에만이 목록을 생략 할 수 있습니다. 그렇지 않으면 기본 가져 오기 목록을 지정하기 위해 최소한 하나의 NULL 포인터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9af5b63a9cb9853b15da20ea4f2739623dc82021" translate="yes" xml:space="preserve">
          <source>Loc.U</source>
          <target state="translated">Loc.U</target>
        </trans-unit>
        <trans-unit id="2c161b9d2652a245b17c473e85af35d98c964e27" translate="yes" xml:space="preserve">
          <source>Loc_ar.U</source>
          <target state="translated">Loc_ar.U</target>
        </trans-unit>
        <trans-unit id="40cd835b717a79093cb71f794169679d3511a012" translate="yes" xml:space="preserve">
          <source>Loc_sed.U</source>
          <target state="translated">Loc_sed.U</target>
        </trans-unit>
        <trans-unit id="b62225661a9783f7a6a2c6e6f754c699e4dfbc8e" translate="yes" xml:space="preserve">
          <source>Local Locales</source>
          <target state="translated">지역 로케일</target>
        </trans-unit>
        <trans-unit id="00b7d8ac28ed6d0a7686172cc54cac83dde1640a" translate="yes" xml:space="preserve">
          <source>Local configuration data for libnet</source>
          <target state="translated">libnet의 로컬 구성 데이터</target>
        </trans-unit>
        <trans-unit id="2073176912b2b8b08756b78673e90f32f9412f5a" translate="yes" xml:space="preserve">
          <source>Local hosts should normally respond to pings within milliseconds. However, on a very congested network it may take up to 3 seconds or longer to receive an echo packet from the remote host. If the timeout is set too low under these conditions, it will appear that the remote host is not reachable (which is almost the truth).</source>
          <target state="translated">로컬 호스트는 일반적으로 밀리 초 내에 핑에 응답해야합니다. 그러나 매우 혼잡 한 네트워크에서는 원격 호스트에서 에코 패킷을 수신하는 데 최대 3 초 이상 걸릴 수 있습니다. 이러한 조건에서 시간 초과가 너무 낮게 설정되면 원격 호스트에 도달 할 수없는 것 같습니다 (거의 사실임).</target>
        </trans-unit>
        <trans-unit id="5ce134969fa4b38910928473dcd30b211050ffe0" translate="yes" xml:space="preserve">
          <source>Local patches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c690298b945c1b37cc5a68671d9b773af108fb2" translate="yes" xml:space="preserve">
          <source>Local settings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b6cc762cf095afa6ac2b3f63960344e064751c" translate="yes" xml:space="preserve">
          <source>LocalAddr =&amp;gt; STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3479965474a90e55723b0f25860802c53406e91d" translate="yes" xml:space="preserve">
          <source>LocalAddrInfo =&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21dabe6c778984c0b6509601202090746e803410" translate="yes" xml:space="preserve">
          <source>LocalHost =&amp;gt; STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9b0a319772622c356126ecbc602688d6563804" translate="yes" xml:space="preserve">
          <source>LocalPort</source>
          <target state="translated">LocalPort</target>
        </trans-unit>
        <trans-unit id="0b1eb8a4f4bc001c793e0eea29e95b79014c3314" translate="yes" xml:space="preserve">
          <source>LocalPort =&amp;gt; STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e824d201d4911c9432bae5428ad07c94b3eaabb9" translate="yes" xml:space="preserve">
          <source>LocalService =&amp;gt; STRING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d14f2f76fdd1296a6f5facde16712babc39964d" translate="yes" xml:space="preserve">
          <source>Locale '%s' contains (at least) the following characters which have unexpected meanings: %s The Perl program will use the expected meanings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0705df55ca759471ac9bb2feda1c0edcd06beb2b" translate="yes" xml:space="preserve">
          <source>Locale '%s' may not work well.%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d6a411ea768d6e339737cbc631007347c4656b" translate="yes" xml:space="preserve">
          <source>Locale is not completely independent. The</source>
          <target state="translated">로케일은 완전히 독립적이지 않습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2ecddee9e3454bdf482ac7866a6d45e31677a35b" translate="yes" xml:space="preserve">
          <source>Locale-aware XS code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d1183f1e4f233c0975643c2ef4f71a04349e2" translate="yes" xml:space="preserve">
          <source>Locale-related functions and macros</source>
          <target state="translated">로케일 관련 기능 및 매크로</target>
        </trans-unit>
        <trans-unit id="e8ffa7590c272791934be71fefca2983045527a4" translate="yes" xml:space="preserve">
          <source>Locale/*.pl</source>
          <target state="translated">Locale/*.pl</target>
        </trans-unit>
        <trans-unit id="1f8d3cc6a62e48187b6914a4e521248e770e765b" translate="yes" xml:space="preserve">
          <source>Locale::Country</source>
          <target state="translated">Locale::Country</target>
        </trans-unit>
        <trans-unit id="711ea7f4d30a8250ee3539542d2d19015e5ecdec" translate="yes" xml:space="preserve">
          <source>Locale::Country - standard codes for country identification</source>
          <target state="translated">로캘 :: 국가-국가 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="745a3f2e63c8527b20fd7a0effbd2a4f6ce52b10" translate="yes" xml:space="preserve">
          <source>Locale::Currency</source>
          <target state="translated">Locale::Currency</target>
        </trans-unit>
        <trans-unit id="c9d7708330810bdeae6d8e6f009ab34981fb3578" translate="yes" xml:space="preserve">
          <source>Locale::Currency - standard codes for currency identification</source>
          <target state="translated">로캘 :: 통화-통화 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a2f93f9cc8bf81f232cf25c9d6170a176bd3c8f2" translate="yes" xml:space="preserve">
          <source>Locale::Language</source>
          <target state="translated">Locale::Language</target>
        </trans-unit>
        <trans-unit id="cbd3f9670295ab004a97a8799e46f114e838f7c9" translate="yes" xml:space="preserve">
          <source>Locale::Language - standard codes for language identification</source>
          <target state="translated">로캘 :: 언어-언어 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a9d8403dd9e14d9c4a74e42c449f4f4083d77a9b" translate="yes" xml:space="preserve">
          <source>Locale::Maketext</source>
          <target state="translated">Locale::Maketext</target>
        </trans-unit>
        <trans-unit id="58f6640492c0aec7031aee510f4ce0bcac4b2a22" translate="yes" xml:space="preserve">
          <source>Locale::Maketext - framework for localization</source>
          <target state="translated">Locale :: Maketext-현지화를위한 프레임 워크</target>
        </trans-unit>
        <trans-unit id="e28b946d05a8b6576abf4d9a367dd68f9175de8e" translate="yes" xml:space="preserve">
          <source>Locale::Maketext does not use any special syntax to differentiate bracket notation methods from normal class or object methods. This design makes it vulnerable to format string attacks whenever it is used to process strings provided by untrusted users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b3c0ab0595b5cdd83722214636b337ad110e39" translate="yes" xml:space="preserve">
          <source>Locale::Maketext does support blacklist and whitelist functionality to limit which methods may be called as bracket notation methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffc03bfc5c484b62d9372e1420bdf253f5b3f52" translate="yes" xml:space="preserve">
          <source>Locale::Maketext offers a variety of methods, which fall into three categories:</source>
          <target state="translated">Locale :: Maketext는 다음과 같은 세 가지 범주로 분류되는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0376cece04f73d6cbbeda92b6c96963d0c327dc4" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Cookbook</source>
          <target state="translated">Locale::Maketext::Cookbook</target>
        </trans-unit>
        <trans-unit id="e7d10311ab56423a10a6401a972e219ed34731ef" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Cookbook - recipes for using Locale::Maketext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5723d6c0c42ee05086667e38fd4249fe7082e8c" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts</source>
          <target state="translated">Locale::Maketext::Guts</target>
        </trans-unit>
        <trans-unit id="63bea57dac9566b0aa40481ae087dc206e13e8ee" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale :: Maketext :: Guts-로케일 :: Maketext utf8 코드를로드하기 위해 사용되지 않는 모듈</target>
        </trans-unit>
        <trans-unit id="b14392dcdae7ce47ee917b41b3e73f1a3b72f5e1" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader</source>
          <target state="translated">Locale::Maketext::GutsLoader</target>
        </trans-unit>
        <trans-unit id="9810a1053985ebcf2f9b5544107826a653c00a65" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale :: Maketext :: GutsLoader-더 이상 사용되지 않는 로케일 :: Maketext utf8 코드로드 모듈</target>
        </trans-unit>
        <trans-unit id="a239b132192c48779d9a0ee403ad81c93ab75902" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple</source>
          <target state="translated">Locale::Maketext::Simple</target>
        </trans-unit>
        <trans-unit id="a942c8cd15bd2125fe42db2a486e9feebf1cfa35" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple - Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale :: Maketext :: Simple-Locale :: Maketext :: Lexicon에 대한 간단한 인터페이스</target>
        </trans-unit>
        <trans-unit id="31310b7b3a3180c515d5a42eececda4ed908af34" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::TPJ13</source>
          <target state="translated">Locale::Maketext::TPJ13</target>
        </trans-unit>
        <trans-unit id="b7159c2a5a142d4334282c641ce964b49b8e476c" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::TPJ13 -- article about software localization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee43c469c3726bd84652212d4ca88cc335a5967" translate="yes" xml:space="preserve">
          <source>Locale::Script</source>
          <target state="translated">Locale::Script</target>
        </trans-unit>
        <trans-unit id="8f438e3df7fafcc383b453fd3213f4653605e9c0" translate="yes" xml:space="preserve">
          <source>Locale::Script - standard codes for script identification</source>
          <target state="translated">로케일 :: 스크립트-스크립트 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="92e24d2019e2a32f9830f5f805e70b0e0aef8c2f" translate="yes" xml:space="preserve">
          <source>Locales according to the default UCA rules include am (Amharic) without &lt;code&gt;[reorder Ethi]&lt;/code&gt;, bg (Bulgarian) without &lt;code&gt;[reorder Cyrl]&lt;/code&gt;, chr (Cherokee) without &lt;code&gt;[reorder Cher]&lt;/code&gt;, de (German), en (English), fr (French), ga (Irish), id (Indonesian), it (Italian), ka (Georgian) without &lt;code&gt;[reorder Geor]&lt;/code&gt;, mn (Mongolian) without &lt;code&gt;[reorder Cyrl Mong]&lt;/code&gt;, ms (Malay), nl (Dutch), pt (Portuguese), ru (Russian) without &lt;code&gt;[reorder Cyrl]&lt;/code&gt;, sw (Swahili), zu (Zulu).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8764300ec3ae038b44ac23ce898f50ceb30676b" translate="yes" xml:space="preserve">
          <source>Locales are supported. There may be glitches when a locale is another EBCDIC code page which has some of the &lt;a href=&quot;#The-13-variant-characters&quot;&gt;code-page variant characters&lt;/a&gt; in other positions.</source>
          <target state="translated">로케일이 지원됩니다. 로케일이 다른 위치에 일부 &lt;a href=&quot;#The-13-variant-characters&quot;&gt;코드 페이지 변형 문자&lt;/a&gt; 가있는 다른 EBCDIC 코드 페이지 인 경우 결함이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33d4312ea8caf12dbb4ec71dca19ee7924926ead" translate="yes" xml:space="preserve">
          <source>Localization and Perl: gettext breaks, Maketext fixes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f83a14354ab144fa1eeefe381bdddf7ef6a4b6" translate="yes" xml:space="preserve">
          <source>Localization of elements of composite types</source>
          <target state="translated">복합 유형 요소의 현지화</target>
        </trans-unit>
        <trans-unit id="87574e6a695fdc9051fd38476db62bcaa8e7cafd" translate="yes" xml:space="preserve">
          <source>Localization of globs</source>
          <target state="translated">글로브의 현지화</target>
        </trans-unit>
        <trans-unit id="f2f69b5bf206324f99fe659a46e5c54c241d441a" translate="yes" xml:space="preserve">
          <source>Localization of special variables</source>
          <target state="translated">특수 변수의 지역화</target>
        </trans-unit>
        <trans-unit id="56adc662b2ff25957a5294f0112a3c7b0d263e47" translate="yes" xml:space="preserve">
          <source>Localized deletion of elements of composite types</source>
          <target state="translated">복합 유형 요소의 현지화 된 삭제</target>
        </trans-unit>
        <trans-unit id="e60da19033e636198e96d7e490201c9c1369d134" translate="yes" xml:space="preserve">
          <source>Localizing &lt;code&gt;$.&lt;/code&gt; will not localize the filehandle's line count</source>
          <target state="translated">지역화 &lt;code&gt;$.&lt;/code&gt; 파일 핸들의 행 수를 현지화하지 않습니다</target>
        </trans-unit>
        <trans-unit id="8364e7e87819604234599a1511218996199f997e" translate="yes" xml:space="preserve">
          <source>Localizing changes</source>
          <target state="translated">현지화 변경</target>
        </trans-unit>
        <trans-unit id="f408eed5847840b83469388030b3326ba3bf4885" translate="yes" xml:space="preserve">
          <source>Localizing tied arrays or hashes does not work. After exiting the scope the arrays or the hashes are not restored.</source>
          <target state="translated">연결된 배열 또는 해시 지역화가 작동하지 않습니다. 범위를 종료하면 배열 또는 해시가 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00e0ebc3f4b2567f4695fa9503d51f87733e190d" translate="yes" xml:space="preserve">
          <source>Locate directory of original perl script</source>
          <target state="translated">원래 펄 스크립트의 디렉토리를 찾으십시오</target>
        </trans-unit>
        <trans-unit id="c6294c5b9baff7ccda4385a76937e4c98b9c0e02" translate="yes" xml:space="preserve">
          <source>Locate the CV corresponding to the currently executing sub or eval. If &lt;code&gt;db_seqp&lt;/code&gt; is non_null, skip CVs that are in the DB package and populate &lt;code&gt;*db_seqp&lt;/code&gt; with the cop sequence number at the point that the DB:: code was entered. (This allows debuggers to eval in the scope of the breakpoint rather than in the scope of the debugger itself.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffe84cd97aaf675f786b03919bbd1aad3c3fe1d" translate="yes" xml:space="preserve">
          <source>Locate the CV corresponding to the currently executing sub or eval. If db_seqp is non_null, skip CVs that are in the DB package and populate *db_seqp with the cop sequence number at the point that the DB:: code was entered. (This allows debuggers to eval in the scope of the breakpoint rather than in the scope of the debugger itself.)</source>
          <target state="translated">현재 실행중인 하위 또는 평가에 해당하는 CV를 찾으십시오. db_seqp가 널이 아닌 경우 DB 패키지에있는 CV를 건너 뛰고 DB :: 코드가 입력 된 시점에서 * db_seqp를 경찰 순번으로 채우십시오. 이렇게하면 디버거가 디버거 자체의 범위가 아닌 중단 점 범위에서 평가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cb0ec5fe28860a73ac5e9c7f201c2864475a69" translate="yes" xml:space="preserve">
          <source>Locates the full path to the script bin directory to allow the use of paths relative to the bin directory.</source>
          <target state="translated">bin 디렉토리에 상대적인 경로를 사용할 수 있도록 스크립트 bin 디렉토리의 전체 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="90f656c2cec82492063f2f19f63b0344475a8752" translate="yes" xml:space="preserve">
          <source>Location of Perl</source>
          <target state="translated">Perl의 위치</target>
        </trans-unit>
        <trans-unit id="e526b099baebb5894aa471d61a7294aea38b4fdb" translate="yes" xml:space="preserve">
          <source>Lock the database with fd &amp;amp; flock.</source>
          <target state="translated">fd &amp;amp; flock으로 데이터베이스를 잠그십시오.</target>
        </trans-unit>
        <trans-unit id="877d08a97c129fe96b732f20ebe8f52e02d93eca" translate="yes" xml:space="preserve">
          <source>Locking and error checking are left as an exercise for the reader. Don't forget them or you'll be quite sorry.</source>
          <target state="translated">잠금 및 오류 검사는 독자의 연습으로 남아 있습니다. 그들을 잊지 마십시오 또는 당신은 매우 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="5c812093b2212c9a68f04fea78f378e5c17f025b" translate="yes" xml:space="preserve">
          <source>Locking this for exclusive access [by specifying &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;$uShare&lt;/code&gt;] doesn't prevent access to the partitions on the disk nor their file systems. So other processes can still access any raw sectors within a partition and can use the file system on the disk as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e083fbbbc4d1d6973e64d911c09f30a9d157b0ca" translate="yes" xml:space="preserve">
          <source>Locking this for exclusive access doesn't prevent access to the physical drive that the partition is on so other processes can still access the raw sectors that way. Locking this for exclusive access &lt;b&gt;does&lt;/b&gt; prevent other processes from opening the same raw partition and &lt;b&gt;does&lt;/b&gt; prevent access to the file system on it. It even prevents the current process from accessing the file system on that partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95da6ca83293caed356315f7966585c98bbeb01" translate="yes" xml:space="preserve">
          <source>Locking this for exclusive access prevents all access to the floppy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cac3a963a1045fd348fae956e2fc8becb2159a" translate="yes" xml:space="preserve">
          <source>Locking: The Trouble with fd</source>
          <target state="translated">잠금 : fd의 문제점</target>
        </trans-unit>
        <trans-unit id="a0ee9e59f4952196e4f063486823a5e6655ed2ab" translate="yes" xml:space="preserve">
          <source>Locks and unlocks the value for an individual key of a hash. The value of a locked key cannot be changed.</source>
          <target state="translated">해시의 개별 키에 대한 값을 잠 그거나 잠금 해제합니다. 잠긴 키의 값은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="409c237554d2d89fa246a166165492e5479e6006" translate="yes" xml:space="preserve">
          <source>Locks are a handy tool to synchronize access to data, and using them properly is the key to safe shared data. Unfortunately, locks aren't without their dangers, especially when multiple locks are involved. Consider the following code:</source>
          <target state="translated">잠금은 데이터에 대한 액세스를 동기화하는 편리한 도구이며이를 안전하게 사용하는 것이 안전한 공유 데이터의 핵심입니다. 불행히도, 특히 여러 개의 잠금 장치가 관련된 잠금 장치에는 위험이 없습니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d77ca7a462f2ee37cd5eeb13d2720840dd8f730e" translate="yes" xml:space="preserve">
          <source>Locks are recursive, which means it's okay for a thread to lock a variable more than once. The lock will last until the outermost &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; on the variable goes out of scope. For example:</source>
          <target state="translated">잠금은 재귀 적이므로 스레드가 변수를 두 번 이상 잠글 수 있습니다. 변수 의 가장 바깥 쪽 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 이 범위를 벗어날 때까지 잠금이 지속 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5da8053ebc549397001271ac2e0aa42fd2e1379" translate="yes" xml:space="preserve">
          <source>Locks are recursive, which means it's okay for a thread to lock a variable more than once. The lock will last until the outermost &lt;code&gt;lock()&lt;/code&gt; on the variable goes out of scope. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0486b135937b6c03b868507a94d272ff8ac6f4" translate="yes" xml:space="preserve">
          <source>Locks on variables only affect &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; calls--they do</source>
          <target state="translated">변수에 대한 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 은 잠금 호출 에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="bf6b3c933353830be1f6195e3ebd4e20c5282db3" translate="yes" xml:space="preserve">
          <source>Locks on variables only affect &lt;code&gt;lock&lt;/code&gt; calls--they do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da97798dad8ca8d2be91a6ab0264ebfef22de7d" translate="yes" xml:space="preserve">
          <source>Locks record for a read operation for this process, while allowing other accessors to read the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34a4fe30048f2f9c89009d31801cebec1a5e7be" translate="yes" xml:space="preserve">
          <source>Locks record for write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2494e49f95e86d62c9e1df9443b971b1071d1eb2" translate="yes" xml:space="preserve">
          <source>Log all messages up to debug:</source>
          <target state="translated">모든 메시지를 디버그하여 디버그하십시오.</target>
        </trans-unit>
        <trans-unit id="ac20548f5a2664c1934f84717b314a50501d6ebb" translate="yes" xml:space="preserve">
          <source>Log an error that can't be ignored.</source>
          <target state="translated">무시할 수없는 오류를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="9f24d2b09c179c98a526a557d74f3d2be5514fb4" translate="yes" xml:space="preserve">
          <source>Log an error unless &lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; 가 아니면 오류를 기록하십시오 . .</target>
        </trans-unit>
        <trans-unit id="352c5f44c11749156243d487f189c562b58e4995" translate="yes" xml:space="preserve">
          <source>Log an error unless &lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598cba7875d82844d0ea4fd50137d27e20e9822b" translate="yes" xml:space="preserve">
          <source>Log critical messages, errors and warnings:</source>
          <target state="translated">중요한 메시지, 오류 및 경고를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc66c8eb58fd8fd2198272ffebc6331b40fb88c" translate="yes" xml:space="preserve">
          <source>Log debugging info to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a127fbcd6604ca1cf80302b78e02d5ba87eed29" translate="yes" xml:space="preserve">
          <source>Log everything except informational messages:</source>
          <target state="translated">정보 메시지를 제외한 모든 것을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="346e7edbc99f3e01ce84957ff3c99842429de19b" translate="yes" xml:space="preserve">
          <source>Log into the remote FTP server with the given login information. If no arguments are given then the &lt;code&gt;Net::FTP&lt;/code&gt; uses the &lt;code&gt;Net::Netrc&lt;/code&gt; package to lookup the login information for the connected host. If no information is found then a login of</source>
          <target state="translated">주어진 로그인 정보를 사용하여 원격 FTP 서버에 로그인하십시오. 인수가 제공되지 않으면 &lt;code&gt;Net::FTP&lt;/code&gt; 는 &lt;code&gt;Net::Netrc&lt;/code&gt; 패키지를 사용 하여 연결된 호스트의 로그인 정보를 찾습니다 . 정보가 없으면 다음의 로그인</target>
        </trans-unit>
        <trans-unit id="38711dd5aba31d74455f59112be713add52892b6" translate="yes" xml:space="preserve">
          <source>Log to UDP port on &lt;code&gt;$remotehost&lt;/code&gt; instead of logging locally:</source>
          <target state="translated">로컬로 로깅하는 대신 &lt;code&gt;$remotehost&lt;/code&gt; 에서 UDP 포트에 로그하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e1bf4e3758f68132ff0d122f3d8b036581a8776" translate="yes" xml:space="preserve">
          <source>Log::Dispatch::Config::TestLog</source>
          <target state="translated">Log::Dispatch::Config::TestLog</target>
        </trans-unit>
        <trans-unit id="ef88b916547cdcd540b35fe969c4a4a3e3015dad" translate="yes" xml:space="preserve">
          <source>Logarithm base two [C99].</source>
          <target state="translated">로그베이스 2 [C99].</target>
        </trans-unit>
        <trans-unit id="126a3068c345063640bada367b1b3170b97166a9" translate="yes" xml:space="preserve">
          <source>Logging if DEBUG (constant)</source>
          <target state="translated">DEBUG (일정) 인 경우 로깅</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">논리 및</target>
        </trans-unit>
        <trans-unit id="4f0fe5e6156db1c8f396f9ada6968d19b442623d" translate="yes" xml:space="preserve">
          <source>Logical Defined-Or</source>
          <target state="translated">논리적 정의 또는</target>
        </trans-unit>
        <trans-unit id="27999dc9087d157951951d7c5ab5c57a64718d42" translate="yes" xml:space="preserve">
          <source>Logical Not</source>
          <target state="translated">논리적 아님</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27af685856a54b17004644154867c40474db6e5" translate="yes" xml:space="preserve">
          <source>Logical or and Exclusive Or</source>
          <target state="translated">논리 또는 독점 또는</target>
        </trans-unit>
        <trans-unit id="eaac42db96179506f42bd718fb8ac139cdc3650b" translate="yes" xml:space="preserve">
          <source>Logical paths specified by system variables containing comma-separated search lists are also allowed; hence &lt;code&gt;System:Modules&lt;/code&gt; is a valid filename, and the filesystem will prefix &lt;code&gt;Modules&lt;/code&gt; with each section of &lt;code&gt;System$Path&lt;/code&gt; until a name is made that points to an object on disk. Writing to a new file &lt;code&gt;System:Modules&lt;/code&gt; would be allowed only if &lt;code&gt;System$Path&lt;/code&gt; contains a single item list. The filesystem will also expand system variables in filenames if enclosed in angle brackets, so &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; would look for the file &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; . The obvious implication of this is that &lt;b&gt;fully qualified filenames can start with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/b&gt; and should be protected when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is used for input.</source>
          <target state="translated">쉼표로 구분 된 검색 목록을 포함하는 시스템 변수로 지정된 논리 경로도 허용됩니다. 따라서 &lt;code&gt;System:Modules&lt;/code&gt; 는 유효한 파일 이름이며 파일 시스템은 디스크의 객체를 가리키는 이름이 만들어 질 때까지 &lt;code&gt;System$Path&lt;/code&gt; 의 각 섹션으로 &lt;code&gt;Modules&lt;/code&gt; 을 접두어 로 사용합니다. 새 파일에 쓰기 &lt;code&gt;System:Modules&lt;/code&gt; 은 &lt;code&gt;System$Path&lt;/code&gt; 에 단일 항목 목록이 포함 된 경우에만 허용됩니다 . 파일 시스템은 꺾쇠 괄호로 묶인 경우 파일 이름의 시스템 변수도 확장하므로 &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; 은 &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; 파일을 찾습니다 . '모듈' . 이것의 명백한 의미는 &lt;b&gt;정규화 된 파일 이름이 &lt;/b&gt;&lt;b&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로&lt;/b&gt;&lt;b&gt; 시작할 수&lt;/b&gt; 있다는 것입니다.&lt;b&gt; &lt;/b&gt;입력에 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이 사용될 때 보호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="720bfdf023a4623ae35ff74918f32bc525e4e4ef" translate="yes" xml:space="preserve">
          <source>Logical paths specified by system variables containing comma-separated search lists are also allowed; hence &lt;code&gt;System:Modules&lt;/code&gt; is a valid filename, and the filesystem will prefix &lt;code&gt;Modules&lt;/code&gt; with each section of &lt;code&gt;System$Path&lt;/code&gt; until a name is made that points to an object on disk. Writing to a new file &lt;code&gt;System:Modules&lt;/code&gt; would be allowed only if &lt;code&gt;System$Path&lt;/code&gt; contains a single item list. The filesystem will also expand system variables in filenames if enclosed in angle brackets, so &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; would look for the file &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt;. The obvious implication of this is that &lt;b&gt;fully qualified filenames can start with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/b&gt; and the three-argument form of &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; should always be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fc415f0920fda900bfdba2744ed1d28349d4d7" translate="yes" xml:space="preserve">
          <source>Logically impossible constraints will be identified immediately by thrown exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79852f7a308fa757ef46ef50b492fb84497039eb" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a Base64 string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 Base64 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efb5f37aee3b9a117751bc32852449eef4e74e78" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a binary string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 이진 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5c5c8e8c0f54246b1b313dd050b036a30efb0a2" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 16 진수 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04b474494be5436c1b0b4486d175dd6df25d94bc" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and uses it to update the current digest state. In other words, the following statements have the same effect:</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고이를 사용하여 현재 다이제스트 상태를 업데이트합니다. 다시 말해, 다음 문장은 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="aaef8ae01439927f0a6ee227f2d792c666fabc4e" translate="yes" xml:space="preserve">
          <source>Login name of the person who ran the Configure script and answered the questions. This is used to tag both</source>
          <target state="translated">Configure 스크립트를 실행하고 질문에 답변 한 사람의 로그인 이름입니다. 둘 다 태그하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="30c490b4b408ece1deda10e7b62b5b4cba9be12b" translate="yes" xml:space="preserve">
          <source>Logs will go on as long as they have to.</source>
          <target state="translated">로그는 필요한 한 계속 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="463552e32614f1099d813cd725ccdec3ad1aa628" translate="yes" xml:space="preserve">
          <source>Long Doubles on Tru64</source>
          <target state="translated">Tru64의 롱 복식</target>
        </trans-unit>
        <trans-unit id="943010215619f82aa64612ba50a6ccaed4ede293" translate="yes" xml:space="preserve">
          <source>Long Doubles.</source>
          <target state="translated">롱 복식.</target>
        </trans-unit>
        <trans-unit id="4d248c964e944a2e6c6cbd3e67c194423372f025" translate="yes" xml:space="preserve">
          <source>Long doubles</source>
          <target state="translated">롱 복식</target>
        </trans-unit>
        <trans-unit id="a209ad07aac520c10047b0552ae5c1c4441aaadc" translate="yes" xml:space="preserve">
          <source>Long integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;long&lt;/code&gt; . The default typemap for &lt;code&gt;long&lt;/code&gt; is T_IV.</source>
          <target state="translated">긴 정수 이것은 T_IV와 동일하지만 리턴 값을 &lt;code&gt;long&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;long&lt;/code&gt; 의 기본 유형 맵 은 T_IV입니다.</target>
        </trans-unit>
        <trans-unit id="39185f77c0d669e9592abefffabc259acc02445d" translate="yes" xml:space="preserve">
          <source>Long integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;long&lt;/code&gt;. The default typemap for &lt;code&gt;long&lt;/code&gt; is T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210129fcaec84064f201e7b1b9a66e1a7acd7738" translate="yes" xml:space="preserve">
          <source>Long lines broken after an operator (except &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; ).</source>
          <target state="translated">연산자 다음에 긴 줄이 끊어졌습니다 ( &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="82e02e558af4f23a10d83ce8c5069dd6822db360" translate="yes" xml:space="preserve">
          <source>Long lines broken after an operator (except &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106ccce59a41316ca39a9a555b12f40ffd8ebb31" translate="yes" xml:space="preserve">
          <source>Long plaguing users of MakeMaker based modules has been the problem of getting basic information about the module out of the sources</source>
          <target state="translated">MakeMaker 기반 모듈의 오랜 골치 아픈 사용자는 소스에서 모듈에 대한 기본 정보를 얻는 데 문제가있었습니다.</target>
        </trans-unit>
        <trans-unit id="d680241590e9a19c54d2635978661f5bb8739734" translate="yes" xml:space="preserve">
          <source>Long regexps like this may impress your friends, but can be hard to decipher. In complex situations like this, the &lt;code&gt;//x&lt;/code&gt; modifier for a match is invaluable. It allows one to put nearly arbitrary whitespace and comments into a regexp without affecting their meaning. Using it, we can rewrite our 'extended' regexp in the more pleasing form</source>
          <target state="translated">이와 같은 긴 정규 표현식은 친구에게 깊은 인상을 줄 수 있지만 해독하기는 어려울 수 있습니다. 이와 같은 복잡한 상황 에서 일치 하는 &lt;code&gt;//x&lt;/code&gt; 수정자는 매우 중요합니다. 거의 임의의 공백과 주석을 의미에 영향을 미치지 않고 정규 표현식에 넣을 수 있습니다. 이를 사용하여 '확장 된'정규 표현식을 더 즐거운 형태로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6c5bcada74abc0711c9dae9786d4c7cc139f2a" translate="yes" xml:space="preserve">
          <source>Long regexps like this may impress your friends, but can be hard to decipher. In complex situations like this, the &lt;code&gt;/x&lt;/code&gt; modifier for a match is invaluable. It allows one to put nearly arbitrary whitespace and comments into a regexp without affecting their meaning. Using it, we can rewrite our &quot;extended&quot; regexp in the more pleasing form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9e2648c307f1adbbaa0fd205252907f8be6f2a" translate="yes" xml:space="preserve">
          <source>Long sequences of elsifs will turn into nested ternary operators, which B::Deparse doesn't know how to indent nicely.</source>
          <target state="translated">긴 Elsif 시퀀스는 중첩 된 삼항 연산자로 바뀌며 B :: Deparse는 잘 들여 쓰는 방법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="5e129104b85153fb31ba0fceac8d1f977b315428" translate="yes" xml:space="preserve">
          <source>Long-running opcodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4ff04cfe182e8bc5dadb069506e27cabf50333" translate="yes" xml:space="preserve">
          <source>Look - search for key in dictionary file</source>
          <target state="translated">찾기-사전 파일에서 키 검색</target>
        </trans-unit>
        <trans-unit id="6f72d2c8eec50883a232d838251fbb3eb807c0d1" translate="yes" xml:space="preserve">
          <source>Look around</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2505a112819d0c19797962a0a34b656ddfcb7762" translate="yes" xml:space="preserve">
          <source>Look at &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; to find out. If you are not using the latest released version, please try to replicate your bug on the latest stable release.</source>
          <target state="translated">에서 봐 &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/은&lt;/a&gt; 밖으로 찾을 수 있습니다. 최신 릴리스 버전을 사용하지 않는 경우 최신 안정 릴리스에서 버그를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="1788237e2a2e0b7dbd5185705c7d994a905e8de0" translate="yes" xml:space="preserve">
          <source>Look for a POD document named &lt;code&gt;$name&lt;/code&gt; in the cache. Returns the reference to the corresponding Pod::Cache::Item object or undef if not found.</source>
          <target state="translated">캐시에서 &lt;code&gt;$name&lt;/code&gt; 이라는 POD 문서를 찾으십시오 . 해당 Pod :: Cache :: Item 객체에 대한 참조를 반환하거나 찾지 못한 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbd0681ce0f07813305ee76bbda2b9bf4d9e94bf" translate="yes" xml:space="preserve">
          <source>Look for a node or index entry named &lt;code&gt;$name&lt;/code&gt; in the object. Returns the unique id of the node (i.e. the second element of the array stored in the node array) or undef if not found.</source>
          <target state="translated">오브젝트에서 이름이 &lt;code&gt;$name&lt;/code&gt; 노드 또는 색인 항목을 찾으십시오 . 노드의 고유 ID (즉, 노드 배열에 저장된 배열의 두 번째 요소)를 반환하거나 찾을 수없는 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4c07166f0931c9bcbab98ad548fcca2101f03fd" translate="yes" xml:space="preserve">
          <source>Look in &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s SEE ALSO for more testing modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123c1cf1f88ba14e6964d416656f6e7d8fd3e930" translate="yes" xml:space="preserve">
          <source>Look in &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s SEE ALSO for more testing modules.</source>
          <target state="translated">에서 봐 &lt;a href=&quot;more&quot;&gt;테스트 :: 더&lt;/a&gt; 의 더 테스트 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1649ed1326706b3a529a44e1b35a34e5184e5a" translate="yes" xml:space="preserve">
          <source>Look up Perl documentation in Pod format.</source>
          <target state="translated">포드 형식의 Perl 설명서를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c69ec9ef84491acf135ee455e26c4726d6d3736b" translate="yes" xml:space="preserve">
          <source>Look up the entry in the cop hints hash</source>
          <target state="translated">경찰 힌트 해시에서 항목을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="014395dfa88deac6c1367d0000e26afdf4422e38" translate="yes" xml:space="preserve">
          <source>Look up the entry in the cop hints hash &lt;code&gt;cophh&lt;/code&gt; with the key specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;COPHH_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar copy of the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f3f361744fabd99e65f601642d504f07f990e2" translate="yes" xml:space="preserve">
          <source>Look up the hint entry in the cop</source>
          <target state="translated">경찰에서 힌트 항목을 찾아</target>
        </trans-unit>
        <trans-unit id="0fee7ddf829801d66655e7ce043a04dd396f49fc" translate="yes" xml:space="preserve">
          <source>Look up the hint entry in the cop &lt;code&gt;cop&lt;/code&gt; with the key specified by &lt;code&gt;keypv&lt;/code&gt; and &lt;code&gt;keylen&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;COPHH_KEY_UTF8&lt;/code&gt; bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. &lt;code&gt;hash&lt;/code&gt; is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar copy of the value associated with the key, or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; if there is no value associated with the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10edb39dcb279e59fbd91c8271e8ebb8f360ce1" translate="yes" xml:space="preserve">
          <source>Look-around assertions are zero-width patterns which match a specific pattern without including it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Look-behind matches text up to the current match position, look-ahead matches text following the current match position.</source>
          <target state="translated">둘러보기 어설 션은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함하지 않고 특정 패턴과 일치하는 폭이 0 인 패턴입니다 . 하위 패턴이 일치하면 포지티브 어설 션이 일치하고 하위 패턴이 실패하면 포지티브 어설 션이 일치합니다. Look-behind는 현재 일치 위치까지 텍스트를 일치시키고, Look-ahead는 현재 일치 위치를 따르는 텍스트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="66105958c37278697eabc3c9dfaee00ab8f9d704" translate="yes" xml:space="preserve">
          <source>Lookaround Assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa1ce4ba86088b9e85e8744c8f85ec1b81ce088" translate="yes" xml:space="preserve">
          <source>Lookaround assertions are zero-width patterns which match a specific pattern without including it in &lt;code&gt;$&amp;amp;&lt;/code&gt;. Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Lookbehind matches text up to the current match position, lookahead matches text following the current match position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99f3f115e8bd3af8ea91944ca784a0a9cfdd772" translate="yes" xml:space="preserve">
          <source>Lookbehind longer than %d not implemented in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724a065c84668bb1516bf7e41f33f4d7062d0ec4" translate="yes" xml:space="preserve">
          <source>Looking ahead and looking behind</source>
          <target state="translated">앞서보고 뒤를 보면서</target>
        </trans-unit>
        <trans-unit id="ddd7aa41b84e676f5291b91d7146d3d34c4b037d" translate="yes" xml:space="preserve">
          <source>Looking at data and -w and v</source>
          <target state="translated">데이터와 -w 및 v 살펴보기</target>
        </trans-unit>
        <trans-unit id="afd51bda07c9e5b3e347f595bec67763e831628e" translate="yes" xml:space="preserve">
          <source>Looking at it another way, writing portable code is usually about willfully limiting your available choices. Naturally, it takes discipline and sacrifice to do that. The product of portability and convenience may be a constant. You have been warned.</source>
          <target state="translated">다른 방법으로 살펴보면 휴대용 코드 작성은 일반적으로 사용 가능한 선택 사항을 의도적으로 제한하는 것입니다. 당연히 그렇게하려면 훈련과 희생이 필요합니다. 휴대 성과 편의성의 제품은 일정 할 수 있습니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="e8e461609613edac0a408d3ea9b1090c941ca168" translate="yes" xml:space="preserve">
          <source>Looking at your</source>
          <target state="translated">당신을보고</target>
        </trans-unit>
        <trans-unit id="b9aa086b4410a1e5dda5b6bd9fecaa602b967f8c" translate="yes" xml:space="preserve">
          <source>Looking in to &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and modern Perl web frameworks is highly recommended, though; web programming in Perl has evolved a long way from the old days of simple CGI scripts.</source>
          <target state="translated">그러나 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 최신 Perl 웹 프레임 워크 를 살펴 보는 것이 좋습니다. Perl의 웹 프로그래밍은 예전의 단순한 CGI 스크립트와는 거리가 멀었습니다.</target>
        </trans-unit>
        <trans-unit id="b407a01503c3f111b5f6d36e40ef6584bf2fa1ec" translate="yes" xml:space="preserve">
          <source>Looking into &lt;a href=&quot;https://plackperl.org&quot;&gt;https://plackperl.org&lt;/a&gt; and modern Perl web frameworks is highly recommended, though; web programming in Perl has evolved a long way from the old days of simple CGI scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24076d6129adc62ded56328acb2536c0df4e3f06" translate="yes" xml:space="preserve">
          <source>Looking up every message is not the easiest way, so let perl to do it for you. Use the diagnostics pragma with turns perl's normal messages into longer discussions on the topic.</source>
          <target state="translated">모든 메시지를 찾는 것이 가장 쉬운 방법은 아니므로 펄에게 맡기십시오. Perl의 일반 메시지를 주제에 대한 더 긴 토론으로 바꾸면서 진단 pragma를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0cda5c2d87b5464569d98d6b83dc0ced023afb49" translate="yes" xml:space="preserve">
          <source>Looking up module information / loading at runtime</source>
          <target state="translated">런타임에 모듈 정보 조회 /로드</target>
        </trans-unit>
        <trans-unit id="747df9a5145420389182a3a0e2f8fb4f1afad4e4" translate="yes" xml:space="preserve">
          <source>Looks OK, after it's been through the syntax check (perl -c scriptname), we run it and all we get is a blank line again! Hmmmm.</source>
          <target state="translated">구문 검사 (perl -c scriptname)를 거친 후에는 확인하고 실행하면 빈 줄이 다시 나타납니다! 흠.</target>
        </trans-unit>
        <trans-unit id="79047f1eed1c43aae002a2db39c10123a7158dcc" translate="yes" xml:space="preserve">
          <source>Looks ahead one (Unicode) character in the text currently being lexed. Returns the codepoint (unsigned integer value) of the next character, or -1 if lexing has reached the end of the input text. To consume the peeked character, use &lt;a href=&quot;#lex_read_unichar&quot;&gt;&quot;lex_read_unichar&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1ff3f5f8cd27194462e5af7c79ade692faba9a" translate="yes" xml:space="preserve">
          <source>Looks ahead one (Unicode) character in the text currently being lexed. Returns the codepoint (unsigned integer value) of the next character, or -1 if lexing has reached the end of the input text. To consume the peeked character, use &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">현재 어휘 화되고있는 텍스트에서 하나의 (유니 코드) 문자를 찾습니다. 다음 문자의 부호 포인트 (부호없는 정수 값)를 반환하거나, 어휘가 입력 텍스트의 끝에 도달하면 -1을 반환합니다. &lt;a href=&quot;#lex_read_unichar&quot;&gt;엿봄&lt;/a&gt; 문자를 소비하려면 lex_read_unichar를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a09e0b7dcffea4a7ed21e9b73140689a5030bc" translate="yes" xml:space="preserve">
          <source>Looks for MakeMaker-like</source>
          <target state="translated">MakeMaker와 같은 제품을 찾습니다</target>
        </trans-unit>
        <trans-unit id="f560b4b8c550fee26628fb62462e2a0f00ebfb7f" translate="yes" xml:space="preserve">
          <source>Looks for Perl DLL in the directory &lt;code&gt;$exedir/../dll&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;$exedir/../dll&lt;/code&gt; 디렉토리에서 Perl DLL을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="0e20c33c03f2909dd222479a34a94e62a5aa2710" translate="yes" xml:space="preserve">
          <source>Looks good, let's just continue off the end of the script:</source>
          <target state="translated">좋아 보인다, 스크립트의 끝에서 계속하자 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
