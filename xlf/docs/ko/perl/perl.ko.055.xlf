<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="49b0c6a17d4f130bfec02b6faa0add21c28561e6" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;glob('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;glob('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt;, or &lt;code&gt;glob('c:/Program\ Files/*/*.dll')&lt;/code&gt;. The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt;, so see &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a8df9b760336178fca425339ec1c7e542a2463" translate="yes" xml:space="preserve">
          <source>Spain</source>
          <target state="translated">Spain</target>
        </trans-unit>
        <trans-unit id="39b253a2d834caa9ad3a83fa215c9eabff3effb2" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="translated">디버깅에 관해서는 Perl에서 정규 표현식을 제어하고 디버깅하는 데 사용할 수있는 몇 가지 pragma가 있습니다. 우리는 이미 이전 섹션에서 하나 프라그가 발생 한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; 변수 보간 및 코드 표현식이 정규 표현식에 공존 할 수 있습니다. 다른 pragma는</target>
        </trans-unit>
        <trans-unit id="0bc7408574e69956819d40445cf53d374170785f" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;use re 'eval';&lt;/code&gt;, that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdd144975003eba8959b061eba84041ab9e203b" translate="yes" xml:space="preserve">
          <source>Speaking of the build directory. Do I have to clean it up myself?</source>
          <target state="translated">빌드 디렉토리에 대해 말하십시오. 직접 청소해야합니까?</target>
        </trans-unit>
        <trans-unit id="cf16c389cb12320d4c2b7cc5db763c0d5676df4a" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , the following are actually the same thing:</source>
          <target state="translated">같은 것들을 말하기 &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , 다음은 실제로 같은 것입니다 :</target>
        </trans-unit>
        <trans-unit id="83aa40d82b5ec161297d7a176f14d055b800dde4" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt;, the following are actually the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942078ca2d04f25545a316c123a392c4d5d339fd" translate="yes" xml:space="preserve">
          <source>Special</source>
          <target state="translated">Special</target>
        </trans-unit>
        <trans-unit id="735223734da1211964b616a8067d85971e38faaf" translate="yes" xml:space="preserve">
          <source>Special &lt;code&gt;make test&lt;/code&gt; targets</source>
          <target state="translated">특별 &lt;code&gt;make test&lt;/code&gt; 대상</target>
        </trans-unit>
        <trans-unit id="fdfdc56af4901b065f0b9e0022efafcd50dad6b5" translate="yes" xml:space="preserve">
          <source>Special Backtracking Control Verbs</source>
          <target state="translated">특별 역 추적 동사</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">특수한 상황들</target>
        </trans-unit>
        <trans-unit id="c09831be5235393e990f8ebc035a5453fef09355" translate="yes" xml:space="preserve">
          <source>Special Characters Inside a Bracketed Character Class</source>
          <target state="translated">대괄호로 묶인 문자 클래스 내의 특수 문자</target>
        </trans-unit>
        <trans-unit id="076a0893de022e884b65708a98aa1abe56ee52c6" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을&lt;/a&gt; 위한 특수 키</target>
        </trans-unit>
        <trans-unit id="fd43bdf2a69d1a862223b1bbefa15cce4dedd0cb" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;use overload&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1bc7b98edc6763e9d6c0abf8b4fa80886e2046f" translate="yes" xml:space="preserve">
          <source>Special Keys for use overload</source>
          <target state="translated">과부하 사용을위한 특수 키</target>
        </trans-unit>
        <trans-unit id="749ad8df41c6024cc71b56ff395f77ccf401c88e" translate="yes" xml:space="preserve">
          <source>Special Literals</source>
          <target state="translated">특수 리터럴</target>
        </trans-unit>
        <trans-unit id="d4cb1cbcc64290386b7c11a130ff81a51320cc9f" translate="yes" xml:space="preserve">
          <source>Special Patterns</source>
          <target state="translated">특수 패턴</target>
        </trans-unit>
        <trans-unit id="f4d1e4b7e421f179bd6711768af6fd760a8db942" translate="yes" xml:space="preserve">
          <source>Special Topics</source>
          <target state="translated">특별 주제</target>
        </trans-unit>
        <trans-unit id="93e61da05b321c91a757c91aeb83a231cf936002" translate="yes" xml:space="preserve">
          <source>Special behaviors for OS X</source>
          <target state="translated">OS X에 대한 특수 동작</target>
        </trans-unit>
        <trans-unit id="e0e39ed69d2c670390ee8a8802b8ef63f9291065" translate="yes" xml:space="preserve">
          <source>Special floating point: infinity (Inf) and not-a-number (NaN)</source>
          <target state="translated">특수 부동 소수점 : 무한대 (Inf) 및 숫자가 아님 (NaN)</target>
        </trans-unit>
        <trans-unit id="ca393fa33bfec26b8152f3f8b37c3b963f3cd851" translate="yes" xml:space="preserve">
          <source>Special make test targets</source>
          <target state="translated">특별 테스트 대상</target>
        </trans-unit>
        <trans-unit id="3bc242af481a6d0584675ca62d67c528336abb44" translate="yes" xml:space="preserve">
          <source>Special note should be made of the return values for a few properties:</source>
          <target state="translated">몇 가지 속성에 대한 반환 값에 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b129e56f9be43046b321c79a90495916b0276970" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; comparison block or function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 사용시 특수 패키지 변수 는 &lt;a href=&quot;functions/sort&quot;&gt;sort를&lt;/a&gt; 참조하십시오 . 이 특수성 때문에 &lt;code&gt;strict 'vars'&lt;/code&gt; 사용할 때에도 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 를 선언 할 필요는 없습니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; ) . 그들을 lexicalize하지 마십시오 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; $ a를 또는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; $ B를 당신이에서 사용할 수 있도록하려면 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 비교 블록 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="11283dda6b65d5275c4aa3ef39c12903730f96b2" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;sort()&lt;/code&gt;, see &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;use vars&lt;/code&gt;, or &lt;code&gt;our()&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;my $a&lt;/code&gt; or &lt;code&gt;my $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;sort()&lt;/code&gt; comparison block or function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c400e57824d764b6a1f1b8ed067b982b5491dad3" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt; . Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="translated">패턴이 특정 위치에서 일치 할 수 있는지 확인하기 위해 &lt;code&gt;re_intuit_start()&lt;/code&gt; 에서 사용하는 특수 regop입니다 . 예를 들어 정규식 엔진이 패턴이 'Z'로 시작해야한다는 것을 알고 있으면 문자열을 찾을 때까지 문자열을 스캔 한 다음 거기서부터 정규식 엔진을 시작할 수 있습니다. 이를 처리하는 루틴을 &lt;code&gt;find_by_class()&lt;/code&gt; 라고 합니다. 때때로이 필드는 프로그램에 내장 된 regop을 가리키고 때로는 옵티마이 저가 구성한 독립적 인 합성 regop을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="52f092c6d31813604bca533dbc8c71a0c669a0b7" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt;. Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c69507b8821a1ac319bfe089337d432b752233" translate="yes" xml:space="preserve">
          <source>Special thanks to Craig Berry and Peter Prymmer (for VMS portability help), Randy Kobes (for Win32 portability help), Clinton Pierce and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond the call of duty), Michael G Schwern (for testing advice), and the rest of the CPAN testers (for testing generally).</source>
          <target state="translated">Craig Gru와 Peter Prymmer (VMS 이식성 도움), Randy Kobes (Win32 이식성 도움), Clinton Pierce 및 Autrijus Tang (위의 의무를 뛰어 넘는 11 시간 Win32 테스트 용), Michael G Schwern (Mr. 테스트 조언) 및 나머지 CPAN 테스터 (일반적으로 테스트)</target>
        </trans-unit>
        <trans-unit id="5543458d832e80fa74fffef1fb3a6e0c964fd937" translate="yes" xml:space="preserve">
          <source>Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including this module in the core and for his patient and helpful guidance during the integration process.</source>
          <target state="translated">코어에이 모듈을 포함시키고 통합 과정에서 환자와 도움을 준 안내에 대해 5.8.0 pumpking 인 Jarkko Hietaniemi에게 특별한 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="bdc349ae3de267bae2e06e8394305bd25b3d697e" translate="yes" xml:space="preserve">
          <source>Special thanks to Tels for suggesting several speed and memory optimizations.</source>
          <target state="translated">여러 속도 및 메모리 최적화를 제안한 Tels에게 특별히 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="58c72ff51f409e740d18b159d1db36db70f1453a" translate="yes" xml:space="preserve">
          <source>Special thanks to the following people who assisted in the creation of the document.</source>
          <target state="translated">문서 작성을 도와 주신 다음 분들께 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="b9982eff3f0e28f25e92903f06ecf866a5e7dab5" translate="yes" xml:space="preserve">
          <source>Special variables that have side effects when you access them or assign to them. For example, in Perl, changing elements of the &lt;code&gt;%ENV&lt;/code&gt; array also changes the corresponding environment variables that subprocesses will use. Reading the &lt;code&gt;$!&lt;/code&gt; variable gives you the current system error number or message.</source>
          <target state="translated">액세스하거나 할당 할 때 부작용이있는 특수 변수. 예를 들어 Perl에서 &lt;code&gt;%ENV&lt;/code&gt; 배열의 요소를 변경하면 하위 프로세스에서 사용할 해당 환경 변수도 변경됩니다. &lt;code&gt;$!&lt;/code&gt; 읽고 ! 변수는 현재 시스템 오류 번호 또는 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="100bcda8aa4f874878478525651d3bbff5ff7492" translate="yes" xml:space="preserve">
          <source>Specialised Import Lists</source>
          <target state="translated">전문화 된 수입 목록</target>
        </trans-unit>
        <trans-unit id="7b09828591f2a4848f0494348259138540610a11" translate="yes" xml:space="preserve">
          <source>Specific (mis)features of OS/2 port</source>
          <target state="translated">OS / 2 포트의 특정 기능</target>
        </trans-unit>
        <trans-unit id="f1dec8c277f6ad361d73048827b65d45acdb1217" translate="yes" xml:space="preserve">
          <source>Specific features of the Cygwin port</source>
          <target state="translated">Cygwin 포트의 특정 기능</target>
        </trans-unit>
        <trans-unit id="686482526f9ca64e951de751df199a7ac0b21959" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Gives the directory part of the location for</source>
          <target state="translated">EMX 포트에만 해당됩니다. 위치의 디렉토리 부분을 제공합니다</target>
        </trans-unit>
        <trans-unit id="8719eacadd757c4d532ec01e84ca717f26242d45" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Should have the form</source>
          <target state="translated">EMX 포트에만 해당됩니다. 양식이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="57a0519d586edded6d90f93d7b49b9ce56048c1e" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since</source>
          <target state="translated">EMX 포트에만 해당됩니다. 이후</target>
        </trans-unit>
        <trans-unit id="3f69d6ce7ad07d5935103bd51d3ea2a5f16d4ee9" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17684874cc7718b5fa207627bf38a956b3362a43" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Used as storage place for temporary files.</source>
          <target state="translated">EMX 포트에만 해당됩니다. 임시 파일의 저장 장소로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8a7871f78fa47c54d3b07594f2afe06c4064c9a" translate="yes" xml:space="preserve">
          <source>Specific types of access to files that can be requested via the &lt;code&gt;$uAccess&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59751d539130b16033ff7290507022cfe789faf" translate="yes" xml:space="preserve">
          <source>Specifically, notice that the formatting codes are present and unescaped in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee5fb071a0f4fc5995dbb8fab061746ab818f7e" translate="yes" xml:space="preserve">
          <source>Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order. If statfs fails, the element pushed onto the return array is the value of errno after the failure. If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure.</source>
          <target state="translated">특히, 우리는 입력 배열에서 한 번에 하나씩 경로 이름을 읽고 결과를 동일한 순서로 출력 배열 (결과)에 저장합니다. statfs가 실패하면 리턴 배열로 푸시 된 요소는 실패 후 errno의 값입니다. statfs가 성공하면 리턴 배열로 푸시 된 값은 statfs 구조의 일부 정보를 포함하는 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="eda3fdece3884b319c275582d4e0949e974b3c68" translate="yes" xml:space="preserve">
          <source>Specifically: Turning on this option will disable the heuristics for seeing only files with Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">구체적으로 :이 옵션을 켜면 Perl과 같은 확장명을 가진 파일 만 볼 수있는 휴리스틱이 비활성화되고 숫자는 있지만 하위 디렉토리는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="ed81a4faa05daf1c1be51b7b8fa82d019bf30684" translate="yes" xml:space="preserve">
          <source>Specification for CPAN distribution metadata</source>
          <target state="translated">CPAN 배포 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="dffd2f13d0f19c68e6d18b2ad7656bd3be03e49e" translate="yes" xml:space="preserve">
          <source>Specified allowed version number formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9358b554d9001e9e29d42fe71cb2423f6e13d1fd" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; or &lt;a href=&quot;#-E-commandline&quot;&gt;-E&lt;/a&gt; switches on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a4072f8995fd4faf63509594cc45d51dcda62a" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;b&gt;-e&lt;/b&gt; or &lt;b&gt;-E&lt;/b&gt; switches on the command line.</source>
          <target state="translated">명령 행에서 &lt;b&gt;-e&lt;/b&gt; 또는 &lt;b&gt;-E&lt;/b&gt; 스위치를 통해 지정된 행 단위.</target>
        </trans-unit>
        <trans-unit id="acc937be340e9018f067e36d4fbe600f0ca7a48d" translate="yes" xml:space="preserve">
          <source>Specifies a TAP::Harness subclass to be used in place of TAP::Harness.</source>
          <target state="translated">TAP :: Harness 대신 사용할 TAP :: Harness 서브 클래스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ccb38b1ea1946cfb54e7b524ba85568b166e308" translate="yes" xml:space="preserve">
          <source>Specifies a name to be used for the extension, e.g., -n RPC::DCE</source>
          <target state="translated">확장에 사용될 이름을 지정합니다 (예 : -n RPC :: DCE).</target>
        </trans-unit>
        <trans-unit id="fb10437a9b9ee94fe2ef27d29d4fd6290157541f" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt; , the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt; .</source>
          <target state="translated">utf8-string 대신 lexicon 항목을 저장하기위한 인코딩을 지정합니다. 세트하는 경우 &lt;code&gt;locale&lt;/code&gt; , 현재 지역 설정의 부호화가 사용된다. &lt;code&gt;Decode&lt;/code&gt; 의 true 값을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="6b02361353aebba65f1252053ca8da3ec24a84ab" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt;, the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5288f1281b330410c08afae34819d7cfc53b87f4" translate="yes" xml:space="preserve">
          <source>Specifies any additional arguments to pass to the compiler. Should be given as a list reference containing the arguments individually, or if this is not possible, as a string containing all the arguments together.</source>
          <target state="translated">컴파일러에 전달할 추가 인수를 지정합니다. 인수를 개별적으로 포함하는 목록 참조 또는 가능하지 않은 경우 모든 인수를 함께 포함하는 문자열로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c0fc5c465acc07c545f1645a7b4737064b57885" translate="yes" xml:space="preserve">
          <source>Specifies any additional directories in which to search for header files. May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</source>
          <target state="translated">헤더 파일을 검색 할 추가 디렉토리를 지정합니다. 단일 디렉토리를 나타내는 문자열 또는 여러 디렉토리를 나타내는 목록 참조로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5f877cdfce163f364b76c3bfab4e6c5095d6d8" translate="yes" xml:space="preserve">
          <source>Specifies file structure for file to be transferred.</source>
          <target state="translated">전송할 파일의 파일 구조를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="087e5ef636ea46b335e961f7299045a135d4c08f" translate="yes" xml:space="preserve">
          <source>Specifies how much effort bzip2 should take before resorting to a slower fallback compression algorithm.</source>
          <target state="translated">느린 대체 압축 알고리즘을 사용하기 전에 bzip2가 얼마나 많은 노력을 기울여야하는지 지정합니다.</target>
        </trans-unit>
        <trans-unit id="98ed6b009cf98007a6f6d9bd7e33d610c98ad8ec" translate="yes" xml:space="preserve">
          <source>Specifies one or more directories to search for the input file if it was not supplied with an absolute path. Each directory path in the given list should be separated by a ':' on Unix (';' on MSWin32 and DOS).</source>
          <target state="translated">입력 파일에 절대 경로가 제공되지 않은 경우 검색 할 하나 이상의 디렉토리를 지정합니다. 주어진 목록의 각 디렉토리 경로는 Unix에서 ':'(MSWin32 및 DOS에서는 ';')로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dd4c4abae664fff706848263f7e2a14f71871c3" translate="yes" xml:space="preserve">
          <source>Specifies source mappings for Tangut ideographs and components. This data file also includes informative radical-stroke values that are used internally by Unicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e97bcf5fbd96ebc76bb798faacc45cc0f7deca3" translate="yes" xml:space="preserve">
          <source>Specifies source material for Nushu characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9774b42720c2ff28dbc21e628ebcd3703ef058" translate="yes" xml:space="preserve">
          <source>Specifies that the source file is a C++ source file and sets appropriate compiler flags</source>
          <target state="translated">소스 파일이 C ++ 소스 파일임을 지정하고 적절한 컴파일러 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="752f5b793296a2436f0f638671fc26add2789004" translate="yes" xml:space="preserve">
          <source>Specifies that this distribution shall not be processed at all.</source>
          <target state="translated">이 분배가 전혀 처리되지 않도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="27c19b2359d6f4ac0335e1401df42879661c8cd1" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.</source>
          <target state="translated">임시 디렉토리에 사용할 디렉토리를 지정합니다. 임시 디렉토리 이름은 내부 템플릿에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="69c1bcd4ebd70c8615309d5b9b715199cd57859f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting from. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">변환중인 인코딩을 지정합니다. &lt;b&gt;iconv&lt;/b&gt; 와 달리이 옵션은 생략 할 수 있습니다. 이러한 경우 현재 로캘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6aabb58f01ed0bc266ebcb530fd5e3060867e4c" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting to. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">변환중인 인코딩을 지정합니다. &lt;b&gt;iconv&lt;/b&gt; 와 달리이 옵션은 생략 할 수 있습니다. 이러한 경우 현재 로캘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc14cf57cc1d526c9df38cf39a2a5e11891e51ad" translate="yes" xml:space="preserve">
          <source>Specifies the extension of the module's loadable object. For example:</source>
          <target state="translated">모듈의로드 가능한 객체의 확장을 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62350db256aee74b2119a37a32d38d1a559bd3c6" translate="yes" xml:space="preserve">
          <source>Specifies the method or subroutine to use when printing error messages about POD syntax. The supplied method/subroutine</source>
          <target state="translated">POD 구문에 대한 오류 메시지를 인쇄 할 때 사용할 메소드 또는 서브 루틴을 지정합니다. 제공된 방법 / 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8490adfe21694bc6560acb4c4b017183f5259a5a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the Perl module that will be created by linking. On platforms that need to do prelinking (Win32, OS/2, etc.) this is a required parameter.</source>
          <target state="translated">링크로 작성 될 Perl 모듈의 이름을 지정합니다. 사전 연결 (Win32, OS / 2 등)을 수행해야하는 플랫폼에서는 필수 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f6fab30529e40665f8d0178ef7752b76fb583aec" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">작성할 출력 실행 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;exe_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;objects&lt;/code&gt; 의 첫 번째 항목 이름을 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="15de15454ec9b8a4605521f63e575015b98bd2c4" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712c7b0a7198fb19bf2fcbbf1b68671ab3789d42" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to create. Otherwise the &lt;code&gt;object_file()&lt;/code&gt; method will be consulted, passing it the name of the &lt;code&gt;source&lt;/code&gt; file.</source>
          <target state="translated">작성할 출력 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;object_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;source&lt;/code&gt; 파일 의 이름을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="0ea5fb9dc13c7dfd946c4f0ec1f502d959136293" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to generate. If no file is specified, output will be written to standard output.</source>
          <target state="translated">생성 할 출력 파일의 이름을 지정합니다. 파일을 지정하지 않으면 출력이 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="95eb37279bd4905df986dc0709bc7910f0b3037c" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">작성할 출력 라이브러리 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;lib_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;objects&lt;/code&gt; 의 첫 번째 항목 이름을 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef72e21940c27171a6511a580792ff08d2fefffd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc8b469ff5b98736322a31c19a8ffad03de9557" translate="yes" xml:space="preserve">
          <source>Specifies the string that will be prefixed to every line of the output. Empty string by default.</source>
          <target state="translated">출력의 모든 행에 접두사가 붙을 문자열을 지정합니다. 기본적으로 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="969aa343df55e9a403d592d5b7e666d694e7c272" translate="yes" xml:space="preserve">
          <source>Specifies transfer mode (stream, block or compressed) for file to be transferred.</source>
          <target state="translated">전송할 파일의 전송 모드 (스트림, 블록 또는 압축)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cc7f9fc804bc9d91b61a85b96105c59f7689d5aa" translate="yes" xml:space="preserve">
          <source>Specifies what to do with symbolic links whose target doesn't exist. If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, a warning of the form &lt;code&gt;&quot;symbolic_link_name is a dangling symbolic link\n&quot;&lt;/code&gt; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7aea723a83b432e8b220dab2e656f549c707e4d" translate="yes" xml:space="preserve">
          <source>Specifies which version of the &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; should be used as the format of the &lt;code&gt;provides&lt;/code&gt; output. Currently only '1.4' and '2' are supported (and their format is identical). This may change in the future as the definition of &lt;code&gt;provides&lt;/code&gt; changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50a3555457e006ff9201a0e994fbe18d143981" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; Perl 버전 요구 사항 지정</target>
        </trans-unit>
        <trans-unit id="b40cf4bd5d43a9f1abad87e39cbbacc3be8422d6" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;use&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51af544190f4d9e1d2d6358a5fcd6745e16f2552" translate="yes" xml:space="preserve">
          <source>Specify SHELL if needed - not done on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a389cd0788a594b00d81ac38b0d5b58f982bb23" translate="yes" xml:space="preserve">
          <source>Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic character.</source>
          <target state="translated">기본 문자 만보고 대소 문자와 분음 부호를 무시하려면 데이터 정렬 수준을 1로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9decfe42c6333527f5da43637561403cd51753" translate="yes" xml:space="preserve">
          <source>Specify a prefix which should be removed from the Perl function names, e.g., -p sec_rgy_ This sets up the XS &lt;b&gt;PREFIX&lt;/b&gt; keyword and removes the prefix from functions that are autoloaded via the &lt;code&gt;constant()&lt;/code&gt; mechanism.</source>
          <target state="translated">Perl 함수 이름에서 제거해야하는 접 두부를 지정하십시오 (예 : -p sec_rgy_). XS &lt;b&gt;PREFIX&lt;/b&gt; 키워드를 설정하고 &lt;code&gt;constant()&lt;/code&gt; 메커니즘을 통해 자동로드되는 함수에서 접 두부를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="8c37cb69f6acc79919a59db7bb047596246ded37" translate="yes" xml:space="preserve">
          <source>Specify a section to include in the output. See &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS in Pod::Parser&lt;/a&gt; for the format to use for</source>
          <target state="translated">출력에 포함 할 섹션을 지정하십시오. 사용할 형식에 대해서는 &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;포드 :: 파서의 섹션 사양을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c842e0100e27043e97262bc2a56a8695e0228b4b" translate="yes" xml:space="preserve">
          <source>Specify a version number for this extension. This version number is added to the templates. The default is 0.01, or 0.00_01 if &lt;code&gt;-B&lt;/code&gt; is specified. The version specified should be numeric.</source>
          <target state="translated">이 확장의 버전 번호를 지정하십시오. 이 버전 번호가 템플릿에 추가됩니다. 기본값은 0.01 또는 &lt;code&gt;-B&lt;/code&gt; 가 지정된 경우 0.00_01 입니다. 지정된 버전은 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e7f58f2c2dcff1260c061c4b22f076c9afef1f52" translate="yes" xml:space="preserve">
          <source>Specify content is binary</source>
          <target state="translated">내용을 이진으로 지정</target>
        </trans-unit>
        <trans-unit id="196ff6b62a23b7ba506c7490495c47cea5d35955" translate="yes" xml:space="preserve">
          <source>Specify in seconds how long to run the command before it is killed with SIG_KILL (9), which effectively terminates it and all of its children (direct or indirect).</source>
          <target state="translated">SIG_KILL (9)로 명령을 종료하기 전에 명령을 실행하는 시간을 초 단위로 지정하십시오. 그러면 명령 및 모든 하위 (직접 또는 간접)가 효과적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e42f9f14e720a274b615a5fad1a17e292745c606" translate="yes" xml:space="preserve">
          <source>Specify pre-requisites in Makefile.PL or Build.PL</source>
          <target state="translated">Makefile.PL 또는 Build.PL에서 전제 조건 지정</target>
        </trans-unit>
        <trans-unit id="1a3e3b8941c020b4dead165334a6a7f6f39e0c5c" translate="yes" xml:space="preserve">
          <source>Specify replacement for groff</source>
          <target state="translated">groff 대체품 지정</target>
        </trans-unit>
        <trans-unit id="82792121ccf914c52ccf31c689a51331bdf9896b" translate="yes" xml:space="preserve">
          <source>Specify some text that will be passed into the &lt;code&gt;STDIN&lt;/code&gt; of the executed program.</source>
          <target state="translated">실행 된 프로그램 의 &lt;code&gt;STDIN&lt;/code&gt; 으로 전달 될 텍스트를 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="e4f8120097eb5801ad49966dad7112d6c8bcad54" translate="yes" xml:space="preserve">
          <source>Specify stream encoding. This is the normal way to deal with encoded text, not by calling low-level functions.</source>
          <target state="translated">스트림 인코딩을 지정하십시오. 이것은 저수준 함수를 호출하는 것이 아니라 인코딩 된 텍스트를 처리하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8473cee86e4b03ee43a6c19c0f0dc45619e13394" translate="yes" xml:space="preserve">
          <source>Specify the HTML file to create. Output goes to STDOUT if no outfile is specified.</source>
          <target state="translated">작성할 HTML 파일을 지정하십시오. 출력 파일이 지정되지 않은 경우 출력은 STDOUT으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2deadb9e68c32c96f8a837b13d5dc23a9778d417" translate="yes" xml:space="preserve">
          <source>Specify the URL of a cascading style sheet. Also disables all HTML/CSS &lt;code&gt;style&lt;/code&gt; attributes that are output by default (to avoid conflicts).</source>
          <target state="translated">계단식 스타일 시트의 URL을 지정하십시오. 또한 충돌을 피하기 위해 기본적으로 출력되는 모든 HTML / CSS &lt;code&gt;style&lt;/code&gt; 속성을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="4aa99f54409387b7146f47653777c920418ff10b" translate="yes" xml:space="preserve">
          <source>Specify the URL of cascading style sheet to link from resulting HTML file. Default is none style sheet.</source>
          <target state="translated">결과 HTML 파일에서 링크 할 CSS (Cascading Style Sheet)의 URL을 지정하십시오. 기본값은 스타일 시트 없음입니다.</target>
        </trans-unit>
        <trans-unit id="9afcf7f83edb719a030bfbfd6d7f5c91cf7f8d6b" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods.</source>
          <target state="translated">라이브러리 포드를 찾기위한 기본 디렉토리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="44291a4ec495223a1da4f1839ae4e831f5a3c791" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods. Default is the current working directory.</source>
          <target state="translated">라이브러리 포드를 찾기위한 기본 디렉토리를 지정하십시오. 기본값은 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5753e538bcef55bd82135ab9b921c4428299f2cd" translate="yes" xml:space="preserve">
          <source>Specify the encoding for implicit byte-string upgrading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5534a64aa32340e65ed43e45968b60d705f9fc" translate="yes" xml:space="preserve">
          <source>Specify the internal type that the constant() mechanism uses for macros. The default is IV (signed integer). Currently all macros found during the header scanning process will be assumed to have this type. Future versions of &lt;code&gt;h2xs&lt;/code&gt; may gain the ability to make educated guesses.</source>
          <target state="translated">constant () 메커니즘이 매크로에 사용하는 내부 유형을 지정하십시오. 기본값은 IV (부호있는 정수)입니다. 현재 헤더 스캐닝 과정에서 발견 된 모든 매크로는이 유형을 가지고 있다고 가정합니다. 미래 버전의 &lt;code&gt;h2xs&lt;/code&gt; 는 교육받은 추측을 할 수있는 능력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20b2619004bea1e14f0e7f2949d240b1952dd51" translate="yes" xml:space="preserve">
          <source>Specify the number of 100K blocks bzip2 uses during compression.</source>
          <target state="translated">압축 중 bzip2가 사용하는 100K 블록 수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1d869ecbc9c626d4a96da51d8e392c8fcdb22cdc" translate="yes" xml:space="preserve">
          <source>Specify the pod file to convert. Input is taken from STDIN if no infile is specified.</source>
          <target state="translated">변환 할 포드 파일을 지정하십시오. 파일이 지정되지 않은 경우 STDIN에서 입력이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2bed91a5a620b4aae10dcfd8cbca6e35a0ef51dd" translate="yes" xml:space="preserve">
          <source>Specify the targets for testing.</source>
          <target state="translated">테스트 대상을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="21bb885000d067ff7c549508e4dd3407f52920a2" translate="yes" xml:space="preserve">
          <source>Specify the title of the resulting HTML file.</source>
          <target state="translated">결과 HTML 파일의 제목을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46f23c724776424563c656a058b3155bcce7e71b" translate="yes" xml:space="preserve">
          <source>Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.</source>
          <target state="translated">Makefile.PL 또는 Build.PL의 전제 조건에서 다른 Perl 모듈의 버전 요구 사항을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd129aeb5d58a2d4cd81a32d015c916c4dfff29" translate="yes" xml:space="preserve">
          <source>Specify which directory is used for storing cache. Default directory is the current working directory.</source>
          <target state="translated">캐시 저장에 사용되는 디렉토리를 지정하십시오. 기본 디렉토리는 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c06413cd34d05ffad8b760e0ccbb2a8039560c0e" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked to in cross references.</source>
          <target state="translated">podroot의 어떤 서브 디렉토리에 HTML 변환 양식을 상호 참조로 링크 할 수있는 pod 파일이 들어 있는지 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed9289cec9db507a9bd1e2cf8a443192d39f482" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked-to in cross-references.</source>
          <target state="translated">상호 참조에서 HTML로 변환 된 양식을 링크 할 수있는 포드 파일을 포함하는 podroot의 서브 디렉토리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="08ce00bfc35270a0506d4be19cf439c32891aca2" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;flags&lt;/code&gt; can further restrict what is allowed and not warned on, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddb0fa6b996bdc82d7ed351288c14ade48e2fbe" translate="yes" xml:space="preserve">
          <source>Specifying I/O layers in MODE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda870361643b1e3b5ceca1a143c1054b6477609" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl (that is, prior to 5.6.0) that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">v5.6.1 형식의 리터럴로 VERSION을 지정하면이 구문을 지원하지 않는 이전 버전의 Perl (즉, 5.6.0 이전)에서 오도를 유발하는 오류 메시지가 발생하므로 일반적으로 피해야합니다. 대신 동등한 숫자 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cc4c6ab0a0e40b55ad8e487edeab38628dd47f2" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">v5.6.1 형식의 리터럴로 VERSION을 지정하면이 구문을 지원하지 않는 이전 버전의 Perl에서 오해를 유발하는 오류 메시지가 발생하므로 일반적으로 피해야합니다. 대신 동등한 숫자 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b76a85ec03f0c93fc5652cb698781d576e230edd" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a numeric argument of the form 5.024001 should generally be avoided as older less readable syntax compared to v5.24.1. Before perl 5.8.0 (released in 2002), the more verbose numeric form was the only supported syntax, which is why you might see it in older code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa5c6fcdba9772c2f949fa78c3312ba8e176e5c" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a numeric argument of the form 5.024001 should generally be avoided as older less readable syntax compared to v5.24.1. Before perl 5.8.0 released in 2002 the more verbose numeric form was the only supported syntax, which is why you might see it in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a66a84ae1308320a2e6185af2d7c0f4640974" translate="yes" xml:space="preserve">
          <source>Specifying Values</source>
          <target state="translated">값 지정</target>
        </trans-unit>
        <trans-unit id="6ddacaf845437713514dee82096d8d2996a0782a" translate="yes" xml:space="preserve">
          <source>Specifying a compatibility version higher than the version of perl you are using to run h2xs will have no effect. If unspecified h2xs will default to compatibility with the version of perl you are using to run h2xs.</source>
          <target state="translated">h2xs를 실행하는 데 사용하는 perl 버전보다 높은 호환성 버전을 지정해도 효과가 없습니다. 지정되지 않은 h2x가 기본적으로 h2x를 실행하는 데 사용하는 perl 버전과 호환되는 경우.</target>
        </trans-unit>
        <trans-unit id="b9ac38be3885e820db907e52feea151509c97c14" translate="yes" xml:space="preserve">
          <source>Specifying a negative flag after the caret is an error, as the flag is redundant.</source>
          <target state="translated">플래그가 중복되므로 캐럿 뒤에 음수 플래그를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcb93594508dd14f6f183606eef58af67f897bab" translate="yes" xml:space="preserve">
          <source>Specifying a negative index position greater than the number of items in the queue adds the list to the head of the queue.</source>
          <target state="translated">큐의 항목 수보다 큰 음수 인덱스 위치를 지정하면 큐의 헤드에 목록이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0428551388a304fda9da2ce393b07c826bf5874b" translate="yes" xml:space="preserve">
          <source>Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel &lt;code&gt;jobs&lt;/code&gt; in your Harness object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae5b52602873edfea60de35a979b3a17659ea0" translate="yes" xml:space="preserve">
          <source>Specifying a rule to allow tests to run in parallel does not make them run in parallel. You still need specify the number of parallel &lt;code&gt;jobs&lt;/code&gt; in your Harness object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e80e764794a3f53d9bd22d3f4959b3c3e8e8c0" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue just adds the list to the end.</source>
          <target state="translated">대기열의 항목 수보다 큰 색인 위치를 지정하면 목록이 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9c224eb1496ab5698ab91d2a22838e04eaf02d0d" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list being returned.</source>
          <target state="translated">큐의 항목 수보다 큰 인덱스 위치를 지정하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="16018fb283b08c865834aaa6b2e024c776590ab5" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;undef&lt;/code&gt; or an empty list being returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fcdf16424ed34965445319ec725af2d142641e" translate="yes" xml:space="preserve">
          <source>Specifying mode and filename as a single argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b369061e994be9b95b9b52fd041d04e9eccbbae" translate="yes" xml:space="preserve">
          <source>Specifying sub-versions such as the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;5.14.0&lt;/code&gt; in feature bundles has no effect. Feature bundles are guaranteed to be the same for all sub-versions.</source>
          <target state="translated">기능 번들 에서 &lt;code&gt;5.14.0&lt;/code&gt; 의 &lt;code&gt;0&lt;/code&gt; 과 같은 하위 버전 을 지정해 도 효과가 없습니다. 기능 번들은 모든 하위 버전에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="79a6f96c957e7feef1314dc46564cc00f5833bc6" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see</source>
          <target state="translated">&quot;udp&quot;프로토콜을 지정하면 ping () 메소드가 udp 패킷을 원격 호스트의 에코 포트로 보냅니다. 반향 된 패킷이 원격 호스트에서 수신되고 수신 된 패킷에 전송 된 패킷과 동일한 데이터가 포함 된 경우 원격 호스트는 도달 가능한 것으로 간주됩니다. 이 프로토콜에는 특별한 권한이 필요하지 않습니다. udp ping의 경우 적절한 에코 서비스를 실행하지 않으면 호스트에 연결할 수없는 것으로보고됩니다. 유닉스 계열 시스템의 경우</target>
        </trans-unit>
        <trans-unit id="a43e4d18241d23c364eb62d107e205d919850575" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see &lt;a href=&quot;http://man.he.net/man8/inetd&quot;&gt;inetd(8)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2819720e6a0b64709090cd36c99161c9c51d2535" translate="yes" xml:space="preserve">
          <source>Specifying the G_DISCARD flag with</source>
          <target state="translated">다음과 같이 G_DISCARD 플래그 지정</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="40e5809be52d66c56af4f3807fbc74465fe77f2b" translate="yes" xml:space="preserve">
          <source>Spherical coordinates,</source>
          <target state="translated">구면 좌표,</target>
        </trans-unit>
        <trans-unit id="0bce309883c4786c8f96950f6206dff26186fc2b" translate="yes" xml:space="preserve">
          <source>Split a directory specification into the components.</source>
          <target state="translated">디렉토리 스펙을 구성 요소로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="0e9eed69886886b90fb3afa01fba40f13ff4d0a7" translate="yes" xml:space="preserve">
          <source>Split a package for autoloading</source>
          <target state="translated">자동 로딩을위한 패키지 분할</target>
        </trans-unit>
        <trans-unit id="5a8f5f6aec0e05c9fd24b5a8ca47f652c1c2ceaf" translate="yes" xml:space="preserve">
          <source>Split loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a230284c2746978c6d208e00f352e0d6fb5d918" translate="yes" xml:space="preserve">
          <source>Split out from Safe module version 1, named opcode tags and other changes added by Tim Bunce.</source>
          <target state="translated">안전 모듈 버전 1에서 이름이 지정된 opcode 태그와 Tim Bunce에 의해 추가 된 기타 변경 사항에서 분리합니다.</target>
        </trans-unit>
        <trans-unit id="273ddbe310d23df41c94915a842b407f242c4749" translate="yes" xml:space="preserve">
          <source>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">볼륨을 디렉토리, 디렉토리 및 파일 이름 부분으로 분할합니다. 볼륨 개념이없는 시스템에서는 볼륨에 대해 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="334895ed21abe595a625b2f1658f99e01bbe8d40" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions.</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="9683042273a4ecd00e523d0bde1551fc4f8c1380" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. Assumes that the last file is a path unless the path ends in '\\', '\\.', '\\..' or $no_file is true. On Win32 this means that $no_file true makes this return ( $volume, $path, '' ).</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다. 경로가 '\\', '\\.', '\\ ..'또는 $ no_file로 끝나지 않는 한 마지막 파일이 경로라고 가정합니다. Win32에서 이는 $ no_file true가이 리턴 값 ($ volume, $ path, '')을 작성 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86fed3cc24e2d19645e7064b9a14b47a5f182fe6" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다. 볼륨 개념이없는 시스템에서는 볼륨에 대해 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d39c4c6b066b235387ae82c04d47c7856f6398b" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context.</source>
          <target state="translated">문자열 EXPR을 문자열 목록으로 분할하고 목록 컨텍스트의 목록 또는 스칼라 컨텍스트의 목록 크기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2936a94e1d47596e4e39d9256be18597c3aa4179" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context. (Prior to Perl 5.11, it also overwrote &lt;code&gt;@_&lt;/code&gt; with the list in void and scalar context. If you target old perls, beware.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250f996321b0ccf8a0a091d8ad8d1f0defcbee6b" translate="yes" xml:space="preserve">
          <source>Splitting up a program text into &lt;b&gt;tokens&lt;/b&gt;. Also known as &amp;ldquo;lexing&amp;rdquo;, in which case you get &amp;ldquo;lexemes&amp;rdquo; instead of tokens.</source>
          <target state="translated">프로그램 텍스트를 &lt;b&gt;토큰&lt;/b&gt; 으로 나누기 . &quot;lexing&quot;이라고도하며,이 경우 토큰 대신 &quot;lexemes&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ff729dbb2771278d79c384030e9caa881a4db264" translate="yes" xml:space="preserve">
          <source>Spool to system printer on close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fc00753787683a6ac1541ee8a68b3aa017c6a5" translate="yes" xml:space="preserve">
          <source>Spurious text after =pod / =cut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44359690bcaf314432bdd57278be918c222c6a77" translate="yes" xml:space="preserve">
          <source>Square Brackets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="dab8825d9ab14cb0ae9c8c35a6b41109eb0231a8" translate="yes" xml:space="preserve">
          <source>Stabilized</source>
          <target state="translated">Stabilized</target>
        </trans-unit>
        <trans-unit id="699cbcfa1d2de31b511ffab2c2a0ef9730993e7e" translate="yes" xml:space="preserve">
          <source>Stable CPAN modules</source>
          <target state="translated">안정적인 CPAN 모듈</target>
        </trans-unit>
        <trans-unit id="0c37e4671699616f1b661a8adda9cc25f7e7c380" translate="yes" xml:space="preserve">
          <source>Stable modules should maintain backwards compatibility</source>
          <target state="translated">안정적인 모듈은 이전 버전과의 호환성을 유지해야합니다</target>
        </trans-unit>
        <trans-unit id="e59f32f5132f95bd8522cf0423d93b2b074371e3" translate="yes" xml:space="preserve">
          <source>Stack Manipulation Macros</source>
          <target state="translated">스택 조작 매크로</target>
        </trans-unit>
        <trans-unit id="d3f19bccf79868f3c579b95c4b4aa5c3173cdfc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow is a free question-and-answer site for programmers. It's not focussed solely on Perl, but it does have an active group of users who do their best to help people with their Perl programming questions.</source>
          <target state="translated">스택 오버플로는 프로그래머를위한 무료 질의 응답 사이트입니다. Perl에만 초점을 맞추지는 않았지만 Perl 프로그래밍 질문에 사람들을 돕기 위해 최선을 다하는 적극적인 사용자 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c0915aad1c8e4662635799d017c78213056099" translate="yes" xml:space="preserve">
          <source>Stack Trace formatting</source>
          <target state="translated">스택 추적 형식</target>
        </trans-unit>
        <trans-unit id="bed6dbd7b4c6ff7ccd34126ec3ad733b680488ca" translate="yes" xml:space="preserve">
          <source>Stack backtrace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbdf4bd83f4cf97cb14bdbe17601c9d4a7b9b2b" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dMARK&quot;&gt;&quot;dMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32c5432806926c51af3a6d722094d1b8498ee67" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;dMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB의 스택 마커 변수 &lt;code&gt;dMARK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abb5c52ccc52723cd1612e07bb13d70407d8e476" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt; .</source>
          <target state="translated">스택 포인터. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . &lt;code&gt;dSP&lt;/code&gt; 및 &lt;code&gt;SPAGAIN&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f089b00d917131a98e897f79444313cdb238edf" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#dSP&quot;&gt;&quot;dSP&quot;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eeeffb91b556017b0569617dac90bb982af82c6" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="translated">스택 크기 토론 : &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="154b31259cd2c2ec7e9e63fa8a80cdb8ccfd16a7" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;https://www.perlmonks.org/?node_id=532956&quot;&gt;https://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249f056b552dcec0dec16b7eed3b2513cf1351f3" translate="yes" xml:space="preserve">
          <source>Stacks</source>
          <target state="translated">Stacks</target>
        </trans-unit>
        <trans-unit id="5972ab200f32099d27f68650121e9738cdd0e0dc" translate="yes" xml:space="preserve">
          <source>Standard Exports</source>
          <target state="translated">표준 수출</target>
        </trans-unit>
        <trans-unit id="615e5b98a32ea52bb60f7df7a2666749db3e59ab" translate="yes" xml:space="preserve">
          <source>Standard I/O functions via VMS extensions</source>
          <target state="translated">VMS 확장을 통한 표준 I / O 기능</target>
        </trans-unit>
        <trans-unit id="eba63c181dd248d4b5bba8f0065bbb50178505fc" translate="yes" xml:space="preserve">
          <source>Standard Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc014247a90e3e9471cd43027f6ed1dd5022323" translate="yes" xml:space="preserve">
          <source>Standard Modules</source>
          <target state="translated">표준 모듈</target>
        </trans-unit>
        <trans-unit id="c9c684d7aa085e9385f19a731c50f29d333142bb" translate="yes" xml:space="preserve">
          <source>Standard TAP formatter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb1fc559ce28778664dae993a8bd3c9c1e13c04" translate="yes" xml:space="preserve">
          <source>Standard codes for country identification</source>
          <target state="translated">국가 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="60f2260734e540712fc0b3a84eed77018b10ca66" translate="yes" xml:space="preserve">
          <source>Standard codes for currency identification</source>
          <target state="translated">통화 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="b5deda2e5280ead9cecc60bbf30d177abf9ec4ea" translate="yes" xml:space="preserve">
          <source>Standard codes for language extension identification</source>
          <target state="translated">언어 확장 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="f2ee3631bc2f34f1c73413a9d2061ce03c5ab44f" translate="yes" xml:space="preserve">
          <source>Standard codes for language identification</source>
          <target state="translated">언어 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="10a16afeaf36afe90baa03b4e90894540cc06be0" translate="yes" xml:space="preserve">
          <source>Standard codes for language variation identification</source>
          <target state="translated">언어 변형 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="b1589d1520251236f9eb362681e4874ce8c5e9ee" translate="yes" xml:space="preserve">
          <source>Standard codes for script identification</source>
          <target state="translated">스크립트 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="5d6d11511a070bcf17fa4eb2391ebf6e7a493c05" translate="yes" xml:space="preserve">
          <source>Standard modules with VMS-specific differences</source>
          <target state="translated">VMS 관련 차이점이있는 표준 모듈</target>
        </trans-unit>
        <trans-unit id="de92c20ac3781f514b3f3e2c2c6d7cf3cd1b6af8" translate="yes" xml:space="preserve">
          <source>Standard, bundled modules are all expected to behave in a well-defined manner with respect to namespace pollution because they use the Exporter module. See their own documentation for details.</source>
          <target state="translated">표준 번들 모듈은 모두 내보내기 모듈을 사용하므로 네임 스페이스 오염과 관련하여 잘 정의 된 방식으로 작동합니다. 자세한 내용은 자체 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06d642894968e30a189e062bc83886c6edaae47c" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.html</source>
          <target state="translated">StandardizedVariants.html</target>
        </trans-unit>
        <trans-unit id="8e0bc2ae4e7dee6efa427af24dac0f51946576f0" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.txt</source>
          <target state="translated">StandardizedVariants.txt</target>
        </trans-unit>
        <trans-unit id="8f1eb352b92791858ba92c3002eb4f33fe75c02e" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Create if none&quot;. If the requested file does not exist, then it is created and then opened. This is the default if &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested or if &lt;code&gt;&quot;t&quot;&lt;/code&gt; or &lt;code&gt;&quot;n&quot;&lt;/code&gt; was specified. Contrast with &lt;code&gt;&quot;e&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822e0e0d7c446c8fe35f0a8dc97579be22addccb" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Existing file only&quot;. If the requested file does not exist, then nothing is opened and the &lt;code&gt;createFile&lt;/code&gt; call fails. This is the default unless &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested or &lt;code&gt;&quot;t&quot;&lt;/code&gt; or &lt;code&gt;&quot;n&quot;&lt;/code&gt; was specified. Contrast with &lt;code&gt;&quot;c&quot;&lt;/code&gt;. Can't be used with &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652ad6f84c10dfa8eb50a6eccca9974ed76fa82f" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Keep if exists&quot;. If the requested file exists, then it is opened. This is the default unless &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested but &lt;code&gt;GENERIC_READ&lt;/code&gt; access has not been requested. Contrast with &lt;code&gt;&quot;t&quot;&lt;/code&gt; and &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97906deb67c16b9ab59b8c8cd40f5544710588f" translate="yes" xml:space="preserve">
          <source>Stands for &quot;New file only&quot;. If the requested file exists, then it is not opened and the &lt;code&gt;createFile&lt;/code&gt; call fails. Contrast with &lt;code&gt;&quot;k&quot;&lt;/code&gt; and &lt;code&gt;&quot;t&quot;&lt;/code&gt;. Can't be used with &lt;code&gt;&quot;e&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a514e0a0fb34443686dd34171dc3a164f90121" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Query access&quot;. This is really a no-op since you always have query access when you open a file. You can specify &lt;code&gt;&quot;q&quot;&lt;/code&gt; to document that you plan to query the file [or device, etc.]. This is especially helpful when you don't want read nor write access since something like &lt;code&gt;&quot;q&quot;&lt;/code&gt; or &lt;code&gt;&quot;q ke&quot;&lt;/code&gt; may be easier to understand than just &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;ke&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca1e430d40009621884ba6704cb12fdbd5a5f0a" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Read access&quot;. Sets the &lt;code&gt;GENERIC_READ&lt;/code&gt; bit(s) in the &lt;code&gt;$uAccess&lt;/code&gt; that is passed to &lt;code&gt;CreateFile&lt;/code&gt;. This is the default access if the &lt;code&gt;$svAccess&lt;/code&gt; parameter is missing [or if it is &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;$rvhvOptions&lt;/code&gt; doesn't specify an &lt;code&gt;&quot;Access&quot;&lt;/code&gt; option].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7a0d1e7c51667204657dcea2b802a67f1a4440" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Truncate if exists&quot;. If the requested file exists, then it is truncated to zero length and then opened. This is the default if &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested and &lt;code&gt;GENERIC_READ&lt;/code&gt; access has not been requested. Contrast with &lt;code&gt;&quot;k&quot;&lt;/code&gt; and &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481c6b37648dd19153bdddeac4cc38f4916dae94" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Write access&quot;. Sets the &lt;code&gt;GENERIC_WRITE&lt;/code&gt; bit(s) in the &lt;code&gt;$uAccess&lt;/code&gt; that is passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07142f93c49bc59a674f3cf54cfc45c16742e4f3" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="translated">디스크 파일을 사용하여 &lt;b&gt;연관 배열&lt;/b&gt; 을 에뮬레이트하는 루틴 세트 인 &quot;데이터베이스 관리&quot;루틴을 나타냅니다 . 루틴은 동적 해싱 구성표를 사용하여 두 개의 디스크 액세스 만있는 항목을 찾습니다. DBM 파일을 사용하면 Perl 프로그램이 여러 호출 에서 지속적 &lt;b&gt;해시&lt;/b&gt; 를 유지할 수 있습니다. 당신은 할 수 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 여러 DBM 구현에 해시 변수를.</target>
        </trans-unit>
        <trans-unit id="1a775e3592f8bbe5e3864eeff5292ad588cc2550" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;tie&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912db97dd4f77a0ec4611c2eb6976e694df9c91d" translate="yes" xml:space="preserve">
          <source>Start by familiarizing yourself with &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and &lt;a href=&quot;TAP::Parser::IteratorFactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt;. &lt;a href=&quot;TAP::Parser::SourceHandler::RawTAP&quot;&gt;TAP::Parser::SourceHandler::RawTAP&lt;/a&gt; is the easiest sub-class to use as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dfbc7a4324027580845858a63c6abfc58480ed" translate="yes" xml:space="preserve">
          <source>Start iPKGui. Install the packages &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;coreutils&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ab44220e1cd65314352df58f468e908b8005a5" translate="yes" xml:space="preserve">
          <source>Start logging each disk request in a buffer internal to the disk device driver of size &lt;code&gt;$uLogBufferSize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e3debe4cf1141c3184e11a9dc572fab1423447" translate="yes" xml:space="preserve">
          <source>Start position and no-match optimisations</source>
          <target state="translated">시작 위치 및 불일치 최적화</target>
        </trans-unit>
        <trans-unit id="db76cc0f3f883ec9a2ed91694d94f4588b9f7245" translate="yes" xml:space="preserve">
          <source>Start up an interval timer: after a certain time, a signal ($which) arrives, and more signals may keep arriving at certain intervals. To disable an &quot;itimer&quot;, use &lt;code&gt;$floating_seconds&lt;/code&gt; of zero. If the &lt;code&gt;$interval_floating_seconds&lt;/code&gt; is set to zero (or unspecified), the timer is disabled &lt;b&gt;after&lt;/b&gt; the next delivered signal.</source>
          <target state="translated">인터벌 타이머를 시작하십시오. 특정 시간이 지나면 신호 ($ which)가 도착하고 더 많은 신호가 특정 간격으로 계속 도착할 수 있습니다. &quot;itimer&quot;를 비활성화하려면 &lt;code&gt;$floating_seconds&lt;/code&gt; 의 0을 사용하십시오. 는 IF &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 제로 (또는 지정)로 설정, 타이머가 비활성화되어 &lt;b&gt;후&lt;/b&gt; 다음 전달 된 신호.</target>
        </trans-unit>
        <trans-unit id="06610ff85775ebe35f7b8f21af74dc2942b66fd2" translate="yes" xml:space="preserve">
          <source>Start using Devel::PPPort for XS projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc3261b7747ff88ddb552066307bdb160a93102" translate="yes" xml:space="preserve">
          <source>Start with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf54d336f01982c7f36b58a5973054d7f918d05e" translate="yes" xml:space="preserve">
          <source>Start with a dummy run of h2xs:</source>
          <target state="translated">h2xs의 더미 실행으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8d112be587c3b58ec2b08ad08b5f28537f049d9b" translate="yes" xml:space="preserve">
          <source>Start with single-step on.</source>
          <target state="translated">단일 단계부터 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8332767a94ccaf8b2674f5e407c13b8594261e03" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 'a'.</source>
          <target state="translated">문자열 'a'의 첫 글자로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="be46870dc50c93db69a63c772d7b331eea2b204f" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 't'.</source>
          <target state="translated">문자열 't'의 첫 글자로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="e5189aa41c41bf90fef351656e01e6473fbaf249" translate="yes" xml:space="preserve">
          <source>Start your Perl program</source>
          <target state="translated">Perl 프로그램을 시작하십시오</target>
        </trans-unit>
        <trans-unit id="9f05ee38f1d8c4b639d2c05f6f7cb39a8f63ba62" translate="yes" xml:space="preserve">
          <source>Start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParser의 시작 토큰</target>
        </trans-unit>
        <trans-unit id="bba3dd50f7eb62963e78abd741a6ecb84d7e0e92" translate="yes" xml:space="preserve">
          <source>Starting From Scratch</source>
          <target state="translated">스크래치에서 시작</target>
        </trans-unit>
        <trans-unit id="d9722acfd050423d2f793d245909513d9f792a51" translate="yes" xml:space="preserve">
          <source>Starting OS/2 (and DOS) programs under Perl</source>
          <target state="translated">Perl에서 OS / 2 (및 DOS) 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="6a454cb163d40a3be765256333ed856099e340c6" translate="yes" xml:space="preserve">
          <source>Starting Perl in the VMS debugger may change the program execution profile in a way that such problems are not reproduced.</source>
          <target state="translated">VMS 디버거에서 Perl을 시작하면 이러한 문제가 재현되지 않는 방식으로 프로그램 실행 프로파일이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b2b3d56b228f00035d9baf98e67307d761a53f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="0aee4d40c0b8d064ab00858293dabb8236e2cf55" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS 4.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c712909317e062b2443119b81f61884099ac7f3f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under OS/2 (and DOS and...)</source>
          <target state="translated">OS / 2 (및 DOS 및 ...)에서 Perl 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="653f89b4c2f41c0d0134c806e923d3709fc205d1" translate="yes" xml:space="preserve">
          <source>Starting from IO::Zlib version 1.02, IO::Zlib can also use an external</source>
          <target state="translated">IO :: Zlib 버전 1.02부터 IO :: Zlib는 외부를 사용할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="a508a2e273548a63bb5c0b07719e420fe300b9fd" translate="yes" xml:space="preserve">
          <source>Starting from OS/400 V5R2 the IBM Visual Age compiler is supported on OS/400 PASE, so it is possible to build Perl natively on OS/400. The easier way, however, is to compile in AIX, as just described.</source>
          <target state="translated">OS / 400 V5R2부터 IBM Visual Age 컴파일러는 OS / 400 PASE에서 지원되므로 OS / 400에서 기본적으로 Perl을 빌드 할 수 있습니다. 그러나 가장 쉬운 방법은 방금 설명한대로 AIX에서 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e473385f5209d49f3d6236a23d69b61072e12c5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say</source>
          <target state="translated">Perl 5.10.1 (5.15.1은 좋지만 제대로 작동하지 않음)부터 시작하면</target>
        </trans-unit>
        <trans-unit id="213483245e12096ac5558b413cc608887022de0d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.6 Perl has had some level of multibyte character support. Perl 5.8 or later is recommended. Supported multibyte character repertoires include Unicode, and legacy encodings through the Encode module. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Perl 5.6부터 Perl은 일정 수준의 멀티 바이트 문자를 지원했습니다. Perl 5.8 이상이 권장됩니다. 지원되는 멀티 바이트 문자 레퍼토리에는 유니 코드 및 인코딩 모듈을 통한 레거시 인코딩이 포함됩니다. &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; , &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 및 &lt;a href=&quot;encode&quot;&gt;Encode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3401e5a549f724e4569e770d48d8137b822e30b" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.7.2 (and consequently 5.8.x / 5.10.x / 5.12.x) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Perl 5.7.2 (및 결과적으로 5.8.x / 5.10.x / 5.12.x)부터 AIX 4.3 이상은 Perl에서 사용 된 에뮬레이트 된 인터페이스 대신 런타임 링크 모드에서 AIX 기본 동적로드 인터페이스를 사용합니다. Perl 릴리스 5.6.1 이하 또는 AIX 릴리스 4.2 이하. 이 변경은 이전 Perl 릴리스에서 컴파일 된 모듈과의 호환성을 손상시킵니다. Perl이 AIX 기본 인터페이스를 사용하는 Apache / mod_perl과 같은 다른 응용 프로그램과 호환되도록 변경되었습니다. 이 변경은 또한 Perl 확장에서 정적 생성자와 소멸자와 함께 C ++ 코드를 사용할 수있게했으며 에뮬레이트 된 인터페이스로는 불가능했습니다.</target>
        </trans-unit>
        <trans-unit id="25d510ae8cee14025ed8b7521c9e7b4803c6e585" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 Filter::Util::Call (the core part of the Source Filters distribution) is part of the standard Perl distribution. Also included is a friendlier interface called Filter::Simple, by Damian Conway.</source>
          <target state="translated">Perl 5.8부터 시작 Filter :: Util :: Call (소스 필터 배포의 핵심 부분)은 표준 Perl 배포의 일부입니다. Damian Conway의 Filter :: Simple이라는 친숙한 인터페이스도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84131be03444ffa9bfcdc4607ace523b2b4abf69" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 you can use the standard module Encode to translate from EBCDIC to Latin-1 code points. Encode knows about more EBCDIC character sets than Perl can currently be compiled to run on.</source>
          <target state="translated">Perl 5.8부터 표준 모듈 Encode를 사용하여 EBCDIC에서 Latin-1 코드 포인트로 변환 할 수 있습니다. Encode는 Perl이 현재 실행되도록 컴파일 할 수있는 것보다 많은 EBCDIC 문자 세트에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b494835e5e76badb9fdcdcf6ee9b4a757213c9dc" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt; , can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="translated">Perl 5.8부터 소스 필터 모듈 인 &lt;code&gt;Switch&lt;/code&gt; 를 사용하여 스위치와 케이스를 얻을 수도 있습니다. Perl 5.10의 기본 스위치와 완벽하게 호환되지 않으므로 소스 필터로 구현되므로 복잡한 구문이 필요할 때 항상 의도 한대로 작동하지 않기 때문에 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d155ec5cb50db186fa8a14b8502428201e840a22" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt;, can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f4302390c39dc69e8bb4ae56d84681737deb52" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library interfaces that have thread-aware versions (e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that correctly handle the multithreaded interaction with the Perl interpreter. This will happen transparently, the only thing you need to do is to instantiate a Perl interpreter.</source>
          <target state="translated">Perl 5.8부터 C / C ++ 레벨에서 Perl은 스레드 인식 버전 (예 : getpwent_r ())이있는 시스템 / 라이브러리 인터페이스를 프론트 엔드 매크로 (예 : getpwent ())로 펄 인터프리터와의 멀티 스레드 상호 작용을 올바르게 처리하는 방법을 알고 있습니다. . 이것은 투명하게 일어날 것입니다. Perl 인터프리터를 인스턴스화하는 것이 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d0ecdc5671ad43a21bb3ba4b49951928dc27fb67" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="translated">Perl 5.8.1부터 다른 Perl 실행은 다른 순서의 해시 키를 갖습니다. 보안 강화를 위해 변경되었습니다 . &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격을&lt;/a&gt; 참조하십시오 . 이는 데이터에 해시가 포함 된 경우 다른 Perl 실행에 서로 다른 Data :: Dumper 출력이 있음을 의미합니다. 다른 Perl 실행에서 동일한 Data :: Dumper 출력이 필요한 경우 환경 변수 PERL_HASH_SEED를 사용하십시오 ( &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;perlrun의 PERL_HASH_SEED&lt;/a&gt; 참조) . 이를 사용하면 이전 (플랫폼 별) 순서가 복원됩니다. 더 좋은 솔루션 은 Data :: Dumper 의 &lt;code&gt;Sortkeys&lt;/code&gt; 필터 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f68deda9f44fedf246c9591657da44f835e61c6d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;&quot;PERL_HASH_SEED&quot; in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b73ef5c7c43845a94f049a96a2982af7951ff5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.9.4 the following extra flags are added:</source>
          <target state="translated">Perl 5.9.4부터 다음과 같은 추가 플래그가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0f3b9a37d935e7c453cae03a9fc889658a8b375" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">Perl v5.6.0부터 Perl은 기본적으로 유니 코드를 처리 할 수 ​​있습니다. 그러나 Perl v5.8.0은 심각한 유니 코드 작업에 권장되는 첫 번째 릴리스입니다. 유지 관리 릴리스 5.6.1은 초기 유니 코드 구현의 많은 문제를 해결했지만 예를 들어 5.6.1의 정규식은 여전히 ​​유니 코드에서 작동하지 않습니다. 펄 v5.14.0 몇 개는 (예외는 일부 차이없이 원활 적분 유니 코드 지원이 (거의) 인 제 릴리스 &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; , 그 펄 5.16.0부터 고정된다). 이 원활한 지원을 활성화하려면 다음을 수행해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (당신이 경우 자동으로 선택되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상). &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조. (5.14는 또한 많은 버그를 수정하고 유니 코드 표준에서 벗어났습니다.)</target>
        </trans-unit>
        <trans-unit id="df97b58d295ae07b3c7e368fabefa9c327ce3a5a" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas. (There are a few exceptions. Firstly, some differences in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;quotemeta&lt;/a&gt; were fixed starting in Perl 5.16.0. Secondly, some differences in &lt;a href=&quot;perlop#Range-Operators&quot;&gt;the range operator&lt;/a&gt; were fixed starting in Perl 5.26.0. Thirdly, some differences in &lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt; were fixed started in Perl 5.28.0.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a20fa36c19a41cf13089d9b7e6cda76a07463" translate="yes" xml:space="preserve">
          <source>Starting from perl 5.7.1 perl uses the Solaris malloc, since the perl malloc breaks when dealing with more than 2GB of memory, and the Solaris malloc also seems to be faster.</source>
          <target state="translated">perl 5.7.1부터 perl은 2GB 이상의 메모리를 처리 할 때 perl malloc이 중단되고 Solaris malloc도 더 빠르기 때문에 Solaris malloc을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e6f60ae2145b9aa31e782db73fe39a61dbb6b373" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt; , the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt; , it determines the most-significant bit of a character.</source>
          <target state="translated">입력 문자열의 시작 부분부터 각 8- 튜플 문자는 1 문자 출력으로 변환됩니다. 형식 &lt;code&gt;b&lt;/code&gt; 로 8- 튜플의 첫 번째 문자는 문자의 최하위 비트를 결정합니다. &lt;code&gt;B&lt;/code&gt; 형식 을 사용하면 문자의 가장 중요한 비트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="924f79553c56797f30f757475a664dc8c52550ae" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt;, the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt;, it determines the most-significant bit of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a530103a351aa6cda54d5b0c4c2b630750302d" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt;, the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt;, it determines the most-significant nybble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca54402551e7931f104cb3acd73bb3d87fc7a43" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to pack(), each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt; , the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt; , it determines the most-significant nybble.</source>
          <target state="translated">템플릿의 처음부터 pack ()까지, 각 문자 쌍은 1 문자 출력으로 변환됩니다. 형식 &lt;code&gt;h&lt;/code&gt; 로 쌍의 첫 번째 문자는 출력 문자의 최하위 니블을 결정합니다. 형식 &lt;code&gt;H&lt;/code&gt; 로 가장 중요한 니블을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e0719e57793beb804762734f954a0430e8236ad0" translate="yes" xml:space="preserve">
          <source>Starting from the top, this says &lt;code&gt;$b&lt;/code&gt; is an SV. The scalar is an IV, which is capable of holding an integer or reference value. It has the &lt;code&gt;ROK&lt;/code&gt; flag set, meaning it is a reference (rather than an integer or string). Notice that Dump follows the reference and shows us what &lt;code&gt;$b&lt;/code&gt; was referencing. We see the same &lt;code&gt;$a&lt;/code&gt; that we found in the previous example.</source>
          <target state="translated">위에서부터 &lt;code&gt;$b&lt;/code&gt; 는 SV입니다. 스칼라는 정수 또는 참조 값을 보유 할 수있는 IV입니다. 이것은 보유 &lt;code&gt;ROK&lt;/code&gt; 이 기준 (아닌 정수 나 문자열)이며 즉, 플래그가 설정. Dump가 참조를 따르고 &lt;code&gt;$b&lt;/code&gt; 가 참조한 것을 보여줍니다 . 앞의 예에서 찾은 것과 동일한 &lt;code&gt;$a&lt;/code&gt; 를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0542c0de06c1b01762ccd40a6fe67b90b3556cde" translate="yes" xml:space="preserve">
          <source>Starting from version 5.8, Perl uses a builtin translation layer for text-mode files. This replaces the efficient well-tested EMX layer by some code which should be best characterized as a &quot;quick hack&quot;.</source>
          <target state="translated">버전 5.8부터 Perl은 텍스트 모드 파일에 내장 변환 레이어를 사용합니다. 이것은 효율적이고 잘 테스트 된 EMX 계층을 &quot;빠른 핵&quot;으로 가장 잘 특징 지워야하는 코드로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="889838782f9044eb1988a4e66547d5f47a179ecb" translate="yes" xml:space="preserve">
          <source>Starting in 5.28, changing locales on threaded builds is supported on systems that offer thread-safe locale functions. These include POSIX 2008 systems and Windows starting with Visual Studio 2005, and this module will work properly in such situations. However, on threaded builds on Windows prior to Visual Studio 2015, retrieving the items &lt;code&gt;CRNCYSTR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; can result in a race with a thread that has converted to use the global locale. It is quite uncommon for a thread to have done this. It would be possible to construct a workaround for this; patches welcome: see &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&quot;switch_to_global_locale&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52cca7c60b1d846e7ee0624e6dbe1baa1d2c524" translate="yes" xml:space="preserve">
          <source>Starting in 5.32, the Name, Name Aliases, and Named Sequences properties are allowed to be matched. They are considered to be a single combination property, just as has long been the case for &lt;code&gt;\N{}&lt;/code&gt;. Loose matching doesn't work in exactly the same way for these as it does for the values of other properties. The rules are given in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;. As a result, Perl doesn't try loose matching for you, like it does in other properties. All letters in names are uppercase, but you can add &lt;code&gt;(?i)&lt;/code&gt; to your subpattern to ignore case. If you're uncertain where a blank is, you can use &lt;code&gt; ?&lt;/code&gt; in your subpattern. No character name contains an underscore, so don't bother trying to match one. The use of hyphens is particularly problematic; refer to the above link. But note that, as of Unicode 13.0, the only script in modern usage which has weirdnesses with these is Tibetan; also the two Korean characters U+116C HANGUL JUNGSEONG OE and U+1180 HANGUL JUNGSEONG O-E. Unicode makes no promises to not add hyphen-problematic names in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac77222ae2e654fdac46266902dcc915cb8e811b" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; also can have an additional meaning (only) in patterns, namely to match a non-newline character. (This is short for &lt;code&gt;[^\n]&lt;/code&gt;, and like &lt;code&gt;.&lt;/code&gt; but is not affected by the &lt;code&gt;/s&lt;/code&gt; regex modifier.)</source>
          <target state="translated">Perl 5.12.0부터, &lt;code&gt;\N&lt;/code&gt; 은 또한 개행 문자와 일치하는 패턴에서 추가적인 의미 (단지)를 가질 수 있습니다. (이것에 대한 짧은 &lt;code&gt;[^\n]&lt;/code&gt; , 및 등 &lt;code&gt;.&lt;/code&gt; 하지만 영향을받지 않는다 &lt;code&gt;/s&lt;/code&gt; 정규식 개질제).</target>
        </trans-unit>
        <trans-unit id="2859a2d886c0e9aec6c1de9465ceff2207dfb72a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="translated">Perl 5.14 (및 부분적으로 Perl 5.12) 부터는 프로그램 시작 부분에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 어휘 범위 내에서이 문제가 발생하지 않아야합니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; 에서 자동으로 활성화 되거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 Perl 5.12 이상의 명령 행에서 &lt;code&gt;-E&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="df8245894479d7975ceddeb310b62137ac0e64fe" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;use feature ':5.12'&lt;/code&gt; or &lt;code&gt;use v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b056d808ccaa125ddd8cb5bd3248f668c64c977" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imnsx&lt;/code&gt;. Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt;) may follow the caret, so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2dad99d1883b55d274e9ecc2470180f982e800" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imnsx&lt;/code&gt;. Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt;) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8902a856b5fd88514da38f6d1ea437cef45dc91" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret, so</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 바로 다음에 &lt;code&gt;&quot;^&quot;&lt;/code&gt; (캐럿 또는 곡절 악센트)가 있습니까? &lt;code&gt;d-imsx&lt;/code&gt; 와 같은 속기 입니다. 모든 양수 플래그 ( &lt;code&gt;&quot;d&quot;&lt;/code&gt; 제외 )는 캐럿을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd982f589d8e87c6c46ce3117db1a952a4a3a29e" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 바로 다음에 &lt;code&gt;&quot;^&quot;&lt;/code&gt; (캐럿 또는 곡절 악센트)가 있습니까? &lt;code&gt;d-imsx&lt;/code&gt; 와 같은 속기 입니다. 플래그 ( &lt;code&gt;&quot;d&quot;&lt;/code&gt; 제외 )는 캐럿을 따라 재정의 할 수 있습니다. 그러나 빼기 부호는 합법적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8764da9a2d4e197710fd50d36bbe6c6ef6a3ac9" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14.0, regular expressions compiled within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; use Unicode rules even when executed or compiled into larger regular expressions outside the scope.</source>
          <target state="translated">Perl 5.14.0부터 &lt;code&gt;unicode_strings&lt;/code&gt; 범위 내에서 컴파일 된 정규 표현식은 범위 외부에서 더 큰 정규 표현식으로 실행되거나 컴파일 될 때에도 유니 코드 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="69cd047e088fdbefa20b4fff4c70feeb8034d880" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , as described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="translated">Perl 5.16.0부터는 &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta에&lt;/a&gt; 설명 된대로 &lt;code&gt;unicode_strings&lt;/code&gt; 범위 내에서 일관된 인용 규칙이 사용됩니다 . 그 전에 또는 범위를 벗어나면 127을 초과하는 코드 포인트는 UTF-8로 인코딩 된 문자열로 인용되지 않지만 바이트로 인코딩 된 문자열에서는 128-255 사이의 코드 포인트가 항상 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="18d82ac8aba251c121572f60699a2bf12308e978" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399f06c020d8cd6de2c45e4ca951de47d9647e70" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.18, there are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. Here's a complete list of the current ones affecting ASCII characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8e157579b8bab3ccd61e698c935bfec29a8f08" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.20, a hash slice operation with the % symbol is a variant of slice operation returning a list of key/value pairs rather than just values:</source>
          <target state="translated">Perl 5.20부터 % 기호가있는 해시 슬라이스 작업은 값이 아닌 키 / 값 쌍의 목록을 반환하는 슬라이스 작업의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="39e60469d5cdf9ceb960a075ac6c5b92f2cc1e99" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.26.0, the range operator on strings treats their lengths consistently within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;. Prior to that, or outside its scope, it could produce strings whose length in characters exceeded that of the right-hand side, where the right-hand side took up more bytes than the correct range endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c411e4acf4de658ce7555b24fb1288a04a3bbeb3" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is a fatal error to try to complement a string containing a character with an ordinal value above 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa44c6c3c091efdcacc965773935ea7f947644" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is illegal for bit operators, like &lt;code&gt;~&lt;/code&gt;, to operate on strings containing code points above 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05b2f43207fbc6b0a71ca28ad690738fd985132" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is now easy to detect strings that aren't script runs. Simply enclose just about any pattern like either of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e29afd35da622d839a7f0cbd5ae88b8a5f51e23" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, on multi-threaded perls compiled on systems that implement POSIX 2008 thread-safe locale operations, this function doesn't actually call the system &lt;code&gt;setlocale&lt;/code&gt;. Instead those thread-safe operations are used to emulate the &lt;code&gt;setlocale&lt;/code&gt; function, but in a thread-safe manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebaa36867a4be778f15993a9a2db66338883da5" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, this module is available even on systems that lack a native &lt;code&gt;nl_langinfo&lt;/code&gt;. On such systems, it uses various methods to construct what that function, if present, would return. But there are potential glitches. These are the items that could be different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e1eb3f09fae3aaaa4cf7976dd6db42da82227a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, this pragma may be used in &lt;a href=&quot;threads&quot;&gt;multi-threaded&lt;/a&gt; applications on systems that have thread-safe locale ability. Some caveats apply, see &lt;a href=&quot;#Multi-threaded&quot;&gt;&quot;Multi-threaded&quot;&lt;/a&gt; below. On systems without this capability, or in earlier Perls, do NOT use this pragma in scripts that have multiple &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; active. The locale in these cases is not local to a single thread. Another thread may change the locale at any time, which could cause at a minimum that a given thread is operating in a locale it isn't expecting to be in. On some platforms, segfaults can also occur. The locale change need not be explicit; some operations cause perl to change the locale itself. You are vulnerable simply by having done a &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af6703d45f3b80a1d7fa23b6e6ecb6c4049fc60" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28.0, the &lt;code&gt;split&lt;/code&gt; function with a pattern specified as a string containing a single space handles whitespace characters consistently within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;. Prior to that, or outside its scope, characters that are whitespace according to Unicode rules but not according to ASCII rules were treated as field contents rather than field separators when they appear in byte-encoded strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7e78b35743da5e79f86d77337042b624f1dcf2" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.30, it is possible to do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c1f2502a54e1fd7e5f8ea0c68c3e31e84a505f" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.32, you can specify a character by its name in regular expression patterns using &lt;code&gt;\p{name=...}&lt;/code&gt;. This is in addition to the longstanding method of using &lt;code&gt;\N{...}&lt;/code&gt;. The following summarizes the differences between these two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013197011e87f7e0633670e8b800c1024b759400" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16 in a very limited way, and more generally in v5.22, you can restrict which category or categories are enabled by this particular instance of the pragma by adding parameters to it. For example,</source>
          <target state="translated">Perl v5.16부터는 매우 제한적인 방식으로 시작하고보다 일반적으로 v5.22에서는 매개 변수를 추가하여 pragma의 특정 인스턴스에서 사용 가능한 카테고리를 제한 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d7be757a62548668bef82e6fa7932eb10efddb3b" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for quoting non-ASCII characters; the quoting of ASCII characters is unchanged.</source>
          <target state="translated">Perl v5.16부터 Perl은 비 ASCII 문자를 인용하기 위해 유니 코드 정의 전략을 채택했습니다. ASCII 문자의 인용은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a75aca801899de40f1e5f4fc3d561cb6af7bcdc4" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use
charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="translated">Perl v5.16부터는 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 시퀀스가 발생 하면 다른 인수와 함께 아직로드되지 않은 경우 &lt;code&gt;:full&lt;/code&gt; 및 &lt;code&gt;:short&lt;/code&gt; (아래 설명) 인수로이 모듈을 자동으로로드합니다 . 명명 된 유니 코드 문자를 문자열의 위치로 컴파일합니다. 이전 v5.16로, 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 이 사용을 활성화하는 데 필요한되었다. 그러나 v5.16 이전에는 &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; 형식으로 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 활성화하지 않았습니다 .)</target>
        </trans-unit>
        <trans-unit id="2febf15cd94e7fcad788accee9fc2d94365a32bb" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;use charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608b1e70a82457592a3e840a3bb2cb2b40f918ad" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except &lt;code&gt;LC_COLLATE&lt;/code&gt; is only partially supported; collation support is improved in Perl v5.26 to a level that may be sufficient for your needs (see &lt;a href=&quot;#Category-LC_COLLATE%3A-Collation%3A-Text-Comparisons-and-Sorting&quot;&gt;&quot;Category &lt;code&gt;LC_COLLATE&lt;/code&gt;: Collation: Text Comparisons and Sorting&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc88b853a6a300ebebd43ce48839b53ca6b33945" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except for &lt;code&gt;LC_COLLATE&lt;/code&gt; (use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; instead). If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">Perl v5.20부터 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 제외하고 UTF-8 로케일이 Perl에서 지원됩니다 ( 대신 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 사용). Perl v5.16 또는 v5.18이 있고 업그레이드 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="24c20bca7982b6c0163573088c845daca9bc60e3" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , ..., &lt;code&gt;\N{U+7F}&lt;/code&gt; . This range is all the printable characters that the ASCII character set contains.</source>
          <target state="translated">Perl v5.22부터는 대괄호 문자 클래스의 범위에 적용됩니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt; 라고하면 &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , .. ., &lt;code&gt;\N{U+7F}&lt;/code&gt; . 이 범위는 ASCII 문자 세트에 포함 된 모든 인쇄 가능한 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b54e661a1090defa2b2777581232122fccb99a2a" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt;, &lt;code&gt;\N{U+21}&lt;/code&gt;, ..., &lt;code&gt;\N{U+7F}&lt;/code&gt;. This range is all the printable characters that the ASCII character set contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23b660058cb3ee939b11052749bad9b7526e31f" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this is trivially changeable to work portably on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl v5.22부터는 ASCII 및 EBCDIC 플랫폼 모두에서 이식 가능하도록 간단하게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b643b4bf49444d908712fc4608ad821a201d28" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.26, if the modifier has a second &lt;code&gt;&quot;x&quot;&lt;/code&gt; within it, it does everything that a single &lt;code&gt;/x&lt;/code&gt; does, but additionally non-backslashed SPACE and TAB characters within bracketed character classes are also generally ignored, and hence can be added to make the classes more readable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d25eddbb4ffae5919e515185604e4ce1f21281" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.26, specifying &lt;code&gt;/xx&lt;/code&gt; changes the square-bracketed portions of a pattern to ignore tabs and space characters unless they are escaped by preceding them with a backslash. So, we could write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f981605ccbb39cb3202cced83d909060decc021" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.30, Perl detects Turkic locales by their behaviour, and seamlessly handles both types; previously only the non-Turkic one was supported. The name of the locale is ignored, if your system has a &lt;code&gt;tr_TR.UTF-8&lt;/code&gt; locale and it doesn't behave like a Turkic locale, perl will treat it like a non-Turkic locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad33022de79501f8101617222266c778da37687" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.32, an alternative to &lt;code&gt;\N{...}&lt;/code&gt; for full names is available, and that is to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e38118c6920f78946e8d31e17cb36ad4ee8bf0e" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.8.6 (&lt;code&gt;Encode&lt;/code&gt; version 2.0.1),</source>
          <target state="translated">Perl v5.8.6 ( &lt;code&gt;Encode&lt;/code&gt; 버전 2.0.1)부터</target>
        </trans-unit>
        <trans-unit id="474e1944b6ecbc8a507bc2e01a2a550b04aa62eb" translate="yes" xml:space="preserve">
          <source>Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and names that were formerly Perl extensions, and some additional ones that Perl did not previously accept. The list is getting too long to reproduce here, but you can get the complete list from the Unicode web site: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt;.</source>
          <target state="translated">유니 코드 6.1 및 Perl v5.16부터 유니 코드는 이전에 Perl 확장이었던 많은 약어 및 이름과 Perl이 이전에 승인하지 않은 추가 약어를 정의합니다. 목록을 여기에 재현하기에는 시간이 너무 오래 걸리지 만 유니 코드 웹 사이트 ( &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt)&lt;/a&gt; 에서 전체 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7ed0dc1ff9e9044e5149578e2503104831b9063" translate="yes" xml:space="preserve">
          <source>Starting in perl v5.30, wildcards are allowed in Unicode property values. See &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b155d3280c20b781dad3393cccf04005ee9e4a0f" translate="yes" xml:space="preserve">
          <source>Starting in the 5.9.x development version of perl you can &lt;code&gt;use re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818df47ef2f0fcf2a87de97f12babb967ed1fcfb" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt; , but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. (If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into.) The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;).</source>
          <target state="translated">v5.20부터 Perl은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 에 대해 UTF-8 로케일을 지원하지만 그렇지 않으면 Perl은 ISO 8859 시리즈와 같은 1 바이트 로케일 만 지원합니다. 이것은 예를 들어 아시아 언어와 같은 넓은 문자 로케일이 잘 지원되지 않음을 의미합니다. 플랫폼에 Perl v5.22부터 &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl이&lt;/a&gt; 이러한 로케일을 감지하는 기능이있는 경우 Perl은 로케일이 전환 될 때마다 &lt;code&gt;locale&lt;/code&gt; 경고 카테고리를 사용하여 기본적으로 경고를 설정 합니다. UTF-8 로케일 지원 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일이 전혀 유효하지 않은 것처럼 실제로 완전한 유니 코드 동작이기 때문에 실제로 POSIX 로케일의 상위 세트입니다 (오염을 제외하고; &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt; 참조).). POSIX 로케일, 심지어 UTF-8 로케일은 문자의 대소 문자를 변경하면 둘 이상의 문자로 확장 될 수 있다는 아이디어와 같이 유니 코드의 특정 개념이 부족합니다. UTF-8 로케일의 Perl은 확장을 제공합니다. v5.20 이전에 Perl은 ISO 8859-1과 같은 일부 플랫폼에서 일부 제한 사항이 있고 &quot;C&quot;로케일과 같은 다른 플랫폼에서 UTF-8 로케일을 처리했습니다. 릴리스 v5.16 및 v5.18의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; 사용하여 이에 대한 임시 해결책으로 사용할 수 있습니다 ( &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="abf931cf0a232d610a20a5327eae490434a5d7a8" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt;, but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. Use of these locales may cause core dumps. If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into. The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;use locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0b3fbd50ff716e496a38d1dbfc0634c6a5772b" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">로케일이 UTF-8 인 경우 v5.20부터 Perl은 완전한 유니 코드 규칙을 사용합니다. 그렇지 않으면이 체계에 결함이 있으며,이 경우 255/256 경계를 넘는 변경 사항은 잘 정의되지 않습니다. 예를 들어, 유니 코드 규칙에서 소문자 대문자 대문자 SHARP S (U + 1E9E)는 U + 00DF (ASCII 플랫폼의 경우)입니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (v5.20 이전 또는 UTF-8 로케일이 아님) U + 1E9E의 소문자는 현재 로케일에서 0xDF가 작은 문자 샤프 S가 아닐 수 있으며 Perl이 해당 문자를 알 수있는 방법이 없기 때문에 로케일에도 존재하며 코드 포인트가 훨씬 적습니다. Perl은 255/256 경계가 교차되는 모든 인스턴스에 대해 거의 항상 입력 문자가 변경되지 않고 255보다 큰 결과를 반환하며 v5.22부터는 &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;로케일&lt;/a&gt; 경고를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="cf1eee1ccf148c85a77132cb28b023038cea490f" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">로케일이 UTF-8 인 경우 v5.20부터 Perl은 완전한 유니 코드 규칙을 사용합니다. 그렇지 않으면이 체계에 결함이 있으며,이 경우 255/256 경계를 넘는 변경 사항은 잘 정의되지 않습니다. 예를 들어, 유니 코드 규칙에서 소문자 대문자 대문자 SHARP S (U + 1E9E)는 U + 00DF (ASCII 플랫폼의 경우)입니다. 그러나 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (v5.20 이전 또는 UTF-8 로케일이 아님) U + 1E9E의 소문자는 현재 로케일에서 0xDF가 작은 문자 샤프 S가 아닐 수 있으며 Perl이 해당 문자를 알 수있는 방법이 없기 때문에 로케일에도 존재하며 코드 포인트가 훨씬 적습니다. Perl은 255/256 경계가 교차되는 모든 인스턴스에 대해 거의 항상 입력 문자가 변경되지 않고 255보다 큰 결과를 반환하며 v5.22부터는 &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;로케일&lt;/a&gt; 경고를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="fc33dddc57e009befe8b624c019e0d98b1679536" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;use locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged), for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can%27t-do-%25s%28%22%25s%22%29-on-non-UTF-8-locale%3B-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c762f587a88d06d3ee0d5c6c5c66f9e2aa3c2b6" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt; , but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt; , and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="translated">v5.22부터는 Perl은 ASCII 인쇄 가능 문자 (및 &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\n&lt;/code&gt; )를 예상과 다른 클래스로 재정의하는 로케일로 전환 할 때 기본적으로 경고 합니다. 이는 예를 들어 CCSID 1047 시스템의 CCSID 0037 로케일이 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 이동하는 EBCDIC 플랫폼에서만 최신 로케일에서만 발생하지만 ISO 646 및 기타 7 비트 로케일이있는 ASCII 플랫폼에서 발생할 수 있습니다. 본질적으로 더 이상 사용되지 않습니다. 프로그램에서 사용되는 Perl의 기능에 따라 여전히 작동 할 수 있습니다. 예를 들어 위의 예에서 &lt;code&gt;&quot;|&quot;&lt;/code&gt; &lt;code&gt;\w&lt;/code&gt; 가된다이 문제가 발생하면 정규 표현식이 없어도 프로그램이 여전히 제대로 작동 할 수 있습니다. 경고에는 부정적인 영향을 줄 수있는 모든 문자가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="045ba6195cde654f0e61c6b886bb35824c0a5a9a" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt;, but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt;, and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ce7d231c27d2be8f1b1d8928ca5c39bf4aed51" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</source>
          <target state="translated">v5.22부터는 정규 표현식 패턴 문자 범위의 끝점으로 유니 코드 코드 포인트를 사용할 수 있으며 범위에는 해당 엔드 포인트 사이에있는 모든 유니 코드 코드 포인트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6a0d77e9e3a9155e3031928b6e984c64d451ee78" translate="yes" xml:space="preserve">
          <source>Starting in v5.32, you can also use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd5e5803935bbb6537a6c17faa83c7fdd9ffba0" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt; . This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; use that encoding.</source>
          <target state="translated">v5.8.6부터 인코딩 이름은 &lt;code&gt;:locale&lt;/code&gt; 일 수 있습니다 . 이는 인코딩이 현재 로케일에서 가져오고 pragma에 의해 하드 코딩되지 않았 음을 의미합니다. 스크립트는 실제로 정확히 하나의 인코딩으로 만 인코딩 될 수 있으므로이 옵션은 위험합니다. 스크립트 자체가 ASCII로 작성된 경우에만 의미가 있으며 스크립트를 실행할 때 사용할 수있는 모든 로케일이 ASCII의 상위 세트입니다. 즉, 스크립트 자체는 변경되지 않지만 I / O 핸들에 지정된 인코딩이 추가되었으며 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 와 같은 작업이 해당 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8cbc9aa4d02eb518e769236727e93c4edd075393" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt;. This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;chr&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; use that encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8eb72d81f87d6a7a0f9e91198c8aa2adc48dbed" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt; . When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="translated">버전 5.21.2 년부터 실험로 구축 perls 정의 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 각 연산에 대한 추가에게 별도의 부울 플래그를 &lt;code&gt;op_moresib&lt;/code&gt; . 설정되지 않은 경우 &lt;code&gt;OpSIBLING&lt;/code&gt; 체인 에서 마지막 op임을 나타냅니다 . 이렇게하면 마지막 형제 의 &lt;code&gt;op_sibling&lt;/code&gt; 필드가 해제되어 상위 op를 가리 킵니다. 이 빌드에서는 해당 필드의 이름이 &lt;code&gt;op_sibparent&lt;/code&gt; 로 바뀌어 공동 역할을 반영합니다. 매크로 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 이 특수한 동작을 래핑하고 항상 마지막 형제에서 NULL을 반환합니다. 이 빌드에서는 &lt;code&gt;op_parent(o)&lt;/code&gt; 함수를 사용하여 모든 op의 부모를 찾을 수 있습니다. 따라서 호환성을 위해 항상 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 사용해야합니다직접 &lt;code&gt;op_sibling&lt;/code&gt; 에 액세스하는 대신 매크로 .</target>
        </trans-unit>
        <trans-unit id="fee6bf661a5a6cbe9e9f6e7dc3357f58ab23b1f3" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt;. When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6641cb9032ef109574e28893d667801fcaa3e2c6" translate="yes" xml:space="preserve">
          <source>Starting with 2.10, the special module name &lt;code&gt;Unicode&lt;/code&gt; refers to the version of the Unicode Character Database bundled with Perl.</source>
          <target state="translated">2.10부터 특수 모듈 이름 &lt;code&gt;Unicode&lt;/code&gt; 는 Perl과 함께 번들로 제공되는 유니 코드 문자 데이터베이스의 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aca846c8be32988d259af2e704c9972784ca9b87" translate="yes" xml:space="preserve">
          <source>Starting with AutoLoader 5.73, you can call the &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; function with the fully-qualified name of the function to load from its</source>
          <target state="translated">AutoLoader 5.73부터는 &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; 함수를 호출하여 정규화 된 함수 이름으로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe6dc30d7e458c682ee2ffab73f38deab13b705d" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Two steps to getting that module's typemaps available in your code:</source>
          <target state="translated">ExtUtils :: ParseXS 버전 3.13_01부터 (perl 5.16 이상이 제공됨) 여러 CPAN 배포간에 유형 맵 코드를 공유하는 것이 다소 쉽습니다. 일반적인 아이디어는 특정 API를 제공하는 모듈로 공유하고 종속 모듈이이를 빌드 요구 사항으로 선언하고 XS로 유형 맵을 가져 오는 것입니다. CPAN에서 이러한 유형 맵 공유 모듈의 예는 &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; 입니다. 코드에서 해당 모듈의 타입 맵을 사용할 수있게하는 두 단계 :</target>
        </trans-unit>
        <trans-unit id="c7a9329439741d22826499b7e8ccc62b257e0036" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt;. Two steps to getting that module's typemaps available in your code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f964cabb5662a6c495bdc0c921d6b311abc6ad4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9212af4220a7c7e6998749dd4723a25f0d7eab4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="translated">Perl 5.10부터 &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; 및 &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; 는 표준 배포판의 일부이므로 다음과 같이 할 수 있다고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97eea9254558fb3fd8f17c44c41b369b3648d850" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="translated">Perl 5.10.0부터는 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 형식 및 &lt;code&gt;()&lt;/code&gt; 그룹 과 함께 정수 및 부동 소수점 형식 에 각각 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 엔디안 수정자를 사용하여 각각 빅 또는 리틀 엔디안 바이트 순서를 적용 할 수 있습니다. 이러한 수정자는 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 부호있는 정수, 64 비트 정수 또는 부동 소수점 값을 다루지 않는 방법에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="91887288c16197195e2b34bfb5cb24e865412909" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee36782903bc57420ba5e155b45524572f22583" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt; :</source>
          <target state="translated">Perl 5.12부터 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 은 32 비트 기반 시간이 오버플로되는 2038 년 1 월 19 일 03:14:08 이후의 날짜를 처리 할 수 ​​있습니다. 여전히 32 비트 &lt;code&gt;perl&lt;/code&gt; 에 대한 경고가 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06064bcbd3db9848f0c8a7c119116ec7dded2dac" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3547c4def41d12fec193f972e11bcb976215d4c4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl 5.12부터 추가 정수 매개 변수가 전달됩니다. 매개 변수없이 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 를 호출 하면 0이됩니다 . &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 에 파일 핸들이 매개 변수로 제공되는 경우 &lt;code&gt;1&lt;/code&gt; , 예 : &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ; 그리고 &lt;code&gt;2&lt;/code&gt; 동점 파일 핸들이있는 아주 특별한 경우 &lt;code&gt;ARGV&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 예를 들어, 빈 매개 변수 목록 불려 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="052780286d8ffb3a2e7d500cfc57d223e2ef8ffc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;eof&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;eof&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;eof(FH)&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;eof&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3385173ff54b55e840ed45e4ab6e0da31d97fba8" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="translated">Perl 5.14부터는 부모가 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; 신호를받은 모든 자식이 자동으로 기다리지 않고 자식이 I / O를 차단하고 신호를받지 못하는 경우 교착 상태를 피합니다.</target>
        </trans-unit>
        <trans-unit id="2f071da8b4fbf9d03d4174f4254c8ac70323e8cb" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;kill('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de3712cf0c49e19f3e9d37735c0e97d4b521ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">5.14 펄부터 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 저주받은 해시 또는 어레이에 대한 레퍼런스를 보유해야 스칼라 EXPR를 취할 수있다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818e24d28a7aaf2cbc1a6702710734a070d06698" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">5.14 펄부터 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 저주받은 해시 또는 어레이에 대한 레퍼런스를 보유해야 스칼라 EXPR를 취할 수있다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fa5cd516760576150d0418affb48e1abda4a5b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 여기에는 축복되지 않은 해시 또는 배열에 대한 참조가 포함되어야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b92aff600824b9c22651f1e75f3d65c35db8ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bb8994fa6804d1b79f779661eabab22fa4d596" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며,이 값은 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10642e156a8402673021a377c62441722a9d8a63" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. 이러한 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5169411fd5bf69d929b67dfac03c2c64e43db230" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7439a015aa95224d62eb3bbca9a133f540e69f0f" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e76a783b752b5dc19b6f3c4b3d934de488d5e6" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 해시 또는 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47398b3574f050221d9d55302c39ea94e67781b9" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 여기에는 축복되지 않은 해시 또는 배열에 대한 참조가 포함되어야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fac0b7eb35a23345be196afebeca8562c183fce3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427fc5d0e35cec380d803ece997f22ba459e7c3c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며,이 값은 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0a12ea19c52c77b676bcf9fb786b8629096b3dc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. 이러한 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3217cf42c0331e4a0cfa6eb7dd493042a8c7e44" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f153998e2fa782a330b974d3d6a495fc8735ee" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3eb26fa45077fda36157e3c2cd25a74327fbf5e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 해시 또는 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de83fa8042912e9f6ddf571cde7008f435d64f25" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a5d1f49a9fb5c5245141f7dfc7c9150a868c0e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99313bdb1dd7941c61f4079e6582dd0df5ded04d" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#pop-ARRAY&quot;&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05abb4efe9535e153e305c31af2507782337868" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#push-ARRAY%2CLIST&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b401da5a4481ae0700b1ffba5e3e1def6bf593b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#shift-ARRAY&quot;&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ee1f2fd5baa405873ebfdb113cbcd1a850a5c7" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04cd81960709d263997df907683fe183f516f9c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#unshift-ARRAY%2CLIST&quot;&gt;&lt;code&gt;unshift&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbf87d17e9cfc89d47e4dceb5bb03787d175d3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84114b43a4e1c51016947fa39587027a5c42b337" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.16, you can embed typemaps into your XS code instead of or in addition to typemaps in a separate file. Multiple such embedded typemaps will be processed in order of appearance in the XS code and like local typemap files take precedence over the default typemap, the embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The syntax for embedded typemaps is</source>
          <target state="translated">Perl 5.16부터는 유형 맵 대신 또는 별도의 파일에 유형 맵을 추가하여 XS 코드에 유형 맵을 포함시킬 수 있습니다. XS 코드에서는 이러한 여러 내장 된 유형 맵이 순서대로 처리되며 로컬 유형 맵 파일이 기본 유형 맵보다 우선하므로 내장 된 유형 맵은 TYPEMAP, INPUT 및 OUTPUT 스탠자의 이전 정의를 겹쳐 쓸 수 있습니다. 임베디드 타입 맵의 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ead2268f227644c92e6fae21c9b2bbc1c3977d01" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8, a macro framework has been defined to allow static data to be safely stored in XS modules that will be accessed from a multi-threaded Perl.</source>
          <target state="translated">Perl 5.8부터는 멀티 스레드 Perl에서 액세스 할 XS 모듈에 정적 데이터를 안전하게 저장할 수 있도록 매크로 프레임 워크가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="83f897274d9417a81431b1cfc87771e6f6b3c937" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8.1 strict is strict about its restrictions: if unknown restrictions are used, the strict pragma will abort with</source>
          <target state="translated">Perl 5.8.1부터 엄격은 제한 사항에 대해 엄격합니다. 알 수없는 제한이 사용되면 엄격한 pragma가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4c86c42abf281eff02c433a98ecba5908f6fea66" translate="yes" xml:space="preserve">
          <source>Starting with Solaris 8, perl5.00503 (or higher) is supplied with the operating system, so you might not even need to build a newer version of perl at all. The Sun-supplied version is installed in /usr/perl5 with</source>
          <target state="translated">Solaris 8부터는 perl5.00503 이상이 운영 체제와 함께 제공되므로 최신 버전의 perl을 전혀 구축하지 않아도됩니다. Sun에서 제공 한 버전은 / usr / perl5에</target>
        </trans-unit>
        <trans-unit id="070cbbea94d8e9dec2f41e08f125528dd6a6e9b2" translate="yes" xml:space="preserve">
          <source>Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for the eu_ES locale (Basque-Spain). In previous releases of Perl, this resulted in failures in the</source>
          <target state="translated">Tiger (Mac OS X 10.4)부터 Apple은 eu_ES 로켈 (Basque-Spain)에 대한 깨진 로켈 파일을 제공했습니다. 이전 버전의 Perl에서는 이로 인해 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="0811928afaca739fa817229f5f4a0d0397bc7c2a" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt; .</source>
          <target state="translated">릴리스 1.23_03부터 스칼라 목록 - 백분율입니다 &lt;b&gt;항상&lt;/b&gt; XS를 구현을 사용하지만, 이전 버전과의 호환성을 위해, 우리는 여전히 발송 &lt;code&gt;List::Util::XS&lt;/code&gt; 단지로드 모듈 &lt;code&gt;List::Util&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd623545d3ee1fd614905389b9ae3f566a5c0eda" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f31afb43ed5a01839f8ddc750e5dd35f48c3a6c" translate="yes" xml:space="preserve">
          <source>Starting with this section, we will be discussing Perl's set of</source>
          <target state="translated">이 섹션부터는 Perl의</target>
        </trans-unit>
        <trans-unit id="351709654314c24c7e4828574de12d19b419fe3b" translate="yes" xml:space="preserve">
          <source>Starting with version 2, the specification document is part of the CPAN-Meta distribution and will be published on CPAN as &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a60279d2b084f61a9ca16d8326eb786bc2e1ba" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef231992030ec09e2d04d1b4b88e1196c802a84" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;b&gt;BerkeleyDB&lt;/b&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;b&gt;BerkeleyDB&lt;/b&gt;.</source>
          <target state="translated">버전 2.x부터 Berkeley DB는 내부 잠금을 지원합니다. 이것에 대한 동반 모듈 인 &lt;b&gt;BerkeleyDB&lt;/b&gt; 는이 잠금 기능에 대한 인터페이스를 제공합니다. 당신은 버클리 DB 데이터베이스를 잠금에 관하여 심각한 경우에, 나는 강력하게 사용하는 것이 좋습니다 &lt;b&gt;버클리을&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ddaaadcc9b4e10884d35d5140782f71785a028" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6299a2f62ed0797f2e4ca75150d013801fc49f" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">try 블록을 시작합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79ce33706ca0540aaf9d8ed291d64bf45fad0cd4" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Startup</target>
        </trans-unit>
        <trans-unit id="6991439e4716de488447c6e2c2f9b1970b90a8e3" translate="yes" xml:space="preserve">
          <source>Stashes and Globs</source>
          <target state="translated">스 태쉬와 글로브</target>
        </trans-unit>
        <trans-unit id="d798831840bb11ab5bf25cf6beacc1e88e0ccd5f" translate="yes" xml:space="preserve">
          <source>State Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf91ec4328cf0ba3defd8522962fa33e41a1740" translate="yes" xml:space="preserve">
          <source>State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; 명령을 위한 상태 저장소 .</target>
        </trans-unit>
        <trans-unit id="ed2cb72d0aaac69d6842c67515cf3bf802a6b33a" translate="yes" xml:space="preserve">
          <source>Statement Modifiers</source>
          <target state="translated">명령문 수정 자</target>
        </trans-unit>
        <trans-unit id="92fe71f129a3152d601e68e5cf094d2e72591e9b" translate="yes" xml:space="preserve">
          <source>Statement unlikely to be reached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddbc09b1ca4e7855762d5787c6c0d7a3595a8af" translate="yes" xml:space="preserve">
          <source>Static Linking of a new Perl Binary</source>
          <target state="translated">새로운 Perl 바이너리의 정적 링크</target>
        </trans-unit>
        <trans-unit id="3c5f15db40f98d51818ecdf0034d37509667528b" translate="yes" xml:space="preserve">
          <source>Static functions might not be visible for the backtrace.</source>
          <target state="translated">역 추적에 정적 기능이 보이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8ab9355e9f77bfc04d09779d25ce6944605b91" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously.</source>
          <target state="translated">다운로드 통계는 크기와 기간에 따라 동시에 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5b62492ca830ebc3f7a3384ab3714a073b9f3f35" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously. Setting this to zero or negative disables download statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5610cd01f9a3d6080e798d67334a100aa1573c90" translate="yes" xml:space="preserve">
          <source>Status 1 overrides status 2. If you want unambiguous results, call &lt;b&gt;podchecker&lt;/b&gt; with one single argument only.</source>
          <target state="translated">상태 1은 상태 2보다 우선합니다. 명확한 결과를 원하면 하나의 인수만으로 &lt;b&gt;podchecker&lt;/b&gt; 를 호출 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="187236d960db5eb4ad8363cf8f2f9b1ddb6ac5e1" translate="yes" xml:space="preserve">
          <source>Stdio class buffering options.</source>
          <target state="translated">Stdio 클래스 버퍼링 옵션.</target>
        </trans-unit>
        <trans-unit id="60a9d23beb62cbe40cee43c7f38898ee6c1f97c7" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">스테 펜 뮬러 &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d59ce5418f2072a961fa75b41a54fbc928b69c82" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &lt;code&gt;&amp;lt;smueller@cpan.org&lt;/code&gt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c982c59dd847ba297d8467bd252ba58dd872a85c" translate="yes" xml:space="preserve">
          <source>Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67aeabbbe7f975f118f5118824dfb5a83bb31c11" translate="yes" xml:space="preserve">
          <source>Step-by-step: Distributing your module</source>
          <target state="translated">단계별 : 모듈 배포</target>
        </trans-unit>
        <trans-unit id="1a565c4552b2edcc3b1a58d76fe5018ccb0e6a32" translate="yes" xml:space="preserve">
          <source>Step-by-step: Making the module</source>
          <target state="translated">단계별 : 모듈 만들기</target>
        </trans-unit>
        <trans-unit id="481a4d002beceae3935eab8245f4c76879540359" translate="yes" xml:space="preserve">
          <source>Step-by-step: Preparing the ground</source>
          <target state="translated">단계별 : 지상 준비</target>
        </trans-unit>
        <trans-unit id="80427e23cbb5abd94ca5e55445014873b52c64b8" translate="yes" xml:space="preserve">
          <source>Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, based on an earlier version by Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, with contributions from Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael Garcia-Suarez.</source>
          <target state="translated">Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;의 이전 버전에 기반한 Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;는 Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons 및 Rafael Garcia-Suarez.</target>
        </trans-unit>
        <trans-unit id="6a244b340bceacb4b7643a7f28401322b0f43369" translate="yes" xml:space="preserve">
          <source>Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</source>
          <target state="translated">Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="406bdac466755debe16970475ad1ba98d0b486e3" translate="yes" xml:space="preserve">
          <source>Stepping through code</source>
          <target state="translated">코드 스테핑</target>
        </trans-unit>
        <trans-unit id="f13a1be70942b94ceb5c4947f5cad9efec256df0" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time, without descending into functions.</source>
          <target state="translated">함수로 내려 가지 않고 한 번에 한 줄씩 프로그램을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="67e08e5dee051e0626b0f262d208037e870d3ac2" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time.</source>
          <target state="translated">한 번에 한 줄씩 프로그램을 단계별로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="44dfc13e25f20c2b72056096edf2fa584b23e680" translate="yes" xml:space="preserve">
          <source>Steve Grazzini &amp;lt;steve.grazzini@grantstreet.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18c11d1612cf243a4188b75a5a32a4030b759d2" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;</source>
          <target state="translated">스티브 헤이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="378237399a39a01265203b3e7167eea75f75c0c4" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;steve.m.hay@googlemail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fe4c0fd5295a5323e60434a55f5b50b8297659" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d16db78589f14f29e83bbd762e7ffb3c9579828" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="translated">Steve Lembark는 자신의 YAPC :: NA 2009 talk &quot;Perly Linked Lists&quot;( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ) 에서 세부 사항을 살펴 봅니다. 그의 &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList :: Single&lt;/a&gt; 모듈 만 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="09652192134371fdefcd293d5003ff83e32ed6ed" translate="yes" xml:space="preserve">
          <source>Steve Peters &amp;lt;steve@fisharerojo.org&amp;gt;</source>
          <target state="translated">스티브 피터스 &amp;lt;steve@fisharerojo.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d6ea163d8063bfc57b0256f3178b768eac364c1" translate="yes" xml:space="preserve">
          <source>Steve Purkis</source>
          <target state="translated">스티브 퍼 키스</target>
        </trans-unit>
        <trans-unit id="9efb7766602083380f01f9cadb6f278fbfabf5e5" translate="yes" xml:space="preserve">
          <source>Steve Purkis &amp;lt;spurkis@cpan.org&amp;gt;</source>
          <target state="translated">스티브 퍼 키스 &amp;lt;spurkis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2200943829d703ee08a178c2eb1eee2c0a806988" translate="yes" xml:space="preserve">
          <source>Steve Purkis.</source>
          <target state="translated">스티브 퍼 키스.</target>
        </trans-unit>
        <trans-unit id="270c172269bbb0672801106f89223f66575337c6" translate="yes" xml:space="preserve">
          <source>Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt; for his help and patience with re-writing this manpage.</source>
          <target state="translated">이 맨 페이지를 다시 작성하는 데 도움과 인내심을 갖고있는 Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="3a70ee5e8fb61558310f5b5e31b73a3d007c0de0" translate="yes" xml:space="preserve">
          <source>Still another problem is that this approach can lead to two code points meaning the same character. Thus in a Greek locale, both U+03A7 and U+00D7 are GREEK CAPITAL LETTER CHI.</source>
          <target state="translated">또 다른 문제점은이 접근법이 동일한 문자를 의미하는 두 개의 코드 포인트로 이어질 수 있다는 것입니다. 따라서 그리스어 로케일에서 U + 03A7과 U + 00D7은 모두 녹색 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="8328b23c2df12839f29c28c4eca38fd0aaace45d" translate="yes" xml:space="preserve">
          <source>Still another use is to maintain visual space between &lt;code&gt;=item&lt;/code&gt; lines. If you specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f032a03c23ac64e26ed67dff94c5b968b51897fa" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548ad6711bf4d2c2e72ae86a234fd3904bec68fd" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.05</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42108b0060916a9925408d666ac09829728230ed" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.11</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c382741891bd1d6f7e460709510a9d80509ec7fa" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.20</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee45fe089bcfb256a94238e7233dca4c3a45655" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.3.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0f25affc6234202644d5b637ab1fbe92fe3712" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6880cdcd0506151ea51b1d4e727ce16ab7512631" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.373</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3165fead8117026ccedeeae5459ce4da4396860" translate="yes" xml:space="preserve">
          <source>Still broken in version: 0.052</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3eea18c3547245e8ba9bb10ace527c065a868d" translate="yes" xml:space="preserve">
          <source>Still in Settings, in Channel Update, select Beta Channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa5a1bd92d7066216395c95a296195ffe2e0f16" translate="yes" xml:space="preserve">
          <source>Stolen from File::Path::Expand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6682620d81182203397e365b84fecf9cd43d1829" translate="yes" xml:space="preserve">
          <source>Stop logging each disk request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bc7a84f86b7c98bba879166a64bc5b045625fd" translate="yes" xml:space="preserve">
          <source>Stops running tests as &quot;TODO&quot; tests. This method is fatal if called without a preceding &lt;code&gt;todo_start&lt;/code&gt; method call.</source>
          <target state="translated">&quot;TODO&quot;테스트로 테스트 실행을 중지합니다. 이 &lt;code&gt;todo_start&lt;/code&gt; 메소드 호출 없이 호출되면이 메소드는 치명적 입니다.</target>
        </trans-unit>
        <trans-unit id="45b0f8b6273dfd6e7997a4038c99b48d40e17dae" translate="yes" xml:space="preserve">
          <source>Storable</source>
          <target state="translated">Storable</target>
        </trans-unit>
        <trans-unit id="46f9f6e335231e1456d3ba18bd5a505213eb74c6" translate="yes" xml:space="preserve">
          <source>Storable - persistence for Perl data structures</source>
          <target state="translated">저장 가능-Perl 데이터 구조에 대한 지속성</target>
        </trans-unit>
        <trans-unit id="1630856d50b3ec9af87960aa33400ccd3dc094bd" translate="yes" xml:space="preserve">
          <source>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</source>
          <target state="translated">Storable은 이제 정수 크기에 대한 정보가있는 파일 헤더에서 읽고 쓰도록 변경되었습니다. 읽히는 오래된 파일이 32 또는 64 비트 정수 (동일한 헤더를 가짐)로 쓰여 졌는지 감지 할 수 없으므로 올바른 하위 호환성 모드로 자동 전환 할 수 없습니다. 따라서이 Storable의 기본값은 새롭고 올바른 동작입니다.</target>
        </trans-unit>
        <trans-unit id="714a2ccbafbac0389af167e01df326cf6b8a78ff" translate="yes" xml:space="preserve">
          <source>Storable magic</source>
          <target state="translated">저장 가능한 마술</target>
        </trans-unit>
        <trans-unit id="dfd98121663ee3170e7a7e6a0d89a8a9dfe033b8" translate="yes" xml:space="preserve">
          <source>Storable now has experimental support for storing regular expressions, but there are significant limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7182df5560db2bb6b5167976e453bb5798e3130f" translate="yes" xml:space="preserve">
          <source>Storable provides you with a &lt;code&gt;dclone&lt;/code&gt; interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</source>
          <target state="translated">Storable은 중간 스칼라를 생성하지 않고 대신 일부 내부 메모리 공간에서 구조를 정지시킨 다음 즉시 해동 시키는 &lt;code&gt;dclone&lt;/code&gt; 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="70fb12ce1748ed7f4a137be836ce41aa365bbd68" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Use eval {} to trap those exceptions.</source>
          <target state="translated">Storable은 &quot;예외&quot;패러다임을 사용합니다. 이는 실패 해결 방법을 시도하지 않습니다. 문제가 발생하면 호출자의 관점에서 예외가 생성됩니다 ( &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; 및 &lt;code&gt;croak()&lt;/code&gt; ). eval {}을 사용하여 해당 예외를 트랩하십시오.</target>
        </trans-unit>
        <trans-unit id="efb225f838cb012d7da5a2492afd60f053bbc61a" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt;). Use eval {} to trap those exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531ca0b8b45f41c9f0b1aa246372790831675baa" translate="yes" xml:space="preserve">
          <source>Storable was written by Raphael Manfredi</source>
          <target state="translated">Storable은 Raphael Manfredi에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f13ce5cb38e462f6f7f68a313f75016b704439f" translate="yes" xml:space="preserve">
          <source>Storable will throw an exception if a frozen regular expression cannot be thawed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e864254e3dece2f3614748bd8acc66ad85caaa" translate="yes" xml:space="preserve">
          <source>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</source>
          <target state="translated">Storable은 Storable을 빌드 한 (네트워크 순서로 쓰지 않을 때) C 컴파일러에 대한 다양한 C 언어 유형의 크기를 포함하는 파일 헤더를 작성하며 Storable이 작성한 파일을 동일한 (또는 호환 가능한) 아키텍처가 아닌로드하지 않습니다. 파일의 다양한 필드 크기가 C 언어 유형의 크기로 제공되므로 다른 아키텍처에서 작성된 파일이 호환되지 않기 때문에이 검사 및 기계 바이트 순서 검사가 필요합니다. 이것은 속도를 높이기 위해 수행됩니다. (네트워크 순서로 쓸 때 모든 필드는 표준 길이로 작성되므로 완전한 인터 워킹이 가능하지만 읽고 쓰는 데 시간이 더 걸립니다)</target>
        </trans-unit>
        <trans-unit id="fcaa72ed14ae844e5cba322adeff102b58e7d72e" translate="yes" xml:space="preserve">
          <source>Store (method 0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4150d3a5cc43231c993765dececd1a150bb52a3d" translate="yes" xml:space="preserve">
          <source>Store Memoized data in Storable database</source>
          <target state="translated">저장 가능한 데이터베이스에 메모 된 데이터 저장</target>
        </trans-unit>
        <trans-unit id="92a651d3dc16aed75ba857e2f774b7e083ba7965" translate="yes" xml:space="preserve">
          <source>Store and re-use state information about distributions between CPAN.pm sessions?</source>
          <target state="translated">CPAN.pm 세션 간 배포에 대한 상태 정보를 저장하고 재사용합니까?</target>
        </trans-unit>
        <trans-unit id="2c71530924851d1b8827aef4994b16eb515c4e61" translate="yes" xml:space="preserve">
          <source>Store data</source>
          <target state="translated">데이터 저장</target>
        </trans-unit>
        <trans-unit id="b25c722ad4f1fce5bbbe8fc35b0030d7d69ef919" translate="yes" xml:space="preserve">
          <source>Store datum</source>
          <target state="translated">데이텀 저장</target>
        </trans-unit>
        <trans-unit id="8f37eea7a30e3775bbbbb580f43dfdd3bec41576" translate="yes" xml:space="preserve">
          <source>Store the results of a test.</source>
          <target state="translated">테스트 결과를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="389cd56c2ab90c83d09e93be1e21e43d82460448" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;$value&lt;/code&gt; in the gzip OS header field. A number between 0 and 255 is valid.</source>
          <target state="translated">gzip OS 헤더 필드에 &lt;code&gt;$value&lt;/code&gt; 를 저장 합니다. 0에서 255 사이의 숫자가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b39d714bdc1e95f53f0e2222e4e3c3755001f302" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; . The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store_ent takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that hv_store_ent only reads the &lt;code&gt;key&lt;/code&gt; ; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 해시에 저장합니다 . 해시 키로 지정 &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;hash&lt;/code&gt; 파라미터는 미리 계산 된 해시 값이고; 0이면 Perl이 계산합니다. 리턴 값은 이렇게 작성된 새 해시 항목입니다. 작업이 실패했거나 값이 실제로 해시 내에 저장 될 필요가없는 경우 (연결된 해시의 경우) NULL입니다. 그렇지 않으면 &lt;code&gt;He?&lt;/code&gt; 를 사용하여 반환 값의 내용에 액세스 할 수 있습니다 . 여기에 설명 된 매크로 호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 NULL을 리턴하면 감소시킵니다. 효과적으로 성공적인 hv_store_ent는 &lt;code&gt;val&lt;/code&gt; 에 대한 하나의 참조 소유권을 갖습니다.. 이것은 일반적으로 원하는 것입니다. 새로 생성 된 SV의 참조 카운트는 1입니다. 따라서 모든 코드에서 SV를 생성 한 다음 해시에 저장하면 hv_store는 새 SV에 대한 유일한 참조를 소유하며 코드는 더 이상 수행 할 작업이 없습니다. 치우다. hv_store_ent는 &lt;code&gt;key&lt;/code&gt; 읽습니다 . &lt;code&gt;val&lt;/code&gt; 과는 달리 소유권을 가지지 않으므로 &lt;code&gt;key&lt;/code&gt; 의 정확한 참조 횟수를 유지하는 것은 전적으로 호출자의 책임입니다. hv_store는 hv_store_ent에 대한 호출로 구현되지 않으며 키에 대한 임시 SV를 작성하지 않으므로 키 데이터가 아직 SV 형식이 아닌 경우 hv_store를 기본적으로 hv_store_ent보다 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d4914da783cf76bac012d3e2b02900b8208b54e" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful &lt;code&gt;hv_store_ent&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that &lt;code&gt;hv_store_ent&lt;/code&gt; only reads the &lt;code&gt;key&lt;/code&gt;; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. The reason it does not take ownership, is that &lt;code&gt;key&lt;/code&gt; is not used after this function returns, and so can be freed immediately. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e853791e7f610503cb4ac62aa2d38d07104bcbf" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash</source>
          <target state="translated">경찰 힌트 해시에 키와 관련된 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="e4608cb007876dc9a320a4e730182bf778f713b9" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash &lt;code&gt;cophh&lt;/code&gt;, and returns the modified hash. The returned hash pointer is in general not the same as the hash pointer that was passed in. The input hash is consumed by the function, and the pointer to it must not be subsequently used. Use &lt;a href=&quot;#cophh_copy&quot;&gt;&quot;cophh_copy&quot;&lt;/a&gt; if you need both hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0142d462eb02b96cf9082ac295203e85636940" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt; . The values are the original list elements.</source>
          <target state="translated">LIST의 각 요소에 대한 모호하지 않은 잘림을 &lt;code&gt;$hashref&lt;/code&gt; 참조하는 연관 배열에 키로 저장합니다 . 값은 원래 목록 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c2253242048c2f74667f3a23355d9505c38b27fe" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt;. The values are the original list elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4236561c990b7cd479ccb52f08cd5fac9306b818" translate="yes" xml:space="preserve">
          <source>Stores an SV in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; and the absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it.</source>
          <target state="translated">SV를 해시에 저장합니다. 해시 키로서 지정된 &lt;code&gt;key&lt;/code&gt; 와의 절대치 &lt;code&gt;klen&lt;/code&gt; 키의 길이이다. 경우 &lt;code&gt;klen&lt;/code&gt; 키에 있다고 가정 부정 유니 UTF-8 인코딩. &lt;code&gt;hash&lt;/code&gt; 파라미터는 미리 계산 된 해시 값이고; 0이면 Perl이 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d6c29a0065e8b044a53af0ddb9dc3214fa041cf5" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt; . The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt; )).</source>
          <target state="translated">SV를 배열에 저장합니다. 배열 인덱스는 &lt;code&gt;key&lt;/code&gt; 로 지정됩니다 . 연산이 실패했거나 값이 실제로 배열 내에 저장 될 필요가없는 경우 (연결 배열의 경우와 같이) 반환 값은 NULL이됩니다. 그렇지 않으면, 저장된 &lt;code&gt;SV*&lt;/code&gt; 를 얻기 위해 역 참조 될 수 있습니다 (= &lt;code&gt;val&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="76dd68cc1b2cbd70a2c8fe63742bb4f5c0c8d0f4" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt;. The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7401a972574f8c1665c02fe0802590c81677bf55" translate="yes" xml:space="preserve">
          <source>Stores an alias to a variable in a hash instead of copying the value.</source>
          <target state="translated">값을 복사하는 대신 별칭에 변수에 별칭을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9f6711f9c55cd1025cf538a50470266deb723a43" translate="yes" xml:space="preserve">
          <source>Stores results for later output, all together.</source>
          <target state="translated">나중에 출력하기위한 결과를 모두 함께 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ced5e829ffc1318c3116b905b84107c1f3b72848" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the COMMENT field in the gzip header. By default, no comment field is written to the gzip file.</source>
          <target state="translated">gzip 헤더의 COMMENT 필드에 &lt;code&gt;$comment&lt;/code&gt; 의 내용을 저장합니다 . 기본적으로 주석 필드는 gzip 파일에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26843a54a3aa3332ec1baa3fb76f8c537a96c327" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the Central File Header of the zip file.</source>
          <target state="translated">&lt;code&gt;$comment&lt;/code&gt; 의 내용을 zip 파일의 중앙 파일 헤더에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f6d27852fc3f996b193528d04367b82db064d418" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the End of Central Directory record of the zip file.</source>
          <target state="translated">zip 파일의 중앙 디렉토리 끝 레코드에 &lt;code&gt;$comment&lt;/code&gt; 의 내용을 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="24042b8640feee28c4f2a0aafea788776423cdd1" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the gzip NAME header field. If &lt;code&gt;Name&lt;/code&gt; is not specified, no gzip NAME field will be created.</source>
          <target state="translated">gzip NAME 헤더 필드 에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 저장합니다 . 경우 &lt;code&gt;Name&lt;/code&gt; 지정되지 않는 경우, GZIP NAME 필드가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1023c335a52babfe2f8c4a04c4f2766471fa8387" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the zip filename header field.</source>
          <target state="translated">zip filename 헤더 필드 에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="51541d8a3d93b2d48a376cb2252ed37ed72421ab" translate="yes" xml:space="preserve">
          <source>Stores the key/value pair in the database.</source>
          <target state="translated">키 / 값 쌍을 데이터베이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ab093d23324af52293488a603b3cc3854b181a9e" translate="yes" xml:space="preserve">
          <source>Stores the pad name (which may be null) at the given index, freeing any existing pad name in that slot.</source>
          <target state="translated">주어진 색인에 패드 이름 (널 (NULL) 일 수 있음)을 저장하여 해당 슬롯의 기존 패드 이름을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="9d70a29a0f92ba96f998b27b0c51d6b21ce2123e" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 문자열로 저장합니다 . 예를 들어 Perl 엔진 은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt; 의 경우 &lt;code&gt;(?^:eek)&lt;/code&gt; 를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="bba419efdc2f7f861e8ccd4110f43bd3fa7e32d3" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;qr//&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;qr/eek/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30082107d90ca21e79e8350f2001678a7dc4b25b" translate="yes" xml:space="preserve">
          <source>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</source>
          <target state="translated">각 해시의 키를 보유하는 임시 배열을 할당, 채우기, 정렬 및 해제해야하므로 큰 해시를 포함하는 데이터를 정식으로 저장하면 동일한 데이터를 저장하는 것보다 상당히 느릴 수 있습니다. 일부 테스트에서 저장 속도가 절반으로 감소한 것으로 나타났습니다. 정확한 벌점은 데이터의 복잡성에 따라 다릅니다. 검색 속도가 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ccce2de5e8ad98636ec0480f8c1e95cb4123766" translate="yes" xml:space="preserve">
          <source>Storing numbers</source>
          <target state="translated">보관 번호</target>
        </trans-unit>
        <trans-unit id="408286a7232f91f660936da7835bac0e8863fd20" translate="yes" xml:space="preserve">
          <source>Storing options values in a hash</source>
          <target state="translated">해시에 옵션 값 저장</target>
        </trans-unit>
        <trans-unit id="5ca11c09231ed950fa4ac2095c30a18383eebf81" translate="yes" xml:space="preserve">
          <source>Storing pre-compiled regexps in an array &lt;code&gt;@compiled&lt;/code&gt; allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</source>
          <target state="translated">사전 컴파일 된 &lt;code&gt;@compiled&lt;/code&gt; 배열에 저장 하면 재 컴파일없이 정규 표현식 을 간단히 반복 할 수 있으므로 속도를 희생하지 않고도 유연성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e08b2cdc880eca3b63a251507ea23ebf665def8" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="translated">직선 우리는 각 라인은 호출 된 횟수가 동일 것을 볼 수있다 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 출력 및 순서는 각 라인은, 실행하는 데 걸린 시간의 순서에 따라 매우 약간 다릅니다 &lt;code&gt;if ( $debug ) { &lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 예를 들어. 실제로 기록 된 시간의 차이는 내부적으로 사용 된 알고리즘에 있거나 시스템 리소스 제한이나 경합으로 인한 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0bd17b455e668c15c8b3e94cf9e6f3076ea19b7" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;my $message = shift;&lt;/code&gt;, for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5060e04f34c62382f4c8552c1d1cf9f000d47b" translate="yes" xml:space="preserve">
          <source>Strategies for Storing Callback Context Information</source>
          <target state="translated">콜백 컨텍스트 정보 저장 전략</target>
        </trans-unit>
        <trans-unit id="85d8ba9bfe62936890930b5c6a10433e149d003f" translate="yes" xml:space="preserve">
          <source>Stratus OpenVOS (17.0 or later)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813265ea56803a78f3b7159d5fee7e20c7133600" translate="yes" xml:space="preserve">
          <source>Stratus Technologies on the web at &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</source>
          <target state="translated">웹의 Stratus Technologies ( &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e27222dd34cc6a5684f257f4f56510f3e78b139" translate="yes" xml:space="preserve">
          <source>Stratus VOS / OpenVOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e8d1a4aa1f448e22fd91f660943bf3fb47ccc9" translate="yes" xml:space="preserve">
          <source>Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</source>
          <target state="translated">Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dac5050cc8d5226a232897b98c67a79066b8e3a" translate="yes" xml:space="preserve">
          <source>Stream TAP from a Perl executable</source>
          <target state="translated">Perl 실행 파일에서 TAP 스트림</target>
        </trans-unit>
        <trans-unit id="411adcb2712346800a739adfeb9ade95333b1abf" translate="yes" xml:space="preserve">
          <source>Stream TAP from a text file.</source>
          <target state="translated">텍스트 파일에서 TAP을 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="5517c94f54c087e37e9e39887df00a0c39d682fc" translate="yes" xml:space="preserve">
          <source>Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">IO :: Handle 또는 GLOB에서 TAP을 스트리밍하십시오.</target>
        </trans-unit>
        <trans-unit id="aa321b146ad904dc93d6b1334004656dc82f28d4" translate="yes" xml:space="preserve">
          <source>Stream format with carriage-return terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf344468bbe5af0df1f27ec4b813e688b7db58d7" translate="yes" xml:space="preserve">
          <source>Stream format with line-feed terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044591cd59e9b7c9396655ff7bb64423112f9b95" translate="yes" xml:space="preserve">
          <source>Stream output from an executable TAP source</source>
          <target state="translated">실행 가능한 TAP 소스의 스트림 출력</target>
        </trans-unit>
        <trans-unit id="137d2933966619b13837102be962efe1a1067d69" translate="yes" xml:space="preserve">
          <source>Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">스칼라 / 배열 참조에서 원시 TAP의 스트림 출력.</target>
        </trans-unit>
        <trans-unit id="1e8325521df6e6903ede77955f9bf1a333363aed" translate="yes" xml:space="preserve">
          <source>Streaming</source>
          <target state="translated">Streaming</target>
        </trans-unit>
        <trans-unit id="79d9a52c246461dc0594d29507cd94db89e5088f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="translated">엄격한 규칙은 오타 및 기타 오류를 찾는 데 도움이됩니다. &lt;code&gt;&quot;-&quot;&lt;/code&gt; 가 다른 문자이거나 &lt;code&gt;&quot;\-&quot;&lt;/code&gt; 와 같이 이스케이프 된 경우 범위를 계획하지 않았을 수도 있습니다 . 범위를 의도 한 경우 사용 된 범위는 ASCII와 EBCDIC 플랫폼간에 이식 가능하지 않으며 일반 독자에게는 분명한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5396990d692459cc4babef519081fd255b847e8f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt;). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eda0deef3d3835356e2633ac9dde47a16b13b5d" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. You included a range, and at least one of the end points is a decimal digit. Under the stricter rules, when this happens, both end points should be digits in the same group of 10 consecutive digits.</source>
          <target state="translated">엄격한 규칙은 오타 및 기타 오류를 찾는 데 도움이됩니다. 범위를 포함 시켰으며 끝점 중 하나 이상이 10 진수입니다. 보다 엄격한 규칙에 따라이 경우 두 끝점은 동일한 연속 10 자리 그룹의 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8871c27b11e121bdab37c41ce307e123e5948970" translate="yes" xml:space="preserve">
          <source>Strictly speaking, MIME header encoding documented in RFC 2047 is more of encapsulation than encoding. However, their support in modern world is imperative so they are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0650e0c020aef4abbfbd4bda604f404ed598e991" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that munches up another program and spits out yet another file containing the program in a &amp;ldquo;more executable&amp;rdquo; form, typically containing native machine instructions. The</source>
          <target state="translated">엄밀히 말하면, 다른 프로그램을 실행하고 프로그램을 포함하는 또 다른 파일을&amp;ldquo;더 실행 가능한&amp;rdquo;형식으로, 일반적으로 기본 기계 명령어를 포함하는 다른 파일을 뱉어내는 프로그램입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="19287d999efabb7aed57bbe8e78bb9475aab4690" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that reads a second program and does what the second program says directly without turning the program into a different form first, which is what &lt;b&gt;compilers&lt;/b&gt; do. Perl is not an interpreter by this definition, because it contains a kind of compiler that takes a program and turns it into a more executable form (&lt;b&gt;syntax trees&lt;/b&gt;) within the</source>
          <target state="translated">엄밀히 말하면, 두 번째 프로그램을 읽고 두 번째 프로그램이 다른 형식으로 먼저 바꾸지 않고 직접 말한 것을 수행하는 프로그램은 &lt;b&gt;컴파일러&lt;/b&gt; 입니다. Perl은 프로그램을 가져 와서 더 실행 가능한 형태 ( &lt;b&gt;구문 트리)&lt;/b&gt; 로 만드는 일종의 컴파일러를 포함하기 때문에이 정의에 의해 해석기가 아닙니다.&lt;b&gt;&lt;/b&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a6fde2b9f7e959d871c8af08462a6492339f7057" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="translated">엄밀히 말하면 아무것도 아닙니다. 말 그대로, 유지 보수 가능한 코드를 작성하는 좋은 방법은 아닙니다. Perl에는 외부 명령을 실행하기위한 여러 연산자가 있습니다. 백틱은 하나입니다. 프로그램에서 사용하기 위해 명령의 출력을 수집합니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 기능은 다른이고; 이 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c8ebada708fb113d97be17e44dc95013a97d6cf" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;system&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ea50d3a212d751dc75823785ce8d3fc481176b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="translated">엄밀히 말하면 연도는 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 과 일치하는 형식으로 지정해야합니다. , 즉 1900에서 오프셋 . 그러나 연도를 더 쉽게 해석하기 위해 연도를 두 자리 또는 네 자리 숫자 값은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="23a6b2fb53b29ab8753d41951749465184e362aa" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;localtime()&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4b8f90e8599772141d5d74184d3678eb652f81" translate="yes" xml:space="preserve">
          <source>Strictly, the shell&amp;rsquo;s &lt;code&gt;*&lt;/code&gt; character, which will match a &amp;ldquo;glob&amp;rdquo; of characters when you&amp;rsquo;re trying to generate a list of filenames. Loosely, the act of using globs and similar symbols to do pattern matching. See also &lt;b&gt;fileglob&lt;/b&gt; and &lt;b&gt;typeglob&lt;/b&gt;.</source>
          <target state="translated">엄밀히 말해, 쉘의 &lt;code&gt;*&lt;/code&gt; 문자는 파일 이름 목록을 생성하려고 할 때 문자의 &quot;글로브&quot;와 일치합니다. 느슨하게, 패턴 매칭을하기 위해 glob와 유사한 심볼을 사용하는 행위. &lt;b&gt;fileglob&lt;/b&gt; 및 &lt;b&gt;typeglob&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="158127f06e6da3362607fa7cbbba756efc7019b1" translate="yes" xml:space="preserve">
          <source>Strictness and warnings</source>
          <target state="translated">엄격함과 경고</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="516c0f4e3c92a494342e3cb25a961d2360643bc2" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="translated">문자열 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;LC_NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13d19fb185a642a2881088ab8e929269f84edb68" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322644ec18f089375fd934ccac0ee29b7bf9401a" translate="yes" xml:space="preserve">
          <source>String Collation</source>
          <target state="translated">문자열 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="40837ec372cc75f0a51393ed930c1fe017719b97" translate="yes" xml:space="preserve">
          <source>String Equivalence</source>
          <target state="translated">문자열 등가</target>
        </trans-unit>
        <trans-unit id="c0852fa4a49f9a7f054796351af22423733e0ae5" translate="yes" xml:space="preserve">
          <source>String Lengths</source>
          <target state="translated">끈 길이</target>
        </trans-unit>
        <trans-unit id="b231adac90ed5af6e5723df56d210bfd345958ac" translate="yes" xml:space="preserve">
          <source>String Processing, Language Text Processing, Parsing, and Searching</source>
          <target state="translated">문자열 처리, 언어 텍스트 처리, 구문 분석 및 검색</target>
        </trans-unit>
        <trans-unit id="a76a0b86b2d8c7c2af26080ae08b76bef9730da0" translate="yes" xml:space="preserve">
          <source>String comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f618ca662dfcc3b16eb26b3a99e8a37d3fd5c229" translate="yes" xml:space="preserve">
          <source>String constants that would normally evaluate to 0 or 1 are warned about.</source>
          <target state="translated">일반적으로 0 또는 1로 평가되는 문자열 상수가 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="6104084e70872a799af75c0c3b3e9c680e29b421" translate="yes" xml:space="preserve">
          <source>String conversion</source>
          <target state="translated">문자열 변환</target>
        </trans-unit>
        <trans-unit id="8dc84df0bc8f7e36bf6046d5ceb68a3cfd06dca6" translate="yes" xml:space="preserve">
          <source>String conversion methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ce711ae430e00ec658d92f901bfb5ff64ae114" translate="yes" xml:space="preserve">
          <source>String eval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597fe8909ca1928228ff982d52d105d13e058f8b" translate="yes" xml:space="preserve">
          <source>String eval and LC_NUMERIC</source>
          <target state="translated">문자열 평가 및 LC_NUMERIC</target>
        </trans-unit>
        <trans-unit id="4941134ab361827bee0789e57907295ac43600ee" translate="yes" xml:space="preserve">
          <source>String for the package. If the package does not have a &lt;code&gt;$VERSION&lt;/code&gt;, this field must be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860dceea01893fc71bff8d83982d93e598606a4e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 처리 기능은 대부분 문자 측면에서 계속 작동합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 는 이전과 마찬가지로 문자열의 문자 수를 반환합니다. 그러나 그 숫자는 더 이상 문자열의 바이트 수와 동일 할 필요는 없습니다 (문자보다 많은 바이트가있을 수 있음). 다른 함수로는 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="401ccffa7eab02269ca231a09dc9fc080d0ef44e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;length()&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;chop()&lt;/code&gt;, &lt;code&gt;chomp()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;pos()&lt;/code&gt;, &lt;code&gt;index()&lt;/code&gt;, &lt;code&gt;rindex()&lt;/code&gt;, &lt;code&gt;sort()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, and &lt;code&gt;write()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93394b81d59344078a9850ad4f758f0f59ea42a4" translate="yes" xml:space="preserve">
          <source>String holding augmented version of second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c329814ec2d3d4971e2511c74b3273f40003742e" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest =
&quot;C:\U$name.$ext&quot;&lt;/code&gt; , may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="translated">&lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt; 와 같이 대소 문자 매핑을 사용한 문자열 보간 은 가짜 &lt;code&gt;LC_CTYPE&lt;/code&gt; 인 경우 위험한 결과를 생성 할 수 있습니다 case-mapping 테이블이 유효한 경우 .</target>
        </trans-unit>
        <trans-unit id="cd79a2810365d4fde650c3f3ecb48c64b7bd3d40" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt;, may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6780b9a46b265648d17e144b69c48ee74770992" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; ). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt; for a list.</source>
          <target state="translated">문자열 리터럴은 일반적으로 작은 따옴표 나 큰 따옴표로 구분됩니다. 표준 Unix 쉘에서 인용 부호와 매우 유사하게 작동합니다. 큰 따옴표로 묶인 문자열 리터럴은 백 슬래시와 변수 대체가 적용됩니다. 작은 따옴표로 묶인 문자열은 없습니다 ( &lt;code&gt;\'&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 제외 ). 일반적인 C 스타일 백 슬래시 규칙은 줄 바꿈, 탭 등과 같은 문자와 좀 더 이국적인 형식을 만드는 데 적용됩니다. 목록 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;은 perlop의 인용 및 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13732576251fc8d08b8cf385b7308ea1c12b8efc" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt; for a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0fe980f60efc7c1f918b95be4503588f28be99" translate="yes" xml:space="preserve">
          <source>String needing checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3051b99c9691d2719f0563e333076fae287e689" translate="yes" xml:space="preserve">
          <source>String needing escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b011a78c96a9c16cf6436848fa3f565de97986a2" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt; . Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="translated">xsubpp에 전달할 옵션 문자열. 여기에는 &lt;code&gt;-C++&lt;/code&gt; 또는 &lt;code&gt;-extern&lt;/code&gt; 이 포함될 수 있습니다. . 여기에 타입 맵을 포함시키지 마십시오. 이를 위해 TYPEMAP 매개 변수가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="01cf92ed42a8c75a1838e0a5762b33f6a2b55111" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt;. Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fec62342425ec8f81ce629d9250491168e3f930" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt; 's case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="translated">문자열 오버로드 된 객체는 &lt;b&gt;문자열로&lt;/b&gt; (또는 비교 op에 적합한 &lt;code&gt;cmp_ok()&lt;/code&gt; 의 경우 문자열 또는 숫자로) 비교됩니다. 이렇게하면 Test :: More가 객체의 인터페이스를 뚫고 더 나은 블랙 박스 테스트를 할 수 없습니다. 따라서 함수가 노출 된 문자열 대신 오버로드 된 객체를 반환하기 시작하면 테스트에서 차이를 인식하지 못합니다. 이거 좋다</target>
        </trans-unit>
        <trans-unit id="fa1a43b0163b121a327b4a58480c5d680c5b9558" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt;'s case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00ebea06538bbe227ded196b24216fa175546f" translate="yes" xml:space="preserve">
          <source>String that will be included in the compiler call command line between the arguments INC and OPTIMIZE.</source>
          <target state="translated">INC와 OPTIMIZE 인수 사이의 컴파일러 호출 명령 행에 포함될 문자열.</target>
        </trans-unit>
        <trans-unit id="6e526f1a740ace9291b3849106bb71fe9922d6d7" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">문자열을 (긴) 정수로 변환합니다. 문자열의 구문 분석되지 않은 부분에서 구문 분석 된 수와 문자 수를 리턴합니다. 진정한 POSIX 호환 시스템 세트 &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; )는 번역 오류를 나타내므로 &lt;code&gt;$!&lt;/code&gt; 를 지우십시오 . &lt;code&gt;strtol&lt;/code&gt; 을 호출하기 전에 . 그러나 비 POSIX 시스템은 오버플로를 검사하지 않을 수 있으므로 &lt;code&gt;$!&lt;/code&gt; 설정하지 않습니다 ! .</target>
        </trans-unit>
        <trans-unit id="1e3afd2c721e94e17632288572aff18f68920d41" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt;. However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ad43047bd965bdc4d07f5ce2456ad0a02b96c7" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">문자열을 이중으로 변환합니다. 문자열의 구문 분석되지 않은 부분에서 구문 분석 된 수와 문자 수를 리턴합니다. 진정한 POSIX 호환 시스템 세트 &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; )는 번역 오류를 나타내므로 &lt;code&gt;$!&lt;/code&gt; 를 지우십시오 . &lt;code&gt;strtod&lt;/code&gt; 를 호출하기 전에 . 그러나 비 POSIX 시스템은 오버플로를 검사하지 않을 수 있으므로 &lt;code&gt;$!&lt;/code&gt; 설정하지 않습니다 !.</target>
        </trans-unit>
        <trans-unit id="d8676f880462f433f166d907d612c3e8919af6de" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt;. However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f0eaf01673564e0319c5f3bfbb5d8942bb1f18" translate="yes" xml:space="preserve">
          <source>String to prepend to the &lt;code&gt;file&lt;/code&gt; field of the resulting output. This defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e6cc14bde5be0fa13f9402d856fc2a265b21a7" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;&quot;strtol&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abcfc7dcb04cc4aa0bcda4543317ca564702847" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; for details.</source>
          <target state="translated">부호없는 (긴) 정수 변환에 대한 문자열입니다. &lt;code&gt;strtoul()&lt;/code&gt; 동일하다 &lt;code&gt;strtol()&lt;/code&gt; 것을 제외 &lt;code&gt;strtoul()&lt;/code&gt; 만 부호없는 정수를 파싱한다. &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ad6f48bf54709b2ba69a1fce32b7638601bfac7" translate="yes" xml:space="preserve">
          <source>String transformation. Returns the transformed string.</source>
          <target state="translated">문자열 변환. 변환 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3093f7beb97882dcb9a98d3b5be7d4560e5f5ef4" translate="yes" xml:space="preserve">
          <source>String, numeric, boolean, and regexp conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095d3b7d7b51ca9267c55a71d96ee740ce9ed714" translate="yes" xml:space="preserve">
          <source>String-To-Number Conversions</source>
          <target state="translated">문자열을 숫자로 변환</target>
        </trans-unit>
        <trans-unit id="5942152bba6334b38f5af4b68fa787f8c4338bf1" translate="yes" xml:space="preserve">
          <source>String.</source>
          <target state="translated">String.</target>
        </trans-unit>
        <trans-unit id="89f0c9a299c3800ad98959c29c190d1bc9de23ac" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">끈. 임의의 문자 시퀀스 인수가 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 로 시작하는 것이 유효합니다. .</target>
        </trans-unit>
        <trans-unit id="81f30cf5068f2f28c67e584c10005d36bbd46507" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6805d3a9d242376321929e78e5ba39e0634fbb9" translate="yes" xml:space="preserve">
          <source>Stringification</source>
          <target state="translated">Stringification</target>
        </trans-unit>
        <trans-unit id="fafc0f2cb3777e3c850edce9bbb0624fb76d8e93" translate="yes" xml:space="preserve">
          <source>Stringification also destroys arrays.</source>
          <target state="translated">스트링 화는 또한 배열을 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="a96e53fa801a030d61d0b0afb131453e4a3a7511" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">인쇄 및 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 적합한 문자열 화 된 펄 데이터 구조</target>
        </trans-unit>
        <trans-unit id="22b2c8519d7e0bf7d3dd8b66c9c7ae4d2bf2a17f" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bad8926562843b707945e86b277e1f637dc69d2" translate="yes" xml:space="preserve">
          <source>Stringify dumps the data inside the object.</source>
          <target state="translated">Stringify는 객체 내부의 데이터를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="242a6a36753d3e416e5262c8b767349bc289b912" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;. These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cca40b8e6ab951533c16fbbdd8e8eeb9f0e6f8" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">로 만든 문자열 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 또한 논리 연산자를 조작 할 수 있습니다 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이 연산자는 두 피연산자가 모두 문자열 인 경우 비트 벡터 연산이 필요하다고 가정합니다. &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Perlop의 비트 단위 문자열 연산자&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="bc0a2fc8d4082ea8e735316dde8d1811abffaf90" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">로 만든 문자열 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 또한 논리 연산자를 조작 할 수 있습니다 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이 연산자는 두 피연산자가 모두 문자열 인 경우 비트 벡터 연산이 필요하다고 가정합니다. &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Perlop의 비트 단위 문자열 연산자&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="9f7e8a6f87a8a42268a64c6a11af8887059d5680" translate="yes" xml:space="preserve">
          <source>Strings of multiple sub- and superscripts are not recognized as numbers. You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &lt;code&gt;num&lt;/code&gt; on the result.</source>
          <target state="translated">여러 첨자 및 위첨자의 문자열은 숫자로 인식되지 않습니다. Unicode :: Normalize의 호환성 분해 중 하나를 사용하여 숫자를 변경 한 다음 결과에서 &lt;code&gt;num&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe482813a109ae5d2d22da9c6e84cc6ce253ee7f" translate="yes" xml:space="preserve">
          <source>Strings with code points over 0xFF may not be mapped into in-memory file handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaa3eb6eac6d4efb6574a9ba9018939acd1f8cf" translate="yes" xml:space="preserve">
          <source>Strings--including hash keys--and regular expression patterns may contain characters that have ordinal values larger than 255.</source>
          <target state="translated">해시 키를 포함한 문자열 및 정규식 패턴에는 서 수가 255보다 큰 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6348b5c86af8ba2c83c3a187e28bfcf9f1d038b" translate="yes" xml:space="preserve">
          <source>Stripping Perl Binaries on Cygwin</source>
          <target state="translated">Cygwin에서 Perl 바이너리 제거</target>
        </trans-unit>
        <trans-unit id="f9141f854e0e233503d419a0cf18d9153715c039" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and fully-featured with a long development history and a large community and addon ecosystem. It is excellent for large and complex applications, where you have full control over the server.</source>
          <target state="translated">오랜 개발 역사와 대규모 커뮤니티 및 애드온 생태계로 강력하게 객체 지향적이며 모든 기능을 갖추고 있습니다. 서버를 완전히 제어 할 수있는 크고 복잡한 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="0a7ad50fa5faede1ac1a8e9d617b83a136f3b36c" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and minimal, built for speed and intended as a toolkit for building micro web apps, custom frameworks or for tieing together existing Plack-compatible web applications with one central dispatcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92faa1dc48e3fe73a6fc4858913998fc576077e6" translate="yes" xml:space="preserve">
          <source>Strtod</source>
          <target state="translated">Strtod</target>
        </trans-unit>
        <trans-unit id="2bb3001dd42d6db227fc38ef7fd440ba6f9787f9" translate="yes" xml:space="preserve">
          <source>Strtol</source>
          <target state="translated">Strtol</target>
        </trans-unit>
        <trans-unit id="aaac07ac9b1f9026b0065ac193b055defc924b2e" translate="yes" xml:space="preserve">
          <source>Strtoul</source>
          <target state="translated">Strtoul</target>
        </trans-unit>
        <trans-unit id="4e5f4595501ae7d455e886e191bc02eb4a97eb9d" translate="yes" xml:space="preserve">
          <source>StructCopy</source>
          <target state="translated">StructCopy</target>
        </trans-unit>
        <trans-unit id="f23a884e110f1886cdc16e896ca93598233740f9" translate="yes" xml:space="preserve">
          <source>Structs are required to be aligned to the maximum alignment required by the fields - which for native types is for usually equivalent to sizeof() of the field</source>
          <target state="translated">구조체는 필드에 필요한 최대 정렬에 맞춰야합니다. 기본 유형의 경우 일반적으로 필드의 sizeof ()와 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb761c94903285d6515bd20e9cd52538249ae83b" translate="yes" xml:space="preserve">
          <source>Structure of a Regexp Program</source>
          <target state="translated">정규식 프로그램의 구조</target>
        </trans-unit>
        <trans-unit id="a5c0ab1b864f9236f0a013c0c90f92ca429edfd8" translate="yes" xml:space="preserve">
          <source>Structure your modules so they are all located under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd40698b4bb94e939846994c9f9741e198f30bc1" translate="yes" xml:space="preserve">
          <source>Structured data retrieval of perl -V output</source>
          <target state="translated">Perl -V 출력의 구조화 된 데이터 검색</target>
        </trans-unit>
        <trans-unit id="3e4953dd11e72439867b2ad528b4c6dad15a7661" translate="yes" xml:space="preserve">
          <source>Stub found while resolving method &quot;%s&quot; overloading &quot;%s&quot; in package &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ce54f7f99cf2cca6626a2de77f397b8065d514" translate="yes" xml:space="preserve">
          <source>Stub that provides thread hook for perl_destruct when there are no threads.</source>
          <target state="translated">스레드가 없을 때 perl_destruct에 스레드 후크를 제공하는 스텁.</target>
        </trans-unit>
        <trans-unit id="d8d7cb9c0bd0e5d2e8d74ffc3881bd4b4fc1400b" translate="yes" xml:space="preserve">
          <source>Stubs for Deleted Documents</source>
          <target state="translated">삭제 된 문서에 대한 스텁</target>
        </trans-unit>
        <trans-unit id="4d7dabe926bb346f9396e40dca4282529b230cab" translate="yes" xml:space="preserve">
          <source>Stuff here is really low-priority to optimize, since it is far better to implement the operation in the low-level math library directly, possible even using a call to the native lib.</source>
          <target state="translated">여기에있는 것들은 최적화하기에 우선 순위가 낮습니다. 낮은 수준의 수학 라이브러리에서 직접 작업을 구현하는 것이 훨씬 낫기 때문에 기본 라이브러리에 대한 호출을 사용하더라도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2869e1f287c823d9d113fb739c0f867918c01e7c" translate="yes" xml:space="preserve">
          <source>Stuffit Expander</source>
          <target state="translated">Stuffit Expander</target>
        </trans-unit>
        <trans-unit id="99a0efc6cfd85d8ff2732a6718140f822cb90472" translate="yes" xml:space="preserve">
          <source>Style</source>
          <target state="translated">Style</target>
        </trans-unit>
        <trans-unit id="454122721f6b63e2ec36cf3779d6bbadd2e22140" translate="yes" xml:space="preserve">
          <source>Sub::Util</source>
          <target state="translated">Sub::Util</target>
        </trans-unit>
        <trans-unit id="200e883b1bf91bd7e7b1892b6781abbb8731b040" translate="yes" xml:space="preserve">
          <source>Sub::Util - A selection of utility subroutines for subs and CODE references</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4fae33d407351a21e057015a8cfce97b1d1d2a" translate="yes" xml:space="preserve">
          <source>Subclass</source>
          <target state="translated">Subclass</target>
        </trans-unit>
        <trans-unit id="1a337fcb31e5829e1a600e170299e1eed7692c3f" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e337d12e7f0f9db812cc8b4bb46be2d64cb670" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a598fbe728e9996509df163e945962ae7a4ffed0" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873c1d3b114c3c8ca9fa8263d71c270acec87256" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">서브 클래스 &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 및 &lt;code&gt;grammar_class&lt;/code&gt; 매개 변수 를 설정하여 구문 분석기를 사용자 정의하십시오 . &lt;a href=&quot;#new&quot;&gt;새로운&lt;/a&gt; 보기 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a88a43bb409ce5ce1ef29fd247b1a667d1a95af9" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="translated">서브 클래스 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 및 새로운 결과 유형 / 클래스를 기본 &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory에&lt;/a&gt; 등록하십시오. .</target>
        </trans-unit>
        <trans-unit id="b9c1095f48c3aca9e5b044be2e9f7d4aebd28ac4" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt; 자체를 서브 클래스 하고 자체 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 생성 로직을 구현하십시오 . 그런 다음 &lt;code&gt;result_factory_class&lt;/code&gt; 매개 변수 를 설정하여 구문 분석기가 사용하는 클래스를 사용자 정의해야합니다 . &lt;a href=&quot;#new&quot;&gt;새로운&lt;/a&gt; 보기 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e73f017d1b2756188610b88957a8f09f27806cab" translate="yes" xml:space="preserve">
          <source>Subclass implementations of this method may wish to invoke the &lt;b&gt;nested()&lt;/b&gt; method of &lt;code&gt;$pod_seq&lt;/code&gt; to see if it is nested inside some other interior-sequence (and if so, which kind).</source>
          <target state="translated">이 메소드의 서브 클래스 구현 은 &lt;code&gt;$pod_seq&lt;/code&gt; 의 &lt;b&gt;nested ()&lt;/b&gt; 메소드 를 호출 할 수 있습니다. 그것이 다른 내부 순서 내에 중첩되어 있는지 (그리고 그렇다면 어떤 종류인지) 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64bde9a828bba22dd63e418d48e0703d9c34544f" translate="yes" xml:space="preserve">
          <source>Subclass it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206092a8f1bccf21dc1a96fb2aecc7852ff2c2b3" translate="yes" xml:space="preserve">
          <source>Subclass off of ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils :: MM_Any에서 서브 클래스</target>
        </trans-unit>
        <trans-unit id="c726c3176746b961b1da7788108e104c74c302c2" translate="yes" xml:space="preserve">
          <source>Subclasses will add methods, and will also inherit these methods:</source>
          <target state="translated">서브 클래스는 메소드를 추가하고 다음 메소드도 상속합니다.</target>
        </trans-unit>
        <trans-unit id="f3e2eeeafa90ba07510736c79555f75b3f2683f2" translate="yes" xml:space="preserve">
          <source>Subclassing Math::BigInt</source>
          <target state="translated">서브 클래 싱 수학 :: BigInt</target>
        </trans-unit>
        <trans-unit id="7a1cf3add6a7e4a2dd149344bc26ee4f53a43b6c" translate="yes" xml:space="preserve">
          <source>Subject to include with the message. You will be prompted if you don't supply one on the command line.</source>
          <target state="translated">메시지에 포함되어야합니다. 명령 행에 하나를 제공하지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="514a69c7cb010ea0bf9f49cd1b452991b8b8c5f5" translate="yes" xml:space="preserve">
          <source>Subject to include with the report. You will be prompted if you don't supply one on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="403bc0e6094ca81cdc2ca6f64a247c639431d231" translate="yes" xml:space="preserve">
          <source>Submit all messages/phrases/etc. to translators.</source>
          <target state="translated">모든 메시지 / 구문 등을 제출하십시오. 번역가에게.</target>
        </trans-unit>
        <trans-unit id="0d2e3edd3ad42a3c825fac56543a9ba6ed29f070" translate="yes" xml:space="preserve">
          <source>Submit as command file on close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">패치 제출</target>
        </trans-unit>
        <trans-unit id="c9a1540fce9398b2881e3e765d38647cec10bf30" translate="yes" xml:space="preserve">
          <source>Subprocesses started with open use a minimal popen() routine and therefore they do not return pids usable with waitpid etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5792d60bcabce4e99c77d69a1b0a93002b6b2c75" translate="yes" xml:space="preserve">
          <source>Subroutine &quot;%s&quot; will not stay shared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800547d773f13c68fa4495c8910007398137cdb8" translate="yes" xml:space="preserve">
          <source>Subroutine &quot;&amp;amp;%s&quot; is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29109439b3ee3e3ad4d67ea3d37066e59b15da" translate="yes" xml:space="preserve">
          <source>Subroutine %s redefined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ef2c6312acb93997fc9533ac9d5fab3c547483" translate="yes" xml:space="preserve">
          <source>Subroutine Attributes</source>
          <target state="translated">서브 루틴 속성</target>
        </trans-unit>
        <trans-unit id="e505b9988266048dcf61fcc7b04326e41ac00577" translate="yes" xml:space="preserve">
          <source>Subroutine References as Methods</source>
          <target state="translated">메소드로서의 서브 루틴 참조</target>
        </trans-unit>
        <trans-unit id="e0c81de6298b00147539fb1fd776b06104ff3a1b" translate="yes" xml:space="preserve">
          <source>Subroutine Stubs</source>
          <target state="translated">서브 루틴 스텁</target>
        </trans-unit>
        <trans-unit id="a522560a592f55d1244a49a61ccbec20e0f1bdb4" translate="yes" xml:space="preserve">
          <source>Subroutine attributes must come before the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17d78c0715b7cc40ffcc13047f5c03c7076ce7e" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2c6bab1119398dcc6fbf96d66f3ef433c36e56" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt;.</source>
          <target state="translated">명명 된 캡처 그룹에 대한 서브 루틴 호출 &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2db8d18b231e5da42e906ca30c0b2a5d6ae6ff13" translate="yes" xml:space="preserve">
          <source>Subroutine calls and lookups of individual array elements arise often enough that it gets cumbersome to use method 2. As a form of syntactic sugar, the examples for method 2 may be written:</source>
          <target state="translated">개별 배열 요소의 서브 루틴 호출 및 조회는 방법 2를 사용하는 것이 번거로울 정도로 자주 발생합니다. 구문 설탕의 형태로 방법 2의 예를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4b563566baea0b906bb1fd2aafe77f5b8f15d9" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="translated">서브 루틴 선언 및 정의에는 선택적으로 연관된 속성 목록이있을 수 있습니다. ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언도 다를 수 있지만 아래 경고를 참조하십시오.) Perl은 호출 사이트에 대한 정보와 속성 목록과 함께 선언 된 사항을이 모듈에 전달하여 이러한 선언을 처리합니다. 특히 위의 첫 번째 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1073836739fed365f30def4568eabbaf570bbb96" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;my&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1033729ecd127028ccf3e2aa66d4fd8f486f7da3" translate="yes" xml:space="preserve">
          <source>Subroutine defined.</source>
          <target state="translated">서브 루틴이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="d9339f9cd00dee3efa9f7f46ee1ed9f5d6e327f1" translate="yes" xml:space="preserve">
          <source>Subroutine definitions (and declarations, for that matter) need not necessarily be situated in the package whose symbol table they occupy. You can define a subroutine outside its package by explicitly qualifying the name of the subroutine:</source>
          <target state="translated">서브 루틴 정의 (및 그 문제에 대한 선언)는 심볼 테이블이 차지하는 패키지에 반드시 위치 할 필요는 없습니다. 서브 루틴 이름을 명시 적으로 규정하여 패키지 외부에서 서브 루틴을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9df428b17a930b0722f07795c93f287fd3afdec" translate="yes" xml:space="preserve">
          <source>Subroutine or method call.</source>
          <target state="translated">서브 루틴 또는 메소드 호출.</target>
        </trans-unit>
        <trans-unit id="69c680037a9b95df2742cb6788f31ebc24c5c06b" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e848b12ba1771594d7f90740383f312abe841d15" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through @INC and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g., &quot;</source>
          <target state="translated">서브 루틴 참조가 가장 간단한 경우입니다. 포함 시스템이 @INC를 통과하고 서브 루틴을 만나면이 서브 루틴은 두 개의 매개 변수로 호출됩니다. 첫 번째는 자체에 대한 참조이고 두 번째는 포함 할 파일의 이름입니다 (예 : &quot;</target>
        </trans-unit>
        <trans-unit id="b392dcb7d8c01390614814ebacd1c58485fdcd21" translate="yes" xml:space="preserve">
          <source>Subroutines</source>
          <target state="translated">Subroutines</target>
        </trans-unit>
        <trans-unit id="3a9c9397dc48823cce2af70d8aec97a4fb827cbd" translate="yes" xml:space="preserve">
          <source>Subroutines can also return values:</source>
          <target state="translated">서브 루틴은 값을 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cbe2412d3dda1f0b9872899595b0870846f911a" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="translated">서브 루틴 선언은 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 문으로로드하거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 네임 스페이스로로드 및 가져올 수도 있습니다 . 이에 대한 자세한 내용 은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9413cb94cc1864a97b409cf3b7e7117c8f53d17" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;require&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;use&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b365b15ba275665842a040de4aa6dff221b841" translate="yes" xml:space="preserve">
          <source>Subroutines in multiple packages within the same file are supported - but you should note that this requires exporting the &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; to every package which requires it. This is done automatically by the &lt;b&gt;SelfLoader&lt;/b&gt; when it first loads the subs into the cache, but you should really specify it in the initialization before the &lt;code&gt;__DATA__&lt;/code&gt; by putting a 'use SelfLoader' statement in each package.</source>
          <target state="translated">동일한 파일 내에서 여러 패키지의 서브 루틴이 지원되지만 &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; 를 필요한 모든 패키지로 내 보내야 합니다. 이는 서브로드를 캐시에 처음로드 할 때 &lt;b&gt;SelfLoader에&lt;/b&gt; 의해 자동으로 수행 되지만 각 패키지에 'use SelfLoader'문을 넣어 &lt;code&gt;__DATA__&lt;/code&gt; 이전의 초기화에서이를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="908bce63fd3bee1510a99f3549ad888c8938e948" translate="yes" xml:space="preserve">
          <source>Subroutines may be called recursively. If a subroutine is called using the &lt;code&gt;&amp;amp;&lt;/code&gt; form, the argument list is optional, and if omitted, no &lt;code&gt;@_&lt;/code&gt; array is set up for the subroutine: the &lt;code&gt;@_&lt;/code&gt; array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.</source>
          <target state="translated">서브 루틴은 재귀 적으로 호출 될 수 있습니다. 서브 루틴이 사용하여 호출하는 경우 &lt;code&gt;&amp;amp;&lt;/code&gt; 양식을 인수 목록은 선택 사항이며, 생략하는 경우에는 &lt;code&gt;@_&lt;/code&gt; 배열이 서브 루틴에 대해 설정되지 않습니다 다음은 &lt;code&gt;@_&lt;/code&gt; 호출시 배열이 대신 서브 루틴 볼 수 있습니다. 이는 새로운 사용자가 피할 수있는 효율성 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="cda2b08c81beb1e8e27be40c69e142c7b306247c" translate="yes" xml:space="preserve">
          <source>Subroutines used with ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils :: ParseXS와 함께 사용되는 서브 루틴</target>
        </trans-unit>
        <trans-unit id="3f753412893b86e74de31ef62203854e630f7671" translate="yes" xml:space="preserve">
          <source>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.</source>
          <target state="translated">이름이 모두 대문자 인 서브 루틴은 이름이 모두 소문자 인 모듈과 마찬가지로 Perl 코어에 예약됩니다. 모든 대문자의 서브 루틴은 느슨하게 유지되는 규칙으로, 일반적으로 트리거 된 이벤트로 인해 런타임 시스템 자체에서 간접적으로 호출됩니다. 이름이 왼쪽 괄호로 시작하는 서브 루틴도 같은 방식으로 예약됩니다. 다음은 현재 사전 정의 된 특수 작업을 수행하는 일부 서브 루틴 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bd995cb059355e488a61a605eadaa870990fb34e" translate="yes" xml:space="preserve">
          <source>Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if there's a portion you're not clear on - who knows, you may unearth a bug in the patch...</source>
          <target state="translated">perl5-porter를 구독하고 패치를 따르고 시도하십시오. 명확하지 않은 부분이 있는지 물어 보는 것을 두려워하지 마십시오. 누군가는 패치에서 버그를 발견 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="93d9b06a27141e76f1c5da56e07d3f537a49d789" translate="yes" xml:space="preserve">
          <source>Subscribe/Unsubscribe</source>
          <target state="translated">Subscribe/Unsubscribe</target>
        </trans-unit>
        <trans-unit id="a9be04fdf20dd61cb8df7236630151f2b739230f" translate="yes" xml:space="preserve">
          <source>Subscribers to perl5-porters (the porters themselves) come in several flavours. Some are quiet curious lurkers, who rarely pitch in and instead watch the ongoing development to ensure they're forewarned of new changes or features in Perl. Some are representatives of vendors, who are there to make sure that Perl continues to compile and work on their platforms. Some patch any reported bug that they know how to fix, some are actively patching their pet area (threads, Win32, the regexp -engine), while others seem to do nothing but complain. In other words, it's your usual mix of technical people.</source>
          <target state="translated">Perl5 포터 (포터 자체)의 구독자는 여러 가지 맛이 있습니다. 일부는 조용하고 호기심 많은 숨어있는 사람들로, Perl의 새로운 변경 사항이나 기능에 대해 미리 알기 위해 거의 참여하지 않고 지속적인 개발을 지켜보고 있습니다. 일부는 공급 업체의 대표자이며, Perl이 플랫폼에서 계속 컴파일하고 작업 할 수 있도록하는 공급 업체입니다. 일부는 그들이 고치는 방법을 알고 있다고보고 된 버그를 패치하고, 일부는 그들의 애완 동물 영역 (스레드, Win32, regexp -engine)을 적극적으로 패치하고있는 반면, 다른 것들은 불평하는 것 외에는 아무것도하지 않는 것 같습니다. 다시 말해서, 그것은 당신의 평범한 기술 사람들의 혼합입니다.</target>
        </trans-unit>
        <trans-unit id="4ce7140689363704a8ba85b5261797d063cdadf8" translate="yes" xml:space="preserve">
          <source>Subscripts</source>
          <target state="translated">Subscripts</target>
        </trans-unit>
        <trans-unit id="6555f256c06dba45d12ae5b008404f7426193f59" translate="yes" xml:space="preserve">
          <source>Substantial contributions by Sean Burke &amp;lt;sburke@cpan.org&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972581919796c696d3887a640cd0abc4a9d6fe2f" translate="yes" xml:space="preserve">
          <source>Substitute &lt;code&gt;mmk&lt;/code&gt; for &lt;code&gt;mms&lt;/code&gt; above if you're using MMK.</source>
          <target state="translated">MMK를 사용하는 경우 &lt;code&gt;mmk&lt;/code&gt; 를 &lt;code&gt;mms&lt;/code&gt; 로 대체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbc00d62cb7997a305b625c77616bced61d7a767" translate="yes" xml:space="preserve">
          <source>Substitution loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d5a9e6f1c5bae7a50cda20695fb756eee0cc0" translate="yes" xml:space="preserve">
          <source>Substitution of &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; block with:</source>
          <target state="translated">&lt;code&gt;BEGIN { add_100() }&lt;/code&gt; 블록으로 대체 :</target>
        </trans-unit>
        <trans-unit id="6aa080c65a0705bf8b85bd864e5d55d3b8ce1d38" translate="yes" xml:space="preserve">
          <source>Substitution pattern not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618ea16f2fe1c5efd77bdfb863d15430e39ab7d9" translate="yes" xml:space="preserve">
          <source>Substitution replacement not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821f56dfe7408535081734d464b6578d0a9340e7" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in</source>
          <target state="translated">에 설명 된 대체 특정 수정 자</target>
        </trans-unit>
        <trans-unit id="748640ee60ffaf08dbf9cf2300dfb0ab8b09456a" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in &lt;a href=&quot;perlop#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;&quot;s/PATTERN/REPLACEMENT/msixpodualngcer&quot; in perlop&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85608dfc0000ff615c1dec302e3be9c2df7837d" translate="yes" xml:space="preserve">
          <source>Substitutions are made with $col and $row in the output string with the following sprintf() line formats:</source>
          <target state="translated">다음 sprintf () 행 형식으로 출력 문자열에서 $ col 및 $ row로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a34939ee76bec97fd549a9a6b322c326e9dbba" translate="yes" xml:space="preserve">
          <source>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</source>
          <target state="translated">마지막으로 일치해야하는 문자열에 대한 부분 문자열 데이터. 이것은 현재 Perl 엔진에서만 내부적으로 사용되지만 향후 모든 엔진에서 최적화를 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f77c4705ec7e98c86e25e92de290785b8aa469" translate="yes" xml:space="preserve">
          <source>Subtest implementation is more sane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9292ec7a4b6c6d463da3dc2a73e0168876180e17" translate="yes" xml:space="preserve">
          <source>Subtest indentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288c9b632547ccefc043ed0814e269fb40d46750" translate="yes" xml:space="preserve">
          <source>Subtests make use of this hub to route events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de3a6f2fafae521ea8d2aedc747771ba7ff68a0" translate="yes" xml:space="preserve">
          <source>Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call &lt;code&gt;done_testing()&lt;/code&gt; until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.</source>
          <target state="translated">하위 테스트는 Perl 5.12.0과 함께 제공되는 Test :: More 0.94에서 릴리스되었습니다. 하위 테스트는 0.96까지 내재적으로 &lt;code&gt;done_testing()&lt;/code&gt; 호출하지 않았습니다 . 해당 수정 사항이 포함 된 첫 번째 Perl은 0.98의 Perl 5.14.0입니다.</target>
        </trans-unit>
        <trans-unit id="da70c837fb111755e855b0a137562f112a4e55e2" translate="yes" xml:space="preserve">
          <source>Subtle interdependencies between test programs can mask problems - for example an earlier test may neglect to remove a temporary file that affects the behaviour of a later test. To find this kind of problem I use the --shuffle and --reverse options to run my tests in random or reversed order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a773e71238655167a41521fa50857f3f27293a6" translate="yes" xml:space="preserve">
          <source>Subtleties of this behavior may be platform-dependent and may change in the future.</source>
          <target state="translated">이 동작의 미묘함은 플랫폼에 따라 다를 수 있으며 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="532674971418925bf881a12b4532f1662a1e9a91" translate="yes" xml:space="preserve">
          <source>Subtracts $y from $x and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c757fe97bd3bdc11456c873d4a95f5772e2115" translate="yes" xml:space="preserve">
          <source>Success results contain:</source>
          <target state="translated">성공 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f918892a0be28ec22ae2148c6c8b20e089383319" translate="yes" xml:space="preserve">
          <source>Successes</source>
          <target state="translated">Successes</target>
        </trans-unit>
        <trans-unit id="9f13946904481800a60a2508acdf81d63816cbc9" translate="yes" xml:space="preserve">
          <source>Successfully tested means that all &quot;make test&quot; runs finish with a result of 100% OK. All tests were conducted with -Duseshrplib set.</source>
          <target state="translated">성공적으로 테스트되었다는 것은 모든 &quot;make test&quot;실행이 100 % OK의 결과로 완료되었음을 의미합니다. 모든 테스트는 -Duseshrplib 세트로 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="acd9d5af15f64c17e2970ba3b3a2889b142e6fb0" translate="yes" xml:space="preserve">
          <source>Such QP strings can be decoded with:</source>
          <target state="translated">이러한 QP 문자열은 다음을 사용하여 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd751ae4548def6edde9b711d0020609ff568b3" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is the one that matters.</source>
          <target state="translated">이러한 코드는 두 가지 이유로 더 이상 원하는 효과가 없습니다. 첫째, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 한다는 것은 정렬 알고리즘이 런타임까지 변경되지 않아서 효과가 너무 늦다는 것을 의미합니다. 둘째, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 는 런타임에 호출되기도합니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 의 컴파일 시간 값 이 중요한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="142ef3d73b12a657e355c82858c85c2cd7a23472" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;eval()&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;sort::current&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;sort::current&lt;/code&gt; is the one that matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ef159fceda5830f0aa82ac39ad009b226aeb52" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="translated">이러한 조합은 대안을 포함 할 수 있으며, 선택의 문제가 발생합니다. 정규식 &lt;code&gt;a|ab&lt;/code&gt; 를 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 와 일치 시키면 하위 문자열 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 와 일치 합니까? 실제로 일치하는 문자열을 설명하는 한 가지 방법은 (참조 되돌아의 개념 &lt;a href=&quot;#Backtracking&quot;&gt;역행을&lt;/a&gt; ). 그러나이 설명은 너무 수준이 낮으며 특정 구현 측면에서 생각하게합니다.</target>
        </trans-unit>
        <trans-unit id="3a0a0250134ad0585c52e578d2c27b8e55bf21c1" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt;? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d1b0795c68a81e9549d343de87babe2d5446e2" translate="yes" xml:space="preserve">
          <source>Such commands are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">이러한 명령은 아래 의 &quot; &lt;a href=&quot;#Formatting-Codes&quot;&gt;포맷 코드&lt;/a&gt; &quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="610620ff68fcfedc9e4625433127c1fd73d100c6" translate="yes" xml:space="preserve">
          <source>Such constructs are quite frequently used, both because older versions of Perl had no official &lt;code&gt;switch&lt;/code&gt; statement, and also because the new version described immediately below remains experimental and can sometimes be confusing.</source>
          <target state="translated">이러한 구조는 이전 버전의 Perl에 공식적인 &lt;code&gt;switch&lt;/code&gt; 설명 이 없었으며 바로 아래에 설명 된 새 버전이 실험적으로 남아 있고 때로는 혼란 스러울 수 있기 때문에 매우 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea3348659ce40b97978cb89e7a2d2a3c12e7d561" translate="yes" xml:space="preserve">
          <source>Such dangers are not peculiar to the locale system: any aspect of an application's environment which may be modified maliciously presents similar challenges. Similarly, they are not specific to Perl: any programming language that allows you to write programs that take account of their environment exposes you to these issues.</source>
          <target state="translated">이러한 위험은 로케일 시스템에 고유하지 않습니다. 악의적으로 수정 될 수있는 응용 프로그램 환경의 모든 측면에서 비슷한 문제가 발생합니다. 마찬가지로 Perl에만 국한되지는 않습니다. 환경을 고려한 프로그램을 작성할 수있는 프로그래밍 언어는 이러한 문제에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="92e64e08c8f255e5e8a21829e9acd359d7cc7e25" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="translated">이러한 리터럴은 버전 확인을 수행 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 위해 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 및 use 모두에 의해 허용됩니다 . 소켓 패키지의 inet_aton () / inet_ntoa () 루틴을 사용하지 않으면 IPv4 주소에 v- 문자열을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3ece4d85f65108445ce8ad183c4acd13b1bae15" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45d151cfb183e258e5e363109f24149b1db62ae" translate="yes" xml:space="preserve">
          <source>Such modules should</source>
          <target state="translated">이러한 모듈은</target>
        </trans-unit>
        <trans-unit id="7aa5a2112d8e6f60d9221533518e8ad273984dab" translate="yes" xml:space="preserve">
          <source>Such things aside, you can see that a lot can be achieved with a modest amount of code.</source>
          <target state="translated">그러한 것들을 제외하고는, 적당한 양의 코드로 많은 것을 얻을 수 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f289da124b245076253fddcae953c824b46fb88" translate="yes" xml:space="preserve">
          <source>Suggestion for disuse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88beb5e8792960b693418a1e821caf3667e2978e" translate="yes" xml:space="preserve">
          <source>Sum of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="625d4a750d30cd6f4ad0513fdf02b0a356847795" translate="yes" xml:space="preserve">
          <source>Summary Results</source>
          <target state="translated">요약 결과</target>
        </trans-unit>
        <trans-unit id="090f5890d90dd32f61ec60eddd99730f85a15bf5" translate="yes" xml:space="preserve">
          <source>Summary about the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d8f92a0739a61061673d891b1afa8db3bbc87d" translate="yes" xml:space="preserve">
          <source>Summary methods</source>
          <target state="translated">요약 방법</target>
        </trans-unit>
        <trans-unit id="bbeaa09c87f3637cdf1095b67ab5a263e83c735c" translate="yes" xml:space="preserve">
          <source>Summary of Option Specifications</source>
          <target state="translated">옵션 사양 요약</target>
        </trans-unit>
        <trans-unit id="90bd8a629095e4d3e067b9ee655f4a7aef77fe44" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and installing the Developer Tools would be good.</source>
          <target state="translated">요약 : &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 및 개발자 도구 설치가 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fac6a1b8f230cdc10fcc15f1e97d9ef7d5b8d095" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt; .</source>
          <target state="translated">요약 : &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 이고 &lt;code&gt;-lbfd&lt;/code&gt; 가 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="667597966182758709a808e416e091ee04e5a076" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4dd97ceb3548f78756cbaa9fdb900f6de48597" translate="yes" xml:space="preserve">
          <source>Summing up, Perl numeric values can store only those numbers which have a finite decimal expansion or a &quot;short&quot; binary expansion.</source>
          <target state="translated">요약하자면, Perl 숫자 값은 유한 소수 확장 또는 &quot;짧은&quot;이진 확장을 갖는 숫자 만 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30c74d272f700d25fc5ffc72319faf190f9cd38" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of May 2019, the last stable release took place on 2017, and one can buy support contracts for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2aaceda628f6be2c51aa728019480822a4776e" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of November 2005, only an alpha version has been released. Until a release of these compilers is made, support for compiling Perl with these compiler experimental.</source>
          <target state="translated">Sun Microsystems는 Linux 용 Sun Studio 컴파일러의 포트를 출시했습니다. 2005 년 11 월 현재 알파 버전 만 릴리스되었습니다. 이러한 컴파일러가 출시 될 때까지 이러한 컴파일러를 사용하여 Perl을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c878825d39958359a72cd8a76c4798d5c63452e1" translate="yes" xml:space="preserve">
          <source>Sun and GNU make</source>
          <target state="translated">썬과 GNU make</target>
        </trans-unit>
        <trans-unit id="718d79465fef1629218681af768f2453685f48a1" translate="yes" xml:space="preserve">
          <source>Sun's C Compiler</source>
          <target state="translated">썬의 C 컴파일러</target>
        </trans-unit>
        <trans-unit id="6195b0f6879010bbee2ff42c95d1331cc047feb8" translate="yes" xml:space="preserve">
          <source>SunOS 4.x</source>
          <target state="translated">SunOS 4.x</target>
        </trans-unit>
        <trans-unit id="0887ccabfd110aa623b91de64a05467ad2ff0b37" translate="yes" xml:space="preserve">
          <source>Supersede.</source>
          <target state="translated">Supersede.</target>
        </trans-unit>
        <trans-unit id="e16d86479fe3fa44742384e85cda27574322cbc3" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;):</source>
          <target state="translated">정렬을 비교 함수 () (에 기재된 공급 &lt;a href=&quot;functions/sort&quot;&gt;정렬&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="1abf49bb15ef4ea8e1f725a8e57c7d302079a707" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de415e5d5000869495451db35dc93df656397ea8" translate="yes" xml:space="preserve">
          <source>Supply a password. If this token is present, the auto-login process will supply the specified string if the remote server requires a password as part of the login process.</source>
          <target state="translated">비밀번호를 입력하십시오. 이 토큰이 있으면 원격 서버에 로그인 프로세스의 일부로 비밀번호가 필요한 경우 자동 로그인 프로세스가 지정된 문자열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b5e575cc764d4329007cce80f84811dda7921d8" translate="yes" xml:space="preserve">
          <source>Supply an additional account password. If this token is present, the auto-login process will supply the specified string if the remote server requires an additional account password.</source>
          <target state="translated">추가 계정 비밀번호를 제공하십시오. 이 토큰이 있으면 원격 서버에 추가 계정 암호가 필요한 경우 자동 로그인 프로세스가 지정된 문자열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63bb1d0a1fc152b9571b2b05084b5b7573c0a7dc" translate="yes" xml:space="preserve">
          <source>Supply object methods for I/O handles</source>
          <target state="translated">I / O 핸들을위한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="e754d6f0995eab7526c2995e6dd29fc5213bbe9f" translate="yes" xml:space="preserve">
          <source>Supply object methods for directory handles</source>
          <target state="translated">디렉토리 핸들을위한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="9f22ffa5d56d4c5cfa232e27b220356c8959032d" translate="yes" xml:space="preserve">
          <source>Supply object methods for filehandles</source>
          <target state="translated">파일 핸들을위한 공급 객체 메소드</target>
        </trans-unit>
        <trans-unit id="b2a77c0ef03836a7333e41ce4f0c7055106ac057" translate="yes" xml:space="preserve">
          <source>Supply object methods for pipes</source>
          <target state="translated">파이프의 공급 객체 방법</target>
        </trans-unit>
        <trans-unit id="24f8675a681a3fcf0a19ce2f457ac46639a461cc" translate="yes" xml:space="preserve">
          <source>Supply seek based methods for I/O objects</source>
          <target state="translated">I / O 객체에 대한 공급 검색 기반 방법</target>
        </trans-unit>
        <trans-unit id="4577ee52f9d606e12ad2fa9f7ea83ec15081ff52" translate="yes" xml:space="preserve">
          <source>Supplying a count to the</source>
          <target state="translated">에 카운트를 제공</target>
        </trans-unit>
        <trans-unit id="9256abeb61b0e9c2634b93f868b22e3b6be3e559" translate="yes" xml:space="preserve">
          <source>Support for 64-bit Windows added in 5.8 (ActiveState Corp).</source>
          <target state="translated">5.8 (ActiveState Corp)에 64 비트 Windows 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="832ef41556695f42d002862c25aa7f6927ea5c9c" translate="yes" xml:space="preserve">
          <source>Support for 64-bit addressing is experimental: some aspects of Perl may be omitted or buggy. Note the messages output by</source>
          <target state="translated">64 비트 주소 지정 지원은 실험적입니다. Perl의 일부 측면은 생략하거나 버그가있을 수 있습니다. 메시지 출력</target>
        </trans-unit>
        <trans-unit id="dfd649a90bcb497a90c270b395e1aca8e9f13d5a" translate="yes" xml:space="preserve">
          <source>Support for Inside-Out Classes</source>
          <target state="translated">인사이드 아웃 클래스 지원</target>
        </trans-unit>
        <trans-unit id="a6e9ff56bd571fa57e267af64d661fa73e5d1898" translate="yes" xml:space="preserve">
          <source>Support for NO_COLOR was added in Term::ANSIColor 5.01.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74542dacfa191bd88d61863d9855931e106e4c3" translate="yes" xml:space="preserve">
          <source>Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).</source>
          <target state="translated">PERL_OBJECT에 대한 지원이 5.005 (ActiveState Tool Corp)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa9a9b9bea1d915cddc6e189a212373757505afc" translate="yes" xml:space="preserve">
          <source>Support for calling Test::Builder-&amp;gt;note is minimal. It's implemented as an empty stub, so modules that use it will not crash but the calls are not recorded for testing purposes like the others. Patches welcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4152d06f964d8c8500926a55fcc080decb5f3944" translate="yes" xml:space="preserve">
          <source>Support for code 3 (italic) is rare and therefore not mentioned in that table. It is not believed to be fully supported by any of the terminals listed, although it's displayed as green in the Linux console, but it is reportedly supported by urxvt.</source>
          <target state="translated">코드 3 (이탈리아)에 대한 지원은 드물기 때문에 해당 표에 언급되어 있지 않습니다. Linux 콘솔에서 녹색으로 표시되지만 urxvt에서 지원되는 것으로 표시되어 있지만 나열된 모든 터미널에서 완벽하게 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d13a3104d38bfebd2d8edefc71bb43ed89c25719" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; , and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="translated">16에서 256까지의 색상 ( &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; 및 &lt;code&gt;grey&lt;/code&gt; 색상)에 대한 지원 &lt;code&gt;:constants256&lt;/code&gt; 가져 오기 태그, coloralias () 함수 및 ANSI_COLORS_ALIASES 환경 변수에 대한 지원이 Perl 5.17에 포함 된 Term :: ANSIColor 4.00에 추가되었습니다. 8.</target>
        </trans-unit>
        <trans-unit id="21899951038dc28e07a818ac9d52e61c8083b56f" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt;, &lt;code&gt;rgb&lt;/code&gt;, and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d79655477c957d3ded48d250eed51bd3ecf8ff" translate="yes" xml:space="preserve">
          <source>Support for colors 8 through 15 (the &lt;code&gt;bright_&lt;/code&gt; variants) was added in Term::ANSIColor 3.00, included in Perl 5.13.3.</source>
          <target state="translated">Perl 5.13.3에 포함 된 Term :: ANSIColor 3.00에서 8에서 15까지의 색상 ( &lt;code&gt;bright_&lt;/code&gt; variant)에 대한 지원 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3520e7db85802558bb1d2a5a7277d73d6dd7678b" translate="yes" xml:space="preserve">
          <source>Support for concurrent interpreters and the fork() emulation was implemented by ActiveState, with funding from Microsoft Corporation.</source>
          <target state="translated">동시 통역사와 fork () 에뮬레이션에 대한 지원은 Microsoft Corporation의 자금으로 ActiveState에 의해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="46d9a08c8fe0a5fa65df6f50206b3d6f86276cea" translate="yes" xml:space="preserve">
          <source>Support for dark was added in Term::ANSIColor 1.08, included in Perl 5.8.4.</source>
          <target state="translated">어두운 부분에 대한 지원은 Perl 5.8.4에 포함 된 Term :: ANSIColor 1.08에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="13c3f3679453dc21cf99ba9668b08821dc7c3536" translate="yes" xml:space="preserve">
          <source>Support for external gzip added by Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi가 추가 한 외부 gzip 지원 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1d15c06235a8f38ea6479c09486fef84b83b91c" translate="yes" xml:space="preserve">
          <source>Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).</source>
          <target state="translated">fork () 에뮬레이션에 대한 지원이 5.6 (ActiveState Tool Corp)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4da419edd1ac30a4a7b7cbe60b1ff8e03675397f" translate="yes" xml:space="preserve">
          <source>Support for globally overriding glob() (GSAR 3-JUN-98)</source>
          <target state="translated">글로벌 오버라이드 glob () 지원 (GSAR 3-JUN-98)</target>
        </trans-unit>
        <trans-unit id="52d4e9ac29525e6d8e33903392c09e0782a71a40" translate="yes" xml:space="preserve">
          <source>Support for italic was added in Term::ANSIColor 3.02, included in Perl 5.17.1.</source>
          <target state="translated">기울임 꼴 지원은 Perl 5.17.1에 포함 된 Term :: ANSIColor 3.02에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e61014798c019e10930e4b0e0ccb8e127ac816a" translate="yes" xml:space="preserve">
          <source>Support for output other than TAP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fee3b6033badb5f9d6b2ad7b4bd90ed22c35a68" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt; . However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="translated">실제적이고 효과적인 사용자 및 그룹 ID 교환에 대한 지원이 불완전합니다. WinNT에서 Cygwin은 &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; 및 &lt;code&gt;setegid()&lt;/code&gt; 합니다. 그러나 WinNT 액세스 토큰 및 보안 컨텍스트 조작을위한 추가 Cygwin 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5bb747be5ba781647f7ee9e1b01af00ae6891e82" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt;, &lt;code&gt;seteuid()&lt;/code&gt;, &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt;. However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d45f23a800f84de37770824448a89f7d793b8" translate="yes" xml:space="preserve">
          <source>Support for this module is provided via the datetime@perl.org email list. See &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; for more details.</source>
          <target state="translated">이 모듈에 대한 지원은 datetime@perl.org 이메일 목록을 통해 제공됩니다. 자세한 내용은 &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5dad507bd8d5ed70d50a2dce7e70ae220730928" translate="yes" xml:space="preserve">
          <source>Support for threading/forking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b47c288b94e063b5e848ebb4c141831f2f842b" translate="yes" xml:space="preserve">
          <source>Support for threads extends beyond the code in this module (i.e.,</source>
          <target state="translated">스레드 지원은이 모듈의 코드를 넘어 확장됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="21dd6f486b02b193ff80841db50fc3fa27133663" translate="yes" xml:space="preserve">
          <source>Support for true color (the &lt;code&gt;rNNNgNNNbNNN&lt;/code&gt; and &lt;code&gt;on_rNNNgNNNbNNN&lt;/code&gt; attributes), defining aliases in terms of other aliases, and aliases mapping to multiple attributes instead of only a single attribute was added in Term::ANSIColor 5.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebd54c9803d67645a6bec6e8a530fc77962d822" translate="yes" xml:space="preserve">
          <source>Supported Colors</source>
          <target state="translated">지원되는 색상</target>
        </trans-unit>
        <trans-unit id="a65b7f12a991185f44b505808bc867e90d749e20" translate="yes" xml:space="preserve">
          <source>Supported Compilers</source>
          <target state="translated">지원되는 컴파일러</target>
        </trans-unit>
        <trans-unit id="e86357f3df6067cf4701809cd469c16322e01a41" translate="yes" xml:space="preserve">
          <source>Supported Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c494dc50dd3ab8063517ff409c4657b627cea738" translate="yes" xml:space="preserve">
          <source>Supported Perl API, sorted by version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a182e900ad0b28f084dbe30c2f1ab8dc81f123a" translate="yes" xml:space="preserve">
          <source>Supported Platforms</source>
          <target state="translated">지원되는 플랫폼</target>
        </trans-unit>
        <trans-unit id="49b953a7424bb44dd08394b0aeda11553bb12089" translate="yes" xml:space="preserve">
          <source>Supported Platforms (Perl 5.8)</source>
          <target state="translated">지원되는 플랫폼 (Perl 5.8)</target>
        </trans-unit>
        <trans-unit id="b1429d26115432e6f40c246dd70a7c60030a0632" translate="yes" xml:space="preserve">
          <source>Supported are: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Please report as a bug when you need another one supported.</source>
          <target state="translated">&lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; 가 지원됩니다. . 지원되는 다른 버그가 필요할 때 버그로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="a300efed490ba967b52cf87f5ed3078c87e2e5f8" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for &lt;code&gt;tempfile&lt;/code&gt;: UNLINK (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename template is specified using the TEMPLATE option. The OPEN option is not supported (the file is always opened).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef4367afdb333ca61c98475adcf339702a0de4a" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for C</source>
          <target state="translated">지원되는 인수는 C와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fea58cf8a3651927bfad6193b75319d8c2af260d" translate="yes" xml:space="preserve">
          <source>Supported operators include &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aee30f240e3b0641c58b8ea19a5ce4e73c13514" translate="yes" xml:space="preserve">
          <source>Supported versions of Perl</source>
          <target state="translated">지원되는 Perl 버전</target>
        </trans-unit>
        <trans-unit id="16d6bd14e545e871010e04ca5850bc1f495fe10f" translate="yes" xml:space="preserve">
          <source>Supporting CLICOLOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8693c1249e9f6a0e8cf33a70dea32c26fa53d" translate="yes" xml:space="preserve">
          <source>Supports the same options as the &lt;code&gt;tempdir&lt;/code&gt; function. Note that directories created with this method default to CLEANUP =&amp;gt; 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab85bed1d3b1a215699ee5c1c8be8f331ffab56" translate="yes" xml:space="preserve">
          <source>Supports the same options as the C</source>
          <target state="translated">C와 동일한 옵션을 지원합니다</target>
        </trans-unit>
        <trans-unit id="68a10bfa60258c2bbfe38e9f1a7ff60f4694f8f6" translate="yes" xml:space="preserve">
          <source>Suppose instead, that if no matching &quot;/endpara&quot; tag is found, the &quot;/para&quot; tag refers only to the immediately following paragraph:</source>
          <target state="translated">대신, 일치하는 &quot;/ endpara&quot;태그가 없으면 &quot;/ para&quot;태그가 바로 다음 단락 만 참조한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2e98ea3f847f379e1d62458409b455691002c8" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt; . This is all we need:</source>
          <target state="translated">이상한 이유로 표준 C 라이브러리 함수 &lt;code&gt;fputs()&lt;/code&gt; 주위에 랩퍼가 필요하다고 가정하십시오 . 이것이 우리에게 필요한 전부입니다.</target>
        </trans-unit>
        <trans-unit id="cc6556ba8db25d3e88bccf33270c985ae50ea100" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt;. This is all we need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9713a66e131c3277390fd2e0a638134463da779" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Then one can use</source>
          <target state="translated">이전 예제 함수에서 multiply (), divide (), add (), subtract ()에 대한 포인터 가 오프셋이 &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; 인 전역 C 배열 &lt;code&gt;fp[]&lt;/code&gt; 유지 된다고 가정하십시오 . 그런 다음 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ea8ab19bf86289ef6108d40f927555e5f4e3c590" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt;, &lt;code&gt;divide_off&lt;/code&gt;, &lt;code&gt;add_off&lt;/code&gt;, &lt;code&gt;subtract_off&lt;/code&gt;. Then one can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b728cf8454bb8ebd395d51ef450a37f61ee3df" translate="yes" xml:space="preserve">
          <source>Suppose that we want to enable a new RE escape-sequence &lt;code&gt;\Y|&lt;/code&gt; which matches at a boundary between whitespace characters and non-whitespace characters. Note that &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; matches exactly at these positions, so we want to have each &lt;code&gt;\Y|&lt;/code&gt; in the place of the more complicated version. We can create a module &lt;code&gt;customre&lt;/code&gt; to do this:</source>
          <target state="translated">새로운 RE 이스케이프 시퀀스 &lt;code&gt;\Y|&lt;/code&gt; 공백 문자와 공백이 아닌 문자의 경계에서 일치합니다. 하는 것으로는 &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; 우리가 서로 갖고 싶어, 그래서 정확히이 위치에서 일치 &lt;code&gt;\Y|&lt;/code&gt; 더 복잡한 버전 대신에. &lt;code&gt;customre&lt;/code&gt; 위해 모듈 사용자 정의 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ab2eaff078de5c28b462a36a77339cffbb8f320" translate="yes" xml:space="preserve">
          <source>Suppose that you have some C files implementing some functionality, and the corresponding header files. How to create an extension which makes this functionality accessible in Perl? The example below assumes that the header files are</source>
          <target state="translated">일부 기능을 구현하는 C 파일과 해당 헤더 파일이 있다고 가정하십시오. Perl에서이 기능에 액세스 할 수 있도록 확장 기능을 만드는 방법은 무엇입니까? 아래 예제는 헤더 파일이</target>
        </trans-unit>
        <trans-unit id="0a98ed263af8d4ba63e18dadba6d2dc4eec20053" translate="yes" xml:space="preserve">
          <source>Suppose we wrote the following string to a file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38ce69c0f981610bad14796ceb31eadf517ce86" translate="yes" xml:space="preserve">
          <source>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</source>
          <target state="translated">배열 참조와 해시 참조로 액세스 할 수있는 객체를 생성한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="abacd026fc80e9051241fe69f59c13539803bbd4" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &amp;lt;a&amp;gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt; . Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">&quot;1122a44&quot;와 같은 문자열에서 모든 연속적인 숫자 쌍을 일치시키고 숫자가 아닌 경우 일치를 중지한다고 가정하십시오. &lt;code&gt;11&lt;/code&gt; 과 &lt;code&gt;22&lt;/code&gt; 를 일치 시키려고하지만 &amp;lt;a&amp;gt; 문자가 &lt;code&gt;22&lt;/code&gt; 와 &lt;code&gt;44&lt;/code&gt; 사이에 표시 되고 &lt;code&gt;a&lt;/code&gt; 에서 멈추기를 원합니다 . 단순히 일치하는 숫자 쌍은 &lt;code&gt;a&lt;/code&gt; 를 건너 뛰고 여전히 &lt;code&gt;44&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="43b6b33a52cb0c2ab7e4d2d5a81bdf49073103dc" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &lt;code&gt;a&lt;/code&gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt;. Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc722b9b16484d706d6ab120abc391e667f22c8" translate="yes" xml:space="preserve">
          <source>Suppose you wanted &lt;code&gt;ARGUMENTS&lt;/code&gt; to be an empty list,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f46adab557fd8dab8b4b0b09a159b2654c69a5" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the unassigned characters:</source>
          <target state="translated">원시 블록 범위가 아닌 할당 된 문자 만 일치 시키려고한다고 가정하십시오. 즉, 할당되지 않은 문자를 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7282725934a73028b4873e419044ca1541b7ef81" translate="yes" xml:space="preserve">
          <source>Suppose your function looks like this:</source>
          <target state="translated">함수가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdc33b87c0a24861f5653d7a4749ecf4d10599b" translate="yes" xml:space="preserve">
          <source>Suppress statically defined functions from the profile.</source>
          <target state="translated">프로파일에서 정적으로 정의 된 기능을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="f000eea4b15966462d081470a0dbb8675e040042" translate="yes" xml:space="preserve">
          <source>Suppress the verbose descriptions in the profile.</source>
          <target state="translated">프로파일에서 자세한 설명을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d411f9454876226deea65132d8958b5f310ebd" translate="yes" xml:space="preserve">
          <source>Suppresses echoing of input data on the screen as it is entered on the keyboard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ca7a4b62d0d93f13a11c00e6e1ef2ac15f93d" translate="yes" xml:space="preserve">
          <source>Suppressing Lines Where All Fields Are Void</source>
          <target state="translated">모든 필드가 비어있는 라인 억제</target>
        </trans-unit>
        <trans-unit id="f8a4d33a75006d37aaaa326a12ea28f45b06e609" translate="yes" xml:space="preserve">
          <source>Suppressing all output.</source>
          <target state="translated">모든 출력을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="4db0aec339465e45f71592f3d61d3b7d5519b564" translate="yes" xml:space="preserve">
          <source>Suppressing everything but the tests summary.</source>
          <target state="translated">테스트 요약을 제외한 모든 것을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="3118002fe0231bc240b745efda50a51f4811af55" translate="yes" xml:space="preserve">
          <source>Suppressing some test output (mostly failures while tests are running).</source>
          <target state="translated">일부 테스트 출력 억제 (주로 테스트 실행 중 실패)</target>
        </trans-unit>
        <trans-unit id="2f0421f55fddacae44a5e70879884253681983a3" translate="yes" xml:space="preserve">
          <source>Surprisingly, &lt;code&gt;decode&lt;/code&gt; will ignore these flags and so treat all input values as governed by the &lt;code&gt;utf8&lt;/code&gt; flag. If it is disabled, this allows you to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf2f474284f3bb3469459a5f2e282c817445e0a" translate="yes" xml:space="preserve">
          <source>Surprisingly, the following dangerous-looking construct will actually work out fine:</source>
          <target state="translated">놀랍게도 다음과 같은 위험한 구조는 실제로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="89de18d6062f8f62c80480423d64e1771fc8ce04" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; . If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="translated">놀랍게도, 호출 될 루틴의 이름은 &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; 입니다. 고정 된 스칼라를 다른 머신으로 보내 &lt;code&gt;nfreeze&lt;/code&gt; 대신 휴대용 이미지를 얻기 위해 nfreeze 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="38b1f8d5199fc680c670a3cdffbc331409087673" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt;. If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a047875b873f6d1d398e86dbb7108d34705540" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
          <target state="translated">대리 쌍</target>
        </trans-unit>
        <trans-unit id="07a0eab00168ce9bedc809f5ad8c9eb56cbd1edb" translate="yes" xml:space="preserve">
          <source>Surrogate pairs were born when the Unicode Consortium finally admitted that 16 bits were not big enough to hold all the world's character repertoires. But they already made UCS-2 16-bit. What do we do?</source>
          <target state="translated">유니 코드 컨소시엄이 16 비트가 세계의 모든 문자 레퍼토리를 보유 할만큼 크지 않다는 것을 마침내 인정했을 때 대리 쌍이 탄생했습니다. 그러나 그들은 이미 UCS-2를 16 비트로 만들었습니다. 우리는 무엇을해야합니까?</target>
        </trans-unit>
        <trans-unit id="1eaaa69a37b20a485ea6f0e51d7a77d119e19f29" translate="yes" xml:space="preserve">
          <source>Surrogates are code points set aside to encode the &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; range of Unicode code points in pairs of 16-bit units. The</source>
          <target state="translated">서로 게이트는 16 비트 단위의 쌍으로 유니 코드 코드 포인트 의 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 범위 를 인코딩하기 위해 별도로 마련된 코드 포인트입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="856dbe523b5bc18c3ac9b4ef67ed5a73d664d082" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="translated">대리자는 다른 코드 포인트를 나타 내기 위해 쌍으로 사용하는 것 외에는 유니 코드에서 의미가 없습니다. 그러나 Perl은 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt; 을 말함으로써 내부적으로 개별적으로 표현 될 수있게하여 오픈 인터체인지에 유효한 것만이 아닌 모든 코드 포인트가 표현 될 수 있도록합니다. 유니 코드는 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 와 같은 의미를 정의합니다. is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . 자신의 사용은 다소 위험하므로 그러나 펄은 (경고 범주 사용하여 경고합니다 &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; 의 하위 범주입니다, &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 낮은 한 경우, 또는 일치하는 사건을 맡아 같은 시도가 일을하게되는 경우를) -무감각하게 또는 출력합니다. (그러나 5.14 이전에는 Perls에서 시도하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="7e4f255eb9d4da0b778db2cbd0767cd7435fa252" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;chr(0xD801)&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt;. But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540da7a8cd172c1838160d487b9d7ef0924efc97" translate="yes" xml:space="preserve">
          <source>Suspicious Warnings on Cygwin</source>
          <target state="translated">Cygwin에 대한 의심스러운 경고</target>
        </trans-unit>
        <trans-unit id="ade7a22fa4aa1143e2d2d4f40f65a94eb90d8572" translate="yes" xml:space="preserve">
          <source>SvAMAGIC_off</source>
          <target state="translated">SvAMAGIC_off</target>
        </trans-unit>
        <trans-unit id="9b9fa0e67675873845864411f1905f615bc33d13" translate="yes" xml:space="preserve">
          <source>SvAMAGIC_on</source>
          <target state="translated">SvAMAGIC_on</target>
        </trans-unit>
        <trans-unit id="2425fee0a45344518684d0c9b14dde2323fe9de7" translate="yes" xml:space="preserve">
          <source>SvCUR</source>
          <target state="translated">SvCUR</target>
        </trans-unit>
        <trans-unit id="6058a9ad780b864ec71080d419dca4d99c96b0e6" translate="yes" xml:space="preserve">
          <source>SvCUR_set</source>
          <target state="translated">SvCUR_set</target>
        </trans-unit>
        <trans-unit id="661476f7df6dbc01af035711108e0d1500868903" translate="yes" xml:space="preserve">
          <source>SvEND</source>
          <target state="translated">SvEND</target>
        </trans-unit>
        <trans-unit id="e59e241299dce8584448d13053a18ac8814b51ab" translate="yes" xml:space="preserve">
          <source>SvGAMAGIC</source>
          <target state="translated">SvGAMAGIC</target>
        </trans-unit>
        <trans-unit id="aebf3d2208b03126421cfebdd2654ea2db0a30f7" translate="yes" xml:space="preserve">
          <source>SvGETMAGIC</source>
          <target state="translated">SvGETMAGIC</target>
        </trans-unit>
        <trans-unit id="4ddf923c756d56139db1069ad97f7b8f40e70f94" translate="yes" xml:space="preserve">
          <source>SvGROW</source>
          <target state="translated">SvGROW</target>
        </trans-unit>
        <trans-unit id="abfa953c1fed37e05526c0219c09e917f51bbd9e" translate="yes" xml:space="preserve">
          <source>SvIOK</source>
          <target state="translated">SvIOK</target>
        </trans-unit>
        <trans-unit id="c0e62457bc773af183a3e1d8cda75a5f3adbaf1c" translate="yes" xml:space="preserve">
          <source>SvIOK_UV</source>
          <target state="translated">SvIOK_UV</target>
        </trans-unit>
        <trans-unit id="cfbeae889fea001d8bb1a161c1f0da0c7af2b5f7" translate="yes" xml:space="preserve">
          <source>SvIOK_notUV</source>
          <target state="translated">SvIOK_notUV</target>
        </trans-unit>
        <trans-unit id="8f0272bd6fc26a005d760d2fea687329b0e4a68c" translate="yes" xml:space="preserve">
          <source>SvIOK_off</source>
          <target state="translated">SvIOK_off</target>
        </trans-unit>
        <trans-unit id="34a30cb8e77826bc36fe6388f6c8eb39936d73d8" translate="yes" xml:space="preserve">
          <source>SvIOK_on</source>
          <target state="translated">SvIOK_on</target>
        </trans-unit>
        <trans-unit id="eed3c603a946c2dcc8e9ac46fa3cd88ac634ee17" translate="yes" xml:space="preserve">
          <source>SvIOK_only</source>
          <target state="translated">SvIOK_only</target>
        </trans-unit>
        <trans-unit id="13e3f4df7cd8f72b57259101aa3948f2204a9335" translate="yes" xml:space="preserve">
          <source>SvIOK_only_UV</source>
          <target state="translated">SvIOK_only_UV</target>
        </trans-unit>
        <trans-unit id="45a18c6bb3b31a95939140770d9eaf87b85c8af4" translate="yes" xml:space="preserve">
          <source>SvIOKp</source>
          <target state="translated">SvIOKp</target>
        </trans-unit>
        <trans-unit id="e58c0b91b4f10ba7ea023ead483916f688590254" translate="yes" xml:space="preserve">
          <source>SvIV</source>
          <target state="translated">SvIV</target>
        </trans-unit>
        <trans-unit id="1e1cd0c78512c809bc8f82ce5a88755a660fc1dd" translate="yes" xml:space="preserve">
          <source>SvIV()</source>
          <target state="translated">SvIV()</target>
        </trans-unit>
        <trans-unit id="e3f836b31a83cc11f5f8cc34d3ffa47690b79351" translate="yes" xml:space="preserve">
          <source>SvIVX</source>
          <target state="translated">SvIVX</target>
        </trans-unit>
        <trans-unit id="a7e83f79d851aa05c23e8e127c1c0104d7becb61" translate="yes" xml:space="preserve">
          <source>SvIV_nomg</source>
          <target state="translated">SvIV_nomg</target>
        </trans-unit>
        <trans-unit id="d54d9f546b2a3ee3896c8e62f21916b605c8749e" translate="yes" xml:space="preserve">
          <source>SvIV_set</source>
          <target state="translated">SvIV_set</target>
        </trans-unit>
        <trans-unit id="d0e6c181ed31a5825fe2aba5e86b6714622736fc" translate="yes" xml:space="preserve">
          <source>SvIVx</source>
          <target state="translated">SvIVx</target>
        </trans-unit>
        <trans-unit id="bfb611e82edc20e454e089941049df596bb71192" translate="yes" xml:space="preserve">
          <source>SvIsCOW</source>
          <target state="translated">SvIsCOW</target>
        </trans-unit>
        <trans-unit id="9aecfe6c9cbba3f5b8ffdf25297fd019b7b2eaf2" translate="yes" xml:space="preserve">
          <source>SvIsCOW_shared_hash</source>
          <target state="translated">SvIsCOW_shared_hash</target>
        </trans-unit>
        <trans-unit id="80a0475edeea5c18e06234c9d64a8fcc2e3f6c39" translate="yes" xml:space="preserve">
          <source>SvLEN</source>
          <target state="translated">SvLEN</target>
        </trans-unit>
        <trans-unit id="556d85f2a0063cc9ba584af5e853a1ceb2f6783d" translate="yes" xml:space="preserve">
          <source>SvLEN_set</source>
          <target state="translated">SvLEN_set</target>
        </trans-unit>
        <trans-unit id="97aec17efc79908cfbaf02941eae143d8b976a42" translate="yes" xml:space="preserve">
          <source>SvLOCK</source>
          <target state="translated">SvLOCK</target>
        </trans-unit>
        <trans-unit id="84cc200fa83f3f6ed106b0dd44cb7c16363e0435" translate="yes" xml:space="preserve">
          <source>SvMAGIC_set</source>
          <target state="translated">SvMAGIC_set</target>
        </trans-unit>
        <trans-unit id="d379abe0c8da0cf1e20d037eb2f8185f062b9489" translate="yes" xml:space="preserve">
          <source>SvNIOK</source>
          <target state="translated">SvNIOK</target>
        </trans-unit>
        <trans-unit id="fb4f99f52267211a93dc9edb5e96013ebf799d8e" translate="yes" xml:space="preserve">
          <source>SvNIOK_off</source>
          <target state="translated">SvNIOK_off</target>
        </trans-unit>
        <trans-unit id="defaa8b9a1718665f488a28ac6a6a046a710c0d6" translate="yes" xml:space="preserve">
          <source>SvNIOKp</source>
          <target state="translated">SvNIOKp</target>
        </trans-unit>
        <trans-unit id="ca25134015aee24be79876d35dd93a74df11c721" translate="yes" xml:space="preserve">
          <source>SvNOK</source>
          <target state="translated">SvNOK</target>
        </trans-unit>
        <trans-unit id="baaa77e5fd0bf7672f89eaeb72acc5efa6ff8b0c" translate="yes" xml:space="preserve">
          <source>SvNOK_off</source>
          <target state="translated">SvNOK_off</target>
        </trans-unit>
        <trans-unit id="dd1f88650a4a7b063453463c4580f0b16fabe2d4" translate="yes" xml:space="preserve">
          <source>SvNOK_on</source>
          <target state="translated">SvNOK_on</target>
        </trans-unit>
        <trans-unit id="1b8500076baeb528cecf476027ad962a134be104" translate="yes" xml:space="preserve">
          <source>SvNOK_only</source>
          <target state="translated">SvNOK_only</target>
        </trans-unit>
        <trans-unit id="df8a270b374b63fb7ad234036190cb6d9599dc79" translate="yes" xml:space="preserve">
          <source>SvNOKp</source>
          <target state="translated">SvNOKp</target>
        </trans-unit>
        <trans-unit id="17482a420e00ffd25f7122c8a4e97ab029e48c16" translate="yes" xml:space="preserve">
          <source>SvNV</source>
          <target state="translated">SvNV</target>
        </trans-unit>
        <trans-unit id="dbc4878fd112ac06a09fc11cde47bb125aee2c3f" translate="yes" xml:space="preserve">
          <source>SvNV()</source>
          <target state="translated">SvNV()</target>
        </trans-unit>
        <trans-unit id="f62717e28cc640cdf47f8dd6ee4c879eb42bea28" translate="yes" xml:space="preserve">
          <source>SvNVX</source>
          <target state="translated">SvNVX</target>
        </trans-unit>
        <trans-unit id="dd86bbe5ae725800fcf2d56c703e0a31d42e3a42" translate="yes" xml:space="preserve">
          <source>SvNV_nomg</source>
          <target state="translated">SvNV_nomg</target>
        </trans-unit>
        <trans-unit id="c026cc4a3dbd70507f3a01baf8b04c8414942781" translate="yes" xml:space="preserve">
          <source>SvNV_set</source>
          <target state="translated">SvNV_set</target>
        </trans-unit>
        <trans-unit id="6a541df7bd973627ec28ca14270b2c53a16dac8e" translate="yes" xml:space="preserve">
          <source>SvNVx</source>
          <target state="translated">SvNVx</target>
        </trans-unit>
        <trans-unit id="020d091cc2310c06e45f2bc3d53eba7c49731b6d" translate="yes" xml:space="preserve">
          <source>SvOK</source>
          <target state="translated">SvOK</target>
        </trans-unit>
        <trans-unit id="0580de03ad05ae223672bac31eca2ff976a459f8" translate="yes" xml:space="preserve">
          <source>SvOOK</source>
          <target state="translated">SvOOK</target>
        </trans-unit>
        <trans-unit id="4dde88ed106842ab159cd28a6c4d036172ee28c7" translate="yes" xml:space="preserve">
          <source>SvOOK_offset</source>
          <target state="translated">SvOOK_offset</target>
        </trans-unit>
        <trans-unit id="b4ad9d1f5c7f6646cd2710f7f7da0b899e3a96cb" translate="yes" xml:space="preserve">
          <source>SvPOK</source>
          <target state="translated">SvPOK</target>
        </trans-unit>
        <trans-unit id="5654f39dee44eae829fb8b496682a50f0982a5e7" translate="yes" xml:space="preserve">
          <source>SvPOK_off</source>
          <target state="translated">SvPOK_off</target>
        </trans-unit>
        <trans-unit id="3fc674f1095783934e3ac6f2709bc63b02d7430c" translate="yes" xml:space="preserve">
          <source>SvPOK_on</source>
          <target state="translated">SvPOK_on</target>
        </trans-unit>
        <trans-unit id="63cf7f854220f91309bc16c8b83e2c3a33c8ab02" translate="yes" xml:space="preserve">
          <source>SvPOK_only</source>
          <target state="translated">SvPOK_only</target>
        </trans-unit>
        <trans-unit id="6181decd9d199af54afc923b0ff0ebf390a6d7b4" translate="yes" xml:space="preserve">
          <source>SvPOK_only_UTF8</source>
          <target state="translated">SvPOK_only_UTF8</target>
        </trans-unit>
        <trans-unit id="1f6818d473538e1037ae99abfd3928b6194d55f4" translate="yes" xml:space="preserve">
          <source>SvPOKp</source>
          <target state="translated">SvPOKp</target>
        </trans-unit>
        <trans-unit id="7565784ec8ed0b2a10e7ce11934bff895f7866ad" translate="yes" xml:space="preserve">
          <source>SvPV</source>
          <target state="translated">SvPV</target>
        </trans-unit>
        <trans-unit id="935c09deb58ecb63d6891adc1aabec93c4c8a5b7" translate="yes" xml:space="preserve">
          <source>SvPV()</source>
          <target state="translated">SvPV()</target>
        </trans-unit>
        <trans-unit id="bf9de3c1167813342adaabc11e3c1b95d085aee2" translate="yes" xml:space="preserve">
          <source>SvPVCLEAR</source>
          <target state="translated">SvPVCLEAR</target>
        </trans-unit>
        <trans-unit id="441e4866b0c8dfdb41e2b081d770159832861536" translate="yes" xml:space="preserve">
          <source>SvPVX</source>
          <target state="translated">SvPVX</target>
        </trans-unit>
        <trans-unit id="bb779035a6b5212f5bc497064139d582eac78761" translate="yes" xml:space="preserve">
          <source>SvPV_force</source>
          <target state="translated">SvPV_force</target>
        </trans-unit>
        <trans-unit id="a371ca6a1e78ccac0de2a78800f60864935747e1" translate="yes" xml:space="preserve">
          <source>SvPV_force_nomg</source>
          <target state="translated">SvPV_force_nomg</target>
        </trans-unit>
        <trans-unit id="e460005b105a2b7bfd76b6a69fac89cf40b7f1d9" translate="yes" xml:space="preserve">
          <source>SvPV_nolen</source>
          <target state="translated">SvPV_nolen</target>
        </trans-unit>
        <trans-unit id="ee503ff4f441fd072927bc4adf1a3b2b61c96eb8" translate="yes" xml:space="preserve">
          <source>SvPV_nomg</source>
          <target state="translated">SvPV_nomg</target>
        </trans-unit>
        <trans-unit id="7dc0def922bcc926f6b2a0768c4dc6365edb9c39" translate="yes" xml:space="preserve">
          <source>SvPV_nomg_nolen</source>
          <target state="translated">SvPV_nomg_nolen</target>
        </trans-unit>
        <trans-unit id="b294767f00b4898e2955e33a91d5667698462a42" translate="yes" xml:space="preserve">
          <source>SvPV_set</source>
          <target state="translated">SvPV_set</target>
        </trans-unit>
        <trans-unit id="8dfe9329a5a7e9cb118b1baf10944b5ae534ec2e" translate="yes" xml:space="preserve">
          <source>SvPVbyte</source>
          <target state="translated">SvPVbyte</target>
        </trans-unit>
        <trans-unit id="a42257f4844c980ccf0e6066f8db9f6f15894819" translate="yes" xml:space="preserve">
          <source>SvPVbyte_force</source>
          <target state="translated">SvPVbyte_force</target>
        </trans-unit>
        <trans-unit id="37adc1f4cfd7a587db4e891abb49367190445337" translate="yes" xml:space="preserve">
          <source>SvPVbyte_nolen</source>
          <target state="translated">SvPVbyte_nolen</target>
        </trans-unit>
        <trans-unit id="7923345fa2b2955faca8c97835509b73e61c0f71" translate="yes" xml:space="preserve">
          <source>SvPVbyte_nomg</source>
          <target state="translated">SvPVbyte_nomg</target>
        </trans-unit>
        <trans-unit id="7dabdc96dfd70ff777704e95caf484a1bbd67626" translate="yes" xml:space="preserve">
          <source>SvPVbyte_or_null</source>
          <target state="translated">SvPVbyte_or_null</target>
        </trans-unit>
        <trans-unit id="6f473eaded3b18d22bd0cfbd398f1d3838819074" translate="yes" xml:space="preserve">
          <source>SvPVbyte_or_null_nomg</source>
          <target state="translated">SvPVbyte_or_null_nomg</target>
        </trans-unit>
        <trans-unit id="00286cef8b77db9493694652d7e00120622a74fd" translate="yes" xml:space="preserve">
          <source>SvPVbytex</source>
          <target state="translated">SvPVbytex</target>
        </trans-unit>
        <trans-unit id="fed8330e0b39b1ac7a27526d358e6d7bd6a90609" translate="yes" xml:space="preserve">
          <source>SvPVbytex_force</source>
          <target state="translated">SvPVbytex_force</target>
        </trans-unit>
        <trans-unit id="b302138ff008911538b45179c44f73ff2f15910d" translate="yes" xml:space="preserve">
          <source>SvPVutf8</source>
          <target state="translated">SvPVutf8</target>
        </trans-unit>
        <trans-unit id="a8de8e18c45d70ca0a2ee1f75e6737824757551e" translate="yes" xml:space="preserve">
          <source>SvPVutf8_force</source>
          <target state="translated">SvPVutf8_force</target>
        </trans-unit>
        <trans-unit id="34b12f7ac99c5d36b41f8c87cb93ef246cef0211" translate="yes" xml:space="preserve">
          <source>SvPVutf8_nolen</source>
          <target state="translated">SvPVutf8_nolen</target>
        </trans-unit>
        <trans-unit id="423ddab605b2202c3b3c7cf1a6aab74e87847180" translate="yes" xml:space="preserve">
          <source>SvPVutf8_nomg</source>
          <target state="translated">SvPVutf8_nomg</target>
        </trans-unit>
        <trans-unit id="4266cc27f9fcb29ce91587ace651e07d810d65b5" translate="yes" xml:space="preserve">
          <source>SvPVutf8_or_null</source>
          <target state="translated">SvPVutf8_or_null</target>
        </trans-unit>
        <trans-unit id="d92f3b72d1647089e88a44d2515cd6a801386b09" translate="yes" xml:space="preserve">
          <source>SvPVutf8_or_null_nomg</source>
          <target state="translated">SvPVutf8_or_null_nomg</target>
        </trans-unit>
        <trans-unit id="35823de756974d226740f00e5c68a6481e4ed0de" translate="yes" xml:space="preserve">
          <source>SvPVutf8x</source>
          <target state="translated">SvPVutf8x</target>
        </trans-unit>
        <trans-unit id="7def8a7e5746a1d922bd31c60d3cb8a70d51aa60" translate="yes" xml:space="preserve">
          <source>SvPVutf8x_force</source>
          <target state="translated">SvPVutf8x_force</target>
        </trans-unit>
        <trans-unit id="6b594f1f8b6cd1295001275a5c619bad5200c1fb" translate="yes" xml:space="preserve">
          <source>SvPVx</source>
          <target state="translated">SvPVx</target>
        </trans-unit>
        <trans-unit id="4fa947438e302d4c0cfa0fd091b866be1356e841" translate="yes" xml:space="preserve">
          <source>SvREADONLY</source>
          <target state="translated">SvREADONLY</target>
        </trans-unit>
        <trans-unit id="be79d366d9292bb9353ad47fa578f3ba4c51d644" translate="yes" xml:space="preserve">
          <source>SvREADONLY(THING, [, $value])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76ee936f6a9d9874c72ac97c2ae38c0ac457002" translate="yes" xml:space="preserve">
          <source>SvREADONLY_off</source>
          <target state="translated">SvREADONLY_off</target>
        </trans-unit>
        <trans-unit id="ebbbefde1cfff96f373b3af6c19695b6b47fe85c" translate="yes" xml:space="preserve">
          <source>SvREADONLY_on</source>
          <target state="translated">SvREADONLY_on</target>
        </trans-unit>
        <trans-unit id="41356e74473a3c2dd231981a54cbf8916dae6a6f" translate="yes" xml:space="preserve">
          <source>SvREFCNT</source>
          <target state="translated">SvREFCNT</target>
        </trans-unit>
        <trans-unit id="e21722a974d6353587902b5def5af30f86188580" translate="yes" xml:space="preserve">
          <source>SvREFCNT(THING [, $value])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbc1bf9563ab155051e035e471f156eba22dc15" translate="yes" xml:space="preserve">
          <source>SvREFCNT_dec</source>
          <target state="translated">SvREFCNT_dec</target>
        </trans-unit>
        <trans-unit id="6d3d7d60ea55b7e2400d8e3c957adb22ceec857f" translate="yes" xml:space="preserve">
          <source>SvREFCNT_dec_NN</source>
          <target state="translated">SvREFCNT_dec_NN</target>
        </trans-unit>
        <trans-unit id="d6d6cfefd8cf7744542e901404792f234eef8a87" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc</source>
          <target state="translated">SvREFCNT_inc</target>
        </trans-unit>
        <trans-unit id="b1c71741a55c44f3cf76f940293fd4e4067b6c8c" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_NN</source>
          <target state="translated">SvREFCNT_inc_NN</target>
        </trans-unit>
        <trans-unit id="6e813ab000508b7b24df3398011a2c9c250e9d3d" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple</source>
          <target state="translated">SvREFCNT_inc_simple</target>
        </trans-unit>
        <trans-unit id="67b0407bf6132cb27ed090533a37abfe3f7d17e7" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_NN</source>
          <target state="translated">SvREFCNT_inc_simple_NN</target>
        </trans-unit>
        <trans-unit id="355f655fe4c86d54f671992d7a810ce7e8512bc2" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_void</source>
          <target state="translated">SvREFCNT_inc_simple_void</target>
        </trans-unit>
        <trans-unit id="822614c7d4b2a58a9282398c20eb02c49458d68d" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_void_NN</source>
          <target state="translated">SvREFCNT_inc_simple_void_NN</target>
        </trans-unit>
        <trans-unit id="c6f050b18183b6e90800a93ea7e82b46868d707f" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_void</source>
          <target state="translated">SvREFCNT_inc_void</target>
        </trans-unit>
        <trans-unit id="149f6e6626b6f4ebd70bdf3a3eb889b7ec93bdf3" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_void_NN</source>
          <target state="translated">SvREFCNT_inc_void_NN</target>
        </trans-unit>
        <trans-unit id="3889ade1aec07364b71e18598417719a90402368" translate="yes" xml:space="preserve">
          <source>SvROK</source>
          <target state="translated">SvROK</target>
        </trans-unit>
        <trans-unit id="b4e270c3ae40052ec524acd38a350e379d3010aa" translate="yes" xml:space="preserve">
          <source>SvROK_off</source>
          <target state="translated">SvROK_off</target>
        </trans-unit>
        <trans-unit id="c7a1d36a4bff0e8c7571cf20c8d6a3df05ea6d45" translate="yes" xml:space="preserve">
          <source>SvROK_on</source>
          <target state="translated">SvROK_on</target>
        </trans-unit>
        <trans-unit id="3551ff814d3508fe0494321baf0b08462a5951a1" translate="yes" xml:space="preserve">
          <source>SvRV</source>
          <target state="translated">SvRV</target>
        </trans-unit>
        <trans-unit id="98657f4eb633c067b2f4bbd96111ec20385af83f" translate="yes" xml:space="preserve">
          <source>SvRV_set</source>
          <target state="translated">SvRV_set</target>
        </trans-unit>
        <trans-unit id="5231d45a15ed6a1e96e1c7adf65310a112ccdb14" translate="yes" xml:space="preserve">
          <source>SvRX</source>
          <target state="translated">SvRX</target>
        </trans-unit>
        <trans-unit id="8bf53e27da8805a20511f9e414f46c9a92c3fe7c" translate="yes" xml:space="preserve">
          <source>SvRXOK</source>
          <target state="translated">SvRXOK</target>
        </trans-unit>
        <trans-unit id="6ce588dbb5a26b48845042b1fed998c7094f41b9" translate="yes" xml:space="preserve">
          <source>SvSETMAGIC</source>
          <target state="translated">SvSETMAGIC</target>
        </trans-unit>
        <trans-unit id="03b9e565f8509ce2cdd182d158dca6b07c40361c" translate="yes" xml:space="preserve">
          <source>SvSHARE</source>
          <target state="translated">SvSHARE</target>
        </trans-unit>
        <trans-unit id="663202fcb6a07de7521aee49ad200856328f670e" translate="yes" xml:space="preserve">
          <source>SvSTASH</source>
          <target state="translated">SvSTASH</target>
        </trans-unit>
        <trans-unit id="1e4dda9ea59b23608fcebfdab0f78b8414975f4b" translate="yes" xml:space="preserve">
          <source>SvSTASH_set</source>
          <target state="translated">SvSTASH_set</target>
        </trans-unit>
        <trans-unit id="55f331b95bad8451772b832cb2896cd13d8a62bf" translate="yes" xml:space="preserve">
          <source>SvSetMagicSV</source>
          <target state="translated">SvSetMagicSV</target>
        </trans-unit>
        <trans-unit id="a2363fa9b8d5575fdee7b5f5137de002a0d7fbd7" translate="yes" xml:space="preserve">
          <source>SvSetMagicSV_nosteal</source>
          <target state="translated">SvSetMagicSV_nosteal</target>
        </trans-unit>
        <trans-unit id="a870c5f5f765c31be19cc225270f373bf2a19609" translate="yes" xml:space="preserve">
          <source>SvSetSV</source>
          <target state="translated">SvSetSV</target>
        </trans-unit>
        <trans-unit id="0a56b40c972eb03057e49afb45a5f79c3b3c850c" translate="yes" xml:space="preserve">
          <source>SvSetSV_nosteal</source>
          <target state="translated">SvSetSV_nosteal</target>
        </trans-unit>
        <trans-unit id="3757c6ffdf931a1f2a0babe56b6b7bcfa87d7dcd" translate="yes" xml:space="preserve">
          <source>SvTAINT</source>
          <target state="translated">SvTAINT</target>
        </trans-unit>
        <trans-unit id="b132d1a6ca07d23104de48a3a5b9b9e288757452" translate="yes" xml:space="preserve">
          <source>SvTAINTED</source>
          <target state="translated">SvTAINTED</target>
        </trans-unit>
        <trans-unit id="da48b96bbbd0a5ec83161761506d58ef29de8d6a" translate="yes" xml:space="preserve">
          <source>SvTAINTED_off</source>
          <target state="translated">SvTAINTED_off</target>
        </trans-unit>
        <trans-unit id="e468ae6914e87cdb2b57113711db192dcf342f4e" translate="yes" xml:space="preserve">
          <source>SvTAINTED_on</source>
          <target state="translated">SvTAINTED_on</target>
        </trans-unit>
        <trans-unit id="0daba26132d99fae2f657acc44a21ff8e035bd1a" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST</source>
          <target state="translated">SvTHINKFIRST</target>
        </trans-unit>
        <trans-unit id="d644182b7fecca2e84a27663743f7d7d1731110e" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</source>
          <target state="translated">SvTHINKFIRST는 때때로 오 탐지를 생성합니다. 이 경우 sv_force_normal은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b4f8344aad95fbd47f327c9ffb82473442fdc07" translate="yes" xml:space="preserve">
          <source>SvTRUE</source>
          <target state="translated">SvTRUE</target>
        </trans-unit>
        <trans-unit id="5591dda75f8cb8334b1aa5f7592580f0e1465a90" translate="yes" xml:space="preserve">
          <source>SvTRUE_nomg</source>
          <target state="translated">SvTRUE_nomg</target>
        </trans-unit>
        <trans-unit id="ef07939a32727e62f23ab3bf8294ee0ae227b03b" translate="yes" xml:space="preserve">
          <source>SvTRUEx</source>
          <target state="translated">SvTRUEx</target>
        </trans-unit>
        <trans-unit id="d0b53af1ac0ffb7024eea6f6ecb8a708b9c38980" translate="yes" xml:space="preserve">
          <source>SvTYPE</source>
          <target state="translated">SvTYPE</target>
        </trans-unit>
        <trans-unit id="b775bed176614e9a49e8732c4986d2b2525760f8" translate="yes" xml:space="preserve">
          <source>SvUNLOCK</source>
          <target state="translated">SvUNLOCK</target>
        </trans-unit>
        <trans-unit id="54b59fb943f1a8c6fc241231137d882737d769f5" translate="yes" xml:space="preserve">
          <source>SvUOK</source>
          <target state="translated">SvUOK</target>
        </trans-unit>
        <trans-unit id="a5569c2ff8aba92fd99ba9b2df30c443b34a6f1f" translate="yes" xml:space="preserve">
          <source>SvUPGRADE</source>
          <target state="translated">SvUPGRADE</target>
        </trans-unit>
        <trans-unit id="4cd670c5feb308ed3b15e5b58b2f681b4c5bb579" translate="yes" xml:space="preserve">
          <source>SvUTF8</source>
          <target state="translated">SvUTF8</target>
        </trans-unit>
        <trans-unit id="12aa020f8a66c3e1d0a998e5c7796999c4211ab4" translate="yes" xml:space="preserve">
          <source>SvUTF8_off</source>
          <target state="translated">SvUTF8_off</target>
        </trans-unit>
        <trans-unit id="31712c4817da7a521357a0236b626c9b62700a5d" translate="yes" xml:space="preserve">
          <source>SvUTF8_on</source>
          <target state="translated">SvUTF8_on</target>
        </trans-unit>
        <trans-unit id="97e374818598ae8696854ce66ebfe26153cf81d6" translate="yes" xml:space="preserve">
          <source>SvUV</source>
          <target state="translated">SvUV</target>
        </trans-unit>
        <trans-unit id="1c39bfc4cdacb7f60ffec9b7097060595b0abf27" translate="yes" xml:space="preserve">
          <source>SvUVX</source>
          <target state="translated">SvUVX</target>
        </trans-unit>
        <trans-unit id="cf7246c4c0c7e22abb4930c099853bf5a86af5d1" translate="yes" xml:space="preserve">
          <source>SvUVXx</source>
          <target state="translated">SvUVXx</target>
        </trans-unit>
        <trans-unit id="37b28974a3152d2c3de1c657d9b3df720c807e0b" translate="yes" xml:space="preserve">
          <source>SvUV_nomg</source>
          <target state="translated">SvUV_nomg</target>
        </trans-unit>
        <trans-unit id="728d716b7fe1f957388320e1810e447969265d9c" translate="yes" xml:space="preserve">
          <source>SvUV_set</source>
          <target state="translated">SvUV_set</target>
        </trans-unit>
        <trans-unit id="f0070f4312b6d3c4e9753ebbebd42cc576a21cc7" translate="yes" xml:space="preserve">
          <source>SvUVx</source>
          <target state="translated">SvUVx</target>
        </trans-unit>
        <trans-unit id="2b2c80bf0f6f562d3d900c990060affb4cc3cdbb" translate="yes" xml:space="preserve">
          <source>SvVOK</source>
          <target state="translated">SvVOK</target>
        </trans-unit>
        <trans-unit id="72ddd2b619af6d6a73febf80f7fcad22495498cd" translate="yes" xml:space="preserve">
          <source>Sweden</source>
          <target state="translated">Sweden</target>
        </trans-unit>
        <trans-unit id="d1e609cdf540975b2ef838162ca1765da2f782c9" translate="yes" xml:space="preserve">
          <source>Switch (?(condition)... contains too many branches in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388b56e3569a3c2f26662f9bd0bad1aef19a414d" translate="yes" xml:space="preserve">
          <source>Switch (?(condition)... not terminated in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d140830d04307683300b42c263a4bad9b2b05e6" translate="yes" xml:space="preserve">
          <source>Switch Statements</source>
          <target state="translated">스위치 문</target>
        </trans-unit>
        <trans-unit id="81f3afb94b79b127f4ba3f323efbf6b5702494d6" translate="yes" xml:space="preserve">
          <source>Switch condition not recognized in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd9a48c2b8a06497ad155d8fb2e22e3efb40ec2" translate="yes" xml:space="preserve">
          <source>Switch off optimizations.</source>
          <target state="translated">최적화를 끕니다.</target>
        </trans-unit>
        <trans-unit id="3bb7fa365adb6d9413c8c9a8c7435723660691af" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; statement. If</source>
          <target state="translated">다른 파일보기로 전환하거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문. 만약</target>
        </trans-unit>
        <trans-unit id="d701d90d00f98c308677ac71f008ef2cd2b1b580" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;eval&lt;/code&gt; statement. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc7caf5e748552e870fbdf8c7d017c5fa6cf84c" translate="yes" xml:space="preserve">
          <source>Switched to JSON serialization from YAML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941726dc5468b689bfb5334269ab159c8c5ac044" translate="yes" xml:space="preserve">
          <source>Switches On the &quot;#!&quot; Line</source>
          <target state="translated">&quot;#!&quot;스위치 선</target>
        </trans-unit>
        <trans-unit id="22865b749e47c4f80690e8fbf02747aa53e87248" translate="yes" xml:space="preserve">
          <source>Switches include:</source>
          <target state="translated">스위치에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1a104dee1272b5ea48fa02cf2cd55d0cf5980bda" translate="yes" xml:space="preserve">
          <source>Switches which take an argument don't care whether there is a space between the switch and the argument. If unspecified switches are found on the command-line, the user will be warned that an unknown option was given.</source>
          <target state="translated">인수를 취하는 스위치는 스위치와 인수 사이에 공백이 있는지 여부는 상관하지 않습니다. 명령 줄에 지정되지 않은 스위치가 있으면 알 수없는 옵션이 제공되었다는 경고 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88a10266365bec895433e46eaf4bb0d9f4319fa6" translate="yes" xml:space="preserve">
          <source>Switching in a loop</source>
          <target state="translated">루프에서 전환</target>
        </trans-unit>
        <trans-unit id="77dcd849e550afec3c83d38fcc8cbc72c058f4db" translate="yes" xml:space="preserve">
          <source>Switzerland</source>
          <target state="translated">Switzerland</target>
        </trans-unit>
        <trans-unit id="c4833a3fbcd559394f2c58d1f54c950e1415a542" translate="yes" xml:space="preserve">
          <source>Sx is an interface to the Athena widget set which comes with X, but again it appears not to be much used nowadays.</source>
          <target state="translated">Sx는 X와 함께 제공되는 Athena 위젯 세트에 대한 인터페이스이지만 요즘에는 많이 사용되지 않는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="cd32c48fcfdab7a133c532cff3d2d0c939be7f22" translate="yes" xml:space="preserve">
          <source>Symbian</source>
          <target state="translated">Symbian</target>
        </trans-unit>
        <trans-unit id="899b34f07ea283295bd5ac5271424c60aff58966" translate="yes" xml:space="preserve">
          <source>Symbian (Series 60 v3, 3.2 and 5 - what else?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="6f23f00b2c5559251a269c3e95612a03f0fa5304" translate="yes" xml:space="preserve">
          <source>Symbol - manipulate Perl symbols and their names</source>
          <target state="translated">기호-Perl 기호 및 이름 조작</target>
        </trans-unit>
        <trans-unit id="e2434de5e406913ebf6a3ac33e80e10d4a315aea" translate="yes" xml:space="preserve">
          <source>Symbol Encodings</source>
          <target state="translated">심볼 인코딩</target>
        </trans-unit>
        <trans-unit id="d794fc2c3b0c30f40edbe0d808d2368ffeb21d98" translate="yes" xml:space="preserve">
          <source>Symbol Tables</source>
          <target state="translated">심벌 테이블</target>
        </trans-unit>
        <trans-unit id="4b05d7078c77af4d667a4898e87b6c3188ae4b11" translate="yes" xml:space="preserve">
          <source>Symbolic Calculator</source>
          <target state="translated">상징적 인 계산기</target>
        </trans-unit>
        <trans-unit id="37008620b710f26771f72ef684d0d762ce0c312d" translate="yes" xml:space="preserve">
          <source>Symbolic Links</source>
          <target state="translated">심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="d0a9fa28cc57e07ecbedf349e28f66a417dbd550" translate="yes" xml:space="preserve">
          <source>Symbolic Unary Operators</source>
          <target state="translated">상징적 인 단항 연산자</target>
        </trans-unit>
        <trans-unit id="c85b29041363945d0d38e6dd76ab2012cab61284" translate="yes" xml:space="preserve">
          <source>Symbolic links will be replicated in the destination directory. If &lt;b&gt;-l&lt;/b&gt; is not specified, then links are skipped over.</source>
          <target state="translated">심볼릭 링크는 대상 디렉토리에 복제됩니다. &lt;b&gt;-l 인&lt;/b&gt; 경우&lt;b&gt;&lt;/b&gt; 지정되지 않은, 다음 링크를 통해 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5740fe00b50befc25ecdbfe2ce1dcb268f365ae5" translate="yes" xml:space="preserve">
          <source>Symbolic methods</source>
          <target state="translated">상징적 방법</target>
        </trans-unit>
        <trans-unit id="2ed5a46b240bca78e1ebda87bbf53e151430ff41" translate="yes" xml:space="preserve">
          <source>Symbolic references</source>
          <target state="translated">상징적 참조</target>
        </trans-unit>
        <trans-unit id="11ea83f8147883e582553aebb48729beba5bdaf1" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma 에서는 기호 참조가 금지되어 &lt;a href=&quot;functions/use&quot;&gt;있습니다&lt;/a&gt; . 그것들은 참된 참조가 아니므로 참조 횟수 나 가비지 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af9f81a30b480e3a5214ee12ab8f0ac2f3b093d2" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;use strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3d231a255923086dc7e82179bb6e9c216f886c" translate="yes" xml:space="preserve">
          <source>Symbolic references are names of variables or other objects, just as a symbolic link in a Unix filesystem contains merely the name of a file. The &lt;code&gt;*glob&lt;/code&gt; notation is something of a symbolic reference. (Symbolic references are sometimes called &quot;soft references&quot;, but please don't call them that; references are confusing enough without useless synonyms.)</source>
          <target state="translated">기호 참조는 Unix 파일 시스템의 기호 링크에 파일 이름 만 포함 된 것처럼 변수 또는 다른 객체의 이름입니다. &lt;code&gt;*glob&lt;/code&gt; 표기는 심볼릭 참조의 무언가이다. (심볼 참조는 &quot;소프트 참조&quot;라고도하지만 호출하지 마십시오. 참조는 쓸모없는 동의어없이 충분히 혼란 스럽습니다.)</target>
        </trans-unit>
        <trans-unit id="7eb647835a30e5a1bbf74157fa14f494b596a5c9" translate="yes" xml:space="preserve">
          <source>Symbols representing the concepts &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;, and &amp;ldquo;not&amp;rdquo;.</source>
          <target state="translated">개념 &quot;and&quot;, &quot;or&quot;, &quot;xor&quot;및 &quot;not&quot;을 나타내는 기호</target>
        </trans-unit>
        <trans-unit id="bc32943d7841b88a1cf40309071785aab7d4e9d1" translate="yes" xml:space="preserve">
          <source>Synchronization and control</source>
          <target state="translated">동기화 및 제어</target>
        </trans-unit>
        <trans-unit id="3cea5373055c1ded68843107ad2f2e539bd093c5" translate="yes" xml:space="preserve">
          <source>Synology manufactures a vast number of Network Attached Storage (NAS) devices that are very popular in large organisations as well as small businesses and homes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6877f381ee0675d5bd925a8ea887b401ae7a51" translate="yes" xml:space="preserve">
          <source>Synonymous options (like both the short and long forms) are separated by a comma and a space on the same &lt;code&gt;=item&lt;/code&gt; line, or optionally listed as their own item with a reference to the canonical name. For example, since &lt;b&gt;--section&lt;/b&gt; can also be written as &lt;b&gt;-s&lt;/b&gt;, the above would be:</source>
          <target state="translated">동의어 옵션 (짧은 형식과 긴 형식 모두)은 동일한 &lt;code&gt;=item&lt;/code&gt; 줄 에 쉼표와 공백으로 구분 되거나 선택적으로 표준 이름을 참조하여 자체 항목으로 나열됩니다. 예를 들어 &lt;b&gt;--section&lt;/b&gt; 을 &lt;b&gt;-s&lt;/b&gt; 로 쓸 수도 있으므로 위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcbf093f7bdc572a445b9a43606c7f7a83836b33" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;recipient&lt;/code&gt; 동의어 .</target>
        </trans-unit>
        <trans-unit id="79fdd2d4dec4b005410dc78b4fc5a2b54509cf1c" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="af5f0a5e089ff24df87876664a300fc1d94de87c" translate="yes" xml:space="preserve">
          <source>Synopsis:</source>
          <target state="translated">Synopsis:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="69c40972b3eb05b16c311ef5e1e2135fa3fd9faa" translate="yes" xml:space="preserve">
          <source>Syntax error in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb07c71de4335da146595d32e9320b5a8140d2f2" translate="yes" xml:space="preserve">
          <source>Syntax error in =encoding directive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90738f5d4b2229f3a4c124484c36b1275df5262" translate="yes" xml:space="preserve">
          <source>Syntax for invoking shar, tar and zip differs from that for Unix.</source>
          <target state="translated">shar, tar 및 zip 호출 구문은 Unix의 구문과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7d8c7607abfe852f9a6ad8648332314d9917e637" translate="yes" xml:space="preserve">
          <source>Syntax of Attribute Lists</source>
          <target state="translated">속성 목록의 구문</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="be3351180e2a37f5c7ceb3ef2e3724ddf7a09419" translate="yes" xml:space="preserve">
          <source>Syohei YOSHIDA &amp;lt;syohex@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0785d5c2121b7134c4af7c65680f001acb76a92c" translate="yes" xml:space="preserve">
          <source>Sys$Library</source>
          <target state="translated">Sys$Library</target>
        </trans-unit>
        <trans-unit id="65fb3d73b0b7d628e2887a67776fd305bc37b9e6" translate="yes" xml:space="preserve">
          <source>Sys$Share</source>
          <target state="translated">Sys$Share</target>
        </trans-unit>
        <trans-unit id="dbb39438e97d2bc740ddc791cb728708fa6deab2" translate="yes" xml:space="preserve">
          <source>Sys$System:</source>
          <target state="translated">Sys$System:</target>
        </trans-unit>
        <trans-unit id="48fee1621e8e0fbac3a51bb7b722933258b770f4" translate="yes" xml:space="preserve">
          <source>Sys::Hostname</source>
          <target state="translated">Sys::Hostname</target>
        </trans-unit>
        <trans-unit id="2e415aac42b72faad3c72367e40e8717dbc66b3c" translate="yes" xml:space="preserve">
          <source>Sys::Hostname - Try every conceivable way to get hostname</source>
          <target state="translated">Sys :: Hostname-가능한 모든 방법으로 호스트 이름을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="c1e878d92efc49a2e4d7c74bab56ecb4df79e136" translate="yes" xml:space="preserve">
          <source>Sys::Syslog</source>
          <target state="translated">Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="d0e7c26b96f1913c444745d08172cdce4e0c92fa" translate="yes" xml:space="preserve">
          <source>Sys::Syslog - Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">Sys :: Syslog-UNIX syslog (3) 호출에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="70083380e8efc0c90f74c992ef02124b7c1f9076" translate="yes" xml:space="preserve">
          <source>Sys::Syslog::Win32</source>
          <target state="translated">Sys::Syslog::Win32</target>
        </trans-unit>
        <trans-unit id="cfe74b88debb47d505f4b0c08319f0ca059d43ec" translate="yes" xml:space="preserve">
          <source>Sys::Syslog::Win32 - Win32 support for Sys::Syslog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c9e6fce8c27f1db38faca8727f60ffbd03b1df" translate="yes" xml:space="preserve">
          <source>SysV IPC</source>
          <target state="translated">SysV IPC</target>
        </trans-unit>
        <trans-unit id="b769fe98988d4570b7169913197897773fb46367" translate="yes" xml:space="preserve">
          <source>SysV Msg IPC object class</source>
          <target state="translated">SysV Msg IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="1b5cd833684b7ef6a59dab44ff94b295bccc40b4" translate="yes" xml:space="preserve">
          <source>SysV Semaphore IPC object class</source>
          <target state="translated">SysV 세마포어 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="71c44529ecac23b5c9809ec7a57f43fadf59d867" translate="yes" xml:space="preserve">
          <source>SysV Shared Memory IPC object class</source>
          <target state="translated">SysV 공유 메모리 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="40f6355398d4cc8e6d990f10eb780e3725d4416e" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno). Note that some system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45e7e358eb9351a96a4b4d44c0db473a81b0bd0" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall은 호출하는 시스템 호출에 의해 반환 된 값을 반환합니다. 시스템 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 일부 시스템 호출</target>
        </trans-unit>
        <trans-unit id="e0b761d47162708932873aa746a0b31a4af21afe" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall은 호출하는 시스템 호출에 의해 반환 된 값을 반환합니다. 시스템 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 일부 시스템 호출</target>
        </trans-unit>
        <trans-unit id="53aa71666c5046c70bdb9cfa19d05f3e5e2dbe70" translate="yes" xml:space="preserve">
          <source>Syslogging with Perl</source>
          <target state="translated">Perl로 Syslogging</target>
        </trans-unit>
        <trans-unit id="b9c23727af44d87276c73142b1bbc56acfa2ff99" translate="yes" xml:space="preserve">
          <source>Sysroot.U</source>
          <target state="translated">Sysroot.U</target>
        </trans-unit>
        <trans-unit id="80c0b230762f1b4764b9bec6b3b1ff958262b7bd" translate="yes" xml:space="preserve">
          <source>System CPU Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286ad58c359f169cf560ed965ca49713b4161be5" translate="yes" xml:space="preserve">
          <source>System Interaction</source>
          <target state="translated">시스템 상호 작용</target>
        </trans-unit>
        <trans-unit id="a5f5e2adb8b84a09a3496b92bfc8ae6f7818b5f8" translate="yes" xml:space="preserve">
          <source>System Resources</source>
          <target state="translated">시스템 리소스</target>
        </trans-unit>
        <trans-unit id="12920688fafa23a0e3538825316e84488141b30c" translate="yes" xml:space="preserve">
          <source>System Specifics</source>
          <target state="translated">시스템 사양</target>
        </trans-unit>
        <trans-unit id="d6112adb659d79581ddf0b5cc4c94caed341f770" translate="yes" xml:space="preserve">
          <source>System V %s is not implemented on this machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c80f9799bbc3cebb5501e8db9a2d073ae25632e" translate="yes" xml:space="preserve">
          <source>System V IPC constants and system calls</source>
          <target state="translated">System V IPC 상수 및 시스템 호출</target>
        </trans-unit>
        <trans-unit id="c4b08ad7296a6185b44d15785cd2e71597984993" translate="yes" xml:space="preserve">
          <source>System V interprocess communication functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16956db37d0c77a530acbdbc4b5059785173084f" translate="yes" xml:space="preserve">
          <source>System calls accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; as the path separator. However, many command-line utilities of DOS vintage treat &lt;code&gt;/&lt;/code&gt; as the option prefix, so may get confused by filenames containing &lt;code&gt;/&lt;/code&gt;. Aside from calling any external programs, &lt;code&gt;/&lt;/code&gt; will work just fine, and probably better, as it is more consistent with popular usage, and avoids the problem of remembering what to backwhack and what not to.</source>
          <target state="translated">시스템 호출 은 경로 구분자로 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; 를 허용합니다 . 그러나 DOS 빈티지의 많은 명령 줄 유틸리티는 &lt;code&gt;/&lt;/code&gt; 를 옵션 접두어로 취급 하므로 &lt;code&gt;/&lt;/code&gt; 가 포함 된 파일 이름과 혼동 될 수 있습니다 . 외부 프로그램을 호출하는 것 외에도 &lt;code&gt;/&lt;/code&gt; 는 널리 사용되는 것과 더 일관성이 있기 때문에 잘 작동하며 아마도 더 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f24e94ced298a298739ba1339ef795f85bd6541" translate="yes" xml:space="preserve">
          <source>System calls at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007271cb98a5608fe64c06188e43289d61f1c7bd" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="translated">시스템 호출은 오류 발생시 -1 (이유로 ERRNO 설정)을 반환하고 성공시 (보통 0)을 반환합니다. 리턴 값이 -1이면이 유형 맵은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 리턴 값이 -1이 아닌 경우,이 유형 맵은 0 (perl false)을 &quot;0 but true&quot;(perl true)로 변환하거나 값 자체를 리턴하여 명령이 성공했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2359b820aa0452b65508553cdd45209d3b858de3" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;undef&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb78d5fbb36025d1ade73acf0ec1dc017253b7c6" translate="yes" xml:space="preserve">
          <source>System calls such as link(), unlink(), rename(), etc. return nonzero for success, not 0. (system(), however, returns zero for success.)</source>
          <target state="translated">link (), unlink (), rename () 등과 같은 시스템 호출은 성공이 아닌 0이 아닌 0을 반환합니다. (system ()은 성공을 위해 0을 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="a5bfc62972086e83c2f9e4d6647ba3081448737b" translate="yes" xml:space="preserve">
          <source>System errno constants</source>
          <target state="translated">시스템 오류 상수</target>
        </trans-unit>
        <trans-unit id="0464247110efd6dc873ab7d03699ac46391aa089" translate="yes" xml:space="preserve">
          <source>SystemV Interprocess Communications:</source>
          <target state="translated">SystemV 프로세스 간 통신 :</target>
        </trans-unit>
        <trans-unit id="a183fb872a859df2f57021c9ab88f775bce8ce4c" translate="yes" xml:space="preserve">
          <source>Systems that don't use GDBM compatibilty for ndbm support will be using a platform specific library, possibly inherited from BSD systems, where it may or may not be safe to use an untrusted file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae914465ea54a3f354cb49e4c193a3ffe266b8f" translate="yes" xml:space="preserve">
          <source>Systems that don't use GDBM compatibilty for old dbm support will be using a platform specific library, possibly inherited from BSD systems, where it may or may not be safe to use an untrusted file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="5217808996f069ddbc219ab5febe206f9d89f653" translate="yes" xml:space="preserve">
          <source>T2_KEEP_TEMPDIR=0</source>
          <target state="translated">T2_KEEP_TEMPDIR=0</target>
        </trans-unit>
        <trans-unit id="463b5addcced0fba1581ac4edc4526052505db59" translate="yes" xml:space="preserve">
          <source>T2_TEMPDIR_TEMPLATE='test2-XXXXXX'</source>
          <target state="translated">T2_TEMPDIR_TEMPLATE='test2-XXXXXX'</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="9f94efb44fe911a9e20566c2b4f9e9743238c25c" translate="yes" xml:space="preserve">
          <source>TABLE OF CONTENTS</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="3b4df05d703541d151d3e3628328bb8fd532308b" translate="yes" xml:space="preserve">
          <source>TAP GRAMMAR</source>
          <target state="translated">탭 그래머</target>
        </trans-unit>
        <trans-unit id="1920029d62435d8577df2572dd0096bfaff76178" translate="yes" xml:space="preserve">
          <source>TAP pragma token.</source>
          <target state="translated">TAP 프라 그마 토큰.</target>
        </trans-unit>
        <trans-unit id="a6ad0c7cbda3b41f87bebc3eecd396afa503fee6" translate="yes" xml:space="preserve">
          <source>TAP syntax version token.</source>
          <target state="translated">TAP 구문 버전 토큰.</target>
        </trans-unit>
        <trans-unit id="3876ffd2c762f78e88b10fd7b5ed6b67ff853ed5" translate="yes" xml:space="preserve">
          <source>TAP::Base</source>
          <target state="translated">TAP::Base</target>
        </trans-unit>
        <trans-unit id="9b1c8b8b7e60c2d2e7b147def758851a2032505c" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393bbdfe5b0291f7582e0a00a859897a43f52662" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="translated">TAP :: Base- &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 및 &lt;a href=&quot;harness&quot;&gt;TAP :: Harness에&lt;/a&gt; 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="863c519a681845de61f18ccf2d91ed2bae4b3a87" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base</source>
          <target state="translated">TAP::Formatter::Base</target>
        </trans-unit>
        <trans-unit id="2219301c0e6ab7a0cac653627940a66913b4e00c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base - Base class for harness output delegates</source>
          <target state="translated">TAP :: Formatter :: Base-하네스 출력 대리자를위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="737a5324c5901c02f42ad717687b54b1dafd7c3b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color</source>
          <target state="translated">TAP::Formatter::Color</target>
        </trans-unit>
        <trans-unit id="83dc9a13e5e40b4cace713c5d42771d2b5bb47e0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color - Run Perl test scripts with color</source>
          <target state="translated">TAP :: Formatter :: Color-색상으로 Perl 테스트 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="de057ff7c6b5e40851d3c50d32e9750e339c5926" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console</source>
          <target state="translated">TAP::Formatter::Console</target>
        </trans-unit>
        <trans-unit id="e5caa85b06270fe34451b375ee12674e638dd733" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console - Harness output delegate for default console output</source>
          <target state="translated">TAP :: Formatter :: Console-기본 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="01b7c503e4f8a4af70b89b685b263fa99a7779a7" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession</target>
        </trans-unit>
        <trans-unit id="db7bd0c049621f91358c7128fbd5472680ec6d31" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output</source>
          <target state="translated">TAP :: Formatter :: Console :: ParallelSession-병렬 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="e10aa0877a249858e704e343610555a15b6331f0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session</source>
          <target state="translated">TAP::Formatter::Console::Session</target>
        </trans-unit>
        <trans-unit id="617e83a9b0bba0c6a87c6403d55512035b5d4331" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session - Harness output delegate for default console output</source>
          <target state="translated">TAP :: Formatter :: Console :: Session-기본 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="ebcc51d604eabcfa523d96f91dc1b0eb51dccb7d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File</source>
          <target state="translated">TAP::Formatter::File</target>
        </trans-unit>
        <trans-unit id="ce9e5131d6998f180ee6abe8bad4643f869cfb3d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File - Harness output delegate for file output</source>
          <target state="translated">TAP :: Formatter :: File-파일 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="5a53ebb59dd4ba13f5939d6a9f81cddf3e1c6f45" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session</source>
          <target state="translated">TAP::Formatter::File::Session</target>
        </trans-unit>
        <trans-unit id="360d8f026e4e5483612bf0275831836f9ffb249f" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session - Harness output delegate for file output</source>
          <target state="translated">TAP :: Formatter :: File :: Session-파일 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="46af53bbf8c7eee3da8d825fcace74fe474d232b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session</source>
          <target state="translated">TAP::Formatter::Session</target>
        </trans-unit>
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">TAP :: Formatter :: Session-하네스 출력 대리자를위한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP :: Harness-통계를 사용하여 테스트 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="a28a3f4d3229f49494c71baca96520e2ecfb6ce6" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env</source>
          <target state="translated">TAP::Harness::Env</target>
        </trans-unit>
        <trans-unit id="91f28a5a62ef8f799cd7525ba0b5759ca2448d9c" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env - Parsing harness related environmental variables where appropriate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object-모든 &lt;code&gt;TAP::*&lt;/code&gt; 모듈에 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="f762f998d40c617b51b08688208676705b948fa6" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser- &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; 출력 구문 분석</target>
        </trans-unit>
        <trans-unit id="947140d84d6dc3586ce66227c8fbf3b5502269bb" translate="yes" xml:space="preserve">
          <source>TAP::Parser also supports callbacks; bailout, comment, plan, test, unknown, version and yaml are called for the corresponding TAP result types, ALL is called for all results, ELSE is called for all results for which a named callback is not installed and EOF is called once at the end of each TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP :: Parser :: Aggregator-집계 TAP :: Parser 결과</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP :: Parser :: Grammar-Test Anything Protocol의 문법입니다.</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP :: Parser :: Iterator-TAP 소스 반복기의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Array-배열 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Process-프로세스 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Stream-파일 핸들 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP :: Parser :: IteratorFactory-주어진 소스에 사용할 SourceHandler 객체를 알아냅니다.</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP :: Parser :: Multiplexer-다중 다중 TAP :: Parsers</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser :: Result-TAP :: Parser 출력 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Bailout-차단 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Comment-댓글 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Plan-계획 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP :: Parser :: Result :: Pragma-TAP 프라 그마 토큰.</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Test-테스트 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Unknown-알 수없는 결과 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP :: Parser :: Result :: Version-TAP 구문 버전 토큰.</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP :: Parser :: Result :: YAML-YAML 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser :: ResultFactory-TAP :: Parser 출력 오브젝트를 작성하기위한 팩토리</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP :: Parser :: Scheduler-병렬 테스트 중 스케줄 테스트</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP :: Parser :: Scheduler :: Job-단일 테스트 작업입니다.</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">TAP :: Parser :: Scheduler :: Spinner-작업이 없습니다.</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source-TAP 소스 및 메타 데이터</target>
        </trans-unit>
        <trans-unit id="b88d422ffa232da21769ecf23f36c9215fb7316d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler</source>
          <target state="translated">TAP::Parser::SourceHandler</target>
        </trans-unit>
        <trans-unit id="7a11e510cbf8229cb9deefa589961e1880c0ef0c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler - Base class for different TAP source handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567fb9a0760765f024156fd52b7260852fb83a9f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable</source>
          <target state="translated">TAP::Parser::SourceHandler::Executable</target>
        </trans-unit>
        <trans-unit id="def5a816ec0112a978d703f8596c8df1a84fd5e0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable - Stream output from an executable TAP source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7855e6a236f3f1bba1561cccffbc0253a8b41c1a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File</source>
          <target state="translated">TAP::Parser::SourceHandler::File</target>
        </trans-unit>
        <trans-unit id="c84a46ff700384567f810cc0dbe5e4d5b91c8613" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File - Stream TAP from a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75757e90ca350dfe386979f74159d3e72435290" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle</source>
          <target state="translated">TAP::Parser::SourceHandler::Handle</target>
        </trans-unit>
        <trans-unit id="b6f0bcffb30af38c06936b6bf1545dd5a83277c1" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle - Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4545cce101afaf68b0bd75f8cbbb180c6b160964" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl</source>
          <target state="translated">TAP::Parser::SourceHandler::Perl</target>
        </trans-unit>
        <trans-unit id="04e054f8c028c674d2c9287cae69082bbf9ce520" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl - Stream TAP from a Perl executable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849652a7b8f5b288e476708d89c71b634dc488c2" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP</source>
          <target state="translated">TAP::Parser::SourceHandler::RawTAP</target>
        </trans-unit>
        <trans-unit id="7fe676e21d00db4b7e1f5adc9ab5a7fc5c10349f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP - Stream output from raw TAP in a scalar/array ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP :: Parser :: YAMLish :: Reader-반복자에서 YAMLish 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP :: Parser :: YAMLish :: Writer-YAMLish 데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="5b754807c6604c3c6635f1f0f60d367a6cffd283" translate="yes" xml:space="preserve">
          <source>TAPx Developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4682dfeedc4e9ca5c57ef7dd969ecc22339454" translate="yes" xml:space="preserve">
          <source>TARG</source>
          <target state="translated">TARG</target>
        </trans-unit>
        <trans-unit id="f762108ca727f0bcd961fc7467c248887dfa70dc" translate="yes" xml:space="preserve">
          <source>TARGET</source>
          <target state="translated">TARGET</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
