<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">버그보고</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">버그 보고서</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">버그와주의 사항</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">버그와 자극</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">버그 및 제한</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">버그와 함정</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">버그 및 경고</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWIN의 버그</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">버그와주의 사항</target>
        </trans-unit>
        <trans-unit id="6c450a35b54bd0a62e732cbab24c3d7221d9a194" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</source>
          <target state="translated">버그는 버그 보고서를 게시하기위한 이메일 또는 URL입니다. UPSTREAM =&amp;gt; ' &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;blead&lt;/a&gt; '가있는 모듈의 경우 mailto : perl5-porters@perl.org를 사용하십시오 . rt.cpan.org는 CPAN 모듈에 대한 URL을 자동으로 제공하는 것처럼 보입니다. 여기에 제공된 모든 값이 기본값을 재정의합니다. &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS는 버그 보고서를 게시하는 이메일 또는 URL입니다. UPSTREAM =&amp;gt; 'blead'인 모듈의 경우 perl5-porters@perl.org를 사용하십시오. rt.cpan.org는 CPAN 모듈의 URL을 자동으로 제공하는 것으로 보입니다. 여기에 주어진 값은 기본값을 재정의합니다. &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt; $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">구축 및 설치</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">새로운 확장 프로그램 구축</target>
        </trans-unit>
        <trans-unit id="915ac3e12b39990a3ff0eb519c7c070afd799641" translate="yes" xml:space="preserve">
          <source>BUILDING</source>
          <target state="translated">BUILDING</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">DOS에서 모듈 구축 및 설치</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">OPENVOS를위한 건물 펄</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">AMIGAOS의 건물 펄</target>
        </trans-unit>
        <trans-unit id="d40a175e7a653e9eaa67c4da87c76fc937184284" translate="yes" xml:space="preserve">
          <source>BUILD_REQUIRES</source>
          <target state="translated">BUILD_REQUIRES</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Perl이 C 라이브러리와 연결하기위한 XS 시스템을 사용하기 전에 프로그래머는 C 헤더 파일을 통해 라이브러리 상수를 가져 왔습니다. 여전히 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; 또는 이와 유사한 것이 &lt;a href=&quot;functions/require&quot;&gt;필요하다는 것을&lt;/a&gt; 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a14d8f418667d750d655e37f8fb2aa536926510a" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;require 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Perl이 C 라이브러리와 연결하기위한 XS 시스템을 갖기 전에 프로그래머는 C 헤더 파일을 읽어 라이브러리 상수를 가져 오는 데 사용했습니다. 여전히 &lt;code&gt;require 'syscall.ph'&lt;/code&gt; 또는 이와 유사한 것이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">당시에는 0xD800-0xDFFF 범위가 할당되지 않았습니다. 절반의 범위를 나타내는 데 전반부를 사용하자 분할 &lt;code&gt;upper half of a character&lt;/code&gt; 와 후반부가 나타내는 &lt;code&gt;lower half of a character&lt;/code&gt; . 그렇게하면 1024 * 1024 = 1048576 개 더 많은 문자를 나타낼 수 있습니다. 이제 16 비트 인코딩에서도 문자 범위를 최대 \ x {10ffff}까지 저장할 수 있습니다. 이 반자 쌍은 이제</target>
        </trans-unit>
        <trans-unit id="8b862d333105bea92e016a8abca6974a21d6cf0e" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower half of a character&lt;/code&gt;. That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">당시에는 0xD800-0xDFFF 범위가 할당되지 않았습니다. 이 범위를 절반으로 나누고 전반을 사용하여 &lt;code&gt;upper half of a character&lt;/code&gt; 의 상반부를 나타내고 &lt;code&gt;lower half of a character&lt;/code&gt; 하반을 나타냅니다 . 이렇게하면 1024 * 1024 = 1048576 자 이상을 나타낼 수 있습니다. 이제 16 비트 인코딩으로도 최대 \ x {10ffff}까지 문자 범위를 저장할 수 있습니다. 이 절반 문자 쌍은 이제</target>
        </trans-unit>
        <trans-unit id="bbe6515e366531ac45779e3d5c9b5a456560e812" translate="yes" xml:space="preserve">
          <source>Back to</source>
          <target state="translated">돌아가다</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">데이터 변환으로 돌아갑니다. 시스템의 고유 8 비트 인코딩 (예 : Latin-1, EBCDIC 등)에 데이터가 있거나 원하는 경우 pack / unpack을 사용하여 유니 코드로 /에서 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">테스트 라이브러리 구축을위한 백엔드</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">백그라운드 프로세스</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">배경과 PERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">이렇게 자신을 배경 :</target>
        </trans-unit>
        <trans-unit id="fec43a1301d416fe4b43d921e7178671d812a1b8" translate="yes" xml:space="preserve">
          <source>Background: &lt;code&gt;atoi&lt;/code&gt; has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided &lt;code&gt;atoi&lt;/code&gt; and &lt;code&gt;strtol&lt;/code&gt; are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</source>
          <target state="translated">배경 : &lt;code&gt;atoi&lt;/code&gt; 함수가 불법 입력에 심각한 문제가있다, 그것은 증분 분석에 사용되는, 따라서 할 수없는 피해야한다 &lt;code&gt;atoi&lt;/code&gt; 함수를 하고 &lt;code&gt;strtol&lt;/code&gt; 함수는 또한 또한 버그 (사용자 환경에 의해 제어 전역 상태)로 볼 수있다 로케일 설정에 의해 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="eced385684cc6954de21105c9b174aaf3bba4295" translate="yes" xml:space="preserve">
          <source>Backported version unknown</source>
          <target state="translated">백 포트 된 버전 알 수 없음</target>
        </trans-unit>
        <trans-unit id="422ea69f009b9513c410e1c50a5058f352b88507" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">명명 된 캡처 그룹에 대한 역 참조. &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">명명 된 캡처 그룹에 대한 역 참조. 동등 &lt;code&gt;\g{NAME}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">대체의 역 참조는 &quot;\&quot;대신 &quot;$&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f6f78ea4ce7c5612a0f7211383bd0176dfc079e5" translate="yes" xml:space="preserve">
          <source>Backslash Operator</source>
          <target state="translated">백 슬래시 연산자</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">백 슬래시 시퀀스</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">일반적으로 백 슬래시는 다음 문자를 피하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">백 슬래시 시퀀스 문자 클래스는 범위의 엔드 포인트 중 하나를 형성 할 수 없습니다. 따라서 당신은 말할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">백 슬래시 시퀀스</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">백 슬래시 문자는 해당 리터럴 문자열 ( &lt;code&gt;\{&lt;/code&gt; 과 같이)로 대체 되거나 유한 자동 마마에서 특수 노드를 생성합니다 ( &lt;code&gt;\b&lt;/code&gt; 와 같이 ). RE 엔진에 특수한 문자 (예 : &lt;code&gt;|&lt;/code&gt; )는 해당 노드 또는 노드 그룹을 생성합니다. &lt;code&gt;(?#...)&lt;/code&gt; 주석은 무시됩니다. 나머지는 모두 일치하도록 리터럴 문자열로 변환되거나 무시됩니다 ( &lt;code&gt;/x&lt;/code&gt; 가 있으면 공백 및 &lt;code&gt;#&lt;/code&gt; 스타일 주석 그대로 ).</target>
        </trans-unit>
        <trans-unit id="5aeb8eb150f9b708f4b9ee0e63969a864d6fc87f" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt;). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt;-style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">백 슬래시 문자는 해당 리터럴 문자열 ( &lt;code&gt;\{&lt;/code&gt; ) 로 대체 되거나 유한 오토 마톤 ( &lt;code&gt;\b&lt;/code&gt; ) 에서 특수 노드를 생성 합니다. RE 엔진에 특수한 문자 (예 : &lt;code&gt;|&lt;/code&gt; )는 해당 노드 또는 노드 그룹을 생성합니다. &lt;code&gt;(?#...)&lt;/code&gt; 주석은 무시됩니다. 나머지는 모두 일치시키기 위해 리터럴 문자열로 변환되거나 무시됩니다 ( &lt;code&gt;/x&lt;/code&gt; 가있는 경우 공백 및 &lt;code&gt;#&lt;/code&gt; 스타일 주석 ).</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perl의 백 슬래시 메타 문자는 &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; 과 같은 영숫자 입니다. 다른 정규 표현식 언어와 달리 영숫자가 아닌 백 슬래시 기호는 없습니다. 따라서 \\, \ (, \), \ [, \], \ {또는 \}와 같은 것은 항상 메타 문자가 아닌 리터럴 문자로 해석됩니다. 이것은 한 번의 공용 관용구에서 패턴에 사용하려는 문자열에서 정규 표현식 메타 문자의 특수 의미를 비활성화하거나 인용하는 데 사용되었습니다. &quot;단어&quot;가 아닌 문자를 모두 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="a9e4564a4cffc22857c4489a19486bf89ae25eff" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;. Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\(&lt;/code&gt;, &lt;code&gt;\)&lt;/code&gt;, &lt;code&gt;\[&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, &lt;code&gt;\{&lt;/code&gt;, or &lt;code&gt;\}&lt;/code&gt; is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perl의 백 슬래시 메타 문자는 &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; 과 같이 영숫자 입니다. 다른 정규식 언어와 달리 영숫자가 아닌 백 슬래시 기호가 없습니다. 따라서 &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\(&lt;/code&gt; , &lt;code&gt;\)&lt;/code&gt; , &lt;code&gt;\[&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; , &lt;code&gt;\{&lt;/code&gt; 또는 &lt;code&gt;\}&lt;/code&gt; 와 같은 것은 항상 메타 문자가 아닌 리터럴 문자로 해석됩니다. 이것은 한때 패턴에 사용하려는 문자열에서 정규식 메타 문자의 특별한 의미를 비활성화하거나 인용하기 위해 공통 관용구에서 사용되었습니다. &quot;단어&quot;가 아닌 모든 문자를 인용하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">명령 행 인수에서 백 슬래시 괄호 &lt;code&gt;()&lt;/code&gt; . 재귀 Makefile &lt;code&gt;$(...)&lt;/code&gt; 구문은 처리하지 않지만 간단한 구문은 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a44d458ea8adc4ce2457e80d59480bf2444b0e2c" translate="yes" xml:space="preserve">
          <source>Backticks</source>
          <target state="translated">Backticks</target>
        </trans-unit>
        <trans-unit id="cada2d153702b188c804c9ed93a320132370a768" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">리디렉션 또는 셸 메타 문자를 포함하는 명령을 사용하여 &lt;code&gt;``&lt;/code&gt; ( &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop의 &quot;I / O 연산자&quot;&lt;/a&gt; 참조) 백틱 ;</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">경로 재 지정 또는 쉘 메타 문자를 포함하는 명령이있는 &lt;code&gt;``&lt;/code&gt; ( 틱의 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O 연산자&lt;/a&gt; 참조 );</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">백틱은 하위 프로세스를 만들고 DCL 명령으로 실행하기 위해 동봉 된 문자열을 전달합니다. 서브 프로세스는 &lt;code&gt;lib$spawn()&lt;/code&gt; 통해 직접 작성되므로 유효한 DCL 명령 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93a46463866e4337a557918eb7f92cb737fcdb4d" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified.</source>
          <target state="translated">백틱은 하위 프로세스를 만들고 DCL 명령으로 실행하기 위해 포함 된 문자열을 하위 프로세스에 전달합니다. 하위 프로세스는 &lt;code&gt;lib$spawn()&lt;/code&gt; 통해 직접 생성되므로 유효한 DCL 명령 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">역 추적 동사</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">경기에 대한 끊임없는 검색 중 역 추적은 특히 경기가 실패 할 때 시간 낭비 일 수 있습니다. 간단한 패턴을 고려하십시오</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">역 추적은 정규 표현식이 다른 반복 된 시도보다 효율적입니다. 정규 표현식이 여러 개 있고 그 중 하나와 일치하는 것이 허용되는 경우 여러 가지 대안으로 조합 할 수 있습니다. 개별 표현식이 입력 데이터 인 경우 조인 연산을 프로그래밍하여 수행 할 수 있습니다. 개선 된 버전의 &lt;code&gt;simple_grep&lt;/code&gt; 프로그램 (여러 패턴과 일치하는 프로그램) 에서이 아이디어를 활용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">이전 버전과 호환되는 상용구</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성</target>
        </trans-unit>
        <trans-unit id="7d01557ea44942b942393d66060697fec065318a" translate="yes" xml:space="preserve">
          <source>Bad arg length for %s, is %u, should be %d</source>
          <target state="translated">% s에 대한 잘못된 인수 길이는 % u입니다. % d 여야합니다.</target>
        </trans-unit>
        <trans-unit id="165656139a26613694c64dbf201f062c5151055a" translate="yes" xml:space="preserve">
          <source>Bad color mapping %s</source>
          <target state="translated">잘못된 색상 매핑 % s</target>
        </trans-unit>
        <trans-unit id="71ab08a2349cea719fd65e95a92efa2f68979a67" translate="yes" xml:space="preserve">
          <source>Bad escape sequence %s</source>
          <target state="translated">잘못된 이스케이프 시퀀스 % s</target>
        </trans-unit>
        <trans-unit id="97e53bd47a32a9c5ca5b26c7f73e5af6cefd27e1" translate="yes" xml:space="preserve">
          <source>Bad evalled substitution pattern</source>
          <target state="translated">잘못된 평가 대체 패턴</target>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">나쁜 예 :</target>
        </trans-unit>
        <trans-unit id="6b1ede25e2d280b57ab0ce582f6faf1b35cf90a7" translate="yes" xml:space="preserve">
          <source>Bad exit or wait status</source>
          <target state="translated">잘못된 종료 또는 대기 상태</target>
        </trans-unit>
        <trans-unit id="390acb944960513fda956a00da4e57aecfbdc40d" translate="yes" xml:space="preserve">
          <source>Bad filehandle: %s</source>
          <target state="translated">잘못된 파일 핸들 : % s</target>
        </trans-unit>
        <trans-unit id="2545bb8b8757d12600ee0fd7c8d21fd5ad24ec74" translate="yes" xml:space="preserve">
          <source>Bad free() ignored</source>
          <target state="translated">잘못된 free () 무시</target>
        </trans-unit>
        <trans-unit id="d801fbd5f10bc4ae72d676efa25b3f102ac7bc5e" translate="yes" xml:space="preserve">
          <source>Bad hash</source>
          <target state="translated">잘못된 해시</target>
        </trans-unit>
        <trans-unit id="4e025cf017a8d1ec1929f0fe963368b8537306db" translate="yes" xml:space="preserve">
          <source>Bad name after %s</source>
          <target state="translated">% s 뒤에 잘못된 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc9adf2eb1c251e659c032b900434bcbefd880c7" translate="yes" xml:space="preserve">
          <source>Bad plugin affecting keyword '%s'</source>
          <target state="translated">키워드 '% s'에 영향을 미치는 잘못된 플러그인</target>
        </trans-unit>
        <trans-unit id="ec81356ab8541823884a0a82a618613aa9cbd7b4" translate="yes" xml:space="preserve">
          <source>Bad realloc() ignored</source>
          <target state="translated">잘못된 realloc () 무시</target>
        </trans-unit>
        <trans-unit id="6da31fb3200e756607d3e2e50254f7cea20fa96d" translate="yes" xml:space="preserve">
          <source>Bad subroutine name for Fatal: %s</source>
          <target state="translated">치명적에 대한 잘못된 서브 루틴 이름 : % s</target>
        </trans-unit>
        <trans-unit id="42447de9c1418f0e2c311d00634195d77eb4c7e0" translate="yes" xml:space="preserve">
          <source>Bad symbol for array</source>
          <target state="translated">배열에 대한 잘못된 기호</target>
        </trans-unit>
        <trans-unit id="d65b92f2abbe5aa53ce089c4d6d379ebd454bfc3" translate="yes" xml:space="preserve">
          <source>Bad symbol for dirhandle</source>
          <target state="translated">dirhandle에 대한 잘못된 기호</target>
        </trans-unit>
        <trans-unit id="b66844a23804f5fa9fb3dbb57550acc9e7e5e7dd" translate="yes" xml:space="preserve">
          <source>Bad symbol for filehandle</source>
          <target state="translated">파일 핸들에 대한 잘못된 기호</target>
        </trans-unit>
        <trans-unit id="d7f407c0868b2e3ed85e66aedb4e0f3e18c18e11" translate="yes" xml:space="preserve">
          <source>Bad symbol for hash</source>
          <target state="translated">해시에 대한 잘못된 기호</target>
        </trans-unit>
        <trans-unit id="08cf554f79f8dc5600aa8436990c34983c96cb70" translate="yes" xml:space="preserve">
          <source>Bad symbol for scalar</source>
          <target state="translated">스칼라에 대한 잘못된 기호</target>
        </trans-unit>
        <trans-unit id="c1bd2e42ef1c41d1f7a37013a433505cff6f0d53" translate="yes" xml:space="preserve">
          <source>Badly placed ()'s</source>
          <target state="translated">잘못 배치 된 ()</target>
        </trans-unit>
        <trans-unit id="9f60e950209318c3cca05ba1dcb8123b97e1b18f" translate="yes" xml:space="preserve">
          <source>Bailout</source>
          <target state="translated">Bailout</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">구제 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="2e1aced5d91a77947ec0c1e15905db2c6dabdd2d" translate="yes" xml:space="preserve">
          <source>Bailout!</source>
          <target state="translated">Bailout!</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</target>
        </trans-unit>
        <trans-unit id="fa6c3752cd00f7f1277fd7e5604ab8d2edaf26b8" translate="yes" xml:space="preserve">
          <source>Bangladesh</source>
          <target state="translated">Bangladesh</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="38e31cd750cd9c5c8abfa83e3cc07bbe5eb34dbc" translate="yes" xml:space="preserve">
          <source>Bare here-document terminators</source>
          <target state="translated">베어 여기 문서 종결 자</target>
        </trans-unit>
        <trans-unit id="8f2f9eceeee98d7bac9099dfb477548bd0d00fe3" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</source>
          <target state="translated">&quot;엄격한 구독&quot;을 사용하는 동안 베어 워드 &quot;% s&quot;은 (는) 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74184baa622016b052c2c66c26dc81d35681d05a" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; refers to nonexistent package</source>
          <target state="translated">베어 워드 &quot;% s&quot;는 존재하지 않는 패키지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3f9425456098bc5db3b65fe0b670ee4dc328cf5" translate="yes" xml:space="preserve">
          <source>Bareword found in conditional</source>
          <target state="translated">조건부에서 발견 된 베어 워드</target>
        </trans-unit>
        <trans-unit id="b3c6c09ca8e54434a9e30a3ee7363deeca4c4687" translate="yes" xml:space="preserve">
          <source>Bareword in require contains &quot;%s&quot;</source>
          <target state="translated">의 Bareword에 &quot;% s&quot;가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99617bf4b7525e79f27dc14c638f75b9b86decd2" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to disallowed filename &quot;%s&quot;</source>
          <target state="translated">의 Bareword에는 허용되지 않는 파일 이름 &quot;% s&quot;에 대한 맵이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e217673de1982c957abdb450217720b611015045" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to empty filename</source>
          <target state="translated">의 Bareword는 빈 파일 이름에 매핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b08d7d96976813240018e31332af5b98b35fa0d" translate="yes" xml:space="preserve">
          <source>Bareword in require must not start with a double-colon: &quot;%s&quot;</source>
          <target state="translated">require의 베어 워드는 이중 콜론 &quot;% s&quot;으로 시작하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">키워드는 오버로드 된 문자열 상수로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO :: Compress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO :: Uncompress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">기본 구조</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">연결된 핸들에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">연결 해시에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">연결된 스칼라에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">모든 클래스의 기본 클래스 (축복 참조)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN 쉘 확장의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils :: Constant 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAP 소스 반복기의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser 출력 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="a0880f8d682b9138475bd47a938947c12338445c" translate="yes" xml:space="preserve">
          <source>Base class for Test2 IPC drivers.</source>
          <target state="translated">Test2 IPC 드라이버의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9cde81f5a0639d96966be94bffabdcc2cee72d19" translate="yes" xml:space="preserve">
          <source>Base class for all event facets.</source>
          <target state="translated">모든 이벤트 패싯의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="28ab0f65808322aafffdf4f4c4569b0ca559cecd" translate="yes" xml:space="preserve">
          <source>Base class for all event objects that get passed through &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;test2&quot;&gt;Test2를&lt;/a&gt; 통해 전달되는 모든 이벤트 객체의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">POD 필터 및 번역기를 만들기위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">다른 TAP 소스 핸들러에 대한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="6d6b96a9e4df11d307d7125ce342fa82d8eb0fc3" translate="yes" xml:space="preserve">
          <source>Base class for events</source>
          <target state="translated">이벤트의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">하네스 출력 대리자를위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">테스트 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">연결된 배열의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="4c8eae847ee205298317c9b96e374f69e5e9feb1" translate="yes" xml:space="preserve">
          <source>Base class package &quot;%s&quot; is empty.</source>
          <target state="translated">기본 클래스 패키지 &quot;% s&quot;이 (가) 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5134fdf6155e7a9843c83a26849d1aff846f4d88" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">모든 &lt;code&gt;TAP::*&lt;/code&gt; 모듈에 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod :: Perldoc 포맷터 용베이스</target>
        </trans-unit>
        <trans-unit id="bf06e03b88934d434a87ce7787240b8e99aae0b0" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Stevan Little의 &lt;a href=&quot;Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 기반</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Stevan Little 's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 기반</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;Pod :: Text :: pod2text ()&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen이 작성한 &lt;b&gt;Pod :: Text :: pod2text (1)&lt;/b&gt; 코드를 기반으로 &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;포드 :: 텍스트&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;pod2text (1)&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;pod2text&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">Shigio Yamaguchi가 작성한 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">Perl의 5.8.0 배포를 위해 MIME :: QuotedPrint.pm에 처음 추가 된 예를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;의 아이디어를 바탕으로</target>
        </trans-unit>
        <trans-unit id="01bb16997fde52e47c429c6fd628c8c4ddf3054c" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt;&amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; 및</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">&lt;code&gt;:perlio&lt;/code&gt; 레이어를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">Larry Wall과 Perl 5 Porter 의 &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; 코드를 기반으로하며 동일한 라이센스 조건에 따라 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">용어집을 기반으로</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">Larry Wall이 작성한 xsubpp 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">기본 블록</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">기본 IO 작업</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">기본 다국어 비행기</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">기본 구조</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">기본 스레드 지원</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">프로그래머를위한 기본 유틸리티</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">기본 명령 :</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">기본 방법</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">기본 읽기 작업</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">기본 세마포어</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">기본 구문 개요</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">테스트 작성을위한 기본 유틸리티.</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">기본 쓰기 작업.</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">기본적으로 Intel 및 VAX CPU는 리틀 엔디안이며 Motorola m68k / 88k, PPC, Sparc, HP PA, Power 및 Cray를 포함한 다른 모든 사람은 빅 엔디안입니다. Alpha 및 MIPS는 다음 중 하나 일 수 있습니다. Digital / Compaq은 리틀 엔디안 모드에서 사용하지만 SGI / Cray는 빅 엔디안 모드에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">기본적으로 TAP에서 개별 결과를 가져옵니다. 각각의 예와 함께 6 가지 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4beb8f757ba4e13e29ffb8c6a2d654b5eee3dc8e" translate="yes" xml:space="preserve">
          <source>Baud rate values</source>
          <target state="translated">전송 속도 값</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">두 가지 중요한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9042cbc9bb8a8748d18e82d265eee86b54008013" translate="yes" xml:space="preserve">
          <source>Be aware that all exceptions are stringified during construction.</source>
          <target state="translated">모든 예외는 구성 중에 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">File :: Glob에서 반환 된 모든 파일 이름이 오염되었습니다.</target>
        </trans-unit>
        <trans-unit id="3297ac638d07f74b1cf62949925d4b3e23422ec7" translate="yes" xml:space="preserve">
          <source>Be aware that many files in the distribution are derivative--avoid patching them, because git won't see the changes to them, and the build process will overwrite them. Patch the originals instead. Most utilities (like perldoc) are in this category, i.e. patch</source>
          <target state="translated">배포판의 많은 파일이 파생 된 파일이라는 점에 유의하세요. git은 파일의 변경 사항을 볼 수없고 빌드 프로세스가 파일을 덮어 쓰므로 패치를 피하세요. 대신 원본을 패치하십시오. 대부분의 유틸리티 (예 : perldoc)는이 범주, 즉 패치에 속합니다.</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;@DB::args&lt;/code&gt; 설정 은</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">다이제스트 루틴은 UTF-8 입력을 기본 인코딩에서 동등한 바이트 시퀀스로 자동 변환합니다 (참조 : utf8 :: downgrade). 이 부작용은 Perl이 데이터를 내부적으로 저장하는 방식에만 영향을 주지만 그렇지 않으면 데이터의 실제 값은 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">파일의 유형 / 생성자 및 리소스 포크가 손실된다는 점에 유의하십시오. 이는 일반적으로 크로스 플랫폼 아카이브에서 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64b3ff265c6f33aa278b5fc7ab5adbd6a628d376" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 주요 가치는 단순성입니다. &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 및 &lt;a href=&quot;Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; 과 같이 이미 더 많은 야심 찬 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 주요 가치는 단순성입니다. &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; 과 같은 야심 찬 모듈이 이미 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f073a8ab4396a4ea1a82c329831db3a4c81e7bb9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; had a chance to get the information. That means that &lt;code&gt;caller(N)&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt;. In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="translated">&lt;a href=&quot;#caller-EXPR&quot;&gt; &lt;code&gt;caller&lt;/code&gt; &lt;/a&gt; 가 정보를 얻기 전에 최적화 프로그램이 호출 프레임을 최적화했을 수 있습니다 . 즉, &lt;code&gt;caller(N)&lt;/code&gt; 은 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 대해 예상되는 호출 프레임에 대한 정보를 반환하지 않을 수 있습니다 . 특히 &lt;code&gt;@DB::args&lt;/code&gt; 에는 이전에 &lt;a href=&quot;#caller-EXPR&quot;&gt; &lt;code&gt;caller&lt;/code&gt; &lt;/a&gt; 가 호출 된 시간의 정보가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 정보를 얻을 수 있기 전에 옵티마이 저가 호출 프레임을 최적화했을 수 있습니다 . 즉, &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 대해 예상 한 호출 프레임에 대한 정보를 반환하지 않을 수 있습니다 . 특히 &lt;code&gt;@DB::args&lt;/code&gt; 에는 이전에 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 정보가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 정보를 얻을 수 있기 전에 옵티마이 저가 호출 프레임을 최적화했을 수 있습니다 . 즉, &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 대해 예상 한 호출 프레임에 대한 정보를 반환하지 않을 수 있습니다 . 특히 &lt;code&gt;@DB::args&lt;/code&gt; 에는 이전에 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 정보가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">심볼릭 링크를 따르는 옵션은 위험 할 수 있습니다. 디렉토리 트리의 구조 (디렉토리에 대한 심볼릭 링크 포함)에 따라 주어진 (물리적) 디렉토리를 두 ​​번 이상 통과 할 수 있습니다 ( &lt;code&gt;follow_fast&lt;/code&gt; 가 유효한 경우에만 ). 또한 기호로 연결된 디렉토리에서 파일을 삭제하거나 변경하면 알 수없는 디렉토리에서 파일을 삭제하거나 변경하기 때문에 매우 불쾌한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">이러한 작업은 완전한 Unix 포크이므로 모든 외계 시스템에서 제대로 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbf362a8476b23d76d24466d122396a40549047" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems. See &lt;a href=&quot;perlport#open&quot;&gt;&quot;open&quot; in perlport&lt;/a&gt; for portability details.</source>
          <target state="translated">이러한 작업은 전체 Unix 포크이므로 모든 외계 시스템에서 올바르게 구현되지 않을 수 있습니다. 이식성에 대한 자세한 내용 &lt;a href=&quot;perlport#open&quot;&gt;은 perlport의 &quot;open&quot;을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5d4c04a6ec8f48645b28a87376c9f6999c39b61b" translate="yes" xml:space="preserve">
          <source>Be aware that this option makes you accept invalid JSON texts as if they were valid!</source>
          <target state="translated">이 옵션을 사용하면 유효하지 않은 JSON 텍스트가 유효한 것처럼 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9573a203063d54f5dc27408bed7844c1be7ddce6" translate="yes" xml:space="preserve">
          <source>Be aware that this will export ANSI_COLORS_DISABLED to any child processes of your program as well.</source>
          <target state="translated">이렇게하면 ANSI_COLORS_DISABLED를 프로그램의 모든 하위 프로세스로 내보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9011ae4d69e158b2d5d9fa7d3f0fa4181ed416ab" translate="yes" xml:space="preserve">
          <source>Be aware that writing a multi-threaded application will not be portable to a platform which lacks the native thread-safe locale support. On systems that do have it, you automatically get this behavior for threaded perls, without having to do anything. If for some reason, you don't want to use this capability (perhaps the POSIX 2008 support is buggy on your system), you can manually compile Perl to use the old non-thread-safe implementation by passing the argument &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="translated">다중 스레드 응용 프로그램을 작성하는 것은 기본 스레드로부터 안전한 로케일 지원이없는 플랫폼으로 이식 할 수 없습니다. 이 기능이있는 시스템에서는 아무것도 수행 할 필요없이 스레드 된 펄에 대해이 동작을 자동으로 얻습니다. 어떤 이유로이 기능을 사용하지 않으려는 경우 (아마도 POSIX 2008 지원이 시스템에 버그가있을 수 있음) &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; 인수를 전달하여 이전의 스레드로부터 안전하지 않은 구현을 사용하도록 Perl을 수동으로 컴파일 할 수 있습니다. -DNO_THREAD_SAFE_LOCALE ' to</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">이 옵션을 사용할 때 POD 소스의 입력 인코딩은 US-ASCII 또는 Latin-1이 아닌 경우 올바르게 선언해야합니다. &lt;code&gt;=encoding&lt;/code&gt; 명령이 없는 POD 입력 은 Latin-1 인 것으로 가정하고 실제로 UTF-8 인 경우 출력이 이중 인코딩됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="112ebc66d2bbad303aae87da4af1076cd40b1dbe" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will produce warnings. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">이 옵션을 사용할 때 US-ASCII가 아닌 경우 POD 소스의 입력 인코딩을 올바르게 선언해야합니다. Pod :: Simple은 인코딩 추측을 시도하고 Latin-1 또는 UTF-8이면 성공할 수 있지만 경고를 생성합니다. &lt;code&gt;=encoding&lt;/code&gt; 명령을 사용하여 인코딩 을 선언하십시오. 자세한 내용은 &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod (1)&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14539a0200a018d8bfd0c01f3ce67edac22b2e5e" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2man&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">이 옵션을 사용할 때 US-ASCII가 아닌 경우 POD 소스의 입력 인코딩을 올바르게 선언해야합니다. Pod :: Simple은 인코딩 추측을 시도하고 Latin-1 또는 UTF-8 인 경우 성공할 수 있지만 경고가 발생하며 기본적으로 &lt;b&gt;pod2man&lt;/b&gt; 오류가 발생합니다. &lt;code&gt;=encoding&lt;/code&gt; 명령을 사용하여 인코딩 을 선언하십시오. 자세한 내용은 &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod (1)&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b528c0888545102ae09966c077f548f42a0a07e8" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2text&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">이 옵션을 사용할 때 US-ASCII가 아닌 경우 POD 소스의 입력 인코딩을 올바르게 선언해야합니다. Pod :: Simple은 인코딩 추측을 시도하고 Latin-1 또는 UTF-8 인 경우 성공할 수 있지만 경고가 발생하며 기본적으로 &lt;b&gt;pod2text&lt;/b&gt; 오류가 발생합니다. &lt;code&gt;=encoding&lt;/code&gt; 명령을 사용하여 인코딩 을 선언하십시오. 자세한 내용은 &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod (1)&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">게다가, 유닉스 시스템에서도 변형이 있다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">구문에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fdb4158175acb38dcf577960ceb71bd1d96eb9" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 문자가 배열 이름의 시작을 의미하는 것으로 간주 될 수 있으므로 그림 주위에 큰 따옴표를 넣으면주의하십시오 . &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt; &lt;code&gt;formline&lt;/code&gt; 은&lt;/a&gt; 항상 true를 반환합니다. 다른 예는 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 문자는 배열 이름의 시작을 의미 하기 때문에 사진 주위에 큰 따옴표를 넣으면주의하십시오 . &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 은 항상 true를 반환합니다. 다른 예는 &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 문자는 배열 이름의 시작을 의미 하기 때문에 사진 주위에 큰 따옴표를 넣으면주의하십시오 . &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 은 항상 true를 반환합니다. 다른 예는 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4aaaf54937dcd1947fa04a848c937575a75bb3aa" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; after a failed system call. Using &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; for anything else than displaying it as output is doubtful (though see the &lt;a href=&quot;errno&quot;&gt;&lt;code&gt;Errno&lt;/code&gt;&lt;/a&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">모듈 또는 프로그램과 함께 제공하는 테스트에서주의하십시오. 모듈 코드는 완전히 이식 가능할 수 있지만 테스트는 그렇지 않을 수 있습니다. 이것은 종종 테스트가 다른 프로세스를 생성하거나 테스트를 돕기 위해 외부 프로그램을 호출 할 때 또는 (위에서 언급 한대로) 테스트가 파일 시스템 및 경로에 대한 특정 사항을 가정 할 때 발생합니다. &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; 를&lt;/a&gt; 확인할 때와 같이 오류에 대해 특정 출력 스타일에 의존하지 않도록주의하십시오 . 실패한 시스템 호출 후. 사용 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt; 출력으로 표시하는 것 이외의 다른 것은 의심 스럽습니다 ( 오류 값에 대해 합리적으로 이식 가능한 테스트에 대해서는 &lt;a href=&quot;errno&quot;&gt; &lt;code&gt;Errno&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 ). 일부 플랫폼은 특정 출력 형식을 예상하며 해당 플랫폼의 Perl은 그에 따라 조정되었을 수 있습니다. 특히, 오류 값을 테스트 할 때 정규식을 고정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">모듈 또는 프로그램과 함께 제공되는 테스트에주의하십시오. 모듈 코드는 완전히 이식 가능하지만 테스트가 불가능할 수 있습니다. 테스트가 다른 프로세스를 생성하거나 테스트를 돕기 위해 외부 프로그램을 호출하거나 (위에서 언급 한 것처럼) 테스트가 파일 시스템 및 경로에 대한 특정 사항을 가정 할 때 종종 발생합니다. &lt;code&gt;$!&lt;/code&gt; 확인할 때와 같이 오류에 대해 특정 출력 스타일에 의존하지 않도록주의하십시오 ! 실패한 시스템 호출 후. &lt;code&gt;$!&lt;/code&gt; 사용 ! 출력이 의심스러운 것으로 표시하는 것 이외의 다른 것은 ( 오류 값에 대해 합리적으로 이식 가능하게 테스트하기 위해 &lt;code&gt;Errno&lt;/code&gt; 모듈을 참조하십시오 ). 일부 플랫폼은 특정 출력 형식을 기대하며 해당 플랫폼의 Perl이 그에 따라 조정되었을 수 있습니다. 가장 구체적으로, 오류 값을 테스트 할 때 정규식을 고정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">chdir ()에 전달한 내용이 정의되어 있고 비어 있지 않은지 확인하십시오. 그렇지 않으면 홈 디렉토리에서 자신을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">open ()과 close ()에서 리턴 값을 확인하십시오. 당신이 있다면</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">AFS 설치 디렉토리가 여전히 유효한지 확신하지 않는 한, 확장을 재 컴파일 할 때마다이 절차를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">명명 된 캡처와 함께 분기 재설정 패턴을 사용할 때주의하십시오. 명명 된 캡처는 캡처를 보유한 번호가 지정된 그룹의 별명으로 구현되며 이는 분기 재설정 패턴의 구현을 방해합니다. 분기 재설정 패턴으로 명명 된 캡처를 사용하는 경우 각 대체에서 동일한 순서로 동일한 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">그러나 텍스트 문자열을 이진 문자열과 결합하지 않도록주의하십시오. 이진 스트림에 텍스트가 필요한 경우 먼저 적절한 인코딩을 사용하여 텍스트 문자열을 인코딩 한 다음 이진 문자열로 조인하십시오. &quot;인코딩하지 않으면 어떻게됩니까?&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">qx (), system () 및 외부 명령 호출을위한 일부 모듈은 fork ()를 수행 한 다음 결과를 기다립니다 (주의). 따라서 신호 처리기가 호출됩니다. wait ()는 이미 system () 또는 qx ()에 의해 호출되었으므로 신호 처리기의 wait ()는 더 이상 좀비를 보지 않으므로 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">기존 모듈과 일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">설명이 필요합니다 (즉, 모듈의 목적을 정확하게 설명하십시오).</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">그것은 수 &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; 또는 맨 페이지에 유니 코드에 대한 언급이없는 확장자, 당신은 반드시 UTF8 플래그가 벗겨되어 있는지 확인해야합니다. 이 글을 쓰는 시점 (2012 년 1 월)에 언급 된 모듈은 UTF-8을 인식하지 않습니다. 이것이 사실인지 확인하려면 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9583b4e268c09c5404dc953e2a7280e9a611066c" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt;, &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">이 수 &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; 또는 맨 페이지에 유니 코드에 대한 언급이없는 확장자, 당신은 반드시 UTF8 플래그가 벗겨되어 있는지 확인해야합니다. 이 글을 쓰는 시점 (2012 년 1 월)에 언급 된 모듈은 UTF-8을 인식하지 않습니다. 이것이 여전히 사실인지 확인하려면 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">착하게 굴 어라.</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">실수로 호출하지 않도록 신호 처리기의 이름으로 베어 워드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">필요한 파서 템플릿 파일을 포함하여 yacc 설치가 적절한 지 확인하십시오. 아직 수행하지 않은 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">코드를 적절히 주석 처리하십시오. 모든 라인에 주석을다는 것은 불필요하지만, 운영자의 부작용을 이용하거나 패치되는 기능 밖에서 느껴지거나 다른 사람들이 혼란 스러울 수있는 변경 사항을 작성하는 것은 문서화해야합니다. 실수를하려고한다면 너무 적은 수의 의견보다 너무 많은 의견을 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">&lt;b&gt;정확한&lt;/b&gt; 오류 메시지가 있으면 반드시 포함 시키 십시오. &quot;Perl has a error&quot;는 정확한 오류 메시지가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fb3f786d0833cb9684920951669ea14a5f8c452b" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;&quot;ENCODING&quot;&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">포드에 ASCII가 아닌 문자가 포함 된 경우 &lt;a href=&quot;#ENCODING&quot;&gt;'인코딩'&lt;/a&gt; 을 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">포드에 ASCII가 아닌 문자가 포함되어 있으면 &lt;a href=&quot;#ENCODING&quot;&gt;인코딩&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">메이크 파일 상단 근처의 지침을주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Makefile.PL 또는 Build.PL 모두에 Perl 버전 요구 사항을 지정 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; 이상 이 필요합니다 . 자세한 내용 은 &lt;a href=&quot;functions/require&quot;&gt;require의 &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="395569931cbd630cae76e8ec72604be440821c6b" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;require 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;use VERSION&lt;/code&gt; of &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">Makefile.PL 또는 Build.PL 및 &lt;code&gt;require 5.6.1&lt;/code&gt; 또는 이와 유사한 Perl 버전 요구 사항을 지정해야합니다 . 섹션 참조 &lt;code&gt;use VERSION&lt;/code&gt; 의 &lt;a href=&quot;perlfunc#require&quot;&gt;을 perlfunc에서 &quot;필요&quot;&lt;/a&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">perl-5.xxtar.gz 파일을 추출하려면 Solaris (SunOS 4.x 아님)에서 컴파일 된 tar 프로그램을 사용해야합니다. Solaris에서 SunOS4 용으로 컴파일 된 GNU tar를 사용하지 마십시오. (Solaris 용으로 컴파일 된 GNU tar는 괜찮습니다.) Solaris에서 SunOS4 바이너리를 실행하면 런타임 시스템이 tar가 lib / locale.pm이라는 파일을 만들려고 할 때 m # lib / locale #과 일치하는 경로 이름을 마술로 변경합니다. 대신 lib / oldlocale.pm이 생성됩니다. 이 조언이 너무 늦어서 SunOS4 컴파일 tar를 사용한 경우, 이름이 잘못 지정된 파일을 찾아서 lib / locale.pm으로 다시 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">이미 설치된 버전이 아니라 테스트 할 버전과 함께 제공된 라이브러리와 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">변수 값을 변경하는 Perl 조작에 매우주의하십시오. 예를 들어 변수에 무언가를 추가하려면 저장 공간을 재 할당해야하므로 사람이없는 땅을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">파일을 만들거나 삭제하지 않아도 NFS를 통한 원자 작업은 보장되지 않습니다. 즉, 두 프로세스가 동일한 파일을 성공적으로 만들거나 연결 해제 할 수 있습니다. 따라서 O_EXCL은 원하는만큼 배타적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15b58e5a1a4863b537d4c8fb01a3a9bfffd23c29" translate="yes" xml:space="preserve">
          <source>Be warned that proxying an &lt;code&gt;https&lt;/code&gt; connection opens you to the risk of a man-in-the-middle attack by the proxy server.</source>
          <target state="translated">프록시 있다고 경고 &lt;code&gt;https&lt;/code&gt; 연결하는 프록시 서버에 의한 man-in-the-middle 공격의 위험에 당신을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">일부 포매터는 32-126 외부의 문자를 안정적으로 렌더링 할 수 없습니다. 많은 사람들이 32-126과 160-255를 처리 할 수 ​​있지만 255보다 큰 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">이 기능은 실험적인 것으로 간주되며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 정규 표현식과 달리 경고를 받습니다. 템플릿이 들어오는 데이터와 일치하지 않으면 Perl은 소리를 지르고 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="02d6d74dc9a4db2057c5683472b9fbbb7012f2b3" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;unpack&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">그러나 정규 표현식과 달리 &lt;code&gt;unpack&lt;/code&gt; 템플릿이 들어오는 데이터와 일치하지 않으면 Perl은 비명을 지르고 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">C 전처리 기가 C를 알지 못하는 것처럼 디버그 필터는 Perl을 알지 못합니다. 꽤 쉽게 속일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS는 BeOS입니다.</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">&quot;perlio.h&quot;는 효율성을 위해 얇은 층이기 때문에 이러한 기능의 의미는 기본 구현에 다소 의존합니다. 이러한 변형이 이해되는 경우 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="370f88e98782bfa7f114dbe532b100225210e150" translate="yes" xml:space="preserve">
          <source>Because 1 + 1 is 2, it prints:</source>
          <target state="translated">1 + 1이 2이기 때문에 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8e172ead13ccd2d2e8aa5c2a8960bb8d1e75406d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#scalar-EXPR&quot;&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/a&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;a href=&quot;#scalar-EXPR&quot;&gt; &lt;code&gt;scalar&lt;/code&gt; &lt;/a&gt; 는 단항 연산자 이기 때문에 실수로 EXPR에 괄호로 묶인 목록을 사용하면 스칼라 쉼표 식으로 작동하여 void 컨텍스트에서 마지막 요소를 제외한 모든 요소를 ​​평가하고 스칼라 컨텍스트에서 평가 된 최종 요소를 반환합니다. 이것은 당신이 원하는 것은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3b453ad82fa85092fb1368c3fb85257f0cedd1e" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 은 컴파일 타임에 적용 되기 때문에 컴파일되는 코드의 일반적인 흐름 제어를 존중하지 않습니다. 특히, 조건부의 거짓 브랜치 안에 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 한다고해서 처리되는 것을 막지는 않습니다. 모듈 또는 pragma를 조건부로만로드해야하는 &lt;a href=&quot;if&quot;&gt;경우 if&lt;/a&gt; pragma를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddac942d8eb120d517202681a1ab56648b51a75" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is a global variable, be careful that analyzing an exception caught by &lt;code&gt;eval&lt;/code&gt; doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">때문에 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 글로벌 변수에 의해 잡힌 예외 분석 않도록주의 &lt;code&gt;eval&lt;/code&gt; 글로벌 변수에 대한 참조를 대체하지 않습니다. 조작하기 전에 참조의 로컬 사본을 만드는 것이 가장 쉽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">&lt;b&gt;perldoc&lt;/b&gt; 은 제대로 오염 된 상태로 실행되지 않고 보안 문제가있는 것으로 알려져 있기 때문에 수퍼 유저로 실행되면 유효하고 실제적인 ID를 아무도 또는 nouser의 계정으로 설정하거나 권한이없는 경우 -2로 설정하여 권한을 삭제하려고 시도합니다. 권한을 포기할 수 없으면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 트리거 보간 때문에 &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 와 같은 것을 사용해야합니다. 문자 그대로 일치 시키 합니다.</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">때문에 &lt;code&gt;$sv&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 연산자는 그것에인가된다 음역 실제로 실행되지 않으며, 프로그램되지 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . 이것은 캡처 변수가 READONLY 변수이므로 5.8 이전 버전의 동작과 다릅니다. 이제 기본 엔진에 할당되면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="6c984d748d72c5bb3b2196996f098ba27134cde9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; when the &lt;code&gt;y///&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;die&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">&lt;code&gt;$sv&lt;/code&gt; 는 &lt;code&gt;y///&lt;/code&gt; 연산자가 적용될 때 &lt;code&gt;undef&lt;/code&gt; 이기 때문에 음역은 실제로 실행되지 않고 프로그램은 &lt;code&gt;die&lt;/code&gt; 않습니다 . 이것은 캡처 변수가 READONLY 변수 였기 때문에 5.8 및 이전 버전의 작동 방식과 다릅니다. 이제 그들은 기본 엔진에 할당되었을 때 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b914e32b809fa7c48d9ec627188d82ebed09a33b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt;. The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt;s from the input list.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 반환 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 피연산자 일 때 &lt;code&gt;NaN&lt;/code&gt; 를 (숫자가 아닌 값)와 같은 비교 기능을 정렬 할 때,주의 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 포함 할 수있는 목록 &lt;code&gt;NaN&lt;/code&gt; 이를 . 다음 예는 활용 &lt;code&gt;NaN != NaN&lt;/code&gt; 어떠한 제거 &lt;code&gt;NaN&lt;/code&gt; 가 입력리스트로부터들.</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 피연산자 일 때 &lt;code&gt;NaN&lt;/code&gt; 를 (숫자가 아닌 값)와 같은 비교 기능을 정렬 할 때,주의 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 포함 할 수있는 목록 &lt;code&gt;NaN&lt;/code&gt; 이를 . 다음의 예는 것을 활용한다 &lt;code&gt;NaN != NaN&lt;/code&gt; 어떤 제거하는 &lt;code&gt;NaN&lt;/code&gt; 의를 입력리스트로부터들.</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 피연산자 일 때 &lt;code&gt;NaN&lt;/code&gt; 를 (숫자가 아닌 값)와 같은 비교 기능을 정렬 할 때,주의 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 포함 할 수있는 목록 &lt;code&gt;NaN&lt;/code&gt; 이를 . 다음 예는 활용 &lt;code&gt;NaN != NaN&lt;/code&gt; 어떠한 제거 &lt;code&gt;NaN&lt;/code&gt; 가 입력리스트로부터들.</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">왜냐하면 &lt;code&gt;.&lt;/code&gt; 는 정규 표현식에서 특별하며 모든 단일 문자와 일치 할 수 있습니다 &lt;code&gt;P.&lt;/code&gt; 여기서 정규 표현식 P 는 원래 문자열의 &amp;lt;Pl&amp;gt;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">왜냐하면 &lt;code&gt;.&lt;/code&gt; 디렉토리 구분자로 사용되었으며 파일 이름은 10 자 이후 고유 한 것으로 가정 할 수 없었습니다. Acorn은 후행 &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; 및 &lt;code&gt;.o&lt;/code&gt; 를 제거하기 위해 C 컴파일러를 구현했습니다. 소스 코드에 지정된 파일 이름에서 접미사를 제거하고 각 파일을 저장합니다. 접미사 이름을 딴 하위 디렉토리에서. 따라서 파일이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 런타임 연산자이고, 이것은 루프를 매번 실행할 얻는다. 결과적으로 루프 외부에서 변수를 지역화하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 때문에 는 단항 연산자 실수로 EXPR에 괄호로 묶은 목록을 사용하는 경우 이는 스칼라 쉼표 표현식으로 작동하여 void 컨텍스트에서 마지막 요소를 제외한 모든 요소를 ​​평가하고 스칼라 컨텍스트에서 평가 된 최종 요소를 리턴합니다. 이것은 거의 당신이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 컴파일 타임에 적용 되므로 컴파일되는 코드의 일반적인 흐름 제어를 고려하지 않습니다. 특히, 조건부의 거짓 브랜치에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고해서 처리되는 것을 막을 수는 없습니다. 모듈 또는 pragma를 조건부로만로드해야하는 &lt;a href=&quot;if&quot;&gt;경우 if&lt;/a&gt; pragma를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 는 단항 연산자 이므로 실수로 EXPR에 괄호로 묶은 목록을 사용하는 경우 이는 스칼라 쉼표 표현식으로 작동하여 void 컨텍스트에서 마지막 요소를 제외한 모든 요소를 ​​평가하고 스칼라 컨텍스트에서 평가 된 최종 요소를 리턴합니다. 이것은 거의 당신이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 컴파일 타임에 적용 되므로 컴파일되는 코드의 일반적인 흐름 제어를 고려하지 않습니다. 특히, 조건부의 거짓 브랜치에 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고해서 처리되는 것을 막을 수는 없습니다. 모듈 또는 pragma를 조건부로만로드해야하는 &lt;a href=&quot;../if&quot;&gt;경우 if&lt;/a&gt; pragma를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f563a9178b31c7b0b34b9e11ab4a6bde66fbd45" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global status variables that might be set by anything you do in your &lt;code&gt;DESTROY&lt;/code&gt; method. If you are in doubt about a particular status variable, it doesn't hurt to localize it. There are five global status variables, and the safest way is to localize all five of them:</source>
          <target state="translated">때문에 &lt;code&gt;DESTROY&lt;/code&gt; 방법은 언제든지 호출 할 수 있습니다, 당신은 당신이 당신의에서 할 아무것도에 의해 설정 될 수있는 글로벌 상태 변수 지역화해야 &lt;code&gt;DESTROY&lt;/code&gt; 방법. 특정 상태 변수에 대해 의심이가는 경우 현지화해도 문제가되지 않습니다. 5 개의 전역 상태 변수가 있으며 가장 안전한 방법은 5 개를 모두 지역화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">때문에 &lt;code&gt;DESTROY&lt;/code&gt; 방법은 언제든지 호출 할 수 있습니다, 당신은 당신이 당신에 업데이트 할 수있는 전역 변수 지역화해야 &lt;code&gt;DESTROY&lt;/code&gt; 를 . 특히, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;$@&lt;/code&gt; 현지화해야 하고 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 백틱을 사용하는 경우 &lt;code&gt;$?&lt;/code&gt; 를 현지화해야 합니까? .</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">테스트 중에 &lt;code&gt;@INC&lt;/code&gt; 에 빌드 디렉토리를 추가하기 위해 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 자주 사용 되므로 prove는 &lt;code&gt;PERL5LIB&lt;/code&gt; 에있는 디렉토리 이름을 -I 스위치로 전달합니다. 이것의 최종 효과는 증명이 오염 모드에서 실행될 때도 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 적용된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">때문에 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 종종 빌드 디렉토리를 추가하기 위해 테스트 중에 사용됩니다 &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 어떤 디렉토리의 이름에서 발견 통과 &lt;code&gt;PERL5LIB&lt;/code&gt; -I 스위치로. 이것의 최종 효과는 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 오염 모드에서도 인정 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">때문에 &lt;code&gt;PL_restartop&lt;/code&gt; 가 비 - 널이, &lt;code&gt;run_body&lt;/code&gt; 는 새로운 runops 루프를 개시 및 실행을 계속한다.</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">때문에 &lt;code&gt;STORABLE_attach&lt;/code&gt; 이 클래스 (아닌 객체)를 전달, 그것은 또한 오히려 전달 된 객체를 수정하는 것보다 직접 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65e2bf1b173528f8a073f03b46510698c20426ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;local&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 은 런타임 연산자 이기 때문에 루프를 통해 매번 실행됩니다. 결과적으로 루프 외부에서 변수를 지역화하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Acorns 는 텍스트 파일에서 Unix와 같이 &lt;code&gt;\012&lt;/code&gt; 로 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; )을 사용하여 ASCII를 사용 하고 Unix 파일 이름 에뮬레이션은 기본적으로 켜져 있기 때문에 대부분의 간단한 스크립트는 &quot;바로&quot;작동합니다. 기본 파일 시스템은 모듈 식이며 개별 파일 시스템은 대소 문자를 구분하거나 구분하지 않고 일반적으로 대소 문자를 유지합니다. 일부 기본 파일 시스템에는 이름 길이 제한이 있으며 파일 및 디렉토리 이름이 자동으로 잘립니다. 스크립트는 표준 파일 시스템의 이름 길이가 &lt;b&gt;10&lt;/b&gt; 자로 제한 되며 디렉토리에 최대 77 개의 항목이 있지만 다른 파일 시스템은 이러한 제한을 적용하지 않을 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="28c382ede78c908c2143af19dbf455bab6188b9c" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt;) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Acorns 는 텍스트 파일에서 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; ) 과 함께 ASCII를 Unix와 같은 &lt;code&gt;\012&lt;/code&gt; 하고 Unix 파일 이름 에뮬레이션이 기본적으로 켜져 있기 때문에 대부분의 간단한 스크립트는 &quot;즉시&quot;작동 할 것입니다. 기본 파일 시스템은 모듈 식이며 개별 파일 시스템은 자유롭게 대소 문자를 구분하거나 구분하지 않으며 일반적으로 대소 문자를 보존합니다. 일부 기본 파일 시스템에는 이름 길이 제한이 있으며 파일 및 디렉토리 이름이 자동으로 잘립니다. 스크립트는 현재 표준 파일 시스템의 이름 길이 제한이 &lt;b&gt;10&lt;/b&gt; 자 (디렉토리에 최대 77 개 항목 포함) 임을 알고 있어야합니다. 그러나 다른 파일 시스템에서는 이러한 제한을 적용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">C에는 정수 지수 함수가 내장되어 있지 않기 때문에 Perl의 ** 연산자를 사용할 수있게하겠습니다 (Perl은 C로 **를 구현하기 때문에 소리보다 유용하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perl에서는 패키지 이름 및 서브 루틴 이름에 베어 워드를 사용할 수 있으므로 베어 워드의 의미를 잘못 해석하는 경우가 있습니다. 예를 들어, &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 구문 은 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; 또는 &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; 로 해석 될 수 있습니다 . 영어에서 두 번째 해석은 &quot;Class ()라는 서브 루틴을 호출 한 다음 Class ()의 리턴 값에 대한 메소드로 new ()를 호출합니다&quot;로 읽습니다. 라는 서브 루틴이있는 경우 &lt;code&gt;Class()&lt;/code&gt; 현재의 네임 스페이스에가, 펄 항상 해석합니다 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 두 번째 대안으로 :에 대한 호출 &lt;code&gt;new()&lt;/code&gt; 의 호출에 의해 반환 된 객체의 &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0ebaa0b26d8e2869e78f420c4e273d09ec93726" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt;. In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perl을 사용하면 패키지 이름과 서브 루틴 이름에 베어 워드를 사용할 수 있기 때문에 때때로 베어 워드의 의미를 잘못 해석합니다. 예를 들어, &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 구성 은 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; 또는 &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; 로 해석 될 수 있습니다 . 영어에서 두 번째 해석은 &quot;Class ()라는 이름의 서브 루틴을 호출 한 다음, Class ()의 반환 값에 대한 메서드로 new ()를 호출&quot;이라고 읽습니다. 현재 네임 스페이스에 &lt;code&gt;Class()&lt;/code&gt; 라는 서브 루틴이있는 경우 Perl은 항상 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 를 두 번째 대안으로 해석 합니다. &lt;code&gt;Class()&lt;/code&gt; 호출에 의해 반환 된 객체에 대한 &lt;code&gt;new()&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perl은 표시하기 전에 포착되지 않은 예외 메시지를 문자열 화하기 때문에 예외 오브젝트에 대해 문자열 화 조작을 과부하 할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perl은 표시하기 전에 포착되지 않은 예외 메시지를 문자열 화하기 때문에 예외 오브젝트에 대해 문자열 화 조작을 과부하 할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="451d2525676f60927dbbc662f71037a75004b879" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that. The stringified message should be non-empty, and should end in a newline, in order to fit in with the treatment of string exceptions. Also, because an exception object reference cannot be stringified without destroying it, Perl doesn't attempt to append location or other information to a reference exception. If you want location information with a complex exception object, you'll have to arrange to put the location information into the object yourself.</source>
          <target state="translated">Perl은 표시되기 전에 포착되지 않은 예외 메시지를 문자열 화하기 때문에 예외 객체에 대한 문자열 화 작업을 오버로드 할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오 . 문자열 화 된 메시지는 비어 있지 않아야하며 문자열 예외 처리에 맞추기 위해 개행으로 끝나야합니다. 또한 예외 개체 참조는 삭제하지 않고는 문자열화할 수 없기 때문에 Perl은 참조 예외에 위치 또는 기타 정보를 추가하려고 시도하지 않습니다. 복잡한 예외 개체가있는 위치 정보를 원하는 경우 위치 정보를 개체에 직접 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Perl은 모든 숫자 계산에 내부적으로 double (또는 구성된 경우 long double)을 사용하기 때문에 double에서 float로 변환 한 다음 다시 double로 변환하면 정밀도가 손실되므로 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ) 일반적으로 $ foo와 같습니다.</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">UTF-8은 Perl의 내부 형식 중 하나이므로 인코딩 또는 디코딩 단계를 건너 뛰고 UTF8 플래그를 직접 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDIC는 UTF-8과 매우 유사하기 때문에 그 차이점은 대부분 숨겨져 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; 과 같은 것은 아님 )은 스크립트가 플랫폼의 &quot;기본&quot;8 비트 인코딩 유니 코드로되어 있음을 선언합니다. &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; 레이어와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f78470b23c3e4057a6f3bfa3fb579763a7c89c67" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;use utf8&lt;/code&gt; (and NOT something like &lt;code&gt;use utfebcdic&lt;/code&gt;) declares the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDIC는 UTF-8과 매우 유사하기 때문에 차이점은 대부분 숨겨져 있습니다. &lt;code&gt;use utf8&lt;/code&gt; (그리고 &lt;code&gt;use utfebcdic&lt;/code&gt; 과 같은 것이 아님 )은 스크립트가 플랫폼의 &quot;기본&quot;8 비트 유니 코드 인코딩으로되어 있음을 선언합니다. ( &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; 레이어와 유사합니다 .)</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">VMS의 종료 코드는 다른 우주와 훨씬 다르고 펄은 내 방식대로 끔찍한 맹 글링을 수행하므로 VMS에서 이와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">XS 모듈은 perl 바이너리를 다시 연결해야하므로 XS 확장 모듈을 빌드하려면 perl 바이너리 배포판과 perl 소스 배포판이 모두 필요합니다. 또한 소스 분배에서 perl 바이너리를 빌드해야 perl 바이너리의 모든 구성 요소가 필수 링크 단계에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실패한 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 일치는 오프셋을 재설정하지 않기 때문에이 경우 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 의 리턴은 변경되지 않습니다. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실패한 &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 일치는 오프셋을 재설정하지 않기 때문에이 경우 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 의 리턴은 변경되지 않습니다. &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;../perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7ae901f4727ecaa2d777b8bd8dde60ff479daae" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;m//gc&lt;/code&gt; match doesn't reset the offset, the return from &lt;a href=&quot;#pos-SCALAR&quot;&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/a&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실패한 &lt;code&gt;m//gc&lt;/code&gt; 일치는 오프셋을 재설정하지 않으므로이 경우 &lt;a href=&quot;#pos-SCALAR&quot;&gt; &lt;code&gt;pos&lt;/code&gt; &lt;/a&gt; 에서 반환되는 값도 변경되지 않습니다. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">잠재적 후보 목록이 리턴되므로 &lt;code&gt;while&lt;/code&gt; 루프는 socket () 및 connect () 호출 모두에 성공 하는 후보를 찾을 때까지 차례로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">향후 유니 코드 릴리스에서는 이름 수정이 추가 될 수 있으므로 &lt;code&gt;viacode&lt;/code&gt; 가 반환 하는 이름 은 결과적으로 변경 될 수 있습니다. 이것은 드문 일이지만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">마침표는 메타 문자이므로 일반 마침표와 일치하도록 이스케이프 처리해야합니다. 예를 들어, &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 는 문자 세트이므로 &lt;code&gt;[^\d\w]&lt;/code&gt; 를 &lt;code&gt;[\D\W]&lt;/code&gt; 로 생각하는 것은 올바르지 않습니다 . 실제로 &lt;code&gt;[^\d\w]&lt;/code&gt; 는 &lt;code&gt;[^\w]&lt;/code&gt; 와 동일하며 &lt;code&gt;[\W]&lt;/code&gt; 와 동일 합니다. DeMorgan의 법칙을 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="7b8b1120df9a594afd2813233aa665ec7f417ba1" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt;; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt;. Think DeMorgan's laws.</source>
          <target state="translated">마침표는 메타 문자이므로 일반 마침표와 일치하도록 이스케이프 처리해야합니다. 예를 들어, &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 는 문자 집합 이기 때문에 &lt;code&gt;[^\d\w]&lt;/code&gt; 를 &lt;code&gt;[\D\W]&lt;/code&gt; 로 생각하는 것은 올바르지 않습니다 . 사실 &lt;code&gt;[^\d\w]&lt;/code&gt; 는 &lt;code&gt;[^\w]&lt;/code&gt; 와 동일하며 &lt;code&gt;[\W]&lt;/code&gt; 와 동일 합니다. DeMorgan의 법칙을 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="4df556755141c60db4ee1a86c658450735dbe881" translate="yes" xml:space="preserve">
          <source>Because a url like &lt;code&gt;http://myrepo.example.com/&lt;/code&gt; is ambiguous as to type, producers should provide a &lt;code&gt;type&lt;/code&gt; whenever a &lt;code&gt;url&lt;/code&gt; key is given. The &lt;code&gt;type&lt;/code&gt; field should be the name of the most common program used to work with the repository, e.g. &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, &lt;code&gt;darcs&lt;/code&gt;, &lt;code&gt;bzr&lt;/code&gt; or &lt;code&gt;hg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://myrepo.example.com/&lt;/code&gt; 과 같은 URL 은 입력이 모호 하기 때문에 제작자는 &lt;code&gt;url&lt;/code&gt; 키가 제공 될 때마다 &lt;code&gt;type&lt;/code&gt; 제공해야합니다 . &lt;code&gt;type&lt;/code&gt; 필드는 저장소, 예를 들면 함께 작업에 사용되는 가장 일반적인 프로그램의 이름이어야합니다 &lt;code&gt;git&lt;/code&gt; , &lt;code&gt;svn&lt;/code&gt; , &lt;code&gt;cvs&lt;/code&gt; , &lt;code&gt;darcs&lt;/code&gt; , &lt;code&gt;bzr&lt;/code&gt; 또는 &lt;code&gt;hg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">access ()가 stat ()를 호출하지 않기 때문에 (적어도 Perl에 보이지 않는 방식으로) &lt;b&gt;통계 결과 캐시 &quot;_&quot;는 설정되지 않습니다&lt;/b&gt; . 이것은 다음 두 테스트의 결과가 다르다는 것을 의미합니다. 첫 번째는 스탯 비트가</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">typeglob에 대한 참조를 할당하면 별칭이 만들어 지므로 로컬 함수 또는 적어도 로컬 별칭을 효과적으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">백틱은 표준 오류에 영향을 미치지 않으므로이 문제를 해결하려면 셸 파일 설명자 구문 (쉘이이를 지원한다고 가정)을 사용하십시오. 명령의 STDERR 및 STDOUT을 함께 캡처하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">CRLF와 LF가 모두 LF로 끝나기 때문에 입력 레코드 구분 기호를 LF로 설정하고 나중에 CR을 제거 할 수 있습니다. 작성하는 것이 좋습니다 :</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">중괄호 (중괄호)는 BLOCK을 포함하여 여러 가지 다른 용도로 사용되기 때문에 펄이 여는 중괄호가 BLOCK을 시작하지 않음을 인식하기 위해 명령문의 시작 부분에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 넣어서 중괄호를 명확하게해야 할 수도 있습니다. . curlies를 사용하는 경제성과 니모닉 가치는 이따금의 번거 로움으로 여겨집니다.</target>
        </trans-unit>
        <trans-unit id="06e52ad8990a21a081873c75e0650e648002cb3f" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;return&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">중괄호 (중괄호)는 BLOCK을 포함하여 다른 여러 가지에 사용되기 때문에, Perl이 여는 중괄호가 BLOCK을 시작하지 않는다는 것을 인식하도록 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; 을 앞에 넣어 문 시작 부분에 중괄호를 명확하게해야 할 수도 있습니다. . 컬리 사용의 경제성과 니모닉 적 가치는 때때로 이처럼 번거 로움을 더할 가치가있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">디렉토리가 존재하는지 확인하기 위해 디렉토리가 너무 잘 작동하지 않기 때문에 (수정 된 시간이 너무 자주 변경됨) dir_target ()은 작성된 디렉토리에 .exists 파일을 작성합니다. 이것이 당신이 의존 해야하는 것입니다. 이식성을 위해 파일과 디렉토리를 구분하려면 '/'대신 $ (DIRFILESEP) 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">각 피연산자는 정수 형식으로 평가되므로 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 는 목록 컨텍스트에서 두 개의 요소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">비 유닉스 포트에서도 Perl의 glob 기능은 표준 Unix globbing 의미를 따릅니다. 숨겨지지 않은 모든 파일을 가져 오려면 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; 가 필요 합니다. 따라서 구형 시스템에서도 glob ()를 이식 할 수 있습니다. 포트에는 독점적 인 글 로빙 기능도 포함되어있을 수 있습니다. 자세한 내용은 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4527823ffed4457ee7db37d2aeb7752e646692c1" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">Unix가 아닌 포트에서도 Perl의 glob 기능은 표준 Unix 글 로빙 의미 체계를 따르기 때문입니다. 모든 (숨겨지지 않은) 파일을 가져 오려면 &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; 이 필요 합니다. 이로 인해 glob ()은 레거시 시스템에서도 이식 가능합니다. 포트에는 독점적 인 globbing 기능도 포함될 수 있습니다. 자세한 내용은 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a019fec3551e537f7d797537de86770f8cb583e9" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; switch could also cause odd results.</source>
          <target state="translated">역사적으로 일부 운영 체제는 &lt;code&gt;#!&lt;/code&gt; 32 자 이후의 줄에서 일부 스위치는 명령 줄에서 전달 될 수 있고 일부는 전달되지 않을 수 있습니다. 주의하지 않으면 문자없이 &quot;-&quot;를 얻을 수도 있습니다. 모든 스위치가 32 자 경계 앞 또는 뒤에 있는지 확인하고 싶을 것입니다. 대부분의 스위치는 중복 처리 여부에 상관하지 않지만 완전한 스위치 대신 &quot;-&quot;를 받으면 Perl이 프로그램 대신 표준 입력을 실행하려고 할 수 있습니다. 부분적인 &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; 스위치도 이상한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">역사적으로 일부 운영 체제는 &lt;code&gt;#!&lt;/code&gt; 의 커널 해석을 자동으로 차단했기 때문에 ! 32 자 뒤의 행에서 일부 스위치는 명령 행에 전달 될 수 있지만 일부는 그렇지 않을 수 있습니다. 조심하지 않으면 문자없이 &quot;-&quot;를받을 수도 있습니다. 모든 스위치가 해당 32 자 경계 전후에 있는지 확인하고 싶을 것입니다. 대부분의 스위치는 실제로 중복으로 처리되는지 신경 쓰지 않지만 완전한 스위치 대신 &quot;-&quot;를 얻으면 Perl이 프로그램 대신 표준 입력을 실행하려고 할 수 있습니다. 부분 &lt;b&gt;I&lt;/b&gt; 스위치도 이상한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">_1이 1이면 &quot;1 개의 문서 &lt;b&gt;가&lt;/b&gt; 일치했습니다&quot; 가 표시되기 때문 입니다. 여기서 허용되는 해킹은 다음과 같은 작업을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">기본 8 비트 인코딩에서 UTF-8을 안정적으로 말할 수 없으므로 소스 코드 시작 부분에 바이트 순서 표시가 필요하거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야합니다&lt;/a&gt; . 펄에게 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ad4161b2b0cababc93ea492bc495fcb997c97d88" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;use utf8;&lt;/code&gt;, to instruct perl.</source>
          <target state="translated">기본 8 비트 인코딩에서 UTF-8을 안정적으로 구분할 수 없기 때문에 소스 코드 시작 부분에 Byte Order Mark가 필요하거나 &lt;code&gt;use utf8;&lt;/code&gt; , perl을 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2126d70bfd6541291d6dfdce3ec02ad289bb688a" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, &lt;code&gt;NEXT&lt;/code&gt; has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">인터프리터의 필수 부분이 아닌 모듈이기 때문에 &lt;code&gt;NEXT&lt;/code&gt; 는 메서드 조회 시퀀스에서 주변 호출이 발견 된 위치를 추측해야합니다. 다이아몬드 상속 패턴이 있으면 때때로 잘못 추측합니다.</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">NEXT.pm은 인터프리터의 필수적인 부분이 아닌 모듈이기 때문에 메소드 조회 시퀀스에서 주변 호출이 어디서 발견되었는지 추측해야합니다. 다이아몬드 상속 패턴이있는 경우 때때로 잘못 추측합니다.</target>
        </trans-unit>
        <trans-unit id="24e659fa848838e6ef33ca050446877416a84202" translate="yes" xml:space="preserve">
          <source>Because literal conversions also work on empty strings, it may surprise some people:</source>
          <target state="translated">리터럴 변환은 빈 문자열에서도 작동하기 때문에 일부 사람들은 놀라게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; 클래스에 로드 하는 작업은 비용이 많이 드는 작업이므로 일반 내장 변수를 사용하는 방법을 배워야합니다.</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">많은 운영 체제에서 Perl 프로그램 파일에 대한 읽기 액세스 권한이있는 사용자는 누구나 사본을 작성하고 사본을 패치 한 다음 사본을 실행할 수 있으므로 보안을 고려한 Perl 프로그래머는 설치된 Perl 사본이 아닌 Perl의 사본을 호출해야합니다. &lt;code&gt;$^X&lt;/code&gt; 의해 참조되는 사본 . 다음 명령문은이 목표를 달성하고 명령으로 호출하거나 파일로 참조 할 수있는 경로 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dd84b64cdc62e50ad281c65222f1464d48cdcca2" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt;. The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">많은 운영 체제에서 Perl 프로그램 파일에 대한 읽기 권한이있는 모든 사람이 복사본을 만들고 패치 한 다음 복사본을 실행할 수 있도록 허용하기 때문에 보안에 민감한 Perl 프로그래머는 설치된 Perl 복사본을 호출하는 데주의해야합니다. &lt;code&gt;$^X&lt;/code&gt; 참조하는 사본 . 다음 명령문은이 목표를 달성하고 명령으로 호출하거나 파일로 참조 할 수있는 경로 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">기본 운영 체제 파일 핸들은 전역 적이며 현재 255에서 할당 된 값으로 0이 예약 된 값이므로 Unix 에뮬레이션 라이브러리는 Unix 파일 핸들을 에뮬레이트합니다. 따라서 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 을 자녀에게 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="775710224a556c9491575c5fd5adccb463f6fd25" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">기본 운영 체제 파일 핸들은 전역이고 현재 255에서 할당 된 값이 예약 된 값이므로 Unix 에뮬레이션 라이브러리는 Unix 파일 핸들을 에뮬레이트합니다. 결과적으로 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 을 자녀에게 전달하는 데 의존 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Perl의 객체는 참조로 구현되므로 객체와 함께 순환 참조를 가질 수도 있습니다. 각 노드가 부모 및 자식 노드를 참조하는 TreeNode 클래스를 상상해보십시오. 부모가있는 모든 노드는 순환 참조의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">DST 변경으로 인해 같은 날 두 개의 다른 GMT 시간에 대해 동일한 현지 시간이 발생하는 시간대가 많이 있습니다. 예를 들어 &quot;유럽 / 파리&quot;시간대에서 2001-10-28 02:30:00의 현지 시간은 2001-10-28 00:30:00 GMT &lt;b&gt;또는&lt;/b&gt; 2001-10-28 01을 나타낼 수 있습니다 . 30:00 그리니치 표준시.</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">최소한 5.6.1 버전에서는 perl (# 19213)의 버그로 인해 Win32 &lt;code&gt;\&lt;/code&gt; 대신 Unix에서와 같이 Win32에서 &lt;code&gt;/&lt;/code&gt; 가되도록 경로 구분 기호를 하드 코딩해야합니다 . 그렇지 않으면 perl은 다시 필요한 경우 또는 최악의 경우 코어 덤프 인 경우 자체 % INC의 이중로드 파일을 정확하게 읽지 못합니다.</target>
        </trans-unit>
        <trans-unit id="bddbdae97f197ffe17554a082cd1e7f07c2861e6" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt;. Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">때문에 펄의 버그 (# 19213)의 버전 5.6.1에서 적어도, 우리는이 수는 Win32에서 필요로의 경로 구분자를 하드 코딩해야 &lt;code&gt;/&lt;/code&gt; 유닉스보다는는 Win32에서와 같은 &lt;code&gt;\&lt;/code&gt; . 그렇지 않으면 perl은 다시 필요한 경우 자체 % INC를 정확하게 이중로드 파일을 읽지 못하거나 최악의 경우 코어 덤프를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">더 나은 것이 없기 때문에이 모듈은 자체 루틴을 사용하여 ICMP 패킷을 포장 및 포장 해제합니다. 다른 종류의 ICMP 패킷을 모두 이해하는 별도의 모듈을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6dcc7b169aa07008925e53db149a044f2ea93db" translate="yes" xml:space="preserve">
          <source>Because of all the alias issues, and because in the general case encodings have state, &quot;Encode&quot; uses an encoding object internally once an operation is in progress.</source>
          <target state="translated">모든 별칭 문제와 일반적인 경우 인코딩에 상태가 있기 때문에 &quot;Encode&quot;는 작업이 진행되는 동안 내부적으로 인코딩 개체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">v5.22부터 이러한 모든 문제로 인해 단일 바이트 로케일이 적용되는 경우 멀티 바이트 (따라서 유니 코드) 코드 포인트가 사용되는 경우 Perl은 경고를 발생시킵니다. (그렇지 않으면 실행 속도가 느려질 경우이를 확인하지는 않지만)</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">레거시 인코딩과의 하위 호환성으로 인해 &quot;모든 문자에 고유 한 숫자&quot;라는 아이디어가 약간 세분화됩니다. 대신 &quot;모든 문자에 대해 하나 이상의 숫자&quot;가 있습니다. 동일한 문자가 여러 레거시 인코딩에서 다르게 표현 될 수 있습니다. 컨버스가 사실이 아닙니다. 일부 코드 포인트에는 할당 된 문자가 없습니다. 첫째, 달리 사용 된 블록 내에 할당되지 않은 코드 포인트가 있습니다. 둘째, 실제 문자를 나타내지 않는 특수 유니 코드 제어 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 의 간단한 경우에 대한 curlies를 생략 할 수 있기 때문에 사람들은 종종 역 참조 기호를 적절한 연산자로 보는 실수를 저지르고 우선 순위가 궁금합니다. 그래도 괄호 대신 괄호를 사용할 수 있습니다. 그렇지 않습니다. 아래 차이점을 고려하십시오. case 0은 case 1의 짧은 버전입니다.</target>
        </trans-unit>
        <trans-unit id="e8951f412eada97de516eafdeec177d3c0f76b4b" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt;, people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 의 단순한 경우에 대한 컬리를 생략 할 수 있기 때문에 사람들은 종종 역 참조 기호를 적절한 연산자로 보는 실수를 저지르고 그 우선 순위에 대해 궁금해합니다. 그래도 중괄호 대신 괄호를 사용할 수 있습니다. 그렇지 않습니다. 아래의 차이점을 고려하십시오. case 0은 case 1의 축약 형 버전입니다.</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">클럭 세분성으로 인해 만료 시간이 예상보다 빨리 1 초 정도 발생할 수 있습니다. 예를 들어, 수명이 10 초인 값을 저장하고 특정 날짜에 12 : 00 : 00.998에 저장한다고 가정하십시오. 메모는 시계를보고 12:00:00을 참조합니다. 그런 다음 9.01 초 후 12 : 00 : 10.008에 다시 읽으려고합니다. 메모는 시계를보고 12:00:10을 참조하여 값이 만료되었다고 결론을 내립니다. &lt;code&gt;Time::HiRes&lt;/code&gt; 설치되어 있으면 발생하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">OS / 2의 특이성 때문에 동일한 바구니에 모든 계란을 가질 수는 없습니다 (EMX 환경이이 한계를 극복하기 위해 노력하지만 상황이 다소 개선 될 수 있습니다). 배포판에서 제공하는 Perl에 대한 4 개의 실행 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">전체적인 효과 때문에이 설정은 모듈 등에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">네이티브 yacc에 대한 문제 때문에 GNU bison을 사용하여 perly.y에 대한 순수한 (= reentrant) 파서를 생성했습니다. yacc는 실제로 다음과 같은 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="57e65a7490f61f523f42c4deffd151e416a21006" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;-ing to locations you got from &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; (and no others), and you are usually free to use &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; even in &quot;text&quot; mode. Using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; or other file operations may be non-portable. If you use &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on a file, however, you can usually &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; with arbitrary values safely.</source>
          <target state="translated">때문에 &quot;텍스트&quot;모드 번역, DOSish의 perls은 사용에 제한이 &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; &quot;텍스트&quot;모드에서 액세스 파일에 있습니다. 당신이 &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 에서 얻은 (그리고 다른 사람이없는) 위치 를 &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 고수하십시오 . 그리고 당신은 보통 &quot;텍스트&quot;모드에서도 &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 자유롭게 사용할 수 있습니다. &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 또는 다른 파일 작업을 사용하면 이식이 불가능할 수 있습니다. 당신이 사용하는 경우 &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 파일에, 그러나, 당신은 일반적으로 수 &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; 안전하게 임의의 값으로.</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">&quot;텍스트&quot;모드 변환으로 인해 DOSish perls은 &quot;텍스트&quot;모드로 액세스 된 파일에 대해 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 를 사용 하는 데 제한이 있습니다. 당신이 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (그리고 다른 사람은 아님) 에서 얻은 위치 를 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 고수하십시오 . 그리고 보통 &quot;text&quot;모드에서도 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 자유롭게 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 다른 파일 작업을 사용 하는 것은 이식 불가능할 수 있습니다. 당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 파일에, 그러나, 당신은 일반적으로 수 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 안전하게 임의의 값으로.</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">16 비트로 인해 UTF-16은 바이트 순서에 따라 다릅니다. UTF-16 자체는 메모리 내 계산에 사용될 수 있지만 저장 또는 전송이 필요한 경우 UTF-16BE (big-endian) 또는 UTF-16LE (little-endian) 인코딩을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">사용 된 알고리즘으로 인해 ISO-8859 중 하나만 유일하게 용의자 (ascii 및 utf8 제외)가 아니면 ISO-8859 시리즈 및 기타 단일 바이트 인코딩이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cf1c92c7c06c92a6e6b33e7b9bd233615db8e45" translate="yes" xml:space="preserve">
          <source>Because of the nature of the Perl parsing and tokenizing routines, certain initialization values &lt;b&gt;must&lt;/b&gt; be quoted in order to correctly parse as the intended version, especially when using the &lt;code&gt;declare&lt;/code&gt; or &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; methods. While you do not have to quote decimal numbers when creating version objects, it is always safe to quote &lt;b&gt;all&lt;/b&gt; initial values when using version.pm methods, as this will ensure that what you type is what is used.</source>
          <target state="translated">Perl 구문 분석 및 토큰 화 루틴의 특성으로 인해 , 특히 &lt;code&gt;declare&lt;/code&gt; 또는 &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv ()&quot;&lt;/a&gt; 메소드를 사용할 때 의도 한 버전으로 올바르게 구문 분석 &lt;b&gt;하려면&lt;/b&gt; 특정 초기화 값 &lt;b&gt;을&lt;/b&gt; 인용 &lt;b&gt;해야합니다&lt;/b&gt; . 버전 개체를 만들 때 십진수를 인용 할 필요는 없지만 version.pm 메서드를 사용할 때는 항상 &lt;b&gt;모든&lt;/b&gt; 초기 값 을 인용 &lt;b&gt;하는&lt;/b&gt; 것이 안전합니다. 이렇게하면 입력 한 내용이 사용되는지 확인할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e124c1c916c9b7a769264558af430e4f129d0a7" translate="yes" xml:space="preserve">
          <source>Because of the nature of the features it enables, forward compatibility can not be guaranteed in any way.</source>
          <target state="translated">활성화되는 기능의 특성으로 인해 어떤 식 으로든 순방향 호환성을 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="89787285641f86ade5feb7e0702432198446d5b1" translate="yes" xml:space="preserve">
          <source>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling &lt;code&gt;clearcache&lt;/code&gt; again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</source>
          <target state="translated">연결된 해시 반복기에 대해 정의 된 기호 목록을 가져 오는 것과 관련된 오버 헤드 때문에 한 번만 수행되고 목록은 후속 반복에 다시 사용됩니다. 이 패키지를 통해 만들어진 심볼에 대한 변경 사항이 기록되지만, 드물게 누군가가 외부에서 프로세스의 심볼 테이블을 변경하는 경우 (네트워크의 일부 소프트웨어를 사용하여 가능) 반복기가 심볼 테이블과 동기화되지 않습니다. 이것이 발생할 것으로 예상되는 경우이 메서드를 호출하여 캐시를 재설정 할 수 있습니다. 또한 첫 번째 인수로 FALSE 값을 전달하면 캐싱이 비활성화됩니다. TRUE 값을 첫 번째 인수로 사용하여 &lt;code&gt;clearcache&lt;/code&gt; 를 다시 호출하여 나중에 다시 활성화 할 수 있습니다 . TRUE 또는 FALSE를 반환하여 캐싱이 이전에 활성화되었는지 여부를 각각 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46fd1b6b9fa8982a77e6c457f5e31e6dd1a8e6bb" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only explicitly use it to maintain weird backward compatibilities.</source>
          <target state="translated">이 수정 자와 관련된 예기치 않은 동작으로 인해 이상한 하위 호환성을 유지하기 위해 명시 적으로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">이 수정 자와 관련된 예기치 않은 동작으로 인해 이전 버전과의 이상한 호환성을 유지하기 위해서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">sort ()에 의한 특수한 사용으로 인해 변수 $ a 및 $ b는이 검사에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="79393165c5e367768108e6eb51a718f96e4510a4" translate="yes" xml:space="preserve">
          <source>Because of this fallback feature of JSON.pm, JSON::PP tries not to be more JavaScript-friendly than JSON::XS (i.e. not to escape extra characters such as U+2028 and U+2029, etc), in order for you not to lose such JavaScript-friendliness silently when you use JSON.pm and install JSON::XS for speed or by accident. If you need JavaScript-friendly RFC7159-compliant pure perl module, try &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, which is derived from &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; web framework and is also smaller and faster than JSON::PP.</source>
          <target state="translated">JSON.pm의 이러한 대체 기능으로 인해 JSON :: PP는 JSON :: XS보다 JavaScript 친화적이지 않습니다 (예 : U + 2028 및 U + 2029 등의 추가 문자를 이스케이프하지 않음). JSON.pm을 사용하고 속도를 위해 또는 우연히 JSON :: XS를 설치할 때 이러한 JavaScript 친 화성을 자동으로 잃지 않습니다. JavaScript 친화적 인 RFC7159 호환 순수 perl 모듈이 필요한 경우 &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; 웹 프레임 워크 에서 파생 된 &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON :: Tiny를 사용&lt;/a&gt; 해보세요. 또한 JSON :: PP보다 작고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">이 메커니즘으로 인해 &lt;b&gt;AutoLoader&lt;/b&gt; 는 항상 d를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하지 않아야 합니다 .</target>
        </trans-unit>
        <trans-unit id="915eb569e5cd5ca772dbf6184e1e9e7f7c40e009" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;use&lt;/code&gt;d and not &lt;code&gt;require&lt;/code&gt;d.</source>
          <target state="translated">이 메커니즘 때문에 &lt;b&gt;AutoLoader&lt;/b&gt; 는 항상 d를 &lt;code&gt;use&lt;/code&gt; d를 &lt;code&gt;require&lt;/code&gt; 하지 않는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">이 두 가지 때문에 ucm 기반 인코딩 SOMETIMES에 사용 된 코드 페이징 접근법이 실패하여이 모듈이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">패턴은 큰 따옴표로 묶인 문자열로 처리되므로 다음도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perl은이 pragma를 적용하기 전에 스크립트를 구문 분석해야하기 때문에 두 번째 바이트에 &lt;code&gt;'\'&lt;/code&gt; ( &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c )를 포함 할 수있는 Shift_JIS 및 Big-5와 같은 인코딩 은 두 번째 바이트가 실수로 뒤에 오는 인용 문자를 이스케이프 할 수 있으므로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e3192cbde985ba3a61564abae80a07c49199034c" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt;) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perl은이 pragma를 적용하기 전에 스크립트를 구문 분석해야하기 때문에 두 번째 바이트가 실수로 뒤 따르는 인용 문자를 이스케이프 할 수 있으므로 두 번째 바이트에 &lt;code&gt;'\'&lt;/code&gt; ( &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c )를 포함 할 수있는 Shift_JIS 및 Big-5와 같은 인코딩은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">포인터 크기가 정수 크기와 반드시 같을 필요는 없으므로 다음 매크로를 사용하여 올바르게 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">스크립트의 방향성이 다르기 때문에 (예 : 히브리어 및 아랍어는 오른쪽에서 왼쪽으로 작성 됨) 유니 코드는 &lt;code&gt;Bidi_Class&lt;/code&gt; 속성을 제공합니다. 이 속성이 가질 수있는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">오염은 각 스칼라 값과 연관되므로 배열 또는 해시의 일부 요소는 오염 될 수 있고 다른 요소는 오염되지 않을 수 있습니다. 해시의 키는 오염 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ED 값이 파일에 다시 기록 될 때 재 부착 세퍼레이터를 가질 것이다. 후행 레코드 구분자 문자열이 누락 된 파일을 작성할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 함수는 파일 끝이나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하기 때문에 다음과 같이 사용되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문은이 의미하는 &lt;code&gt;BEGIN&lt;/code&gt; 블록을 곧만큼, 의미의 수입이 발생하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 파일의 나머지 부분이 컴파일되기 전에 문이 컴파일됩니다. 이것이 pragma 메커니즘으로 기능 할 수있는 방법과 모듈이 서브 루틴을 선언하여 현재 파일의 나머지 부분에 대한 목록 또는 단항 연산자로 표시되는 방법입니다. 당신이 사용하는 경우이 작동하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 대신에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 와 함께이 문제에 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3e36ebc253e6320dfa90cfe5b728b065ce3f37" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;chomp&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">때문에 &lt;code&gt;chomp&lt;/code&gt; ED 값이 파일에 다시 기록 될 때 재 부착 세퍼레이터를 가질 것이다. 후행 레코드 구분자 문자열이 누락 된 파일을 만들 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; 패턴 의 &lt;code&gt;.*&lt;/code&gt; 앞에 있기 때문에 위치를 정확하게 결정할 수 있습니다. 즉, 위해, 그러나, 사실이 아니에요 &lt;code&gt;there&lt;/code&gt; ; 고정 문자열이 나타난 후 어느 시점 에나 나타날 수 있습니다. Perl은 최적화를 위해 둘 다 사용하며, 더 길거나 (동일한 경우) 부동을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="fef986661cf1ec507db2ffa4c44fc0d6ca39bba4" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; 패턴에서 &lt;code&gt;.*&lt;/code&gt; 앞에 있기 때문에 위치를 정확하게 결정할 수 있습니다. 즉, 위해, 그러나, 사실이 아니에요 &lt;code&gt;there&lt;/code&gt; ; 고정 된 문자열이 나타난 후 어느 지점에서나 나타날 수 있습니다. Perl은 최적화를 위해 두 가지를 모두 사용하며 더 긴 것을 선호하거나 동일하다면 플로팅을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="a2431412f653ac2d48b2590f72b1ae7bed247322" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;mark&lt;/code&gt; variable is converted to a pointer on the value stack, extra care must be taken if &lt;code&gt;EXTEND&lt;/code&gt; or any of the &lt;code&gt;XPUSH&lt;/code&gt; macros are invoked within the function, because the stack may need to be moved to extend it and so the existing pointer will now be invalid. If this may be a problem, a possible solution is to track the mark offset as an integer and track the mark itself later on after the stack had been moved.</source>
          <target state="translated">&lt;code&gt;mark&lt;/code&gt; 변수는 값 스택의 포인터로 변환 되기 때문에 &lt;code&gt;EXTEND&lt;/code&gt; 또는 &lt;code&gt;XPUSH&lt;/code&gt; 매크로가 함수 내에서 호출되는 경우 추가주의를 기울여야합니다 . 스택을 확장하려면 스택을 이동해야 할 수 있으므로 기존 포인터가 이제 유효하지 않습니다. 이것이 문제가 될 수있는 경우 가능한 해결책은 마크 오프셋을 정수로 추적하고 스택이 이동 된 후 나중에 마크 자체를 추적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="28a1dea2b8dc5fa2f3798b76ce3f11a720999a6b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;readline&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;readline&lt;/code&gt; 함수는 파일 끝이나 오류시 &lt;code&gt;undef&lt;/code&gt; 를 반환 하기 때문에 때때로 다음과 같은 방식으로 사용되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="206300e9a9cae7d4d33910fad6d81cd5f5d5cc80" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;use&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;use&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;require&lt;/code&gt; instead of &lt;code&gt;use&lt;/code&gt;. With &lt;code&gt;require&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">때문에 &lt;code&gt;use&lt;/code&gt; 문은이 의미하는 &lt;code&gt;BEGIN&lt;/code&gt; 블록을 곧만큼, 의미의 수입이 발생하는 &lt;code&gt;use&lt;/code&gt; 파일의 나머지 부분이 컴파일되기 전에 문이 컴파일됩니다. 이것이 pragma 메커니즘으로 작동 할 수있는 방법과 모듈이 현재 파일의 나머지 부분에 대해 목록 또는 단항 연산자로 표시되는 서브 루틴을 선언 할 수있는 방법입니다. 당신이 사용하는 경우이 작동하지 않습니다 &lt;code&gt;require&lt;/code&gt; 대신에 &lt;code&gt;use&lt;/code&gt; . &lt;code&gt;require&lt;/code&gt; 를 사용하면 다음과 같은 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb97ff89f00546d3eb19d15e7c154022a6e40c9" translate="yes" xml:space="preserve">
          <source>Because the L&amp;lt;...&amp;gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting. That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.</source>
          <target state="translated">L &amp;lt;...&amp;gt;은 언어에서 가장 복잡한 구조이기 때문에 생성되는 이벤트가 언어에서 가장 복잡하다는 사실은 놀랄 일이 아닙니다. 대부분의 복잡성은 속성 값에 숨겨져 있으므로 하이퍼 텍스트 형식이 아닌 형식을 생성하는 Pod 포맷터를 작성하는 경우 속성을 무시하고 L 이벤트 구조를 (아마도) 그렇지 않은 형식 지정 요소처럼 취급 할 수 있습니다. t는 실제로 형식을 변경합니다. 즉, 속성이 아닌 L 이벤트 구조의 내용은 항상 표시되어야하는 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="fe1ecaef6dcc4b2b01535ebf9f55c2fce3a55dd0" translate="yes" xml:space="preserve">
          <source>Because the arithmetic operators all have fixed arity and are postfixed, there is no need for operator precedence, nor for a grouping operator to override precedence. This is half of the point of RPN.</source>
          <target state="translated">산술 연산자는 모두 고정 된 arity를 ​​가지며 접미사이므로 연산자 우선 순위가 필요하지 않으며 그룹화 연산자가 우선 순위를 재정의 할 필요가 없습니다. 이것은 RPN 포인트의 절반입니다.</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">할당은 값을 복사하기 때문에 참조 별 호출을 값별 호출로 전환하는 효과도 있습니다. 그렇지 않으면 함수의 현재 위치에서 수정을 자유롭게 &lt;code&gt;@_&lt;/code&gt; 및 호출자의 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ef6e720933c8cfb7b84641d15fcb0ddf15b2f13b" translate="yes" xml:space="preserve">
          <source>Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), the byte values that result are in an unspecified encoding.</source>
          <target state="translated">bytes pragma는 캡슐화를 중단하기 때문에 (즉, perl 실행 파일이 현재 문자열을 저장하는 방식에 대한 내부를 노출) 결과로 발생하는 바이트 값은 지정되지 않은 인코딩이됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">변환이 수행되기 때문에 변환 될 데이터는 문자열 상수 일 수 없습니다. 스칼라 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">현재 구현에서는 해시 알고리즘에 테이블 및 키 크기를 사용하므로 초기화 매개 변수의 값을 동적으로 변경할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">이 기능의 목적은 기본적으로 내장 함수처럼 작동하는 서브 루틴을 정의 할 수 있도록하기위한 것이므로 해당 내장 함수와 거의 동일하게 구문 분석하는 다른 함수의 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">내부 형식은 종종 UTF-8이므로 UTF-8은 일반적으로 원하는 인코딩이기 때문에 이러한 버그를 찾기가 어렵습니다! 그러나 게으르지 말고 Perl의 내부 형식이 UTF-8이라는 이점을 사용하지 마십시오. 이상한 버그를 피하고 유지 보수 프로그래머에게이를 생각한다고 명시 적으로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="92b5a68a7f930a6d97c59ffe2faa9fff5db40d0e" translate="yes" xml:space="preserve">
          <source>Because the magical increment only works on non-empty strings matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the following will only return an alpha:</source>
          <target state="translated">마법 증분은 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 와 일치하는 비어 있지 않은 문자열에서만 작동 하므로 다음은 알파 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">이 모드에는 파일 형식과 사용 권한이 모두 포함되어 있으므로 실제 사용 권한을 보려면 파일 형식 부분과 &lt;code&gt;&quot;%o&quot;&lt;/code&gt; 사용하여 printf를 마스크 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; 의 결과 에는 모든 메타 문자가 인용 되어 있으므로 &lt;code&gt;\Q\E&lt;/code&gt; 쌍 안에 리터럴 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 를 삽입 할 방법이 없습니다 . 에 의해 보호되는 경우 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; 가 되기 위해 인용 될 것 &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; 그렇지 않은 경우, 보간 된 스칼라의 시작으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="097258c8be4cbb48ed4be0fc9859bc5c3825bc9a" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt;; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; 의 결과 에는 모든 메타 문자가 인용 되어 있으므로 &lt;code&gt;\Q\E&lt;/code&gt; 쌍 안에 리터럴 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 를 삽입 할 방법이 없습니다 . 에 의해 보호되는 경우 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; 가 되기 위해 인용 될 것 &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; 그렇지 않은 경우 보간 된 스칼라의 시작으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">스마트 매치 연산자는 중첩 배열에서 반복되므로 &quot;red&quot;가 배열에 있다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">테스트가 실패 할 때마다 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder가&lt;/a&gt; 생성 하는 표준 실패 메시지가 테스트 오류 출력에서 ​​일반적으로 발생하고 Test :: Builder 버전간에 변경 되었기 때문에 모든 문자열을 사용하여 &lt;code&gt;test_err&lt;/code&gt; 를 호출 하지 않습니다. 그렇게 시간</target>
        </trans-unit>
        <trans-unit id="87490af32e5b48ef0bb10c89847f02a1cf0e7677" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">테스트가 실패 할 때마다 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder가&lt;/a&gt; 생성 하는 표준 실패 메시지는 테스트 오류 출력에서 ​​흔히 발생하고 Test :: Builder 버전간에 변경 되었기 때문에 모든 문자열을 사용하여 &lt;code&gt;test_err&lt;/code&gt; 을 호출하도록 강요하지 않기 때문입니다 . 그렇게 시간</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">대상이 재사용되므로 스택에서 여러 값을 푸시 할 때주의해야합니다. 다음 코드는 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">음역 테이블은 컴파일 타임에 빌드되므로</target>
        </trans-unit>
        <trans-unit id="c4a2190965562aceb584191519393c161752b237" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; may depend on the hardware architecture, it can vary more than the value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt; 값은 하드웨어 아키텍처에 따라 달라질 수 있으므로 &lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt; 값보다 더 다양 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Config{archname}&lt;/code&gt; 값은 하드웨어 아키텍처에 따라 달라질 수 있으므로 &lt;code&gt;$^O&lt;/code&gt; 값보다 더 다양 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">값 행에 임의의 표현식 (캐럿 필드가 아닌 at 필드에 대한)이 포함될 수 있으므로보다 복잡한 처리를 sprintf () 또는 자체 함수와 같은 다른 함수로 팜 아웃 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">변수가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 에서 즉시 변수가 유효 해 지므로 해당 이름을 가진 변수가 이미 범위 내에 있지 않는 한 동일한 명령문 내에서도 패키지 변수를 다시 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">변수가 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 에서 즉시 변수가 유효 해 지므로 해당 이름을 가진 변수가 이미 범위 내에 있지 않는 한 동일한 명령문 내에서도 패키지 변수를 다시 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10adcfecf1a02c362d02294237aa3b65ee35acfd" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;use strict 'vars'&lt;/code&gt;, so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">&lt;code&gt;use strict 'vars'&lt;/code&gt; 하면 변수가 즉시 합법화되기 때문에 해당 이름의 변수가 이미 범위에있는 한 동일한 문 내에서도 패키지 변수를 다시 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">open ()에는 세 개 이상의 인수가 있으므로 ps (1) 명령을 분기합니다.</target>
        </trans-unit>
        <trans-unit id="327e12e185eccd28ae382163925adec0406495ff" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), it forks the ps(1) command</source>
          <target state="translated">open ()에 세 개 이상의 인수가 있기 때문에 ps (1) 명령을 포크합니다.</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">@INC 경로의 어디에 설치하고 누가 @INC 배열을 사용하는지에 대한 정확한 기대를 가진 사람들이 있기 때문입니다. 미세 조정 된 환경에서 &lt;code&gt;UNINST=1&lt;/code&gt; 은 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61339e91fc8e465df58897366d437a1f422fcc97" translate="yes" xml:space="preserve">
          <source>Because there is currently no way for a distribution to specify a dependency on an optional feature of another dependency, the use of &lt;code&gt;optional_feature&lt;/code&gt; is discouraged. Instead, create a separate, installable distribution that ensures the desired feature is available. For example, if &lt;code&gt;Foo::Bar&lt;/code&gt; has a &lt;code&gt;Baz&lt;/code&gt; feature, release a separate &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; distribution that satisfies requirements for the feature.</source>
          <target state="translated">현재 다른 의존성의 옵션 기능에 대한 종속성을 지정하는 배포 방법이 없기 때문에, 사용 &lt;code&gt;optional_feature&lt;/code&gt; 이 좋습니다. 대신 원하는 기능을 사용할 수 있도록 별도의 설치 가능한 배포를 만드십시오. 예를 들어 &lt;code&gt;Foo::Bar&lt;/code&gt; 에 &lt;code&gt;Baz&lt;/code&gt; 기능 이있는 경우 기능 요구 사항을 충족 하는 별도의 &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; 배포를 릴리스 합니다.</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">이러한 자원 오브젝트는 직렬화되는 대상의 &quot;속성&quot;이 아니라 전체 프로세스 / 시스템이 소유 한 것으로 간주되므로 오브젝트 아래의 참조는 직렬화 된 문자열에 포함되지 않아야합니다. 따라서 &lt;code&gt;STORABLE_attach&lt;/code&gt; 를 구현하는 모든 클래스 에서 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 메소드는 참조를 리턴 할 수 없으며 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 가 참조를 리턴하려고 하면 &lt;code&gt;Storable&lt;/code&gt; 은 오류를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="26af08e2f43bfef9b9e40cba2b2ed696b0549e29" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt;, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">이러한 리소스 개체는 직렬화되는 모든 항목의 &quot;속성&quot;이 아니라 전체 프로세스 / 시스템이 소유하는 것으로 간주되기 때문에 개체 아래의 참조는 직렬화 된 문자열에 포함되지 않아야합니다. 따라서 &lt;code&gt;STORABLE_attach&lt;/code&gt; 를 구현하는 모든 클래스 에서 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 메서드는 참조를 반환 할 수 없으며 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 가 참조를 반환하려고 하면 &lt;code&gt;Storable&lt;/code&gt; 에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">이 명령은 새로운 의미이므로 실수로 블록을 입력 한 것으로 보이는 경우 경고가 발행됩니다. 그게 당신이 할 무슨 뜻인지의 경우와 같이 쓰기 &lt;code&gt;;{ ... }&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74266b6323d7ce62912d6c101e78cdb916449da7" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;do { ... }&lt;/code&gt;.</source>
          <target state="translated">이 명령은 어떤 의미에서 새로운 것이기 때문에 실수로 블록을 대신 입력 한 것처럼 보이면 경고가 발행됩니다. 그것이 의미하는 바라면 &lt;code&gt;;{ ... }&lt;/code&gt; 하거나 &lt;code&gt;do { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afe0d4d00dfd6cabe863bda5f9354b347e13a163" translate="yes" xml:space="preserve">
          <source>Because this construct compiles under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt;, unrecognized escapes that generate warnings in normal classes are fatal errors here, as well as all other warnings from these class elements, as well as some practices that don't currently warn outside &lt;code&gt;re 'strict'&lt;/code&gt;. For example you cannot say</source>
          <target state="translated">이 구조 &lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict&lt;/code&gt; &lt;/a&gt; 하에서 컴파일되기 때문에 일반 클래스에서 경고를 생성하는 인식되지 않은 이스케이프는 여기에서 치명적인 오류이며 이러한 클래스 요소의 다른 모든 경고는 물론 현재 re'strict &lt;code&gt;re 'strict'&lt;/code&gt; 외부에서 경고하지 않는 일부 사례입니다. . 예를 들어 당신은 말할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="e618c1116f848d64cf69ade37db078db462072bd" translate="yes" xml:space="preserve">
          <source>Because this function operates at the byte level, and because of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the needle and the haystack are strings with the same UTF-8ness, but not if the UTF-8ness differs.</source>
          <target state="translated">이 함수는 바이트 수준에서 작동하고 UTF-8 (또는 UTF-EBCDIC)의 고유 한 특성으로 인해 needle과 haystack이 모두 동일한 UTF-8ness를 가진 문자열이면 제대로 작동합니다. UTF-8ness는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">이 함수는 mktemp ()를 사용하기 때문에 경쟁 조건이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">이 정보는 perl 실행 파일 자체에 저장되지 않기 때문에 정보가 정보에 액세스하는 데 사용되는 실제 perl 바이너리와 관련이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">이것은 광범위하게 개방 된 인터페이스이므로 pragma (컴파일러 지시문)도 이런 방식으로 구현됩니다. 현재 구현 된 pragma는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="872c328b526f9b9864d2cfe0b4165fd06ef13624" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Some of the currently implemented pragmas are:</source>
          <target state="translated">이것은 개방형 인터페이스이기 때문에 pragma (컴파일러 지시문)도 이런 방식으로 구현됩니다. 현재 구현 된 pragma 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">이 연산자는 할당 가능한 결과를 생성하므로 괄호없이 할당을 사용하면 문제가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">이렇게하면 원거리에서의 작업이 촉진되므로이 반 직관적 인 동작은 향후 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">스레드 생성 및 스레드 결합은 다른 컨텍스트에서 발생할 수 있으므로 컨텍스트를 스레드의 진입 점 함수에 명시 적으로 지정하는 것이 바람직 할 수 있습니다. 이것은 첫 번째 인수로 해시 참조와 함께 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">변수 참조는 항상 '$', '@'또는 '%'로 시작하기 때문에 &quot;예약 된&quot;단어는 실제로 변수 이름과 관련하여 예약되지 않습니다. 그들</target>
        </trans-unit>
        <trans-unit id="cf7852aa0f7da3fa109ef4464da14b644fe19dd6" translate="yes" xml:space="preserve">
          <source>Because various errors may only be detected by close() (e.g. buffering could allow the &lt;code&gt;print&lt;/code&gt; in this example to return true even when the disk is full), it is dangerous to ignore its result. So when it happens implicitly, perl will signal errors by warning.</source>
          <target state="translated">다양한 오류는 close ()에 의해서만 감지 될 수 있기 때문에 (예 : 버퍼링은 디스크가 꽉 찼을 때도이 예제 에서 &lt;code&gt;print&lt;/code&gt; 가 참을 반환 하도록 허용 할 수 있습니다 ), 그 결과를 무시하는 것은 위험합니다. 따라서 암시 적으로 발생하면 perl은 경고로 오류 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">우리는 이제 반환 값에 관심이 있기 때문에</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">SV를 사용하여 전화하기 때문에</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">sv_2mortal () 호출을 통해 임시 값을 만들었으므로 Perl 스택을 정리하고 필사자 SV를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">G_DISCARD를 지정 했으므로 반환 된 값을 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">경우이므로 &lt;code&gt;autochomp&lt;/code&gt; 가 비활성화되어, &lt;code&gt;$a[10]&lt;/code&gt; 로 다시 읽어 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (또는 기록 분리기 스트링이 무엇이든).</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">기존 &lt;b&gt;stdout&lt;/b&gt; 을 다른 곳 으로 옮겼 기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">파일을 자르는 이와 같은 것을 사용하고 있기 때문에</target>
        </trans-unit>
        <trans-unit id="230b0b84c4580dce513ede6c977fdc5dbaffa5e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10, setting &lt;code&gt;$*&lt;/code&gt; to a true value globally enabled multi-line matching within a string. This relique from the past lost its special meaning in 5.10. Use of this variable will be a fatal error in Perl 5.30, freeing the variable up for a future special meaning.</source>
          <target state="translated">Perl 5.10 이전에는 &lt;code&gt;$*&lt;/code&gt; 를 true 값으로 설정하여 문자열 내에서 여러 줄 일치를 전역 적으로 활성화했습니다. 과거로부터의이 relique는 5.10에서 특별한 의미를 잃었습니다. 이 변수를 사용하면 Perl 5.30에서 치명적인 오류가 발생하여 향후 특별한 의미를 위해 변수를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">Perl 5.10.0 및 5.8.8 이전에는 외부 명령을 실행할 때 PERL5SHELL이 오염 검사되지 않았습니다. Windows에서 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 인트 모드로 실행할 때 $ ENV {PERL5SHELL} 을 명시 적으로 설정하거나 삭제하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ebab29b2af9a7a7c7ceefc18fae2257d84323d02" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some, but not all errors:</source>
          <target state="translated">Perl 5.14 이전에는 지역화 된 변수를 복원하기 전에 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 대한 할당이 발생했습니다. 즉, 코드가 이전 버전에서 실행 되려면 일부 오류를 마스킹하려면 임시가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">Perl 5.14 이전에는 지역화 된 변수를 복원하기 전에 &lt;code&gt;$@&lt;/code&gt; 할당 했습니다. 즉, 이전 버전에서 코드를 실행하려면 모든 오류는 아니지만 일부를 숨기려면 임시가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">Perl 5.14 이전에는 과부하와 tie ()의 관계가 깨졌습니다. 과부하가 발생했거나</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">Perl 5.18 이전에는 &lt;code&gt;given(EXPR)&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="8ed431b288a3361b742578011935581f2edfcced" translate="yes" xml:space="preserve">
          <source>Before Perl 5.28, the returned values are unreliable for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; locale constants.</source>
          <target state="translated">Perl 5.28 이전에는 리턴 된 값이 &lt;code&gt;RADIXCHAR&lt;/code&gt; 및 &lt;code&gt;THOUSEP&lt;/code&gt; 로케일 상수에 대해 신뢰할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0ba6dd90f594f9b5d19255a91f0ae4487b358318" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6 이전에는 &lt;code&gt;*FH&lt;/code&gt; 또는 &lt;code&gt;\*FH&lt;/code&gt; 표기법 을 사용해야했습니다 . 이들은 &quot;typeglobs&quot; 입니다. 자세한 내용 &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;은 perldata의 &quot;Typeglobs 및 Filehandles&quot;&lt;/a&gt; , 특히 perlsub의 &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6 이전에는 &lt;code&gt;*FH&lt;/code&gt; 또는 &lt;code&gt;\*FH&lt;/code&gt; 표기법 을 사용해야했습니다 . 이것들은 &quot;typeglobs&quot; 입니다. 자세한 정보 &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;는 perldata의 Typeglobs 및 Filehandles&lt;/a&gt; , 특히 &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub의 Pass by Reference&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Perl 5.8.0 이전에는 Perl 코드를 설치하여 두 가지 위험에 노출 된 신호를 처리합니다. 먼저, 거의 재진입 할 ​​수있는 시스템 라이브러리 기능이 거의 없습니다. Perl이 malloc (3) 또는 printf (3)와 같은 하나의 함수를 실행하는 동안 신호가 중단되고 신호 처리기가 동일한 함수를 다시 호출하면 예측할 수없는 동작 (종종 코어 덤프)이 발생할 수 있습니다. 둘째, Perl 자체가 가장 낮은 수준으로 재진입되는 것은 아닙니다. Perl이 자체 내부 데이터 구조를 변경하는 동안 신호가 Perl을 중단하면 예측할 수없는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0 이전 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 사용을 사용 하여 현재 블록 또는 파일의 조작이 유니 코드를 인식 함을 선언했습니다. 이 모델은 잘못되었거나 적어도 어색한 것으로 밝혀졌습니다. &quot;유니 코드&quot;는 이제 작업에 첨부되지 않고 데이터와 함께 전달됩니다. Perl v5.8.0부터는 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야&lt;/a&gt; 하는 경우가 하나만 남아 있습니다. Perl 스크립트 자체가 UTF-8로 인코딩 된 경우 식별자 이름과 문자열 및 정규식 리터럴에서 UTF-8을 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 말하십시오 . 레거시 8 비트 데이터가 포함 된 스크립트가 작동하지 않기 때문에 이것이 기본값이 아닙니다. &lt;a href=&quot;utf8&quot;&gt;utf8을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fa99c9f82e7be9fceb5a0c188011fae1cb7cad5" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;use utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;use utf8&lt;/code&gt;. This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0 이전 &lt;code&gt;use utf8&lt;/code&gt; 사용을 사용 하여 현재 블록 또는 파일의 작업이 유니 코드를 인식 함을 선언했습니다. 이 모델은 틀렸거나 적어도 어색한 것으로 밝혀졌습니다. 이제 &quot;유니 코드 성&quot;이 작업에 연결되는 대신 데이터와 함께 전달됩니다. Perl v5.8.0부터는 명시적인 &lt;code&gt;use utf8&lt;/code&gt; 이 필요한 경우가 하나만 남아 있습니다. Perl 스크립트 자체가 UTF-8로 인코딩 된 경우 식별자 이름과 문자열 및 정규식 리터럴에 UTF-8을 사용할 수 있습니다. &lt;code&gt;use utf8&lt;/code&gt; 이라고 말함으로써 . 레거시 8 비트 데이터가 포함 된 스크립트는 손상 될 수 있으므로 기본값이 아닙니다. &lt;a href=&quot;utf8&quot;&gt;utf8을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">유니 코드 이전에는 대부분의 인코딩에서 각 문자를 인코딩하는 데 8 비트 (1 바이트)가 사용되었습니다. 따라서 문자는 바이트 였고 바이트는 문자였으며 256 자 이하의 문자 만 가능했습니다. 이 섹션 제목의 &quot;바이트 의미&quot;는이 동작을 나타냅니다. &quot;바이트&quot;와 &quot;문자&quot;를 구분할 필요가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="98f333eb7b1048c01de83e53fdf2f8f76121657f" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="translated">유니 코드 이전에는 문자가 바이트 였을 때 Perl은 ASCII로 정의 된 128 개의 문자, 코드 포인트 0에서 127까지만 알고있었습니다 (Under &lt;a href=&quot;perllocale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt; 제외 ). 이로 인해 코드 포인트 128 ~ 255가 할당되지 않은 상태로 남았으며 프로그램이 원하는 모든 용도에 사용할 수 있습니다. 그들이 가진 유일한 의미는 그들의 서수이며, 음수가 아닌 문자 클래스의 구성원이 아닙니다. 예를 들어 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 것으로 간주되지 않지만 모두 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">유니 코드 이전에는 문자가 바이트 일 때 문자가 ASCII였으며 Perl은 ASCII로 정의 된 128 개의 문자 (0에서 127까지의 코드 포인트 만 알고 있음 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 제외 ))를 알고있었습니다 . 그것은 코드 포인트 128에서 255를 할당되지 않은 채로 두었고, 프로그램이 원하는 어떤 용도로든 사용할 수 있습니다. 그들이 가진 유일한 의미는 그들의 서수이며, 음이 아닌 문자 클래스의 멤버가 아닙니다. 예를 들어, &lt;code&gt;\w&lt;/code&gt; 와 일치하는 것으로 간주되지는 않지만 모두 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">명령이 실행되기 전에 또는 예기치 않은 오류가 발생하면 &lt;code&gt;code()&lt;/code&gt; 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 반환 하고 message () 는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">무엇보다 먼저 테스트 계획이 필요합니다. 이것은 기본적으로 조기 실패로부터 보호하기 위해 스크립트가 몇 개의 테스트를 실행할지 선언합니다.</target>
        </trans-unit>
        <trans-unit id="62bd9b6df52b51e065387fd43e36061f890b0944" translate="yes" xml:space="preserve">
          <source>Before calling copy() or move() on a filehandle, the caller should close or flush() the file to avoid writes being lost. Note that this is the case even for move(), because it may actually copy the file, depending on the OS-specific implementation, and the underlying filesystem(s).</source>
          <target state="translated">파일 핸들에서 copy () 또는 move ()를 호출하기 전에 호출자는 쓰기 손실을 방지하기 위해 파일을 닫거나 플러시 ()해야합니다. 이는 OS 별 구현 및 기본 파일 시스템에 따라 실제로 파일을 복사 할 수 있으므로 move ()의 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">IBM C 컴파일러에 패치를 설치하기 전에 운영 체제의 패치 레벨을 알아야합니다. IBM의 명령 'oslevel'은 기본을 표시하지만 항상 완전한 것은 아닙니다 (이 예에서는 oslevel은 4.3.NULL을 표시하지만 시스템은 대부분 4.3을 실행합니다).</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">perl5.6 이전에는 이전 코드에서 볼 수있는 다양한 글로브 관용구를 처리해야했습니다.</target>
        </trans-unit>
        <trans-unit id="cb7ffbda991b922f283aad1fac8b7fea6f1f3918" translate="yes" xml:space="preserve">
          <source>Before pushing</source>
          <target state="translated">밀기 전에</target>
        </trans-unit>
        <trans-unit id="84ceb0c5361b0c57292563baaff9c21803203fbb" translate="yes" xml:space="preserve">
          <source>Before pushing any change to a maint version, make sure you've satisfied the steps in &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;Committing to blead&quot;&lt;/a&gt; above.</source>
          <target state="translated">메인 트 버전에 변경 사항을 적용하기 전에 위의 &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;커밋하기&quot;에&lt;/a&gt; 있는 단계를 만족했는지 확인하십시오 . ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">Perl의 릴리스 5 이전에는 모든 참조가 기호 여야했기 때문에 복잡한 데이터 구조를 표현하기가 어려웠으며 심지어 기호 테이블 항목 대신 변수를 참조하기도 어려웠습니다. Perl은 이제 변수에 대한 기호 참조를보다 쉽게 ​​사용할 수있을뿐 아니라 모든 데이터 또는 코드에 대한 &quot;하드&quot;참조를 가질 수 있습니다. 모든 스칼라는 어려운 참조를 보유 할 수 있습니다. 배열과 해시는 스칼라를 포함하므로 이제 배열 배열, 해시 배열, 배열 해시, 함수 해시 배열 등을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">버그를 제출하기 전에 해당 패키지의 설치 지시 사항에 따라 쉘에서 Perl 모듈 패키지를 빌드하는 일반적인 방법이 여전히 환경에서 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">종료하기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;filter_add&lt;/code&gt; 를 호출하여 필터를 명시 적으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c19a9bcc3d0fce58bd4d9d25f82f4cb8c5d35503" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;import&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt;.</source>
          <target state="translated">종료하기 전에 &lt;code&gt;import&lt;/code&gt; 함수는 &lt;code&gt;filter_add&lt;/code&gt; 를 호출하여 명시 적으로 필터를 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Perl 인터프리터는 Perl 스크립트를 실행하기 전에 파싱 및 컴파일을 위해 파일에서 메모리로 먼저 읽어야합니다. 해당 스크립트 자체에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 문 이있는 다른 스크립트가 포함 된 경우 해당 스크립트 각각을 해당 파일에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6081a0bc2c6ca5d40e9bce0501b5e221be236ae" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Perl 인터프리터가 Perl 스크립트를 실행하려면 먼저 파싱 및 컴파일을 위해 파일에서 메모리로 읽어야합니다. 해당 스크립트 자체에 &lt;code&gt;use&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문 이있는 다른 스크립트가 포함 된 경우 각 스크립트도 해당 파일에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">Perl에서 유니 코드 지원을 도입하기 전에 &lt;code&gt;eq&lt;/code&gt; 연산자는 두 스칼라로 표시되는 문자열을 비교했습니다. Perl 5.8부터 &lt;code&gt;eq&lt;/code&gt; 는 두 문자열을 동시에 고려하여 비교합니다.</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">어휘 경고를 도입하기 전에 Perl에는 필수 및 선택의 두 가지 경고 클래스가있었습니다.</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">코드 스크랩을 시작하기 전에 미리해야 할 것이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">더 나아 가기 전에 디버거를 종료하는 방법을 알고 싶을 것입니다 . 단어 'quit'또는 'exit'이 아닌 ' &lt;b&gt;q&lt;/b&gt; ' 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="10af6d27d8d05a680d682b1087a82d6e520c2fff" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; section below.</source>
          <target state="translated">XS를 작성하기 전에 아래 &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; 섹션을 읽으 십시오.</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">XS를 작성하기 전에 읽어 &lt;a href=&quot;#CAVEATS&quot;&gt;주의 사항의&lt;/a&gt; 아래 부분을.</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">버그 보고서 게시를 고려하기 전에 토론을 통해 토론 포럼에 메시지를 게시하여 발생한 문제가 알려진 문제인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">계속하기 전에 변수의 정렬 순서를 참고하십시오. 일반적으로, &lt;code&gt;$_&lt;/code&gt; 와 &lt;code&gt;@_&lt;/code&gt; 는 맨 위로 이동 하지만 먼저 변수를 대소 문자를 구분하지 않고 거의 어휘 순서대로 나열합니다 ( &lt;code&gt;${^UNICODE}&lt;/code&gt; 또는 &lt;code&gt;$^T&lt;/code&gt; 에서와 같이 &lt;code&gt;{&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 선행 단어 무시 ) 더미의. 식별자가 동일한 변수의 경우 스칼라, 배열, 해시 및 베어 워드 순서로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e90a6f007e6fb64dd92c6079f36a3d06c252dda3" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt;), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">계속하기 전에 변수의 정렬 순서를 확인하십시오. 일반적으로 &lt;code&gt;$_&lt;/code&gt; 및 &lt;code&gt;@_&lt;/code&gt; 가 맨 위로 이동 하더라도 대소 문자를 구분하지 않고 거의 사전 순서로 변수를 나열합니다 ( &lt;code&gt;${^UNICODE}&lt;/code&gt; 또는 &lt;code&gt;$^T&lt;/code&gt; 에서와 같이 &lt;code&gt;{&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 선행 단어 무시 ). 더미의. 동일한 식별자를 가진 변수의 경우 스칼라, 배열, 해시 및 베어 워드의 순서로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">두 개의 해시를 병합하기로 결정하기 전에 두 해시에 동일한 키가 포함되어 있고 원래 해시를 그대로 두려면 어떻게해야하는지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">다른 작업을 수행하기 전에 Perl이 코드의 문제 영역에 대해 알려주도록하여 스스로 도울 수 있습니다. 경고와 제한을 설정하면 문제가 너무 커지기 전에 많은 문제를 해결할 수 있습니다. 당신은 이들에 대한 자세한 내용을 찾을 수 있습니다 &lt;a href=&quot;strict&quot;&gt;엄격한&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">이를 수행하기 전에 먼저 &lt;code&gt;resolve_alias()&lt;/code&gt; 사용하여 별명이 존재하지 않는지 확인하십시오.이 경우 표준 이름이 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fa55498f41c7cd4663e8d59ae7b91ebb05c3bad" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt;, which returns the canonical name thereof. For example:</source>
          <target state="translated">이를 수행하기 전에 먼저 정규 이름을 반환하는 &lt;code&gt;resolve_alias()&lt;/code&gt; 사용하여 별칭이 존재하지 않는지 확인합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 문서의 나머지 부분으로 먼저 들어가기 전에 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 문서를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">당황하기 전에 많은 사람들이 명령 줄 도구 및 기타 시작에 민감한 코드에 &lt;code&gt;Moose&lt;/code&gt; 를 사용한다는 것을 알고 있습니다. 시작 속도가 걱정되기 전에 &lt;code&gt;Moose&lt;/code&gt; 를 먼저 사용해 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">시작하기 전에</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">시작하기 전에 몇 가지 사항을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">시작하기 전에 Perl 분배가 추출 된 최상위 디렉토리에있는 README 파일을 살펴 봐야합니다. 이 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">시작하기 전에 Perl 배포가 추출 된 최상위 디렉토리에있는 README 파일을 살펴 봐야합니다. 이 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">원격 서버에서 &lt;code&gt;FILE&lt;/code&gt; 이라는 파일 검색을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">초보자 참고 사항 : 예 2에서 위의 &lt;code&gt;$columns&lt;/code&gt; 로컬 네임 스페이스로 가져 와서 로컬로 설정합니다. 예 3에서 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 는 가져 오지 않고 자체 네임 스페이스에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">초보자는 종종 변수 이름에 변수 이름이 포함되기를 원한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Perl 5.12부터 Perl은 아직 구현하지 않은 코드의 자리 표시 자로 줄임표 &quot; &lt;code&gt;...&lt;/code&gt; &quot;를 허용합니다 . 구현되지 않은 명령문 인이 줄임표는 이진 flip-flop &lt;code&gt;...&lt;/code&gt; 연산자 와 혼동해서는 안됩니다 . 하나는 설명이고 다른 하나는 연산자입니다. (펄은 보통 연산자 나 문장을 원하는지 알 수 있기 때문에 혼동하지 않으며, 예외는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="dc88deeacfc5c23c60a84d0e355d8d08bad0853c" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt;&quot;, as a placeholder for code that you haven't implemented yet. When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt;:</source>
          <target state="translated">Perl 5.12부터 Perl은 아직 구현하지 않은 코드의 자리 표시 자로 줄임표 &quot; &lt;code&gt;...&lt;/code&gt; &quot;를 허용합니다 . Perl 5.12 이상에서 줄임표 문이 발견되면 오류없이이를 구문 분석하지만 실제로 실행을 시도해야하는 경우 Perl은 &lt;code&gt;Unimplemented&lt;/code&gt; 텍스트와 함께 예외를 throw합니다 .</target>
        </trans-unit>
        <trans-unit id="90c724bcc9cdece1aeab2aab45c2518eb7791435" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.28, multi-threaded locale operation is supported on systems that implement either the POSIX 2008 or Windows-specific thread-safe locale operations. Many modern systems, such as various Unix variants and Darwin do have this.</source>
          <target state="translated">Perl 5.28부터 다중 스레드 로케일 작업은 POSIX 2008 또는 Windows 관련 스레드 안전 로케일 작업을 구현하는 시스템에서 지원됩니다. 다양한 Unix 변형 및 Darwin과 같은 많은 최신 시스템에는이 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a346d69c5ac7465ea021c968ddc77fd7f137feb" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;&quot;Using References&quot;&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0부터 참조를 사용하기위한 접미사 구문을 사용할 수 있습니다. &lt;a href=&quot;#Using-References&quot;&gt;&quot;참조 사용&quot;에&lt;/a&gt; 설명 된대로 작동 하지만 접두사시길 대신 접두사시길 및 별표가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0부터 참조 사용을위한 접미사 구문을 사용할 수 있습니다. &lt;a href=&quot;#Using-References&quot;&gt;참조 사용에&lt;/a&gt; 설명 된대로 작동 하지만 접두사 sigil 대신 접두사 sigil-and-star가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">v5.22.0부터 참조 연산자를 할당 할 수 있습니다. 왼쪽에서 참조되는 변수 이름이 오른쪽에서 참조되는 항목의 별칭이되도록 앨리어싱 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ffa0956923ab92c4c7492c5469e046b41154fb80" translate="yes" xml:space="preserve">
          <source>Beginning in v5.26.0, the referencing operator can come after &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;local&lt;/code&gt;. This syntax must be enabled with &lt;code&gt;use feature 'declared_refs'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">v5.26.0부터 참조 연산자는 &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; , &lt;code&gt;our&lt;/code&gt; 또는 &lt;code&gt;local&lt;/code&gt; 뒤에 올 수 있습니다 . 이 구문은 &lt;code&gt;use feature 'declared_refs'&lt;/code&gt; 을 사용 하여 활성화해야합니다 . 실험적이며 &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; 적용 되지 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">HP-UX 11.00부터 HP-UX에서 컴파일 된 프로그램은 LP64 프로그래밍 환경 (LP64는 Long 및 Pointer의 너비가 64 비트임을 의미 함)을 이용할 수 있으며 스칼라 변수는 2 ^ 32보다 큰 숫자를 완전하게 보유 할 수 있습니다. 정도. Perl은 모든 HP-UX 11.xx에서 5.8.1 이후 64 비트 모드에서 일관되고 안정적인 것으로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">HP-UX 버전 10.20부터 2GB (2 ^ 31 바이트)보다 큰 파일을 작성하고 조작 할 수 있습니다. 이 작업을 수행하는 세 가지 방법이 있습니다. 이러한 방법 중 Perl에 대한 가장 좋은 방법은 -Duselargefiles 플래그를 사용하여 컴파일하는 것입니다. 이로 인해 Perl은 32 비트가 아닌 64 비트의 구조와 함수를 사용하여 컴파일됩니다. (이 기능은 HP의 ANSI C 컴파일러에서만 작동합니다. gcc를 사용하여 Perl을 컴파일하려면 64 비트 연산을 지원하는 컴파일러 버전을 가져와야합니다. 위의 위치는 위를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Perl 5.10.0부터는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 변수를 선언 할 수 있습니다 . 그래도 작동하려면 &lt;code&gt;feature&lt;/code&gt; pragma를 사용하거나 하나의 라이너에서 &lt;code&gt;-E&lt;/code&gt; 를 사용하여 해당 기능을 미리 활성화해야합니다 ( &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조 ). Perl 5.16부터 &lt;code&gt;CORE::state&lt;/code&gt; 양식에는 &lt;code&gt;feature&lt;/code&gt; pragma가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="043ad372200ab11184230c8b464cbbec604d0f73" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;state&lt;/code&gt; keyword in place of &lt;code&gt;my&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">펄 5.10.0을 시작으로, 당신은에 변수를 선언 할 수 있습니다 &lt;code&gt;state&lt;/code&gt; 대신에 키워드를 &lt;code&gt;my&lt;/code&gt; . 그래도 작동하려면 &lt;code&gt;feature&lt;/code&gt; pragma를 사용하거나 한 줄에 &lt;code&gt;-E&lt;/code&gt; 를 사용하여 해당 기능을 미리 활성화해야합니다 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ). Perl 5.16부터 &lt;code&gt;CORE::state&lt;/code&gt; 양식 &lt;code&gt;feature&lt;/code&gt; pragma 기능이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18부터는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 개인 서브 루틴을 선언 할 수 있습니다 . 상태 변수와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드는 아래에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 이상.</target>
        </trans-unit>
        <trans-unit id="4f40c1f7eb582d4b15076061b6d0a8e085b355dc" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. As with state variables, the &lt;code&gt;state&lt;/code&gt; keyword is only available under &lt;code&gt;use feature 'state'&lt;/code&gt; or &lt;code&gt;use 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18부터 &lt;code&gt;my&lt;/code&gt; 또는 &lt;code&gt;state&lt;/code&gt; 로 프라이빗 서브 루틴을 선언 할 수 있습니다 . 상태 변수와 마찬가지로 &lt;code&gt;state&lt;/code&gt; 키워드는 &lt;code&gt;use feature 'state'&lt;/code&gt; 을 사용 하거나 &lt;code&gt;use 5.010&lt;/code&gt; 이상을 사용 하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb06f268b9e85c6ee8127ae9f07256660624d8e4" translate="yes" xml:space="preserve">
          <source>Beginning with Perl version 5.26, a much simpler and cleaner way to write indented here documents has been added to the language: the tilde (~) modifier. See &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Perl 버전 5.26부터 여기에 들여 쓰기 된 문서를 작성하는 훨씬 더 간단하고 깔끔한 방법이 언어에 추가되었습니다. 물결표 (~) 수정 자입니다. 자세한 내용 &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;은 perlop의 &quot;Indented Here-docs&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0부터는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 변수를 사용 하여 한 번만 초기화되는 어휘를 가질 수 있습니다 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="62b599a702a0e45efa83ae9abd2c72ac9e40e2f7" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;state&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0부터는 &lt;code&gt;state&lt;/code&gt; 변수를 사용 하여 한 번만 초기화되는 어휘를 가질 수도 있습니다 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">버전 5.004부터 다음 기능도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1a2270a454451ac22b568bca58999ca2a57b3c" translate="yes" xml:space="preserve">
          <source>Beginning/End of line positions</source>
          <target state="translated">줄 위치의 시작 / 끝</target>
        </trans-unit>
        <trans-unit id="f2dfcf5f267b41370cad897910ad80d037ac22ab" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt;, except that &lt;code&gt;name&lt;/code&gt; is nul-terminated rather than of counted length, and no flags are set. (This means that &lt;code&gt;name&lt;/code&gt; is always interpreted as Latin-1.)</source>
          <target state="translated">&lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt; 와 같이 작동하지만 &lt;code&gt;name&lt;/code&gt; 이 계산 된 길이가 아닌 널로 끝나고 플래그가 설정되지 않는다는 점이 다릅니다 . (이는 &lt;code&gt;name&lt;/code&gt; 이 항상 Latin-1로 해석 됨을 의미합니다 .)</target>
        </trans-unit>
        <trans-unit id="5b6fd5b0516beaff8d8429855f694694659eb195" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait(2)&lt;/a&gt; on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;. Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">시스템에서 &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait (2)&lt;/a&gt; 처럼 동작 합니다. 자식 프로세스가 종료 될 때까지 기다렸다가 죽은 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. 상태는 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;및 &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt; . 반환 값이 &lt;code&gt;-1&lt;/code&gt; 이면&lt;a href=&quot;perlipc&quot;&gt;perlipc에&lt;/a&gt; 설명 된대로 자식 프로세스가 자동으로 수확됨을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb78858d773149c7141146370197d2f530d8902f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">시스템에서 wait (2)처럼 작동합니다. 자식 프로세스가 종료 될 때까지 대기하고 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . &lt;code&gt;-1&lt;/code&gt; 의 리턴 값은 &lt;a href=&quot;../perlipc&quot;&gt;perlipc에&lt;/a&gt; 설명 된대로 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">시스템에서 wait (2)처럼 작동합니다. 자식 프로세스가 종료 될 때까지 대기하고 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . &lt;code&gt;-1&lt;/code&gt; 의 리턴 값은 &lt;a href=&quot;perlipc&quot;&gt;perlipc에&lt;/a&gt; 설명 된대로 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="756aaec531bd197c8baf40355b6e7560606340ee" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt; 과 동일하게 작동합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 함수는 실제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; 과 동일하게 동작합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 이 함수는 실제로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3b8ea26eb4d496c3c9598880a77b0e504f2a647" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt; 와 동일하게 작동합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 함수는 실제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; 와 동일하게 작동합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 이 함수는 실제로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">분기 된 유사 프로세스에서 다른 Perl 기능의 동작</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">이 기능의 동작은 시스템 구현에 따라 크게 다릅니다. 예를 들어 일반적으로 시스템이 파일 시스템 경계를 넘어서도 파일 시스템 경계에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">버전 2.11 이후의 동작</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">무대 뒤에서</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">장면 뒤에서 &lt;code&gt;globmap&lt;/code&gt; 함수는 기존 파일 이름과 일치시키기 위해 파일 glob를 조합 한 다음 새 파일 이름을 만드는 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">Perl에 특화된이 기능은 시간이 지남에 따라 발전했습니다. 현재 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">기계적인 프로세스 pl2pm은 방탄이 아닙니다. 변환 된 코드는 특히 패키지 문을주의 깊게 검사해야합니다. 새 .pm 파일이 작동 할 때까지 원본 .pl 파일을 삭제하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="7f0407ad618a0bd51d559ec6185eae8ed67ffedb" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. If you do just &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt;, the filehandle &lt;code&gt;$A&lt;/code&gt; will not have the same file descriptor as &lt;code&gt;$B&lt;/code&gt;, and therefore &lt;code&gt;flock($A)&lt;/code&gt; will not &lt;code&gt;flock($B)&lt;/code&gt; nor vice versa. But with &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt;, the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; 을&lt;/a&gt; 사용한 잠금과 같이 파일 설명자에 의존하는 경우 파일 핸들에 대한 간결함은 유용합니다 (간결함 외에도) . 당신이 경우에 단지 &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt; , 파일 핸들 &lt;code&gt;$A&lt;/code&gt; 같은 파일 기술자가 없습니다 &lt;code&gt;$B&lt;/code&gt; , 따라서 &lt;code&gt;flock($A)&lt;/code&gt; 하지 않을 것이다 &lt;code&gt;flock($B)&lt;/code&gt; 도 그 반대의 경우도 마찬가지입니다. 그러나 &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt; 을 사용하면 파일 핸들이 동일한 기본 시스템 파일 설명자를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">예를 들어 flock ()을 사용한 잠금과 같이 파일 디스크립터에 의존하는 경우 파일 처리에 대해 parsimonious 인 것이 유용합니다 (parsimonious 외에). 당신은 그냥 할 경우 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , 파일 핸들 A는 B와 같은 파일 설명이 없습니다, 따라서 반대 무리하지 않을 것이다 (A)를 무리 (B)도 그. 그러나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; 을 사용하면 파일 핸들은 동일한 기본 시스템 파일 설명자를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">예를 들어 flock ()을 사용한 잠금과 같이 파일 디스크립터에 의존하는 경우 파일 처리에 대해 parsimonious 인 것이 유용합니다 (parsimonious 외에). 당신은 그냥 할 경우 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , 파일 핸들 A는 B와 같은 파일 설명이 없습니다, 따라서 반대 무리하지 않을 것이다 (A)를 무리 (B)도 그. 그러나 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; 을 사용하면 파일 핸들은 동일한 기본 시스템 파일 설명자를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">단어 완성에 실패하면 벨 소리가납니다.</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">아래는 글로브 맵의 몇 가지 예입니다</target>
        </trans-unit>
        <trans-unit id="8b537b36a224ab3855e5388cf5af4a7324861d08" translate="yes" xml:space="preserve">
          <source>Below comes a verbose discussion of these flags. Note that a &quot;codeset&quot; is simply an abstract set of character-codepoint pairs, while an encoding takes those codepoint numbers and</source>
          <target state="translated">다음은 이러한 플래그에 대한 자세한 설명입니다. &quot;코드 세트&quot;는 단순히 문자-코드 포인트 쌍의 추상 세트 인 반면 인코딩은 이러한 코드 포인트 번호와</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">아래는</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">다음은 특정 요구 사항에 따라 결정을 내리는 데 도움이 될 수있는 주석이 포함 된 몇 가지 프레임 워크 목록입니다. 먼저 문서를 읽고 관련 메일 링리스트 나 IRC 채널에 질문하십시오.</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">아래는 Perl이 현재 사용하지 않는 유니 코드 데이터베이스의 파일 목록과 그 목적에 대한 간단한 설명입니다. 파일 이름 중 일부는 이름의 처음 8 자만 중요한 파일 시스템에서 유사한 이름의 파일과 구별 될 수 있도록 유니 코드가 사용하는 이름에서 단축되었습니다.</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">아래는 사용 가능한 방법 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">다음은 유효한 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">다음은 사용 가능한 유틸리티가 어떤 체계에 어떤 순서로 사용되는지에 대한 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="19c0c3663e2dbbc758912a1313a649285c7d7339" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="translated">아래는 &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt; 에서 가져온 &lt;code&gt;Apache::GZip&lt;/code&gt; 이라는 mod_perl Apache 압축 모듈 입니다 .</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">다음은 이름 변경을 수행 할 수있는 스크립트 구현입니다 (오류 사례는 생략 됨).</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">아래는 &lt;code&gt;gzreadline&lt;/code&gt; 을 사용하는 스크립트입니다 . 그것은 매우 간단한 구현</target>
        </trans-unit>
        <trans-unit id="dc35361ae28756350bcadeedc93fea7a717eda63" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt;. It implements a very simple</source>
          <target state="translated">아래는 &lt;code&gt;gzreadline&lt;/code&gt; 을 사용하는 스크립트입니다 . 그것은 매우 간단한 구현</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">다음은 &lt;code&gt;globmap&lt;/code&gt; 을 사용하여 소스 및 대상 파일 이름을 결정 하는 간단한 &quot;이름 바꾸기&quot;스크립트입니다 .</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">아래는 매크로를 사용하는 예제 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">아래는 이 필터를 사용 하는 예제 프로그램 &lt;code&gt;cpp_test&lt;/code&gt; 입니다. 특정 라인을 쉽게 참조 할 수 있도록 라인 번호가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b304a8ff907f2b83be9fd715d004cdf9a531f584" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt;, which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">아래는 이 필터를 사용 하는 예제 프로그램 &lt;code&gt;cpp_test&lt;/code&gt; 입니다. 특정 라인을 쉽게 참조 할 수 있도록 라인 번호가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">아래는 제어 동사 &lt;code&gt;(*FAIL)&lt;/code&gt; 를 나타내는 한 가지 예일 뿐이며, &lt;code&gt;(*F)&lt;/code&gt; 로 약어로 표시 될 수 있습니다 . 이것이 정규 표현식에 삽입되면 패턴과 문자열이 일치하지 않는 것처럼 실패하게됩니다. 정규 표현식 처리는 &quot;정상적인&quot;실패 후에와 같이 계속 진행되므로 문자열의 다음 위치 또는 다른 대안이 시도됩니다. 일치하지 않으면 캡처 그룹이 보존되지 않거나 결과가 생성되지 않으므로이를 임베디드 코드와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dfcb4bdf0851e123d1da057d122d3eaadab35bd" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt;, which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt;. If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">아래는 &lt;code&gt;(*F)&lt;/code&gt; 로 축약 될 수 있는 제어 동사 &lt;code&gt;(*FAIL)&lt;/code&gt; 를 보여주는 한 가지 예 입니다. 이것이 정규 표현식에 삽입되면 패턴과 문자열이 일치하지 않는 것처럼 실패하게됩니다. 정규식의 처리는 &quot;정상적인&quot;실패 후에도 계속됩니다. 예를 들어 문자열의 다음 위치 나 다른 대안이 시도됩니다. 일치에 실패하면 캡처 그룹이 유지되거나 결과가 생성되지 않으므로이를 포함 된 코드와 함께 사용해야 할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">다음은 내 컴퓨터에서 구성을 재현하기 위해 수행 할 작업의 샘플입니다. 에</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">아래는 &lt;code&gt;LimitOutput&lt;/code&gt; 사용 방법을 보여주는 일반적인 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="b7690c7bdc8f256fde6341fc38dc8edeb2bb2bde" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;LimitOutput&lt;/code&gt; 을 사용하는 방법을 보여주는 일반적인 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">벤 틸리</target>
        </trans-unit>
        <trans-unit id="e231863abeba6b63203ae12c8ced1dd832bf1e27" translate="yes" xml:space="preserve">
          <source>Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</source>
          <target state="translated">Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">벤치 마크-Perl 코드의 벤치 마크 실행 시간</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">벤치 마크 객체</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">벤치 마크는 Exporter의 과정을 제외하고 다른 클래스에서 상속받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl 코드의 벤치 마크 실행 시간</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">벤자민 홀츠 만 (Benjamin Holzman)은 묶인 변수 지원에 기여했고, 앤드류 포드 (Andrew Ford)는 해시의 정식 순서에 기여했으며, Gisle Aas는 펄 내부와 관련하여 광산에 대한 오해를 수정했으며, 대신에 객체를 세는 것만으로 출력 스트림에서 &quot;태그&quot;의 방출을 최적화했습니다. 태그 지정 (버전 0.6부터는 Storable 이미지의 이진 비 호환성으로 이어짐-이전 이미지는 여전히 올바르게 이해 됨). Murray Nesbitt는 Storable thread-safe를 만들었습니다. Marc Lehmann은 묶음 품목 지원에 대한 과부하 및 참조를 추가했습니다. Benjamin Holzman은 오버로드 된 클래스의 성능 향상을 추가했습니다. 이 법안을 발표 한 Grant Street Group에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="97adf5b0f3e282d4b4c33cdd224636f12368207c" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill. Reini Urban took over maintainance from p5p, and added security fixes and huge object support.</source>
          <target state="translated">Benjamin Holzman은 묶인 변수 지원에 기여했고 Andrew Ford는 해시의 표준 순서에 기여했으며 Gisle Aas는 펄 내부에 대한 몇 가지 오해를 수정했으며 단순히 개체를 계산하여 출력 스트림에서 &quot;태그&quot;의 방출을 최적화했습니다. 태그 지정 (버전 0.6부터 저장 가능 이미지에 대한 이진 비 호환성 발생-물론 이전 이미지는 여전히 적절하게 이해 됨). Murray Nesbitt는 Storable을 스레드로부터 안전하게 만들었습니다. Marc Lehmann은 연결된 항목 지원에 대한 오버로딩 및 참조를 추가했습니다. Benjamin Holzman은 오버로드 된 클래스에 대한 성능 향상을 추가했습니다. 법안을 제시 한 Grant Street Group에게 감사드립니다. Reini Urban은 p5p에서 유지 관리를 인수하고 보안 수정 및 대규모 개체 지원을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ce63cc3b1fa95fc4c74ca1cad11a70531a58a69f" translate="yes" xml:space="preserve">
          <source>Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</source>
          <target state="translated">Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB는 파일 이름 대신 NULL (즉, C에서 &lt;code&gt;(char *)0&lt;/code&gt; ) 을 사용하여 메모리 내 데이터베이스를 만들 수 있습니다 . &lt;b&gt;DB_File&lt;/b&gt; 은 NULL 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용 하여이 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b44f74f0eaff4623bb4f32a3bc9a77a5a293d873" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;undef&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB를 사용 하면 파일 이름 대신 NULL (즉, C 의 &lt;code&gt;(char *)0&lt;/code&gt; ) 을 사용하여 메모리 내 데이터베이스를 만들 수 있습니다 . &lt;b&gt;DB_File&lt;/b&gt; 은 NULL 대신 &lt;code&gt;undef&lt;/code&gt; 를 사용 하여이 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB는 여러 데이터베이스 형식에 대한 일관된 인터페이스를 제공하는 C 라이브러리입니다. &lt;b&gt;DB_File&lt;/b&gt; 은 현재 Berkeley DB에서 지원하는 세 가지 데이터베이스 유형 모두에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DB는 dbopen () 함수를 사용하여 데이터베이스를 열거 나 만듭니다. dbopen ()의 C 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">Cygwin에 BerkeleyDB를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">import () 및 AUTOLOAD () 외에도 몇 가지 다른 메소드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eaf9c16309e0e030fec414bcececf296c9fd80c" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#Metacharacters&quot;&gt;&lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/a&gt;, Perl defines the following zero-width assertions:</source>
          <target state="translated">&lt;a href=&quot;#Metacharacters&quot;&gt; &lt;code&gt;&quot;^&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;$&quot;&lt;/code&gt; &lt;/a&gt; 외에도 Perl은 다음과 같은 제로 너비 어설 션을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9ba06ebae884c8bbbcddfe487f2f73c4f3cbe88a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;&quot;decode&quot;&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;&quot;encode&quot;&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">&lt;a href=&quot;#decode&quot;&gt;&quot;디코딩&quot;&lt;/a&gt; 및 &lt;a href=&quot;#encode&quot;&gt;&quot;인코딩&quot;&lt;/a&gt; 외에 다른 방법도 사용할 수 있습니다. 예를 들어, &lt;code&gt;name()&lt;/code&gt; 은 인코딩 객체의 정식 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">&lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 및 &lt;a href=&quot;#encode&quot;&gt;인코딩&lt;/a&gt; 외에도 다른 방법도 사용할 수 있습니다. 예를 들어 &lt;code&gt;name()&lt;/code&gt; 은 인코딩 객체의 정식 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c3f604e026977938c21e0b164fdc42c9575f5038" translate="yes" xml:space="preserve">
          <source>Besides being a metacharacter, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; is an example of a &quot;character class&quot;, something that can match any single character of a given set of them. In its case, the set is just about all possible characters. Perl predefines several character classes besides the &lt;code&gt;&quot;.&quot;&lt;/code&gt;; there is a separate reference page about just these, &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">메타 문자 외에 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 는 &quot;문자 클래스&quot;의 예이며, 주어진 세트의 단일 문자와 일치 할 수 있습니다. 이 경우 세트는 가능한 모든 문자입니다. Perl은 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 외에 여러 문자 클래스를 미리 정의합니다 . ; 이것에 대한 별도의 참조 페이지 인 &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="212828aa9819262a5dba3e04d7db334b30f00e96" translate="yes" xml:space="preserve">
          <source>Besides being able to say &lt;code&gt;\p{Name=...}&lt;/code&gt;, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt;, &lt;code&gt;charnames::vianame()&lt;/code&gt;, and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;use charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">&lt;code&gt;\p{Name=...}&lt;/code&gt; 라고 말할 수있을 뿐 아니라 Name 및 Name_Aliases 속성은 큰 따옴표로 묶인 문자열 및 정규식에서 &lt;code&gt;\N{}&lt;/code&gt; 보간을 통해 액세스 할 수 있습니다 . 및 함수 &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; 및 &lt;code&gt;charnames::string_vianame()&lt;/code&gt; ( &lt;code&gt;use charnames ();&lt;/code&gt; 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">기존 XS 코드를 확인하는 것 외에도 &lt;code&gt;--api-info&lt;/code&gt; 명령 줄 스위치를 사용하여 스크립트를 사용하여 다양한 API 호출에 대한 호환성 정보를 검색 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">다른 많은 테스트 외에도 시스템에서 찾은 모든 로캘을 테스트하여 POSIX 표준을 준수하는지 확인합니다. 오류가있는 경우 모든 로케일이 모든 테스트를 통과 한 출력의 끝에 거의 실패한 이유와 이유에 대한 요약이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">크로스 컴파일러와 나머지 툴체인을 PATH에 넣는 것 외에도 -Dsysroot를 통해 Configure로 전달할 QNX_TARGET 변수도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">이 해시를 hashref 속성 &lt;code&gt;name2path&lt;/code&gt; 및 &lt;code&gt;path2name&lt;/code&gt; 으로 저장하는 것 외에도이 함수를 호출하면 이러한 해시 참조 도 반환됩니다. 목록 컨텍스트에서 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; 의 리턴 값은 목록 &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; 입니다. 스칼라 컨텍스트에서 리턴 값은 &lt;code&gt;\%name2path&lt;/code&gt; 입니다. 또는 void 컨텍스트에서 이것을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68eae0359edab349209444648a1ef905188cfbd0" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt;, calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt;. In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt;. Or you can just call this in void context.</source>
          <target state="translated">이 해시를 해시 참조 속성 &lt;code&gt;name2path&lt;/code&gt; 및 &lt;code&gt;path2name&lt;/code&gt; 으로 저장하는 것 외에도이 함수를 호출하면 이러한 해시 참조가 반환됩니다. 목록 컨텍스트에서 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; 의 반환 값은 목록 &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; 입니다. 스칼라 컨텍스트에서 반환 값은 &lt;code&gt;\%name2path&lt;/code&gt; 입니다. 또는 공백 컨텍스트에서 이것을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6db52c932112966f376fe8b88f42b909a1d77f94" translate="yes" xml:space="preserve">
          <source>Besides taking away the special meaning of a metacharacter, a prefixed backslash changes some letter and digit characters away from matching just themselves to instead have special meaning. These are called &quot;escape sequences&quot;, and all such are described in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;. A backslash sequence (of a letter or digit) that doesn't currently have special meaning to Perl will raise a warning if warnings are enabled, as those are reserved for potential future use.</source>
          <target state="translated">메타 문자의 특별한 의미를 제거하는 것 외에도 접두사가 붙은 백 슬래시는 일부 문자와 숫자 문자가 자신과 일치하지 않고 대신 특별한 의미를 갖도록 변경합니다. 이를 &quot;이스케이프 시퀀스&quot;라고하며 이러한 모든 내용은 &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash에&lt;/a&gt; 설명되어 있습니다 . 현재 Perl에 특별한 의미가없는 백 슬래시 시퀀스 (문자 또는 숫자)는 경고가 활성화 된 경우 경고를 발생시킵니다. 경고는 향후 사용을 위해 예약되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">게다가 &lt;code&gt;$|&lt;/code&gt; 특수 변수, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용하여 파일 핸들에 버퍼링되지 않은 : &lt;code&gt;:unix&lt;/code&gt; 레이어 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28b7e372985d4c31ff927994e7e34211eb124b71" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;binmode&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; 외에 특수 변수 인 경우 &lt;code&gt;binmode&lt;/code&gt; 를 사용하여 파일 핸들에 버퍼링되지 않은 : &lt;code&gt;:unix&lt;/code&gt; 레이어 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">위에서 논의한 NBSP 문자 이외에도, 구현 자들은 라틴어 -1에서 &quot; &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; 하이픈&quot;문자로 알려진 &quot;소프트 하이픈&quot;문자, 즉 &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = E &amp;lt;0xAD&amp;gt;에 다른 &quot;특수&quot;문자가 있음을 상기 시킵니다 = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). 이 문자는 선택적인 하이픈 포인트를 나타냅니다. 즉, 일반적으로 아무것도 렌더링하지 않지만 포맷터가 해당 지점에서 단어를 분리하면 &quot;-&quot;로 렌더링 될 수 있습니다. 포드 포맷터는 적절하게 다음 중 하나를 수행해야합니다. 1) 동일한 의미를 가진 코드 (예 : RTF에서 &quot;\-&quot;)로 코드를 렌더링합니다. 2) 포맷터가이 문자를 다음과 같이 이해한다고 기대합니다. 또는 3) 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="fb9d8bd5854ba8b088687eedfedb188dbc42540c" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt;). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">위에서 설명한 NBSP 문자 외에도 구현자는 Latin-1의 다른 &quot;특수&quot;문자, &quot;임의 하이픈&quot;이라고도하는 &quot;소프트 하이픈&quot;문자 (예 : &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). 이 문자는 선택적 하이픈 포인트를 나타냅니다. 즉, 일반적으로 아무것도 렌더링하지 않지만 포맷터가 해당 지점에서 단어를 분리하면 &quot;-&quot;로 렌더링 될 수 있습니다. 포드 포맷터는 해당하는 경우 다음 중 하나를 수행해야합니다. 1) 동일한 의미 (예 : RTF의 &quot;\-&quot;)를 가진 코드로이를 렌더링하고, 2) 포맷터가이 문자를 다음과 같이 이해할 것으로 예상하여 전달합니다. 또는 3) 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">일반 배열 인덱스 루핑 외에도 &lt;code&gt;for&lt;/code&gt; 는 다른 많은 흥미로운 응용 프로그램에 적합합니다. 다음은 대화식 파일 설명자에서 파일 끝을 명시 적으로 테스트하여 프로그램이 중단 된 것처럼 보이는 경우 발생하는 문제를 피하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">명백한 문서 외에도 소스 코드가 도움이 될 수 있습니다. 참고 문헌 사용에 대한 일부 병리학 적 예는</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">Pod :: Man은 명백한 포드 변환 외에도 func (), func (3) 및 $ foo 또는 @bar와 같은 간단한 변수 참조의 형식을 지정하므로 코드 이스케이프를 사용할 필요가 없습니다. 그러나 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 와 같은 복잡한 표현 은 여전히 ​​탈출해야합니다. 또한 하이픈으로 사용되지 않는 대시를 대시로 변환하고, 이와 같이 긴 대시를 만듭니다. 적절한 em 대시로, &quot;페어링 된 따옴표&quot;를 수정하고, C ++을 올바르게 보이게하고, 이중 밑줄 사이에 약간의 공간을두고 ALLCAPS를 만듭니다. &lt;b&gt;troff&lt;/b&gt; 의 작은 비트 이며 * roff가 특별한 것으로 취급하지 않는 것을 피합니다.</target>
        </trans-unit>
        <trans-unit id="5bb351a96d9e7856a11971d899903843a4ce13f1" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">명백한 pod 변환 외에도 Pod :: Man, 따라서 pod2man은 func (), func (n) 및 $ foo 또는 @bar와 같은 간단한 변수 참조 형식을 처리하므로 코드 이스케이프를 사용할 필요가 없습니다. ; 하지만 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 와 같은 복잡한 표현 은 여전히 ​​이스케이프해야합니다. 또한 하이픈으로 사용되지 않는 대시를 엔 대시로 변환하고, 이와 같은 긴 대시를 적절한 전각 대시로 만들고, &quot;쌍으로 된 따옴표&quot;를 수정하고, 기타 troff 관련 조정을 처리합니다. 전체 정보는 &lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">Pod :: Man이라는 명백한 포드 변환 외에도 pod2man은 func (), func (n) 및 $ foo 또는 @bar와 같은 간단한 변수 참조의 형식을 지정하므로 코드 이스케이프를 사용할 필요가 없습니다. ; 그러나 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 와 같은 복잡한 표현 은 여전히 ​​탈출해야합니다. 또한 하이픈으로 사용되지 않는 대시를 대시로 변환하고, 이와 같이 긴 대시를 적절한 em 대시로 만들고, &quot;페어링 된 따옴표&quot;를 수정하며, 다른 몇 가지 troff 관련 조정을 처리합니다. 자세한 내용은 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">포드 파서는 잘 알려진 &quot;E &amp;lt;&quot;및 &quot;E&quot;코드 외에 &quot;/&quot;(고체, 슬래시) 및 &quot;&quot;에 대한 &quot;E &amp;lt;sol&amp;gt;&quot;을 이해해야합니다. &quot;|&quot;에 대한 E &amp;lt;verbar&amp;gt; &quot; (세로 막대, 파이프). 포드 파서는 또한 &quot;E &amp;lt;lchevron&amp;gt;&quot;및 &quot;E &amp;lt;rchevron&amp;gt;&quot;을 문자 171 및 187의 레거시 코드로 이해해야합니다. 각도 인용 부호 &quot;=&quot;오른쪽 포인팅 길레 &quot;. (이들은 &quot;&amp;lt;&amp;lt;&quot;및 &quot;&amp;gt;&amp;gt;&quot;처럼 보이지 않으며, 이제 HTML / XHTML 코드 &quot;E &amp;lt;laquo&amp;gt;&quot;및 &quot;E &amp;lt;raquo&amp;gt;&quot;로 표시되는 것이 바람직합니다.)</target>
        </trans-unit>
        <trans-unit id="860a34f94eb6573e4bc9c4a64ff033a99b23eda5" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">이 외에도 위에서 언급 한 모든 유니 코드 문자 속성 (Perl에서 내부 용으로 표시된 속성 제외)은 &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;Unicode :: UCD의 &quot;prop_invlist ()&quot;&lt;/a&gt; 에서도 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">이 외에도 위에서 언급 한 모든 유니 코드 문자 속성 (Perl에서 내부 용으로 표시 한 속성 제외 &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;)은 Unicode :: UCD의 prop_invlist ()를&lt;/a&gt; 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">출력을위한 전체 문구 외에도 언어에 의존하는 것은 메소드 나 어휘집 항목으로 Projname :: L10N :: en_us 클래스에 넣어야합니다. 이는 위의 &quot;각 어휘집에있는 항목&quot;섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ab1d9532fa300263b037333b93fafef9210c8c57" translate="yes" xml:space="preserve">
          <source>Besides, I don't know how to write the damned things.</source>
          <target state="translated">게다가 나는 저주받은 것들을 쓰는 법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">새 모듈을 만드는 모범 사례.</target>
        </trans-unit>
        <trans-unit id="ae28545952ad516171bc8541be8a3d6e7dcf583f" translate="yes" xml:space="preserve">
          <source>Better diagnostics capabilities.</source>
          <target state="translated">더 나은 진단 기능.</target>
        </trans-unit>
        <trans-unit id="80d4f16c5fc7da807c79c20a2575508b93d90392" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;unpairs&lt;/code&gt;, a higher-order list function can be used to operate on the pairs as single scalars; such as the following near-equivalents of the other &lt;code&gt;pair*&lt;/code&gt; higher-order functions:</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 과 쌍 &lt;code&gt;unpairs&lt;/code&gt; 사이 에서 고차 목록 함수를 사용하여 쌍을 단일 스칼라로 작동 할 수 있습니다. 다음과 같은 다른 &lt;code&gt;pair*&lt;/code&gt; 고차 함수 와 거의 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Mac OS X 10.3 &quot;Panther&quot;와 10.6 &quot;Snow Leopard&quot;사이에서 'Command Line Tools'번들은 'unix tools'라고하며 일반적으로 Mac OS 설치 DVD와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 와 형식 문자 사이에서 형식 해석을 제어하는 ​​몇 가지 추가 속성을 지정할 수 있습니다. 순서대로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">다음과 같은 복잡한 표현 순서도주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6cfef1757642ae2cc2b58e48199cf1ffe99563dc" translate="yes" xml:space="preserve">
          <source>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</source>
          <target state="translated">결과를 캐스팅 할 수 있으므로 전체 표현식을 캐스팅하지 않도록주의하세요.이 시점에서 너무 늦습니다.</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">전체 표현식을 단순하게 &quot;캐스팅&quot;한다는 점에주의하십시오. 이렇게하면 이미 계산 된 결과 만 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="993aa75891c2224a1f9c297f58bf1ffa758e779f" translate="yes" xml:space="preserve">
          <source>Beware of the &quot;else syndrome&quot;:</source>
          <target state="translated">&quot;else 증후군&quot;에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="1a9c3aa0cee4b1c15e1e5a6a65e3ca3cde192e4e" translate="yes" xml:space="preserve">
          <source>Beware of using &lt;code&gt;&quot;$&quot;&lt;/code&gt; to indicate to match the end of the string. It can too easily be interpreted as being a punctuation variable, like &lt;code&gt;$/&lt;/code&gt;.</source>
          <target state="translated">문자열의 끝과 일치 함을 나타 내기 위해 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 를 사용하는 것에주의하십시오 . &lt;code&gt;$/&lt;/code&gt; 와 같은 구두점 변수로 너무 쉽게 해석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">주의 사항 :</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 와 &lt;code&gt;\E&lt;/code&gt; 사이에 리터럴 백 슬래시 (보간 된 변수가 아닌)를 넣으면 큰 따옴표 백 슬래시 보간으로 인해 결과가 혼동 될 수 있습니다. 만약 너라면</target>
        </trans-unit>
        <trans-unit id="eebfc88db53433dbd95a0208b9c35bedb078dc7e" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;, double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 와 &lt;code&gt;\E&lt;/code&gt; 사이에 리터럴 백 슬래시 (보간 변수 내부가 아님)를 넣으면 큰 따옴표 백 슬래시 보간으로 인해 혼란스러운 결과가 발생할 수 있습니다. 만약 너라면</target>
        </trans-unit>
        <trans-unit id="5349c42e3fc571db11577ff5f6cb8d88af8429b8" translate="yes" xml:space="preserve">
          <source>Beware that in a UTF-8 locale, anything you pass to this function must be in UTF-8; and when not in a UTF-8 locale, anything passed must not be UTF-8 encoded.</source>
          <target state="translated">UTF-8 로케일에서이 함수에 전달하는 모든 것은 UTF-8이어야합니다. UTF-8 로케일이 아닌 경우 전달되는 모든 항목은 UTF-8로 인코딩되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">일부 명령 셸은 명령 줄 길이에 제한을 둘 수 있습니다. 필요한 보간 후 문자열이이 제한을 초과하지 않아야합니다. 특정 환경에 대한 자세한 내용은 플랫폼 별 릴리스 노트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cd8d5856a80822f4c1d90c9c02e95de943bc843" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그와는 달리 조심 &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수로 패턴을 고려하지 않습니다. &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 비교 .</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">그와는 달리 조심 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 첫 번째 인수로 패턴을 고려하지 않습니다. &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">그와는 달리 조심 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 첫 번째 인수로 패턴을 고려하지 않습니다. &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">주의 :이 기능은 아직 완전히 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">주의 :이 목록은 완전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">주의 :이 함수가 반환 된 후 &lt;code&gt;ptr&lt;/code&gt; 과 SvPVX_const (sv)는 더 이상 동일한 데이터 청크를 참조하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">유니 코드 코드 포인트를 넘어</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">테스트를 넘어</target>
        </trans-unit>
        <trans-unit id="16881dc1b286f9fd89e3c68a1307509ea4208790" translate="yes" xml:space="preserve">
          <source>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</source>
          <target state="translated">API 호출 및 관련 상수에 대한 원시 액세스 외에도이 모듈은 스마트 버퍼 할당 및 반환 코드 변환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">그 도움 외에도 urllist config 매개 변수는 귀하의 것입니다. 당신은 자유롭게 사이트를 추가하고 제거 할 수 있습니다. 최신 사이트, 대역폭, 안정성 등을 보유하고 있으며 토폴로지에 가장 가까운 사이트를 찾아야합니다. 어떤 사람들은 빠른 다운로드를 선호하고 다른 사람들은 최신 다운로드, 다른 사람들은 안정성을 선호합니다. 어떤 순서로 시도할지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">그 외에도 가장 간단한 디버거는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능입니다. 프로그램을 실행할 때이 값을 사용하여 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cc8c0bdbbf061aa1132ad0db52bd5ab409c1d5c4" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;print&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">그 외에도 가장 간단한 디버거는 &lt;code&gt;print&lt;/code&gt; 기능입니다. 프로그램을 실행할 때이를 사용하여 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">그 외에도 몇 가지 사항을 고려하여 가장 적합한 것을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">일반적인 Perl 프로그램을 더 빠르거나 작게 만드는 일반적인 방법 외에도 CGI 프로그램에는 추가 문제가 있습니다. 초당 여러 번 실행될 수 있습니다. 실행될 때마다 다시 컴파일해야하고 종종 메가 바이트 이상의 시스템 메모리를 할당해야하므로 이는 킬러가 될 수 있습니다. 프로세스 시작 오버 헤드가 병목 현상이 발생하기 때문에 C로 컴파일 &lt;b&gt;해도 도움이되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">많은 버전의 Unix 버전에서 스크립트처럼 유연한 시스템에 특별한 권한을 부여함으로써 발생하는 명백한 문제 외에도 set-id 스크립트는 처음부터 안전하지 않습니다. 문제는 커널의 경쟁 조건입니다. 커널이 파일을 열어 어떤 인터프리터를 실행할지와 (현재 set-id) 인터프리터가 돌아와서 파일을 해석하기 위해 파일을 다시 열 때 사이에, 특히 심볼릭 링크가있는 경우 문제의 파일이 변경되었을 수 있습니다 당신의 시스템.</target>
        </trans-unit>
        <trans-unit id="cfa5b349eaf3622485b4949d5b4c1629b7136aa6" translate="yes" xml:space="preserve">
          <source>BhkDISABLE</source>
          <target state="translated">BhkDISABLE</target>
        </trans-unit>
        <trans-unit id="097eaa76fb990cb3c085617a09bb68f2d2dd28d0" translate="yes" xml:space="preserve">
          <source>BhkENABLE</source>
          <target state="translated">BhkENABLE</target>
        </trans-unit>
        <trans-unit id="56657a5c49e88295c9fdbd426498620306255970" translate="yes" xml:space="preserve">
          <source>BhkENTRY</source>
          <target state="translated">BhkENTRY</target>
        </trans-unit>
        <trans-unit id="eed78c8324c929e21a7725f018dc13f233941d2d" translate="yes" xml:space="preserve">
          <source>BhkENTRY_set</source>
          <target state="translated">BhkENTRY_set</target>
        </trans-unit>
        <trans-unit id="6303b515a179b4880dfa9b0c5bdeef24554d4d0d" translate="yes" xml:space="preserve">
          <source>BhkFLAGS</source>
          <target state="translated">BhkFLAGS</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="c81d74ec4f5774b83707b81c40273f9931cc6799" translate="yes" xml:space="preserve">
          <source>BidiCharacterTest.txt</source>
          <target state="translated">BidiCharacterTest.txt</target>
        </trans-unit>
        <trans-unit id="69ecda50c93df6838e91e9e521a5ea42b19e7e09" translate="yes" xml:space="preserve">
          <source>BidiTest.txt</source>
          <target state="translated">BidiTest.txt</target>
        </trans-unit>
        <trans-unit id="603c926318562657586c9e1146fc9dbe3c25c988" translate="yes" xml:space="preserve">
          <source>Bidirectional Character Types</source>
          <target state="translated">양방향 문자 유형</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">다른 프로세스와의 양방향 통신</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">자신과의 양방향 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="de1698114af4355c5ccd60424049fded636df6a2" translate="yes" xml:space="preserve">
          <source>Big5</source>
          <target state="translated">Big5</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigInt의 bcmp () 루틴은 현재 Nadef가 비교에 포함되었음을 알리기 위해 undef를 리턴합니다. 그러나 과부하 코드는이를 1 또는 ''로 바꾸므로 &lt;code&gt;NaN != NaN&lt;/code&gt; 과 같은 연산은 잘못된 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">더 큰 숫자</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;!=&quot;&lt;/code&gt; 은 왼쪽 인수가 숫자와 오른쪽 인수가 아닌 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 는 논리적 의미에서 반환 값이 무시된다는 점을 제외하고는 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">비파괴 대체 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ) 또는 음역 ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; )이있는 이진 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="669b5730a4de160e3201236f63831582ab97b4ad" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;s///r&lt;/code&gt;) or transliteration (&lt;code&gt;y///r&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">비파괴 대체 ( &lt;code&gt;s///r&lt;/code&gt; ) 또는 음역 ( &lt;code&gt;y///r&lt;/code&gt; )이있는 바이너리 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">이항 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 모듈로 연산자로, 두 번째 인수와 관련하여 첫 번째 인수의 나머지 부분을 계산합니다. 정수 피연산자 감안 &lt;code&gt;$m&lt;/code&gt; 과 &lt;code&gt;$n&lt;/code&gt; : 만약 &lt;code&gt;$n&lt;/code&gt; 이어서, 긍정적 인 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 최대 다중 &lt;code&gt;$n&lt;/code&gt; 보다 작거나 같 &lt;code&gt;$m&lt;/code&gt; . 경우 &lt;code&gt;$n&lt;/code&gt; 이어서, 부정적 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 작은 복수 &lt;code&gt;$n&lt;/code&gt; 이상인 &lt;code&gt;$m&lt;/code&gt; (즉, 그 결과는보다 적은 수 또는 제로와 동일 함). 피연산자가 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 부동 소수점 값이고 &lt;code&gt;$n&lt;/code&gt; 의 절대 값 ( &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; )이 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 보다 작 으면 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 의 정수 부분 만 조작에 사용됩니다 (참고 : &lt;code&gt;UV_MAX&lt;/code&gt; 부호없는 정수 유형의 최대 값을 의미합니다). 오른쪽 피연산자 (의 절대치 경우 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; )보다 크거나 동일한 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 부동 소수점 나머지 계산 &lt;code&gt;$r&lt;/code&gt; 식에서 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; 여기서 &lt;code&gt;$i&lt;/code&gt; 는 &lt;code&gt;$r&lt;/code&gt; 을 오른쪽 피연산자와 같은 부호로 만드는 특정 정수입니다. &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;되지&lt;/b&gt; 왼쪽 피연산자 &lt;code&gt;$m&lt;/code&gt; C 함수 등 &lt;code&gt;fmod()&lt;/code&gt; ) 이하보다 절대 값 &lt;code&gt;$n&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 범위에 있을 때 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 C 컴파일러에 의해 구현 된대로 모듈로 연산자에 직접 액세스 할 수 있습니다. 이 연산자는 음의 피연산자에 대해 잘 정의되어 있지 않지만 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="41e316d0ff24f3ca1a3464d44861dfcd88d324d8" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt;: If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt;. If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;abs($n)&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;abs($n)&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt;) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt;. Note that when &lt;code&gt;use integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">이진 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 두 번째 인수에 대해 첫 번째 인수의 나눗셈 나머지를 계산하는 모듈로 연산자입니다. 정수 피연산자 감안 &lt;code&gt;$m&lt;/code&gt; 과 &lt;code&gt;$n&lt;/code&gt; : 만약 &lt;code&gt;$n&lt;/code&gt; 이어서, 긍정적 인 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 최대 다중 &lt;code&gt;$n&lt;/code&gt; 보다 작거나 같 &lt;code&gt;$m&lt;/code&gt; . 경우 &lt;code&gt;$n&lt;/code&gt; 이어서, 부정적 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 작은 복수 &lt;code&gt;$n&lt;/code&gt; 이상인 &lt;code&gt;$m&lt;/code&gt; (즉, 그 결과는보다 적은 수 또는 제로와 동일 함). 피연산자 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 부동 소수점 값이고 &lt;code&gt;$n&lt;/code&gt; 의 절대 값 (즉, &lt;code&gt;abs($n)&lt;/code&gt; )이 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 보다 작 으면 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 의 정수 부분 만 연산에 사용됩니다 (참고 : 여기서 &lt;code&gt;UV_MAX&lt;/code&gt; 부호없는 정수 유형의 최대 값을 의미 함). 오른쪽 피연산자 (의 절대치 경우 &lt;code&gt;abs($n)&lt;/code&gt; )보다 크거나 동일한 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 부동 소수점 나머지 계산 &lt;code&gt;$r&lt;/code&gt; 식에서 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; 여기서 &lt;code&gt;$i&lt;/code&gt; 는 &lt;code&gt;$r&lt;/code&gt; 이 오른쪽 피연산자와 같은 부호를 갖도록 하는 특정 정수입니다. &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;되지&lt;/b&gt; 왼쪽 피연산자 &lt;code&gt;$m&lt;/code&gt; C 함수 등 &lt;code&gt;fmod()&lt;/code&gt; ) 이하보다 절대 값 &lt;code&gt;$n&lt;/code&gt; . &lt;code&gt;use integer&lt;/code&gt; 가 범위 내에 있을 때 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 C 컴파일러에 의해 구현 된 모듈로 연산자에 대한 직접 액세스를 제공합니다. 이 연산자는 음수 피연산자에 대해 잘 정의되어 있지 않지만 더 빨리 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a8a326cd0bd8e1d3d414fab02e5019eeeb66d4b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="translated">이진 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 는 비트 단위로 AND 처리 된 피연산자를 반환합니다. 현재 경고가 발생하지 않지만이 연산이 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;정수 산술&quot;&lt;/a&gt; 참조) 나 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열&lt;/a&gt; ( &quot;비트 문자열 연산자&quot; 참조) 이 아닌 피연산자에 대해 수행 될 때 결과가 제대로 정의되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 는 피연산자 AND를 비트 단위로 함께 반환합니다. 현재 경고가 발생하지 않지만 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 ) 또는 비트 열 ( &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 별 문자열 연산자&lt;/a&gt; 참조) 이 아닌 피연산자에서이 작업을 수행 할 때 결과가 제대로 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; 는 단락 논리 AND 연산을 수행합니다. 즉, 왼쪽 피연산자가 false이면 오른쪽 피연산자도 평가되지 않습니다. 스칼라 또는 목록 컨텍스트는 평가되는 경우 오른쪽 피연산자로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">왼쪽 인수가 숫자보다 오른쪽 인수보다 큰 경우 이진수 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b8b841de5eb99d0ccb88b329de6ee433524b771" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="translated">이진 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 은 오른쪽 인수에 지정된 비트 수만큼 오른쪽으로 이동 한 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">이진수 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 는 오른쪽 인수에 의해 지정된 비트 수만큼 오른쪽으로 시프트 된 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 크거나 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">왼쪽 인수가 숫자보다 오른쪽 인수보다 작 으면 이진 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 이 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="699e70a5fa87498319583ad7600759912b343d42" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="translated">이진 &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; 은 오른쪽 인수에 지정된 비트 수만큼 왼쪽으로 이동 한 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">이진수 &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; 는 오른쪽 인수로 지정된 비트 수만큼 왼쪽으로 시프트 된 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작거나 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작은 지, 같은지 또는 큰지에 따라 -1, 0 또는 1을 반환합니다. 플랫폼 이 숫자가 아닌 &lt;code&gt;NaN&lt;/code&gt; 을 숫자 값으로 지원하는 경우 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 와 함께 사용하면 undef가 반환됩니다. &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 무엇이든 ( &lt;code&gt;NaN&lt;/code&gt; 조차도 ) 아니므로 5는 false를 반환합니다. &lt;code&gt;NaN != NaN&lt;/code&gt; 처럼 NaN 은 true를 반환합니다 &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04a45698769168d1350bede297cc638685f279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt;'s (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;==&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt;), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">이진 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 은 왼쪽 인수가 숫자 적으로 오른쪽 인수보다 작은 지, 같은지 또는 큰지에 따라 -1, 0 또는 1을 반환합니다. 플랫폼이 &lt;code&gt;NaN&lt;/code&gt; (숫자가 아님)을 숫자 값으로 지원하는 경우 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 와 함께 사용하면 undef가 반환됩니다. &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 아무것도 ( &lt;code&gt;NaN&lt;/code&gt; 조차도 ) 아니므로이 5 개는 false를 반환합니다. &lt;code&gt;NaN != NaN&lt;/code&gt; 은 &lt;code&gt;NaN !=&lt;/code&gt; 처럼 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 는 두 숫자를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">이항 &lt;code&gt;&quot;**&quot;&lt;/code&gt; 은 지수 연산자입니다. 이 때문에, 더욱 긴밀하게 단항 마이너스보다는 결합 &lt;code&gt;-2**4&lt;/code&gt; 입니다 &lt;code&gt;-(2**4)&lt;/code&gt; ,하지 &lt;code&gt;(-2)**4&lt;/code&gt; . (이것은 실제로 내부에서 두 배로 작동하는 C의 &lt;code&gt;pow(3)&lt;/code&gt; 함수를 사용하여 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="ea1f5488b58109753bdbb42f40a1d426d3469962" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt;, not &lt;code&gt;(-2)**4&lt;/code&gt;. (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">이진 &lt;code&gt;&quot;**&quot;&lt;/code&gt; 는 지수 연산자입니다. 단항 마이너스보다 훨씬 더 단단히 결합하므로 &lt;code&gt;-2**4&lt;/code&gt; 는 &lt;code&gt;(-2)**4&lt;/code&gt; 가 아니라 &lt;code&gt;-(2**4)&lt;/code&gt; 입니다. (이것은 실제로 내부적으로 복식에서 작동하는 C의 &lt;code&gt;pow(3)&lt;/code&gt; 함수를 사용하여 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 두 숫자의 합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">이진 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 은 쉼표 연산자입니다. 스칼라 컨텍스트에서는 왼쪽 인수를 평가하고 해당 값을 버린 다음 오른쪽 인수를 평가하여 해당 값을 반환합니다. 이것은 C의 쉼표 연산자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 두 숫자의 차이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">이진 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 두 개의 문자열을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">이진 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 은 범위 연산자이며 컨텍스트에 따라 실제로 두 개의 다른 연산자입니다. 목록 컨텍스트에서 왼쪽 값에서 오른쪽 값까지 세는 값 목록 (1 씩 증가)을 반환합니다. 왼쪽 값이 오른쪽 값보다 크면 빈 목록을 반환합니다. range 연산자는 &lt;code&gt;foreach (1..10)&lt;/code&gt; 루프 를 작성 하고 배열에서 슬라이스 작업을 수행하는 데 유용 합니다. 현재 구현에서 범위 연산자를 &lt;code&gt;foreach&lt;/code&gt; 루프 에서 표현식으로 사용하면 임시 배열이 작성되지 않지만 이전 버전의 Perl은 다음과 같이 작성할 때 많은 메모리를 소모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 는 두 숫자를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수와 숫자가 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">이항 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 은 스칼라 식을 패턴 일치에 바인딩합니다. 특정 작업 은 기본적으로 &lt;code&gt;$_&lt;/code&gt; 문자열을 검색하거나 수정합니다 . 이 연산자는 다른 문자열에서 이러한 종류의 작업을 수행합니다. 올바른 주장은 검색 패턴, 대체 또는 음역입니다. 왼쪽 인수는 기본 &lt;code&gt;$_&lt;/code&gt; 대신 검색, 대체 또는 음역되어야합니다 . 스칼라 문맥에서 사용될 때, 반환 값은 일반적으로 연산의 성공을 나타냅니다. 예외는 교체 (있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; )과 음역 ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 포함) &lt;code&gt;/r&lt;/code&gt; 원인 (비파괴) 옵션, &lt;b&gt;R을&lt;/b&gt;eturn 값은 대체 결과입니다. 목록 컨텍스트의 동작은 특정 연산자에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like 연산자&lt;/a&gt; 를 참조하고 이러한 연산자를 사용하는 예제는 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79a4495643878d498724e64ed7f89a0f4674d534" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt;. When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;s///&lt;/code&gt;) and transliteration (&lt;code&gt;y///&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">이진 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 는 스칼라 표현식을 패턴 일치에 바인드합니다. 특정 작업 은 기본적으로 &lt;code&gt;$_&lt;/code&gt; 문자열을 검색하거나 수정합니다 . 이 연산자는 이러한 종류의 작업이 다른 문자열에서 작동하도록합니다. 오른쪽 인수는 검색 패턴, 대체 또는 음역입니다. 왼쪽 인수는 기본 &lt;code&gt;$_&lt;/code&gt; 대신 검색, 대체 또는 음역되어야하는 항목입니다 . 스칼라 컨텍스트에서 사용되는 경우 반환 값은 일반적으로 작업의 성공을 나타냅니다. 예외는 &lt;code&gt;/r&lt;/code&gt; (비파괴) 옵션 으로 대체 ( &lt;code&gt;s///&lt;/code&gt; ) 및 음역 ( &lt;code&gt;y///&lt;/code&gt; )이며 , 이로 인해 &lt;b&gt;r&lt;/b&gt;&lt;b&gt;&lt;/b&gt;대체의 결과로 값을 반환합니다. 목록 컨텍스트의 동작은 특정 연산자에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like 연산자&quot;&lt;/a&gt; 를 참조하고 이러한 연산자를 사용하는 예제는 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">이항 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 은 비트 단위로 XOR 된 피연산자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">이항 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 는 두 주변 표현식의 논리적 연결을 반환합니다. 우선 순위가 매우 낮은 것을 제외하고는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 같습니다 . 이것은 단락을 의미합니다. 올바른 표현은 왼쪽 표현이 참인 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 는 왼쪽 인수가 오른쪽 인수보다 작거나 같거나 큰지 여부에 따라 -1, 0 또는 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">이진 &lt;code&gt;&quot;eq&quot;&lt;/code&gt; 는 왼쪽 인수가 문자열과 오른쪽 인수와 같은 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 크거나 같으면 이진 &lt;code&gt;&quot;ge&quot;&lt;/code&gt; 가 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 큰 경우 이진 &lt;code&gt;&quot;gt&quot;&lt;/code&gt; 는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;le&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작거나 같은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 작 으면 이진 &lt;code&gt;&quot;lt&quot;&lt;/code&gt; 가 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열과 오른쪽 인수가 같지 않으면 이진 &lt;code&gt;&quot;ne&quot;&lt;/code&gt; 이 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">이항 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 은 두 주변 표현식의 논리적 분리를 반환합니다. &lt;code&gt;||&lt;/code&gt; 와 같습니다. 우선 순위가 매우 낮습니다. 이것은 제어 흐름에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">이항 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 는 반복 연산자입니다. 스칼라 컨텍스트에서 또는 왼쪽 피연산자가 괄호로 묶이지 않은 경우 오른쪽 피연산자가 지정한 횟수만큼 반복 된 왼쪽 피연산자로 구성된 문자열을 반환합니다. 목록 컨텍스트에서 왼쪽 피연산자가 괄호로 묶이거나 &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; 구성된 목록 인 경우 목록을 반복합니다. 오른쪽 피연산자가 0이거나 음수이면 (음수에 경고 발생) 컨텍스트에 따라 빈 문자열 또는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">이항 &lt;code&gt;&quot;xor&quot;&lt;/code&gt; 는 두 주변 표현식의 배타적 논리합을 반환합니다. 물론 단락 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">이진 &lt;code&gt;&quot;|&quot;&lt;/code&gt; OR 피연산자를 비트 단위로 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">이진 &lt;code&gt;&quot;||&quot;&lt;/code&gt; 단락 논리 OR 연산을 수행합니다. 즉, 왼쪽 피연산자가 true이면 오른쪽 피연산자도 평가되지 않습니다. 스칼라 또는 목록 컨텍스트는 평가되는 경우 오른쪽 피연산자로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">이항 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 는 인수간에 스마트 매치를 수행합니다. 스마트 매칭은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="474b37cbe0d6e0c72ec20c7e955273bab42d36ef" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;isa&lt;/code&gt; evaluates to true when the left argument is an object instance of the class (or a subclass derived from that class) given by the right argument. If the left argument is not defined, not a blessed object instance, nor does not derive from the class given by the right argument, the operator evaluates as false. The right argument may give the class either as a bareword or a scalar expression that yields a string class name:</source>
          <target state="translated">이진 &lt;code&gt;isa&lt;/code&gt; 는 왼쪽 인수가 오른쪽 인수에 의해 제공된 클래스 (또는 해당 클래스에서 파생 된 하위 클래스)의 객체 인스턴스 일 때 참으로 평가됩니다. 왼쪽 인수가 정의되지 않았고 축복 된 개체 인스턴스가 아니거나 오른쪽 인수가 제공하는 클래스에서 파생되지 않은 경우 연산자는 false로 평가됩니다. 오른쪽 인수는 클래스를 베어 워드 또는 문자열 클래스 이름을 생성하는 스칼라 표현식으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47cc7ad1e48a139eed3a38cd085aae1011cbc98f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;x&lt;/code&gt; is the repetition operator. In scalar context, or if the left operand is neither enclosed in parentheses nor a &lt;code&gt;qw//&lt;/code&gt; list, it performs a string repetition. In that case it supplies scalar context to the left operand, and returns a string consisting of the left operand string repeated the number of times specified by the right operand. If the &lt;code&gt;x&lt;/code&gt; is in list context, and the left operand is either enclosed in parentheses or a &lt;code&gt;qw//&lt;/code&gt; list, it performs a list repetition. In that case it supplies list context to the left operand, and returns a list consisting of the left operand list repeated the number of times specified by the right operand. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">이진 &lt;code&gt;x&lt;/code&gt; 는 반복 연산자입니다. 스칼라 컨텍스트에서 또는 왼쪽 피연산자가 괄호 나 &lt;code&gt;qw//&lt;/code&gt; 목록으로 묶여 있지 않으면 문자열 반복을 수행합니다. 이 경우 왼쪽 피연산자에 스칼라 컨텍스트를 제공하고 오른쪽 피연산자가 지정한 횟수만큼 반복되는 왼쪽 피연산자 문자열로 구성된 문자열을 반환합니다. 경우 &lt;code&gt;x&lt;/code&gt; 목록 맥락에서, 왼쪽 피연산자는 중 괄호 또는로 묶여 &lt;code&gt;qw//&lt;/code&gt; 목록, 목록 반복을 수행합니다. 이 경우 왼쪽 피연산자에 목록 컨텍스트를 제공하고 오른쪽 피연산자가 지정한 횟수만큼 반복되는 왼쪽 피연산자 목록으로 구성된 목록을 반환합니다. 오른쪽 피연산자가 0 또는 음수이면 (음수 경고 발생) 컨텍스트에 따라 빈 문자열 또는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">이진 역 호환성; 이 함수는 매크로이지만 &lt;code&gt;Perl_&lt;/code&gt; 구현 (내 보낸)도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">일부 독점 플랫폼에 대한 이진 배포는 &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; 디렉토리 에서 찾을 수 있습니다 . 이들은 표준 배포의 일부가 아니기 때문에 다양한 방식으로 기본 perl 포트와 다를 수 있습니다. 차이점이 무엇인지 보려면 해당 릴리스 노트를 확인해야합니다. 이러한 차이는 긍정적 (예 : perl의 소스 릴리스에서 지원되지 않는 특정 플랫폼의 기능에 대한 확장)이거나 부정적 일 수 있습니다 (예 : perl의 최신 소스 릴리스를 기반으로 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">이진 설치 관리자는 바탕 화면에 유용한 개체가 포함 된 폴더를 만듭니다. 이진 설치 프로그램 작업의 일부 측면을 변경해야하는 경우 파일을 자유롭게 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="b3b1f88d8a58f93a423339c57b3f74f2d820a432" translate="yes" xml:space="preserve">
          <source>Binary number &amp;gt; 0b11111111111111111111111111111111 non-portable</source>
          <target state="translated">이진수&amp;gt; 0b11111111111111111111111111111111 휴대 불가능</target>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">이진 문자열 (바이트 문자열)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">바인딩 연산자</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">매크로에서 여러 명령문을 함께 바인딩</target>
        </trans-unit>
        <trans-unit id="be19add4d0d70fd9e2b19a5940d1ed397561b92a" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind(2)&lt;/a&gt; does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind (2)&lt;/a&gt; 와 마찬가지로 네트워크 주소를 소켓에 바인드 합니다. 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 패킹 된 주소 여야합니다. &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipc의 &quot;소켓 : 클라이언트 / 서버 통신&quot;&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ee51bd7870301b5b50c94bd801894ab927735dc" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;code&gt;bind(2)&lt;/code&gt; does. Returns true if it succeeded, false otherwise. You should provide a packed address of the appropriate type for the socket.</source>
          <target state="translated">&lt;code&gt;bind(2)&lt;/code&gt; 와 마찬가지로 네트워크 주소를 소켓에 바인드 합니다. 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. 소켓에 적합한 유형의 패킹 된 주소를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind (2)와 마찬가지로 네트워크 주소를 소켓에 바인딩합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind (2)와 마찬가지로 네트워크 주소를 소켓에 바인딩합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d4a984a59802112ea9e0afc9140f13f4e5333e8" translate="yes" xml:space="preserve">
          <source>Binmode</source>
          <target state="translated">Binmode</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell, Andrew D. 쓰레드 프로그래밍에 대한 소개. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 : &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; ( 온라인 권장)</target>
        </trans-unit>
        <trans-unit id="36b5cf92c2fb97a05ef7bf770fab59d48c1cb050" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell, Andrew D. 스레드를 사용한 프로그래밍 소개. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 온라인 ( &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf)&lt;/a&gt; (적극 권장)</target>
        </trans-unit>
        <trans-unit id="a110cc2137a88f53fa983eabf18c6a369cdd6cc9" translate="yes" xml:space="preserve">
          <source>Bisecting</source>
          <target state="translated">Bisecting</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">비트 보완 연산자 ~ 및 vec ()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">비트 문자열</target>
        </trans-unit>
        <trans-unit id="ba34e7ebde4a9f60d96348693e30b97a898d1671" translate="yes" xml:space="preserve">
          <source>Bit vector size &amp;gt; 32 non-portable</source>
          <target state="translated">비트 벡터 크기&amp;gt; 32 개 비 휴대용</target>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">비트는 메모리 세계의 원자입니다. 개별 비트에 대한 액세스는 최후의 수단으로 또는 데이터를 처리하는 가장 편리한 방법이기 때문에 사용해야 할 수도 있습니다. 비트 문자열 (비) 패킹은 일련의 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 문자를 포함하는 문자열 과 각각 8 비트 그룹을 포함하는 일련의 바이트 사이를 변환 합니다. 이것은 바이트의 내용이 비트 열로 쓰여질 수있는 두 가지 방법이 있다는 점을 제외하고는 거의 들리는 것처럼 간단합니다. 주석이 달린 바이트를 보자.</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">파일 &lt;b&gt;소유자&lt;/b&gt; 가 다른 사람에 대한 액세스를 허용하거나 허용하지 않도록 설정하거나 설정하지 않은 비트입니다 . 이 플래그 비트는 파일에 대해 물어볼 때 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 내장에서 반환 하는 &lt;b&gt;모드&lt;/b&gt; 워드의 일부입니다 . 유닉스 시스템에서는</target>
        </trans-unit>
        <trans-unit id="aca05ef0109989b493ae0975df5c4747401f63d8" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;stat&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">파일 &lt;b&gt;소유자&lt;/b&gt; 가 다른 사람에 대한 액세스를 허용하거나 허용하지 않기 위해 설정하거나 설정 해제하는 비트입니다 . 이러한 플래그 비트는 파일에 대해 질문 할 때 내장 된 &lt;code&gt;stat&lt;/code&gt; 에 의해 반환되는 &lt;b&gt;모드&lt;/b&gt; 단어의 일부입니다 . Unix 시스템에서는 다음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">모든 크기의 비트 열은 비트 연산자 ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ) 로 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">비트와</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">비트 단위 및 독점 또는</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">비트 문자열 연산자</target>
        </trans-unit>
        <trans-unit id="60dab14d1038a5ab6653c6e814d064d60e1699d8" translate="yes" xml:space="preserve">
          <source>Bitwise methods</source>
          <target state="translated">비트 방식</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="8a7fb7c64ed6d34c679867c6172b911e0f987e0b" translate="yes" xml:space="preserve">
          <source>Bitwise operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 중 비트 연산자</target>
        </trans-unit>
        <trans-unit id="ca6124b539fbe18e72605192e10e84abc660b435" translate="yes" xml:space="preserve">
          <source>Bizarre SvTYPE [%d]</source>
          <target state="translated">특이한 SvTYPE [% d]</target>
        </trans-unit>
        <trans-unit id="6569857bf0d6ff7a8e148a4adb3a9e8ee5c017ec" translate="yes" xml:space="preserve">
          <source>Bizarre copy of %s</source>
          <target state="translated">% s의 이상한 복사본</target>
        </trans-unit>
        <trans-unit id="d97eb984318634f0d968a3f61bf23fd2faf3f45b" translate="yes" xml:space="preserve">
          <source>Bizarre space in item</source>
          <target state="translated">항목의 기괴한 공간</target>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">다른 일을하는 청크 사이에 빈 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">축복받은 참고 문헌과 클래스 개체</target>
        </trans-unit>
        <trans-unit id="68214e18c0b1867aaa68202e63eba7567e9b30a9" translate="yes" xml:space="preserve">
          <source>Blessed objects are not directly representable in JSON, but &lt;code&gt;JSON::PP&lt;/code&gt; allows various ways of handling objects. See &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt;, below, for details.</source>
          <target state="translated">축복받은 객체는 JSON으로 직접 표현할 수 없지만 &lt;code&gt;JSON::PP&lt;/code&gt; 는 객체를 처리하는 다양한 방법을 허용합니다. 자세한 내용은 아래의 &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="79c23f408055d193d91f1b67442a45565695178a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt;). The reference count of the SV is unaffected.</source>
          <target state="translated">SV를 지정된 패키지로 축복합니다. SV는 RV 여야합니다. 패키지는 숨김으로 지정되어야합니다 ( &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt; 참조 ). SV의 참조 횟수는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">지정된 패키지에 SV를 축복합니다. SV는 RV 여야합니다. 패키지는 숨김으로 지정해야합니다 ( &lt;code&gt;gv_stashpv()&lt;/code&gt; 참조 ). SV의 참조 카운트는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="548174d374d3a6d330e0dce28420c09b6c8a9390" translate="yes" xml:space="preserve">
          <source>Blessing a shared item after it has been nested in another shared item does not propagate the blessing to the shared reference:</source>
          <target state="translated">다른 공유 항목에 중첩 된 후 공유 항목을 축복해도 공유 참조에 축복이 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">맹목적으로 전달되는 va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">가변적으로 매크로를 사용하여 맹목적으로</target>
        </trans-unit>
        <trans-unit id="82dd2cdf36f9436d89f404454654ad3e53fd428d" translate="yes" xml:space="preserve">
          <source>Block</source>
          <target state="translated">Block</target>
        </trans-unit>
        <trans-unit id="3df7eee072ad8f186abf1b2d2565ea2787bb93b4" translate="yes" xml:space="preserve">
          <source>Block eval</source>
          <target state="translated">블록 평가</target>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">블록 이름은 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; 또는 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; 와 같이 복합 형식으로 일치합니다 . 대부분의 다른 속성과 달리, 일부 블록 이름 만 유니 코드로 정의 된 짧은 이름을 갖습니다. 그러나 Perl은 (약간, 더 이상 권장하지 않음) 지름길을 제공합니다. 예를 들어 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; 또는 &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; 와 같이 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75cda6989df1a079fcf560c9e780003cd931ab30" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Unlike most other properties, only a few block names have a Unicode-defined short name.</source>
          <target state="translated">블록 이름은 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; 또는 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; 와 같은 복합 형식으로 일치합니다 . 대부분의 다른 속성과 달리 몇 개의 블록 이름에만 유니 코드로 정의 된 짧은 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="bbaa0510707f42633a5b2810cc339df2222d09f5" translate="yes" xml:space="preserve">
          <source>Blocking =&amp;gt; BOOL</source>
          <target state="translated">차단 =&amp;gt; BOOL</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="91c2278276bfdf926da91f0d87d6f0041b36f310" translate="yes" xml:space="preserve">
          <source>Blocks versus Scripts</source>
          <target state="translated">블록 대 스크립트</target>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">보고서 본문. 명령 행 또는 &lt;b&gt;-f&lt;/b&gt; 파일에 포함되지 않은 경우 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b26c9b3704fe7427bfc6aa57886af38bc8fd15" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the report.</source>
          <target state="translated">보고서 본문입니다. 명령 줄 또는 &lt;b&gt;-f&lt;/b&gt; 파일에 포함되지 않은 경우 보고서를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)에는이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)에는이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="feeb11edec497ca4f54c665a95df5130b4c829b2" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 너비 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)은이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="302306e8a29ac5f2d9ddbda14d6dbb86f08c19c5" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="translated">고정 너비 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)은이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 체 버전. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 체 버전. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4826fec0f048131f813dc8e60e9509d935802a38" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 너비 글꼴의 굵은 버전입니다. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="21be102197e929754c4d027624958a11458b8256" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="translated">고정 너비 글꼴의 굵은 버전입니다. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">부울 이 매개 변수가 true이면 필수 모듈 (또는 올바른 버전)이 없으면 치명적입니다. &lt;code&gt;perl Makefile.PL&lt;/code&gt; 은 사용자에게 누락 된 종속성을 알려주는 대신 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa02db7b0e1536fcc3f6de1b2a7dcf01412dc0c6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;die&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">Bool. 이 매개 변수가 true 인 경우 필요한 모듈 (또는 올바른 버전)이 없으면 치명적입니다. &lt;code&gt;perl Makefile.PL&lt;/code&gt; 은 단순히 사용자에게 누락 된 종속성을 알리는 대신 &lt;code&gt;die&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">부울 이 매개 변수가 true이면 전제 조건이 stdout으로 인쇄되고 MakeMaker가 종료됩니다. 출력 형식은 평가 가능한 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="09eca632f0dfa4476bacf2f878b87c41a27eb16f" translate="yes" xml:space="preserve">
          <source>Boolean context</source>
          <target state="translated">부울 컨텍스트</target>
        </trans-unit>
        <trans-unit id="02eefeb78b1690ec4b9fb5543382dba69c8c96d9" translate="yes" xml:space="preserve">
          <source>Boolean logic</source>
          <target state="translated">부울 논리</target>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">부울 메소드</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">부울 연산자</target>
        </trans-unit>
        <trans-unit id="55aef5e3c5e0b75d499308ca6279e82ab808182b" translate="yes" xml:space="preserve">
          <source>Boolean operators &lt;code&gt;is_zero()&lt;/code&gt;, &lt;code&gt;is_one()&lt;/code&gt;, &lt;code&gt;is_inf()&lt;/code&gt;, etc. return true or false.</source>
          <target state="translated">부울 연산자 &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_inf()&lt;/code&gt; 등은 true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">부울 옵션 :</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">부울 값. false 인 경우 테스트가 실행되는 동안 표시되는 &lt;code&gt;X/Y&lt;/code&gt; 테스트 카운트를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">부울을 만드는 규칙을 포함해야한다고 MakeMaker에 알려주는 부울입니다. 이것은 MakeMaker에 의해 스위치로 자동 처리됩니다. 사용자는 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">부울. 하위 디렉토리로 내려가는 것을 금지하는 속성.</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="62ac59b7255ce5ff9fee8ac49157bdd9bc4445e2" translate="yes" xml:space="preserve">
          <source>Bosnia and Herzegovina</source>
          <target state="translated">보스니아 헤르체고비나</target>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">클래스 &lt;code&gt;two_refs1&lt;/code&gt; 에 축복 된 두 &quot;객체&quot; 는 배열에 대한 참조, 따라서</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated"># 1과 # 2는 $ data가 완전히 유효한 UTF-8 문자열로 구성되도록하지만 # 2만이 UTF8 플래그를 켭니다. # 1은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">두 &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;bsstr()&lt;/code&gt; 뿐만 아니라 오버로드를 통해 캐릭터 라인 화 자동으로 현재 최고의 '+'를 놓습니다. 이전 코드는 '+3'을 반환하고 새 코드는 '3'을 반환합니다. 이것은 Perl과 일관성을 유지하고 &lt;code&gt;cmp&lt;/code&gt; (특히 과부하가 걸리는 경우)가 예상대로 작동하도록하는 것입니다. 또한 &lt;code&gt;Test.pm&lt;/code&gt; 및 &lt;a href=&quot;../test/more&quot;&gt;Test :: More의&lt;/a&gt; 문제를 해결 하여 인수를 비교하기 전에 문자열 로 묶 습니다.</target>
        </trans-unit>
        <trans-unit id="a620ebe99c93fe5ad5f0770d99e27217bee38fe8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">두 &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;bsstr()&lt;/code&gt; 뿐만 아니라 캐릭터 라인 화를 통해 과부하로 최고의 '+'를 놓습니다. 이것은 Perl과 일치하고 &lt;code&gt;cmp&lt;/code&gt; (특히 오버로딩)가 예상대로 작동 하도록 만드는 것입니다. 또한 &lt;code&gt;Test.pm&lt;/code&gt; 및 &lt;a href=&quot;Test::More&quot;&gt;Test :: More의&lt;/a&gt; 문제를 해결 하여 비교하기 전에 인수 를 문자열 화합니다.</target>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">두 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 및 &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 반환합니다 &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에 있지 않으며 (NFC는 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; 이며) &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a5a39017b338373b526416f145175959e75a080" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt;. &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt;), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">두 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 및 &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 반환합니다 &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에없는 반면 (NFC는 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0dc99557ca052a1f52b6aa9fe01653c0b56cfaf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators perform the same comparison between terms (upgrading to a version object automatically). Perl automatically generates all of the other comparison operators based on those two. In addition to the obvious equalities listed below, appending a single trailing 0 term does not change the value of a version for comparison purposes. In other words &quot;v1.2&quot; and &quot;1.2.0&quot; will compare as identical.</source>
          <target state="translated">두 &lt;code&gt;cmp&lt;/code&gt; 및 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 연산자 (자동 버전의 객체로 업그레이드) 같은 용어의 비교를 수행합니다. Perl은이 두 가지를 기반으로 다른 모든 비교 연산자를 자동으로 생성합니다. 아래 나열된 명백한 동등성 외에도 단일 후행 0 용어를 추가해도 비교 목적으로 버전의 값이 변경되지 않습니다. 즉, &quot;v1.2&quot;와 &quot;1.2.0&quot;은 동일한 것으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">지원되는 범위를 벗어난 날짜가 제공된 경우 &lt;code&gt;timelocal()&lt;/code&gt; 및 &lt;code&gt;timegm()&lt;/code&gt; 둘 다 사라 집니다.</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">두 &lt;code&gt;wrap()&lt;/code&gt; 와 &lt;code&gt;fill()&lt;/code&gt; 하나의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">두 Perl 함수 모두 첫 번째 매개 변수로 오브젝트를 예상합니다. 생성 된 C ++ 코드에서 오브젝트를 &lt;code&gt;THIS&lt;/code&gt; 라고 하며이 오브젝트 에서 메소드 호출이 수행됩니다. 따라서 C ++ 코드에서 blue () 및 set_blue () 메소드는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7be927e1ed4202312ce2dde8192f9556312f51fd" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt;, and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">두 Perl 함수 모두 첫 번째 매개 변수로 오브젝트를 예상합니다. 생성 된 C ++ 코드에서 객체는 &lt;code&gt;THIS&lt;/code&gt; 라고 하며이 객체에 대해 메서드 호출이 수행됩니다. 따라서 C ++ 코드에서 blue () 및 set_blue () 메서드는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">YAML.pm과 YAML :: Syck는 모두 코드를 역 직렬화 할 수 있습니다. 보안 위험이있는 문자열 평가가 필요하므로이 옵션을 사용하여 CPAN :: DeferredCode를 통해 코드의 직렬화 해제를 활성화하거나 비활성화 할 수 있습니다. (참고 : 이것은 perl 5.6에서는 작동하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">둘 다 나쁘고 부러지고 운반 할 수 없습니다. 올바른 PTR2IV () 매크로를 사용하십시오. 마찬가지로 PTR2UV (), PTR2NV (), INT2PTR () 및 NUM2PTR ()이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8f3fbafa937e38c34348185c6cef931d0a050c2" translate="yes" xml:space="preserve">
          <source>Both colored() and many uses of the color constants will add the reset escape sequence after a newline. If a program mixes colored output to standard output with output to standard error, this can result in the standard error text having the wrong color because the reset escape sequence hasn't yet been flushed to the display (since standard output to a terminal is line-buffered by default). To avoid this, either set autoflush() on STDOUT or set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">colors ()와 색상 상수의 많은 사용은 줄 바꿈 뒤에 재설정 이스케이프 시퀀스를 추가합니다. 프로그램이 컬러 출력을 표준 출력에 혼합하고 표준 오류에 대한 출력을 혼합하면 재설정 이스케이프 시퀀스가 ​​아직 디스플레이에 플러시되지 않았기 때문에 표준 오류 텍스트가 잘못된 색상을 가질 수 있습니다 (터미널에 대한 표준 출력이 라인이므로 -기본적으로 버퍼링 됨). 이를 방지하려면 STDOUT에 autoflush ()를 설정하거나 $ Term :: ANSIColor :: EACHLINE을 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">두 가지 노력 모두 자원 봉사자를 환영합니다. 펄 자체의 연기 테스트에 참여하려면 &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/를&lt;/a&gt; 방문 하십시오 . CPAN 모듈의 연기 테스트를 시작하려면 &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org를&lt;/a&gt; 방문 하십시오 . / DIST / CPAN-기자 / .</target>
        </trans-unit>
        <trans-unit id="ae562d3087c6e461927df57072977056d07bc9d8" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter&lt;/a&gt;.</source>
          <target state="translated">두 가지 노력 모두 자원 봉사자를 환영합니다. Perl 자체의 연기 테스트에 참여하려면 &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke를&lt;/a&gt; 방문 하십시오 . 연기 테스트 CPAN 모듈을 시작하려면 &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; 또는 &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; 또는 &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter를&lt;/a&gt; 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="55d4c4d23a88d207ea9fa065963f476f871b153f" translate="yes" xml:space="preserve">
          <source>Both encode and decode methods propagate &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; when encoding and decoding the MIME charset.</source>
          <target state="translated">인코딩 및 디코딩 메서드는 모두 MIME 문자 집합을 인코딩 및 디코딩 할 때 &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK 플래그를&lt;/a&gt; 전파 합니다.</target>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">두 형태 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">두 함수 모두 &lt;code&gt;gettimeofday&lt;/code&gt; 와 같은 동등한 정보를 리턴 하지만 다른 표현을 리턴합니다 . &lt;code&gt;NVtime&lt;/code&gt; 및 &lt;code&gt;U2time&lt;/code&gt; 이라는 이름 은 운영 체제와 독립적이므로 주로 선택되었습니다. ( &lt;code&gt;gettimeofday&lt;/code&gt; 는 Unix 중심이지만 Win32 및 VMS와 같은 일부 플랫폼에는 에뮬레이션이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5c4e6f175302e55e83c34f1bf1849d831a9de257" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt;) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">두 함수 모두 동일한 정보 (예 : &lt;code&gt;gettimeofday&lt;/code&gt; )를 반환 하지만 표현이 다릅니다. &lt;code&gt;NVtime&lt;/code&gt; 및 &lt;code&gt;U2time&lt;/code&gt; 이라는 이름 은 주로 운영 체제에 독립적이기 때문에 선택되었습니다. ( &lt;code&gt;gettimeofday&lt;/code&gt; 는 Unix 중심이지만 Win32 및 VMS와 같은 일부 플랫폼에는 에뮬레이션이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">install () 및 uninstall ()은 ExtUtils :: MakeMaker가 perl 모듈의 설치 및 제거를 처리하는 방식에 따라 다릅니다. 범용 도구로 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5627699dd1ad2924464995985beca5c6cf35ef97" translate="yes" xml:space="preserve">
          <source>Both methods will prevent the import() method from firing and exporting the &lt;code&gt;qv()&lt;/code&gt; sub.</source>
          <target state="translated">두 메서드 모두 import () 메서드가 &lt;code&gt;qv()&lt;/code&gt; 하위를 시작 하고 내보내는 것을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">숫자 및 문자열 값이 모두 허용되지만 문자열 값은 대소 문자를 구분합니다. 이 설정의 기본값은 &quot;RANDOM&quot;또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">위의 두 문자는 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; &lt;code&gt;\x09&lt;/code&gt; 와 일치 하지만 \ x09 는 다음과 같습니다. 실수로 경고가 발생합니다 ( &lt;code&gt;re 'strict'&lt;/code&gt; 하에 ).</target>
        </trans-unit>
        <trans-unit id="6cba8f2c40b0b7e7464484e646fc77656ccf2181" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt;, ... &lt;code&gt;\N{U+08}&lt;/code&gt;, &lt;code&gt;\N{U+09}&lt;/code&gt;, but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt;) for it.</source>
          <target state="translated">위의 두 가지 모두 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; &lt;code&gt;\x09&lt;/code&gt; 와 일치 하지만 \ x09 는 그럴 수있는 것처럼 보입니다. 실수로 인해 경고가 발생합니다 ( &lt;code&gt;re 'strict'&lt;/code&gt; 아래 ).</target>
        </trans-unit>
        <trans-unit id="19034866ba0e5cf040b7023a16a969fddf08ed53" translate="yes" xml:space="preserve">
          <source>Both of the provided scalars are already compiled as regular expressions and do not contain either anchors or implicit groupings, so they can be included in your own regular expressions freely. For example, consider the following code:</source>
          <target state="translated">제공된 두 스칼라는 이미 정규식으로 컴파일되었으며 앵커 또는 암시 적 그룹을 포함하지 않으므로 자신의 정규식에 자유롭게 포함 할 수 있습니다. 예를 들어, 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e6fc8a94496c661c5e9f86f3352074c1b6a4eef2" translate="yes" xml:space="preserve">
          <source>Both of these methods will produce similar version objects, in that the default stringification will yield the version &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; only if required:</source>
          <target state="translated">이 두 메서드는 모두 필요한 경우에만 기본 문자열 화가 &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; 버전을 생성한다는 점에서 유사한 버전 객체를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2a103cc718ae6b6f4898e4597463858c0b08dfa7" translate="yes" xml:space="preserve">
          <source>Both or neither range ends should be Unicode in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">범위 끝은 모두 정규식에서 유니 코드 여야합니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">읽기 및 쓰기 액세스</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">두 루틴 모두 작동 된 해시에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">둘 다 &quot;$ x&quot;, 하나의 공백, &quot;?&quot;, 하나의 공백, &quot;:&quot;, 하나의 공백, &quot;$ z&quot;로 구성되는 모노 스페이스 (c [ode] 스타일) 텍스트를 나타냅니다. 차이점은 후자의 경우 S 코드에서 해당 공간은 &quot;정상&quot;공간이 아니라 비 공백 공간이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed699d8c766ffac9fc7609020189bb30a788c2d9" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">stringify와 bstr () 모두 이제 선행 '+'를 삭제합니다. 이전 코드는 '+1.23'을 반환하고 새 코드는 '1.23'을 반환합니다. 추론 및 자세한 내용 은 &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt&lt;/a&gt; 의 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">stringify와 bstr ()은 이제 선행 '+'를 삭제합니다. 이전 코드는 '+1.23'을 반환하고 새 코드는 '1.23'을 반환합니다. 추론 및 자세한 내용 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 의 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">두 스타일 모두 실제 파일 핸들의 객체 또는 유형 글로브와 함께 작동합니다. (일부 상황에서는 문자열을 사용할 수도 있지만 위험합니다.)</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">여기서 두 서브 루틴은 스칼라 컨텍스트에서 호출되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88a5a602af253e21581322ee44c47e54f2ad5148" translate="yes" xml:space="preserve">
          <source>Both sysread() and recv() currently use only the &lt;code&gt;:utf8&lt;/code&gt; flag for the stream, ignoring the actual layers. Since sysread() and recv() do no UTF-8 validation they can end up creating invalidly encoded scalars.</source>
          <target state="translated">sysread () 및 recv () 모두 현재 스트림에 대해 &lt;code&gt;:utf8&lt;/code&gt; 플래그 만 사용 하고 실제 레이어는 무시합니다. sysread () 및 recv ()는 UTF-8 유효성 검사를 수행하지 않기 때문에 잘못 인코딩 된 스칼라를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">양쪽 &lt;code&gt;$key&lt;/code&gt; 와 &lt;code&gt;$value&lt;/code&gt; 매개 변수는 키 / 값 쌍으로 설정됩니다 데이터베이스에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">모두 &lt;code&gt;FETCH&lt;/code&gt; 기능을 보내고하고는 &lt;code&gt;EXISTS&lt;/code&gt; 기능은 동일한 서명이 : 인수는 &lt;code&gt;$key, $data&lt;/code&gt; ; $ data는 tie () 중 인수로 제공된 값과 같습니다. 값이 없으면 두 함수 모두 빈 목록을 반환해야합니다. 경우 &lt;code&gt;EXISTS&lt;/code&gt; 기능은 다른 &lt;code&gt;FETCH&lt;/code&gt; 보내고 기능, 그것은 성공에 TRUE 값을 반환해야합니다. &lt;code&gt;FETCH&lt;/code&gt; 키가 유효한지 보내고 기능은 의도 된 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="26d9da8f5ad7069914e20430c62d4e761633b2e9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt;ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt;; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt;ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt;ing function should return the intended value if the key is valid.</source>
          <target state="translated">모두 &lt;code&gt;FETCH&lt;/code&gt; 기능을 보내고하고는 &lt;code&gt;EXISTS&lt;/code&gt; 기능은 동일한 서명이 : 인수는 &lt;code&gt;$key, $data&lt;/code&gt; ; $ data는 tie () ing 동안 인자로 주어진 것과 같은 값입니다. 값이 존재하지 않으면 두 함수 모두 빈 목록을 반환해야합니다. &lt;code&gt;EXISTS&lt;/code&gt; 함수가 &lt;code&gt;FETCH&lt;/code&gt; ing 함수와 다른 경우 성공하면 TRUE 값을 반환해야합니다. &lt;code&gt;FETCH&lt;/code&gt; 키가 유효한지 보내고 기능은 의도 된 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">두 &lt;code&gt;\p&lt;/code&gt; 상대방은 항상 유니 코드 규칙이 유효하다고 가정합니다. ASCII 플랫폼에서 이는 128에서 255까지의 코드 포인트가 Latin-1이라고 가정하며 로케일이 Latin-1 또는 UTF-8이 아니라면 로케일 규칙에서 코드 포인트를 사용하는 것이 현명하지 않다는 것을 의미합니다. 반대로 POSIX 문자 클래스는 로케일 규칙에서 유용합니다. 다음과 같이 실제 규칙의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">모두 &lt;code&gt;filter&lt;/code&gt; 방법은 사용할</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Store 및 Fetch 필터는 모두 &lt;code&gt;$_&lt;/code&gt; 조작 합니다.</target>
        </trans-unit>
        <trans-unit id="4fb703f0b0c3a852ad76e2cb00f9c501f48f8ec4" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">Store 및 Fetch 필터 모두 &lt;code&gt;$_&lt;/code&gt; 조작 합니다.</target>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">두 함수 모두 지정된 함수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">기본 프로세스와 포크 프로세스가 동일한 STDIN, STDOUT 및 STDERR 파일 핸들을 공유합니다. 두 프로세스 모두 한 번에 액세스하려고하면 이상한 일이 발생할 수 있습니다. 자녀의 파일 핸들을 닫거나 다시 열 수도 있습니다. open ()으로 파이프를 열어이 문제를 해결할 수 있지만 일부 시스템에서는 하위 프로세스가 상위 프로세스보다 오래 지속될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">기본 프로세스와 백그라운드 프로세스 ( &quot;하위&quot;프로세스)는 모두 동일한 STDIN, STDOUT 및 STDERR 파일 핸들을 공유합니다. 둘 다 한 번에 액세스하려고하면 이상한 일이 발생할 수 있습니다. 자녀를 위해 문을 닫거나 다시 열 수 있습니다. 파이프 를 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이 문제를 해결할 수 있지만 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ) 일부 시스템에서는 하위 프로세스가 상위 프로세스보다 오래 지속될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f7d92bf0fef8c6d376360d3e96b538b59d69f577" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;open&lt;/code&gt;ing a pipe (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">메인 프로세스와 백그라운드 프로세스 ( &quot;하위&quot;프로세스)는 모두 동일한 STDIN, STDOUT 및 STDERR 파일 핸들을 공유합니다. 둘 다 한 번에 액세스하려고하면 이상한 일이 발생할 수 있습니다. 자녀를 위해이를 닫거나 다시 열 수 있습니다. 당신은 이것을 주변에 얻을 수있는 &lt;code&gt;open&lt;/code&gt; (참조 파이프를 보내고 &lt;a href=&quot;perlfunc#open&quot;&gt;을 perlfunc에서 &quot;열기&quot;&lt;/a&gt; 자식 프로세스가 부모를 오래 살 수 없다는이 의미하지만 일부 시스템).</target>
        </trans-unit>
        <trans-unit id="d89a0af2055da02fc83d8afed6e917b5cc66d525" translate="yes" xml:space="preserve">
          <source>Both the native cc and gcc seem to consume lots of memory when building Perl. toke.c is a known trouble spot when optimizing: 256 megabytes of data section seems to be enough. Another known trouble spot is the mktables script which builds the Unicode support tables. The default setting of the process data section in Tru64 should be one gigabyte, but some sites/setups might have lowered that. The configuration process of Perl checks for too low process limits, and lowers the optimization for the toke.c if necessary, and also gives advice on how to raise the process limits (for example: &lt;code&gt;ulimit -d 262144&lt;/code&gt;)</source>
          <target state="translated">기본 cc와 gcc 모두 Perl을 빌드 할 때 많은 메모리를 소비하는 것 같습니다. toke.c는 최적화 할 때 알려진 문제 지점입니다. 256MB의 데이터 섹션이면 충분할 것 같습니다. 또 다른 알려진 문제 지점은 유니 코드 지원 테이블을 빌드하는 mktables 스크립트입니다. Tru64에서 프로세스 데이터 섹션의 기본 설정은 1 기가 바이트 여야하지만 일부 사이트 / 설정에서이 값을 낮췄을 수 있습니다. Perl의 구성 프로세스는 너무 낮은 프로세스 한계를 확인하고 필요한 경우 toke.c에 대한 최적화를 낮추며 프로세스 한계를 높이는 방법에 대한 조언도 제공합니다 (예 : &lt;code&gt;ulimit -d 262144&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">특수 매핑과 일반 매핑이 모두</target>
        </trans-unit>
        <trans-unit id="e87bc450de2089bfd62a5bd96629fc5b32ff6be9" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt;.</source>
          <target state="translated">이 두 XS 선언은 모두 &lt;code&gt;char*&lt;/code&gt; C 유형에 해당하지만 의미가 다릅니다. &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">이 두 XS 선언은 &lt;code&gt;char*&lt;/code&gt; C 유형에 해당하지만 의미가 서로 다릅니다 ( &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">이 두 가지 방법 모두 첫 번째 인수로 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 을 자동으로 삽입 하고 (다른 인수가 제공되지 않은 경우) &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">이 두 가지 문제를 모두 해결할 수 있습니다. 예를 들어, 객체에 대한 참조에 해시 역 참조를 오버로드하려면</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">wdayname (일)과 monname (월) 모두 일의 이름을 색인하는 데 사용할 목록을 전달할 수 있습니다. 실제로 로케일을 설치하거나 사용하지 않고 특정 형식의 현지화를 구현해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7251257be5507cef24fe3fb21a50fe67755c29b8" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales. Note that this is a global override and will affect all Time::Piece instances.</source>
          <target state="translated">wdayname (일) 및 monname (월) 모두 목록을 전달하여 날짜 이름을 색인화하는 데 사용할 수 있습니다. 이것은 실제로 로케일을 설치하거나 사용하지 않고 어떤 형태의 현지화를 구현해야하는 경우에 유용 할 수 있습니다. 이것은 전역 재정의이며 모든 Time :: Piece 인스턴스에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">최하위 UTF-8 디코딩 루틴. UTF-8 (또는 UTF-EBCDIC) 인코딩으로 가정되며 더 이상 &lt;code&gt;curlen&lt;/code&gt; bytes가 아닌 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 첫 번째 문자의 원시 코드 포인트 값을 리턴합니다 . &lt;code&gt;*retlen&lt;/code&gt; ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 )은 해당 문자의 길이 (바이트)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa04ba4cca5e78047dc43990129bc3ae3f19bff" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;s&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">최하위 수준의 UTF-8 디코딩 루틴입니다. UTF-8 (또는 UTF-EBCDIC) 인코딩으로 가정되고 &lt;code&gt;curlen&lt;/code&gt; 바이트 보다 길지 않은 문자열 &lt;code&gt;s&lt;/code&gt; 의 첫 번째 문자의 원시 코드 포인트 값을 리턴합니다 . &lt;code&gt;*retlen&lt;/code&gt; ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 )은 해당 문자의 길이 (바이트)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">한글 음절의 경계는 다음의 Jamo 동작에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin, Joseph, David Kirschen, Alan Langerman 및 Susan LoVerso. 마하에서 프로그래밍. 애디슨-웨슬리, 1994 년, ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">이전 단계의 결과로 오는 감사, 버그 보고서, 증오 메일 및 스팸에 대해 스스로를 보호하십시오. 선한 행동은 처벌받지 말아야합니다!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">명명 된 캡처 그룹을 참조 할 때는 중괄호가 필요하지만 절대 또는 상대 번호가 지정된 그룹은 선택 사항입니다. 작은 문자열을 연결하여 정규식을 만들 때 중괄호가 더 안전합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; 가 있고 &lt;code&gt;$a&lt;/code&gt; 에 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 포함되어 있고 &lt;code&gt;$b&lt;/code&gt; 에 &lt;code&gt;&quot;37&quot;&lt;/code&gt; 이 포함되어 있으면 &lt;code&gt;/\g137/&lt;/code&gt; 을 얻게 되며 아마도 의도하지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="18fd4ec0e937de91c70828b19eb3454f88d75941" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">중괄호는 명명 된 캡처 그룹을 참조 할 때 필요하지만 절대 또는 상대 번호가 매겨진 그룹의 경우 선택 사항입니다. 더 작은 문자열을 연결하여 정규식을 만들 때 중괄호가 더 안전합니다. 예를 들어 &lt;code&gt;qr/$a$b/&lt;/code&gt; 가 있고 &lt;code&gt;$a&lt;/code&gt; 가 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 을 포함하고 &lt;code&gt;$b&lt;/code&gt; 가 &lt;code&gt;&quot;37&quot;&lt;/code&gt; 을 포함 하면 &lt;code&gt;/\g137/&lt;/code&gt; 을 얻습니다. 이는 아마도 의도 한 것과 다를 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">대괄호 표기법은 Locale :: Maketext의 중요한 기능입니다. sprintf 형식을 대신 할 대괄호 표기법을 의미합니다. 대괄호 표기법으로 수행하는 모든 작업은 하위 블록으로 수행 할 수 있지만 대괄호 표기법은 훨씬 간결합니다.</target>
        </trans-unit>
        <trans-unit id="bb9b16ff2deefe21cce7105f1030ffe04c9ef94b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">대괄호 표기법은 일반 텍스트가 기본적으로있는 그대로 전달되지만 특수 영역의 텍스트는 특별히 해석 되는 소형 &quot;템플릿&quot;시스템 ( C ++ 템플릿 의미가 아닌 &lt;a href=&quot;Text::Template&quot;&gt;Text :: Template&lt;/a&gt; 의미)과 같습니다. 대괄호 표기법에서는 특별히 해석되는 섹션을 표시하기 위해 중괄호 ( &quot;{...}&quot;)가 아닌 대괄호 ( &quot;[...]&quot;)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">대괄호 표기법은 소형 &quot;템플릿&quot;시스템과 유사합니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; 의 의미에서 기본 텍스트는 그대로 그대로 전달되지만 특수 영역의 텍스트는 특별히 해석 C ++ 템플릿의 의미가 아닌 의 의미)과 유사합니다. 대괄호 표기법에서는 중괄호 ( &quot;{...}&quot;)가 아닌 대괄호 ( &quot;[...]&quot;)를 사용하여 특별히 해석되는 섹션을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">대괄호 표기법은 다음 섹션에서 설명합니다. 문자열을 대괄호 표기법으로 컴파일하려고하면 문자열이 구문 상 유효하지 않은 경우 (예 : 대괄호를 올바르게 조정하지 않음) 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">공백이거나 공백으로 만 구성된 대괄호 그룹은 무시됩니다. (예 : &quot;[]&quot;, &quot;[]&quot;또는 리턴 및 / 또는 탭 및 / 또는 공백이있는 [및 a].</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">브라켓 문자 클래스</target>
        </trans-unit>
        <trans-unit id="1d6defc184cd831ef1a40a992a7bc00f4a08d7aa" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the /xx pattern modifier</source>
          <target state="translated">대괄호 문자 클래스 및 / xx 패턴 수정 자</target>
        </trans-unit>
        <trans-unit id="56159ead51e4e16a6e6e36a9eba26b713462d135" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the &lt;code&gt;/xx&lt;/code&gt; pattern modifier</source>
          <target state="translated">대괄호 문자 클래스 및 &lt;code&gt;/xx&lt;/code&gt; 패턴 수정 자</target>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">&lt;code&gt;regnode_charclass&lt;/code&gt; 로 묶인 문자 클래스는 regnode_charclass 로 표시됩니다 . 구조 , 4 바이트 인수와 그에 따라 Latin1 범위의 문자가 클래스에 포함되는 32 바이트 (256 비트) 비트 맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">기호 참조 주위의 대괄호는 항상 문자열 내에있는 것처럼 식별자 또는 변수 이름을 나머지 표현식에서 분리하는 역할을합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">브래킷은 균형을 유지해야합니다. 모든 개방형 브래킷에는 일치하는 근접 브래킷이 하나씩 있어야하며 그 반대도 마찬가지입니다. 따라서 이들은 모두 &lt;b&gt;유효하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt; (초기 버전), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6593228df02466d50b8cc0c36e813c08ba422fcb" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (port to Pod::Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (more porting to Pod::Simple) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (more porting to Pod::Simple)</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (초기 버전), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (포트에서 Pod :: Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (Pod :: Simple로 더 포팅) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (Pod :: Simple로 더 포팅)</target>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt;, 마렉 루찰 &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ace391da91b3b622751d8ebf145fd4091f241ba4" translate="yes" xml:space="preserve">
          <source>Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</source>
          <target state="translated">Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3ae43dcfe840a5e3a18a13f5b3acd9cb0f221ef8" translate="yes" xml:space="preserve">
          <source>Brandon Browning,</source>
          <target state="translated">브랜든 브라우닝,</target>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">브랜든 L. 블랙, &amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb6fe57c36bfedd5ff6f16a948fc45d01c7d083" translate="yes" xml:space="preserve">
          <source>Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="translated">Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="37497aa5a2272c49714aee1b07e8edf973a95f59" translate="yes" xml:space="preserve">
          <source>Brazil</source>
          <target state="translated">Brazil</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 벗어남 블록.</target>
        </trans-unit>
        <trans-unit id="70e84e284b7238bd647c1d2ad9dae3dcf040b2c5" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 블록에서 벗어나십시오 .</target>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">이 모듈의 경우 프로그램의 실행을 브레이크 &lt;code&gt;autouse&lt;/code&gt; d는 조기 완료 될 것으로 예상하고 일부 초기화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="848f64a4802a4e63379bfcaf66c37f0f07a8afee" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt;d has some initialization which it expects to be done early.</source>
          <target state="translated">이 모듈의 경우 프로그램의 실행을 브레이크 &lt;code&gt;autouse&lt;/code&gt; d는 조기 완료 될 것으로 예상하고 일부 초기화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">유니 코드 규칙에 따라 텍스트를 줄로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">재사용 가능한 코드를 하나 이상의 개별 모듈 파일로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">줄 바꿈 가능한 줄은 다음과 &lt;code&gt;:&lt;/code&gt; 표시됩니다 . 중단 점이있는 줄은 &lt;code&gt;b&lt;/code&gt; 로 표시되고 작업이 &lt;code&gt;a&lt;/code&gt; 줄은 a 로 표시됩니다 . 실행하려고하는 줄은 &lt;code&gt;==&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cca55190538278526fdb090660eae35486629fc" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt;. Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt;. The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">구분할 수있는 줄은 다음과 &lt;code&gt;:&lt;/code&gt; 표시됩니다 .. 중단 점이있는 줄은 &lt;code&gt;b&lt;/code&gt; 로 표시되고 작업이 &lt;code&gt;a&lt;/code&gt; 줄은 a 로 표시됩니다 . 실행될 줄은 &lt;code&gt;==&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="73cb8429b43020f4d84d456449c4c5b228dde417" translate="yes" xml:space="preserve">
          <source>Breaking gettext</source>
          <target state="translated">gettext 속보</target>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">돌파</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">DBM 파일과 해시 간의 바인딩을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="fece5a66de93443d7bff991c12beae4eb8074f61" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">변수와 패키지 간의 바인딩을 끊습니다. ( &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;동점&lt;/a&gt; 참조 ) 변수가 동률이 아니면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">변수와 패키지 사이의 바인딩을 끊습니다. (참조 &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;넥타이&lt;/a&gt; .) 변수가 연결되지 않은 경우는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powers에는 Memoize와 작동하도록 설계되었으며 가장 최근에 사용 된 데이터의 만료를 제공 하는 &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; 모듈이 있습니다. 캐시는 고정 된 수의 항목으로 유지되며 새 데이터가 들어 오면 가장 최근에 사용 된 데이터가 만료됩니다. &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c27cf707cf417ff0a776233c5044d0c0f1f7ca1a" translate="yes" xml:space="preserve">
          <source>Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</source>
          <target state="translated">Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f48c0d1bc27a1a6d3322c34a40dc48ed4836827" translate="yes" xml:space="preserve">
          <source>Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</source>
          <target state="translated">Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">간단히 말해서 &lt;code&gt;/l&lt;/code&gt; 은 문자 일치를 패턴 일치 실행시 적용되는 &lt;b&gt;L&lt;/b&gt; ocale 의 문자 세트로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="617a3fbf545ee5333943d4e71b255277bef3b51a" translate="yes" xml:space="preserve">
          <source>Broadcast =&amp;gt; BOOL</source>
          <target state="translated">방송 =&amp;gt; BOOL</target>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">일반적으로 패턴과 문자열을 일치시키는 작업에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">고장난 시스템</target>
        </trans-unit>
        <trans-unit id="1def5ba77699f04961452989de376f438210ae2b" translate="yes" xml:space="preserve">
          <source>Bucket Order Perturbance</source>
          <target state="translated">버킷 주문 변동</target>
        </trans-unit>
        <trans-unit id="d93b6657484eea5e944049ac0b3ddce1a19d87f5" translate="yes" xml:space="preserve">
          <source>Buffer overflow in prime_env_iter: %s</source>
          <target state="translated">prime_env_iter의 버퍼 오버 플로우 : % s</target>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">현재 어휘 분석중인 텍스트를 고려중인 청크를 포함하는 버퍼 스칼라. 이것은 항상 일반 문자열 스칼라입니다 ( &lt;code&gt;SvPOK&lt;/code&gt; 가 true 인 경우). 일반적인 스칼라 수단에 의해 스칼라로 사용되지는 않습니다. 대신 아래 설명 된 포인터 변수로 버퍼를 직접 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">버그 리포트 및 기타 피드백이 가장 환영합니다.</target>
        </trans-unit>
        <trans-unit id="4a6ed58e35768beb4922face36916e3eb34ceb32" translate="yes" xml:space="preserve">
          <source>Bug reports should be submitted to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;. The &lt;b&gt;perlbug@perl.org&lt;/b&gt; address no longer automatically opens tickets. You can use this tool to compose your report and save it to a file which you can then submit to the issue tracker.</source>
          <target state="translated">버그 보고서는 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; 의 GitHub 문제 추적기에 제출해야합니다 . &lt;b&gt;perlbug@perl.org의&lt;/b&gt; 주소는 더 이상 자동으로 티켓을 열어 없습니다. 이 도구를 사용하여 보고서를 작성하고 문제 추적기에 제출할 수있는 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">많은 사람들이 제공하는 버그 보고서, 패치 및 잔소리-모두 감사합니다! &amp;amp; nested_quotewords ()가 유용하다는 것을 보증 해 주신 Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt;에게 감사의 말을 전하고 오류 점검에 대해 걱정하지 말라고 알려 주신 Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; -당신은 거기에 있어야했다).</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Peter John Acklam의 버그 수정 &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</target>
        </trans-unit>
        <trans-unit id="238715da3b418db89372b9015297a37b9b381344" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="60757698bb42548c3dda76e0d4ec377b0dd06d65" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though GitHub: &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt;</source>
          <target state="translated">버그 (및 새로운 기능에 대한 요청)는 GitHub : &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt; 를 통해 작성자에게보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">CPAN RT 시스템을 통해 버그 (및 새로운 기능에 대한 요청)를 작성자에게보고 할 수 있습니다. &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">버그 / 기능 요청</target>
        </trans-unit>
        <trans-unit id="58d170e283eb8eb2d13abdce7bd1aa5026377f10" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;.</source>
          <target state="translated">버그는 &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt; 에서 제출할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a450dc1be8865ad9e376ea507387ccd3c0e65886" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;).</source>
          <target state="translated">버그는 &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;RT 버그 추적기&lt;/a&gt; (또는 &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt; )를 통해 제출할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="147820deb7b5b2f1e33d540237db5f728a826fed" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;).</source>
          <target state="translated">버그는 &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;RT 버그 추적기&lt;/a&gt; (또는 &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt; )를 통해 제출할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">해결하지 않을 버그. :-)</target>
        </trans-unit>
        <trans-unit id="bbd80cf7e2ded5efed8f4ee9151ab57a8ab66392" translate="yes" xml:space="preserve">
          <source>Build</source>
          <target state="translated">Build</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용하여 이상 현상 빌드</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">빌드 FAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl에 대한 전제 조건 빌드</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">주어진 디렉토리 아래의 트리에서 distroprefs 파일을 찾는 반복자를 빌드하십시오. 트리 내에서 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; 와 일치하는 디렉토리 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1f5e8d7b401e7067eefc5a283830fcc846d1ee9e" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;m/^[._]/&lt;/code&gt; are pruned.</source>
          <target state="translated">주어진 디렉토리 아래의 트리에서 distroprefs 파일을 찾는 반복자를 빌드하십시오. &lt;code&gt;m/^[._]/&lt;/code&gt; 와 일치하는 트리 디렉토리 내에서 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="39f0d013521af98c935739685e85fd389eb57d10" translate="yes" xml:space="preserve">
          <source>Build hash based classes.</source>
          <target state="translated">해시 기반 클래스를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">OS / 2, &lt;a href=&quot;perlos2&quot;&gt;perlos2에&lt;/a&gt; 대한 빌드 지시 사항</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">의는 Win32에 대한 작성 지침 &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt; , 또는에서 니 환경에서 &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">매뉴얼 페이지도 작성</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">시스템 구축</target>
        </trans-unit>
        <trans-unit id="857fee8f38d36d4d66b3ca310ad74ff4223ccbe4" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the UTF-8 encoded string &lt;code&gt;spv&lt;/code&gt;, length &lt;code&gt;len&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &lt;code&gt;&quot;...&quot;&lt;/code&gt; will be appended).</source>
          <target state="translated">스칼라 &lt;code&gt;dsv&lt;/code&gt; 에 UTF-8로 인코딩 된 문자열 &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; 의 표시 가능한 버전을 &lt;code&gt;pvlim&lt;/code&gt; 합니다. 표시 가능한 버전은 최대 pvlim 바이트 길이입니다 (더 길면 나머지는 잘리고 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">스칼라 &lt;code&gt;dsv&lt;/code&gt; 에 표시 가능한 스칼라 &lt;code&gt;sv&lt;/code&gt; 의 버전을 빌드하십시오 . 표시 가능한 버전은 최대 &lt;code&gt;pvlim&lt;/code&gt; 바이트 길이입니다 (더 긴 경우 나머지는 잘리고 &quot;...&quot;가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="46af0313d23f0c460bfa1f3a9e5387975e8b2b74" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">스칼라 &lt;code&gt;dsv&lt;/code&gt; 에 스칼라 &lt;code&gt;sv&lt;/code&gt; 의 표시 가능한 버전을 빌드합니다. 표시 가능한 버전은 최대 &lt;code&gt;pvlim&lt;/code&gt; 바이트 길이입니다 (더 길면 나머지는 잘리고 &quot;...&quot;가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">스칼라로 빌드 &lt;code&gt;dsv&lt;/code&gt; 에 표시 가능한 버전의 문자열 &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; 을 . 표시 가능한 버전은 최대 &lt;code&gt;pvlim&lt;/code&gt; 바이트 길이입니다 (더 긴 경우 나머지는 잘리고 &quot;...&quot;가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="c6bd3f51881e4d26f104fbcd7a9347aa8d6d5282" translate="yes" xml:space="preserve">
          <source>Build, Configure, Make, Install</source>
          <target state="translated">빌드, 구성, 만들기, 설치</target>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl 빌드, 테스트, 설치</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Windows 플랫폼 용 빌더 클래스</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Irix에서 32 비트 Perl 빌드</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Irix에서 64 비트 Perl 빌드</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">AIX에서 동적 확장 빌드</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">AIX &amp;lt;5L에서 동적 확장 빌드</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">HP-UX에서 동적 확장 작성</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="translated">건물 확장</target>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">DOS에서 비 XS 모듈 빌드</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">WinCE 용 Perl 구축</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">DOS에서 펄 구축하기</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">DOS에서 Perl에 대한 전제 조건 빌드</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">DOS에서 XS 모듈 구축</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">소스에서 PA-RISC에 64 비트 가능 gcc를 빌드하는 것은 HP C-ANSI C 컴파일러가 있거나 이미 작동중인 gcc의 64 비트 바이너리가있는 경우에만 가능합니다. 펄의 최상의 성능은 HP의 기본 컴파일러로 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">이진 배포판 만들기</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">정규 표현식 작성</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">LP64 펄 구축</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">건물 관습</target>
        </trans-unit>
        <trans-unit id="38b3b94607428da1a192459760b9b24f29336537" translate="yes" xml:space="preserve">
          <source>Building custom .EXE files</source>
          <target state="translated">사용자 지정 .EXE 파일 빌드</target>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">사용자 지정 _.EXE_ 파일 작성</target>
        </trans-unit>
        <trans-unit id="e10bbd8c13474666bee2a919ca9d0cf777bfbdb2" translate="yes" xml:space="preserve">
          <source>Building debugging-enabled binaries (with -g or -g3) will increase the chance of getting these errors. Prevent -g if possible.</source>
          <target state="translated">디버깅이 가능한 바이너리 (-g 또는 -g3 사용)를 빌드하면 이러한 오류가 발생할 가능성이 높아집니다. 가능하면 -g를 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="60333d2c51f8933ea40f3711d31effe77527e1a4" translate="yes" xml:space="preserve">
          <source>Building perl at older commits</source>
          <target state="translated">이전 커밋에서 펄 빌드</target>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">설치하는 perl의 버전이 시스템에 이미 있고 사용 중인지 또는 아직 사용되지 않은 새 버전인지에 따라 빌드가 다르게 진행되어야합니다. 아래 설명은 버전이 새로운 것으로 가정하므로 DLL을 설치하고</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Irix에서 스레드로 빌드</target>
        </trans-unit>
        <trans-unit id="c882cff5cf66c8bc0ee9d0ac391aee6b3e4faba4" translate="yes" xml:space="preserve">
          <source>Buildtype.bat</source>
          <target state="translated">Buildtype.bat</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">내장 속성</target>
        </trans-unit>
        <trans-unit id="03c641eb4ff3905fcf16d5ff9fd329806e0d8127" translate="yes" xml:space="preserve">
          <source>Built-in Encodings</source>
          <target state="translated">내장 인코딩</target>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">내장 연산자 및 기능</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">내장 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c77726358c5daf98ad9cdccd0882bca0f718b88" translate="yes" xml:space="preserve">
          <source>Bulgaria</source>
          <target state="translated">Bulgaria</target>
        </trans-unit>
        <trans-unit id="572f7127eed71e662d147110ecd2618b7d80c972" translate="yes" xml:space="preserve">
          <source>Bultibuffer count</source>
          <target state="translated">Bultibuffer 수</target>
        </trans-unit>
        <trans-unit id="56c511a735d99d5e1aad2b7d21a4ed9e5dff3aca" translate="yes" xml:space="preserve">
          <source>Bumped version.</source>
          <target state="translated">범프 버전.</target>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">번들 인코딩 :: 로케일</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">번들은 CPAN 패키지에서 특별히 취급됩니다. 'bundle :: Tkkit'설치 (이러한 번들이 존재한다고 가정)하면 CPAN은 포드의 CONTENTS 섹션에 모든 모듈을 설치합니다. 준수 번들 파일을 @INC 경로에 배치하여 고유 번들을 로컬로 설치할 수 있습니다. 쉘 인터페이스에서 사용 가능한 autobundle () 명령은 현재 설치된 모든 모듈을 스냅 샷 번들 파일에 포함 시켜서 수행합니다.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">그러나 (예측 가능한 미래에) 포드는 포드 작성자가 위의 &quot;= 항목&quot;-클러스터 구조가 어떤 그룹을 의미하는지 구별 할 수있는 방법을 제공하지 않습니다. 따라서 포맷터는 다음과 같이 포맷해야합니다.</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">그러나 나는 메인 코드를 작동시키는 작업에서 다소 혼란을 겪고 있다고 생각합니다. 메시지에서 원하는 단어를 정확히 결정할 수 있기 전에 프로그램을 몇 번 가지고 놀아야한다는 사실에 대해서는 아무 말도하지 않습니다. 이 경우 세 줄의 코드를 변경해야합니다 : 해당 키로 maketext를 호출 한 다음 ThisProject / I18N / en.pm의 두 줄로 변경하십시오).</target>
        </trans-unit>
        <trans-unit id="68ec332e5b845e28e04fd0941baf17f046ea1744" translate="yes" xml:space="preserve">
          <source>But Perl treats &lt;code&gt;\n&lt;/code&gt; as the start- and end-line delimiter, whereas Unicode specifies more characters that should be so-interpreted.</source>
          <target state="translated">그러나 Perl은 &lt;code&gt;\n&lt;/code&gt; 을 시작 및 끝 줄 구분 기호로 취급 하는 반면 유니 코드는 그렇게 해석되어야하는 더 많은 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">그러나 유니 코드의 의도는 기존 문자 세트 표준과 실습을 통합하는 것이며, 기존의 여러 표준에는 단일 문자가 있으며 이는 ISO-8859-1과 같은 일부 조합과 동일한 의미를 갖습니다. 예를 들어, 유니 코드가 등장 할 때 &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; 는 이미이 표준에있었습니다. 따라서 유니 코드는이를 단일 문자로 레퍼토리에 추가했습니다. 그러나이 문자는 유니 코드에 의해 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; 문자와 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 문자로 구성된 시퀀스와 동등한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc372f6b713e0d837f8396fac1cbf07d86470ffa" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt;.</source>
          <target state="translated">그러나 유니 코드의 의도는 기존 문자 집합 표준과 관행을 통합하는 것이며, 기존의 여러 표준에는 ISO-8859-1과 같이 이러한 조합 중 일부와 동일한 의미를 갖는 단일 문자가 있습니다. 예를 들어 &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; 는 유니 코드가 등장했을 때 이미이 표준에 포함되었습니다. 따라서 유니 코드는이를 단일 문자로 레퍼토리에 추가했습니다. 그러나이 문자는 유니 코드에서 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; 문자와 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 문자로 구성된 시퀀스와 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">그러나 경고가 순서입니다. 다음을 사용하여 숫자를 복사 할 때 얕은 사본 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">그러나 모든 수정자는 여전히 모든 구성 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">그러나 당신이 잘 알겠지만, 이것은 독자에게 꽤 거칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 에서 CJK 통합 표의 문자에 대한 가중치 할당 은 여전히 ​​유효합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 CJK 통합 표의 문자의 가중치는 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8 인 경우 &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d36eb62a097e882438bf9a3637e15c6d9e493e5" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 한중일 통일 표의 문자에 대한 가중치 할당 은 여전히 ​​유효합니다. &lt;code&gt;undef&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 CJK 통합 표의 문자에 대한 가중치는 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8 인 경우 &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; 는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">그러나 첫 번째 블록에서 &lt;code&gt;ok&lt;/code&gt; 가 두 번째 블록에서 &lt;code&gt;skip&lt;/code&gt; 이 호출되는 것처럼 정확하게 여러 번 호출 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">그러나 둘 다 빈 목록을 할당하거나 % HASH 또는 @ARRAY를 정의하는 것보다 느립니다. 이는 집계를 비우는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">그러나 그를 귀찮게하지 마십시오, 그는 은퇴했다.</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">그러나 넣지 마십시오</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">그러나 typemap 파일의 수정 불가능한 버그 (고정으로 인해 기존 CPAN 모듈이 많이 손상됨)로 인해 &lt;code&gt;AV *&lt;/code&gt; 의 참조 횟수 가 제대로 감소하지 않습니다. 따라서 위의 XSUB는 호출 될 때마다 메모리를 누출시킵니다. &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; 및 &lt;code&gt;SVREF&lt;/code&gt; (일반 &lt;code&gt;SV *&lt;/code&gt; 가 아닌 스칼라 참조를 나타냄)에 대해 동일한 문제가 있습니다 . perl 5.16으로 시작하는 perls의 XS 코드에서 참조 유형을 올바르게 처리하는 버전으로 이러한 유형의 유형 맵을 재정의 할 수 있습니다. 당신에 &lt;code&gt;TYPEMAP&lt;/code&gt; 의 섹션 수행</target>
        </trans-unit>
        <trans-unit id="3bda93cc7a8a89f24895e1ee457675fc5ec79f7f" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt;, &lt;code&gt;CV *&lt;/code&gt;, and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt;). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">그러나 typemap 파일의 수정 불가능한 버그 (수정하면 기존 CPAN 모듈이 많이 손상됨)로 인해 &lt;code&gt;AV *&lt;/code&gt; 의 참조 횟수 가 제대로 감소하지 않습니다. 따라서 위의 XSUB는 호출 될 때마다 메모리가 누출됩니다. &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; 및 &lt;code&gt;SVREF&lt;/code&gt; (일반 &lt;code&gt;SV *&lt;/code&gt; 가 아니라 스칼라 참조를 나타냄)에 대해서도 동일한 문제가 있습니다 . perl 5.16으로 시작하는 perls의 XS 코드에서 refcount를 적절히 처리하는 버전으로 이러한 유형에 대한 typemap을 재정의 할 수 있습니다. 당신에 &lt;code&gt;TYPEMAP&lt;/code&gt; 의 섹션 수행</target>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">그러나 문자가 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 와 같이 리터럴로 지정 가능한 경우이를 사용하는 것이 가장 쉽습니다 . 구체적이지 않은 경우 부작용이 문제가되지 않으면 use &lt;code&gt;\N{}&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;\xZZ&lt;/code&gt; 대신 &lt;code&gt;\N{U+ZZ}&lt;/code&gt; 를 사용하여 16 진수로 모든 문자를 지정하십시오 . &lt;code&gt;\N{}&lt;/code&gt; 은 유니 코드 이름이므로 항상 유니 코드 문자를 제공합니다. &lt;code&gt;\N{U+41}&lt;/code&gt; 은 유니 코드 코드 포인트가 &lt;code&gt;0x41&lt;/code&gt; 인 문자 이므로 모든 플랫폼에서 &lt;code&gt;'A'&lt;/code&gt; 입니다. 부작용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d7d9f0491fdf8f26d2ae8e336ebfac29d297c05" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt;, to use that; if not so specificable, you can use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt;. &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt;, hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">그러나 가장 쉬운 방법은 문자가 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 와 같이 리터럴로 지정 가능한 경우 이를 사용하는 것입니다. 그렇게 구체적이지 않은 경우 부작용이 번거롭지 않으면 &lt;code&gt;\N{}&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;\xZZ&lt;/code&gt; 대신 &lt;code&gt;\N{U+ZZ}&lt;/code&gt; 를 사용하여 모든 문자를 16 진수로 지정하기 만하면 됩니다. &lt;code&gt;\N{}&lt;/code&gt; 은 유니 코드 이름이므로 항상 유니 코드 문자를 제공합니다. &lt;code&gt;\N{U+41}&lt;/code&gt; 은 유니 코드 코드 포인트가 &lt;code&gt;0x41&lt;/code&gt; 이므로 모든 플랫폼에서 &lt;code&gt;'A'&lt;/code&gt; 인 문자입니다 . 부작용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">그러나 failure_handler_auto는 죽거나 다른 것 대신에 $ key를 컴파일하여 캐싱합니다.</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">그러나 간단한 해결책이 있습니다. &lt;code&gt;Sub::Name&lt;/code&gt; 모듈 은 perl internals에 도달하여 익명 서브 루틴에 이름을 지정합니다. 간단히 이렇게하십시오 :</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">그러나 &quot;directory&quot;의 경우, 기본 &lt;code&gt;quant&lt;/code&gt; 방법이 &quot;directory&quot;의 복수가 &quot;directorys&quot;라고 생각하지 않도록 &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; 원할 것입니다. 다음과 같이 음수 형식을 지정하면 출력이 더 나아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">그러나 지금은 이러한 모든 유형의 데이터 구조에 공통적 인 일반적인 문제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="44e2925861f8472f51f5341cbaaf661343ddc11e" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt;/&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">그러나 다른 언어의 경우 ( &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; 에서 자세히 설명 했듯이 ) 간단한 &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; 로는 충분하지 않습니다. 특히 문제가있는 슬라브어의 경우 숫자, 수량화 할 명사의 인용 형식, 문장의 구문이 해당 명사 슬롯에 투영하는 대소 문자 및 성별을 제공하는 방법이 필요할 수 있습니다. 그런 다음이 방법은 숫자가 명사구에 투영하는 문법적 숫자를 결정하고 정상적인 대소 문자와 성별을 대체 할 수있는 대소 문자 및 성별을 결정합니다. 그런 다음 필요한 모든 변형 된 형태를 제공하는 어휘집에서 명사를 조회합니다.</target>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">그러나 다른 언어의 경우 ( &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13에서 자세히 설명 함)&lt;/a&gt; ) 간단한 &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; 로는 충분하지 않습니다. 특히 문제가있는 슬라브어 언어의 경우, 숫자, 명사 인용 형식, 문장의 구문이 해당 명사 슬롯에 표시되는 경우 및 성별을 제공하는 방법이 필요할 수 있습니다. 그 방법은 그 숫자가 그 명사구에 어떤 문법적 숫자로 투영되는지, 그리고 어떤 경우와 성별이 정상적인 경우와 성별을 무시할 것인지를 결정하는 책임이있다. 그런 다음 필요한 모든 활용 형태를 제공하는 어휘집에서 명사를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">그러나 일부 프로세서 / 포맷의 경우이를 쉽게 제어 할 수 없습니다. HTML 예제와 마찬가지로 여러 모호한 &amp;lt;a name = &quot;의 동작</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">그러나 일반적으로 블록은 중괄호라고도하는 중괄호로 구분됩니다. 이 구문 구조를 BLOCK이라고합니다.</target>
        </trans-unit>
        <trans-unit id="12fcc42a7dd22316cac44e40d51daa68deca033b" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK. Because enclosing braces are also the syntax for hash reference constructor expressions (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;), you may occasionally need to disambiguate by placing a &lt;code&gt;;&lt;/code&gt; immediately after an opening brace so that Perl realises the brace is the start of a block. You will more frequently need to disambiguate the other way, by placing a &lt;code&gt;+&lt;/code&gt; immediately before an opening brace to force it to be interpreted as a hash reference constructor expression. It is considered good style to use these disambiguating mechanisms liberally, not only when Perl would otherwise guess incorrectly.</source>
          <target state="translated">그러나 일반적으로 블록은 중괄호라고도하는 중괄호로 구분됩니다. 이 구문 구조를 BLOCK이라고 부를 것입니다. 둘러싸는 중괄호는 해시 참조 생성자 표현식의 구문이기도하므로 ( &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 참조 ) 경우에 따라 &lt;code&gt;;&lt;/code&gt; Perl이 중괄호가 블록의 시작임을 인식하도록 여는 중괄호 바로 뒤에. 여는 중괄호 바로 앞에 &lt;code&gt;+&lt;/code&gt; 를 배치 하여 해시 참조 생성자 표현식으로 해석되도록 강제하는 방식으로 더 자주 다른 방법을 명확하게해야합니다 . Perl이 그렇지 않으면 잘못 추측 할 때뿐만 아니라 이러한 명확성 메커니즘을 자유롭게 사용하는 것이 좋은 스타일로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">그러나 클라이언트가 &quot;i-Mingo&quot;또는 &quot;x-mingo&quot;또는 &quot;Fr&quot;을 요청하면 % greetings의 조회가 실패합니다. 그게 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">그러나 문서가 시작되면 :</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">그러나 Pod :: Simple :: Methody를 서브 클래 싱하는 경우 &quot;= head1 Hi there&quot;가 표시되면 대신이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">그러나 이것을 시도하면 :</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">그러나 &lt;code&gt;START&lt;/code&gt; 부터 &lt;code&gt;END&lt;/code&gt; 까지 의 중첩 된 발생을 원하면 이 단원의 균형 조정 텍스트 일치에 대한 질문에 설명 된 문제에 대비할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3edd5ad7f10118d3c50f146510574f8277f3c749" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt;, you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">그러나 &lt;code&gt;START&lt;/code&gt; 에서 &lt;code&gt;END&lt;/code&gt; 까지 의 중첩 된 항목을 원하면 균형 잡힌 텍스트 일치에 대한이 섹션의 질문에 설명 된 문제에 맞서게됩니다.</target>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">그러나 &lt;code&gt;\005&lt;/code&gt; 를 사용 하여 TAB을 의미하거나 &lt;code&gt;\xC1&lt;/code&gt; 을 &quot;A&quot; 를 의미 하거나 &lt;code&gt;\xDF&lt;/code&gt; 를 사용하여 &quot;&amp;yuml;&quot;( 분음이있는 작은 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ) 를 의미하는 코드를 작성하면 코드가 제대로 작동 할 수 있습니다 ASCII 플랫폼이 아닌 EBCDIC 플랫폼. 아무도 ASCII 플랫폼에서 코드를 실행하지 않으려는 경우 좋습니다. 그러나이 문서의 편견은 EBCDIC과 ASCII 시스템 사이에서 이식 가능한 코드를 작성하는 것입니다. 다시 말하지만, 관심있는 모든 문자를 키보드에서 쉽게 입력 할 수 있다면 ASCII에 대해 아무것도 알 필요가 없지만 많은 키보드는 &lt;code&gt;\xDF&lt;/code&gt; 문자를 직접 입력하는 것을 쉽게 허용하지 않기 때문에 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; 사용하여 간접적으로 지정하십시오.탈출 순서. 이러한 경우 ASCII / 유니 코드 문자 집합에 대해 가장 쉽게 알 수 있습니다. 작은 &quot;&amp;yuml;&quot;가 &lt;code&gt;U+00FF&lt;/code&gt; 이면이를 대신 &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; 로 지정 하고 컴퓨터가 자동으로 플랫폼에서 &lt;code&gt;\xDF&lt;/code&gt; 번역 하도록하고 &lt;code&gt;\xFF&lt;/code&gt; ASCII에서 xFF . 또는 이름으로 지정할 수 있습니다. &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 와 함께 작은 문자 Y 를 입력하면 숫자를 알 필요가 없습니다. 어느 쪽이든 작동하지만 유니 코드에 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c5b9a3f892143e75b663a18f94ea6753bbb8def" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be towards writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt;, so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt;, then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt;, and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but both require familiarity with Unicode.</source>
          <target state="translated">그러나 &lt;code&gt;\005&lt;/code&gt; 를 사용 하여 TAB을 의미하거나 &lt;code&gt;\xC1&lt;/code&gt; 을 사용하여 &quot;A&quot; 를 의미 하거나 &lt;code&gt;\xDF&lt;/code&gt; 를 사용하여 &quot;&amp;yuml;&quot;( 분음 기호가있는 작은 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ) 을 의미하는 코드를 작성하면 코드가 잘 작동 할 수 있습니다. EBCDIC 플랫폼 (ASCII 플랫폼은 아님). 아무도 여러분의 코드를 ASCII 플랫폼에서 실행하고 싶지 않다면 괜찮습니다. 그러나이 문서의 편견은 EBCDIC와 ASCII 시스템간에 이식 가능한 코드를 작성하는 것입니다. 다시 말하지만, 관심있는 모든 문자를 키보드에서 쉽게 입력 할 수있는 경우 ASCII에 대해 알 필요가 없지만 많은 키보드에서는 문자 &lt;code&gt;\xDF&lt;/code&gt; 를 직접 입력 할 수 없으므로 다음을 수행해야합니다. &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; 사용하는 것과 같이 간접적으로 지정합니다.이스케이프 시퀀스. 이러한 경우 ASCII / 유니 코드 문자 집합에 대해 아는 것이 가장 쉽습니다. 작은 &quot;&amp;yuml;&quot;이 &lt;code&gt;U+00FF&lt;/code&gt; 라는 것을 알고있는 경우 대신 &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; 로 지정 하고 컴퓨터가 자동으로 플랫폼에서 &lt;code&gt;\xDF&lt;/code&gt; 번역 하도록하고 &lt;code&gt;\xFF&lt;/code&gt; ASCII의 xFF . 또는 이름, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 수 있으며 숫자를 알 필요가 없습니다. 어느 쪽이든 작동하지만 둘 다 유니 코드에 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">그러나 펄 프로그래머라면 구조 오프셋 프린터보다 훨씬 더 놀라운 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d1347e7974f3a5c8f6ee662fc96a7143711f4b" translate="yes" xml:space="preserve">
          <source>But if you're using &lt;code&gt;PerlIO_printf()&lt;/code&gt;, it's less typing and visual clutter to use the &lt;code&gt;%z&lt;/code&gt; length modifier (for</source>
          <target state="translated">그러나 &lt;code&gt;PerlIO_printf()&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;%z&lt;/code&gt; 길이 수정자를 사용하는 것이 입력 및 시각적 혼란이 적습니다.</target>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">그러나 어쨌든 기능과 운영 체제를 별도로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">그러나 필요한 경우를 대비하여 ...</target>
        </trans-unit>
        <trans-unit id="3425ba57841c54a0c594ad2ebd352f7a60dfde42" translate="yes" xml:space="preserve">
          <source>But in general, such surprises are rare when entire sentences are being translated, especially when the functional context is restricted to that of a computer interacting with a user either to convey a fact or to prompt for a piece of information. So, for purposes of localization, translation by phrase (generally by sentence) is both the simplest and the least problematic.</source>
          <target state="translated">그러나 일반적으로 전체 문장이 번역 될 때, 특히 기능적 맥락이 사실을 전달하거나 정보를 요구하기 위해 사용자와 상호 작용하는 컴퓨터의 맥락으로 제한되는 경우 이러한 놀라움은 드뭅니다. 따라서 현지화를 위해 구문 별 번역 (일반적으로 문장 별)이 가장 간단하고 문제가 가장 적습니다.</target>
        </trans-unit>
        <trans-unit id="8e2d7167267546a3345c93288a69c7eaaae59c46" translate="yes" xml:space="preserve">
          <source>But in many cases, especially multi-byte CJK encodings, you have to tweak a little more. Your network connection may not accept any data with the Most Significant Bit set, and your computer may not be able to tell if a given byte is a whole character or just half of it. So you have to</source>
          <target state="translated">그러나 많은 경우, 특히 멀티 바이트 CJK 인코딩의 경우 조금 더 조정해야합니다. 네트워크 연결은 최상위 비트가 설정된 데이터를 허용하지 않을 수 있으며, 컴퓨터는 주어진 바이트가 전체 문자인지 절반에 불과한지 알 수 없습니다. 그래서 당신은</target>
        </trans-unit>
        <trans-unit id="56073db003479cbcc5aa02dbdcbc3839993740e4" translate="yes" xml:space="preserve">
          <source>But in other cases, it just is that no one has implemented support yet. Patches welcome! Some elements are ported backward for some releases, but not all the way to 5.003_07.</source>
          <target state="translated">그러나 다른 경우에는 아직 아무도 지원을 구현하지 않은 것입니다. 패치 환영합니다! 일부 요소는 일부 릴리스에서 역방향으로 포팅되지만 5.003_07로 완전히 포팅되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">하지만이 특정 예에서는 아마도</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">그러나 실제로 다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">그러나 XSUB 자체의 특정 필드에도 동일한 정보를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">그러나 어휘 적으로 선언 된 집계에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">그러나 &quot;Neque&quot;, &quot;Porro&quot;및 &quot;Quisquam Est&quot;의 세 가지 (관련 또는 동등한) 항목에 대한 논의가 될 수 있으며 그 다음에 모든 항목을 설명하는 단락과 &quot;Ut Enim&quot;이라는 새 항목이 있습니다. 이 경우 다음과 같이 형식을 지정하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">그러나 Perl 6에서는 전혀 작동하지 않습니다. 대신 (병렬화 가능) &lt;code&gt;any&lt;/code&gt; 연산자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5bdbc1f908497576f552335e7ff9cc35570484f5" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Raku. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">그러나 Raku에서는 전혀 작동하지 않습니다. 대신 (병렬 가능) &lt;code&gt;any&lt;/code&gt; 연산자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">그러나 다음과 같은 경우에는 삐걱 거릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="934319e95a665a2a7425edac031de11ea5229dad" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="translated">그러나 가장 중요한 것은 Windows와 같이 &lt;code&gt;nl_langinfo&lt;/code&gt; 가없는 시스템에서 작동 하므로 코드를 더 이식 가능하게 만듭니다. POSIX 2008 표준 ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html)에&lt;/a&gt; 지정된 50 개의 가능한 항목 중 하나만 완전히 구현되지 않았지만 비 Windows 플랫폼에서는 다른 중요한 것도 구현되지 않았습니다). &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt; 호출을 포함하여 다양한 기술을 사용하여 다른 항목을 복구합니다 . 둘 다 C89에 지정되어 있으므로 항상 사용할 수 있어야합니다. 이후의 &lt;code&gt;strftime()&lt;/code&gt; 버전에는 추가 기능이 있습니다. 시스템에서 사용할 수없는 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">그러나 기본 인코딩을 먼저 설정하지 않은 상태 에서 베어 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 를 사용하지 마십시오 . 그렇지 않으면, Perl은 당신이 가지고있는 많은, 많은, 많은 맛의 텍스트 파일을 알 수 없으며, Perl은 파일의 데이터를 작업 할 수있는 실제 문자로 올바르게 매핑하는 방법을 모를 것입니다. 를 포함한 다른 일반적인 인코딩 형식 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , 심지어 &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . 인코딩에 대한 자세한 내용은 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0747e69fd78e083ffa59b04def2af91b0c7abf3" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt;, &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt;, &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt;, and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt;. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">그러나 기본 인코딩을 먼저 설정하지 않고 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 를 사용하지 마십시오 . 그렇지 않으면 Perl은 당신이 가지고있는 많은, 많은, 많은 가능한 텍스트 파일의 종류를 알 수 없으며 Perl은 파일의 데이터를 작업 할 수있는 실제 문자로 올바르게 매핑하는 방법을 알지 못할 것입니다. &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; 를 포함한 기타 일반적인 인코딩 형식 입니다. 인코딩에 대한 자세한 내용은 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">그러나이 마지막 세 매크로는 &lt;code&gt;SvPOK()&lt;/code&gt; 가 true 인 경우에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">그러나 이것이 문자열의 문자 중 하나가 UTF-8로 인코딩되어 있거나 문자의 코드 포인트가 0xFF (255) 또는 0x80 (128)보다 크거나 문자열에 있음을 의미하지는 않습니다. 모든 문자. 모든 &lt;code&gt;is_utf8()&lt;/code&gt; 은 내부 &quot;utf8ness&quot;플래그의 값을 반환하는 것입니다. &lt;code&gt;$string&lt;/code&gt; . 플래그가 꺼져 있으면 스칼라의 바이트는 단일 바이트 인코딩으로 해석됩니다. 플래그가 켜져 있으면 스칼라의 바이트는 문자의 (가변 길이, 잠재적으로 멀티 바이트) UTF-8 인코딩 코드 포인트로 해석됩니다. UTF-8로 인코딩 된 문자열에 추가 된 바이트는 자동으로 UTF-8로 업그레이드됩니다. 비 UTF-8 및 UTF-8 스칼라가 혼합 된 경우 (큰 따옴표 삽입, 명시 적 연결 또는 printf / sprintf 매개 변수 대체) 결과는 바이트 문자열의 사본이 UTF로 업그레이드 된 것처럼 UTF-8로 인코딩됩니다. -8 : 예를 들어</target>
        </trans-unit>
        <trans-unit id="f3b88a9932e49bdc61514a0893c4a2b1cc99c884" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt;. If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">그러나 이것이 문자열의 어떤 문자도 UTF-8 인코딩이 필요하다는 것을 의미하지 않으며, 문자 중 하나에 0xFF (255) 또는 0x80 (128)보다 큰 코드 포인트가 있거나 문자열에 모든 문자. 모든 &lt;code&gt;is_utf8()&lt;/code&gt; 수행이 부착 된 내부 &quot;utf8ness&quot;플래그의 값을 반환하는 것입니다 &lt;code&gt;$string&lt;/code&gt; . 플래그가 꺼져 있으면 스칼라의 바이트가 단일 바이트 인코딩으로 해석됩니다. 플래그가 켜져 있으면 스칼라의 바이트는 문자의 (가변 길이, 잠재적으로 다중 바이트) UTF-8 인코딩 코드 포인트로 해석됩니다. UTF-8로 인코딩 된 문자열에 추가 된 바이트는 자동으로 UTF-8로 업그레이드됩니다. 비 UTF-8 및 UTF-8 혼합 스칼라가 병합되면 (큰 따옴표 보간, 명시 적 연결 또는 printf / sprintf 매개 변수 대체) 결과는 바이트 문자열의 사본이 UTF로 업그레이드 된 것처럼 UTF-8로 인코딩됩니다. -8 : 예 :</target>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">그러나 v5.16 이전에는 원하는 문자 세트에 대해 명시해야합니다. &lt;code&gt;:full&lt;/code&gt; 이름은 공식 유니 코드 문자 이름, 별명, 또는 시퀀스, 모두가 공유 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">그러나 모든 운영 체제가 명령 출력의 포크 또는 캡처를 지원하지는 않으므로이 복잡한 설명은 이식성이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="80db3d6002a0ea4be473c7d7a0631f6d66de4e4e" translate="yes" xml:space="preserve">
          <source>But second off, it's not isomorphic -- the &quot;solution&quot; (i.e., the phrasebook entries) for Chinese maps from these four English phrases to the one Chinese phrase that fits for all of them. In other words, the informal solution would be &quot;The way to say what you want in Chinese is with the one phrase 'For your question, in Y directories you would find X files'&quot; -- and so the implemented solution should be, isomorphically, just a straightforward way to spit out that one phrase, with numerals properly interpolated. It shouldn't have to map from the complexity of other languages to the simplicity of this one.</source>
          <target state="translated">그러나 두 번째로, 이것은 동형이 아닙니다. 중국어에 대한 &quot;솔루션&quot;(즉, 관용구 항목)은이 네 가지 영어 구에서 모두에 맞는 하나의 중국어 구로 매핑합니다. 즉, 비공식적 인 해결책은 &quot;중국어로 원하는 것을 말하는 방법은 '당신의 질문에 대해 Y 디렉토리에서 X 파일을 찾을 것입니다'라는 문구를 사용하는 것입니다.&quot;이므로 구현 된 해결책은 동형이어야합니다. , 숫자를 적절하게 삽입하여 한 구를 뱉어내는 간단한 방법입니다. 다른 언어의 복잡성에서이 언어의 단순성으로 매핑 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">그러나 일부 모듈은이 만트라로 구축 할 수 없습니다. 환경, 추가 인수 또는 대화식을 통해 사용자로부터 일부 추가 데이터를 얻으려고 시도합니다. 따라서 Phalanx100과 같은 대형 번들 또는 Plagger와 같은 많은 종속성을 가진 모듈의 설치를 방해합니다.</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">그러나 그것을 문자열 화하면 텍스트 내용 만 얻습니다.</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">그러나 예를 들어 전달하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">그러나 오염 테스트는 지금까지만 가능합니다. 때로는 데이터의 오염을 제거해야합니다. 값을 해시의 키로 사용하여 값을 보존 할 수 있습니다. 그렇지 않으면 오염 메커니즘을 우회하는 유일한 방법은 정규식 일치에서 하위 패턴을 참조하는 것입니다. Perl은 비 오염 패턴으로 $ 1, $ 2 등을 사용하여 하위 문자열을 참조하면 해당 패턴을 작성할 때 수행 한 작업을 알고 있다고 가정합니다. 그것은 약간의 생각을 사용한다는 것을 의미합니다. 맹목적으로 아무것도 막지 않거나 전체 메커니즘을 물리칩니다. 변수에 잘못된 문자가 있는지 확인하는 대신 변수에 &quot;좋은&quot;값이있는 올바른 문자 만 있는지 확인하는 것이 좋습니다. 생각하지 못한 나쁜 캐릭터를 놓치기가 너무 쉽기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">그러나 특정 상황에서는 모호한 구문이 생성 될 수 있으므로 직접 메소드 호출 방식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">그러나 그것은 맞지 않을 것입니다. 적어도 당신이 바라고있는 방식은 아닙니다. 문자열에 123이 없다고 주장합니다. 다음은 일반적인 기대와 달리 패턴이 일치하는 이유를 명확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">그러나 두 번째 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 가 앞서 가고 있습니다. 템플릿에 간단한 리터럴 문자열을 사용하지 않습니다. 아마도 우리는 소개해야 할 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="ebd21a1f53afcb90bb2e6fa1c3ee1beda8c1e31a" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;unpack&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">그러나 두 번째 &lt;code&gt;unpack&lt;/code&gt; 는 서두르고 있습니다. 템플릿에 간단한 리터럴 문자열을 사용하지 않습니다. 그래서 우리가 소개해야 할 것 같습니다 ...</target>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">그러나 그것은별로 예쁘지 않습니다. 장기적으로는 다음과 같은 작업을 수행하는 것이 더 간단하거나 명확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">그러나 그것은 비효율적입니다. 더 좋은 방법은 다음과 같이 프로그램을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c5623d3d8f73ddcc75bce9ec5d80243561beb13" translate="yes" xml:space="preserve">
          <source>But the Arabic translator is the next to write back. First off, your code for &quot;I scanned %g directory.&quot; or &quot;I scanned %g directories.&quot; assumes there's only singular or plural. But, to use linguistic jargon again, Arabic has grammatical number, like English (but unlike Chinese), but it's a three-term category: singular, dual, and plural. In other words, the way you say &quot;directory&quot; depends on whether there's one directory, or</source>
          <target state="translated">그러나 다음은 아랍어 번역가입니다. 먼저 &quot;% g 디렉토리를 스캔했습니다.&quot;에 대한 코드입니다. 또는 &quot;% g 디렉터리를 검색했습니다.&quot; 단수 또는 복수 만 있다고 가정합니다. 그러나 언어 전문 용어를 다시 사용하기 위해 아랍어에는 영어와 같은 문법 번호가 있지만 (중국어와는 달리) 단수, 이중 및 복수의 3 개 용어 범주입니다. 즉, &quot;디렉토리&quot;라고 말하는 방식은 디렉토리가 하나인지 아니면</target>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">그러나 HERE_TARGET은 여백에 대해 여전히 플러시되어야합니다. 들여 쓰기를 원하면 들여 쓰기를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">그러나 다음 코드는 매우 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="903f25d05dc48316bba755ecdc1e7944baec6c3c" translate="yes" xml:space="preserve">
          <source>But the marked code isn't syntactically correct to be such an interpolated class.</source>
          <target state="translated">그러나 표시된 코드는 이러한 보간 된 클래스에 대해 구문 적으로 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">그러나이 솔루션 만 작동하는 경우가 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="f444a7ccc18a957e30bdbe83f2e4500327151823" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt;);</source>
          <target state="translated">그러나이 솔루션 만 작동하는 경우가 있습니다 (예 : &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">그러나 어떤 캐릭터 세트를 사용하고 있는지 알고 싶을 수도 있습니다. 가능한 한 가지 예는 성능이 중요한 내부 루프에서 &lt;a href=&quot;#SORTING&quot;&gt;정렬하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">그러나 &lt;b&gt;둘 다&lt;/b&gt; 임시 파일이 될 필요는 없습니다 ... 교착 상태없이 다음과 같이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">그러나 그들은 임의로 길 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">그러나 이들은 여러 개의 (공백이 아닌) 줄에 걸쳐있을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">그러나 교차로가 &lt;code&gt;\p{Thai}&lt;/code&gt; 에만 적용되므로 코드를 읽는 사람이 기대할 수있는 효과는 없습니다. Laotian을 제외한 . 구성 요소 조각을 괄호로 묶으면 이와 같은 함정을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e961579d9e8252ea504999636a1d461e186d84b" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the source code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt;, excluding the Laotian. Its best to compile the subcomponents, but you could also parenthesize the component pieces:</source>
          <target state="translated">그러나 이것은 소스 코드를 읽는 사람이 예상 할 수있는 효과가 없습니다. 교차점 이 라오스 어를 제외한 &lt;code&gt;\p{Thai}&lt;/code&gt; 에만 적용되기 때문 입니다. 하위 구성 요소를 컴파일하는 것이 가장 좋지만 구성 요소 조각을 괄호로 묶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">그러나 이것은 적어도 사람이 기대할 수있는 방식과 일치하지 않습니다. 보간 된 &lt;code&gt;$a99a&lt;/code&gt; 삽입하고 정규 표현식의 전체 텍스트를 확인한 후에 만 ​​역 참조가 역효과를 낸 것이 분명합니다. 하위 식 &lt;code&gt;(\w+)&lt;/code&gt; 이 1 번을 &lt;code&gt;$a99a&lt;/code&gt; 의 그룹 을 한 등급 씩 내 렸습니다 . 상대 역 참조를 사용하면이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6783211af3a27626c9e0e73fe10e75f068ecbc7b" translate="yes" xml:space="preserve">
          <source>But this is not guaranteed to work.</source>
          <target state="translated">그러나 이것이 작동한다고 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">그러나 이것은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">그러나 이식성 경고를 피하려면 ( &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 참조) ) 다음을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9f8099c8d1ed2b0fc4c9abd170ecd56ff0e63b5" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;), you may prefer:</source>
          <target state="translated">그러나 이식성 경고를 피하려면 ( &lt;a href=&quot;perlfunc#use&quot;&gt;perlfunc의 &quot;사용&quot;&lt;/a&gt; 참조 ) 다음을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 대기 :하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 단지 바이트 시퀀스를 반환? 결국이 숫자 문자열을 C 코드에 전달하여 결국 숫자가 아닌 포인터를 기대할 수 있습니까? 답은 간단하다 : 우리는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 바이트로부터 숫자 주소를 얻어야한다 .</target>
        </trans-unit>
        <trans-unit id="9d8b172e82350b535193e00efe170bf43ca91d34" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;pack&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="translated">하지만 잠깐만 요 : &lt;code&gt;pack&lt;/code&gt; 단지 일련의 바이트를 반환 하지 않습니까? 결국 숫자에 불과한 포인터를 기대하는 일부 C 코드에이 바이트 문자열을 어떻게 전달할 수 있습니까? 대답은 간단합니다. &lt;code&gt;pack&lt;/code&gt; 에 의해 반환 된 바이트에서 숫자 주소를 얻어야합니다 .</target>
        </trans-unit>
        <trans-unit id="681fa12b5aa88395e6be12e5639cef0794d6ebaa" translate="yes" xml:space="preserve">
          <source>But what about user-defined subroutines from modules? If you use &lt;code&gt;autodie&lt;/code&gt; on a user-defined subroutine then it assumes the following behaviour to demonstrate failure:</source>
          <target state="translated">그러나 모듈의 사용자 정의 서브 루틴은 어떻습니까? 사용자 정의 서브 루틴에서 &lt;code&gt;autodie&lt;/code&gt; 를 사용하는 경우 실패를 보여주기 위해 다음 동작을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1178148d2666470319bf944b3a6373f8bd5ec43c" translate="yes" xml:space="preserve">
          <source>But what happens if your test program dies halfway through?! Since we didn't say how many tests we're going to run, how can we know it failed? No problem, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</source>
          <target state="translated">그러나 테스트 프로그램이 중간에 종료되면 어떻게됩니까?! 실행할 테스트 수를 말하지 않았는데 실패했는지 어떻게 알 수 있습니까? 문제 없습니다. &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 는 모든 테스트가 그 지점까지 통과하더라도 그 죽음을 포착하고 테스트를 실패로 전환하기 위해 약간의 마법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">그러나 우리가 불확실한 단어를 가지고 있다면 어떨까요? 이것은 &lt;code&gt;//g&lt;/code&gt; 가 만든 일종의 작업 입니다. 모든 단어를 추출하려면 간단한 정규식 &lt;code&gt;(\w+)&lt;/code&gt; 하고 &lt;code&gt;/(\w+)/g&lt;/code&gt; 하여 모든 일치 항목을 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="90358bd78c20e742086dbdc6ea3490a9deb3bfcc" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;/g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt;:</source>
          <target state="translated">하지만 불확실한 단어가 있다면 어떨까요? 이것은 &lt;code&gt;/g&lt;/code&gt; 가 만든 일종의 작업 입니다. 모든 단어를 추출하려면 간단한 정규식 &lt;code&gt;(\w+)&lt;/code&gt; 만들고 &lt;code&gt;/(\w+)/g&lt;/code&gt; 모든 일치 항목을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">그러나 때 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 대신에 사용된다 &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="818681641ebe6c47ebb66c7080c5a8f6b3070c54" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt;:</source>
          <target state="translated">그러나 때 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 대신에 사용된다 &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">그러나 끝에 다음 줄이 추가되면</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">그러나 &lt;code&gt;$a = $b + $c&lt;/code&gt; 대한 실제 컴파일 트리 다릅니다. 일부 노드</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">그러나 다음과 같이 호출하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">그러나 실제로 두 번의 파이프 호출을 할 필요는 없습니다. socketpair () 시스템 호출이 있으면이 모든 것이 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eb429c70b04342714cf4d23c433974bea348e678" translate="yes" xml:space="preserve">
          <source>But you put it aside for the moment, and optimistically hope that the other translators won't have this problem, and that their languages will be better behaved -- i.e., that they will be just like English.</source>
          <target state="translated">그러나 당신은 그것을 잠시 제쳐두고, 낙관적으로 다른 번역자들이이 문제를 겪지 않을 것이고 그들의 언어가 더 잘 작동하기를 희망합니다. 즉, 그들은 마치 영어처럼 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">그러나 귀하의 정책에 명시되어 있지 않는 한 여전히 이것이 올바른지에 대한 가정을 할 수는 없습니다. 사용자에게 물어 보는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">그러나 여전히 재미있는 select ()가 있습니다. 따라서 FileHandle 모듈을 사용하십시오. 이제 소문자 메소드 이름을 사용하여 이러한 특수 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c127d3080f3bd57d92c9f856e712493975078203" translate="yes" xml:space="preserve">
          <source>But you still have to localize it for all the languages you're producing this software for, so you pull Locale::gettext off of CPAN so you can access the &lt;code&gt;gettext&lt;/code&gt; C functions you've heard are standard for localization tasks.</source>
          <target state="translated">그러나이 소프트웨어를 생산하는 모든 언어에 대해 현지화해야하므로 CPAN에서 Locale :: gettext를 가져와 현지화 작업의 표준이라고 들었던 &lt;code&gt;gettext&lt;/code&gt; C 함수에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77a3c4f45d8b18ec4a584229683442d84d642772" translate="yes" xml:space="preserve">
          <source>But you then read in the gettext manual (Drepper, Miller, and Pinard 1995) that this is not a good idea, since how a single word like &quot;directory&quot; or &quot;directories&quot; is translated may depend on context -- and this is true, since in a case language like German or Russian, you'd may need these words with a different case ending in the first instance (where the word is the object of a verb) than in the second instance, which you haven't even gotten to yet (where the word is the object of a preposition, &quot;in %g directories&quot;) -- assuming these keep the same syntax when translated into those languages.</source>
          <target state="translated">하지만 gettext 매뉴얼 (Drepper, Miller 및 Pinard 1995)에서 &quot;디렉토리&quot;또는 &quot;디렉토리&quot;와 같은 단일 단어가 어떻게 번역되는지는 문맥에 따라 달라질 수 있기 때문에 이것이 좋은 생각이 아니라고 읽었습니다. 이것은 사실입니다. , 독일어 또는 러시아어와 같은 대소 문자 언어의 경우 첫 번째 인스턴스 (단어가 동사의 목적어 인 경우)로 끝나는 대소 문자가 다른 단어가 필요할 수 있습니다. 아직까지 (단어가 &quot;% g 디렉토리&quot;에서 전치사의 목적어 인 경우)-이러한 언어로 번역 될 때 동일한 구문을 유지한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d919612387e489786e93250f1cb6101f4eb4f66e" translate="yes" xml:space="preserve">
          <source>But!</source>
          <target state="translated">But!</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">그러나 &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; 사용하여 지시문을 추출하면 '&amp;gt;'문자가 코드 블록의 가장 바깥 레벨에서 구분 된 것으로 취급되므로 지시문이 올바르게 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="30f80e7cf502991565c61822cae8756f6fbb85c6" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">그러나 &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; 사용하여 지시문을 추출하면 '&amp;gt;'문자가 코드 블록의 가장 바깥 쪽 수준에서 구분자로만 처리되므로 지시문이 올바르게 구문 분석됩니다. .</target>
        </trans-unit>
        <trans-unit id="d9550f9852e2d8ab541a52ef7f81900ea09883af" translate="yes" xml:space="preserve">
          <source>But, even for portable ranges, it is not generally obvious what is included without having to look things up in the manual. A sound principle is to use only ranges that both begin from, and end at, either ASCII alphabetics of equal case (&lt;code&gt;b-e&lt;/code&gt;, &lt;code&gt;B-E&lt;/code&gt;), or digits (&lt;code&gt;1-4&lt;/code&gt;). Anything else is unclear (and unportable unless &lt;code&gt;\N{...}&lt;/code&gt; is used). If in doubt, spell out the character sets in full.</source>
          <target state="translated">그러나 휴대용 범위의 경우에도 매뉴얼에서 항목을 찾아 볼 필요없이 무엇이 포함되어 있는지 일반적으로 명확하지 않습니다. 건전한 원칙은 대소 문자가 동일한 ASCII 알파벳 ( &lt;code&gt;b-e&lt;/code&gt; , &lt;code&gt;B-E&lt;/code&gt; ) 또는 숫자 ( &lt;code&gt;1-4&lt;/code&gt; ) 에서 시작하고 끝나는 범위 만 사용하는 것 입니다. 다른 것은 불분명합니다 ( &lt;code&gt;\N{...}&lt;/code&gt; 를 사용 하지 않으면 이식 할 수 없습니다 ). 확실하지 않은 경우 문자 집합의 철자를 모두 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="64523236f0a5dcac7b40cdaff74c2e2dc5991adf" translate="yes" xml:space="preserve">
          <source>But, starting with Perl v5.28, locales are thread-safe on platforms that support this functionality. Windows has this starting with Visual Studio 2005. Many other modern platforms support the thread-safe POSIX 2008 functions. The C &lt;code&gt;#define&lt;/code&gt;&lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; will be defined iff this build is using these. From Perl-space, the read-only variable &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; is 1 if either the build is not threaded, or if &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; is defined; otherwise it is 0.</source>
          <target state="translated">그러나 Perl v5.28부터 로케일은이 기능을 지원하는 플랫폼에서 스레드로부터 안전합니다. Windows에는 Visual Studio 2005부터이 기능이 있습니다. 다른 많은 최신 플랫폼은 스레드로부터 안전한 POSIX 2008 기능을 지원합니다. 이 빌드가이를 사용하는 경우 C &lt;code&gt;#define&lt;/code&gt; &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; 이 정의됩니다. Perl 공간에서 읽기 전용 변수 &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; 는 빌드가 스레드되지 않았거나 &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; 가 정의 된 경우 1 입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="adebbf716096e26741f223bcfa719eec45495d73" translate="yes" xml:space="preserve">
          <source>Buzzword: Concision</source>
          <target state="translated">버즈 워드 : 간결</target>
        </trans-unit>
        <trans-unit id="b968913e712f1017ea8c46a9442142f5b0258e4f" translate="yes" xml:space="preserve">
          <source>Buzzword: Inheritance</source>
          <target state="translated">유행어 : 상속</target>
        </trans-unit>
        <trans-unit id="ca9a9237da961c2681cd1e9d5c45f274b009d9f4" translate="yes" xml:space="preserve">
          <source>Buzzword: Isomorphism</source>
          <target state="translated">버즈 워드 : 동형</target>
        </trans-unit>
        <trans-unit id="caad58d09c49a59cd7461be6687704deef207767" translate="yes" xml:space="preserve">
          <source>Buzzwords: Abstraction and Encapsulation</source>
          <target state="translated">유행어 : 추상화와 캡슐화</target>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">클래스 메서드 호출하여 &lt;code&gt;Math::Complex::display_format&lt;/code&gt; 하고 하나가 공급 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 인수로, 당신은 기본 표시 스타일, 오버라이드 (override) &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . 인수를 제공하지 않으면 현재 설정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="43dd785845dcbec8cafe7f755ed628d733e41645" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt;. Not supplying any argument returns the current settings.</source>
          <target state="translated">클래스 메서드 호출하여 &lt;code&gt;Math::Complex::display_format&lt;/code&gt; 하고 하나가 공급 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 인수로, 당신은 기본 표시 스타일, 오버라이드 (override) &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . 인수를 제공하지 않으면 현재 설정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cfd6475e714f8f18a3dfbb9986cb52d7a25b9828" translate="yes" xml:space="preserve">
          <source>By carefully looking at the encoded byte sequence, you can find that the byte sequence conforms a unique number. In that sense, EUC is a CCS generated by a CES above from up to four CCS (complicated?). UTF-8 falls into this category. See &lt;a href=&quot;perlunicode#UTF-8&quot;&gt;&quot;UTF-8&quot; in perlUnicode&lt;/a&gt; to find out how UTF-8 maps Unicode to a byte sequence.</source>
          <target state="translated">인코딩 된 바이트 시퀀스를주의 깊게 살펴보면 바이트 시퀀스가 ​​고유 번호를 따르는 것을 알 수 있습니다. 그런 의미에서 EUC는 최대 4 개의 CCS (복잡합니까?)에서 위의 CES에 의해 생성 된 CCS입니다. UTF-8이이 범주에 속합니다. UTF-8이 유니 코드를 바이트 시퀀스에 매핑하는 방법을 알아 보려면 &lt;a href=&quot;perlunicode#UTF-8&quot;&gt;perlUnicode의 &quot;UTF-8&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">대조적으로</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">일반적으로 CPAN 다이제스트 모듈은 Base64 출력을 채우지 &lt;b&gt;않습니다&lt;/b&gt; . 이러한 다이제스트를 올바르게 채워진 Base64 인코딩이 필요한 다른 소프트웨어에 공급할 때 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">일반적으로 OS / 2 API에 대한 모든 호출은 $ ^ E를 재설정하여 실패를 표시해야합니다. OS / 2 API를 호출하는 모든 Perl 액세스 가능 함수는 두 가지 클래스로 나눌 수 있습니다. 일부 API 오류가 발생하면 일부 die (), 다른 하나는 잘못된 리턴 값을 통해 오류를보고합니다 (물론 Perl과 관련이 없습니다) 액세스 가능한 기능</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">관례 적으로 점검 루틴의 이름은 &lt;code&gt;ck_*&lt;/code&gt; 입니다. 일반적으로 &lt;code&gt;new*OP&lt;/code&gt; 서브 루틴 (또는 &lt;code&gt;convert&lt;/code&gt; )에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="21e06347ae19cac9895adb4f7e858bf0ed8086b5" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt;. They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt;) (which in turn are called from</source>
          <target state="translated">관례 상 체크 루틴의 이름은 &lt;code&gt;ck_*&lt;/code&gt; 입니다. 일반적으로 &lt;code&gt;new*OP&lt;/code&gt; 서브 루틴 (또는 &lt;code&gt;convert&lt;/code&gt; )에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">일반적으로 각 테스트에는 순서대로 번호가 할당됩니다. 이것은 대부분 자동으로 수행됩니다. 그러나 각 테스트에 이름을 지정하는 것이 종종 유용합니다. 어느 쪽이 좋을까요?</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">기본적으로 &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; 은 압축 해제됩니다</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">기본적으로 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 는 zlib 라이브러리 버전 1.2.5의 개인 복사본으로 빌드됩니다. (참조</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">기본적으로 &lt;code&gt;Hash::Util&lt;/code&gt; 은 아무것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62c898d4495e40824d05af53004d3c74a134ca35" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; will</source>
          <target state="translated">기본적으로 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="7bbc45d166d6a142bcf7adafd5a3ff246af5dec6" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; will only uncompress the first bzip2 data stream in a pbzip2 file. To uncompress the complete pbzip2 file you must include the &lt;code&gt;MultiStream&lt;/code&gt; option, like this.</source>
          <target state="translated">기본적으로 &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; 는 pbzip2 파일의 첫 번째 bzip2 데이터 스트림 만 압축 해제합니다. 전체 pbzip2 파일의 압축을 풀려면 다음과 같이 &lt;code&gt;MultiStream&lt;/code&gt; 옵션을 포함해야합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
