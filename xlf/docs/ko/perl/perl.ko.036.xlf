<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="64b8d2bb065ca77fe0dc5f5fef705f4b317c4fca" translate="yes" xml:space="preserve">
          <source>How do I redirect to another page?</source>
          <target state="translated">다른 페이지로 리디렉션하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0261e937b4173727b02c00645ba76e6a415fae20" translate="yes" xml:space="preserve">
          <source>How do I reformat a paragraph?</source>
          <target state="translated">단락을 어떻게 다시 포맷합니까?</target>
        </trans-unit>
        <trans-unit id="0eeeab64d2dc7e3dd771f347a9a11591454f54b3" translate="yes" xml:space="preserve">
          <source>How do I remove HTML from a string?</source>
          <target state="translated">문자열에서 HTML을 어떻게 제거합니까?</target>
        </trans-unit>
        <trans-unit id="7190f2c95452c7e338420c52915e20b7f528657f" translate="yes" xml:space="preserve">
          <source>How do I remove consecutive pairs of characters?</source>
          <target state="translated">연속 된 문자 쌍을 제거하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="d5da8d0925bfcf1ec95ecac71470e320a20303f5" translate="yes" xml:space="preserve">
          <source>How do I reset an each() operation part-way through?</source>
          <target state="translated">each () 작업을 도중에 어떻게 재설정합니까?</target>
        </trans-unit>
        <trans-unit id="344b42394088d6a1b32ccef3d8e8decb8e4c01b4" translate="yes" xml:space="preserve">
          <source>How do I reverse a string?</source>
          <target state="translated">문자열을 어떻게 바꾸나요?</target>
        </trans-unit>
        <trans-unit id="c109790cdec5d8d7c505dc674edb8df7914a81e2" translate="yes" xml:space="preserve">
          <source>How do I select a random element from an array?</source>
          <target state="translated">배열에서 임의의 요소를 어떻게 선택합니까?</target>
        </trans-unit>
        <trans-unit id="199c93de57e75c85ebb9d101614dabcde24b6614" translate="yes" xml:space="preserve">
          <source>How do I select a random line from a file?</source>
          <target state="translated">파일에서 임의의 줄을 어떻게 선택합니까?</target>
        </trans-unit>
        <trans-unit id="39ccafc4ea9b3fd7b952612609873f9c549c7c42" translate="yes" xml:space="preserve">
          <source>How do I send email?</source>
          <target state="translated">이메일을 보내려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="56fc4c1960e173cac75e9d994591b6be91c2c2f5" translate="yes" xml:space="preserve">
          <source>How do I set CPU limits?</source>
          <target state="translated">CPU 제한은 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="73ae95585e094adfdbb75ef9f256a18859cff476" translate="yes" xml:space="preserve">
          <source>How do I set a file's timestamp in perl?</source>
          <target state="translated">펄에서 파일의 타임 스탬프를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="7015da22cf6dfd7afb1594ce5e8862f937d3b755" translate="yes" xml:space="preserve">
          <source>How do I set the time and date?</source>
          <target state="translated">시간과 날짜를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="36b77dc941cd48cd98a47f8dbd2c57de165d3aa2" translate="yes" xml:space="preserve">
          <source>How do I shuffle an array randomly?</source>
          <target state="translated">배열을 무작위로 섞는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c56fb4f98404c5161610269f73993e7de95a3de7" translate="yes" xml:space="preserve">
          <source>How do I skip some return values?</source>
          <target state="translated">일부 반환 값을 건너 뛰려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="f999ee460d48e77fd71574c2f54756bd21091885" translate="yes" xml:space="preserve">
          <source>How do I sort a hash (optionally by value instead of key)?</source>
          <target state="translated">해시를 정렬하려면 어떻게해야합니까 (선택적으로 키 대신 값으로)?</target>
        </trans-unit>
        <trans-unit id="3557025618ab23a2cf788475e1bcca26065db241" translate="yes" xml:space="preserve">
          <source>How do I sort an array by (anything)?</source>
          <target state="translated">(아무 것으로) 배열을 어떻게 정렬합니까?</target>
        </trans-unit>
        <trans-unit id="11e9e959693213fc786f53e3eeef7ea5001cbb5a" translate="yes" xml:space="preserve">
          <source>How do I start a process in the background?</source>
          <target state="translated">백그라운드에서 프로세스를 시작하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="e8df49adcf72001a3aba0a320e673d15d1fbff49" translate="yes" xml:space="preserve">
          <source>How do I store complex data structures with DB_File?</source>
          <target state="translated">DB_File로 복잡한 데이터 구조를 어떻게 저장합니까?</target>
        </trans-unit>
        <trans-unit id="d0810d8592d3996c240e80dd3d6e5421e650a5a9" translate="yes" xml:space="preserve">
          <source>How do I strip blank space from the beginning/end of a string?</source>
          <target state="translated">문자열의 시작 / 끝에서 공백을 어떻게 제거합니까?</target>
        </trans-unit>
        <trans-unit id="8ae8648605278dba0e8e66d1aa18bb02cd9cbee2" translate="yes" xml:space="preserve">
          <source>How do I substitute case-insensitively on the LHS while preserving case on the RHS?</source>
          <target state="translated">RHS에서 케이스를 보존하면서 LHS에서 대소 문자를 구분하지 않고 대체하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="32d79b5f1ff74cbc3bfb77b42941e7971f7cd494" translate="yes" xml:space="preserve">
          <source>How do I tell the difference between errors from the shell and perl?</source>
          <target state="translated">쉘과 펄의 오류의 차이점을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="402cd06b394cf67e3d76498ee9b3e9b9d87437a0" translate="yes" xml:space="preserve">
          <source>How do I temporarily block warnings?</source>
          <target state="translated">경고를 일시적으로 차단하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="c0789eca0c8fd61b4175e61db4aa71f599404e50" translate="yes" xml:space="preserve">
          <source>How do I test whether two arrays or hashes are equal?</source>
          <target state="translated">두 배열 또는 해시가 같은지 어떻게 테스트합니까?</target>
        </trans-unit>
        <trans-unit id="e84b81ceb7f858ca3fa98015c2c4dfea66af9e8b" translate="yes" xml:space="preserve">
          <source>How do I timeout a slow event?</source>
          <target state="translated">느린 이벤트 시간을 어떻게 초과합니까?</target>
        </trans-unit>
        <trans-unit id="4865802f290eeeec02fbec1851daaa986a328389" translate="yes" xml:space="preserve">
          <source>How do I transfer files in binary mode ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46e5cb6feaa9bdc58f6ceead41bdfe807157710" translate="yes" xml:space="preserve">
          <source>How do I trap control characters/signals?</source>
          <target state="translated">제어 문자 / 신호를 어떻게 트랩합니까?</target>
        </trans-unit>
        <trans-unit id="d2dd15b6c1b33b3c86eddf841d0c83120333ce34" translate="yes" xml:space="preserve">
          <source>How do I traverse a directory tree?</source>
          <target state="translated">디렉토리 트리를 어떻게 통과합니까?</target>
        </trans-unit>
        <trans-unit id="e9dd0c064f83a182ab0d7dad0b56b72fe36b708b" translate="yes" xml:space="preserve">
          <source>How do I unescape a string?</source>
          <target state="translated">문자열을 이스케이프 해제하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="de74f402e85f9eee7aa46222792929c66c3f3ab7" translate="yes" xml:space="preserve">
          <source>How do I use MIME to make an attachment to a mail message?</source>
          <target state="translated">MIME을 사용하여 메일 메시지에 첨부하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="d3ed87430fcbcc3ae6919edba6458d4a0ecbd944" translate="yes" xml:space="preserve">
          <source>How do I use a module without installing it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da1c1f95c027b2d1444208c25f958dcd9f486" translate="yes" xml:space="preserve">
          <source>How do I use a regular expression to strip C-style comments from a file?</source>
          <target state="translated">파일에서 C 스타일 주석을 제거하기 위해 정규식을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="a8b6bf66c7856a15f241de6c0802175e07cd63b3" translate="yes" xml:space="preserve">
          <source>How do I use all this in extensions?</source>
          <target state="translated">확장에서이 모든 것을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="b826b48e54f42be4d7b4af41a8de11eb743f6b7a" translate="yes" xml:space="preserve">
          <source>How do I use an SQL database?</source>
          <target state="translated">SQL 데이터베이스는 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="2bdd87983f12ab09515439198b26c02b64e724f4" translate="yes" xml:space="preserve">
          <source>How do I validate input?</source>
          <target state="translated">입력은 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="26964c4f36b19d9f1a78d8688cbdbdb4cea51cb7" translate="yes" xml:space="preserve">
          <source>How do I verify a credit card checksum?</source>
          <target state="translated">신용 카드 체크섬은 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="4f3796bf485f2eb722b7ed35a129d4469581633e" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;; however, since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">우리는 어떻게합니까? 먼저 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용한다고 생각할 수도 있습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 이 빈 필드를 축소하므로 레코드가 수입인지 지출인지 알 수 없습니다. 죄송합니다. 글쎄, 당신은 항상 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="103fbca18a8de8029a50cc2b1c4a72ca20bf5fba" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;split&lt;/code&gt;; however, since &lt;code&gt;split&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;substr&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb503b87f7ea09a8ed712efab2105d52de66798" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt; ? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;pat&lt;/code&gt; 의 첫 번째 형식 인지 어떻게 알 수 있습니까? 음, &lt;code&gt;pat&lt;/code&gt; 의 시작에 대한 포인터가 있다면 &lt;code&gt;U&lt;/code&gt; 를 보면 여전히 문자열의 시작에 있는지 테스트 할 수 있습니다. 여기 &lt;code&gt;pat&lt;/code&gt; 이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8d788126db97a55dce37692218aca769c60ab7" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt;? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c2d105be109eed3cac8eac59cfe5a2af927614" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">이 문제를 해결하기 위해 어떻게 준비합니까? 먼저 문제의 코드를 찾습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 런타임에 발생하므로 다음 중 하나에 속합니다.</target>
        </trans-unit>
        <trans-unit id="5d7d9138e293d0199d65703623c0ff89dd97e453" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;pack&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a7f470a36048c277bd60a862a28514c120a416" translate="yes" xml:space="preserve">
          <source>How do you know that you've made the right decisions? Have you picked an interface design that will cause problems later? Have you picked the most appropriate name? Do you have any questions?</source>
          <target state="translated">올바른 결정을 내렸다는 것을 어떻게 알 수 있습니까? 나중에 문제를 일으킬 인터페이스 디자인을 선택 했습니까? 가장 적합한 이름을 선택 했습니까? 질문있으세요?</target>
        </trans-unit>
        <trans-unit id="41a4f1d575f0f11ff6874b18c40b76daeb66d4c2" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">어떻게 인쇄합니까? 왜 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; &lt;a href=&quot;functions/print&quot;&gt;인쇄&lt;/a&gt; 한다고 말할 수 없습니까 ? 어떻게 정렬합니까? 어떻게 함수에 전달하거나 함수에서 다시 가져올 수 있습니까? 대상입니까? 나중에 읽을 수 있도록 디스크에 저장할 수 있습니까? 해당 행렬의 전체 행 또는 열에 어떻게 액세스합니까? 모든 값이 숫자 여야합니까?</target>
        </trans-unit>
        <trans-unit id="7a08ef652d92b58fe7f054cbc142a1867f296373" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;print @AoA&lt;/code&gt;? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db30a52c84584239974d26d09f54763e3e6b602" translate="yes" xml:space="preserve">
          <source>How do you want to capitalize those words?</source>
          <target state="translated">이 단어들을 어떻게 대문자로 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="057ea76fe6b43747bac035e0aa618c75b67755d7" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 는 어떻게 작동합니까? 버퍼에서 언 패킹 될 일부 포인터를 상상해보십시오. 널 포인터가 아닌 경우 ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 생성 할 ) 시작 주소가 있습니다. Perl은이 &quot;고정 길이 문자열&quot;의 길이를 알 수있는 방법이 없으므로 실제 크기를 &lt;code&gt;P&lt;/code&gt; 뒤에 명시 적 길이로 지정하는 것은 사용자의 몫 입니다.</target>
        </trans-unit>
        <trans-unit id="7cb23bf82dfe8e718e7ef8eacd292b571d084be2" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;undef&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9905196a168946e4c1e199eb5d4a39f1df926922" translate="yes" xml:space="preserve">
          <source>How does C3 work</source>
          <target state="translated">C3는 어떻게 작동합니까</target>
        </trans-unit>
        <trans-unit id="ec67f8e66f8cd607856093fe73d4e05432e16189" translate="yes" xml:space="preserve">
          <source>How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</source>
          <target state="translated">Perl은 Java, Python, REXX, Scheme 또는 Tcl과 같은 다른 언어와 어떻게 비교됩니까?</target>
        </trans-unit>
        <trans-unit id="1c4f7191bdf4e77d9f3df9d3633a24eb4798422b" translate="yes" xml:space="preserve">
          <source>How does Perl store UTF-8 strings?</source>
          <target state="translated">Perl은 UTF-8 문자열을 어떻게 저장합니까?</target>
        </trans-unit>
        <trans-unit id="d6555d1bc4e0774734c01cf5a9778e9667013a49" translate="yes" xml:space="preserve">
          <source>How does UTF-8 represent Unicode characters?</source>
          <target state="translated">UTF-8은 유니 코드 문자를 어떻게 표현합니까?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc6d699d794fc3ac271d46b893bbe5d8af9561d" translate="yes" xml:space="preserve">
          <source>How does the HAS_QUUX become defined where it needs to be? Well, if Foonix happens to be Unixy enough to be able to run the Configure script, and Configure has been taught about detecting and testing quux(), the HAS_QUUX will be correctly defined. In other platforms, the corresponding configuration step will hopefully do the same.</source>
          <target state="translated">HAS_QUUX는 필요한 곳에 어떻게 정의됩니까? Foonix가 Configure 스크립트를 실행할 수있을 정도로 Unixy 인 경우 quux () 감지 및 테스트에 대해 Configure에 대해 학습 한 경우 HAS_QUUX가 올바르게 정의됩니다. 다른 플랫폼에서는 해당 구성 단계가 동일하게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7654b1f75662fbb39441273d3ed984d7a322d6a" translate="yes" xml:space="preserve">
          <source>How far up the call stack should &lt;code&gt;$Test&lt;/code&gt; look when reporting where the test failed.</source>
          <target state="translated">테스트가 실패한 위치를보고 할 때 콜 스택에서 &lt;code&gt;$Test&lt;/code&gt; 까지의 거리 .</target>
        </trans-unit>
        <trans-unit id="085217ef4c6745e3415b3c7e78584430d39a3a20" translate="yes" xml:space="preserve">
          <source>How field hashes work</source>
          <target state="translated">필드 해시 작동 방식</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="debefefe9570a7f478b45607468c1f04ecf9084c" translate="yes" xml:space="preserve">
          <source>How long to wait for child processes and threads before aborting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aeac53e476a9bc19466fb717cce28dc3a661453" translate="yes" xml:space="preserve">
          <source>How many bits fit in the NaN depends on what kind of floating points are being used, but on the most common platforms (64-bit IEEE 754, or the x86 80-bit long doubles) there are 51 and 61 bits available, respectively. (There would be 52 and 62, but the quiet/signaling bit of NaNs takes away one.) However, because of the floating-point-to- integer-and-back conversions, please test carefully whether you get back what you put in. If your integers are only 32 bits wide, you probably should not rely on more than 32 bits of payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8392c4bc182245c6112422d8ac379f29dc0269" translate="yes" xml:space="preserve">
          <source>How many days shall we keep statistics about downloads?</source>
          <target state="translated">다운로드에 대한 통계는 며칠 동안 유지해야합니까?</target>
        </trans-unit>
        <trans-unit id="a2df7a98d6c586141cd04b6aa0105c17934a6b57" translate="yes" xml:space="preserve">
          <source>How many items shall we keep in the statistics about downloads?</source>
          <target state="translated">다운로드 통계에 몇 개의 항목을 보관해야합니까?</target>
        </trans-unit>
        <trans-unit id="a4c476d15c4f91ec82f82f8c5a4b611455926ad6" translate="yes" xml:space="preserve">
          <source>How many things you have to skip over when moving from the beginning of a string or array to a specific position within it. Thus, the minimum offset is zero, not one, because you don&amp;rsquo;t skip anything to get to the first item.</source>
          <target state="translated">문자열이나 배열의 시작 부분에서 특정 위치로 이동할 때 건너 뛰어야 할 항목 수 따라서 첫 번째 항목으로 이동하는 항목을 건너 뛰지 않기 때문에 최소 오프셋은 1이 아니라 0입니다.</target>
        </trans-unit>
        <trans-unit id="e8f69207ec93ea9ac0d7bd7d78ad22c5fad82d93" translate="yes" xml:space="preserve">
          <source>How much memory will an X kb tar file need?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d061df76ab13c25cd39004271d0f48f24f772c" translate="yes" xml:space="preserve">
          <source>How multiple interpreters and concurrency are supported</source>
          <target state="translated">여러 통역사 및 동시성이 지원되는 방법</target>
        </trans-unit>
        <trans-unit id="6077b2c6a621300c72c26286304312a48389905e" translate="yes" xml:space="preserve">
          <source>How often are new versions of Perl released?</source>
          <target state="translated">Perl의 새 버전은 얼마나 자주 출시됩니까?</target>
        </trans-unit>
        <trans-unit id="09667313848c3831b4f83a58be79ca17489cfe27" translate="yes" xml:space="preserve">
          <source>How stable is Perl?</source>
          <target state="translated">Perl은 얼마나 안정적입니까?</target>
        </trans-unit>
        <trans-unit id="83c34a283446a710c37e72f2a9adb47d8902892c" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">해당 문자열을 평가하는 방법은 시스템의 명령 인터프리터에 전적으로 적용됩니다. 대부분의 플랫폼에서 문자 그대로 처리하려면 셸 메타 문자를 보호해야합니다. 어떤 캐릭터를 이스케이프 처리하는 방법이 확실하지 않기 때문에 실제로는 수행하기가 어렵습니다. 백틱을 안전하게 에뮬레이트 하는 수동 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 깨끗하고 안전한 예제는 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eed5100d867c777939bb5769caf179997d17506" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; to emulate backticks safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c335ff6cb2a45884654c99fc61e53c7a376324b" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;declare()&lt;/code&gt; a dotted-decimal version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0814da3e299e49d2449969ad142f5bd55fcc256" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;parse()&lt;/code&gt; a version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e58ed61895689f9ea71e1d65dd7b363842c21f" translate="yes" xml:space="preserve">
          <source>How to Eat an Egg on a Net</source>
          <target state="translated">그물에 계란을 먹는 방법</target>
        </trans-unit>
        <trans-unit id="1e92c63bea5bacbfe17288aa9b727bd5b57d76ef" translate="yes" xml:space="preserve">
          <source>How to Export</source>
          <target state="translated">수출 방법</target>
        </trans-unit>
        <trans-unit id="c94aa75d1f562c0c7126364d18c31a48ccae10ce" translate="yes" xml:space="preserve">
          <source>How to Import</source>
          <target state="translated">가져 오는 방법</target>
        </trans-unit>
        <trans-unit id="66e5306e1ee37b9c8432fab22e675761fdae05d9" translate="yes" xml:space="preserve">
          <source>How to build it - possible changes to Makefile.PL etc.</source>
          <target state="translated">빌드 방법-Makefile.PL 등의 변경 가능</target>
        </trans-unit>
        <trans-unit id="276af2b0e47e1128b2d6988024c5aa973d55b3ad" translate="yes" xml:space="preserve">
          <source>How to check for a legal version string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200eebf37528bcbed0445247c76a5eb54f9e1c23" translate="yes" xml:space="preserve">
          <source>How to compare version objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca504da3ad384a1782b8a80c01519809d8213b8a" translate="yes" xml:space="preserve">
          <source>How to contribute to the perlfaq</source>
          <target state="translated">perlfaq에 기여하는 방법</target>
        </trans-unit>
        <trans-unit id="d80ee544d5d5799659326d52d976ff8d1a12d506" translate="yes" xml:space="preserve">
          <source>How to contribute to this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f26a635f2b0eee95797f21034bacde6a2960b0" translate="yes" xml:space="preserve">
          <source>How to convert a module from decimal to dotted-decimal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59750c3fc03389b5d7028878d6d502ec39f41a63" translate="yes" xml:space="preserve">
          <source>How to create a new module</source>
          <target state="translated">새 모듈을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="4b6cf27d781b549a9ad503d5e122d5adb52f744e" translate="yes" xml:space="preserve">
          <source>How to declare() a dotted-decimal version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117233b2c5097bb47b4e325f79c07984d73d5ef7" translate="yes" xml:space="preserve">
          <source>How to get a package, unwrap it, and make a change before building it?</source>
          <target state="translated">패키지를 가져 와서 포장을 풀고 빌드하기 전에 변경하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="581ecead393f1357725f2a7ad157c2752daf62ea" translate="yes" xml:space="preserve">
          <source>How to install it.</source>
          <target state="translated">설치 방법</target>
        </trans-unit>
        <trans-unit id="6a513660bb1d74aac4457f5e1ad35cd324a50563" translate="yes" xml:space="preserve">
          <source>How to parse() a version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ad195185248d449699ab965e2e195908cc3f7" translate="yes" xml:space="preserve">
          <source>How to release and distribute a module.</source>
          <target state="translated">모듈을 해제하고 배포하는 방법.</target>
        </trans-unit>
        <trans-unit id="fac65371d245ce74fd54b584511aa21b655f4973" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">오류를보고하는 방법 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 모든 POD 형식 오류에 대해 예외를 던지라고 말합니다. &lt;code&gt;stderr&lt;/code&gt; 는 표준 오류에 대한 오류를보고하지만 예외는 발생시키지 말라고 말합니다. &lt;code&gt;pod&lt;/code&gt; 는 결과 문서에 오류를 요약 한 POD ERRORS 섹션을 포함 시키라고 말합니다. &lt;code&gt;none&lt;/code&gt; 은 가능한 한 POD 오류를 완전히 무시 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d8e06e503e624ee14cb08fcb7aa8200b1d1a33be" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;die&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d2e49b42408e54cf7a34c3e80635f480f9c4a8" translate="yes" xml:space="preserve">
          <source>How to use Field Hashes</source>
          <target state="translated">필드 해시 사용법</target>
        </trans-unit>
        <trans-unit id="fc1ff928efd359368d94e6d36c9ac3ed9b57df61" translate="yes" xml:space="preserve">
          <source>How to use ppport.h</source>
          <target state="translated">ppport.h 사용법</target>
        </trans-unit>
        <trans-unit id="76a1aee9e2d87dca5af8b9f3523a520421f66d36" translate="yes" xml:space="preserve">
          <source>How to use the perlfaq</source>
          <target state="translated">perlfaq를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="3f24180ceba0ec0cc68f9d5c0e1e26d52c83ce1f" translate="yes" xml:space="preserve">
          <source>How you access/control keyboards, screens, and pointing devices (&quot;mice&quot;) is system-dependent. Try the following modules:</source>
          <target state="translated">키보드, 화면 및 포인팅 장치 ( &quot;마우스&quot;)에 대한 액세스 / 제어 방법은 시스템에 따라 다릅니다. 다음 모듈을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="4bc300db17dcedeb6194b557a3ba400e45f35668" translate="yes" xml:space="preserve">
          <source>How you choose to license your work is a personal decision. The general mechanism is to assert your Copyright and then make a declaration of how others may copy/use/modify your work.</source>
          <target state="translated">작업 라이센스를 선택하는 방법은 개인적인 결정입니다. 일반적인 메커니즘은 귀하의 저작권을 주장한 다음 다른 사람이 귀하의 저작물을 복사 / 사용 / 수정하는 방법에 대한 선언을하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb2f13a23bf4830d2fc62239cefe549717cd58f6" translate="yes" xml:space="preserve">
          <source>How your various pieces of data relate to each other and what shape they make when you put them all together, as in a rectangular table or a triangular tree.</source>
          <target state="translated">다양한 데이터 조각이 서로 관련되는 방식과 직사각형 테이블 또는 삼각형 트리와 같이 모두 함께 모을 때 만드는 모양</target>
        </trans-unit>
        <trans-unit id="49e45b77d6ea8c9934575389c7d37f20873b7d78" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;change()&lt;/code&gt; inherited from &lt;code&gt;Unicode::Collate&lt;/code&gt; allows such a tailoring that is reserved by &lt;code&gt;locale&lt;/code&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a5d362bff5ef9a53ac39d40f0d72384a7a7980" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;entry&lt;/code&gt; is allowed, even if it is used for &lt;code&gt;locale&lt;/code&gt; support, to add or override mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b89735ac32202767302de6090cfe3b522ac706" translate="yes" xml:space="preserve">
          <source>However adding a Time::Piece object to another Time::Piece object will cause a runtime error.</source>
          <target state="translated">그러나 다른 Time :: Piece 객체에 Time :: Piece 객체를 추가하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30f041c654fc533b28dcc332c81f8669c3b80359" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt; ), even though the same text in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt; .</source>
          <target state="translated">그러나 &lt;code&gt;\&lt;/code&gt; 다음에 문자가 오는 다른 조합은 다음 단계에서 정규 표현식으로 구문 분석하기 위해 대체되지 않고 건너 뜁니다. 마찬가지로 &lt;code&gt;\c&lt;/code&gt; ,이 단계에서 건너 &lt;code&gt;@&lt;/code&gt; 의 &lt;code&gt;\c@&lt;/code&gt; 에서 RE 가능성 (예를 들어, 어레이에 대한 심볼로서 취급된다 &lt;code&gt;@foo&lt;/code&gt; 동일한 텍스트에도) &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 보간 제공 &lt;code&gt;\c@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa46c7dac1006200659c34da5fea0149776dd8d" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt;), even though the same text in &lt;code&gt;qq//&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e29f719714863d70b942d575046dbb5cba98f5" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">그러나 이러한 메소드를 호출하면 데이터 연결을 리턴 할 수있는 위의 메소드 사용에만 영향을줍니다. 메소드 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; 및 데이터 연결이 필요없는 메소드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de13c057041819bc6b844abfeff87d29540cb81e" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd9e96cfe2926dfabdbc85765517e42ef1d89e7" translate="yes" xml:space="preserve">
          <source>However if you use them for methods it is up to you to figure out how to make inheritance work.)</source>
          <target state="translated">그러나 메소드에 사용하면 상속 작업을 수행하는 방법을 결정해야합니다.)</target>
        </trans-unit>
        <trans-unit id="3eb546f277a4853248567d6d99dbadcec1483c0f" translate="yes" xml:space="preserve">
          <source>However it is possible to :</source>
          <target state="translated">그러나 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b048a4ce1b3f69d17018ba3c836a5e60080a819e" translate="yes" xml:space="preserve">
          <source>However the parent classes are set, the package's &lt;code&gt;@ISA&lt;/code&gt; variable will contain a list of those parents. This is simply a list of scalars, each of which is a string that corresponds to a package name.</source>
          <target state="translated">그러나 부모 클래스가 설정되면 패키지의 &lt;code&gt;@ISA&lt;/code&gt; 변수에 해당 부모 목록이 포함됩니다. 이것은 단순히 스칼라 목록이며, 각각은 패키지 이름에 해당하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ba3e62d1138ee32c59c072f255ef49bd8748a854" translate="yes" xml:space="preserve">
          <source>However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</source>
          <target state="translated">그러나 다른 반올림 스타일의 결과는 반올림 위치 바로 오른쪽에있는 자릿수 (소수점 건너 뛰기)가 5이고 그 이후 5 뒤에 숫자가 없거나 0 이외의 숫자가없는 경우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4fbf8823a3b3cfa62eaf7d0dd429a9afbd37439d" translate="yes" xml:space="preserve">
          <source>However the test engine bleeds these message to screen in unexpected moments. Two messages of this kind</source>
          <target state="translated">그러나 테스트 엔진은 예상치 못한 순간에 이러한 메시지를 화면에 표시합니다. 이런 종류의 두 가지 메시지</target>
        </trans-unit>
        <trans-unit id="ef8fc937e43b67ff40714fcd8d7fd4e3c6c06fbf" translate="yes" xml:space="preserve">
          <source>However you should never rely on the numerical position of any opcode within the opset. In other words both sides of a bit vector operator should be opsets returned from Opcode functions.</source>
          <target state="translated">그러나 옵셋 내에서 opcode의 숫자 위치에 의존해서는 안됩니다. 즉, 비트 벡터 연산자의 양쪽은 Opcode 함수에서 반환 된 opset이어야합니다.</target>
        </trans-unit>
        <trans-unit id="553943043c049c659e40aebd03db5306b0148501" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;sudo&lt;/code&gt; sets the real user or group ID to that of the target identity, not just the effective ID as set-id bits do. As a result, Perl can't detect that it is running under &lt;code&gt;sudo&lt;/code&gt;, and so won't automatically take its own security precautions such as turning on taint mode. Where &lt;code&gt;sudo&lt;/code&gt; configuration dictates exactly which command can be run, the approved command may include a &lt;code&gt;-T&lt;/code&gt; option to perl to enable taint mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98648e73024116127cb39bd5de118b8a0a2cc6ca" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">그러나 Filter :: Simple은 기존 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 하고 올바른 작업 을 수행 할 수있을 정도로 똑똑 합니다. 즉, Filter :: Simple을 사용하는 패키지에서 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 을 명시 적으로 정의하면 필터를 설치 한 직후에도 해당 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d3a8dddc21154e6d620bf1f1a45edff899ff21" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;import&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;import&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;import&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b48fb21a2bbb8cdba9c4ae239ab0a9635d85aa" translate="yes" xml:space="preserve">
          <source>However, Perl supports Unicode, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">그러나 Perl은 유니 코드를 지원합니다 ( &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="0a6f0fb90e2229030c78d6a2fabfcae7c71bc14e" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nbsp_for_S&lt;/code&gt; option which, if enabled, will suppress all S events, and instead change all spaces in the content to non-breaking spaces. This is intended for formatters that output to a format that has no code that means the same as S&amp;lt;...&amp;gt;, but which has a code/character that means non-breaking space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf2ba42f69a41e6f42882a675ee34d4602093f3" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nix_X_codes&lt;/code&gt; option which, if enabled, will suppress all X events and ignore their content. For formatters/processors that don't use X events, this is presumably quite useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aacf8e8d0ef0c63358a4dd55406f6405076e03d" translate="yes" xml:space="preserve">
          <source>However, a dynamically loaded Perl extension is forced to use some symbols from the perl executable, e.g., to know how to find the arguments to the functions: the arguments live on the perl internal evaluation stack. The solution is to put the main code of the interpreter into a DLL, and make the</source>
          <target state="translated">그러나 동적으로로드 된 Perl 확장은 perl 실행 파일의 일부 기호를 사용하여 함수에 대한 인수를 찾는 방법을 알아야합니다. 인수는 Perl 내부 평가 스택에 있습니다. 해결책은 인터프리터의 주요 코드를 DLL에 넣고</target>
        </trans-unit>
        <trans-unit id="cb42fd65a00722a5c95e1e740839f3eb31964f36" translate="yes" xml:space="preserve">
          <source>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</source>
          <target state="translated">그러나 잘못 적용된 NBSP 대체는 다음과 같은 것을 잘못 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81448f13f8166a4612eb5d956580cdb8ee3e6da5" translate="yes" xml:space="preserve">
          <source>However, a value assigned to &lt;code&gt;$(&lt;/code&gt; must be a single number used to set the real gid. So the value given by &lt;code&gt;$(&lt;/code&gt; should</source>
          <target state="translated">그러나 &lt;code&gt;$(&lt;/code&gt; 할당 된 값 은 실제 gid를 설정하는 데 사용되는 단일 숫자 여야합니다. 따라서 &lt;code&gt;$(&lt;/code&gt; 의해 주어진 값 은</target>
        </trans-unit>
        <trans-unit id="2623bb5aade26c0a0ddb97e7e99b8d0d79bed6e1" translate="yes" xml:space="preserve">
          <source>However, anyone particularly interested in getting the full value of the treelet, can just traverse the content of the treeleet @$treelet_object. To wit:</source>
          <target state="translated">그러나 트리 릿의 전체 가치를 얻는 데 특히 관심이있는 사람은 treeleet @ $ treelet_object의 내용을 통과 할 수 있습니다. 재치 :</target>
        </trans-unit>
        <trans-unit id="120fef724fd1ad9704e66311dce9e65e6c74f159" translate="yes" xml:space="preserve">
          <source>However, as an 80% solution it is still effective, as it has caught bugs in the past.</source>
          <target state="translated">그러나 80 % 솔루션으로 과거에는 버그를 발견 했으므로 여전히 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="9b024ed706553b3e26fb5776910e94a5d18ec48c" translate="yes" xml:space="preserve">
          <source>However, be aware this will delete ALL untracked content. You can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3b493b7bf70efb7fa8d258ead45b41c49f7ae9" translate="yes" xml:space="preserve">
          <source>However, because there are</source>
          <target state="translated">그러나 있기 때문에</target>
        </trans-unit>
        <trans-unit id="4c76c10ddfa1b1106d8945288c840e976b5200f2" translate="yes" xml:space="preserve">
          <source>However, before calling Configure, you need to check if using adb is a viable choice in the first place. Because Android doesn't have a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4c0892873afe913676eee2f3455aa2ddb34a7e" translate="yes" xml:space="preserve">
          <source>However, between perl v5.10.0 and v5.24.0, it could be used lexically by writing &lt;code&gt;my $_&lt;/code&gt;. Making &lt;code&gt;$_&lt;/code&gt; refer to the global &lt;code&gt;$_&lt;/code&gt; in the same scope was then possible with &lt;code&gt;our $_&lt;/code&gt;. This experimental feature was removed and is now a fatal error, but you may encounter it in older code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd72d7b069cc72d81b73b3f8597e881a55bd64a6" translate="yes" xml:space="preserve">
          <source>However, calling any &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; methods in such an &lt;code&gt;END&lt;/code&gt; block will most likely</source>
          <target state="translated">그러나 이러한 &lt;code&gt;END&lt;/code&gt; 블록 에서 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 메소드를 호출 하면 대부분</target>
        </trans-unit>
        <trans-unit id="4d2c94143c1c2488e5582ae3924e1321e1fc2e29" translate="yes" xml:space="preserve">
          <source>However, everything referenced by the returned value is a fresh copy in the joining thread, even if a returned object had in the child thread been a copy of something that previously existed in the parent thread. After joining, the parent will therefore have a duplicate of each such object. This sometimes matters, especially if the object gets mutated; this can especially matter for private data to which a returned subroutine provides access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c314b40d0f00ce73038bbcc98e7f0ca7b1457690" translate="yes" xml:space="preserve">
          <source>However, for the following, the items are already shared, so their references are added directly to the queue, and no cloning takes place:</source>
          <target state="translated">그러나 다음의 경우 항목이 이미 공유되므로 해당 참조가 큐에 직접 추가되며 복제가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc1303f64a141ea4136f512c4911ecba9b92d10" translate="yes" xml:space="preserve">
          <source>However, for the one-off simple case where I don't want to pull out a full templating system, I'll use a string that has two Perl scalar variables in it. In this example, I want to expand &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;$bar&lt;/code&gt; to their variable's values:</source>
          <target state="translated">그러나 전체 템플릿 시스템을 꺼내고 싶지 않은 일회성 간단한 경우에는 두 개의 Perl 스칼라 변수가있는 문자열을 사용합니다. 이 예에서는 &lt;code&gt;$foo&lt;/code&gt; 및 &lt;code&gt;$bar&lt;/code&gt; 를 변수 값 으로 확장하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="5ff029079aabc6f922c78c4701467310a318c5e3" translate="yes" xml:space="preserve">
          <source>However, if a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt; -marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding. (&lt;code&gt;BOM&lt;/code&gt; -less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</source>
          <target state="translated">그러나 Perl 스크립트가 유니 코드 &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE 또는 UTF-8)으로 시작하거나 스크립트가 비 엔디안의 &lt;code&gt;BOM&lt;/code&gt; 이 아닌 UTF-16으로 표시되면 Perl은 적절한 유니 코드 인코딩으로 스크립트를 작성하십시오. ( &lt;code&gt;BOM&lt;/code&gt; - 덜 UTF-8을 효과적으로 인식 또는 ISO 8859-1 또는 다른 8 비트 인코딩을 구별 할 수 없다.)</target>
        </trans-unit>
        <trans-unit id="7a530119f7016cecda2473b0ac614ce58e818515" translate="yes" xml:space="preserve">
          <source>However, if a particular species of quote character is included in the delimiter specification, then that type of quote will be correctly handled. for example, if &lt;code&gt;$text&lt;/code&gt; is:</source>
          <target state="translated">그러나 특정 종의 인용 문자가 구분 기호 스펙에 포함되어 있으면 해당 인용 유형이 올바르게 처리됩니다. 예를 들어 &lt;code&gt;$text&lt;/code&gt; 가 다음 과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="9e2ebae72b3d33fdf44dedb85d641ca00f3f57a1" translate="yes" xml:space="preserve">
          <source>However, if all you want to do is change your time zone, you can probably get away with setting an environment variable:</source>
          <target state="translated">그러나 시간대를 변경하기 만하면 환경 변수를 설정하여 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12d8527d56fa8ab8e8667f75a93e6392109725d" translate="yes" xml:space="preserve">
          <source>However, if hitting EOF is an expected and normal event, you do not want to exit simply because you have run out of input. Instead, you probably just want to exit an input loop. You can then test to see if an actual error has caused the loop to terminate, and act accordingly:</source>
          <target state="translated">그러나 EOF 적중이 예상되는 정상적인 이벤트 인 경우 입력이 부족하여 종료하지 않으려 고합니다. 대신 입력 루프를 종료하고 싶을 것입니다. 그런 다음 실제 오류로 인해 루프가 종료되었는지 확인하고 그에 따라 조치를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e1fafc250caebd597211caeac2164bfd06193d" translate="yes" xml:space="preserve">
          <source>However, if the &lt;code&gt;]&lt;/code&gt; is the</source>
          <target state="translated">그러나 &lt;code&gt;]&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="8b420ee9db4dd8d8741d24e9570ff42a7cdea42c" translate="yes" xml:space="preserve">
          <source>However, if the command contained arguments that contained whitespace, stringifying the command would lose the significance of the whitespace. Therefore, &lt;code&gt;IPC::Cmd&lt;/code&gt; will quote any arguments containing whitespace in your command if the command is passed as an arrayref and contains special characters.</source>
          <target state="translated">그러나 명령에 공백이 포함 된 인수가 포함 된 경우 명령을 문자열 화하면 공백의 중요성이 없어집니다. 따라서 명령이 arrayref로 전달되고 특수 문자가 포함 된 경우 &lt;code&gt;IPC::Cmd&lt;/code&gt; 는 명령에 공백을 포함하는 인수를 인용합니다.</target>
        </trans-unit>
        <trans-unit id="6cc1c4bf7e539678ba51b5fda046a8f31ec28dde" translate="yes" xml:space="preserve">
          <source>However, if the data can't be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</source>
          <target state="translated">그러나 데이터를 유효한 Perl로 구문 분석 할 수 없으면 해석되지 않은 문자열로 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="713c4744650ad1f6870512c16d626634ea8370be" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">그러나 입력 텍스트가 변수로 전달 된 경우 해당 변수의 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 값이 추출 된 텍스트 다음의 첫 문자를 가리 키도록 업데이트됩니다. 이는리스트 컨텍스트에서 다양한 서브 루틴이 정규 표현식과 매우 유사하게 사용될 수 있음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95b66c82de22ae75797335cbe11c9ea09bb6550e" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;pos&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755d5a289c3e42c14904a4a718307f0b6e480799" translate="yes" xml:space="preserve">
          <source>However, if the kernel set-id script feature isn't disabled, Perl will complain loudly that your set-id script is insecure. You'll need to either disable the kernel set-id script feature, or put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">그러나 커널 set-id 스크립트 기능이 비활성화되어 있지 않으면 Perl은 set-id 스크립트가 안전하지 않다고 크게 불평합니다. 커널 set-id 스크립트 기능을 비활성화하거나 스크립트 주위에 C 래퍼를 배치해야합니다. AC 래퍼는 Perl 프로그램을 호출하는 것 외에는 아무것도하지 않는 컴파일 된 프로그램입니다. 컴파일 된 프로그램은 set-id 스크립트를 괴롭히는 커널 버그의 영향을받지 않습니다. 다음은 C로 작성된 간단한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="cbc9ddee054ab9351fcec45d24db4192d4d2775c" translate="yes" xml:space="preserve">
          <source>However, if the list element is itself a variable, it appears that you can change a list element. However, the list element is the variable, not the data. You're not changing the list element, but something the list element refers to. The list element itself doesn't change: it's still the same variable.</source>
          <target state="translated">그러나 목록 요소 자체가 변수 인 경우 목록 요소를 변경할 수있는 것으로 나타납니다. 그러나 list 요소는 데이터가 아니라 변수입니다. 목록 요소를 변경하지 않고 목록 요소가 참조하는 것입니다. 목록 요소 자체는 변경되지 않습니다. 여전히 동일한 변수입니다.</target>
        </trans-unit>
        <trans-unit id="1ff33c873357001776962a640d53584ca4867e68" translate="yes" xml:space="preserve">
          <source>However, if the string value associated with &amp;lt;reject&amp;gt; is &quot;MAX&quot;, then &lt;code&gt;extract_tagged&lt;/code&gt; returns the complete text up to the point of failure. If the string is &quot;PARA&quot;, &lt;code&gt;extract_tagged&lt;/code&gt; returns only the first paragraph after the tag (up to the first line that is either empty or contains only whitespace characters). If the string is &quot;&quot;, the the default behaviour (i.e. failure) is reinstated.</source>
          <target state="translated">그러나 &amp;lt;reject&amp;gt;와 연관된 문자열 값이 &quot;MAX&quot;인 경우 &lt;code&gt;extract_tagged&lt;/code&gt; 는 전체 텍스트를 실패 지점까지 리턴합니다. 문자열이 &quot;PARA&quot;인 경우 &lt;code&gt;extract_tagged&lt;/code&gt; 는 태그 다음의 첫 번째 단락 (공백이거나 공백 문자 만 포함하는 첫 번째 줄까지) 만 반환합니다. 문자열이 &quot;&quot;이면 기본 동작 (예 : 실패)이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a40e24fb0252cc9815324344313381a888c122c8" translate="yes" xml:space="preserve">
          <source>However, if there is no matching &lt;code&gt;}&lt;/code&gt;, Perl doesn't know if it was mistakenly omitted, or if &lt;code&gt;[^\n]{&lt;/code&gt; was desired, and raises this error. If you meant the former, add the right brace; if you meant the latter, escape the brace with a backslash, like so: &lt;code&gt;\N\{&lt;/code&gt;</source>
          <target state="translated">그러나 일치하는 &lt;code&gt;}&lt;/code&gt; 이 없으면 Perl은 실수로 생략되었는지 또는 &lt;code&gt;[^\n]{&lt;/code&gt; 을 (를) 원하는지 알 수 없으므로이 오류가 발생합니다. 전자를 의미한다면 올바른 버팀대를 추가하십시오. 후자를 의미하는 경우 다음과 같이 백 슬래시로 중괄호를 이스케이프하십시오. &lt;code&gt;\N\{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4db7ce89f0ac0ff04237db2ffe65056106401da4" translate="yes" xml:space="preserve">
          <source>However, if you have fixed sized records, then you might do something more like this:</source>
          <target state="translated">그러나 고정 된 레코드 크기를 가진 경우 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a31e0971a11a0c1d822f02efd0eb4f79c74f3a" translate="yes" xml:space="preserve">
          <source>However, if you set &quot;_AUTO =&amp;gt; 1&quot; in the %Lexicon in, ThisProject/I18N/en.pm (assuming that English (en) is the language that all your programmers will be using for this project's internal message keys), then you don't ever have to go adding lines like this</source>
          <target state="translated">그러나 % Lexicon in, ThisProject / I18N / en.pm에서 &quot;_AUTO =&amp;gt; 1&quot;을 설정하면 (영어 (en)는 모든 프로그래머가이 프로젝트의 내부 메시지 키에 사용하는 언어라고 가정) 이런 식으로 줄을 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a09363cd76b1dde7e3a57d25fdf3272ced3af2ab" translate="yes" xml:space="preserve">
          <source>However, if you want the old behavior (and think carefully about that because it's a weird side effect), you can pass a hash slice instead. Perl 5.004 didn't make this a special case:</source>
          <target state="translated">그러나 이전 동작을 원한다면 (그리고 이상한 부작용이기 때문에 신중하게 생각하면) 대신 해시 슬라이스를 전달할 수 있습니다. Perl 5.004는 이것을 특별한 경우로 만들지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e5e7624dee9866ac2811666ebfbf093d8c557c15" translate="yes" xml:space="preserve">
          <source>However, if you'd like to override that just for perl, execute something like the following in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bcfc80dafa07d27c313feb7344f54609aa72b0" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt; , you can produce a diff like this:</source>
          <target state="translated">그러나 git을 사용하지 않는 경우에도 여전히 적절한 패치를 생성 할 수 있습니다. 비교해 보려면 펄 소스의 깨끗한 사본이 필요합니다. 포터들은 통일 된 차이를 선호합니다. GNU &lt;code&gt;diff&lt;/code&gt; 를 사용 하면 다음과 같은 diff를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3945c60d94533987656e9ddcf44eefd8a3f5cf4" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt;, you can produce a diff like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912422cfe6349f661271a697889a1ce04bbb7530" translate="yes" xml:space="preserve">
          <source>However, in list context, the line input operator returns all of the lines as a list. The first line goes into &lt;code&gt;@array[1]&lt;/code&gt; and the rest of the lines mysteriously disappear:</source>
          <target state="translated">그러나 목록 컨텍스트에서 행 입력 연산자는 모든 행을 목록으로 리턴합니다. 첫 번째 줄은 &lt;code&gt;@array[1]&lt;/code&gt; 로 들어가고 나머지 줄은 신비롭게 사라집니다.</target>
        </trans-unit>
        <trans-unit id="a4cbc737f6445190a51915b10ef52747baeb38d6" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt; : it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt; ) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt; . Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">그러나 &lt;code&gt;LANGUAGE&lt;/code&gt; 를 사용하는 경우 명령에 의해 출력되는 정보, 경고 및 오류 메시지의 언어 (즉, &lt;code&gt;LC_MESSAGES&lt;/code&gt; 와 유사 함 )에 영향을 주지만 &lt;code&gt;LC_ALL&lt;/code&gt; 보다 우선 순위가 높습니다 . 또한 단일 값이 아니라 &quot;경로&quot;( &quot;:&quot;로 구분 된 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="7b6e0b1c8600ac9825ba07e5dbd49e2921e845b8" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt;: it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt;) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt;. Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264a100caceb32bafbc7cc09c2eb6cec03b010a6" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdfb88ca6aeb7caca106e8a86ebad4a7bd611554" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">그러나 &lt;code&gt;is_deeply()&lt;/code&gt; 와 같은 함수를 사용하여 문자열 오버로드 된 객체의 내부를 테스트 할 수는 없습니다. 이 경우 복잡한 데이터 구조에 대해 더 유연한 테스트 기능을 포함 하는 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test :: Deep&lt;/a&gt; 을 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="4b56d396ba6f1980056b816ee33f44e386574d54" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">그러나 Perl 스레드는 운영 체제의 스레드가 허용하지 않는 한 마술처럼 작업을 수행 할 수 없다는 것을 기억해야합니다. 따라서 시스템이 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 에서 전체 프로세스를 차단하면 일반적으로 Perl도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="13d58a858b7bda780cb252aafbed51984ace596c" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;sleep()&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9bc751c2a736800a6ded071584d5744291603c" translate="yes" xml:space="preserve">
          <source>However, it is possible to set up attribute handlers that are called at other points in the program's compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</source>
          <target state="translated">그러나 속성 핸들러를 호출 할 단계를 명시 적으로 지정하여 프로그램 컴파일 또는 실행의 다른 지점에서 호출되는 속성 핸들러를 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f3f862372589763b899aeb3b91931550dc55057" translate="yes" xml:space="preserve">
          <source>However, it may happen that parsing must be restarted at the beginning when various circumstances occur along the way. An example is if the program turns out to be so large that there are jumps in it that won't fit in the normal 16 bits available. There are two special regops that can hold bigger jump destinations, BRANCHJ and LONGBRANCH. The parse is restarted, and these are used instead of the normal shorter ones. Whenever restarting the parse is required, the function returns failure and sets a flag as to what needs to be done. This is passed up to the top level routine which takes the appropriate action and restarts from scratch. In the case of needing longer jumps, the &lt;code&gt;RExC_use_BRANCHJ&lt;/code&gt; flag is set in the &lt;code&gt;RExC_state_t&lt;/code&gt; structure, which the functions know to inspect before deciding how to do branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495f4657c76d2b9516ad67652bc58b23f23940a2" translate="yes" xml:space="preserve">
          <source>However, it would be unwise to write tests such as:</source>
          <target state="translated">그러나 다음과 같은 테스트를 작성하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b30399fa602102d2334ab528f7c1b9ececea8d0d" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt; :</source>
          <target state="translated">그러나이 순서대로 작업 을 &lt;b&gt;수행&lt;/b&gt; 하는 것은 불가능 합니다. 예를 들어 &lt;code&gt;$b&lt;/code&gt; 와 &lt;code&gt;$c&lt;/code&gt; 를 함께 추가하기 전에 값을 찾아야합니다 . 따라서 op 트리를 통해 실행되는 다른 스레드는 실행 순서입니다. 각 op에는 다음 op가 실행될 &lt;code&gt;op_next&lt;/code&gt; 필드가 있으므로이 포인터를 따르면 perl이 코드를 실행하는 방법을 알 수 있습니다. &lt;code&gt;B::Terse&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여이 순서대로 트리를 순회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c7146a5076741d60fd0b54759165e4d154c0a24" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;exec&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a82c6ab7917617f6a85766c8d2b1d78c8def0" translate="yes" xml:space="preserve">
          <source>However, it's possible to have distinct files in different directories that intentionally has the same name, just differing in case, that should be reported. Hence, you may force the behavior by setting this to true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3fd83f97cb972df229bb4d55a4c188b477d626" translate="yes" xml:space="preserve">
          <source>However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings. Here's a simple example being:</source>
          <target state="translated">그러나 오랜 경험에 따르면 길이가 0 인 하위 문자열과 일치 할 수있는 반복 된 하위 표현식을 사용하면 많은 프로그래밍 작업이 크게 단순화 될 수 있습니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="d855fdc3242b3ecead3a30530ccd98509a636a5c" translate="yes" xml:space="preserve">
          <source>However, not everything you can write in Perl code can be written in the above shorthand system -- not by a long shot. For example, consider the Italian translator from the beginning of this article, who wanted the Italian for &quot;I didn't find any files&quot; as a special case, instead of &quot;I found 0 files&quot;. That couldn't be specified (at least not easily or simply) in our shorthand system, and it would have to be written out in full, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc9947a9b58d2f4b1cd78cbf550721e43e5ecea" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt; . If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">그러나 &lt;code&gt;sv_unmagic&lt;/code&gt; 은 &lt;code&gt;SV&lt;/code&gt; 에서 특정 &lt;code&gt;type&lt;/code&gt; 의 모든 마술을 제거합니다 . 매직 가상 테이블을 기반으로 특정 &lt;code&gt;type&lt;/code&gt; 매직 만 제거 하려면 대신 &lt;code&gt;sv_unmagicext&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="755c4cc30c87595f07d149af2b7b703fd4c79822" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt;. If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0770ad99650293f49eefd8e2631959530003f02" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;use encoding&lt;/code&gt; actually had three distinct effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3714710035618507b561178df5f82b541c8974c8" translate="yes" xml:space="preserve">
          <source>However, note that even as the specified layers are &quot;pushed on top&quot; for open() and binmode(), this doesn't mean that the effects are limited to the &quot;top&quot;: PerlIO layers can be very 'active' and inspect and affect layers also deeper in the stack. As an example there is a layer called &quot;raw&quot; which repeatedly &quot;pops&quot; layers until it reaches the first layer that has declared itself capable of handling binary data. The &quot;pushed&quot; layers are processed in left-to-right order.</source>
          <target state="translated">그러나 지정된 레이어가 open () 및 binmode ()에 대해 &quot;맨 위로 푸시&quot;되더라도 효과가 &quot;맨 위&quot;로 제한되는 것은 아닙니다. PerlIO 레이어는 매우 '활성'일 수 있습니다. 스택에서 더 깊이있는 레이어에 영향을줍니다. 예를 들어 이진 데이터를 처리 할 수 ​​있다고 선언 한 첫 번째 레이어에 도달 할 때까지 레이어를 반복적으로 &quot;팝핑&quot;하는 &quot;raw&quot;라는 레이어가 있습니다. &quot;푸시 된&quot;레이어는 왼쪽에서 오른쪽 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e68001f4c648450ca168ec0cde1c3f91a0e8624c" translate="yes" xml:space="preserve">
          <source>However, on Windows systems this isn't quite true prior to Visual Studio 15, at which point Microsoft fixed a bug. A race can occur if you use the following operations on earlier Windows platforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237e671ead4e4f448bac6dfef4927434cec18095" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">그러나 이전 Perls에서 또는 기능 범위 밖의 서브 루틴에 문자열을 전달하는 경우 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 을 수행하여 인코딩을 UTF-8로 변경하여 유니 코드 규칙을 강제 실행할 수 있습니다 . 이미 업그레이드 된 문자열을 확인하고 변경하지 않으므로 모든 문자열에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e3115d2c9ec337c66cb9d3c294ddc900febcb1" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt;. This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d790ef4b7b652054f8ef9f08eabcfceb4c9c9d7" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt; ):</source>
          <target state="translated">그러나 큰 따옴표 만 &quot;보간&quot;변수와 개행 ( &lt;code&gt;\n&lt;/code&gt; ) 과 같은 특수 문자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e743ca902ceb7982199b34d10b972ebd948b6061" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4f7d0c2e35a50b2d5589c3de0999f54d0755a9" translate="yes" xml:space="preserve">
          <source>However, other accidents of history have made Perl a well-accepted language for design of server-side programs (generally in CGI form) for Web site interfaces. Localization of static pages in Web sites is trivial, feasible either with simple language-negotiation features in servers like Apache, or with some kind of server-side inclusions of language-appropriate text into layout templates. However, I think that the localization of Perl-based search systems (or other kinds of dynamic content) in Web sites, be they public or access-restricted, is where Maketext will see the greatest use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f40951889d3378b60336de3c7c19a48f84efe15" translate="yes" xml:space="preserve">
          <source>However, over the years, changes in gcc, GNU ld, and Solaris ld have made it difficult to automatically detect which ld ultimately gets called. You may have to manually edit config.sh and add the -Wl,-E flags yourself, or else run Configure interactively and add the flags at the appropriate prompts.</source>
          <target state="translated">그러나 수년 동안 gcc, GNU ld 및 Solaris ld의 변경으로 인해 어떤 ld가 궁극적으로 호출되는지 자동으로 감지하기가 어려워졌습니다. config.sh를 수동으로 편집하고 -Wl, -E 플래그를 직접 추가하거나 대화식으로 구성을 실행하고 적절한 프롬프트에서 플래그를 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed61c8dd1afaf8e79d8960756c0fdb435ad95dc" translate="yes" xml:space="preserve">
          <source>However, people often either forget to add &lt;code&gt;BEGIN&lt;/code&gt;, or mistakenly group &lt;code&gt;use_ok&lt;/code&gt; with other tests in a single &lt;code&gt;BEGIN&lt;/code&gt; block, which can create subtle differences in execution order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abae8990eb0eaeb22dbcaa2121181a9c3213635" translate="yes" xml:space="preserve">
          <source>However, since I am running a very recent Hurd snapshot, in which a lot of bugs that were exposed by the Perl test suite have been fixed, you may encounter more failures. Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</source>
          <target state="translated">그러나 Perl 테스트 스위트에 의해 노출 된 많은 버그가 수정 된 최신 Hurd 스냅 샷을 실행 중이므로 더 많은 오류가 발생할 수 있습니다. 후보는 &quot;op / stat&quot;, &quot;lib / io_pipe&quot;, &quot;lib / io_sock&quot;, &quot;lib / io_udp&quot;및 &quot;lib / time&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0a2932991138cff6cda965e1aa59120419d51793" translate="yes" xml:space="preserve">
          <source>However, since prototype checking happens at compile time, the assignment above happens too late to be of much use. You could address this by putting the whole loop of assignments within a BEGIN block, forcing it to occur during compilation.</source>
          <target state="translated">그러나 프로토 타입 검사는 컴파일 타임에 수행되므로 위의 과제는 너무 늦어서 많이 사용되지 않습니다. BEGIN 블록 내에 전체 할당 루프를 배치하여 컴파일 중에 발생하도록하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f30360d0680e8617d8855ae3da4bf95cb66d3a40" translate="yes" xml:space="preserve">
          <source>However, since the name is not used by perl except as the return value of &lt;code&gt;caller&lt;/code&gt;, for stack traces or similar, there is no actual requirement that the name be syntactically valid as a perl function name. This could be used to attach extra information that could be useful in debugging stack traces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dc0373ab5a69dc9065fd1361f3fe68378bd857" translate="yes" xml:space="preserve">
          <source>However, some people find that code harder to read than writing it with parentheses:</source>
          <target state="translated">그러나 일부 사람들은 괄호로 코드를 작성하는 것보다 코드를 읽기가 어렵다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b290a654499ed3de25fe105a7a5f328394110489" translate="yes" xml:space="preserve">
          <source>However, strings composed purely of ASCII code points (&lt;code&gt;0x00&lt;/code&gt;..&lt;code&gt;0x7F&lt;/code&gt;) will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f317ee43849ba21e4562b2cfcaf42b63f23a8" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt; , shows up:</source>
          <target state="translated">그러나 줄 끝이 줄 바꿈이 아닌 경우 작동하지 않습니다. 해당 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; /// 로 변경 하여 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; 가 표시 되는 횟수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9245af6fccc9a0ce411947a6accfc71a28fd8594" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;tr///&lt;/code&gt; to a &lt;code&gt;s///&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt;, shows up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8d86d9a6fdf31c1cce87bc99b477e123d4270e" translate="yes" xml:space="preserve">
          <source>However, the &lt;b&gt;.ph&lt;/b&gt; files almost double in size when built using &lt;b&gt;-h&lt;/b&gt;.</source>
          <target state="translated">그러나 &lt;b&gt;-h를&lt;/b&gt; 사용하여 빌드 하면 &lt;b&gt;.ph&lt;/b&gt; 파일의 크기가 거의 두 배가됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf442c2f732fb4fe8240d9ec730b9c9278986a2a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;Filter =&amp;gt; 1&lt;/code&gt; flavor of &lt;code&gt;use encoding&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf1c5152a0ddfa7cc0b45d1130d02f94e11246a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;W&lt;/code&gt; specifier does operate on whole characters, as does the &lt;code&gt;U&lt;/code&gt; specifier.</source>
          <target state="translated">그러나 &lt;code&gt;W&lt;/code&gt; 지정자는 &lt;code&gt;U&lt;/code&gt; 지정자 와 마찬가지로 전체 문자에서 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3da026c415acace03626d9fb7e1ee90aa243fe42" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">그러나 위의 사용법은 프로그램 전체에 전역 변수를 생성하므로 프로그래밍이 잘못됩니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 사 전적으로 대신 변수를 범위 작성합니다. 변수는 블록이 정의 된 블록 (즉, 중괄호로 묶은 여러 문장)으로 범위가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="38d3383a6acfe85a3e5c76aa619706a45144742d" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;my&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a041fd9ed4a1cc9a27e266960cf76f5cd2574980" translate="yes" xml:space="preserve">
          <source>However, the behaviour it enables is always performed by &lt;code&gt;IO::Socket::IP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643bcb3d157afa153f651f6fc7ccfed78f3e704a" translate="yes" xml:space="preserve">
          <source>However, the call in:</source>
          <target state="translated">그러나 전화 :</target>
        </trans-unit>
        <trans-unit id="5357a547fd30e714675256546afb934f7d52ca74" translate="yes" xml:space="preserve">
          <source>However, the ever-increasing internationalization of the Web (whether measured in terms of amount of content, of numbers of content writers or programmers, or of size of content audiences) makes it increasingly likely that the interface to the average Web-based dynamic content service will be localized for two or maybe three languages. It is my hope that Maketext will make that task as simple as possible, and will remove previous barriers to localization for languages dissimilar to English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ecfcc25810d7a7cdf5b6a2a73a83af471c9442" translate="yes" xml:space="preserve">
          <source>However, the generated Perl function is called in very C-ish style:</source>
          <target state="translated">그러나 생성 된 Perl 함수는 매우 C-ish 스타일로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="be1c834c7d4d71f52243b42559f80aabe198a844" translate="yes" xml:space="preserve">
          <source>However, the matching position of the input variable would be set to &quot;exit;&quot; (i.e.</source>
          <target state="translated">그러나 입력 변수의 일치 위치는 &quot;exit;&quot;로 설정됩니다. (즉</target>
        </trans-unit>
        <trans-unit id="25bf3d063af8542ff55fc69607480626e4cfa1dd" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized or assigned to. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95f0313fce5fa0d84ae8a729df3c8f4e82e2159" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized, deleted or used in assignment. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">그러나 이러한 슬라이스의 결과는 지역화, 삭제 또는 할당에 사용할 수 없습니다. 그렇지 않으면 @ 기호를 사용하는 해시 슬라이스와 매우 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c017b28f94bbc1527d3a99433c0d70601c0484be" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt; .</source>
          <target state="translated">그러나 바로 가기에는 정확히 두 개의 명령 줄 인수 인 &lt;code&gt;indirs&lt;/code&gt; 및 &lt;code&gt;outdir&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b66f8dabd20676d1be94167c3e3005cd50687163" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8789f7d9a0995a0db12e65eee11cc6c52128e982" translate="yes" xml:space="preserve">
          <source>However, the use of bare v-strings to initialize version objects is &lt;b&gt;strongly&lt;/b&gt; discouraged in all circumstances. Also, bare v-strings are not completely supported in any version of Perl prior to 5.8.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5988e176ff20437ccf0016e7e2f8d1b308901fa5" translate="yes" xml:space="preserve">
          <source>However, the way a programmer should think about references is not so much in terms of the bare reference count, but in terms of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174d3b644e004445441e24cae4b9fd65f9fed124" translate="yes" xml:space="preserve">
          <source>However, their are many, many other differences. For example, this works in Perl 5:</source>
          <target state="translated">그러나 그것들은 많은 다른 많은 차이점입니다. 예를 들어, 이것은 Perl 5에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="431ca5f68339a06fd3a547e35432cecf8dddda74" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt; . They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt; . Prior to v5.20, It is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; --</source>
          <target state="translated">그러나 이것이 고장난 곳이 있습니다. 특정 Perl 구성은 &lt;code&gt;\p{Alpha}&lt;/code&gt; 와 같은 유니 코드 전용 입니다. 그들은 0xD7이 항상 유니 코드 의미 (또는 EBCDIC 플랫폼에서 동등한 의미)를 가지고 있다고 가정합니다. Latin1은 유니 코드의 하위 집합이고 0xD7은 Latin1과 유니 코드의 곱셈 부호이므로 &lt;code&gt;\p{Alpha}&lt;/code&gt; 는 로캘에 관계없이 일치하지 않습니다. &lt;code&gt;\N{...}&lt;/code&gt; 에서도 비슷한 문제가 발생합니다 . 이전 v5.20에 따라서 사용하는 나쁜 생각 &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\N{}&lt;/code&gt; 일반에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="bfffc2a487e4695cb332617a58fbff944ca5de8f" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt;. They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt;. Prior to v5.20, it is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;use locale&lt;/code&gt;--</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a79d341666f9d08432041587a457666ea4e643" translate="yes" xml:space="preserve">
          <source>However, there is a third way: perl DLL exports the main() function and several callbacks to customize the search path. Below is a complete example of a &quot;Perl loader&quot; which</source>
          <target state="translated">그러나 세 번째 방법이 있습니다. perl DLL은 main () 함수와 여러 콜백을 내보내 검색 경로를 사용자 정의합니다. 아래는 &quot;펄 로더&quot;의 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="167fa8624f523d65d674923630d20eace6f440ad" translate="yes" xml:space="preserve">
          <source>However, there is one other function which manipulates the reference count of its argument. The &lt;code&gt;newRV_inc&lt;/code&gt; function, you will recall, creates a reference to the specified argument. As a side effect, it increments the argument's reference count. If this is not what you want, use &lt;code&gt;newRV_noinc&lt;/code&gt; instead.</source>
          <target state="translated">그러나 인수의 참조 횟수를 조작하는 다른 함수가 있습니다. &lt;code&gt;newRV_inc&lt;/code&gt; 의 기능은, 당신을 기억합니다, 지정된 인수에 대한 참조를 만듭니다. 부작용으로 인수의 참조 횟수가 증가합니다. 이것이 원하는 것이 &lt;code&gt;newRV_noinc&lt;/code&gt; 대신 newRV_noinc를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a934c497d33c3b96a41f7573fdbc88756bd17bf7" translate="yes" xml:space="preserve">
          <source>However, these filepaths appear in the list returned by &lt;code&gt;standard_typemap_locations()&lt;/code&gt; in reverse order,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78acaa936efa9d2893b28f11a288123a0f9298ff" translate="yes" xml:space="preserve">
          <source>However, these two XSUBs provide almost identical generated C code: &lt;b&gt;xsubpp&lt;/b&gt; compiler is smart enough to figure out the &lt;code&gt;CODE:&lt;/code&gt; section from the first two lines of the description of XSUB. What about &lt;code&gt;OUTPUT:&lt;/code&gt; section? In fact, that is absolutely the same! The &lt;code&gt;OUTPUT:&lt;/code&gt; section can be removed as well,</source>
          <target state="translated">그러나이 두 XSUB는 거의 동일하게 생성 된 C 코드를 제공합니다. &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러는 XSUB 설명의 처음 두 줄에서 &lt;code&gt;CODE:&lt;/code&gt; 섹션 을 알아낼 수있을 정도로 똑똑 합니다. 무엇에 대한 &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션? 사실, 그것은 완전히 같습니다! &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션도 제거 할 수있다</target>
        </trans-unit>
        <trans-unit id="84b8501e3adfdc161bae2d83215ead9cfc2ea49b" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;a href=&quot;File::Spec::Unix#canonpath%28%29&quot;&gt;&quot;canonpath()&quot; in File::Spec::Unix&lt;/a&gt;. If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8993e8546f1a446361af9208f62149f37c72c7da" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">그러나이 방법은 &quot;root&quot;다음에 오는 첫 번째 인수로 제한됩니다 (다시 &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). 디렉토리 트리를 위로 이동하는 인수가 더 있으면 루트를 넘어서는 잘못된 경로를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5458eab9c28fdf9d40e7593c2500908102783b51" translate="yes" xml:space="preserve">
          <source>However, this feature was undeprecated in Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01b858fc25bd1ebdcf816e174585aed80aab581" translate="yes" xml:space="preserve">
          <source>However, this function may return a Unicode string if the environment variable being expanded hasn't been assigned to via %ENV. Access to %ENV is currently always using byte semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7865ef8ee24a1f53476e6455eeebeda223f24ca5" translate="yes" xml:space="preserve">
          <source>However, this only does what you mean if &lt;code&gt;$init_fields&lt;/code&gt; is indeed a hash reference. The condition &lt;code&gt;$init_fields ~~ $REQUIRED_FIELDS&lt;/code&gt; also allows the strings &lt;code&gt;&quot;name&quot;&lt;/code&gt;, &lt;code&gt;&quot;rank&quot;&lt;/code&gt;, &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; as well as any array reference that contains &lt;code&gt;&quot;name&quot;&lt;/code&gt; or &lt;code&gt;&quot;rank&quot;&lt;/code&gt; or &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; anywhere to pass through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b29d0e56857b797fbe9046c1637ec13ba0255e" translate="yes" xml:space="preserve">
          <source>However, this produces a list of temporary integer values as long as the original list of strings, only to reduce it down to a single value again. We can compute the same result more efficiently by using &lt;code&gt;reduce&lt;/code&gt; with a code block that accumulates lengths by writing this instead as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a498e0a44f0f9f8fbe6e40968d0b21c8d56b2479" translate="yes" xml:space="preserve">
          <source>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</source>
          <target state="translated">그러나 현재 코드는 숫자 부분을 직접 저장하기 위해 저수준 수학 라이브러리를 사용하므로이 요청은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7469fc2b44cf29dd35f31f1f2fa503b7de276c" translate="yes" xml:space="preserve">
          <source>However, this silent upgrading can easily cause problems, if you happen to mix unicode strings with non-Latin1 data -- i.e. byte-strings encoded in UTF-8 or other encodings. The error will not manifest until the combined string is written to output, at which time it would be impossible to see where did the silent upgrading occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c442891dca9145a3b9c79c668f4b9ec23f39a60" translate="yes" xml:space="preserve">
          <source>However, this still does not guarantee that these DLL may be loaded. The reason is the mangling of the name of the</source>
          <target state="translated">그러나 그래도이 DLL이로드 될 수 있음을 보증하지는 않습니다. 그 이유는</target>
        </trans-unit>
        <trans-unit id="2084b9ad89039a2ea6c4200ac2905bee170c22b7" translate="yes" xml:space="preserve">
          <source>However, to help ease understanding, it is suggested that you place a &quot;&amp;amp;&quot; next to the variable name and away from the variable type), and place a &quot;*&quot; near the variable type, but away from the variable name (as in the call to foo above). By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the &quot;last column&quot;.</source>
          <target state="translated">그러나 이해하기 쉽도록 변수 이름 옆에 &quot;&amp;amp;&quot;를 배치하고 변수 유형에서 멀리 떨어 뜨리고 변수 유형 근처에 &quot;*&quot;를 배치하지만 위의 foo에 대한 호출). 그렇게하면 C 함수에 전달 될 내용을 정확하게 이해하기가 쉽습니다. &quot;마지막 열&quot;에있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae3f94bdf7ac1269b60e51c2ce0911730992c14a" translate="yes" xml:space="preserve">
          <source>However, under some circumstances, this behavior may be excessively slow. For example, suppose you have a million-record file, and you want to do:</source>
          <target state="translated">그러나 일부 상황에서는이 동작이 너무 느려질 수 있습니다. 예를 들어, 백만 레코드 파일이 있고 다음을 수행하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="37cab8dafbfef6134cbae52136465a602af12595" translate="yes" xml:space="preserve">
          <source>However, unless you tell &lt;code&gt;Memoize&lt;/code&gt; that these calls are equivalent, it will not know that, and it will compute the values for these invocations of your function separately, and store them separately.</source>
          <target state="translated">그러나 이러한 호출이 동등하다는 것을 &lt;code&gt;Memoize&lt;/code&gt; 에 알리지 않으면이를 알 수 없으며 함수의 이러한 호출에 대한 값을 별도로 계산하여 별도로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="142779c491fb94a0d076da32b3296ae6b26999c0" translate="yes" xml:space="preserve">
          <source>However, up through v5.20, Perl initialized things on start-up so that &lt;code&gt;LC_NUMERIC&lt;/code&gt; was set to the &quot;C&quot; locale. But if any code anywhere changed it, it would stay changed. This means that your module can't count on &lt;code&gt;LC_NUMERIC&lt;/code&gt; being something in particular, and you can't expect floating point numbers (including version strings) to have dots in them. If you don't allow for a non-dot, your code could break if anyone anywhere changed the locale. For this reason, v5.22 changed the behavior so that Perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the &quot;C&quot; locale except around the operations internally where it should be something else. Misbehaving XS code will always be able to change the locale anyway, but the most common instance of this is checked for and handled.</source>
          <target state="translated">그러나 v5.20까지 Perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이 &quot;C&quot;로케일로 설정 되도록 시작시 항목을 초기화했습니다 . 그러나 코드가 어디에서나 변경되면 변경 상태를 유지합니다. 이것은 모듈이 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 특별히 고려할 수 없으며 부동 소수점 숫자 (버전 문자열 포함)에 점이있을 것으로 기대할 수 없음을 의미합니다. 점이 아닌 것을 허용하지 않으면, 누군가가 로케일을 변경하면 코드가 깨질 수 있습니다. 이러한 이유로 v5.22는 Perl이 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 &quot;C&quot;로케일 로 유지하도록 동작을 변경하여 내부적으로 다른 곳이 아닌 조작을 제외하고는 &quot;C&quot;로케일 을 유지 합니다. XS 코드가 잘못 작동하면 항상 로케일을 변경할 수 있지만 가장 일반적인 인스턴스가 확인되고 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="068b747d32004750485efe98f8d1cbafa2e0e35a" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;&amp;amp;&lt;/code&gt; in the call still overrides the prototype of &lt;code&gt;foo&lt;/code&gt; if present:</source>
          <target state="translated">그러나 호출에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용 하면 &lt;code&gt;foo&lt;/code&gt; 의 프로토 타입이있는 경우 여전히 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f9fabcfc6b8511bdc0a7ecd34a3e04f701d2b56e" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt; , or &lt;code&gt;\x0D\x0A&lt;/code&gt; ) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;code&gt;Socket&lt;/code&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">그러나 &lt;code&gt;\015\012&lt;/code&gt; (또는 &lt;code&gt;\cM\cJ&lt;/code&gt; 또는 &lt;code&gt;\x0D\x0A&lt;/code&gt; )를 사용하면 코드를 유지 관리하는 사람들과 혼동을 줄뿐만 아니라 지루하고보기 흉하지 않을 수 있습니다. 따라서 &lt;code&gt;Socket&lt;/code&gt; 모듈은 원하는 사람들에게 올바른 것을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc2515b31d0fe90459c261be099beca3ae68dad0" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt;, or &lt;code&gt;\x0D\x0A&lt;/code&gt;) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;a href=&quot;socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; module supplies the Right Thing for those who want it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163537b4f5c11cd47e9722700a60c6c7ea0ade4a" translate="yes" xml:space="preserve">
          <source>However, using the code requires that you have a working C compiler and can use it to build and install a CPAN module. Here's a solution using the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module, which is already on your system (assuming your system supports POSIX).</source>
          <target state="translated">그러나 코드를 사용하려면 작동중인 C 컴파일러가 있어야하며이를 사용하여 CPAN 모듈을 빌드하고 설치할 수 있습니다. 다음 은 시스템에 이미 있는 표준 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 사용하는 솔루션입니다 (시스템이 POSIX를 지원한다고 가정).</target>
        </trans-unit>
        <trans-unit id="a4350da00ad3028f4efc1846f8fc750c07ee286a" translate="yes" xml:space="preserve">
          <source>However, when it's a list-context assignment and you're trying to use &lt;code&gt;||&lt;/code&gt; for control flow, you probably need &lt;code&gt;&quot;or&quot;&lt;/code&gt; so that the assignment takes higher precedence.</source>
          <target state="translated">그러나 목록 컨텍스트 지정이고 &lt;code&gt;||&lt;/code&gt; 제어 흐름의 경우 할당이 더 높은 우선 순위를 갖도록 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b662692b6fa64e61f6a9c3f800af2536f40b3b4a" translate="yes" xml:space="preserve">
          <source>However, when you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f9727ede39a1ce5211e24f06cf1afdd8d7ee83" translate="yes" xml:space="preserve">
          <source>However, you can change the way an object is smartmatched by overloading the &lt;code&gt;~~&lt;/code&gt; operator. This is allowed to extend the usual smartmatch semantics. For objects that do have an &lt;code&gt;~~&lt;/code&gt; overload, see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;~~&lt;/code&gt; 연산자 를 오버로드하여 객체의 스마트 매칭 방식을 변경할 수 있습니다 . 이는 일반적인 스마트 매치 시맨틱을 확장 할 수 있습니다. 할 객체가 가지고 들어 &lt;code&gt;~~&lt;/code&gt; 과부하를 볼 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b89d0d284e64c095a60bef4f1dd049a654a9b8f4" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">그러나 명시적인 빈 가져 오기 목록을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 를 억제 할 수 있습니다 . 이 두 가지 모두 여전히 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="260fe9f97d0d69a65905fdc8f061356d4780ef04" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;import&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb959e8b316e23c060bb14a1aa10ea6663e7a66" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt; . We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">그러나 영속 인터프리터를 사용할 때는 네임 스페이스와 변수 범위 지정에 더주의해야합니다. 이전 예제에서는 기본 패키지 &lt;code&gt;main&lt;/code&gt; 에서 전역 변수를 사용했습니다 . 우리는 어떤 코드가 실행 될지 정확히 알고 있었고, 변수 충돌과 터무니없는 심볼 테이블 증가를 피할 수 있다고 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="f80e0acb7e372dabc4a5f7b74c6498f8798ef7a3" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt;. We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66a879553ebe7b620fa37901232bfb863aa6d3d" translate="yes" xml:space="preserve">
          <source>However, you may know that you intend to use the results in a particular context, where some pragmas are already in scope. In this case, you use the &lt;b&gt;ambient_pragmas&lt;/b&gt; method to describe the assumptions you wish to make.</source>
          <target state="translated">그러나 일부 pragma가 이미 범위에있는 특정 상황에서 결과를 사용하려고 할 수도 있습니다. 이 경우, &lt;b&gt;ambient_pragmas&lt;/b&gt; 메소드를 사용하여 원하는 가정을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="13143a50c1533ee9fae63ea9ed2eae1b6ad85192" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cfa87ada9834b01835bf9c64cf509441054b7b" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">그러나 반대편에 진짜 사람이 있다는 것을 의미한다면 운이 나쁠 수도 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; 모듈을 사용하면 다른 프로그램이 사람인 것처럼 가장 할 수 있습니다. 이 프로그램은 튜링 테스트를 통과하는 것에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="a422dec568026043ae4e005023457a913a05b272" translate="yes" xml:space="preserve">
          <source>However, you must not do this, for example:</source>
          <target state="translated">그러나 다음과 같이이 작업을 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a4e64a25b29be20841a60bc10f2c0bc37e06f9" translate="yes" xml:space="preserve">
          <source>However, you should &lt;b&gt;not&lt;/b&gt; blindly rely on perl always doing the right thing. Particularly, perl will mistakenly return true when you clear the hash by repeatedly calling DELETE until it is empty. You are therefore advised to supply your own SCALAR method when you want to be absolutely sure that your hash behaves nicely in scalar context.</source>
          <target state="translated">그러나 항상 올바른 일을하는 펄에 맹목적으로 의존 해서는 &lt;b&gt;안됩니다&lt;/b&gt; . 특히, 펄은 비어있을 때까지 DELETE를 반복해서 호출하여 해시를 지우면 true를 잘못 반환합니다. 따라서 해시가 스칼라 컨텍스트에서 훌륭하게 작동하도록하려면 자체 SCALAR 방법을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="684d82ac83a5f8790e5e4368c88d7c77aa0309c6" translate="yes" xml:space="preserve">
          <source>Hub ID of the hub that is represented in the parent-child relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42118b9b162322837f3cc4bb7657481f703e832" translate="yes" xml:space="preserve">
          <source>Hub subclasses (and some hub utility objects) live under this namespace. It is perfectly reasonable for third party distributions to add new hub subclasses in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a802db1cd7382689ea166fa197e7bee4e5a74a9" translate="yes" xml:space="preserve">
          <source>Hub used by interceptor to grab results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64bf0d9364108763162c7fb9f03b312d24f14b0" translate="yes" xml:space="preserve">
          <source>Hub used by subtests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d2100593fec39720245432930b526325693698" translate="yes" xml:space="preserve">
          <source>Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</source>
          <target state="translated">휴고 반 데르 샌덴 &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="903a8361b68cfddd3da7251d755007dc0e94f5d3" translate="yes" xml:space="preserve">
          <source>Human readable description of the assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eba29a5d2ddda0020c1cac7fb53eb47535a92ce" translate="yes" xml:space="preserve">
          <source>Human readable description of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606d069fe25297dd11df0cc8580ee8dbe3f85e7" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the plan being set. This is normally not rendered by most formatters except when the &lt;code&gt;skip&lt;/code&gt; field is also set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1a79a67a1a08817e952e2d08177e5fbf4cba31" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the special behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f687605c0577ef885ee45c1c086d0ad37ee205b5" translate="yes" xml:space="preserve">
          <source>Human readable explanation of why amnesty was granted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2aebac92e9a840f478fce4b6343c22b8d0ca60" translate="yes" xml:space="preserve">
          <source>Human readable string or data structure, this is the information to display. Formatters are free to render the structures however they please. This may contain a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d2d17793130f2e86c0885a2d78da3c7f24dc7" translate="yes" xml:space="preserve">
          <source>Human readable text for display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14e46ce7d094f9326167acc499698128651be85" translate="yes" xml:space="preserve">
          <source>Hungary</source>
          <target state="translated">Hungary</target>
        </trans-unit>
        <trans-unit id="1938ed7c63e01c8a596d909427e34650befec480" translate="yes" xml:space="preserve">
          <source>HvENAME</source>
          <target state="translated">HvENAME</target>
        </trans-unit>
        <trans-unit id="6d3ea3f5bd46317a0b128c10a43f2b6c88d4d4cb" translate="yes" xml:space="preserve">
          <source>HvENAMELEN</source>
          <target state="translated">HvENAMELEN</target>
        </trans-unit>
        <trans-unit id="867db34eff4673062e6b813ed04df520c5233a3d" translate="yes" xml:space="preserve">
          <source>HvENAMEUTF8</source>
          <target state="translated">HvENAMEUTF8</target>
        </trans-unit>
        <trans-unit id="df110dc29f38c56ef4eec2b4759e744b23e69e1f" translate="yes" xml:space="preserve">
          <source>HvFILL</source>
          <target state="translated">HvFILL</target>
        </trans-unit>
        <trans-unit id="d18ff5331b7e22893e39912957fedf5b97c67829" translate="yes" xml:space="preserve">
          <source>HvNAME</source>
          <target state="translated">HvNAME</target>
        </trans-unit>
        <trans-unit id="9c77eb3e074087eb866a360b06af707ee5df0f01" translate="yes" xml:space="preserve">
          <source>HvNAMELEN</source>
          <target state="translated">HvNAMELEN</target>
        </trans-unit>
        <trans-unit id="c5d2d62591fdff3694f9b23256ac71f286680b41" translate="yes" xml:space="preserve">
          <source>HvNAMEUTF8</source>
          <target state="translated">HvNAMEUTF8</target>
        </trans-unit>
        <trans-unit id="9711a7cfeff071972d36fdd6050e80bc9d749c0b" translate="yes" xml:space="preserve">
          <source>Hyperlinks</source>
          <target state="translated">Hyperlinks</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="68ea31ac882843ca3bb7347afdcbec874605911e" translate="yes" xml:space="preserve">
          <source>I almost always use keys that are themselves valid lexicon values. One notable exception is when the value is quite long. For example, to get the screenful of data that a command-line program might return when given an unknown switch, I often just use a brief, self-explanatory key such as &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to define that lexicon entry in the ProjectClass::L10N::en lexicon (since English is always my &quot;project language&quot;):</source>
          <target state="translated">나는 거의 항상 유효한 어휘 값인 키를 사용합니다. 주목할만한 예외 중 하나는 값이 매우 길 때입니다. 예를 들어, 알 수없는 스위치가 주어 졌을 때 명령 줄 프로그램이 반환 할 수있는 데이터를 얻기 위해 종종 &quot;_USAGE_MESSAGE&quot;와 같은 간단한 설명 키를 사용합니다. 그 시점에서 나는 즉시 ProjectClass :: L10N :: en lexicon에 lexicon 항목을 정의합니다 (영어는 항상 &quot;프로젝트 언어&quot;이므로).</target>
        </trans-unit>
        <trans-unit id="bd142ae3cc7adab96cfaa7558d02068b158e85c3" translate="yes" xml:space="preserve">
          <source>I am also usually active on IRC as 'autarch' on &lt;code&gt;irc://irc.perl.org&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1174e9f9955c9e61d54f218d08d7285e0e0ae8" translate="yes" xml:space="preserve">
          <source>I am behind a SOCKS firewall, but the Firewall option does not work ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b0de54116e38392536f989ded25ad9bceea24f" translate="yes" xml:space="preserve">
          <source>I am behind an FTP proxy firewall, but cannot access machines outside ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12498934a0d4cbe958ea9ae2277b44bccce11e2" translate="yes" xml:space="preserve">
          <source>I am not root, how can I install a module in a personal directory?</source>
          <target state="translated">루트가 아닙니다. 개인 디렉터리에 모듈을 어떻게 설치할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="720225fb87f4fceb999d3d3c67fa208ed54fe066" translate="yes" xml:space="preserve">
          <source>I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</source>
          <target state="translated">코드에 버그가 있다고 확신합니다. 당신이 발견하거나 개선 사항을 제안 할 수 있다면, 나는 당신의 의견을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="f822dc00911ca2b5b17523234c19e71174239e30" translate="yes" xml:space="preserve">
          <source>I assume that each language class derives (directly or indirectly) from your project class, and also defines its @ISA, its %Lexicon, or both. But I anticipate no dire consequences if these assumptions do not hold.</source>
          <target state="translated">각 언어 클래스는 프로젝트 클래스에서 (직접 또는 간접적으로) 파생되며 @ISA, % Lexicon 또는 둘 다를 정의한다고 가정합니다. 그러나 이러한 가정이 유지되지 않으면 심각한 결과는 없을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="aac2738433180b0fc7eec7ab6421ac5a20b62f00" translate="yes" xml:space="preserve">
          <source>I believe this issue is prevalent not only for Mac Indics but also in other Indic encodings, but the above were the only Indic encodings maps that I could find at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4d37f069c57cb7de599233daad3bd27d0a8ebc" translate="yes" xml:space="preserve">
          <source>I can also pass callbacks to the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bcef0f48a866ba703693e5fcdad43a764ad25a" translate="yes" xml:space="preserve">
          <source>I can also tell prove to save the results again so that it updates its idea of which tests failed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d96c393b63a12dec2fe257877addccb84b91ed" translate="yes" xml:space="preserve">
          <source>I can incorporate these options into my own version of prove. It's pretty simple. Most of the work of prove is handled by App::Prove. The important code in prove is just:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f16057cfc74a8e91522c5a546d3a88bbd9af3c3" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">조회가 실패하기를 원하지 않는 모든 종류의 상황을 묘사 할 수 있습니다 (일반적으로 실패하면 maketext가 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 던지는 것을 의미하기 때문에 다음 섹션을 참조하십시오). 그러나 여기에 _AUTO 사전이 있어야 할 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73e0e4b77d6bcf01d6041debc1a2e83d30fd057e" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;die&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08456af218bdc4a506b4e778d48d6e90d82b1d13" translate="yes" xml:space="preserve">
          <source>I can tell prove just to run the tests that are failing like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4089c61d9307c046d40cd9abd561382f7f03ee3" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use</source>
          <target state="translated">프로그램에 펄을 포함 시키거나 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="31d3f8a1fa15d729190062c1ddc4f7dd97a4bdd9" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use _perl.dll_ from my program.</source>
          <target state="translated">프로그램에 perl을 포함 시키거나 프로그램에서 _perl.dll_을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0dabde4d7970f758fc132b87f569962de8417e4" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use perl.dll from my program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfdb8e8d03951e17fc904de692bb5bbd7335317" translate="yes" xml:space="preserve">
          <source>I cannot run external programs</source>
          <target state="translated">외부 프로그램을 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="993598ed9e1ff928aa61c98c2c0a4e51ef13499b" translate="yes" xml:space="preserve">
          <source>I cleaned it up a little.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ed42e550b2837d803cc938a5c931b4a08219dc" translate="yes" xml:space="preserve">
          <source>I copied the Perl binary from one machine to another, but scripts don't work.</source>
          <target state="translated">한 컴퓨터에서 다른 컴퓨터로 Perl 바이너리를 복사했지만 스크립트가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9327e89bd234d7a986b2da9100760b6e37c4547a" translate="yes" xml:space="preserve">
          <source>I could start up faster by delaying compilation until it should be needed, but this gets a &quot;panic: top_level&quot; when using the pragma form in Perl 5.001e.</source>
          <target state="translated">컴파일이 필요할 때까지 지연시켜 더 빨리 시작할 수 있지만 Perl 5.001e에서 pragma 양식을 사용할 때 &quot;panic : top_level&quot;이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88a201ad71d898eadaddaac681114556a0d035b9" translate="yes" xml:space="preserve">
          <source>I do not anticipate that you will need (or particularly want) to nest bracket groups, but you are welcome to email me with convincing (real-life) arguments to the contrary.</source>
          <target state="translated">나는 당신이 괄호 그룹을 중첩해야 할 것이라고 기대하지는 않지만 (실제로) 설득력있는 주장을 이메일로 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="3bb5142da6ee5443fb8a1f91f511fc41a8d23e27" translate="yes" xml:space="preserve">
          <source>I don't have a C compiler. How can I build my own Perl interpreter?</source>
          <target state="translated">C 컴파일러가 없습니다. 어떻게 펄 통역사를 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d6d0389812dedc1090c3af8ee3195c2e1255c8d3" translate="yes" xml:space="preserve">
          <source>I foresee no problems with having multiple inheritance in your hierarchy of language classes. (As usual, however, Perl will complain bitterly if you have a cycle in the hierarchy: i.e., if any class is its own ancestor.)</source>
          <target state="translated">언어 클래스의 계층 구조에서 다중 상속을하는 데 아무런 문제가 없다고 생각합니다. 그러나 평소와 같이 Perl은 계층 구조에주기가있는 경우 (즉, 클래스가 자체 조상 인 경우) 심하게 불평합니다.</target>
        </trans-unit>
        <trans-unit id="371ea8fdbc8bb052c307098a6984a7c87ed2802d" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">내 쉘에서 이것을 실행할 때 오류가 발생합니다 (bash). 그것은 perl처럼 보일 수도 있지만 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 함수를 가지고 있지만 내 shebang 줄은 perl의 경로가 아니므로 쉘이 스크립트를 실행하고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b40ca07783bb532ad8480c512cbc6f6a04c95d1" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;print()&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b36e7f52406231ec7c4381f27e5a02ba4d1de4" translate="yes" xml:space="preserve">
          <source>I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?</source>
          <target state="translated">나는 소스를 잡고 컴파일하려고했지만 gdbm / dynamic loading / malloc / linking / ...이 실패했습니다. 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="d3f27f69fc434f23222da72a1a4ed476958555fb" translate="yes" xml:space="preserve">
          <source>I have heard of one other type of firewall which requires a login to the firewall with an account, then a second login with &lt;code&gt;user@hostname&lt;/code&gt;. You can still use Net::FTP to traverse these firewalls, but a more manual approach must be taken, eg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aeb2257dccbb467ef10e49ef5687a5f072930e" translate="yes" xml:space="preserve">
          <source>I have no clue what this does. Strips function prefixes?</source>
          <target state="translated">나는 이것이 무엇을하는지 전혀 모른다. 함수 접두사를 제거 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="0cb0121fc9974d9d1b5aed90c164d431509f7248" translate="yes" xml:space="preserve">
          <source>I have seen scripts call a method message, but cannot find it documented ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc30870b270d5fd5a0e0ca93284b0967a0e43a00" translate="yes" xml:space="preserve">
          <source>I have supposed that since this module is concerned with file I/O, almost all normal use of it will be heavily I/O bound. This means that the time to maintain complicated data structures inside the module will be dominated by the time to actually perform the I/O. When there was an opportunity to spend CPU time to avoid doing I/O, I usually tried to take it.</source>
          <target state="translated">이 모듈은 파일 I / O와 관련이 있기 때문에 거의 모든 일반적인 사용은 I / O에 크게 구속됩니다. 이는 모듈 내에서 복잡한 데이터 구조를 유지하는 시간이 실제로 I / O를 수행하는 시간에 의해 지배됨을 의미합니다. I / O를 피하기 위해 CPU 시간을 소비 할 기회가 있었을 때 나는 보통 그것을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="9f890badb47c01638de767ac6be14f492fbbfa01" translate="yes" xml:space="preserve">
          <source>I installed a Bundle and had a couple of fails. When I retried, everything resolved nicely. Can this be fixed to work on first try?</source>
          <target state="translated">번들을 설치했는데 몇 가지 오류가 발생했습니다. 다시 시도하면 모든 것이 잘 해결되었습니다. 첫 번째 시도에서 작동하도록 수정할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f93fb27a66a374179e4455b8d8985c2d226a8af1" translate="yes" xml:space="preserve">
          <source>I installed a new version of module X but CPAN keeps saying, I have the old version installed</source>
          <target state="translated">모듈 X의 새 버전을 설치했지만 CPAN에서 계속 이전 버전이 설치되어 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ce465a8fc00712ba52e5306e95737f3b12576087" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of popups</source>
          <target state="translated">팝업 상태를 알 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="50ca6fc19f7270831b580874499d55acf40e475f" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of redirection of popups to the disk</source>
          <target state="translated">팝업이 디스크로 리디렉션되는 상태를 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="74eeceb13c393c687a92a5cda3bd40599b660cd1" translate="yes" xml:space="preserve">
          <source>I lost track; what encoding is the internal format really?</source>
          <target state="translated">나는 길을 잃었다. 내부 형식은 실제로 어떤 인코딩입니까?</target>
        </trans-unit>
        <trans-unit id="d25ced27930e65857371f29ffd1a913f02b5e4b7" translate="yes" xml:space="preserve">
          <source>I love it when a plan comes together</source>
          <target state="translated">계획이 모일 때 나는 그것을 좋아한다</target>
        </trans-unit>
        <trans-unit id="606078fbab11616b11caaa1df541827c0df787a2" translate="yes" xml:space="preserve">
          <source>I maintain a mailing list on which I occasionally announce new versions of Memoize. The list is for announcements only, not discussion. To join, send an empty message to mjd-perl-memoize-request@Plover.com.</source>
          <target state="translated">나는 때때로 새로운 버전의 Memoize를 발표하는 메일 링리스트를 유지한다. 이 목록은 공지가 아닌 토론 용입니다. 가입하려면 빈 메시지를 mjd-perl-memoize-request@Plover.com으로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="8c678b32e1afc117e7298e7cd70848ce65ee6435" translate="yes" xml:space="preserve">
          <source>I need to tell prove to use my My::TAP::Harness. If My::TAP::Harness is on Perl's @INC include path I can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c1a5ec60a557a8f6b6b470a96e90910a56e1c7" translate="yes" xml:space="preserve">
          <source>I pointed out that &lt;code&gt;Memoize&lt;/code&gt; uses a hash, and that looking up a number in the hash is necessarily going to take a lot longer than a single multiplication. There really is no way to speed up the &lt;code&gt;square&lt;/code&gt; function.</source>
          <target state="translated">나는 &lt;code&gt;Memoize&lt;/code&gt; 가 해시를 사용하고 해시에서 숫자를 찾는 것이 단일 곱셈보다 훨씬 오래 걸릴 것이라고 지적했습니다 . 실제로 &lt;code&gt;square&lt;/code&gt; 함수의 속도를 높일 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="05b0f6d7121204753b37fe3a1f3d86b9576db3c7" translate="yes" xml:space="preserve">
          <source>I presume that it would be only the exceptional Web site that gets localized for English</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44584b7f38a4c7c497d3af92b7cb4267fde694f9" translate="yes" xml:space="preserve">
          <source>I promised to give you 90% of the benefit with 10% of the details, and that means I left out 90% of the details. Now that you have an overview of the important parts, it should be easier to read the &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; manual page, which discusses 100% of the details.</source>
          <target state="translated">나는 10 %의 세부 사항으로 혜택의 90 %를 제공하겠다고 약속했고, 이는 90 %의 세부 사항을 생략했음을 의미합니다. 중요한 부분에 대한 개요를 &lt;a href=&quot;perlref&quot;&gt;보았&lt;/a&gt; 으므로 perlref 매뉴얼 페이지를 보다 쉽게 ​​읽을 수 있습니다 . 자세한 내용은 100 %를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fe86a2ccd7bbbde333da23b987f2e2e4802f719a" translate="yes" xml:space="preserve">
          <source>I put a regular expression into $/ but it didn't work. What's wrong?</source>
          <target state="translated">정규 표현식을 $ /에 넣었지만 작동하지 않았습니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="73511fb1b7957dad066b5bf11010746dfb956b61" translate="yes" xml:space="preserve">
          <source>I recommend reading all of these:</source>
          <target state="translated">이 모든 것을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b7928600b482b60ec404a555ac7072bbe1486616" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">PP 코드가 반드시 전체 스택 자체를 가져 오지는 않기 때문에 위에서 &quot;스택의 일부&quot;라고 말합니다. 함수가 다른 함수를 호출하는 경우 호출 된 함수를 대상으로하는 인수 만 노출하고 싶을 필요는 없습니다. ) 자신의 데이터를 얻습니다. 이를 수행하는 방법은 &quot;가상&quot;스택의 최하위를 각 함수에 노출시키는 것입니다. 마크 스택은 각 함수에서 사용할 수있는 인수 스택의 위치에 책갈피를 유지합니다. 예를 들어, 묶인 변수를 처리 할 때 (내부적으로 &quot;P&quot;마술이있는 것) Perl은 묶인 변수에 액세스하기위한 메소드를 호출해야합니다. 그러나 메소드에 노출 된 인수를 원래 함수 (스토어 또는 페치 또는 기타)에 노출 된 인수로 분리해야합니다. 여기'대략적인 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 가 어떻게 구현 되는지 ; 보다 &lt;code&gt;av_push&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="3b74357799ff3a807572f0228d6475d4cbcdbf36" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;push&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd010707291df43195b163d13725276025549dad" translate="yes" xml:space="preserve">
          <source>I still don't get locking. I just want to increment the number in the file. How can I do this?</source>
          <target state="translated">여전히 잠금이되지 않습니다. 파일의 숫자를 늘리고 싶습니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0c3fa205e2bf9a49a23f4b51209de0f9232902bf" translate="yes" xml:space="preserve">
          <source>I think it would help to give some concrete examples to make it easier to understand the API. Of course I agree that the API has to be concise, but since there is no second document that is more of a guide, I think that it'd make it easier to start with the doc which is an API, but has examples in it in places where things are unclear, to a person who is not a PerlIO guru (yet).</source>
          <target state="translated">API를 이해하기 쉽도록 구체적인 예제를 제공하는 것이 도움이 될 것이라고 생각합니다. 물론 나는 API가 간결해야한다는 데 동의하지만, 더 많은 가이드가있는 두 번째 문서가 없기 때문에 API 인 문서로 시작하는 것이 더 쉬울 것이라고 생각하지만 예제가 있습니다. PerlIO 전문가 (아직)가 아닌 사람에게 일이 불분명 한 곳에서.</target>
        </trans-unit>
        <trans-unit id="09ffd110a6022c3eacd4a506a275e7c45f272e0d" translate="yes" xml:space="preserve">
          <source>I think that keys as lexicon values makes the completed lexicon entries more readable:</source>
          <target state="translated">사전 값인 키는 완성 된 사전 항목을 더 읽기 쉽게 만든다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="794953983b61d639901830159ca78a40665adca3" translate="yes" xml:space="preserve">
          <source>I used 'lynx' to fetch a file, but its contents is all wrong!</source>
          <target state="translated">파일을 가져 오기 위해 'lynx'를 사용했지만 내용이 모두 잘못되었습니다!</target>
        </trans-unit>
        <trans-unit id="14dcb94db4c292bdfbf0b5c851ca4df4a4bf4c31" translate="yes" xml:space="preserve">
          <source>I want to clean up my mess, and install a new perl along with all modules I have. How do I go about it?</source>
          <target state="translated">엉망을 정리하고 모든 모듈과 함께 새로운 펄을 설치하고 싶습니다. 어떻게하면 되나요?</target>
        </trans-unit>
        <trans-unit id="3ae9e2275243ec65b397ebef16d91a7d431148ac" translate="yes" xml:space="preserve">
          <source>I want to log my test results in a database so I can track them over time. To do this I override the summary method in TAP::Harness. I start with a simple prototype that dumps the results as a YAML document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2d698fc768ffb8cd382c1370e66993c67187ee" translate="yes" xml:space="preserve">
          <source>I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?</source>
          <target state="translated">펄 스크립트에서 {디렉토리를 변경하고 환경을 수정했습니다}. 스크립트를 종료하면 어떻게 변경이 사라 집니까? 변경 사항을 표시하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8d4b0ae21d1479e72399aeb9631081d458e4ae16" translate="yes" xml:space="preserve">
          <source>I&amp;lt;bar&amp;gt;</source>
          <target state="translated">I&amp;lt;bar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3bb667cf6d485cf87366e4fa5d3fb7627b160f2b" translate="yes" xml:space="preserve">
          <source>I'll define the</source>
          <target state="translated">나는 정의 할 것이다</target>
        </trans-unit>
        <trans-unit id="5cc9daab4dbfbc15ce11a2a71cb8dfe5485782e2" translate="yes" xml:space="preserve">
          <source>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</source>
          <target state="translated">우리는 아직 얼라인먼트 캐치를 아직 끝내지 못하고 있습니다. 구조물 배열을 포장 할 때 히드라가 또 다른 추악한 머리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f883cc87b6710df9317db1561fdc26ada281ddbe" translate="yes" xml:space="preserve">
          <source>I'm frequently irritated with the CPAN shell's inability to help me select a good mirror.</source>
          <target state="translated">CPAN 쉘이 좋은 미러를 선택할 수 없다는 점에 자주 짜증이납니다.</target>
        </trans-unit>
        <trans-unit id="70a3ef0517de91698e88a243cc2feee12ba385a3" translate="yes" xml:space="preserve">
          <source>I'm having trouble matching over more than one line. What's wrong?</source>
          <target state="translated">두 줄 이상 일치하는 데 문제가 있습니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="8b9d03c166b0dec7e59491eb481c804d58495438" translate="yes" xml:space="preserve">
          <source>I'm not totally sure that locale names map satisfactorily to language tags. Think REAL hard about how you use this. YOU HAVE BEEN WARNED.</source>
          <target state="translated">로캘 이름이 언어 태그에 만족스럽게 매핑되는지 확실하지 않습니다. 이것을 사용하는 방법에 대해 REAL을 열심히 생각하십시오. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="73daa2b6bdc84827d06ade0cf82b30946cb9ce40" translate="yes" xml:space="preserve">
          <source>I'm offering this port &quot;as is&quot;. You can ask me questions, but I can't guarantee I'll be able to answer them. There are some excellent books available on the Perl language; consult a book seller.</source>
          <target state="translated">이 포트를 &quot;있는 그대로&quot;제공하고 있습니다. 당신은 나에게 질문을 할 수 있지만, 내가 대답 할 수 있다고 보장 할 수는 없습니다. Perl 언어로 된 훌륭한 책들이 있습니다; 서적 판매자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="4357a589e4e3b7a00e21bb3c83ca3b640b5e0ab8" translate="yes" xml:space="preserve">
          <source>I'm ok, you're not ok.</source>
          <target state="translated">난 괜찮아 넌 괜찮아</target>
        </trans-unit>
        <trans-unit id="108bd315655f1ba897c01059e340ad678da6e2f4" translate="yes" xml:space="preserve">
          <source>I'm sure most of us have seen code which looks like, (or worse than), this:</source>
          <target state="translated">우리 대부분은 다음과 같은 코드를 보았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f2f2a41a5729ebdf99d33e9a94c056bfe6a7622" translate="yes" xml:space="preserve">
          <source>I'm using WinZip, or some other non-POSIX client, and files are not being extracted properly!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c00e4567fd7637d5e9878ed4c5f66e616b88b8" translate="yes" xml:space="preserve">
          <source>I've considered making all the above functions that output language tags return all those tags strictly in lowercase. Having all your language tags in lowercase does make some things easier. But you might as well just lowercase as you like, or call &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; where appropriate.</source>
          <target state="translated">출력 언어 태그를 출력하는 위의 모든 기능을 모든 태그를 소문자로 엄격하게 반환하는 것을 고려했습니다. 모든 언어 태그를 소문자로 사용하면 더 쉽게 할 수 있습니다. 그러나 원하는대로 소문자를 입력하거나 적절한 경우 &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88c5fcd7802546df837a3bf463ca41dcbe3c282a" translate="yes" xml:space="preserve">
          <source>I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?</source>
          <target state="translated">나는 perlembed, perlguts 등을 읽었지만 C 프로그램에 perl을 포함시킬 수는 없다. 내가 뭘 잘못하고 있죠?</target>
        </trans-unit>
        <trans-unit id="4dfe11ac55007ac0949167eaeb2efbe8ea5b1f5d" translate="yes" xml:space="preserve">
          <source>I/O</source>
          <target state="translated">I/O</target>
        </trans-unit>
        <trans-unit id="c880785e491d41fc494e4fbfcd55e995f2687586" translate="yes" xml:space="preserve">
          <source>I/O Operators</source>
          <target state="translated">I / O 연산자</target>
        </trans-unit>
        <trans-unit id="1bd45ae6f90a489462015faa36411b1a7a88b1e2" translate="yes" xml:space="preserve">
          <source>I/O control operations for disk devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Most of these are to be used on physical drive devices like &lt;code&gt;&quot;//./PhysicalDrive0&quot;&lt;/code&gt;. However, &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; and &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; should only be used on a single-partition device like &lt;code&gt;&quot;//./C:&quot;&lt;/code&gt;. Also, &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; is documented as having been superseded but is still useful when used on a floppy device like &lt;code&gt;&quot;//./A:&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4882a6a30b4583bba173c6035cc140752a4ec0" translate="yes" xml:space="preserve">
          <source>I/O control operations for generic storage devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Includes &lt;code&gt;IOCTL_STORAGE_CHECK_VERIFY&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_MEDIA_REMOVAL&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_EJECT_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_LOAD_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RESERVE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RELEASE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_FIND_NEW_DEVICES&lt;/code&gt;, and &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa930eaf91e1f81994700657728c3a757afb3cf" translate="yes" xml:space="preserve">
          <source>I/O flow (the actual 5 minute tutorial)</source>
          <target state="translated">I / O 흐름 (실제 5 분 자습서)</target>
        </trans-unit>
        <trans-unit id="ae9cf1f9e1227f9dff6b41ea1e5f80cc2ae055d8" translate="yes" xml:space="preserve">
          <source>I/O layer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fc5fcf49da9b0ec975af77958aa41975a1fe45" translate="yes" xml:space="preserve">
          <source>I/O redirection and backgrounding</source>
          <target state="translated">I / O 리디렉션 및 배경</target>
        </trans-unit>
        <trans-unit id="30d63bddfa4212ccce60957ddceaf4fa37417d27" translate="yes" xml:space="preserve">
          <source>I/O timeout value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8571fe32abe041d9dce3d7d7c47b858f248fa514" translate="yes" xml:space="preserve">
          <source>I18N AND L10N</source>
          <target state="translated">I18N과 L10N</target>
        </trans-unit>
        <trans-unit id="e6b903dcac2bbc1b40e43d5e333946755137d36f" translate="yes" xml:space="preserve">
          <source>I18N::Charset</source>
          <target state="translated">I18N::Charset</target>
        </trans-unit>
        <trans-unit id="de5d730fbdbbf0183cf0f4683f1a73058ef3481c" translate="yes" xml:space="preserve">
          <source>I18N::Collate</source>
          <target state="translated">I18N::Collate</target>
        </trans-unit>
        <trans-unit id="01ad2dd6dde49d7565416cd97f4d499093f9d249" translate="yes" xml:space="preserve">
          <source>I18N::Collate - compare 8-bit scalar data according to the current locale</source>
          <target state="translated">I18N :: Collate-현재 로케일에 따라 8 비트 스칼라 데이터 비교</target>
        </trans-unit>
        <trans-unit id="e106875b328699ace6767aa9c5ecab5bca3b0bd8" translate="yes" xml:space="preserve">
          <source>I18N::LangTags</source>
          <target state="translated">I18N::LangTags</target>
        </trans-unit>
        <trans-unit id="169f8297167d0e993d7316faae039b48a7c3bab1" translate="yes" xml:space="preserve">
          <source>I18N::LangTags - functions for dealing with RFC3066-style language tags</source>
          <target state="translated">I18N :: LangTags-RFC3066 스타일 언어 태그를 처리하는 기능</target>
        </trans-unit>
        <trans-unit id="921275b7d99f260593561350c7678a20816444ed" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect</source>
          <target state="translated">I18N::LangTags::Detect</target>
        </trans-unit>
        <trans-unit id="778875cc577b876aab7ab802d4648cdcd4ee6cae" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect - detect the user's language preferences</source>
          <target state="translated">I18N :: LangTags :: Detect-사용자의 언어 기본 설정 감지</target>
        </trans-unit>
        <trans-unit id="c04ea1622f377702e175508a3a481907575a2f47" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List</source>
          <target state="translated">I18N::LangTags::List</target>
        </trans-unit>
        <trans-unit id="020bb812c335fc278093b15a03a292e40918c844" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List -- tags and names for human languages</source>
          <target state="translated">I18N :: LangTags :: List-인간 언어의 태그 및 이름</target>
        </trans-unit>
        <trans-unit id="e3646198e54c82833384221bb49e8cf11f385f8f" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo</source>
          <target state="translated">I18N::Langinfo</target>
        </trans-unit>
        <trans-unit id="75f77bed8de0aee0770843a55893169b79d25155" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo - query locale information</source>
          <target state="translated">I18N :: Langinfo-로캘 정보 쿼리</target>
        </trans-unit>
        <trans-unit id="fde9493a25e191231f11e09ab4dbdd30b2b2a8bf" translate="yes" xml:space="preserve">
          <source>I18N:Collate obsolete</source>
          <target state="translated">I18N : 더 이상 사용되지 않는 컬렉션</target>
        </trans-unit>
        <trans-unit id="0afef78a7afa599e29cd712fed951b6314ade53c" translate="yes" xml:space="preserve">
          <source>I18n and l10n</source>
          <target state="translated">I18n 및 L10N</target>
        </trans-unit>
        <trans-unit id="3886f65f7123288c1155f83462ecaa6186be5aba" translate="yes" xml:space="preserve">
          <source>I64 (8.2 and later)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d467a87245290159a1b6af42928666730653f6" translate="yes" xml:space="preserve">
          <source>IANA</source>
          <target state="translated">IANA</target>
        </trans-unit>
        <trans-unit id="0e13c62333772940b082221be7ca7762de31a069" translate="yes" xml:space="preserve">
          <source>IBM XL C for AIX</source>
          <target state="translated">AIX 용 IBM XL C</target>
        </trans-unit>
        <trans-unit id="c8afdae11327e149f5501c448b30becf77bc4954" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ for AIX</source>
          <target state="translated">AIX 용 IBM XL C / C ++</target>
        </trans-unit>
        <trans-unit id="90317bc062fe454cff88014258aea7e36e9b3afc" translate="yes" xml:space="preserve">
          <source>IBM calls its implementation of long doubles 128-bit, but it is not the IEEE 128-bit (&quot;quadruple precision&quot;) which would give 116 bit of mantissa (nor it is implemented in hardware), instead it's a special software implementation called &quot;double-double&quot;, which gives 106 bits of mantissa.</source>
          <target state="translated">IBM은 long doubles 128 비트 구현을 호출하지만 IEEE 116 비트 ( &quot;사중 정밀도&quot;)가 아니라 116 비트의 가수 (하드웨어로 구현되지 않음)가 아니라 &quot; double-double &quot;은 106 비트의 가수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="896c500f28ef7df0fbbd0268cb9652b7cfe0014c" translate="yes" xml:space="preserve">
          <source>IBM uses the AIX system Perl (V5.6.0 on AIX 5.1 and V5.8.2 on AIX 5.2 / 5.3 and 6.1; V5.8.8 on AIX 5.3 TL11 and AIX 6.1 TL4; V5.10.1 on AIX 7.1) for some AIX system scripts. If you switch the links in /usr/bin from the AIX system Perl (/usr/opt/perl5) to the newly build Perl then you get the same features as with the IBM AIX system Perl if the threaded options are used.</source>
          <target state="translated">IBM은 일부 AIX 시스템 스크립트에 AIX 시스템 Perl (AIX 5.1 / 5.3 및 6.1의 경우 AIX 5.1 및 V5.8.2, AIX 5.3 TL11 및 AIX 6.1 TL4의 경우 V5.8.8, AIX 7.1의 경우 V5.10.1)을 사용합니다. AIX 시스템 Perl (/ usr / opt / perl5)에서 새로 빌드 된 Perl로 / usr / bin의 링크를 전환하면 스레드 옵션이 사용되는 경우 IBM AIX 시스템 Perl과 동일한 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade9d724c5b212d6e78013557f35ac5c64927377" translate="yes" xml:space="preserve">
          <source>ICU Character Mapping Tables &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</source>
          <target state="translated">ICU 문자 매핑 테이블 &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92d0be3756020c7fb70f5f8d43b6e18e96de1472" translate="yes" xml:space="preserve">
          <source>ICU Home Page &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</source>
          <target state="translated">ICU 홈페이지 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b3a4d066585cb49384b262b020e538f42a1f2ef" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU : 전환 데이터 &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="46c5f048dbe4176fe265d2a79feb829754221b1e" translate="yes" xml:space="preserve">
          <source>IDENTIFYING CHARACTER CODE SETS</source>
          <target state="translated">문자 코드 세트 식별</target>
        </trans-unit>
        <trans-unit id="98eebf3bdf415d089af03ec0debc7c66f797a900" translate="yes" xml:space="preserve">
          <source>IETF Policy on Character Sets and Languages</source>
          <target state="translated">문자 집합 및 언어에 대한 IETF 정책</target>
        </trans-unit>
        <trans-unit id="db4d48e5feaf920779dd2373b4efffa265df836a" translate="yes" xml:space="preserve">
          <source>IFS access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5d66d70494ee5ff5a453f224b81868447c393b" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION</source>
          <target state="translated">IMPLEMENTATION</target>
        </trans-unit>
        <trans-unit id="282613097967896b3e57bca75eb0bce558486a26" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION DETAILS</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="0e35eae7c0731d3856fc41389b70ba2d34677ec0" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION NOTE</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="00f6ac93461571c87bf08a0fa480109344a9be63" translate="yes" xml:space="preserve">
          <source>IMPLICIT LOADING</source>
          <target state="translated">묵시적 로딩</target>
        </trans-unit>
        <trans-unit id="2af61b8a92b859239b57341d2094b6ce58292a8a" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE 2: Attempting to bypass the normal stringification rules by manually applying &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; and &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; will sometimes yield surprising results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d100fb60d3feed237cfa4b32f5da84abc315f27f" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: As shown above, if your Decimal version contains more than 3 significant digits after the decimal place, it will be split on each multiple of 3, so 1.0003 is equivalent to v1.0.300, due to the need to remain compatible with Perl's own 5.005_03 == 5.5.30 interpretation. Any trailing zeros are ignored for mathematical comparison purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d142ce7a912c87993ee95b67742ac2fb602f1" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: There is one exceptional cases shown in the above table where the &quot;initializer&quot; is not stringwise equivalent to the stringified representation. If you use the &lt;code&gt;qv&lt;/code&gt;() operator on a version without a leading 'v' &lt;b&gt;and&lt;/b&gt; with only a single decimal place, the stringified output will have a leading 'v', to preserve the sense. See the &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; operator for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb759641a6b8b6611a890056cf82c280511d2e9e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: This may mean that code which searches for a specific string (to determine whether a given module is available) may need to be changed. It is always better to use the built-in comparison implicit in &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, rather than manually poking at &lt;code&gt;class-&amp;gt;VERSION&lt;/code&gt; and then doing a comparison yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926527594f94772fcf38d60a2b632b1bb4c3c38c" translate="yes" xml:space="preserve">
          <source>IMPORTANT!</source>
          <target state="translated">IMPORTANT!</target>
        </trans-unit>
        <trans-unit id="c2e68d710cae68fae1b4d1132f818132a6f1837f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: if you use this &lt;code&gt;-S&lt;/code&gt; switch, be sure to delete the CONFIG environment variable before running the script:</source>
          <target state="translated">중요 :이 &lt;code&gt;-S&lt;/code&gt; 스위치 를 사용 하는 경우 스크립트를 실행하기 전에 CONFIG 환경 변수를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0c22f22ac148bf746659a76f51a0cce8f4070e" translate="yes" xml:space="preserve">
          <source>IMPORTS</source>
          <target state="translated">IMPORTS</target>
        </trans-unit>
        <trans-unit id="7696e648752c3c28012375bdb960a19fe39b8205" translate="yes" xml:space="preserve">
          <source>IMPORTS THE FUNCTIONS</source>
          <target state="translated">기능을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="6a09657af85954f963dea9fb1156c8ea7994677c" translate="yes" xml:space="preserve">
          <source>IN6ADDR_ANY, IN6ADDR_LOOPBACK</source>
          <target state="translated">IN6ADDR_ANY, IN6ADDR_LOOPBACK</target>
        </trans-unit>
        <trans-unit id="8b4b83ea115334b0957635d43569bbc4350f1369" translate="yes" xml:space="preserve">
          <source>INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</source>
          <target state="translated">INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</target>
        </trans-unit>
        <trans-unit id="ff3c82a6fc602d03a66e45a7aa9a2ebf5c59e91e" translate="yes" xml:space="preserve">
          <source>INC</source>
          <target state="translated">INC</target>
        </trans-unit>
        <trans-unit id="3c49bdd8d8e33e31f0c17fbcb306d09e8c131ead" translate="yes" xml:space="preserve">
          <source>INCLUDE_EXT</source>
          <target state="translated">INCLUDE_EXT</target>
        </trans-unit>
        <trans-unit id="648fb0ddc69c6bf59cfae2b4b521d2eea5687df1" translate="yes" xml:space="preserve">
          <source>INCREMENTAL PARSING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe356b54ea95780c909073ac988ee31715e5615" translate="yes" xml:space="preserve">
          <source>INDIVIDUAL RESULTS</source>
          <target state="translated">개별 결과</target>
        </trans-unit>
        <trans-unit id="87d0fcde0a601e06d986c8740283892296dbb885" translate="yes" xml:space="preserve">
          <source>INHERITANCE</source>
          <target state="translated">INHERITANCE</target>
        </trans-unit>
        <trans-unit id="bc46a4e0420d357db7bfbcb7b5fcbc613dc48c1b" translate="yes" xml:space="preserve">
          <source>INIT</source>
          <target state="translated">INIT</target>
        </trans-unit>
        <trans-unit id="59990b467aae79667fd3fe1156086a0a147fb594" translate="yes" xml:space="preserve">
          <source>INIT HOOKS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c335a27a082cc8d17dd36dc0eda3086cb0c9baaa" translate="yes" xml:space="preserve">
          <source>INSTALL</source>
          <target state="translated">INSTALL</target>
        </trans-unit>
        <trans-unit id="bcfd83b3c8dcdbc242801037551b58c708467a92" translate="yes" xml:space="preserve">
          <source>INSTALL PERL ON CYGWIN</source>
          <target state="translated">CYGWIN에 PERL 설치</target>
        </trans-unit>
        <trans-unit id="b3642e83164b0035941a17dcaac1e8efc8ccc9e9" translate="yes" xml:space="preserve">
          <source>INSTALLARCHLIB</source>
          <target state="translated">INSTALLARCHLIB</target>
        </trans-unit>
        <trans-unit id="9d09dba09f4e15504911bf4a5e67189762904dd8" translate="yes" xml:space="preserve">
          <source>INSTALLATION</source>
          <target state="translated">INSTALLATION</target>
        </trans-unit>
        <trans-unit id="e5f21f5cfe15896cc57e4f66a25de31e67f38e54" translate="yes" xml:space="preserve">
          <source>INSTALLBIN</source>
          <target state="translated">INSTALLBIN</target>
        </trans-unit>
        <trans-unit id="a8dc0b332a8b3a30e1a3bfbf06a9ca622fa8b35a" translate="yes" xml:space="preserve">
          <source>INSTALLDIRS</source>
          <target state="translated">INSTALLDIRS</target>
        </trans-unit>
        <trans-unit id="16fff6f9fc1411630b91667c135606baff1eac91" translate="yes" xml:space="preserve">
          <source>INSTALLING PERL IN OPENVOS</source>
          <target state="translated">OPENVOS에서 PERL 설치</target>
        </trans-unit>
        <trans-unit id="7f052cc6553ecac6e3df0d0b879d905d556954d5" translate="yes" xml:space="preserve">
          <source>INSTALLMAN1DIR</source>
          <target state="translated">INSTALLMAN1DIR</target>
        </trans-unit>
        <trans-unit id="0e681f5032851ed30a543a900ac579e142841900" translate="yes" xml:space="preserve">
          <source>INSTALLMAN3DIR</source>
          <target state="translated">INSTALLMAN3DIR</target>
        </trans-unit>
        <trans-unit id="5933a08af3c7bebbbe6c3b67d67acaea7b113126" translate="yes" xml:space="preserve">
          <source>INSTALLPRIVLIB</source>
          <target state="translated">INSTALLPRIVLIB</target>
        </trans-unit>
        <trans-unit id="0c644278acf33a9a81880f74ea11f3e383631b34" translate="yes" xml:space="preserve">
          <source>INSTALLSCRIPT</source>
          <target state="translated">INSTALLSCRIPT</target>
        </trans-unit>
        <trans-unit id="54fcbd0bdcbf148e12836065934bc12897303524" translate="yes" xml:space="preserve">
          <source>INSTALLSITEARCH</source>
          <target state="translated">INSTALLSITEARCH</target>
        </trans-unit>
        <trans-unit id="89655a121385e7efe5f2cdc5a6d3add0eebb0223" translate="yes" xml:space="preserve">
          <source>INSTALLSITEBIN</source>
          <target state="translated">INSTALLSITEBIN</target>
        </trans-unit>
        <trans-unit id="933a51e99c70b3ad9b7b202ddc1482a7c0f44d60" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB</source>
          <target state="translated">INSTALLSITELIB</target>
        </trans-unit>
        <trans-unit id="df84db65783bcfd646d621819ed5a53534ed4081" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB=i:\perl\lib</source>
          <target state="translated">INSTALLSITELIB=i:\perl\lib</target>
        </trans-unit>
        <trans-unit id="26ed8090363cf70046fb05d12bd5b73ad1feec3a" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN1DIR</source>
          <target state="translated">INSTALLSITEMAN1DIR</target>
        </trans-unit>
        <trans-unit id="1df2b4517a777a7e926d6a7992d6ee2806c0c778" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN3DIR</source>
          <target state="translated">INSTALLSITEMAN3DIR</target>
        </trans-unit>
        <trans-unit id="ce3a6803fc962f8355f8305d4755ca6b09a83fff" translate="yes" xml:space="preserve">
          <source>INSTALLSITESCRIPT</source>
          <target state="translated">INSTALLSITESCRIPT</target>
        </trans-unit>
        <trans-unit id="8fee1b3f92888427d17dfd354d028dcbcbc0ee9c" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORARCH</source>
          <target state="translated">INSTALLVENDORARCH</target>
        </trans-unit>
        <trans-unit id="8b9cc74bd95a4dcfb94e960cfd6efdacf510a333" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORBIN</source>
          <target state="translated">INSTALLVENDORBIN</target>
        </trans-unit>
        <trans-unit id="c8fe30115e9bf08d3e86930e4100d4ce2c1a6393" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORLIB</source>
          <target state="translated">INSTALLVENDORLIB</target>
        </trans-unit>
        <trans-unit id="e80dab2a62b5932a7c992c9d56713d5afabb5666" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN1DIR</source>
          <target state="translated">INSTALLVENDORMAN1DIR</target>
        </trans-unit>
        <trans-unit id="635ef78bb9259eec612010b989a90be923912f75" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN3DIR</source>
          <target state="translated">INSTALLVENDORMAN3DIR</target>
        </trans-unit>
        <trans-unit id="64618110e901d3a5a0394dcdad64f11844b60749" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORSCRIPT</source>
          <target state="translated">INSTALLVENDORSCRIPT</target>
        </trans-unit>
        <trans-unit id="f1bd7855c675170fd5743049f5030b83e6d9486c" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE</source>
          <target state="translated">INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="972644501aef360867a4520d3945803529f2cc3e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE can be passed into Makefile.PL to change where your module will be installed. INSTALL_BASE is more like what everyone else calls &quot;prefix&quot; than PREFIX is.</source>
          <target state="translated">INSTALL_BASE는 Makefile.PL로 전달되어 모듈 설치 위치를 변경할 수 있습니다. INSTALL_BASE는 다른 사람들이 PREFIX보다 &quot;접두사&quot;라고 부르는 것과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="964f70f55608056234ee8f272195661f239be038" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE in MakeMaker and &lt;code&gt;--install_base&lt;/code&gt; in Module::Build (as of 0.28) install to the same location. If you want MakeMaker and Module::Build to install to the same location simply set INSTALL_BASE and &lt;code&gt;--install_base&lt;/code&gt; to the same location.</source>
          <target state="translated">MakeMaker의 INSTALL_BASE와 Module :: Build의 &lt;code&gt;--install_base&lt;/code&gt; (0.28 기준)는 동일한 위치에 설치됩니다. MakeMaker와 Module :: Build를 같은 위치에 설치하려면 INSTALL_BASE와 &lt;code&gt;--install_base&lt;/code&gt; 를 같은 위치로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f863f63a3576929f3be4a5b8b4b41019807a08" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE tells these tools to put your modules into</source>
          <target state="translated">INSTALL_BASE는 이러한 도구에 모듈을 넣도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7b883de1f22bd64a8fb3db547deeba102b803a0e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE was added in 6.31.</source>
          <target state="translated">INSTALL_BASE는 6.31에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="886581b5b89b6e85f222ace37294af35562883c9" translate="yes" xml:space="preserve">
          <source>INST_ARCHLIB</source>
          <target state="translated">INST_ARCHLIB</target>
        </trans-unit>
        <trans-unit id="8a2379bc7653dd5379a3e78bb80106b03ea038a2" translate="yes" xml:space="preserve">
          <source>INST_BIN</source>
          <target state="translated">INST_BIN</target>
        </trans-unit>
        <trans-unit id="b3767b1163f565cbd5848c1ada0a99e721fdaa0f" translate="yes" xml:space="preserve">
          <source>INST_LIB</source>
          <target state="translated">INST_LIB</target>
        </trans-unit>
        <trans-unit id="391959e82830797dda34f122ffd715943af1eafc" translate="yes" xml:space="preserve">
          <source>INST_MAN1DIR</source>
          <target state="translated">INST_MAN1DIR</target>
        </trans-unit>
        <trans-unit id="eb72524f0c074de5e6da6ca437d4e86dc340dc3b" translate="yes" xml:space="preserve">
          <source>INST_MAN3DIR</source>
          <target state="translated">INST_MAN3DIR</target>
        </trans-unit>
        <trans-unit id="0e2cba5b7722f5d7d798d0a11841e1fc5d220d67" translate="yes" xml:space="preserve">
          <source>INST_SCRIPT</source>
          <target state="translated">INST_SCRIPT</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="325df994199a5a3b5bfde97c65a8f35d498e9bab" translate="yes" xml:space="preserve">
          <source>INTERNAL FORMAT</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="f2ee4f9d199f048c10a5b49f80f81e925ff271d9" translate="yes" xml:space="preserve">
          <source>INTERNAL VARIABLE TYPES</source>
          <target state="translated">내부 변수 유형</target>
        </trans-unit>
        <trans-unit id="ae880205d974d478a4f8301ed9ed724acfe764dd" translate="yes" xml:space="preserve">
          <source>INTERNALS</source>
          <target state="translated">INTERNALS</target>
        </trans-unit>
        <trans-unit id="0270ca97abe5bddc53ed95fb7179da4406621a18" translate="yes" xml:space="preserve">
          <source>INTRODUCTION</source>
          <target state="translated">INTRODUCTION</target>
        </trans-unit>
        <trans-unit id="0f6bca99bbb2a730f1c35f8aa2b2773658a27931" translate="yes" xml:space="preserve">
          <source>INTUIT</source>
          <target state="translated">INTUIT</target>
        </trans-unit>
        <trans-unit id="ce753ef37866a2969f587c295482b688037bd94e" translate="yes" xml:space="preserve">
          <source>IN_LOCALE</source>
          <target state="translated">IN_LOCALE</target>
        </trans-unit>
        <trans-unit id="4e3731a31894b7187bb76565396bb61a32a82161" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_COMPILETIME</source>
          <target state="translated">IN_LOCALE_COMPILETIME</target>
        </trans-unit>
        <trans-unit id="b36325353ec225c227d7b482dcf439805cffb50a" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_RUNTIME</source>
          <target state="translated">IN_LOCALE_RUNTIME</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="9703b620b98df0424c1d2891029b0a53270adadc" translate="yes" xml:space="preserve">
          <source>IO - load various IO modules</source>
          <target state="translated">IO-다양한 IO 모듈로드</target>
        </trans-unit>
        <trans-unit id="8218c7c584e2e73f83429a7a715ed0c77b1e9143" translate="yes" xml:space="preserve">
          <source>IO Functions</source>
          <target state="translated">IO 기능</target>
        </trans-unit>
        <trans-unit id="8e8c7b4a7985c2b9c9f4e596a14848275f335be5" translate="yes" xml:space="preserve">
          <source>IO Redirect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4992825d003b9237bfbb2d1eeebbc4148368e7" translate="yes" xml:space="preserve">
          <source>IO layers (like '%s') unavailable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95153958c8a3fc0d7cc0242c39911001df17f39d" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82ec6ecdf1d506a4bc4471deaf660ec582141" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: &lt;a href=&quot;compress/zlib&quot;&gt;Compress :: Zlib에 대한&lt;/a&gt; 스타일 인터페이스</target>
        </trans-unit>
        <trans-unit id="d76ad5f2ab8e85a14e373d86896f0b50ad94632d" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base</source>
          <target state="translated">IO::Compress::Base</target>
        </trans-unit>
        <trans-unit id="f7a823195ba1022235bbaa930f5dacd9dcd2cde3" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base - Base Class for IO::Compress modules</source>
          <target state="translated">IO :: Compress :: Base-IO :: Compress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="2246092601d71db730b1277537bdfeb99922692b" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2</source>
          <target state="translated">IO::Compress::Bzip2</target>
        </trans-unit>
        <trans-unit id="4c110e2dd18855a5ac17fa0ff96df45279296253" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2 - Write bzip2 files/buffers</source>
          <target state="translated">IO :: Compress :: Bzip2-쓰기 bzip2 파일 / 버퍼</target>
        </trans-unit>
        <trans-unit id="faeedf86bc5c3bf443dc7cb32aca40a75c1a61b1" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate</source>
          <target state="translated">IO::Compress::Deflate</target>
        </trans-unit>
        <trans-unit id="a24fa13516822c712bdf720b0c4b0786c457612f" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate - Write RFC 1950 files/buffers</source>
          <target state="translated">IO :: Compress :: Deflate-RFC 1950 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="f27ab19280760fb919a1e3287acc4b2ced04c845" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ</source>
          <target state="translated">IO::Compress::FAQ</target>
        </trans-unit>
        <trans-unit id="7dd8dce39506e0315c95f5807e0b2eb0d3b042f5" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fa9683b439c9ad1a7266191cc46683626bdae6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip</source>
          <target state="translated">IO::Compress::Gzip</target>
        </trans-unit>
        <trans-unit id="9e41ceaa77fd713ed3c8d8b1bfe6a609a7ddcea6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip - Write RFC 1952 files/buffers</source>
          <target state="translated">IO :: Compress :: Gzip-RFC 1952 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="3205da05670e0698dd32ff4811dcf7e209aab757" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate</source>
          <target state="translated">IO::Compress::RawDeflate</target>
        </trans-unit>
        <trans-unit id="94bf2f893b55a2f57dfacc0d6c1e83c0ef44793d" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate - Write RFC 1951 files/buffers</source>
          <target state="translated">IO :: Compress :: RawDeflate-RFC 1951 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="7015e5f6eae1214c2df0155ccaef808cdc7d0769" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip</source>
          <target state="translated">IO::Compress::Zip</target>
        </trans-unit>
        <trans-unit id="b05cb1e00a4226cff2f721fcd3f609b4ad94b38c" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip - Write zip files/buffers</source>
          <target state="translated">IO :: Compress :: Zip-zip 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="4bf7c8cfd258e92c5a7a288432da2eb725c5d32c" translate="yes" xml:space="preserve">
          <source>IO::Dir</source>
          <target state="translated">IO::Dir</target>
        </trans-unit>
        <trans-unit id="f3b94128fba8d6583679638179ef4a0530bdd5d3" translate="yes" xml:space="preserve">
          <source>IO::Dir - supply object methods for directory handles</source>
          <target state="translated">IO :: Dir-디렉토리 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="1287d92d070eaf8f54116ae56a21bfe69917a99d" translate="yes" xml:space="preserve">
          <source>IO::File</source>
          <target state="translated">IO::File</target>
        </trans-unit>
        <trans-unit id="aef399115f05d82a203fb89d5e657a748c3e82de" translate="yes" xml:space="preserve">
          <source>IO::File - supply object methods for filehandles</source>
          <target state="translated">IO :: File-파일 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="85678e755d6fdd386f63c43333047c282a85eb74" translate="yes" xml:space="preserve">
          <source>IO::Handle</source>
          <target state="translated">IO::Handle</target>
        </trans-unit>
        <trans-unit id="d2ccf931b06cca09cc21fc6e3f7adaeb42eedc30" translate="yes" xml:space="preserve">
          <source>IO::Handle - supply object methods for I/O handles</source>
          <target state="translated">IO :: Handle-I / O 핸들에 대한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="33e6674e03fd1f9387dffec88a9442f12eb239c1" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_formfeed(EXPR)</source>
          <target state="translated">IO::Handle-&amp;gt;format_formfeed(EXPR)</target>
        </trans-unit>
        <trans-unit id="4328314a142bc495dbcedc8dec821af05b31bc33" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_line_break_characters EXPR</source>
          <target state="translated">IO :: 핸들-&amp;gt; format_line_break_characters EXPR</target>
        </trans-unit>
        <trans-unit id="6e5d46bf8e867cd748990f3121e29b41bc040337" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;input_record_separator( EXPR )</source>
          <target state="translated">IO :: 핸들-&amp;gt; 입력 _ 레코드 _ 분리기 (EXPR)</target>
        </trans-unit>
        <trans-unit id="88d38bb7198b1035ad2fe3e3a4c8b631ea81ae89" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_field_separator( EXPR )</source>
          <target state="translated">IO :: 핸들-&amp;gt; output_field_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="960c5c651b09566f1754a215a5295869a49e219e" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_record_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="7d7436d4629d382e64fc528a233e4705d021fb55" translate="yes" xml:space="preserve">
          <source>IO::Pipe</source>
          <target state="translated">IO::Pipe</target>
        </trans-unit>
        <trans-unit id="00e90fb1e0a6527593ec48869ad8bdd4be4727ec" translate="yes" xml:space="preserve">
          <source>IO::Pipe - supply object methods for pipes</source>
          <target state="translated">IO :: Pipe-파이프에 대한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="7411852690ce77d3e52c0392cb140a1da3c8926a" translate="yes" xml:space="preserve">
          <source>IO::Poll</source>
          <target state="translated">IO::Poll</target>
        </trans-unit>
        <trans-unit id="4af10858345e94c5247f732b4f8aeefb3d3033f8" translate="yes" xml:space="preserve">
          <source>IO::Poll - Object interface to system poll call</source>
          <target state="translated">IO :: Poll-시스템 폴 호출에 대한 오브젝트 인터페이스</target>
        </trans-unit>
        <trans-unit id="a68be240586077bf55c7114e0c2dd0a3089b0b00" translate="yes" xml:space="preserve">
          <source>IO::Seekable</source>
          <target state="translated">IO::Seekable</target>
        </trans-unit>
        <trans-unit id="aca83121c079f3f44793e1fb400037048e6c0ec3" translate="yes" xml:space="preserve">
          <source>IO::Seekable - supply seek based methods for I/O objects</source>
          <target state="translated">IO :: 검색 가능-I / O 객체에 대한 검색 기반 검색 방법</target>
        </trans-unit>
        <trans-unit id="a4d83b02d49f96871e2c2e3d92dc1e0d34ec01f3" translate="yes" xml:space="preserve">
          <source>IO::Select</source>
          <target state="translated">IO::Select</target>
        </trans-unit>
        <trans-unit id="f909f3c8685d0640556ffd855c6e6b3161826eb6" translate="yes" xml:space="preserve">
          <source>IO::Select - OO interface to the select system call</source>
          <target state="translated">IO :: Select-선택 시스템 호출에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="77ccdb7781ae721df7a63530341f8d0e30eb9ba3" translate="yes" xml:space="preserve">
          <source>IO::Socket</source>
          <target state="translated">IO::Socket</target>
        </trans-unit>
        <trans-unit id="bcf86f1138a4fa3de29dc58d70750df124a76378" translate="yes" xml:space="preserve">
          <source>IO::Socket - Object interface to socket communications</source>
          <target state="translated">IO :: Socket-소켓 통신을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="d9cad026ce1354129e7518abf6e60742a423f5cd" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET</source>
          <target state="translated">IO::Socket::INET</target>
        </trans-unit>
        <trans-unit id="21c7e3d3993af799697bb17b584159010291f1ca" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET - Object interface for AF_INET domain sockets</source>
          <target state="translated">IO :: Socket :: INET-AF_INET 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="847540cd1ff5e36f63fe89cede6f91a6c8dc3cc9" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET INCOMPATIBILITES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c6a2e029e8c8c79ed477acabec06a520b7120a" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP</source>
          <target state="translated">IO::Socket::IP</target>
        </trans-unit>
        <trans-unit id="f8d87248556e958244a0c1aaa8d71d0e3f955f2d" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP version 0.25 or IO::Socket::INET6 version 2.62 is required for IPv6 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef92351b8f3537bb6cc9713b22a0a29a3dd06aa7" translate="yes" xml:space="preserve">
          <source>IO::Socket::SSL version 2.007 or higher is required for SSL support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d370bee8efab5b347f028125483323b0c8ed6d8" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX</source>
          <target state="translated">IO::Socket::UNIX</target>
        </trans-unit>
        <trans-unit id="fd6fc205eb14f250173655f91ae8e3991e80a0fc" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX - Object interface for AF_UNIX domain sockets</source>
          <target state="translated">IO :: Socket :: UNIX-AF_UNIX 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="d387a4118fc41f5c91b925119de8c6c9b651a7b5" translate="yes" xml:space="preserve">
          <source>IO::Socket::atmark not implemented on this architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9efdf30a325c69f4eff01ffa74edfa8d13285c" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate</source>
          <target state="translated">IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="3f52359b31109c62a3cfec4235eb32afa54b7e76" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">IO :: Uncompress :: AnyInflate-zlib 기반 (zip, gzip) 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="9bcf772c56ff61361b8adfe8ed0930e47dd806cc" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress</source>
          <target state="translated">IO::Uncompress::AnyUncompress</target>
        </trans-unit>
        <trans-unit id="da915e62cd2924afaf5bdf41d62bf124d1816c96" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">IO :: Uncompress :: AnyUncompress-gzip, zip, bzip2 또는 lzop 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="a94c8d52ccfd5a43c50325b3be6e5dc8c0de211d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9d98befeabd4f68c0ee5ed490ad9ef9466ce0b" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base</source>
          <target state="translated">IO::Uncompress::Base</target>
        </trans-unit>
        <trans-unit id="6dd0aef5e96daa96cabb662e679bcaf3f782ff34" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base - Base Class for IO::Uncompress modules</source>
          <target state="translated">IO :: Uncompress :: Base-IO :: Uncompress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="47626e73b0c552496671b93615517289c7a72139" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2</source>
          <target state="translated">IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="558fc1d47555183743c62caa50f8fea7e57150e4" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2 - Read bzip2 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Bunzip2-bzip2 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="c56a044dac563ce20e270b6dad9d51e1ed4d67b5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip</source>
          <target state="translated">IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="6858dbc4b4fa294b4bc17de10e3aec6d95c7a29d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip - Read RFC 1952 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Gunzip-RFC 1952 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="bdd707a0a7c129500d87baf2238a9f12252dc1a6" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate</source>
          <target state="translated">IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="9ea3fd5cd65551930396ea883f6b4523a57e56f5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate - Read RFC 1950 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Inflate-RFC 1950 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="2387ca346858e6f631ae40207df5832845bfa4d3" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate</source>
          <target state="translated">IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="0d1105cd05d8ddcb7bbad73158149f37cd425d0a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate - Read RFC 1951 files/buffers</source>
          <target state="translated">IO :: Uncompress :: RawInflate-RFC 1951 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="eb25986effc3adf3d081252f8af9cf0ffcfb3a8a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip</source>
          <target state="translated">IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="7aed8f7e034916e56f4674cc0310d37a446ee94f" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip - Read zip files/buffers</source>
          <target state="translated">IO :: Uncompress :: Unzip-zip 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="f4c4eb93eddc35e78414020ae5db828e1e7864b8" translate="yes" xml:space="preserve">
          <source>IO::Zlib</source>
          <target state="translated">IO::Zlib</target>
        </trans-unit>
        <trans-unit id="d04446e459b1e71b578f998f8ab90764c4b0f8e3" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib-IO :: &lt;a href=&quot;../compress/zlib&quot;&gt;Compress :: Zlib에 대한&lt;/a&gt; 스타일 인터페이스</target>
        </trans-unit>
        <trans-unit id="1a833dc84965b791c8180a7f9bca2ad00d4ae502" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f1ff5ae16f8f008a024c94a2871ed43a079e29" translate="yes" xml:space="preserve">
          <source>IO::Zlib::READ: NBYTES must be specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b518756109da5b44c543995580fa7fa3fe28da6b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::WRITE: too long LENGTH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16afa17f59e61e732bb594e1d07367170d0e3516" translate="yes" xml:space="preserve">
          <source>IO::Zlib::getlines: must be called in list context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744b77ff3abbf3b6e1e64e30f7190f2e0e168879" translate="yes" xml:space="preserve">
          <source>IO::Zlib::gzopen_external: mode '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ece9d22f9b2c053955dd1211c105cea7756474" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84556d1d56bdf3da066fa6199f9990e8d2a4eaa9" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: ':gzip_external' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33a6e3d14094a99186bbb131dd967ca442a99e2" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read' '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430510c63254c938fe8a419081620b44e9a63369" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read_open' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef06ad0f4357c011fb32988808d09f0b27277a4" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cbd51a10bd74c633549cef79628135e981981b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cde92750a3d48d656e69ded8901f66e2e3f4c3" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: no Compress::Zlib and no external gzip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baefedf7f6990fe793b903ceae7ef91bfaf79c09" translate="yes" xml:space="preserve">
          <source>IO::Zlib::open: needs a filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea424d38af72dd1366a08aad1f47eca3e7ec3d24" translate="yes" xml:space="preserve">
          <source>IP</source>
          <target state="translated">IP</target>
        </trans-unit>
        <trans-unit id="e66f01e3abb1a4678f130fa0379ceec3adaec42e" translate="yes" xml:space="preserve">
          <source>IP protocol constants to use as the third argument to socket(), the level argument to getsockopt() or setsockopt(), or the value of the &lt;code&gt;SO_PROTOCOL&lt;/code&gt; socket option.</source>
          <target state="translated">socket ()에 대한 세 번째 인수, getsockopt () 또는 setsockopt ()에 대한 레벨 인수 또는 &lt;code&gt;SO_PROTOCOL&lt;/code&gt; 소켓 옵션 의 값으로 사용할 IP 프로토콜 상수 .</target>
        </trans-unit>
        <trans-unit id="061b6bad243fee6cf3f9b677d21494fee55f1c64" translate="yes" xml:space="preserve">
          <source>IPA</source>
          <target state="translated">IPA</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="d54b59c534e736687131e3ec256172d1adbc895d" translate="yes" xml:space="preserve">
          <source>IPC AND CONCURRENCY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e5cff8767ed4c7882144c6f5c7afd4a74a2869" translate="yes" xml:space="preserve">
          <source>IPC drivers live in this namespace. It is fine to create new IPC drivers and to put them in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bb80888fafae35a8c04a482f4c52ba12354860" translate="yes" xml:space="preserve">
          <source>IPC::Cmd</source>
          <target state="translated">IPC::Cmd</target>
        </trans-unit>
        <trans-unit id="4aa727aa3bbf49a23200ff9a15dd661ace7ba750" translate="yes" xml:space="preserve">
          <source>IPC::Cmd - finding and running system commands made easy</source>
          <target state="translated">IPC :: Cmd-시스템 명령을 쉽게 찾고 실행</target>
        </trans-unit>
        <trans-unit id="9e94bec610bda8b6d6dba9768e7c89860ea7cbd2" translate="yes" xml:space="preserve">
          <source>IPC::Cmd allows you to run commands platform independently, interactively if desired, but have them still work.</source>
          <target state="translated">IPC :: Cmd를 사용하면 원하는 경우 대화식으로 명령 플랫폼을 독립적으로 실행할 수 있지만 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="55a4e391e67ff1bdcc3e16ba0fb5ae458ce57904" translate="yes" xml:space="preserve">
          <source>IPC::Msg</source>
          <target state="translated">IPC::Msg</target>
        </trans-unit>
        <trans-unit id="6b32de39850adb752165f60b3bda5f0d97f34ff3" translate="yes" xml:space="preserve">
          <source>IPC::Msg - SysV Msg IPC object class</source>
          <target state="translated">IPC :: Msg-SysV Msg IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="9dd902f8639b58e7edb7b6f8c06c22ac41c9ca2e" translate="yes" xml:space="preserve">
          <source>IPC::Open2</source>
          <target state="translated">IPC::Open2</target>
        </trans-unit>
        <trans-unit id="699765d9577f1c1501174faba27f2ca1f61d47cd" translate="yes" xml:space="preserve">
          <source>IPC::Open2 - open a process for both reading and writing using open2()</source>
          <target state="translated">IPC :: Open2-open2 ()를 사용하여 읽고 쓰는 프로세스를 엽니 다</target>
        </trans-unit>
        <trans-unit id="6e80951681402ceb79b82897f2cb2015d59ab625" translate="yes" xml:space="preserve">
          <source>IPC::Open3</source>
          <target state="translated">IPC::Open3</target>
        </trans-unit>
        <trans-unit id="cbebbea4476633d292dae0e9b37d3ff0220e8a12" translate="yes" xml:space="preserve">
          <source>IPC::Open3 - open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">IPC :: Open3-open3 ()을 사용하여 읽기, 쓰기 및 오류 처리를위한 프로세스 열기</target>
        </trans-unit>
        <trans-unit id="e9c314ea8a55f232d58be815a30ee23b54cdb80b" translate="yes" xml:space="preserve">
          <source>IPC::Run</source>
          <target state="translated">IPC::Run</target>
        </trans-unit>
        <trans-unit id="5696dbec647d54eae7948ff758da75aceb6e7bdd" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore</source>
          <target state="translated">IPC::Semaphore</target>
        </trans-unit>
        <trans-unit id="4ac3e2f97ecebc0c9df272394b412c2bc0e4c139" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore - SysV Semaphore IPC object class</source>
          <target state="translated">IPC :: Semaphore-SysV 세마포어 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="eaac05351199d5338d0c67774a49f0ff5b08ddcd" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem</source>
          <target state="translated">IPC::SharedMem</target>
        </trans-unit>
        <trans-unit id="b67329129b7437abd470390d9b8de8b506578731" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem - SysV Shared Memory IPC object class</source>
          <target state="translated">IPC :: SharedMem-SysV 공유 메모리 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="cac6bf077ecf12b8c4774537cb90121c12f40546" translate="yes" xml:space="preserve">
          <source>IPC::SysV</source>
          <target state="translated">IPC::SysV</target>
        </trans-unit>
        <trans-unit id="4a65a5b9999ec2f5bcb9aefce9ed4d2ebb83e351" translate="yes" xml:space="preserve">
          <source>IPC::SysV - System V IPC constants and system calls</source>
          <target state="translated">IPC :: SysV-시스템 V IPC 상수 및 시스템 호출</target>
        </trans-unit>
        <trans-unit id="eb04f21953f498789cba10742ad8acc6a3a6d8ee" translate="yes" xml:space="preserve">
          <source>IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR, instead of</source>
          <target state="translated">IPC :: [Run | Open3]은 먼저 모든 STDOUT을 읽은 다음 모든 STDERR을 읽습니다. 즉, 출력은 STDOUT에서 '13', STDERR에서 '24'로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c31963d765721dcd50b3ac6ea7828e71081eb9d0" translate="yes" xml:space="preserve">
          <source>IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</source>
          <target state="translated">IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</target>
        </trans-unit>
        <trans-unit id="d605f8c901e4d72b551c09d9a4925d13cd9fbbb6" translate="yes" xml:space="preserve">
          <source>IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</source>
          <target state="translated">IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</target>
        </trans-unit>
        <trans-unit id="b69eb35e4d4802a904ccf4f4eadf16b1c7831980" translate="yes" xml:space="preserve">
          <source>IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</source>
          <target state="translated">IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</target>
        </trans-unit>
        <trans-unit id="5dcc16ca06e8e1e2d76e2715098a08de9cb62845" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS, IP_TOS, IP_TTL, ...</source>
          <target state="translated">IP_OPTIONS, IP_TOS, IP_TTL, ...</target>
        </trans-unit>
        <trans-unit id="52736177bb0ddc7186d53ccc0e904a6fc38535ec" translate="yes" xml:space="preserve">
          <source>IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="e845e309f2bc4605301c4c8195c02b9ee45aab86" translate="yes" xml:space="preserve">
          <source>IRIX 6.5 documentation on syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 IRIX 6.5 설명서, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e349cb6fd67b0b7af90f7902a26799f4b980ca8" translate="yes" xml:space="preserve">
          <source>IRIX documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&quot;&gt;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407683774352e467c08d20959c8dcea8f6ef7fa7" translate="yes" xml:space="preserve">
          <source>ISIRI 3342, Iran System, ISIRI 2900 [Farsi]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="f776e0bcef88f6053e04b30cd9568a2f517c3848" translate="yes" xml:space="preserve">
          <source>ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it. Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.</source>
          <target state="translated">ISO 6429는 ISO에서 유료로 제공됩니다. 이 모듈의 작성자는 해당 모듈의 사본을 소유하지 않습니다. ISO 6429의 소스 자료는 ECMA-048이고 후자는 무료로 제공되므로 ISO 표준을 얻을 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="3353e215f71b71f7414efad5057c41576384753e" translate="yes" xml:space="preserve">
          <source>ISO 8859</source>
          <target state="translated">ISO 8859</target>
        </trans-unit>
        <trans-unit id="8fb0773017f88d072a29c4af9bf4189cc9c9a466" translate="yes" xml:space="preserve">
          <source>ISO 8859-1 (Latin-1)</source>
          <target state="translated">ISO 8859-1 (라틴 -1)</target>
        </trans-unit>
        <trans-unit id="58189607ac5de761659ad85bfe08184fa60a5f97" translate="yes" xml:space="preserve">
          <source>ISO codes for country sub-divisions (states, counties, provinces, etc), as defined in ISO 3166-2. This module is not part of the Locale-Codes distribution, but is available from CPAN in CPAN/modules/by-module/Locale/</source>
          <target state="translated">ISO 3166-2에 정의 된 국가 하위 구역 (주, 카운티, 주 등)에 대한 ISO 코드. 이 모듈은 로케일 코드 분배의 일부는 아니지만 CPAN / 모듈 / 모듈 / 로케일 /의 CPAN에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2ee43903e014e67bbc02a16177f46410f4c5e2d5" translate="yes" xml:space="preserve">
          <source>ISO-2022</source>
          <target state="translated">ISO-2022</target>
        </trans-unit>
        <trans-unit id="0be641e76803b7f8b2767005594a25c505dcb463" translate="yes" xml:space="preserve">
          <source>ISO-2022-CN [RFC1922]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2562b9e7af09019f9f6f2808d127ef571d29778" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which adds support for JIS X 0212-1990. That means you can use the same code to decode to utf8 but not vice versa.</source>
          <target state="translated">ISO-2022-JP-1 (RFC2237)은 JIS X 0212-1990에 대한 지원을 추가하는 ISO-2022-JP (RFC1468)의 상위 집합입니다. 즉, 동일한 코드를 사용하여 utf8로 디코딩 할 수 있지만 그 반대의 경우는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="29cc7458d9efed7fe50460a3c77c7b87ac7a4db4" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-2 [RFC1554]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ffbc186932bc40f01e94ff7f5da5bf38a7154e" translate="yes" xml:space="preserve">
          <source>ISO-8859 and corresponding vendor mappings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19de626ae38d6fda9f9525299d239d5c0047248b" translate="yes" xml:space="preserve">
          <source>ISO-8859-8-1 [Hebrew]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846e5e5cfd7e004c49ed6ae8c1a88eb61f8816e2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 10646 encoding form: Universal Character Set coded in two octets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dc9cc90e3e41be961fd70df5f28ccfd86e620a" translate="yes" xml:space="preserve">
          <source>ISSUES</source>
          <target state="translated">ISSUES</target>
        </trans-unit>
        <trans-unit id="c5d9779f83f04a49a66dda9ed50dc9241b27d743" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_GREATER_THAN_UV_MAX bool IS_NUMBER_GREATER_THAN_UV_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f5693602a943228410c2db90175bdc9e162f71" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_INFINITY bool IS_NUMBER_INFINITY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed51a22a984a7a3384cf7607e6083139f796bac6" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_IN_UV bool IS_NUMBER_IN_UV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b619f91f9748472f17789ce360cdba95124ee65" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NAN bool IS_NUMBER_NAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63251c261b533d85d9b19ec08396f8b333d44ea2" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NEG bool IS_NUMBER_NEG</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d56a5e4d44a907f0379be77749d8420d47b899" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT</source>
          <target state="translated">IS_NUMBER_NOT_INT</target>
        </trans-unit>
        <trans-unit id="6c84053d4886e789ea8b111c5248970e59a2046c" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were seen (in which case *valuep gives the true value truncated to an integer), and IS_NUMBER_NEG if the number is negative (in which case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e notation was used or the number is larger than a UV.</source>
          <target state="translated">IS_NUMBER_NOT_INT는 소수점 이하 자릿수가 보이는 경우 IS_NUMBER_IN_UV로 설정되며 (이 경우 * valuep는 정수로 잘린 실제 값을 제공함) 숫자가 음수 인 경우 IS_NUMBER_NEG (이 경우 * valuep는 절대 값을 보유 함)입니다. e 표기법을 사용했거나 숫자가 UV보다 큰 경우 IS_NUMBER_IN_UV는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a41c9a62c208bda09b6e0e4693fb0c85b4373197" translate="yes" xml:space="preserve">
          <source>IS_SAFE_SYSCALL</source>
          <target state="translated">IS_SAFE_SYSCALL</target>
        </trans-unit>
        <trans-unit id="e849c5f96439c1fe622e4ace3225dd079d5ce0bc" translate="yes" xml:space="preserve">
          <source>ITEM</source>
          <target state="translated">ITEM</target>
        </trans-unit>
        <trans-unit id="e98fda145e73c44d41ee1cf81a9942997f60dc03" translate="yes" xml:space="preserve">
          <source>ITEM...</source>
          <target state="translated">ITEM...</target>
        </trans-unit>
        <trans-unit id="81355db038b4c2e62588bc2f02426816803c8b50" translate="yes" xml:space="preserve">
          <source>ITEMHASH</source>
          <target state="translated">ITEMHASH</target>
        </trans-unit>
        <trans-unit id="932eaaf5a36529c34a7868b56cba634f534f39b4" translate="yes" xml:space="preserve">
          <source>IV</source>
          <target state="translated">IV</target>
        </trans-unit>
        <trans-unit id="af7024f6a1aba1b8353a4f8d081230e10f559e67" translate="yes" xml:space="preserve">
          <source>IVX</source>
          <target state="translated">IVX</target>
        </trans-unit>
        <trans-unit id="3776b457f4a64c1c2e929c3beb97e225d7174238" translate="yes" xml:space="preserve">
          <source>Iain Truskett. Updated by the Perl 5 Porters.</source>
          <target state="translated">이언 트루 케트 Perl 5 포터가 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="18334cc78787c9bf930719c033735bf066a1783e" translate="yes" xml:space="preserve">
          <source>Idaho</source>
          <target state="translated">Idaho</target>
        </trans-unit>
        <trans-unit id="d3280028436889a62f2d1e26e6623a3b63327bf8" translate="yes" xml:space="preserve">
          <source>Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, wardrobe by Calvin Klein.</source>
          <target state="translated">Tony Bowden과 Paul Johnson의 아이디어, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;의 코드, Calvin Klein의 옷장.</target>
        </trans-unit>
        <trans-unit id="38eaa27bde2babc938a1d3f61f24a4c3c9ee9393" translate="yes" xml:space="preserve">
          <source>Ideally, all instances of &lt;code&gt;PL_sub_generation++&lt;/code&gt; in perl source outside of</source>
          <target state="translated">이상적으로 는 펄 소스 에있는 &lt;code&gt;PL_sub_generation++&lt;/code&gt; 의 모든 인스턴스 가</target>
        </trans-unit>
        <trans-unit id="e4477a644f309bbba5035bb03dd4d512f954eb2e" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501684b206c21ec5483e8cb92e79c26ad4af36ca" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code. To avoid this a future version of perl will throw an exception when any of sysread(), recv(), syswrite() or send() are called on handle with the &lt;code&gt;:utf8&lt;/code&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ac1e7c6fddbcf97426592a619f53420c1c124" translate="yes" xml:space="preserve">
          <source>Ideally, someone who's slightly familiar with your module should be able to refresh their memory without hitting &quot;page down&quot;. As your reader continues through the document, they should receive a progressively greater amount of knowledge.</source>
          <target state="translated">이상적으로 모듈에 약간 익숙한 사람은 &quot;페이지 다운&quot;을 누르지 않고 메모리를 새로 고칠 수 있어야합니다. 독자가 문서를 계속 읽으면 점차 많은 지식을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="6760494b3e87b72d6f704a16dfd8c909bfd06f21" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;&quot;lrint&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c30d178b22c94b418adae6de96d27ac6651de9" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lrint&quot;&gt;lrint와&lt;/a&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c269c4512ac345c8ac0e6a3f0761757db1ece435" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;grok_number_flags()&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189f7c8820b5d91329256424f9abd34533abf5d2" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt; , but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">&lt;code&gt;has_errors&lt;/code&gt; 와 동일 하지만 예기치 않은 TODO 테스트가 있으면 true를 리턴합니다. 이것은 &quot;경고&quot;와 더 유사합니다.</target>
        </trans-unit>
        <trans-unit id="0e295a166224f4ec773840e576cbbb4eea64c35a" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt;, but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49923c15da594194a42e0f23479dad9afb3e6e18" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;seek OFFSET, WHENCE&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725851e6339b491e1de8826e667b9695d8cea364" translate="yes" xml:space="preserve">
          <source>Identical to grok_number_flags() with flags set to zero.</source>
          <target state="translated">플래그가 0으로 설정된 grok_number_flags ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9052a2716f89fc7937386d07b0ec6eb570325f21" translate="yes" xml:space="preserve">
          <source>Identifier parsing</source>
          <target state="translated">식별자 파싱</target>
        </trans-unit>
        <trans-unit id="c9e9b7fc2f9e092c9b1b92a7e63d7d890ea86035" translate="yes" xml:space="preserve">
          <source>Identifier too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bd1c9d626bb40d98db0e06c9d88504407f597b" translate="yes" xml:space="preserve">
          <source>Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV. Although POSIX isn't entirely consistent across platforms, this is likely to be present in virtually all of them.</source>
          <target state="translated">_POSIX_ARG_MAX를 IV에 최적화 된 상수 서브로 식별합니다. POSIX가 여러 플랫폼에서 완전히 일치하지는 않지만 사실상 모든 플랫폼에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651807fc401b8332ec409deb81843bccbd052364" translate="yes" xml:space="preserve">
          <source>Identifies md5 as an XS function. The export is needed so that BC can find it in main.</source>
          <target state="translated">md5를 XS 함수로 식별합니다. BC 주가 주요 수출품을 찾을 수 있도록 수출이 필요하다.</target>
        </trans-unit>
        <trans-unit id="c85a93ef2b6eb1be3e8769838c333c812af4359a" translate="yes" xml:space="preserve">
          <source>Identify a remote machine name. The auto-login process searches the .netrc file for a machine token that matches the remote machine specified. Once a match is made, the subsequent .netrc tokens are processed, stopping when the end of file is reached or an- other machine or a default token is encountered.</source>
          <target state="translated">원격 시스템 이름을 식별하십시오. 자동 로그인 프로세스는 지정된 원격 시스템과 일치하는 시스템 토큰을 .netrc 파일에서 검색합니다. 일치하면 후속 .netrc 토큰이 처리되어 파일 끝에 도달하거나 다른 시스템 또는 기본 토큰에 도달하면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ad36a5ddf7af0b9b2aadce75c61491b0c464af3b" translate="yes" xml:space="preserve">
          <source>Identify a user on the remote machine. If this token is present, the auto-login process will initiate a login using the specified name.</source>
          <target state="translated">원격 시스템에서 사용자를 식별하십시오. 이 토큰이 있으면 자동 로그인 프로세스가 지정된 이름을 사용하여 로그인을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93ca58cc90c1952df3129b0ab2a244d796f9ba81" translate="yes" xml:space="preserve">
          <source>Identify and return the FQDN of the current host.</source>
          <target state="translated">현재 호스트의 FQDN을 식별하고 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="1b3b4987c2d4674f5207d125a1368bf151a6aeb4" translate="yes" xml:space="preserve">
          <source>Identify the C functions which use some inband info as an indication of failure. They may be candidates to return undef or an empty list in case of failure. If the failure may be detected without a call to the C function, you may want to use an INIT: section to report the failure. For failures detectable after the C function returns one may want to use a POSTCALL: section to process the failure. In more complicated cases use CODE: or PPCODE: sections.</source>
          <target state="translated">장애 표시로 일부 대역 정보를 사용하는 C 기능을 식별하십시오. 실패한 경우 undef 또는 빈 목록을 반환 할 수 있습니다. C 함수를 호출하지 않고 실패가 감지되면 INIT : 섹션을 사용하여 실패를보고 할 수 있습니다. C 함수가 리턴 된 후 감지 가능한 실패의 경우 POSTCALL : 섹션을 사용하여 실패를 처리 할 수 ​​있습니다. 더 복잡한 경우에는 CODE : 또는 PPCODE : 섹션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d8de6657b1cd9ff03db4bb8c676352163c1ab9" translate="yes" xml:space="preserve">
          <source>Identify the C functions with input/output or output parameters. The XSUBs for these functions may be able to return lists to Perl.</source>
          <target state="translated">입력 / 출력 또는 출력 매개 변수를 사용하여 C 기능을 식별하십시오. 이러한 함수에 대한 XSUB는 목록을 Perl로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f84ba2bf147a844b20d38f482ee57bb2e58f7e" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">C 함수 매개 변수 목록에서 포인터를 식별하고 값을 리턴하십시오. 일부 포인터는 입력 / 출력 또는 출력 매개 변수를 구현하는 데 사용될 수 있으며 XS에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 단항 연산자를 사용하거나 NO_INIT 키워드를 사용하여 처리 할 수 ​​있습니다 . 다른 것들은 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 와 같은 타입의 처리를 요구할 것이고, 그러한 경우에 유용한 Perl 변환이 무엇을할지 결정해야합니다. 시맨틱이 명확하면 변환을 유형 맵 파일에 넣는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="02c745f2a38f59b1173a4d016d93fc6da4107dea" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;int *&lt;/code&gt;, and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f574cc58fec6b5a326569871a9bc4c7e511150" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt; .)</source>
          <target state="translated">C 함수가 사용하는 구조를 식별하십시오. 많은 경우에 이러한 구조에 대해 T_PTROBJ 타입 맵을 사용하는 것이 도움이 될 수 있으므로 Perl에서 축복 된 객체로 조작 할 수 있습니다. 이것은 &lt;code&gt;h2xs -x&lt;/code&gt; 에 의해 자동으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="010ff5be16a493cb47c53ed9163162ed618b8c47" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cadfb291553bfe2fe292f1f1bdcc23146b4ce0c" translate="yes" xml:space="preserve">
          <source>Identify which values are used by only the C and XSUB functions themselves, say, when a parameter to a function should be a contents of a global variable. If Perl does not need to access the contents of the value then it may not be necessary to provide a translation for that value from C to Perl.</source>
          <target state="translated">함수의 매개 변수가 전역 변수의 내용이어야하는 경우와 같이 C 및 XSUB 함수 만 사용하는 값을 식별하십시오. Perl이 값의 내용에 액세스 할 필요가 없으면 C에서 Perl로 해당 값에 대한 변환을 제공하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="56f43be29163ab63b1344b6e022e099866950791" translate="yes" xml:space="preserve">
          <source>Identifying DLLs</source>
          <target state="translated">DLL 식별</target>
        </trans-unit>
        <trans-unit id="82508a1705f3161aa990aa2c93c5670f8e0880f2" translate="yes" xml:space="preserve">
          <source>Identity of objects returned from threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322518cb4fde79b98b609332667667f3d3c4e560" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">명시 적 객체 레지스트리를 사용한 Idhash 기반 내부 구현. 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="bc58745f8a36f6c13d8394fd39a743ccc1e12aee" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation. Like &lt;code&gt;Name_id&lt;/code&gt; it needs a &lt;code&gt;DESTROY&lt;/code&gt; method and would need &lt;code&gt;CLONE&lt;/code&gt; for thread support.</source>
          <target state="translated">Idhash 기반 내부 구현. 마찬가지로 &lt;code&gt;Name_id&lt;/code&gt; 그것은 필요한 &lt;code&gt;DESTROY&lt;/code&gt; 방법 및 필요 &lt;code&gt;CLONE&lt;/code&gt; 스레드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="37c8800e90368fca825ac19f3c1c00b3997debbb" translate="yes" xml:space="preserve">
          <source>If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.</source>
          <target state="translated">$ ENV { 'PERLIO_DEBUG'}이 설정되지 않은 경우 PerlIO_debug ()는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34dc71088c30578327b9b7bd86a2add6dfe92c0b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL이 설정되면 (아래 참조) $ Term :: ANSIColor :: AUTORESET보다 우선하며 후자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7df1e43ea1f957f59393ae695f2cf9b6d2d606b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants will be implicitly preceded by LOCALCOLOR. In other words, the following:</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL을 설정하면 각 색상 상수 시퀀스에 내재적으로 LOCALCOLOR이옵니다. 다시 말해 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9886d30e7ae4310a71b5b389e615e24f477c9c12" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL이 설정되면 $ Term :: ANSIColor :: AUTORESET보다 우선하며 후자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="00b4b93a6e7c56aaf9898bc10e1ac72d3a78d804" translate="yes" xml:space="preserve">
          <source>If $base doesn't have a trailing colon, the last element of $base is assumed to be a filename. This filename is ignored. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">$ base에 후행 콜론이 없으면 $ base의 마지막 요소는 파일 이름 인 것으로 가정합니다. 이 파일 이름은 무시됩니다. 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e44a850613a15c52040db7b75a563e3363f3a945" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ base가 없거나 ''인 경우 $ base는 현재 작업 디렉토리로 설정됩니다. $ base가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1ac0ec7cd3bc97fc5c257fe4a45200d456c5936a" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845e455de01e5f024d6cd4c4973aa19e89db7d23" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">$ base가 없거나 ''이면 &lt;a href=&quot;../../cwd&quot;&gt;cwd ()&lt;/a&gt; 가 사용됩니다. $ base가 상대적이면 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()를&lt;/a&gt; 사용하여 절대 형식으로 변환됩니다 . 즉, &lt;a href=&quot;../../cwd&quot;&gt;cwd ()에&lt;/a&gt; 상대적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c40ff51bf83072e14de8451f609e067639c21f4" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9272bd7bdd63c187d96603ba9d632df6f83a5a3" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ base가 없거나 ''인 경우 현재 작업 디렉토리가 사용됩니다. $ base가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b66c3e7b074813162992aae05acc57abf750bc24" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5fe1a187e17b34fb3d5857b8fec9a663cd647f" translate="yes" xml:space="preserve">
          <source>If $chld_in begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. If $chld_out or $chld_err begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eeec7a0508f8bfb175a7dfc1c9f776420700e6b" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">$ chld_out이 문자열 (즉, glob 또는 참조가 아닌 베어 워드 파일 핸들)이고 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작 하면 자식은 해당 파일 핸들로 직접 출력을 보냅니다. $ chld_in이 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 로 시작하는 문자열이면 $ chld_in은 부모에서 닫히고 자식은 직접 읽습니다. 두 경우 모두 pipe (2) 대신 dup (2)이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="bb5d964b870841cdc4d8247b114d6ed7feacad03" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fc8fa9695e13537785e072991da9317e572016" translate="yes" xml:space="preserve">
          <source>If $device is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">$ device가 제공되면이 장치는 ping 패킷을 보내기 전에 소스 엔드 포인트를 바인딩하는 데 사용됩니다. 나는 이것이 현재 수퍼 유저 권한과 udp 및 icmp 프로토콜에서만 작동한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c0ccd65f83616cd6cb2edfc67d2ca291d582e3dc" translate="yes" xml:space="preserve">
          <source>If $dont_execute is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">$ dont_execute가 true 인 경우 실제로 수행하지 않고 수행 한 작업 만 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="4487f23cdc43d77eefda03ffdb355fcd16d21554" translate="yes" xml:space="preserve">
          <source>If $dry_run is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">$ dry_run이 true 인 경우 실제로 수행하지 않고 수행 한 작업 만 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="18c02a1762fa9a8596890767dac4fd996ccee7b8" translate="yes" xml:space="preserve">
          <source>If $file is not given, output goes to STDOUT.</source>
          <target state="translated">$ file을 지정하지 않으면 출력은 STDOUT으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d0d307167134c6f267f7b1e5ea27d0a25a9d1edd" translate="yes" xml:space="preserve">
          <source>If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.</source>
          <target state="translated">$ lang1이 유효한 언어 태그가 아닌 경우 스칼라 컨텍스트에서 undef로 목록 컨텍스트에서 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6adb44f6d344c97f88c0df71861fe153cb8933a6" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, F(0) to F(12), are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b3052cab9399b49f31b3d6abdfc51fc8199576" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, L(0) to L(-12), are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee23960e33f02c0ec76877b3b88bcea62b52eb5" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt; . Defaults to true.</source>
          <target state="translated">$ options {allow_variables}가 true이면 &lt;code&gt;'$(FOO)'&lt;/code&gt; 는 변수를 건드리지 않습니다. 거짓이면 다른 &lt;code&gt;$&lt;/code&gt; 처럼 이스케이프됩니다 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="5af890a74a4e63465dd086ae3936bc7cc991986f" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt;. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4290bb3a94a4f28c693632b42d671f5b272d5b" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt; .</source>
          <target state="translated">$ opts {allow_variables}가 true이면 &lt;code&gt;$(...)&lt;/code&gt; 형식의 변수를 이스케이프 처리하지 마십시오. 다른 &lt;code&gt;$&lt;/code&gt; will. 기본값은 모든 &lt;code&gt;$&lt;/code&gt; 를 이스케이프하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="45a9cc1fe09732d92a99ea0ef6a79df5a1201010" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855199c44e171a04babf60aa36fe8d5f139967b6" translate="yes" xml:space="preserve">
          <source>If $opts{append} is true the $file will be appended to rather than overwritten. Default is to overwrite.</source>
          <target state="translated">$ opts {append}가 true 인 경우 $ file은 덮어 쓰지 않고 추가됩니다. 기본값은 덮어 쓰기입니다.</target>
        </trans-unit>
        <trans-unit id="6f940e23e748b82cd99453c8e14fb88e03638ce9" translate="yes" xml:space="preserve">
          <source>If $path and $base appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return $path. Note that previous versions of this module ignored the volume of $base, which resulted in garbage results part of the time.</source>
          <target state="translated">$ path와 $ base가 서로 다른 두 볼륨에있는 경우 두 경로를 확인하지 않고 대신 $ path를 반환합니다. 이 모듈의 이전 버전은 $ base의 볼륨을 무시하여 시간의 일부 가비지 결과를 초래했습니다.</target>
        </trans-unit>
        <trans-unit id="cbae8edca75030504736a7e9ba0e1664c9973d5c" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath%28%29&quot;&gt;&quot;canonpath()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850236350e7bb82f14f3904d51572fc6195796da" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath()&quot;&gt;canonpath()&lt;/a&gt;.</source>
          <target state="translated">$ path가 절대이면 &lt;a href=&quot;#canonpath()&quot;&gt;canonpath ()를&lt;/a&gt; 사용하여 정리되고 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dd162a4e3a5b7fb03319f43889033f3ce26c0ac" translate="yes" xml:space="preserve">
          <source>If $path is already absolute, it is returned and $base is ignored.</source>
          <target state="translated">$ path가 이미 절대이면 반환되고 $ base는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="886dc2f5228118ff9d61b100bc53fdb8e15c29aa" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c7fd35866ed59635fd89f40d3d520a0dbf9c9" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">$ path가 상대적이면 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()를&lt;/a&gt; 사용하여 절대 형식으로 변환됩니다 . 즉, &lt;a href=&quot;../../cwd&quot;&gt;cwd ()에&lt;/a&gt; 상대적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ca3a7041ed2c9c63e8a6e3a8ccf54b7c562514d" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ path가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e06af1fee89e76c48b343a46105f41869071f188" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5254527bc2e7fffb01bf04870bf9b3803ac84a3a" translate="yes" xml:space="preserve">
          <source>If $skip is undefined then the skip file will be autodetected and used if it is found. If $skip is a reference to an array then it is assumed the array contains the list of patterns, if $skip is a true non reference it is assumed to be the filename holding the list of patterns, any other value of $skip is taken to mean that no install filtering should occur.</source>
          <target state="translated">$ skip이 정의되어 있지 않으면 건너 뛰기 파일이 자동 감지되어 발견되면 사용됩니다. $ skip이 배열에 대한 참조 인 경우 배열에 패턴 목록이 포함되어 있다고 가정하고 $ skip가 참 비 참조 인 경우 패턴 목록을 보유한 파일 이름으로 간주되며 $ skip의 다른 값을 가져옵니다 설치 필터링이 발생하지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8fa5810ef2976d0d9f6da3cb5784a5117836d30e" translate="yes" xml:space="preserve">
          <source>If $tos is given, this ToS is configured into the socket.</source>
          <target state="translated">$ tos가 주어지면이 ToS가 소켓에 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92f994b9259d086e448ddc0c57c689110cb3a4ae" translate="yes" xml:space="preserve">
          <source>If $uninstall_shadows is true any differing versions throughout @INC will be uninstalled. This is &quot;make install UNINST=1&quot;</source>
          <target state="translated">$ uninstall_shadows가 true이면 @INC 전체의 다른 버전이 제거됩니다. &quot;UNINST = 1 설치&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d25dc89b5c8f1043b2555a0a5b1ef64713bc4410" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false.</source>
          <target state="translated">$ verbose가 true이면 제거 된 각 파일을 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="bcca2238b940008ca2f6edea6b116ca4f08340a0" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false. This is &quot;make install VERBINST=1&quot;. $verbose values going up to 5 show increasingly more diagnostics output.</source>
          <target state="translated">$ verbose가 true이면 제거 된 각 파일을 인쇄합니다. 기본값은 false입니다. 이것은 &quot;make install VERBINST = 1&quot;입니다. 5까지 올라가는 $ verbose 값은 점점 더 많은 진단 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="769e2245fa144a60a2da225854d87529340273af" translate="yes" xml:space="preserve">
          <source>If &amp;lt;tos&amp;gt; is given, this ToS is configured into the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6210a09cf838e292147ff60a09be55f53fc7bf" translate="yes" xml:space="preserve">
          <source>If 'pattern' is an empty string, the last</source>
          <target state="translated">'pattern'이 빈 문자열이면 마지막</target>
        </trans-unit>
        <trans-unit id="0ebb8bcb9771923015eb97e7f45b5b7f4e5fde8a" translate="yes" xml:space="preserve">
          <source>If 0 is given as the version number, then any version is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce161c1d1a95615015e87f6deb5c4e15fba876e" translate="yes" xml:space="preserve">
          <source>If 0, allows</source>
          <target state="translated">0이면 허용</target>
        </trans-unit>
        <trans-unit id="e3e28f04766a1a5f37a30a978712cb8019a0f8ec" translate="yes" xml:space="preserve">
          <source>If 0, perl ignores setlocale() failing. May be useful with some strange</source>
          <target state="translated">0이면 perl은 setlocale () 실패를 무시합니다. 이상하게도 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0fcc1cd2f54ca974c2f03b70436631faa5fcbfff" translate="yes" xml:space="preserve">
          <source>If 0, perl would not warn of in case of unwarranted free(). With older perls this might be useful in conjunction with the module DB_File, which was buggy when dynamically linked and OMF-built.</source>
          <target state="translated">0이면, 펄은 보증되지 않은 free ()의 경우 경고하지 않습니다. 이전 perls에서는 동적으로 링크되고 OMF로 빌드 될 때 버그가있는 DB_File 모듈과 함께 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0184b287a86a499460e472243734776163d62a28" translate="yes" xml:space="preserve">
          <source>If 0, then you have specified the G_DISCARD flag.</source>
          <target state="translated">0이면 G_DISCARD 플래그를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="59622b7a1ad0df9c79750964aae25dbf7a4a54d5" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section</source>
          <target state="translated">1이면 Perl 서브 루틴이 실제로 리턴 한 항목은 Perl 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f287e1183da76005aad8b01623d1574c97f08bac" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section &lt;a href=&quot;#Returning-a-Scalar&quot;&gt;&quot;Returning a Scalar&quot;&lt;/a&gt; shows how to access this value on the stack. Remember that regardless of how many items the Perl subroutine returns, only the last one will be accessible from the stack - think of the case where only one value is returned as being a list with only one element. Any other items that were returned will not exist by the time control returns from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea4460b4f37611ed7726bdc86a6a203f8857086" translate="yes" xml:space="preserve">
          <source>If 1. and 2. didn't work, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for anything looking like UTF-8, and if any found, &lt;code&gt;:utf8&lt;/code&gt; is used as the default encoding for the open pragma.</source>
          <target state="translated">1과 2가 작동하지 않으면 환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 과 &lt;code&gt;LANG&lt;/code&gt; (순서대로)가 UTF-8과 같은 것으로 일치하며, 발견되면 &lt;code&gt;:utf8&lt;/code&gt; 이 열린 pragma의 기본 인코딩으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="564ba04f0c77bd18f1de6b5d8d1c4de41e90203f" translate="yes" xml:space="preserve">
          <source>If 1. didn't work but we are under the locale pragma, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for encodings (the part after &quot;&lt;code&gt;.&lt;/code&gt;&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</source>
          <target state="translated">1. 작동하지 않지만 로케일 pragma 아래에있는 경우 환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LANG&lt;/code&gt; (순서대로)는 인코딩 ( &quot; &lt;code&gt;.&lt;/code&gt; &quot; 뒤에있는 부분 )과 찾은 경우 사용됩니다. 열린 pragma의 기본 인코딩으로.</target>
        </trans-unit>
        <trans-unit id="3a1afd51d6a3da0d6403cee52200d8b304585c08" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, the current chunk will not be discarded. If the current chunk has not been entirely consumed, then it will not be discarded regardless of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc7e264f1e9eeedc8d7e2b14c1a68dd77cae7b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; 이 현재 청크의 맨 끝을 가리키는 경우 (즉, 현재 청크가 완전히 소비 된 경우) 일반적으로 현재 청크는 새 청크를 읽을 때 동시에 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9b9dc2a96c1b74c9cadb45dfb3263c99d73a6b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; can read the file but cannot compile it, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets an error message in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; cannot read the file, it returns undef and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; to the error. Always check &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; first, as compilation could fail in a way that also sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. If the file is successfully compiled, &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; returns the value of the last expression evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf2b0be95e3bf2e4bd6ed03a9822036447b6309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; encounters an operating system error, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set with the corresponding error message. It can be helpful to check &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; and dies if the result is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878d2594c5d9d20b43a7cfef25e3d9ca8c531de7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; operator. However, there are a few situations where programs are likely to want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;srand($seed)&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; after a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10fb228e7791a04f02a88f131ae6798266242b1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;, or filetest are returned. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa00f7897b1c66fe0a596f5bb93527533128be4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (or &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">경우 &lt;a href=&quot;../../term/ansicolor&quot;&gt;기간 : ANSIColor가&lt;/a&gt; (또는 찾을 수 없습니다 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;에서 Win32 : 콘솔&lt;/a&gt; 윈도우에서 실행되는 경우) 테스트는 색상없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="42a72e58cfc32531fbd4fab5178d34e628485bf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">경우 &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: 메타가&lt;/a&gt; 설치되어 MakeMaker가 자동으로 생성됩니다</target>
        </trans-unit>
        <trans-unit id="e5d244370ef566711e04ba5145e26efe3e9b271c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a37900ec3a9e29958a45c25ea701d35b6e343f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO::Socket::IP&lt;/a&gt; 0.25 or later is installed, HTTP::Tiny will use it instead of &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt; for transparent support for both IPv4 and IPv6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd755112fc59cf8f24f51046f0dfaee1c7bd92bf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (and &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a94e167e7f1c0794c5a0b78b8cee155e32baf87" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;umask(2)&lt;/a&gt; is not implemented on your system and you are trying to restrict access for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c3ec58f6b5e85635c3d7dfd311e4342f5aba20" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108eca6848696cd0de287a231d549cff82edd6aa" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will take the current width of your screen from this environment variable, if available. It overrides terminal width information in TERMCAP.</source>
          <target state="translated">경우 &lt;b&gt;-t가&lt;/b&gt; 주어집니다, &lt;b&gt;pod2text이&lt;/b&gt; 가능한 경우,이 환경 변수에서 화면의 현재 너비를 취할 것입니다. TERMCAP의 터미널 너비 정보를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="fc2c6665b79caef5aa91e98d089e901b7263b1c2" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will use the contents of this environment variable if available to determine the correct formatting sequences for your current terminal device.</source>
          <target state="translated">경우 &lt;b&gt;-t가&lt;/b&gt; 주어집니다, &lt;b&gt;pod2text이&lt;/b&gt; 가능한 현재의 터미널 장치에 대한 올바른 형식의 순서를 결정하는 경우이 환경 변수의 내용을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c867f84603d2f4182710d040ee18f9885c092cc" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt; , with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt; , which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt; , or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">경우 &lt;b&gt;로케일 :: Maketext :: 어휘집이&lt;/b&gt; 없는, 단순히 보간함으로써 최소 파악 기능을 구현 &lt;code&gt;[_1]&lt;/code&gt; 첫번째 인수 &lt;code&gt;[_2]&lt;/code&gt; 등 등 번째 보간 함수 &lt;code&gt;[quant,_1]&lt;/code&gt; 로 처리 &lt;code&gt;[_1]&lt;/code&gt; , 유일한 예외 &lt;code&gt;[tense,_1,X]&lt;/code&gt; 추가합니다, &lt;code&gt;ing&lt;/code&gt; 에 &lt;code&gt;_1&lt;/code&gt; X 인 경우 &lt;code&gt;present&lt;/code&gt; 또는 추가 &lt;code&gt;ed&lt;/code&gt; 에 &amp;lt;_1&amp;gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="3da75cd17f8484e1cc0ad4bbfd2ed5b8f369d8c3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt;, with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt;, which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt;, or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3079127a0d6aa2996f8f83dac436403e0868d7e3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</source>
          <target state="translated">이 &lt;b&gt;모든&lt;/b&gt; 경우 에 해당하는 경우 최종 호출 (최종 호출 만)에서 &lt;code&gt;$eof&lt;/code&gt; 매개 변수를 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0055cca9e96f566b053907d319402c20f817d1a7" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21045907ee178d775e967c06cc19006db36b57f1" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1304e40e4e83fe3d3333f01173ec1c6d1e1c6f99" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">경우 &lt;b&gt;pod2man이&lt;/b&gt; 오류와 함께 실패를 참조 &lt;a href=&quot;pod/man&quot;&gt;포드 :: 남자&lt;/a&gt; 와 &lt;a href=&quot;pod/simple&quot;&gt;포드 :: 간단한&lt;/a&gt; 이러한 오류는 의미 할 수 있습니다 무엇에 대한 정보를.</target>
        </trans-unit>
        <trans-unit id="f3c086d017a2724c073cdc0c004a469d39ebb70e" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4176eb0fb0948998c97b4edf835cbf5dcd8f3b5" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">경우 &lt;b&gt;pod2text이&lt;/b&gt; 오류와 함께 실패를 참조 &lt;a href=&quot;pod/text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 와 &lt;a href=&quot;pod/simple&quot;&gt;포드 :: 간단한&lt;/a&gt; 이러한 오류는 의미 할 수 있습니다 무엇에 대한 정보를. 내부적으로 다음 진단을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="988f5c207e367599a6818bf91e93811516af5517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is optional. With the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt; , to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no interpolation is performed on the</source>
          <target state="translated">경우 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 구분 기호는 다음 초기 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 은 선택 사항입니다. 으로 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 당신은 공백이 아닌 (ASCII)를 분리 문자로 문자의 쌍을 사용할 수 있습니다. 이것은 LTS (lean toothpick syndrome)를 피하기 위해 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 가 포함 된 경로 이름을 일치시키는 데 특히 유용합니다 . 만약 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 구분 기호는 다음과 같습니다. &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 설명 된 일치 전용 규칙이 적용 됩니까? &lt;i&gt;패턴&lt;/i&gt; ? 이하. 경우 &lt;code&gt;&quot;'&quot;&lt;/code&gt; (따옴표)가 구분 기호, 더 보간이 수행되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6b9a8e2c3960de18a19c42696e997f8ffea4a1fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;m&lt;/code&gt; is optional. With the &lt;code&gt;m&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt;, to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no variable interpolation is performed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd1c59bcbb68bd82e85d30cea7a785addeb35a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;&quot;B&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;T&quot;&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc627db8f0150de994b80dc55cea56de1a9e2796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4134f85a82aca95ee568f43289ebb0ed4545d2aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;$@&lt;/code&gt; 다음 문자열 비어 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1898954d30bb03694346f5c287c1a5d39827435" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;$@&lt;/code&gt; 다음 문자열 비어 &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd653baf1f66ef92b469ea572e07f68509c56382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ENV{PERL_DESTRUCT_LEVEL}&lt;/code&gt; is set to an integer greater than the value of &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; its value is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8349dcfb4261ce55d683cb8a5fd2171cf0fa3a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$Storable::Deparse&lt;/code&gt; and/or &lt;code&gt;$Storable::Eval&lt;/code&gt; are set to false values, then the value of &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (see below) is respected while serializing and deserializing.</source>
          <target state="translated">경우 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 및 / 또는 &lt;code&gt;$Storable::Eval&lt;/code&gt; 잘못된 값으로 설정되어, 다음의 값 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 직렬화 및 역 직렬화하는 동안 (아래 참조)를 존중한다.</target>
        </trans-unit>
        <trans-unit id="e98020b671aa605e805711cb6bc682413e70f748" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 상기 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 나타난다는 (그것이되지 선언 되었기 때문에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 로컬 목록 요소 별명되는 것에 더하여, 다음 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부 어휘 인 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f7113393512805f0f59fa7b96e8b849e1995d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 하여 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 나타납니다이 (가되지 않는 선언되어 있기 때문에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; , 로컬리스트 요소 별칭 될뿐만 아니라, 다음, 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부의 어휘있는 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb93a45a461425fe55c63aa4556c32605c5c3edf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 상기 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 나타난다는 (그것이되지 선언 되었기 때문에 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 로컬 목록 요소 별명되는 것에 더하여, 다음 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부 어휘 인 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25899b6abc79ff8d8c10640cbdc4955bb3e63743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 하여 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 나타납니다이 (가되지 않는 선언되어 있기 때문에 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; , 로컬리스트 요소 별칭 될뿐만 아니라, 다음, 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부의 어휘있는 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bf18bea13d8e6a37cbbcfdc3ed1634945661fd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are scalars then after these statements</source>
          <target state="translated">경우 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 스칼라는이 문 다음에 다음이다</target>
        </trans-unit>
        <trans-unit id="92cf042152ebf0550f54e6d7d3ad9a3448e3c104" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; pointed to an array of two elements then we would see the following.</source>
          <target state="translated">경우 &lt;code&gt;$a&lt;/code&gt; 두 요소의 배열에 대한 지적은 우리는 다음을 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="fee2f2e0ebac86e4349ab49b826ea37defd988af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt; , which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">&lt;code&gt;$aref&lt;/code&gt; 가 배열에 대한 참조를 보유 하면 $ aref- &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; 은 배열의 네 번째 요소입니다. 이것을 &lt;code&gt;@aref&lt;/code&gt; 라고하는 완전히 다른 배열의 네 번째 요소 인 &lt;code&gt;$aref[3]&lt;/code&gt; 와 혼동하지 마십시오 . &lt;code&gt;$aref&lt;/code&gt; 와 &lt;code&gt;@aref&lt;/code&gt; 는 &lt;code&gt;$item&lt;/code&gt; 과 &lt;code&gt;@item&lt;/code&gt; 과 같은 방식으로 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="56cb4a03de2631e78fd42838b903ba847f7a9d3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt;, which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt;. &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c98499f2d6c2b76ade873a689c1003108b5526" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$bFailIfExists&lt;/code&gt; is true and &lt;code&gt;$sNewFileName&lt;/code&gt; is the path to a file that already exists, then &lt;code&gt;CopyFile&lt;/code&gt; will fail. If &lt;code&gt;$bFailIfExists&lt;/code&gt; is false, then the copy of the &lt;code&gt;$sOldFileNmae&lt;/code&gt; file will overwrite the &lt;code&gt;$sNewFileName&lt;/code&gt; file if it already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de74274409753dd786fd5d63e5d1412ca957382c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not defined, Euler's number (e) is used:</source>
          <target state="translated">&lt;code&gt;$base&lt;/code&gt; 가 정의되지 않은 경우 오일러 번호 (e)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0050f172fa605210fb670bacd9e4150d6ef91f04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$base&lt;/code&gt; ''존재 여부이며, 다음 &lt;a href=&quot;../cwd&quot;&gt;CWD : CWD ()이&lt;/a&gt; 사용된다. 경우 &lt;code&gt;$base&lt;/code&gt; 상대적 후이를 이용하여 절대 형태로 전환된다 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs을 ()&lt;/a&gt; . 이것은 &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()에&lt;/a&gt; 상대적인 것으로 간주됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="efe7c38890e29ff157911650e99baf9d891029df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7addd5930cc7a5f994dbe5d5d02d12cbcde98a29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$buffer&lt;/code&gt; consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &lt;code&gt;gunzip&lt;/code&gt; with the &lt;code&gt;MultiStream&lt;/code&gt; option in the &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; module if you need to deal with concatenated data streams.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 가 여러 개의 연결된 gzip 데이터 스트림으로 구성된 경우 첫 번째 만 압축 해제됩니다. 연결된 데이터 스트림을 처리해야하는 경우 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 모듈 의 &lt;code&gt;MultiStream&lt;/code&gt; 옵션 과 함께 &lt;code&gt;gunzip&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f8dcce322cf03e285482ec192e88b4162c7d25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, the corresponding callback will be disabled. There can only ever be one callback for a given key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7811262733e4fe0a3b5f69a60aebbea5b3943e0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;decode&lt;/code&gt; will only accept valid JSON texts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1982a9afd1e57e2a8bcba28c638e592681686f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion, and tagged JSON values will cause a parse error in &lt;code&gt;decode&lt;/code&gt;, as if tags were not part of the grammar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e48b0ec5233ac4e9e42a4dc42eb1f5c48b74c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb7a77074d5d405efea88b2c7bbc5c701916dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters a blessed object that it cannot convert otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04de0fcb5da7e078ae940e967073b0177355bd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters anything it cannot encode as JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3086280d8ee71ea70bdfcb2afb309beaf2d06527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, no newlines or indenting will be produced, and the resulting JSON text is guaranteed not to contain any &lt;code&gt;newlines&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e975b01cc569dbba02de74e0b10f766fc4f3b4f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then JSON::PP does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be336cd490e25871d5c5a043187b4c6b849802ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will croak if it isn't passed an arrayref or hashref, as JSON texts must either be an object or array. Likewise, &lt;code&gt;decode&lt;/code&gt; will croak if given something that is not a JSON object or array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4552208ed349063bd809d4cf67b8cd611bca27cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not add any extra space at those places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e2d73b94d150c5d23686bd0382b4503285cd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3902c5124259f16919978729c3ce2be1df8d80a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags. This results in a faster and more compact format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86f85aa1caeceb3912119cb7b2d498b0a32493f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will output key-value pairs in the order Perl stores them (which will likely change between runs of the same script, and can change even within the same run from 5.18 onwards).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b52abf83b8965155f261b8d742e8a34398b89a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will return the JSON string as a (non-encoded) Unicode string, while &lt;code&gt;decode&lt;/code&gt; expects thus a Unicode string. Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ad37ba20b3a29620caccad5e3ecd7a88326558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), the string returned by &lt;code&gt;encode&lt;/code&gt; will be shrunk (i.e. downgraded if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb4e08bf1d863891f648ce2830c8c09f60cbc10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain JSON objects whose names don't begin and end with quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246bb991806282f44448e175226c86c650ef5e28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain strings that begin and end with single quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67308b350cc4783d9abd2fdf5b4a1f710199873e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c] characters. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7558d7379ca02e4f9b9f352b5ef01f5fb78976eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept some extensions to normal JSON syntax (see below). &lt;code&gt;encode&lt;/code&gt; will not be affected in anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ace324f1a416d3e8da7b9e8dd1ed7db2c8c1dab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will convert big integers Perl cannot handle as integer into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; objects and convert floating numbers into &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects. &lt;code&gt;encode&lt;/code&gt; will convert &lt;code&gt;Math::BigInt&lt;/code&gt; and &lt;code&gt;Math::BigFloat&lt;/code&gt; objects into JSON numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c0e8fb85aba2afac4d627a09a871fc06d122a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491263f59c01a4eaaa7f2c7452a1609d3f1f36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will explicitly escape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3f1412723a3ab4e362a57dd7e73738bb982d44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;FREEZE&lt;/code&gt; method on the object's class. If found, it will be used to serialise the object into a nonstandard tagged JSON value (that JSON decoders cannot decode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35a5f5496c5b2efdffca81661108891f4928274" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;TO_JSON&lt;/code&gt; method on the object's class. If found, it will be called in scalar context and the resulting scalar will be encoded instead of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aabc89dbe4a6bf91747a70a7f38abf24d998ff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method can convert a non-reference into its corresponding string, number or null JSON value, which is an extension to RFC4627. Likewise, &lt;code&gt;decode&lt;/code&gt; will accept those JSON values instead of croaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd9f62480de589dfa295edb699ae5c2e11f3633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space after the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects and extra whitespace after the &lt;code&gt;,&lt;/code&gt; separating key-value pairs and array members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40417ce6845e6ec8b53c1d5a6af47798ccba201d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space before the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08f5353e1c6dfda4e64411628e93b6243deb94f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the JSON result into UTF-8, as required by many protocols, while the &lt;code&gt;decode&lt;/code&gt; method expects to be handled an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any characters outside the range &lt;code&gt;0..255&lt;/code&gt;, they are thus useful for bytewise/binary I/O. In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32 encoding families, as described in RFC4627.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb7643219ec296a582847f0971f541d53b49849" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the resulting JSON text as latin1 (or iso-8859-1), escaping any characters outside the code range &lt;code&gt;0..255&lt;/code&gt;. The resulting string can be treated as a latin1-encoded JSON text or a native Unicode string. The &lt;code&gt;decode&lt;/code&gt; method will not be affected in any way by this flag, as &lt;code&gt;decode&lt;/code&gt; by default expects Unicode, which is a strict superset of latin1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d729ea73360087d038c168d6df4573c08be0b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not barf when it encounters a blessed reference that it cannot convert otherwise. Instead, a JSON &lt;code&gt;null&lt;/code&gt; value is encoded instead of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8120948e30627d79c4071787a445caabdb06a056" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not generate characters outside the code range &lt;code&gt;0..127&lt;/code&gt; (which is ASCII). Any Unicode characters outside that range will be escaped using either a single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence, as per RFC4627. The resulting encoded JSON text can be treated as a native Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string, or any other superset of ASCII.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f442720c1ebc67a4d7d3134850e92ef85f78491" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will output JSON objects by sorting their keys. This is adding a comparatively high overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fd8141083b0c1d8b81b6f4d6866a0fb5c4899a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will use a multiline format as output, putting every array member or object/hash key-value pair into its own line, indenting them properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c05ab0710c330ccfa58b05a1d99cb1930161cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$fh&lt;/code&gt; is a filehandle, such as is returned by &lt;code&gt;IO::File&lt;/code&gt; or one of the other &lt;code&gt;IO&lt;/code&gt; modules, you may use:</source>
          <target state="translated">경우 &lt;code&gt;$fh&lt;/code&gt; 같은 의해 반환되는 파일 핸들입니다 &lt;code&gt;IO::File&lt;/code&gt; 또는 다른 하나의 &lt;code&gt;IO&lt;/code&gt; 모듈, 당신은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e3cb3fa6da7016a06a0ddc81b83c00820e64661b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$global&lt;/code&gt; is true then the driver should send the event to all hubs in all processes and threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412f2956d9be3c45dbde64ef1450e59ad2d04b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;&quot;register&quot;&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cddfe7cac5da52e604c2e95ecabe44db020236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$id&lt;/code&gt; (참조 등록 된 오브젝트의 ID 인 &lt;a href=&quot;#register&quot;&gt;등록&lt;/a&gt; ), 오브젝트 달리 정의되지 않은 값을 반환한다. 등록 된 객체의 경우 이것은 &lt;code&gt;id()&lt;/code&gt; 의 역함수 입니다.</target>
        </trans-unit>
        <trans-unit id="cc434bb4b25d64e8d72b26a1167930b8ab9c02ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$input&lt;/code&gt; 스칼라 기준이고, 상기 압축 된 데이터로부터 판독한다 &lt;code&gt;$$input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260df432afe5ea3f6b10347c137307e5145777ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1deee19e273a335c0c4f6a1643abcff33ad56b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 스칼라 기준이며, 입력 데이터로부터 판독한다 &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61f15d9caa9af92bd7bab0101da2a2fc66fae53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442fe7b0ca25d4c885c4e854d9668346a5bb7269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="9aa314fdcd8580313e8abf8e02f29427ab27b460" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyuncompress&lt;/code&gt; 은 문자열 이</target>
        </trans-unit>
        <trans-unit id="18a54dcb23d30a160237fad9927225b0b52fd938" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bunzip2&lt;/code&gt; 는 다음과 같이 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2674b9a8665c681ee519359fca9a33d0c649f2e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="8d40f68b3835780881ecdd758b0745e5d0346006" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;deflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4fe4284a3754ea968d5efe965b410a0bdc45da42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gunzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="54bfc13f24ab6d2f1fe87f0e4095f9cb61a84059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 문자로 구분되는 문자열 인 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="9bc5cf10f5ea974c9dba92b8ddcdee6c56efe154" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 문자로 구분되는 문자열 인 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="8e074643e90fcbea02cb6c241eab28946a00d829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawdeflate&lt;/code&gt; 는 문자열 이</target>
        </trans-unit>
        <trans-unit id="c17eec5153adb41349f1323f8a2716fe9be3d4a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4ab52d4fbbd216b398b3cd45ad27a194f5b5a84f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;unzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="35a8f72eaee6c21d9a2ad219023a7a4de0558584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;zip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2e1657129b850f80b9a61087ceca9451d92c60dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is an array reference, each element in the array must be a filename.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 경우 배열 참조는, 어레이의 각 요소는 이름이어야한다.</target>
        </trans-unit>
        <trans-unit id="f6f55f2709b4c8b210fa8171af0e426a8189b01a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$locale_name&lt;/code&gt; is not available, fallback is selected in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbc80ca8dd7a56323169258329eaced7ec9500d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$n&lt;/code&gt; is negative, returns the digit counting from left.</source>
          <target state="translated">경우 &lt;code&gt;$n&lt;/code&gt; , 음수 왼쪽에서 숫자 계산을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="320bf336e74d67e7ea69246db25f2a4bdd482c4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$num_tests&lt;/code&gt; is omitted, the number of tests run will be used, like no_plan.</source>
          <target state="translated">경우 &lt;code&gt;$num_tests&lt;/code&gt; 생략, 테스트의 수는 no_plan처럼 사용됩니다 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9d696967ac485ed4d512d17c0805aaab2b3cb743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$numeric&lt;/code&gt; is true, these will be given in numeric form rather than being resolved into names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec7e6706afeeac3972bbf967d824b032cbdeb1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$olBytesRead&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, it will be set to the actual number of bytes read, though &lt;code&gt;length($opBuffer)&lt;/code&gt; can also be used to determine this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1acd93b6a6ef1f8b92bfb6d087b55815058f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt; . Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 버퍼이며 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 모든 압축 된 데이터의 끝에 추가 될 것이다 &lt;code&gt;$output&lt;/code&gt; . 그렇지 않으면 데이터가 기록되기 전에 &lt;code&gt;$output&lt;/code&gt; 이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="92afc15c575b4de234228583007cad12aa627fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt;. Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8582554c9105fe0c715aaa06eeaea2d3fcfc688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a file or a filehandle, it must be seekable.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일이나 파일 핸들을, 그것은 시크해야합니다.</target>
        </trans-unit>
        <trans-unit id="430d11ebbae99eabba1b751c1fb7c8e38808dc22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일 핸들입니다 파일 포인터에 대한 호출을 통해 파일의 끝에 배치됩니다 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 모든 압축 된 데이터가 기록되기 전에. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f05d0ea62b4bacb21e297df6978bb119d6575e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f34a91ef18a1100dcab801875430fa2964155e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filename and &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일 이름이며 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일은 확장 모드에서 열립니다. 그렇지 않으면 압축 된 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="905a4b022cfd04d4344f06eb8d1d7814fe3b2e8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 스칼라 기준이고, 상기 압축 된 데이터를 저장한다 &lt;code&gt;$$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a7576a43214d6e50502e7d58fdfce2630e01b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130d5c72326e4e51651ab55caf6ff565c16bd2ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 스칼라를 참조하고, 압축 데이터를 저장한다 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a39be39ddf44d7bf461e73a4324b038a6242f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e6e43463d8cf9f8c4cc955f62290b2d79a9ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 스칼라 참조이며, 압축되지 않은 데이터에 저장됩니다 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a168ccb52122de1bd3352cd9d3af1687ee7454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffed2a8f82140ef8dc0c4ed699c9112d9f907c47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b9f151907f2e5c73c6d5a7f5e3827d63f2d086e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyuncompress&lt;/code&gt; 은 문자열 이</target>
        </trans-unit>
        <trans-unit id="eb784e91a1d15b001b3d17241bbd0f023fa0db31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bunzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="308eaa4a6536e52e6cbbe3d9c09c32dfa80725fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="632c19749781b38310b67e8cb7d2da8bcbd87fa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;deflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4846f7304e22cdc9a232215f9939eddfa8d9211d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gunzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="4f11ec72b95266da1fd717b81d461cc92a72f199" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="f099e710944546f4f6281f3a2de13a8288ffdd0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 문자 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot;로 구분되는 문자열입니다 &lt;code&gt;inflate&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="cceae651ad537fbe024d4ffd9a457c78fec4fbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawdeflate&lt;/code&gt; 는 문자열 이</target>
        </trans-unit>
        <trans-unit id="767601b4f86c38e1ce00ed67d4e6753dd438a660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="c227dd1ee1e8b9659ffdea7cebe0fc1ef9dd1a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;unzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2ae55891ab5b00668d1e680f825b4abc927f84c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; 문자로 구분 된 문자열 인 경우 은</target>
        </trans-unit>
        <trans-unit id="a78a9fcfd00ce247c78fb42d76b95940b9310c9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the compressed data will be pushed onto the array.</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 배열 기준이고, 상기 압축 된 데이터는 어레이 상에 푸시한다.</target>
        </trans-unit>
        <trans-unit id="37e6606fa0b627f8a29d46dde4b8ebad46bd51a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the uncompressed data will be pushed onto the array.</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 배열 참조되면, 압축 데이터는 어레이 상에 푸시한다.</target>
        </trans-unit>
        <trans-unit id="46c17470e6cc4d6d06d981448409ffd8362d74b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;&quot;canonpath&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369470062bc6b67bd375785b11035d408478ab66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$path&lt;/code&gt; 절대, 그것은 청소 및 사용하여 반환 &lt;a href=&quot;#canonpath&quot;&gt;canonpath을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2c38c6381b06048880f2f47e06a03a66a2f0d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8992ca77fb991d344a3dd6a4f26aedbf1b0f1d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$path&lt;/code&gt; 상대적이며,이를 이용하여 절대 형태로 전환된다 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs을 ()&lt;/a&gt; . 이것은 &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()에&lt;/a&gt; 상대적인 것으로 간주됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a33d4ccec3781b021129aedf529c68c428662f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$phase&lt;/code&gt; or &lt;code&gt;$type&lt;/code&gt; are undefined or otherwise invalid, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529756014729906a36945c0c1d2b4d6306a5c66b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt; . The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; , and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">경우 &lt;code&gt;$potential_libs&lt;/code&gt; 비어, 반환 값은 비어 있습니다. 그렇지 않으면 &lt;code&gt;$Config{perllibs}&lt;/code&gt; (Config.pm 참조)로 지정된 라이브러리 가 &lt;code&gt;$potential_libs&lt;/code&gt; 목록에 추가됩니다 . 라이브러리는 &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; 및 &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; 지정된 디렉토리에서 검색됩니다. . 발견 된 각 라이브러리에 대해 공백으로 구분 된 완전한 라이브러리 경로 이름 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a33dfa3cb51d3b667a9940aa0224c9aa9e3bd626" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt;. The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt;, &lt;code&gt;$Config{libpth}&lt;/code&gt;, and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt;. For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e553e7605e3100f0e3fcb5a8fa623376f34f081" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">경우 &lt;code&gt;$priority&lt;/code&gt; 허가, 기록 &lt;code&gt;$message&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; 하는 첨가 &lt;code&gt;%m&lt;/code&gt; $ 메시지 또는 &lt;code&gt;$format&lt;/code&gt; 으로 대체 &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (최신 오류 메시지).</target>
        </trans-unit>
        <trans-unit id="853d4061f455f6e6d37a506979fa44f0b913548a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;sprintf($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f52d52d1ba29c4eacb016d029d5d02c84a30a69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; 축복 참조는 리턴으로 축복하고있는 패키지의 이름입니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e917878adcf725e243606546ded3ddf73b8c65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference, the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e261aa8c38ef64f4ef56cc680e427a28531090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt; ). Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; (예 참조 변수의 기본 펄 타입은 일반 문자열로 반환되는 참조입니다 &lt;code&gt;ARRAY&lt;/code&gt; 또는 &lt;code&gt;HASH&lt;/code&gt; ). 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc02c6f36c505398dff2d8f520950bd61427281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference, the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt;). Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac5930e7537a0d644cf3490408ca500262cfef0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; 참조입니다 참조 값의 내부 메모리 주소는 일반 정수로 반환됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7f8848e692246887d1670a841851026e0d0d247e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference, the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2f6d4bd4dbef02b5adcb98b33be7311853de12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$result&lt;/code&gt; is undefined the corresponding parser has reached the end of its input (and will automatically be removed from the multiplexer).</source>
          <target state="translated">경우 &lt;code&gt;$result&lt;/code&gt; 정의되지 대응 파서는 입력이 종료 할 때 (자동 멀티플렉서에서 제거한다).</target>
        </trans-unit>
        <trans-unit id="78156973481681bf236b7a46f7e67281a60be7e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$string&lt;/code&gt; is given, then this string is appended to the already existing JSON fragment stored in the &lt;code&gt;$json&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a340f9f260eea8720ddb9232a9ecfe918063812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 어떤 부분과 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; , 반환 &lt;code&gt;-1&lt;/code&gt; 스칼라 문맥과 목록 문맥에서 빈 목록을.</target>
        </trans-unit>
        <trans-unit id="34f2ce5e748390e7ea9b7256361ae68fda804dd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 스칼라 문맥과 목록 문맥에서 빈 목록.</target>
        </trans-unit>
        <trans-unit id="78ec8c638c3f85aaeb890b68130939aac53cb1a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns an empty list.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc1b67e1c3f6e66a8b72265ebfbfbd5b7ef792af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c201b05fbdc585a181de55865d16278affee3294" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;undef&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2e1e8a9a6ad69b33dbc5f664836bb1347dcf06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc9206b35b196b0963c771281e4b1c34fd9c295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 일치하는 부분의 모든 발생에 의해 대체되는 &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; 수정) 및 &lt;code&gt;$count&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b46dcd3b846eff16d0953c63180197a9948d71b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 스칼라 문맥에서, 반환 &lt;b&gt;에 대한 참조&lt;/b&gt; 일치하는 부분의 첫 번째 항목을 ( &lt;code&gt;$match_ref&lt;/code&gt; 모든 기준이기 때문에, 항상 일치하는 경우는 true입니다 &lt;b&gt;진정한&lt;/b&gt; ); 목록 컨텍스트에서 일치하는 부분의 첫 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c160da8add608824da0efecdea8fe8dbd7d4c55a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 일치하는 모든 부품 (스칼라 문맥 또는 일치하는 수를) 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c10bc187ce931b2a7b22530d13ae4fe64805817c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 일부 일치 &lt;code&gt;$string&lt;/code&gt; 스칼라 컨텍스트 매칭 부 처음 나타나는 위치를 반환한다; 목록 컨텍스트에서 일치하는 부분의 위치와 길이의 두 요소로 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d649e7e5214d8eb5d7dfa63d2b26508aa3ec136c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt; ) is returned.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 일부 일치 &lt;code&gt;$string&lt;/code&gt; , 일치 부분의 처음 발생에 의해 대체된다 &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; 수정) 및 &lt;code&gt;$count&lt;/code&gt; (항상 같음 &lt;code&gt;1&lt;/code&gt; )이 반환된다.</target>
        </trans-unit>
        <trans-unit id="c3fbde2ba093a3465cab9494d515f9997f56434f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4911ca5dae8ff08a4b4cb6051ee9c7432277080b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50330de1105cec13a916504977d0fffac051d470" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns all the matching parts (or matching count in scalar context).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37346d5bdc4adf2f6aafd9b3124f4a5fcee52ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7936ff462585086c63c3b202fca7c61f67f270da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt;) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923955b556ee1c107b87425fc0d239520dd618a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$thing&lt;/code&gt; 개체를 참조,이 기능은 객체로 축복 된 패키지의 이름을 반환합니다. 경우 &lt;code&gt;$thing&lt;/code&gt; 축복받은 객체의 참조가 포함되어 있지 않습니다 &lt;code&gt;blessed&lt;/code&gt; 함수가 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6339b1ca7faa12a87dd16d8376168402efc0b0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b5b827c9fa69b1b1193c08475c48b1b10adad6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , you've got a successful test.</source>
          <target state="translated">경우 &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; 과 &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , 당신은 성공적인 테스트를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="762c2fef6e9c59f981f639aa3049b28356711a9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt;, you've got a successful test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c7b300af278a42c6325ca397a30c8b1a02bd5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$uOldFlags&lt;/code&gt; were the value of the handle's flags before the call to &lt;code&gt;SetHandleInformation&lt;/code&gt;, then the value of the handle's flags afterward would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9127d14922a52db0d5d2508646de8dbb02dabc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar that has both numeric and string values, the result is true.</source>
          <target state="translated">경우 &lt;code&gt;$var&lt;/code&gt; 모두 숫자 및 문자열 값이 스칼라이며, 결과는 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="811b177adb678df1c7fcd2ebe9a8006c41328bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring the result is true.</source>
          <target state="translated">경우 &lt;code&gt;$var&lt;/code&gt; vstring으로 코딩 된 스칼라이고 결과는 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="a9caaf937ca561a040c20b5fbde0fec6da524973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring, the result is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea1e5cda1b021861102b8f6816c7f61a9adac01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . '&lt;code&gt;NaN&lt;/code&gt; ' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">경우 &lt;code&gt;$x&lt;/code&gt; 와 &lt;code&gt;$y&lt;/code&gt; 비제로, 그들은 즉 상대적으로 소수,해야 &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . 모듈 형 곱셈 역수가 존재하지 않으면 ' &lt;code&gt;NaN&lt;/code&gt; '이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5fcc92529718794debebbbd28d3a6b743f73817" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt;. '&lt;code&gt;NaN&lt;/code&gt;' is returned when no modular multiplicative inverse exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1241f2fba2bddba0f0228a9100bb47c11034264" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$z&lt;/code&gt; 버퍼와 연결되어,이 방법은 효과가 없습니다 항상 반환 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9624e7af7def5be294a442f4173d4d3d6d7e212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2e0c2819ecb9af14cc06d8987b7eee133a60fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; is being operated on, if any.</source>
          <target state="translated">만약 &lt;code&gt;%+&lt;/code&gt; 또는 &lt;code&gt;%-&lt;/code&gt; 있는 경우에 운영되고있다.</target>
        </trans-unit>
        <trans-unit id="33759bad70947890a80808b87beeb0ad07a9f99a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is overloaded then the same implementation is used for both the</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 다음 과부하 동일한 구현 모두에 사용</target>
        </trans-unit>
        <trans-unit id="2655a0d13879bb1273409b47214e136f442c0716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 문자 클래스의 첫 번째 또는 마지막 문자가, 그것은 일반 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3fbcc9b880c1850b742f9cae8dd87f58567ba57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 문자 클래스의 첫 번째 또는 마지막 문자가, 그것은 일반 문자로 처리됩니다; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; 및 &lt;code&gt;[a\-b]&lt;/code&gt; 는 모두 같습니다.</target>
        </trans-unit>
        <trans-unit id="7642b1add676b77e55b012fe61fa0084ce5fe11b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt;, &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4ef209f3736a149a4cf48e4ad6ea5f08cb5ced" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl's fallback for the &lt;code&gt;++&lt;/code&gt; operator is to increment the reference itself.)</source>
          <target state="translated">경우 &lt;code&gt;'fallback'&lt;/code&gt; , 객체 참조의 할당이다 - 참이고 어떤 복사 생성자는 스칼라 기반으로하지 않는 개체에 대해 다음 정의되지 펄은 자동으로 간단한 과제에 다시 떨어질 수 있습니다. 실제로, 객체 데이터의 새 복사본이 만들어지지 않기 때문에 복사 생성자 메커니즘이 비활성화됩니다. 이것은 거의 확실히 당신이 원하는 것이 아닙니다. (그러나 일관성이 있습니다. 예를 들어, &lt;code&gt;++&lt;/code&gt; 연산자에 대한 Perl의 폴백 은 참조 자체를 증가시키는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="f876580a65734a569954c7e1c0d71566801b2a2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object's data is stored as, for example, an array of scalars, the following might be appropriate:</source>
          <target state="translated">경우 &lt;code&gt;'fallback'&lt;/code&gt; 정의되지 않았거나 TRUE되어 다음 복사 생성자는하지만 스칼라에 기반하여 객체에 대한, 자동 생성 할 수 있습니다. 다른 경우에는 명시 적으로 정의해야합니다. 객체의 데이터가 예를 들어 스칼라 배열로 저장되는 경우 다음이 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaf2bfa6a27ac22ef6886057189af7b7a1f09aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;//p&lt;/code&gt; ) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</source>
          <target state="translated">만약 &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; 입니다 &lt;code&gt;-1&lt;/code&gt; 캡처 그룹이 일치하지 않습니다 그. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; 나타내는 &lt;code&gt;$&amp;amp;&lt;/code&gt; (또는 &lt;code&gt;${^MATCH}&lt;/code&gt; 아래 &lt;code&gt;//p&lt;/code&gt; )과 &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; 일치 &lt;code&gt;$$paren&lt;/code&gt; 여기서 &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="57dd1014f096fb43a6b9346ad9421342ded823ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;/p&lt;/code&gt;) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt;= 1&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6203f8ab9db59ac080a4fb390ff800c0d1e53c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; . If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 가 인식되는 전환 문자가 아닌 경우 getopts ()는 인수 &lt;code&gt;--help&lt;/code&gt; 및 &lt;code&gt;--version&lt;/code&gt; 을 지원합니다 . 경우 &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; 및 / 또는 &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; 정의되어, 그들 불리는; 인수는 출력 파일 핸들, 옵션 처리 패키지 이름, 버전 및 스위치 문자열입니다. 서브 루틴이 정의되지 않은 경우 지능형 메시지를 생성하려고 시도합니다. 최상의 결과를 얻으려면 $ main :: VERSION을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="14cd49c88b8972d01c98fe1ff97e8e713aaa02a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;. If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7069d110eb31ac59c5fa5654832fee9ae99f4bc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Strict&lt;/code&gt; is disabled, then &lt;code&gt;$string&lt;/code&gt; can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">&lt;code&gt;-Strict&lt;/code&gt; 를 사용하지 않으면 &lt;code&gt;$string&lt;/code&gt; 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다. 널 문자가 존재하면 필드는 첫 번째 NULL에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="72b90d51b78e3f86c015e424f0a9c82ae7cdd392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:full&lt;/code&gt; is present, for expansion of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;, the string</source>
          <target state="translated">경우 &lt;code&gt;:full&lt;/code&gt; 의 확장을 위해 존재하는 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 문자열</target>
        </trans-unit>
        <trans-unit id="34845b5a7409ae2ff88602a784737cd832c5bd71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:short&lt;/code&gt; is present, and</source>
          <target state="translated">경우 &lt;code&gt;:short&lt;/code&gt; , 존재하고</target>
        </trans-unit>
        <trans-unit id="51514fa7ee13d4abe63d9987d2badb1e9b04ad61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 스택의 상단 떨어져 바람이이 가장 높은 상황을보고한다.</target>
        </trans-unit>
        <trans-unit id="b1ac9c6b50bb86cfe48d37ba1ee2e0f181649af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) is ordered after &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt; . In this point, &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (안 문자열 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; )이 키 값으로 명시 적으로 전달되고, 어떤 정상화는 (모든 정상화가 요구되지 않은 경우이 쉽게 재봉 할 수 있습니다) 수행되지 않습니다. 에서 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 만 연속 수축 해결; 경우에도 예를 들면 &lt;code&gt;A-ring&lt;/code&gt; (및 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) 후 주문한 &lt;code&gt;Z&lt;/code&gt; 는 , &lt;code&gt;A-cedilla-ring&lt;/code&gt; 동일한 기본 것이다 . 이 시점에서 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;a href=&quot;../functions/undef&quot;&gt; undef&lt;/a&gt; , preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {NFD ( &lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt; )}) &lt;b&gt;는 이 아닙니다&lt;/b&gt; 동등 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3ebd4a416f2ed67a7f6e0321914f19253d4061" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt; ).</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달파일을 읽지 않습니다 (그러나 &lt;code&gt;entry&lt;/code&gt; 를 통해 데이터 정렬 요소를 정의 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="311ed3b2b34ac0afe5f28bb9003642de34a3cf73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 한글 음절의 가중치는 한글 자모로 분해되지 않고 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 에서 한글 음절의 무게 정의 는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a0847d602472c48d4557dcd264e5fd82c70ededc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; (see &lt;b&gt;-D&lt;/b&gt; flags in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;). &lt;code&gt;:opd&lt;/code&gt; is a shortcut for &lt;code&gt;:opd=st&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; 지시어는있다 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 인수를,이 연산 코드 파견의 디버깅에 전환합니다. &lt;code&gt;FLAGS&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 의 조합이어야합니다 ( &lt;a href=&quot;../perlrun&quot;&gt;perlrun의 &lt;/a&gt;&lt;b&gt;-D&lt;/b&gt; 플래그 참조). ). &lt;code&gt;:opd&lt;/code&gt; 는 &lt;code&gt;:opd=st&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="dae0c23c00276e5219bdb2cdf7fffc6926c2f0f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 있지만 그것을 컴파일 할 수 없습니다, 그것은 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 과에서 오류 메시지를 설정 &lt;code&gt;$@&lt;/code&gt; . 경우 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 없습니다, 그것은 미확정 및 세트 반환 &lt;code&gt;$!&lt;/code&gt; 오류에. 컴파일은 &lt;code&gt;$!&lt;/code&gt; 를 설정하는 방식으로 실패 할 수 있으므로 항상 &lt;code&gt;$@&lt;/code&gt; 먼저 확인하십시오 . . 파일이 성공적으로 컴파일되면 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 는 마지막으로 평가 된 식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e753c27e9c7187898b162963067981265acf4ee7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">하면 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 있지만 그것을 컴파일 할 수 없습니다, 그것은 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 과에서 오류 메시지를 설정 &lt;code&gt;$@&lt;/code&gt; . 경우 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 없습니다, 그것은 미확정 및 세트 반환 &lt;code&gt;$!&lt;/code&gt; 오류에. 컴파일은 &lt;code&gt;$!&lt;/code&gt; 를 설정하는 방식으로 실패 할 수 있으므로 항상 &lt;code&gt;$@&lt;/code&gt; 먼저 확인하십시오 . . 파일이 성공적으로 컴파일되면 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 는 마지막으로 평가 된 식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a29f1441f3fe81108d43067a84beeb2b3df06a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 정말 필요 후 다음 사용을 고려 :</target>
        </trans-unit>
        <trans-unit id="fbdbd42df3d8a3289f178b0b712d70c88452aff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 만남 운영 시스템 오류, &lt;code&gt;$!&lt;/code&gt; 해당 오류 메시지와 함께 설정됩니다. &lt;code&gt;$!&lt;/code&gt; 를 확인하면 도움이 될 수 있습니다 ! 파일 핸들에서 읽을 때 tty 또는 소켓과 같은 신뢰할 수 없습니다. 다음 예제는 연산자 형태의 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 을 사용 하고 결과가 정의되지 않은 경우 죽습니다.</target>
        </trans-unit>
        <trans-unit id="d241999daf1d6b5b1d790a94e12c3db4b7639b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 활성화되어 잘 형성 UTF8 문자와 UTF8 경고 가리 키지 않는 제로가 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 은 (경우 설정 &lt;code&gt;retlen&lt;/code&gt; 는 -1 NULL이 아닌). 이러한 경고가 해제 된 경우 올바르게 정의 된 경우 계산 된 값 (또는 유니 코드 REPLACEMENT CHARACTER가 아닌 경우)이 자동으로 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 다음 가능한 위치 비 변형 문자를 시작할 수 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0d74bacc686d5d25a69c27fe56691316eb86755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 활성화되어 잘 형성 UTF8 문자와 UTF8 경고 가리 키지 않는 제로가 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 은 (경우 설정 &lt;code&gt;retlen&lt;/code&gt; 는 -1 NULL이 아닌). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 대체 문자가 아닌 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이됩니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 다음 가능한 위치 변형되지 않은 문자를 시작할 수 REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd7ce6c8380ad430d911ba4aeab09bd5672c569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 -1 NULL을 가리키고 있지 않음). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 대체 문자가 아닌 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 비 변형 문자를 시작할 수 있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 다음 위치 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f087a32f599c70b71522f617c69df5af3084d9d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 -1 NULL이 아니다). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 REPLACEMENT CHARACTER, 그렇지 않은 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 비 변형 문자를 시작할 수 있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 다음 위치 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f4f6bcfdeca5ca3ce7d26db71a53789a3b67e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; is invoked as &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 로 호출 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 정말 의미 (또는 인수로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , 참조 &lt;a href=&quot;functions/split&quot;&gt;분할&lt;/a&gt; ), 펄이 플래그를 설정합니다. 그런 다음 정규식 엔진이이를 확인하고 SKIPWHITE 및 WHITE extflags를 설정할 수 있습니다. 이를 위해 Perl 엔진은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5670ad2e09b0f96c2653919425d0503ae94298b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출되지 않습니다, 그것은의 첫 번째 사용에서 매개 변수없이 암시 적으로 호출 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 운영자입니다. 그러나 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 호출하려고하는 상황이 몇 가지 있습니다 . 하나는 일반적으로 테스트 또는 디버깅을 위해 예측 가능한 결과를 생성하기위한 것입니다. 거기, 당신은 사용 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; 매번같은 &lt;code&gt;$seed&lt;/code&gt; 와 함께 srand ($ seed) 를 사용합니다. 또 다른 경우는 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 다음에 srand () 를 호출하여 부모와 동일한 시드 값을 공유하는 하위 프로세스 (및 결과적으로 서로 ) 를 피할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cccd9e31f8fdf12513d7e9607d1902ac2bd43369" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 밑줄로 구성된 특수한 파일 핸들을 전달, 어떤 스탯이 이루어지지되지만, 마지막에서 합계 구조의 현재 내용 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 는이 , 또는 파일 테스트가 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3a943f3015131830c0ed79135dd6ffd5caeedbfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt; , then it uses &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 에 대한 인수로 지정 &lt;code&gt;autodie&lt;/code&gt; , 그것은 사용하는 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: 시스템 :: 간단한&lt;/a&gt; 무거운 리프팅을 할 수 있습니다. 자세한 정보는 해당 모듈의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a8b7802544453fc6ad5238177a90c2f0eccb634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (를 포함하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자에 의해 영향을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 의 로케일. 참조 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및&lt;a href=&quot;posix&quot;&gt; POSIX를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="037fc9127a03dbcb60108531d797528430fc80ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 인 경우 만남 운영 시스템 오류, &lt;code&gt;$!&lt;/code&gt; 해당 오류 메시지와 함께 설정됩니다. &lt;code&gt;$!&lt;/code&gt; 를 확인하면 도움이 될 수 있습니다 ! 파일 핸들에서 읽을 때 tty 또는 소켓과 같은 신뢰할 수 없습니다. 다음 예제는 연산자 형태의 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 을 사용 하고 결과가 정의되지 않은 경우 죽습니다.</target>
        </trans-unit>
        <trans-unit id="2d7702ac9f2d2a81c61f2c22a4643a2b4934ac53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출되지 않습니다, 그것은의 첫 번째 사용에서 매개 변수없이 암시 적으로 호출 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 운영자입니다. 그러나 프로그램이 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 호출하려고하는 상황이 몇 가지 있습니다 . 하나는 일반적으로 테스트 또는 디버깅을 위해 예측 가능한 결과를 생성하기위한 것입니다. 거기, 당신은 사용 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; 를 사용합니다. &lt;code&gt;$seed&lt;/code&gt; 매번 $ seed . 또 다른 경우는 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 호출 후 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 하여 부모와 동일한 시드 값을 공유하는 하위 프로세스 (및 결과적으로 서로 ) 를 피할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e39dea0f8d4bc40933767354a2f3ede98ed2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 밑줄로 구성된 특수한 파일 핸들을 전달, 어떤 스탯이 이루어지지되지만, 마지막에서 합계 구조의 현재 내용 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 는이 , 또는 파일 테스트가 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="4d0fc4f120e9a470fc6f07be480b6e3ed0441ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;사용하는&lt;/a&gt; 경우 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="acafe9c3ebbd6459bfa75fbfb2c2b7c67ce9bcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (를 포함하여 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자에 의해 영향을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 의 로케일. &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 및&lt;a href=&quot;../posix&quot;&gt; POSIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fa0102bfd20d7fca81e7a9229fd0c15e53ef801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@descriptions&lt;/code&gt; is given, these correspond to the keys used in each call to the add() method. Returns an array of the requested parsers (in the requested order) in list context or an array reference in scalar context.</source>
          <target state="translated">만약 &lt;code&gt;@descriptions&lt;/code&gt; 이 주어집니다, 키 이러한 대응은 추가 () 메소드에 대한 각 호출에 사용. 요청 된 파서의 배열을 요청 된 순서대로 목록 컨텍스트에서 또는 스칼라 컨텍스트에서 배열 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19fd000c86a54d51f5f77fda0d06393c9c4850ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; is a better match for &lt;code&gt;T&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A'&lt;/code&gt; 일치 하는 경우 : &lt;code&gt;AB&lt;/code&gt; 가 &lt;code&gt;AB'&lt;/code&gt; 보다 일치하는 경우 &lt;code&gt;B&lt;/code&gt; 는 을위한 더 나은 일치 &lt;code&gt;T&lt;/code&gt; 보다 &lt;code&gt;B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cdd4b8faba979c10f3007699d2ae7796c4a29c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a better match for &lt;code&gt;S&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 을위한 더 나은 일치 &lt;code&gt;S&lt;/code&gt; 이상은 &lt;code&gt;A'&lt;/code&gt; , &lt;code&gt;AB&lt;/code&gt; 는 보다 더 나은 일치 &lt;code&gt;A'B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4156d315c54ceb2fee7698af8b63e714f0a2462c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any compressed data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 모든 압축 된 데이터는 출력 버퍼의 끝에 추가 될 것이다. 그렇지 않으면 압축 된 데이터를 쓰기 전에 출력 버퍼가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="949b457391fc5cf37099eaecff56b10b510ca113" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all uncompressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any uncompressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 가 활성화 된 압축되지 않은 모든 데이터가 출력 버퍼의 끝에 추가됩니다. 그렇지 않으면 압축되지 않은 데이터가 쓰여지기 전에 출력 버퍼가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="badd301fd65baa8719ba53ea1a80949656267442" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일이 추가 모드에서 열립니다. 그렇지 않으면 압축 된 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="1454be0505ecbcd6144a8007fb6e1b0593fddf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일이 추가 모드에서 열립니다. 그렇지 않으면 압축되지 않은 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="65081513c33900b0638266063d522dfa1dd85637" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; 가 활성화 된 경우 파일 핸들은 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 요청을 통해 파일 끝에 배치됩니다. 압축 된 데이터가 기록되기 전에 합니다. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26fb68f8b046494190d2e776943c032f469c5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; 가 활성화 된 경우 파일 핸들은 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 요청을 통해 파일 끝에 배치됩니다. 모든 비 압축 데이터가 기록되기 전에. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61760816f1c2f85d9599ced573f084a05cf816ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4c77f4cfed963d8872c1a7f3de19f7c8bb526f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cc3d0792e66bfb9901cb16087529158d209e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyinflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;anyinflate&lt;/code&gt; 가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e70bd36d1a537ad13b970c5e3018a8db164c8ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyuncompress&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;anyuncompress&lt;/code&gt; 가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c9769aa738284afde961b2f9bd816825ddcd7550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bunzip2&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;bunzip2&lt;/code&gt; 는이 완성되었다.</target>
        </trans-unit>
        <trans-unit id="45ce2b192ba4b06ccb81a9f97e89861c03acbbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bzip2&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;bzip2&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="931b26269125b502ee9a79f1079ca4ffe0db45ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;deflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;deflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="e1fd436eb74e99c1011e676ef2d33a7ca8f221d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gunzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;gunzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="88e88b090b73765991b48faaa8220edbbe4df365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;gzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="a90d9e6b94ea9918e75047142b2356a3ca3ce954" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;inflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;inflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a6b1372a509b879eaf5e2572538481635eccd1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawdeflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;rawdeflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="49cd128d450ba32be8b448e6b5ad08dbf2c6fedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawinflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;rawinflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0389ec2b7c0d6d8486da6034ee7b237f00728a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;unzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 한번 폐쇄되고 &lt;code&gt;unzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b28f338327748e0ed3d3b45714c8c08b6240edf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;zip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;zip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f369078e4170f80457a1f35c7563da5a1cc6678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Blocking&lt;/code&gt; is set to 0, the connection will be in nonblocking mode. If not specified it defaults to 1 (blocking mode).</source>
          <target state="translated">&lt;code&gt;Blocking&lt;/code&gt; 경우 0으로 설정, 연결 모드 블로킹에있을 것입니다. 지정하지 않으면 기본값은 1 (차단 모드)입니다.</target>
        </trans-unit>
        <trans-unit id="bb88f5eab4e448f2a5e55013144cf7297d82804e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca4e9e26da273f75ec2f01acbae00f6340bacd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;DATA&lt;/code&gt; 지정되지 않은 결과는 서버에서 전송되는 데이터를 원하는 것으로 표시됩니다. 그런 다음 &lt;a href=&quot;cmd&quot;&gt;Net :: Cmd에&lt;/a&gt; 설명 된 &lt;code&gt;datasend&lt;/code&gt; 및 &lt;code&gt;dataend&lt;/code&gt; 메소드를 사용하여 데이터를 보내야합니다. .</target>
        </trans-unit>
        <trans-unit id="1b9556c0d7129263a154caaea9b76ae15222d837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Digest::MD5&lt;/code&gt; is not available, it return a string with only &lt;code&gt;0&lt;/code&gt;'s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e077eab3d667c955449b8c582fa6b4685309db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExactAddresses&lt;/code&gt; is passed to the constructor, then addresses should be a valid rfc2821-quoted address, although Net::SMTP will accept the address surrounded by angle brackets.</source>
          <target state="translated">만약 &lt;code&gt;ExactAddresses&lt;/code&gt; 가 생성자에 전달 Net :: SMTP는 꺾쇠 괄호로 묶은 주소를 허용하지만 주소는 유효한 rfc2821 인용 주소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f9a7de111ad6f15c5cac01bf2df035fda0020" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FH&lt;/code&gt; is specified then it is expected to be a valid filehandle and the result will be printed to it, on success a true value will be returned. If &lt;code&gt;FH&lt;/code&gt; is not specified then the return value, on success, will be a reference to an array containing the article requested, each entry in the array will contain one line of the article.</source>
          <target state="translated">&lt;code&gt;FH&lt;/code&gt; 가 지정 되면 유효한 파일 핸들이 될 것으로 예상되고 결과가 인쇄되며 성공하면 true 값이 리턴됩니다. &lt;code&gt;FH&lt;/code&gt; 인 경우 다음 성공 반환 값을 지정하지 않고, 요청 된 문서를 포함하는 배열을 참조 할 것, 어레이의 각 항목은 문서의 한 행을 포함 할 것이다.</target>
        </trans-unit>
        <trans-unit id="dcf85df21ad4f13a17a67e275700748df1fd4365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Features&lt;/code&gt; method reports a feature &lt;code&gt;attribs&lt;/code&gt; as present, the method &lt;code&gt;Attribs&lt;/code&gt; is not dummy.</source>
          <target state="translated">경우 &lt;code&gt;Features&lt;/code&gt; 방법은 기능보고 &lt;code&gt;attribs&lt;/code&gt; 선물로를, 방법 &lt;code&gt;Attribs&lt;/code&gt; 은 더미 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e81c8aad04f59a1692e53f2e58534a0dee91bde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt; , which inherited from &lt;code&gt;Thing&lt;/code&gt; , then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">경우, &lt;code&gt;File&lt;/code&gt; 로부터 상속 된 &lt;code&gt;DataSource&lt;/code&gt; 로부터 상속, &lt;code&gt;Thing&lt;/code&gt; , 다음 펄이 필요한 경우 &quot;체인까지&quot;계속 찾고있다.</target>
        </trans-unit>
        <trans-unit id="01422e251ecb63e2630d1526d1b2fd71e7e35b64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt;, which inherited from &lt;code&gt;Thing&lt;/code&gt;, then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871f80a19c627be0f52c1b6ef1cd6cbad1358e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle::open&lt;/code&gt; 숫자 모드를 주어, 그 모드와 펄에 대한 선택 권한 값 전달 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 연산자를. 편의상 &lt;code&gt;FileHandle::import&lt;/code&gt; 는 Fcntl 모듈에서 O_XXX 상수를 가져 시도합니다. 동적 로딩을 사용할 수 없으면 실패 할 수 있지만 나머지 FileHandle은 여전히 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5d4678ebb21520018d8a8ac8a3ed168c69d444f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1f139d098c0a906b0eeef1ef6e5dc6d9836cd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle::open&lt;/code&gt; 펄 모드 문자열을 수신한다 ( &quot;&amp;gt;&quot;, &quot;+는 &amp;lt;&quot;, 등) 또는 (등 &quot;w&quot;, &quot;R +&quot;)는 POSIX는 fopen 모드 () 문자열, 상기 기본 펄 사용 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="f576810c104d4cab1572ebfd5a073a5c50992b01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2feaf81d0c85e64b59f8f9c85179dcb22ae1819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GLOB_NOSORT&lt;/code&gt; is not in effect, sort filenames is alphabetical order (case does not matter) rather than in ASCII order.</source>
          <target state="translated">경우 &lt;code&gt;GLOB_NOSORT&lt;/code&gt; 가 유효하지 않다, 종류의 파일 이름 알파벳 순서 오히려 ASCII 순서보다 (경우는 문제가되지 않습니다)입니다.</target>
        </trans-unit>
        <trans-unit id="67e8ee96965d8f4239b93f54928c2446de8f1552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; to indicate whether the compiler is version 1 or 2. This is used in setting some of the default cflags. It is set to '' if not gcc.</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)을 사용하고,이 변수는 보유 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 컴파일러 버전 1 또는 2.이 기본 CFLAGS의 일부를 설정하는 데 사용되어 있는지 여부를 나타냅니다. gcc가 아닌 경우 ''로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ee184683f7c3453d93a7bedbc7d10e7e2d4b99bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds the operating system and version used to compile gcc. It is set to '' if not gcc, or if nothing useful can be parsed as the os version.</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)가 사용되며,이 변수는 컴파일 GCC에 사용되는 운영 체제 및 버전을 보유하고 있습니다. gcc가 아닌 경우 또는 ''os 버전으로 구문 분석 할 수있는 내용이없는 경우 ''로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c81dd0bd77cba1c688390cdf8b5eb031575d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable will enable (if set) the -ansi and -pedantic ccflags for building core files (through cflags script). (See</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)가 사용되며,이 변수 (CFLAGS 스크립트를 통해) 코어 파일을 구축 (설정되는 경우) -ansi와 -pedantic ccflags 수있게된다. (보다</target>
        </trans-unit>
        <trans-unit id="0efd17fe9103ee1aaae0dc765c4fdcda7599e53f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 포함하는 모드 주어진다 &lt;code&gt;:&lt;/code&gt; 문자를,이 세 가지 인수에 대한 모든 세 개의 인수를 전달 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 연산자를.</target>
        </trans-unit>
        <trans-unit id="d9d2307f492ec346285f4361272b678878cc377e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b022840a97cd5dd7f3b791be6eab1e939aa4189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 숫자 모드를 주어, 그 모드와 펄에 대한 선택 권한 값 전달 &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 연산자를. 사용 권한의 기본값은 0666입니다.</target>
        </trans-unit>
        <trans-unit id="648473154f696c7584f730b90fd7267a915b5e74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e83efe8c19dc0d9571afae7a20a9dcda69bd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 펄 모드 문자열을 수신한다 ( &quot;&amp;gt;&quot;, &quot;+는 &amp;lt;&quot;, 등) 또는 ANSI C는 fopen 모드 () 문자열 ( &quot;w&quot;, &quot;R +&quot;등)는 사용 기본 Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 연산자 (특수 문자는 보호)</target>
        </trans-unit>
        <trans-unit id="a2b31024d2546cbe74c22838b7e8daa31b3fb8b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25244641705396e9c5a0c603f886177852688f85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; is omitted, the file list is obtained from the manifest. The file list may include shell wildcards which will be expanded out.</source>
          <target state="translated">경우 &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; 생략 된 파일 목록은 매니페스트에서 얻을 수있다. 파일 목록에는 확장 될 쉘 와일드 카드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc047fe00993cc36f1bde2a682c140574f3968b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; has been specified then XFL is set to 2. If &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; has been specified then XFL is set to 4. Otherwise XFL is set to 0.</source>
          <target state="translated">경우 &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; 다음 지정 XFL은 2로 설정되어있는 경우 &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; XFL은 그렇지 XFL을 0으로 설정 4로 설정 한 후 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="0aa2ad74e8011287eeea7635ab9b549166e0107b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LimitOutput&lt;/code&gt; is enabled, the &lt;code&gt;ConsumeInput&lt;/code&gt; option will also be enabled.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutput&lt;/code&gt; 이 활성화되면, &lt;code&gt;ConsumeInput&lt;/code&gt; 의 옵션도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5272a0252e677f68469c99e247e850a281513f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Listen&lt;/code&gt; is defined then a listen socket is created, else if the socket type, which is derived from the protocol, is SOCK_STREAM then connect() is called. If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">경우 &lt;code&gt;Listen&lt;/code&gt; 다음 정의 된 프로토콜에서 파생 된 소켓 형이 호출 한 후 연결 SOCK_STREAM가 () 인 경우는, 소켓이 생성됩니다 다른 들어요. 는 IF &lt;code&gt;Listen&lt;/code&gt; 인수가 주어하지만 거짓되고, 큐 크기는 5로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="119d044a27ad244e9922efb2919b95739dfc6f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is a reference to a list of two message numbers and the second number in a range is less than or equal to the first then the range represents all messages in the group after the first message number.</source>
          <target state="translated">경우 &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; 보다 적은 두 메시지 번호 목록과 범위 제 번호에 대한 참조 또는 우선 범위와 동일한 제 1 메시지 번호 뒤에 그룹의 모든 메시지를 의미한다.</target>
        </trans-unit>
        <trans-unit id="983c80c65b5dc12e5941f3ad256f42dbd5aa351d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fae31070991ff1f03f3487ee3feed2b35c28afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;MESSAGE&lt;/code&gt; 지정되지 메시지가 사용하여 전송해야 &lt;code&gt;datasend&lt;/code&gt; 및 &lt;code&gt;dataend&lt;/code&gt; 에서 방법 &lt;a href=&quot;cmd&quot;&gt;넷 :: Cmd를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4f8b5e83cced9672fcf844844603c4b1519fbeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NEXT&lt;/code&gt; redispatching is used in the methods of a &quot;diamond&quot; class hierarchy:</source>
          <target state="translated">&quot;다이아몬드&quot;클래스 계층의 메소드에서 &lt;code&gt;NEXT&lt;/code&gt; 재배포가 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="fa6cc1f17445fc581970662d0c27067922cd4606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the zip filename header field.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 지정하지 않 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름입니다,의 값 &lt;code&gt;$input&lt;/code&gt; 압축 파일 이름 헤더 필드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16fa552eaed310969186dcb3a6fc9c674d262d84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, no zip filename field will be created.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 지정되지하고있다 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름이 아니라, 더 압축 파일 이름 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90ec1912df6897d3b8157fa885ee828e31fcb30c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_DENY&lt;/code&gt; is set, the module is loaded as if with &lt;code&gt;no&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d9c7a2c762fe5aa671ca88a1e57aa13b9aa7f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; is set, the module is loaded as if with an empty import list, as in &lt;code&gt;use Foo::Bar ()&lt;/code&gt;; this is the only circumstance in which the trailing optional arguments may be omitted entirely. Otherwise, if &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing arguments must consist of exactly one &lt;code&gt;OP*&lt;/code&gt;, containing the op tree that produces the relevant import arguments. Otherwise, the trailing arguments must all be &lt;code&gt;SV*&lt;/code&gt; values that will be used as import arguments; and the list must be terminated with &lt;code&gt;(SV*) NULL&lt;/code&gt;. If neither &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; nor &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing &lt;code&gt;NULL&lt;/code&gt; pointer is needed even if no import arguments are desired. The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; argument is decremented. In addition, the &lt;code&gt;name&lt;/code&gt; argument is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7150b29ccf2318861af577a7533fe5cd202a009c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_ALL&lt;/code&gt; is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if &lt;code&gt;PERL_PV_ESCAPE_NONASCII&lt;/code&gt; is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt;. Otherwise, if &lt;code&gt;PERL_PV_ESCAPE_NOBACKSLASH&lt;/code&gt; then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6e934e5c2d97914014a2305fe6d83cca0f7a87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_FIRSTCHAR&lt;/code&gt; is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4556bf449af07632214df812c6e299c60c88a77e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_RE&lt;/code&gt; is set then the escape char used will be a &lt;code&gt;&quot;%&quot;&lt;/code&gt; and not a &lt;code&gt;&quot;\\&quot;&lt;/code&gt;. This is because regexes very often contain backslashed sequences, whereas &lt;code&gt;&quot;%&quot;&lt;/code&gt; is not a particularly common character in patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b287252fa0fadb9f209dd7e1ddcb194eaed64b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_UNI&lt;/code&gt; is set then the input string is treated as UTF-8 if &lt;code&gt;PERL_PV_ESCAPE_UNI_DETECT&lt;/code&gt; is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35533bcb02c546225ef493f044a6f536db7a71c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; 가 설정된 경우</target>
        </trans-unit>
        <trans-unit id="927d1c982e9f33464297a28a964aa06b97d23586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; then any or all pairs of digits may be separated from each other by a single underscore; also a single leading underscore is accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cb6eab9df9b80f7b8043595e084ea362a195f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt; . If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl
-MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">경우 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 의 환경 변수가 설정되어, 그것은 예기치 않은 여러 결과를 비교하기위한 명령으로 사용됩니다. GNU diff가 설치되어 있으면 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 를 &lt;code&gt;diff -u&lt;/code&gt; 로 설정하려고 할 수 있습니다 . 적합한 프로그램이없는 경우 &lt;code&gt;Text::Diff&lt;/code&gt; 모듈을 설치 한 다음 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 를 &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; 로 설정할 수 있습니다 . 경우 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 가 설정하지만되지 않은 &lt;code&gt;Algorithm::Diff&lt;/code&gt; 모듈을 사용할 수, 다음은 여러 결과의 차이를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e08ae53639fc6920187fdd8042110e8e1996f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt;. If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt;. If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb3ad782aee3a8db708fe40cb7ddcd44325815d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PadnameOUTER&lt;/code&gt; is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee3b30e6a54d64d92736caa387fa1fa00014452" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PerlIO_push&lt;/code&gt; was performed and open has failed, it must &lt;code&gt;PerlIO_pop&lt;/code&gt; itself, since if it's not, the layer won't be removed and may cause bad problems.</source>
          <target state="translated">경우 &lt;code&gt;PerlIO_push&lt;/code&gt; 이 수행 된 오픈에 실패했습니다, 그것은해야한다 &lt;code&gt;PerlIO_pop&lt;/code&gt; 그렇지 않은 경우, 층이 제거되지 않기 때문에, 그 자체를 나쁜 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92add0536c750719a7004e9b389b82f89f36216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Proto&lt;/code&gt; is not given and you specify a symbolic &lt;code&gt;PeerPort&lt;/code&gt; port, then the constructor will try to derive &lt;code&gt;Proto&lt;/code&gt; from the service name. As a last resort &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot; is assumed. The &lt;code&gt;Type&lt;/code&gt; parameter will be deduced from &lt;code&gt;Proto&lt;/code&gt; if not specified.</source>
          <target state="translated">경우 &lt;code&gt;Proto&lt;/code&gt; 주어지지하고 상징적 지정 &lt;code&gt;PeerPort&lt;/code&gt; 의 포트를 다음 생성자를 도출하기 위해 노력할 것입니다 &lt;code&gt;Proto&lt;/code&gt; 서비스 이름에서. 최후의 수단으로 &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot;가 가정됩니다. &lt;code&gt;Type&lt;/code&gt; 매개 변수를 추론됩니다 &lt;code&gt;Proto&lt;/code&gt; 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fe5b8d2d2cf1b0bc68bdf3e0b890723eb0712304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SkipBad&lt;/code&gt; is true the &lt;code&gt;recipient&lt;/code&gt; will not return an error when a bad address is encountered and it will return an array of addresses that did succeed.</source>
          <target state="translated">경우 &lt;code&gt;SkipBad&lt;/code&gt; 는 사실이다 &lt;code&gt;recipient&lt;/code&gt; 잘못된 주소가 발견 될 때 오류를 반환하지 않습니다 그것은 성공 않았다 주소의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0468225999e79fdda0c8dc21ac9ecaa76acd0e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Strict&lt;/code&gt; is enabled the following behaviour will be policed:</source>
          <target state="translated">경우 &lt;code&gt;Strict&lt;/code&gt; IS가 활성화 된 다음과 같은 동작이 치안을한다 :</target>
        </trans-unit>
        <trans-unit id="b96d3e92a2737a01f8355b6b1112adb835436235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;TIMEOUT&lt;/code&gt; 가 누락 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 작거나 0보다,이 호출은 동일하게 동작 &lt;code&gt;dequeue_nb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c530cec74f6e8b7055d3fa3d9efe868ec89d0a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;undef&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3dbb2f4f8d2f84122800f9964093173fd31ae6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt; 's memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , the entire file will be rewritten in a single pass.</source>
          <target state="translated">경우 &lt;code&gt;Tie::File&lt;/code&gt; 의 메모리 제한이 충분히 큰이며, 모든 쓰기는 메모리에서 수행됩니다. 그런 다음 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 를 호출 하면 전체 파일이 단일 패스로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="86295dc1bf1fa74a00cc2da2e3439e42c182b9ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt;'s memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt;, the entire file will be rewritten in a single pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717bb6fc0375ed7c5d36f69b6a41d7203067aa19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is 26 or later, the &lt;code&gt;identical&lt;/code&gt; level is preferred; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; and &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt;&lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; should be used.</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; 가 26 이상이되면, &lt;code&gt;identical&lt;/code&gt; 레벨이 바람직하다; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; 및 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt; &lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="02434c0e062f79bd3d8c8ef802e8385afcfb68a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or greater than 14, default is &lt;code&gt;[]&lt;/code&gt; (i.e. no rearrangement).</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; 는 같거나 14보다 큰 경우, 디폴트는 없다 &lt;code&gt;[]&lt;/code&gt; (즉, 어떠한 재 배열).</target>
        </trans-unit>
        <trans-unit id="b309f1cb237c3cb1331fc5e7c80d1a3dc5b1ba82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 디버그 레벨은 클래스의 기본 디버그 레벨로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4e940cabf3eff6f96ef019a41252378fda2e834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44072f8a4414482a73ce8e1b198996a838545678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WHERE&lt;/code&gt; is given then the first &lt;code&gt;WHERE&lt;/code&gt; bytes of the file will not be transferred, and the remaining bytes will be appended to the local file if it already exists.</source>
          <target state="translated">만약 &lt;code&gt;WHERE&lt;/code&gt; 다음 첫 번째 주어진 &lt;code&gt;WHERE&lt;/code&gt; 파일의 바이트가 전송되지 않습니다, 그리고 이미 존재하는 경우 나머지 바이트는 로컬 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ac99e0f8353a2cf6b3d40ee09fd4abe5de979195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allow_tags&lt;/code&gt; is enabled, &lt;code&gt;JSON::PP&lt;/code&gt; will look up the &lt;code&gt;THAW&lt;/code&gt; method of the package/classname used during serialisation (it will not attempt to load the package as a Perl module). If there is no such method, the decoding will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdf8e9a5929ab26a43f519805188b99c5f0b522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">bunzip2 오브젝트의 생성자에서 &lt;code&gt;appendOutput&lt;/code&gt; 이 사용 가능한 경우 압축되지 않은 데이터가 &lt;code&gt;$output&lt;/code&gt; 추가됩니다 . 사용하지 않으면 압축되지 않은 데이터가 쓰기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="667286e52e2e632a32355f2300da667dd6bd7a78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f450b4455b8d11ffbd473a1bb2010cafedaed33e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">bzip2 객체의 생성자에서 &lt;code&gt;appendOutput&lt;/code&gt; 이 활성화 된 경우 압축 된 데이터가 &lt;code&gt;$output&lt;/code&gt; 추가됩니다 . 사용하지 않으면 압축 된 데이터를 쓰기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="096baeccf53db357601ffc253c8281b1e48c8ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1432fae77d6dafc174cc09ef9602a6c9c5caf4ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block&lt;/code&gt; is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as &lt;code&gt;sub foo ($$);&lt;/code&gt;. If &lt;code&gt;block&lt;/code&gt; is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to &lt;code&gt;PL_compcv&lt;/code&gt;. The code is not expected to include a &lt;code&gt;leavesub&lt;/code&gt; or &lt;code&gt;leavesublv&lt;/code&gt; op; this function will add such an op. &lt;code&gt;block&lt;/code&gt; is consumed by this function and will become part of the constructed subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b199e24b4ee7d3c552a01dcb6637c8cc3a9e1f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bundling_override&lt;/code&gt; is enabled, bundling is enabled as with &lt;code&gt;bundling&lt;/code&gt; but now long option names override option bundles.</source>
          <target state="translated">경우 &lt;code&gt;bundling_override&lt;/code&gt; 가 활성화되어 번들은에서와 같이 사용할 수 있습니다 &lt;code&gt;bundling&lt;/code&gt; 하지만 지금은 긴 옵션 이름 재정의 옵션 번들.</target>
        </trans-unit>
        <trans-unit id="54b90baea8c11dc735bd2168186bca9ee27f1a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;caller()&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dc97ff755fb934bfd6f1a8ed830ff62cc4e40b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;consumeInput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, &lt;code&gt;$input&lt;/code&gt; will have all compressed data removed from it after uncompression. On &lt;code&gt;BZ_OK&lt;/code&gt; return this will mean that &lt;code&gt;$input&lt;/code&gt; will be an empty string; when &lt;code&gt;BZ_STREAM_END&lt;/code&gt;&lt;code&gt;$input&lt;/code&gt; will either be an empty string or will contain whatever data immediately followed the compressed data stream.</source>
          <target state="translated">bunzip2 오브젝트의 생성자에서 &lt;code&gt;consumeInput&lt;/code&gt; 이 사용 가능한 경우 , &lt;code&gt;$input&lt;/code&gt; 은 압축 해제 후 모든 압축 된 데이터가 제거됩니다. 에 &lt;code&gt;BZ_OK&lt;/code&gt; 이 있음을 의미합니다 반환 &lt;code&gt;$input&lt;/code&gt; 빈 문자열이 될 것이다; &lt;code&gt;BZ_STREAM_END&lt;/code&gt; &lt;code&gt;$input&lt;/code&gt; 이 빈 문자열이거나 압축 된 데이터 스트림 바로 뒤에 오는 모든 데이터를 포함 할 때</target>
        </trans-unit>
        <trans-unit id="13672333fc5b967feaa626b683b8bcc04e6c7332" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1dd05ec9d332008df8a7389201274fce30d7a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">&lt;code&gt;cv&lt;/code&gt; 가 인라인 할 수있는 상수 하위 인 경우 하위에서 반환 한 상수 값을 반환합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ede33bdf6d08f63d2072630b001c1c1d527bfdbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37d86734f002378b0c0f7d856f9af361e68cbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done_testing()&lt;/code&gt; is called twice, the second call will issue a failing test.</source>
          <target state="translated">경우 &lt;code&gt;done_testing()&lt;/code&gt; 두 번 호출되고, 두 번째 호출은 실패 테스트를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="a074a15a27ab0ac63397d85c19569d7f123797eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;down()&lt;/code&gt; 시도가 영하 카운터를 감소하기 위해서는 블록 카운터가 충분히 큰 때까지. 시작 카운트가 0 인 세마포어를 만들 수 있지만, &lt;code&gt;up()&lt;/code&gt; 또는 &lt;code&gt;down()&lt;/code&gt; 항상 카운터를 하나 이상 변경하므로 &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; 은 &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; 와 같습니다. down (1) .</target>
        </trans-unit>
        <trans-unit id="dc095b856cd7bbcf568ac5723a3a668cbf72bdda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2ee9c9e231a07f99e855dc49bb00a01e62f7c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e &amp;lt; s&lt;/code&gt; or if the scan would end up past &lt;code&gt;e&lt;/code&gt;, it raises a UTF8 warning and returns the number of valid characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73e1156e34709c2cf87a897c0dfdd15558afa70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit()&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ba804a2596516d0c1570f7f282c973ab9c2345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extract&lt;/code&gt; is called without a list of file names, the entire contents of the archive are extracted.</source>
          <target state="translated">경우 &lt;code&gt;extract&lt;/code&gt; 파일 이름 목록없이 호출, 아카이브의 전체 내용이 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1942906fddd7c45d5614b21cfa194ab92d3708" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fallback&lt;/code&gt; is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</source>
          <target state="translated">두 피연산자 모두에 대해 &lt;code&gt;fallback&lt;/code&gt; 가 참 이면 피연산자를 연산자에 적합한 숫자, 문자열 또는 부울로 처리하여 연산자에 대해 일반적인 작업을 수행하십시오 (주 참조).</target>
        </trans-unit>
        <trans-unit id="77c9ad5fa8afacb61183204af87e0582ca853195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags &amp;amp; SV_SMAGIC&lt;/code&gt; is true, will call &lt;code&gt;SvSETMAGIC&lt;/code&gt;. If &lt;code&gt;flags &amp;amp; SV_HAS_TRAILING_NUL&lt;/code&gt; is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt;, and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt;, and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd52e0f8326669fc207b7050c548b0008ac0b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC is true, will call SvSETMAGIC. If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt; , and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt; , and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt; ).</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 및 SV_SMAGIC이 참, SvSETMAGIC를 호출합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 및 SV_HAS_TRAILING_NUL 해당하는 다음 &lt;code&gt;ptr[len]&lt;/code&gt; 있어야 &lt;code&gt;NUL&lt;/code&gt; 및 realloc을 스킵한다 (즉, 버퍼는보다 적어도 1 바이트 이상 실제로 &lt;code&gt;len&lt;/code&gt; 및 이미 기억 요건을 충족 &lt;code&gt;SvPVX&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0edc0d40cf1bae07e3194b59cda754464ac0af29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not include the &lt;code&gt;G_DISCARD&lt;/code&gt; flag then &lt;code&gt;hv_delete&lt;/code&gt; will create and return a mortal copy of the deleted value.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 인클루드하지 않는 &lt;code&gt;G_DISCARD&lt;/code&gt; 의 플래그를 다음 &lt;code&gt;hv_delete&lt;/code&gt; 는 생성하고 삭제 된 값의 인간의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10df1aa8bd4f0824119d6cef9b8d19de3f0f48a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV will expand when converted to UTF-8, and skips the extra work of checking for that. Typically this flag is used by a routine that has already parsed the string and found such characters, and passes this information on so that the work doesn't have to be repeated.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 SV_FORCE_UTF8_UPGRADE가 설정되어 있으면 이 함수는 UTF-8로 변환 될 때 PV가 확장된다고 가정하고 추가 점검 작업을 건너 뜁니다. 일반적으로이 플래그는 이미 문자열을 구문 분석하고 해당 문자를 찾은 루틴에서 사용하며이 정보를 전달하여 작업을 반복 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad87c09509d32a63c00d8007a6c9913223d72fda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;CV_NAME_NOTQUAL&lt;/code&gt; bit set, then the package name will not be included. If the first argument is neither a CV nor a GV, this flag is ignored (subject to change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b250f1c8aff9dcda9cab5ceb3c6ef02e048bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on &lt;code&gt;dsv&lt;/code&gt; afterwards if appropriate. &lt;code&gt;sv_catpvn&lt;/code&gt; and &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_set&lt;/code&gt; 에 &lt;code&gt;dsv&lt;/code&gt; 필요한 경우 나중에. &lt;code&gt;sv_catpvn&lt;/code&gt; 및 &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="883c9501bfde5d52c5604a1b12447c3d9a8fe23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_MARK_EARLY&lt;/code&gt; set, then the handling of a GV reference is modified. If a GV was examined and its CV slot was found to be empty, then the &lt;code&gt;gv&lt;/code&gt; op has the &lt;code&gt;OPpEARLY_CV&lt;/code&gt; flag set. If the op is not optimised away, and the CV slot is later populated with a subroutine having a prototype, that flag eventually triggers the warning &quot;called too early to check prototype&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba87252f4445bc6642c895685a2b0c13a4c9f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_RETURN_NAME_GV&lt;/code&gt; set, then instead of returning a pointer to the subroutine it returns a pointer to the GV giving the most appropriate name for the subroutine in this context. Normally this is just the &lt;code&gt;CvGV&lt;/code&gt; of the subroutine, but for an anonymous (&lt;code&gt;CvANON&lt;/code&gt;) subroutine that is referenced through a GV it will be the referencing GV. The resulting &lt;code&gt;GV*&lt;/code&gt; is cast to &lt;code&gt;CV*&lt;/code&gt; to be returned. A null pointer is returned as usual if there is no statically-determinable subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242a2d0b6758ae9991c2578558a99b10e3dde258" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; in non-zero, it can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, and with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ac1f6f577ac784401bb8130dc871e9c34ad1b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, any well-formed UTF-8, as extended by Perl, is accepted without restriction. If the final few bytes of the buffer do not form a complete code point, this will return TRUE anyway, provided that &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char_flags&quot;&gt;&quot;is_utf8_valid_partial_char_flags&quot;&lt;/a&gt;&lt;/code&gt; returns TRUE for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23848029d478b456b26bba2286d77574bebc75c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this behaves identically to &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char&quot;&gt;&quot;is_utf8_valid_partial_char&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. If there is any sequence of bytes that can complete the input partial character in such a way that a non-prohibited character is formed, the function returns TRUE; otherwise FALSE. Non character code points cannot be determined based on partial character input. But many of the other possible excluded types can be determined from just the first one or two bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7776c59483454fdc128e37c2b654f9e899314281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this function accepts any code point from 0..&lt;code&gt;IV_MAX&lt;/code&gt; as input. &lt;code&gt;IV_MAX&lt;/code&gt; is typically 0x7FFF_FFFF in a 32-bit word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e5eab05bd09c8fe9f56a01b844bac5e3765d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01ee327fde250472c539a32455541306b4bc120" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef48bc44bf4f8b7aeee22cccd386b0d4dcfb8f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame
&amp;amp; 16&lt;/code&gt; , the return value from the subroutine is printed.</source>
          <target state="translated">&lt;code&gt;frame &amp;amp; 4&lt;/code&gt; 인 경우 함수에 대한 인수와 컨텍스트 및 호출자 정보가 인쇄됩니다. &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; 인 경우 , 인쇄 된 인수 에서 오버로드 &lt;code&gt;stringify&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; 가 활성화됩니다. &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; 인 경우 서브 루틴의 리턴 값이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f6ef7c333faaf2cb26f8747450c37161f8d75370" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt;, arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt;, overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;tie&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame &amp;amp; 16&lt;/code&gt;, the return value from the subroutine is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e3981c02655a1fab1a806eaa02120a0c9bfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;function&lt;/code&gt; was the name of a function, then &lt;code&gt;memoize&lt;/code&gt; hides the old version and installs the new memoized version under the old name, so that &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; actually invokes the memoized version.</source>
          <target state="translated">경우 &lt;code&gt;function&lt;/code&gt; 함수의 이름이고, 다음 &lt;code&gt;memoize&lt;/code&gt; 는 이전 버전을 숨기고 이전 이름으로 새로운 memoized 버전을 설치, 그래서 &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; 실제로 memoized 버전을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4823580da2e2f493ed7ea495228a6fb43531c2a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;get_handle&lt;/code&gt; 그것은 CGI로 호출 된 프로그램에서 실행중인 것을 감각, 다음은 환경 변수 &quot;HTTP_ACCEPT_LANGUAGE&quot;에서 언어 태그를 가져 오려고 시도하고, 그가에 매개 변수로 전달하는 언어라고 척 &lt;code&gt;get_handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8f1bd59bcb9836018bddcc2b5f32a734b99099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5501c614e6eee43f2f2b50112bdb8a824a2fea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a completely empty typeglob, it is deleted from the stash.</source>
          <target state="translated">경우 &lt;code&gt;gv&lt;/code&gt; 완전히 빈 타입 글로브입니다, 그것은 숨김에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="171c792393c3bd16ce8492fbf51df1d34df47fa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</source>
          <target state="translated">&lt;code&gt;gv&lt;/code&gt; 가 충분히 일반적인 상수 서브 만 포함하는 타입 글로브 인 경우 , 타입 글로브는 동일한 것을보다 간결하게 나타내는 스칼라 참조 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="91c336e511b07c506517b1f2fbdfac89a7b69625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15863e2e3bcfe9bf34415295eb886e40c8b84a73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">경우 &lt;code&gt;gv&lt;/code&gt; 그 루틴 엔트리 인라인 또는 동안 일정한 서브 적격 인 타입 글로브이고 &lt;code&gt;gv&lt;/code&gt; 이러한 타입 글로브 승격 될 플레이스 홀더 기준이며, 그때 서브 의해 반환 값을 반환한다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b76926b7fe43456ac634077129deadebe6d1749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt; ) on each line.</source>
          <target state="translated">&lt;code&gt;ignoreName&lt;/code&gt; 또는 &lt;code&gt;undefName&lt;/code&gt; 을 사용하는 경우 각 행 에서 문자 이름을 주석 ( &lt;code&gt;#&lt;/code&gt; 다음에 )으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c67ec45488470986d50d9732fc06ac7df6e89db8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt;) on each line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606bfb04b8810dddbc165299090455517c6f31d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt; , (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 0,이를 사용하여 계산됩니다 &lt;code&gt;strlen(s)&lt;/code&gt; (이 옵션을 사용하는 경우 것으로, 어떤 수단 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 포함 할 수 없습니다 &lt;code&gt;NUL&lt;/code&gt; 의 문자와 종료해야합니다 &lt;code&gt;NUL&lt;/code&gt; 의 바이트).</target>
        </trans-unit>
        <trans-unit id="35a8aa529d970b1105047bbf5eb8254c1640c25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt;, (which means if you use this option, that &lt;code&gt;s&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564f6927aa67faeb8390b79eb296fc0609382f07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_archive()&lt;/code&gt; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</source>
          <target state="translated">경우 &lt;code&gt;list_archive()&lt;/code&gt; 세 번째 인자로 배열 참조를 전달 각 파일의 요구 된 속성을 포함하는 해시 참조 목록을 반환한다. full_path, 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type 등의 속성 목록이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30b6892ba87f6c10d6419b32b55f7a86419b6ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_files()&lt;/code&gt; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</source>
          <target state="translated">경우 &lt;code&gt;list_files()&lt;/code&gt; 첫 번째 인수로 배열 참조를 전달 각 파일의 요구 된 속성을 포함하는 해시 참조 목록을 반환한다. 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix 등의 속성 목록이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6b6ca16484970453642612331b9f95d68983da46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounter an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors), or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">경우 &lt;code&gt;make_path&lt;/code&gt; 또는 &lt;code&gt;remove_tree&lt;/code&gt; 발생 오류, 진단 메시지를 출력한다 &lt;code&gt;STDERR&lt;/code&gt; 통해 &lt;code&gt;carp&lt;/code&gt; (치명적 오류) 또는 비아 &lt;code&gt;croak&lt;/code&gt; (치명적인 오류).</target>
        </trans-unit>
        <trans-unit id="c1dea29744b11722e865e983de60cdb68d486715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounters an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors) or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12005256b82b7dbf15e43b617aa6446b9ea3caa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge&lt;/code&gt; is true the harness will create parsers that merge STDOUT and STDERR together for any processes they start.</source>
          <target state="translated">경우 &lt;code&gt;merge&lt;/code&gt; 사실이다 하네스은 시작하는 모든 프로세스를 위해 함께 STDOUT 및 STDERR 병합 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a65b7746a43b203ecde7cf3199ef2365227c5212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt;. &lt;code&gt;flags&lt;/code&gt; may contain flag bits understood by &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt; with the same meaning as they have there, such as &lt;code&gt;GV_ADDWARN&lt;/code&gt;. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab07e7506173a92d684e99bcaa1a4031e98f0c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified. If the name is unqualified then it defaults to being in the stash specified by &lt;code&gt;stash&lt;/code&gt; if that is non-null, or to &lt;code&gt;PL_curstash&lt;/code&gt; if &lt;code&gt;stash&lt;/code&gt; is null. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a417a1f8bba03650439d46556e6b5e2f42cdc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;namlen&lt;/code&gt; is greater than zero then a &lt;code&gt;savepvn&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;namlen&lt;/code&gt; 는 다음 제로 (A)보다 큰 &lt;code&gt;savepvn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5b4f60a5261a12c3ad5e79f21f3b4cceb3007ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">만약 &lt;code&gt;new()&lt;/code&gt; 인수로 호출되고있다 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 메소드는 어떤 이유로 실패, &lt;code&gt;new()&lt;/code&gt; 반환 미확정.</target>
        </trans-unit>
        <trans-unit id="7cef9a9221becdc1b22f8b33e94c433da6581c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;read()&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33de51c2b233ea7368e7ccccf568c1e624835ecc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o&lt;/code&gt; is null, the state op is returned. Otherwise the state op is combined with &lt;code&gt;o&lt;/code&gt; into a &lt;code&gt;lineseq&lt;/code&gt; list op, which is returned. &lt;code&gt;o&lt;/code&gt; is consumed by this function and becomes part of the returned op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c8f13fd0a4ec2abf65b26b0dde9b71cbc468dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is null, then the subroutine will be anonymous. If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is non-null, then &lt;code&gt;o&lt;/code&gt; must point to a &lt;code&gt;const&lt;/code&gt; op, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If &lt;code&gt;o_is_gv&lt;/code&gt; is true, then &lt;code&gt;o&lt;/code&gt; doesn't point to an &lt;code&gt;OP&lt;/code&gt; at all, but is instead a cast pointer to a &lt;code&gt;GV&lt;/code&gt; by which the subroutine will be named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf32c805e2ddc81931fd2560a08109645dce7e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is &lt;code&gt;OP_ANDASSIGN&lt;/code&gt;, &lt;code&gt;OP_ORASSIGN&lt;/code&gt;, or &lt;code&gt;OP_DORASSIGN&lt;/code&gt;, then a suitable conditional optree is constructed. If &lt;code&gt;optype&lt;/code&gt; is the opcode of a binary operator, such as &lt;code&gt;OP_BIT_OR&lt;/code&gt;, then an op is constructed that performs the binary operation and assigns the result to the left argument. Either way, if &lt;code&gt;optype&lt;/code&gt; is non-zero then &lt;code&gt;flags&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ecad3c0cc7408f92e26472fcb7141e48a993e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is zero, then a plain scalar or list assignment is constructed. Which type of assignment it is is automatically determined. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 or 2 is automatically set as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b4ce4ab1caa8905ea03f71030c64a0c404abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pass_through&lt;/code&gt; is also enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first.</source>
          <target state="translated">경우 &lt;code&gt;pass_through&lt;/code&gt; 이 또한 활성화되어, 옵션은 둘 중 먼저 첫 번째 인식 옵션, 또는 비 - 옵션에서 종료됩니다 처리.</target>
        </trans-unit>
        <trans-unit id="9243fb188fd78661a99b6e8ffc13a07c0c193e45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and the pointer it points to is not &lt;code&gt;NULL&lt;/code&gt;, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt;). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt;, the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02b449190a1b90198a28e96aea10bbc105c7788" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-NULL and the pointer it points to is not NULL, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt; ). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; , the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;pe1&lt;/code&gt; 아닌 NULL이고 그것을 가리키는 포인터가 NULL이 아닌, 그 포인터의 최대 포인트 과거의 위치를 1 바이트로 끝 포인터로 간주됩니다 &lt;code&gt;s1&lt;/code&gt; 검사는 어떤 상황에서도 계속할 것이다 이상. (이 루틴은 UTF-8로 인코딩 된 입력 문자열의 형식이 잘못되었다고 가정합니다. 잘못된 형식의 입력으로 인해 &lt;code&gt;pe1&lt;/code&gt; 지나서 읽힐 수 있습니다 .) 이는 &lt;code&gt;l1&lt;/code&gt; 과 &lt;code&gt;pe1&lt;/code&gt; 이 모두 지정되고 &lt;code&gt;pe1&lt;/code&gt; 이 &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 보다 작 으면 , 목표까지 도달 할 수 없기 때문에 (성공적으로 주장되지 않음) 일치하지 않습니다. &lt;code&gt;s2&lt;/code&gt; 와 관련하여 &lt;code&gt;pe2&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="e5414852c94de9d937514c7b2ffd918737261abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;permute&lt;/code&gt; is enabled, this means that</source>
          <target state="translated">&lt;code&gt;permute&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="e47709e624b959c659a6f5424e397b7429bd08c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess&lt;/code&gt; and/or &lt;code&gt;normalization&lt;/code&gt; is applied, the code points of the string after them (in NFD by default) are used.</source>
          <target state="translated">경우 &lt;code&gt;preprocess&lt;/code&gt; 및 / 또는 &lt;code&gt;normalization&lt;/code&gt; 적용됩니다 (기본적으로 NFD에서) 그 후 문자열의 코드 포인트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a3e0b813ddb5c552aec4199fd49e48847ff2c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prompt()&lt;/code&gt; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting. This prevents automated processes from blocking on user input.</source>
          <target state="translated">경우 &lt;code&gt;prompt()&lt;/code&gt; 가 대화 형으로 실행되지 않고 STDIN 아무것도 또는 PERL_MM_USE_DEFAULT 환경 변수가 true로 설정되어있는 경우 $ 기본이 메시지를 표시하지 않고 사용되는이 없음을 감지합니다. 따라서 자동화 된 프로세스가 사용자 입력을 차단하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9d8185228e8e06faca877b9d0926aab5904e951a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing terminates when the first non-option is encountered.</source>
          <target state="translated">&lt;code&gt;require_order&lt;/code&gt; 가 사용 가능한 경우 , 옵션이 아닌 첫 번째 옵션이 발견되면 옵션 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec89b0e13a7db5b1125011c45839f2c6cfb36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first and all remaining arguments are passed to &lt;code&gt;@ARGV&lt;/code&gt; instead of the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present. However, if &lt;code&gt;permute&lt;/code&gt; is enabled instead, results can become confusing.</source>
          <target state="translated">&lt;code&gt;require_order&lt;/code&gt; 가 사용 가능한 경우 , 옵션 처리는 인식 할 수없는 첫 번째 옵션 또는 옵션이 아닌 옵션에서 종료되며 나머지 모든 인수는 catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;@ARGV&lt;/code&gt; 로 전달 됩니다 (있는 경우). 그러나 대신 &lt;code&gt;permute&lt;/code&gt; 를 사용하면 결과가 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e12b0dc8bb5978452519b2af8436776d186cd58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
