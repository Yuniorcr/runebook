<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="44b7c0500e40c11db7bf0e11bd6e37ab7d88c5ec" translate="yes" xml:space="preserve">
          <source>Code originally inside MM_Win32. Original author unknown.</source>
          <target state="translated">원래 MM_Win32 내부의 코드입니다. 원저자 불명</target>
        </trans-unit>
        <trans-unit id="242e717fb5b853da360c4c4e3fd5e16c899cc09d" translate="yes" xml:space="preserve">
          <source>Code tree</source>
          <target state="translated">코드 트리</target>
        </trans-unit>
        <trans-unit id="238c9390ad5966dbe9669eb0b38a5c9c564b39c3" translate="yes" xml:space="preserve">
          <source>Code which is compiled outside the compartment can choose to place variables into (or</source>
          <target state="translated">구획 외부에서 컴파일 된 코드는 변수를 (또는</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="7346b6c55ef1dd3ee635f412ba8c8fa0b34bc040" translate="yes" xml:space="preserve">
          <source>Coderef of a subroutine to call when a portion of data is received on STDERR from the executing program.</source>
          <target state="translated">STDERR에서 실행중인 프로그램으로부터 일부 데이터가 수신 될 때 호출 할 서브 루틴의 코드 참조.</target>
        </trans-unit>
        <trans-unit id="0e6272092332283344899c5d9151fdf70f8638d8" translate="yes" xml:space="preserve">
          <source>Coderef of a subroutine to call when a portion of data is received on STDOUT from the executing program.</source>
          <target state="translated">STDOUT에서 실행중인 프로그램으로부터 일부 데이터가 수신 될 때 호출 할 서브 루틴의 코드 참조.</target>
        </trans-unit>
        <trans-unit id="cc3b474bef3775734e7b035b9dfcfb4a3687ffad" translate="yes" xml:space="preserve">
          <source>Coding style is a matter of personal taste. Many people evolve their style over several years as they learn what helps them write and maintain good code. Here's one set of assorted suggestions that seem to be widely used by experienced developers:</source>
          <target state="translated">코딩 스타일은 개인적인 취향의 문제입니다. 많은 사람들이 좋은 코드를 작성하고 유지하는 데 도움이되는 것을 배우면서 몇 년 동안 자신의 스타일을 발전시킵니다. 다음은 숙련 된 개발자가 널리 사용하는 것으로 보이는 여러 가지 제안입니다.</target>
        </trans-unit>
        <trans-unit id="83c20e2b46967a4d332883ed6f06dc35bb23a9dc" translate="yes" xml:space="preserve">
          <source>Coerce the given SV to a double and return it. See &lt;code&gt;SvNVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 더블로 강제 변환하고 리턴하십시오. sv를 한 번만 평가하는 버전 은 &lt;code&gt;SvNVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b9cb8dd077ee8e9789410150752cb5df2cf59b7" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to a double and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvNV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 double로 강제 변환하고 리턴합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvNV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bac4ad8b9286fd32a256bd30b536befa1ae2a9ff" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an integer and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvIV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 정수로 강제 변환하고 반환합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvIV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4398a91485317bebc11f68b77ab6f61e17b4142" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an integer and returns it. See &lt;code&gt;SvIVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 정수로 강제 변환하고 반환합니다. sv를 한 번만 평가할 수있는 버전 은 &lt;code&gt;SvIVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7056ee3094a77bc1cd5afdf0d2f7a644af6c1de6" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an unsigned integer and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvUV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 부호없는 정수로 강제 변환하고 반환합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvUV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="796a973103d95c3243cc98edd65b34d9d2c5c67f" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an unsigned integer and returns it. See &lt;code&gt;SvUVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 부호없는 정수로 강제 변환하고 반환합니다. sv를 한 번만 평가할 수있는 버전 은 &lt;code&gt;SvUVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea772ad5805b57d6b06159ae7393c73ccddc1d9c" translate="yes" xml:space="preserve">
          <source>CollationTest_NON_IGNORABLE.txt</source>
          <target state="translated">CollationTest_NON_IGNORABLE.txt</target>
        </trans-unit>
        <trans-unit id="7b7f09f7ff55d9003bbbf6e2b6ad35cc1d55629d" translate="yes" xml:space="preserve">
          <source>CollationTest_SHIFTED.txt</source>
          <target state="translated">CollationTest_SHIFTED.txt</target>
        </trans-unit>
        <trans-unit id="ca66835bc771bd4402dea87da5941178b9bd8799" translate="yes" xml:space="preserve">
          <source>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear malloced buffer, which the caller &lt;b&gt;must&lt;/b&gt; Perl_free_c_backtrace().</source>
          <target state="translated">역 추적 (일명 &quot;스택 트레이스&quot;)을 단일 선형 malloced 버퍼로 수집합니다.이 버퍼는 호출자 &lt;b&gt;가&lt;/b&gt; Perl_free_c_backtrace () &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e2794035cca1617a1f9360d576b9e234bb68e64d" translate="yes" xml:space="preserve">
          <source>Color for debugging messages?</source>
          <target state="translated">메시지 디버깅을위한 색상?</target>
        </trans-unit>
        <trans-unit id="931d4698b17a59cb56194fcf346f0e3466642612" translate="yes" xml:space="preserve">
          <source>Color for normal output?</source>
          <target state="translated">정상적인 출력을위한 색상?</target>
        </trans-unit>
        <trans-unit id="943c85b3de9955c182721971471df60c6005726b" translate="yes" xml:space="preserve">
          <source>Color for warnings?</source>
          <target state="translated">경고 색상?</target>
        </trans-unit>
        <trans-unit id="37277b98a26979971b3578b4784f262eaebdf1a4" translate="yes" xml:space="preserve">
          <source>Color screen output using ANSI escape sequences</source>
          <target state="translated">ANSI 이스케이프 시퀀스를 사용한 컬러 화면 출력</target>
        </trans-unit>
        <trans-unit id="814253eeac185847ba47c5faad82c62ef62cc160" translate="yes" xml:space="preserve">
          <source>Color support requires &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; on Unix-like platforms and &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; on windows. If the necessary module is not installed colored output will not be available.</source>
          <target state="translated">색상을 지원하려면 Unix와 유사한 플랫폼에서 &lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 가 필요 하고 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Windows에서는 Win32 :: Console이&lt;/a&gt; 필요합니다. 필요한 모듈이 설치되어 있지 않으면 컬러 출력을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="303879dcc89284b00c097930cabcb85cc2dc5e5d" translate="yes" xml:space="preserve">
          <source>Colored Test Output</source>
          <target state="translated">컬러 테스트 출력</target>
        </trans-unit>
        <trans-unit id="8864b43824503a2f85bf0964b2768f6f871f7626" translate="yes" xml:space="preserve">
          <source>Colored test output using &lt;a href=&quot;tap/formatter/color&quot;&gt;TAP::Formatter::Color&lt;/a&gt; is the default, but if output is not to a terminal, color is disabled. You can override this by adding the &lt;code&gt;--color&lt;/code&gt; switch.</source>
          <target state="translated">&lt;a href=&quot;tap/formatter/color&quot;&gt;TAP :: Formatter :: Color를&lt;/a&gt; 사용하는 컬러 테스트 출력 이 기본값이지만 출력이 터미널로 출력되지 않으면 컬러가 비활성화됩니다. &lt;code&gt;--color&lt;/code&gt; 스위치 를 추가하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3923712e15f6cde93b49aa53ec44f5c8d09bcfff" translate="yes" xml:space="preserve">
          <source>Combination of perl's malloc() and rigid DLL name resolution creates a special problem with library functions which expect their return value to be free()d by system's free(). To facilitate extensions which need to call such functions, system memory-allocation functions are still available with the prefix &lt;code&gt;emx_&lt;/code&gt; added. (Currently only DLL perl has this, it should propagate to</source>
          <target state="translated">perl의 malloc ()과 엄격한 DLL 이름 확인의 조합은 시스템의 free ()에 의해 반환 값이 free ()가 될 것으로 기대하는 라이브러리 함수에 특별한 문제를 만듭니다. 이러한 함수를 호출해야하는 확장을 용이하게하기 위해 접두어 &lt;code&gt;emx_&lt;/code&gt; 를 추가 하여 시스템 메모리 할당 기능을 계속 사용할 수 있습니다 . (현재 DLL perl만이 이것을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4084d48b233ef3ed460fe34c2d006a3d174500e" translate="yes" xml:space="preserve">
          <source>Combining RE Pieces</source>
          <target state="translated">RE 조각 결합</target>
        </trans-unit>
        <trans-unit id="d5245a49f5313d2490851a0af63ee29dbcb57fb2" translate="yes" xml:space="preserve">
          <source>Combining that form with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and putting parentheses immediately around a hash are forbidden (because it is not clear what they should do):</source>
          <target state="translated">해당 형식을 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 과 결합하고 괄호를 해시 주위에 두는 것은 금지되어 있습니다 (왜냐하면 무엇을 해야하는지 명확하지 않기 때문입니다).</target>
        </trans-unit>
        <trans-unit id="763921651d0da6d3a3be0284d4211879873417fe" translate="yes" xml:space="preserve">
          <source>Combining two pack codes with a slash (&lt;code&gt;/&lt;/code&gt;) associates them with a single value from the argument list. In &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the length of the argument is taken and packed according to the first code while the argument itself is added after being converted with the template code after the slash. This saves us the trouble of inserting the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; call, but it is in &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; where we really score: The value of the length byte marks the end of the string to be taken from the buffer. Since this combination doesn't make sense except when the second pack code isn't &lt;code&gt;a*&lt;/code&gt; , &lt;code&gt;A*&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; , Perl won't let you.</source>
          <target state="translated">두 팩 코드를 슬래시 ( &lt;code&gt;/&lt;/code&gt; )와 결합하면 인수 목록에서 단일 값과 연관됩니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 에서는 인수의 길이가 첫 번째 코드에 따라 채워지고 압축되며 인수 자체는 슬래시 후 템플리트 코드로 변환 된 후 추가됩니다. 이것은 우리에게 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 호출 을 삽입하는 수고를 덜어 주지만 우리가 실제로 점수를 매기는 곳의 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; . 길이 바이트 값은 버퍼에서 가져올 문자열의 끝을 나타냅니다. 이 조합은 두 번째 팩 코드가 &lt;code&gt;a*&lt;/code&gt; , &lt;code&gt;A*&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; 가 아닌 경우를 제외하고는 의미가 없으므로 Perl에서는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32bae387055126d95306c7bb6532b73268f5a2d5" translate="yes" xml:space="preserve">
          <source>Comma Operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="62802cbe492e03ca981781cca641adb33725f540" translate="yes" xml:space="preserve">
          <source>Command Line Options, an Introduction</source>
          <target state="translated">명령 줄 옵션, 소개</target>
        </trans-unit>
        <trans-unit id="18beb4c43cfe79cec6e126626aa3ad7fd190e477" translate="yes" xml:space="preserve">
          <source>Command Paragraph</source>
          <target state="translated">명령 단락</target>
        </trans-unit>
        <trans-unit id="417187d63fa0def34d24b8c333083506dc32200a" translate="yes" xml:space="preserve">
          <source>Command Switches</source>
          <target state="translated">명령 스위치</target>
        </trans-unit>
        <trans-unit id="f6fe35e209171bf42b301a97ecb399ad5a56cfaf" translate="yes" xml:space="preserve">
          <source>Command line</source>
          <target state="translated">커맨드 라인</target>
        </trans-unit>
        <trans-unit id="12f9d6c76aaded8fe20cb1cb15944fff0ce754c0" translate="yes" xml:space="preserve">
          <source>Command line operated programs traditionally take their arguments from the command line, for example filenames or other information that the program needs to know. Besides arguments, these programs often take command line</source>
          <target state="translated">명령 행 운영 프로그램은 전통적으로 명령 행에서 인수를 가져옵니다 (예 : 파일 이름 또는 프로그램이 알아야하는 기타 정보). 인수 외에도 이러한 프로그램은 종종 명령 행을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="97c3aa97cab34b4855e7892644f3277edc0d033f" translate="yes" xml:space="preserve">
          <source>Command line options come in several flavours. Historically, they are preceded by a single dash &lt;code&gt;-&lt;/code&gt; , and consist of a single letter.</source>
          <target state="translated">커맨드 라인 옵션은 여러 가지 맛이 있습니다. 역사적으로, 앞에는 단일 대시 ( &lt;code&gt;-&lt;/code&gt; )가 있고 단일 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee51dd0beb8fe1eba61df99e777a8a7fdc630b8" translate="yes" xml:space="preserve">
          <source>Command line options used by &lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt; , and thus by &lt;code&gt;WriteMakefile()&lt;/code&gt; . The string is split as the shell would, and the result is processed before any actual command line arguments are processed.</source>
          <target state="translated">&lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt; 및 &lt;code&gt;WriteMakefile()&lt;/code&gt; 의해 사용되는 명령 행 옵션 . 문자열은 쉘처럼 분할되고 결과는 실제 명령 행 인수가 처리되기 전에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="774ba146a62c9c3ff46ff9cc5455b08807e03827" translate="yes" xml:space="preserve">
          <source>Command line switches</source>
          <target state="translated">커맨드 라인 스위치</target>
        </trans-unit>
        <trans-unit id="878211c78a67be0fed3e28b560c4cca71216618c" translate="yes" xml:space="preserve">
          <source>Command names versus file pathnames</source>
          <target state="translated">명령 이름과 파일 경로 이름</target>
        </trans-unit>
        <trans-unit id="f1032cc2ac5d43d9d5d41261914fc29d43686b3f" translate="yes" xml:space="preserve">
          <source>Command so make does not print the literal commands it's running.</source>
          <target state="translated">따라서 make 명령은 실행중인 리터럴 명령을 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c37e3809f3281c8c25395b17b26a434eb5f38e1" translate="yes" xml:space="preserve">
          <source>Command-interpreters on non-Unix systems have rather different ideas on quoting than Unix shells. You'll need to learn the special characters in your command-interpreter (&lt;code&gt;*&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are common) and how to protect whitespace and these characters to run one-liners (see &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; below).</source>
          <target state="translated">비 유닉스 시스템의 명령 해석기는 Unix 쉘과는 다른 인용 방식을 가지고 있습니다. 명령 해석기의 특수 문자 ( &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 는 일반적 임)와 공백을 보호하고 이러한 문자를 보호하여 한 줄짜리 문자를 실행하는 방법 (아래 &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; 참조)을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f2498f5306d2ed5cdf02e78b8fd02f5090806ac" translate="yes" xml:space="preserve">
          <source>Command-line options (switches). Switches in this variable are treated as if they were on every Perl command line. Only the &lt;b&gt;-[CDIMUdmtwW]&lt;/b&gt; switches are allowed. When running taint checks (either because the program was running setuid or setgid, or because the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was used), this variable is ignored. If PERL5OPT begins with &lt;b&gt;-T&lt;/b&gt;, tainting will be enabled and subsequent options ignored. If PERL5OPT begins with &lt;b&gt;-t&lt;/b&gt;, tainting will be enabled, a writable dot removed from @INC, and subsequent options honored.</source>
          <target state="translated">명령 줄 옵션 (스위치). 이 변수의 스위치는 마치 모든 Perl 명령 행에있는 것처럼 취급됩니다. 만 &lt;b&gt;- [CDIMUdmtwW]&lt;/b&gt; 스위치는 허용된다. 프로그램이 setuid 또는 setgid를 실행 중이거나 &lt;b&gt;-T&lt;/b&gt; 또는 &lt;b&gt;-t&lt;/b&gt; 스위치를 사용 했기 때문에 오염 검사를 실행할 때이 변수는 무시됩니다. PERL5OPT가 &lt;b&gt;-T로&lt;/b&gt; 시작하면 오염이 활성화되고 후속 옵션은 무시됩니다. PERL5OPT가 &lt;b&gt;-t로&lt;/b&gt; 시작하면 오염이 활성화되고 쓰기 가능한 점이 @INC에서 제거되고 후속 옵션이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f3e177b917fb27cf84346755d918af92a7cfb2b" translate="yes" xml:space="preserve">
          <source>Commands for the MM's to use in Makefiles</source>
          <target state="translated">MM이 Makefile에서 사용할 명령</target>
        </trans-unit>
        <trans-unit id="2312e47cb85161c64e509845981fc1af27401c37" translate="yes" xml:space="preserve">
          <source>Commands that launch external processes are generally supported on most platforms (though many of them do not support any type of forking). The problem with using them arises from what you invoke them on. External tools are often named differently on different platforms, may not be available in the same location, might accept different arguments, can behave differently, and often present their results in a platform-dependent way. Thus, you should seldom depend on them to produce consistent results. (Then again, if you're calling</source>
          <target state="translated">외부 프로세스를 시작하는 명령은 일반적으로 대부분의 플랫폼에서 지원됩니다 (많은 유형의 포크는 지원하지 않습니다). 그것들을 사용할 때의 문제는 당신이 그것들을 불러내는 것에서 발생합니다. 외부 도구는 종종 다른 플랫폼에서 다르게 이름이 지정되고, 동일한 위치에서 사용 가능하지 않을 수 있으며, 다른 인수를 허용하고, 다르게 동작 할 수 있으며, 결과를 플랫폼에 따라 다르게 표시 할 수 있습니다. 따라서 일관된 결과를 얻기 위해 그들에 의존하지 않아야합니다. (그러면 다시 전화하면</target>
        </trans-unit>
        <trans-unit id="3f11f6a37b2bb1f46ae24400fbbec0133765dee3" translate="yes" xml:space="preserve">
          <source>Comment result token.</source>
          <target state="translated">댓글 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="33cd8b27d6e79d80d7f00dae59eedee6f870da21" translate="yes" xml:space="preserve">
          <source>Comment, suggestions, and patches welcome.</source>
          <target state="translated">의견, 제안 및 패치를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="a6b602c915283ace9dfdb4567ddd955a24271e51" translate="yes" xml:space="preserve">
          <source>Comments begin with &quot;#&quot;, not &quot;/*&quot; or &quot;//&quot;. Perl may interpret C/C++ comments as division operators, unterminated regular expressions or the defined-or operator.</source>
          <target state="translated">주석은 &quot;/ *&quot;또는 &quot;//&quot;가 아닌 &quot;#&quot;으로 시작합니다. Perl은 C / C ++ 주석을 나누기 연산자, 종결되지 않은 정규 표현식 또는 정의 된 연산자로 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a11c5627026c5647a98241784b981e03eeba67" translate="yes" xml:space="preserve">
          <source>Comments can be added to XSUBs by placing a &lt;code&gt;#&lt;/code&gt; as the first non-whitespace of a line. Care should be taken to avoid making the comment look like a C preprocessor directive, lest it be interpreted as such. The simplest way to prevent this is to put whitespace in front of the &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 을 줄의 첫 번째 비 공백으로 배치하여 주석을 XSUB에 추가 할 수 있습니다 . 주석이 C 프리 프로세서 지시문처럼 보이게하지 않도록주의해야합니다. 이를 방지하는 가장 간단한 방법은 &lt;code&gt;#&lt;/code&gt; 앞에 공백을 두는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d3573b55c22b5f8d93f519ce02a5ac87f75d58f1" translate="yes" xml:space="preserve">
          <source>Comments can be embedded in a TEMPLATE using &lt;code&gt;#&lt;/code&gt; through the end of line. White space can separate pack codes from each other, but modifiers and repeat counts must follow immediately. Breaking complex templates into individual line-by-line components, suitably annotated, can do as much to improve legibility and maintainability of pack/unpack formats as &lt;code&gt;/x&lt;/code&gt; can for complicated pattern matches.</source>
          <target state="translated">줄 끝까지 &lt;code&gt;#&lt;/code&gt; 을 사용하여 주석을 TEMPLATE에 삽입 할 수 있습니다 . 공백은 팩 코드를 서로 분리 할 수 ​​있지만 수정 자와 반복 횟수는 즉시 따라야합니다. 복잡한 템플릿을 개별 라인 단위 구성 요소로 나누고 적절하게 주석을 달면 복잡한 패턴 일치를 위해 &lt;code&gt;/x&lt;/code&gt; 가 할 수있는 것처럼 팩 / 포장 해제 형식의 가독성과 유지 관리 성을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a223d578e07988c8679c590eaf92f0323e14f" translate="yes" xml:space="preserve">
          <source>Comments on this feature are welcome; send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">이 기능에 대한 의견은 환영합니다. &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 로 이메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="66bf0dd35fe077bd96ea49557abe1254cfe3d453" translate="yes" xml:space="preserve">
          <source>Comments start with a hash symbol and run to the end of the line</source>
          <target state="translated">주석은 해시 기호로 시작하여 줄 끝까지 이어집니다.</target>
        </trans-unit>
        <trans-unit id="a0809fab0f6e5f47cada9e750c63afe1aea71d14" translate="yes" xml:space="preserve">
          <source>Comments, Comments, Comments</source>
          <target state="translated">의견, 의견, 의견</target>
        </trans-unit>
        <trans-unit id="a635957687d394ed8eb32dd7af4e9fb9ea45ae9c" translate="yes" xml:space="preserve">
          <source>Commit message</source>
          <target state="translated">커밋 메시지</target>
        </trans-unit>
        <trans-unit id="bf8186840565d9d31b1a177074576c6626b1a28e" translate="yes" xml:space="preserve">
          <source>Committing your work will save the change</source>
          <target state="translated">작업을 커밋하면 변경 사항이 저장됩니다</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="0160caed21fbd46d3db9b1e56d4701e45dadedf1" translate="yes" xml:space="preserve">
          <source>Common encodings recognized by ISO, MIME, IANA, and various other standardisation organisations are recognised; for a more detailed list see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">ISO, MIME, IANA 및 기타 다양한 표준화 기관에서 인정하는 공통 인코딩이 인식됩니다. 자세한 목록은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9506633a3b0fc3eabffeede071b59b13423caf84" translate="yes" xml:space="preserve">
          <source>Common errors and problems</source>
          <target state="translated">일반적인 오류 및 문제</target>
        </trans-unit>
        <trans-unit id="3710bbf841f5662d9076f286b3544953fd32bcdf" translate="yes" xml:space="preserve">
          <source>Common type methods</source>
          <target state="translated">일반적인 유형 방법</target>
        </trans-unit>
        <trans-unit id="e8a9217a7a2833f7343523310e0806117cb02577" translate="yes" xml:space="preserve">
          <source>Compare 8-bit scalar data according to the current locale</source>
          <target state="translated">현재 로케일에 따라 8 비트 스칼라 데이터 비교</target>
        </trans-unit>
        <trans-unit id="e77e2932b456b90db814e0a4de05c60e78fca296" translate="yes" xml:space="preserve">
          <source>Compare C</source>
          <target state="translated">C 비교</target>
        </trans-unit>
        <trans-unit id="9608a3eba277fa15d97bc5d85ad1fc9cb0be2844" translate="yes" xml:space="preserve">
          <source>Compare OBJ1 and OBJ2 and return -1, 0, or 1, if OBJ1 is less than, equal to, or larger than OBJ2, respectively.</source>
          <target state="translated">OBJ1과 OBJ2를 비교하고 OBJ1이 각각 OBJ2보다 작거나 같거나 큰 경우 -1, 0 또는 1을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5ea95d1f886daac818a31006775ac3fb0265210d" translate="yes" xml:space="preserve">
          <source>Compare files or filehandles</source>
          <target state="translated">파일 또는 파일 핸들 비교</target>
        </trans-unit>
        <trans-unit id="c8f1d71cf0a936dd7f0500caee4610cd7b62576a" translate="yes" xml:space="preserve">
          <source>Compare the following to the examples in &lt;code&gt;(*PRUNE)&lt;/code&gt; ; note the string is twice as long:</source>
          <target state="translated">다음을 &lt;code&gt;(*PRUNE)&lt;/code&gt; 의 예제와 비교하십시오 . 문자열의 길이가 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="69ddd15b8d251ac3138eb554c808b81fba8e3f77" translate="yes" xml:space="preserve">
          <source>Compare this code that uses an arbitrary ID...</source>
          <target state="translated">임의의 ID를 사용하는이 코드를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="d12d96005a498c4cadff6daa5f0a0e574ae4acad" translate="yes" xml:space="preserve">
          <source>Compare this to:</source>
          <target state="translated">이것을 다음과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="7f18e1a8f5bc872f75eec509b3be6157fc03fc7a" translate="yes" xml:space="preserve">
          <source>Compare this with a similar but locale-aware program:</source>
          <target state="translated">이것을 비슷하지만 로케일 인식 프로그램과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="777b2f3ef1bbfb2e49e5cc0c311dce3b665b3d34" translate="yes" xml:space="preserve">
          <source>Compare this with the characters that you see and their order if you state explicitly that the locale should be ignored:</source>
          <target state="translated">로케일을 무시해야한다고 명시 적으로 표시 한 경우이 문자와 표시 순서를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="8989d48e5efe1cfe0a91400d8b896a2d5b0f2ac0" translate="yes" xml:space="preserve">
          <source>Compares $x with $y and takes the sign into account. Returns -1, 0, 1 or undef.</source>
          <target state="translated">$ x와 $ y를 비교하고 부호를 고려합니다. -1, 0, 1 또는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7080fdc780e08e244284eff667294f04737c6d6a" translate="yes" xml:space="preserve">
          <source>Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.</source>
          <target state="translated">부호를 무시하고 $ x와 $ y를 비교합니다. -1, 0, 1 또는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb939a704fb32544966548a9a5549dad34ca8481" translate="yes" xml:space="preserve">
          <source>Compares the sequence of characters (stored as octets) in &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;blen&lt;/code&gt; with the sequence of characters (stored as UTF-8) in &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;ulen&lt;/code&gt; . Returns 0 if they are equal, -1 or -2 if the first string is less than the second string, +1 or +2 if the first string is greater than the second string.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , &lt;code&gt;blen&lt;/code&gt; 의 문자 시퀀스 (옥텟으로 저장)를 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;ulen&lt;/code&gt; 의 문자 시퀀스 (UTF-8로 저장)와 비교 합니다. 같으면 0, 첫 번째 문자열이 두 번째 문자열보다 작 ​​으면 -1 또는 -2를, 첫 번째 문자열이 두 번째 문자열보다 큰 경우 +1 또는 +2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20da491304f6c81eaa643ddf1af11a10dab08b5e" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and 'use bytes' aware and will coerce its args to strings if necessary. If the flags contain SV_GMAGIC, it handles get magic. See also &lt;code&gt;sv_cmp_flags&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 로케일 인식 방식으로 비교합니다. UTF-8이며 '바이트 사용'을 인식하고 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 SV_GMAGIC이 포함되어 있으면 마술을 처리합니다. &lt;code&gt;sv_cmp_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14038da5801f25b5039c66301e98f0e246769198" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and 'use bytes' aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;sv_cmp&lt;/code&gt; .</source>
          <target state="translated">로케일 인식 방식으로 두 SV의 문자열을 비교합니다. UTF-8 및 '바이트 사용'을 인식하고, 핸들은 마술을 얻고, 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;sv_cmp&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="810a90ac09960b8d41b487c729062ca1467528ef" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt; . Is UTF-8 and 'use bytes' aware and will coerce its args to strings if necessary. If the flags include SV_GMAGIC, it handles get magic. See also &lt;code&gt;sv_cmp_locale_flags&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 다음의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 반환 합니다. &lt;code&gt;sv2&lt;/code&gt; 리턴 합니다. UTF-8이며 '바이트 사용'을 인식하고 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 SV_GMAGIC이 포함되면 마술을 처리합니다. &lt;code&gt;sv_cmp_locale_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41ea1ccdf864f6da3ab35b8196aaf20a51353014" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt; . Is UTF-8 and 'use bytes' aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;sv_cmp_locale&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 &lt;code&gt;sv2&lt;/code&gt; 의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 리턴합니다. 합니다. UTF-8 및 '바이트 사용'을 인식하고, 핸들은 마술을 얻고, 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;sv_cmp_locale&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b4ac967a48ac38926d5bd3b00ae02344f0ba5c7" translate="yes" xml:space="preserve">
          <source>Comparing and sorting by locale is usually slower than the default sorting; slow-downs of two to four times have been observed. It will also consume more memory: once a Perl scalar variable has participated in any string comparison or sorting operation obeying the locale collation rules, it will take 3-15 times more memory than before. (The exact multiplier depends on the string's contents, the operating system and the locale.) These downsides are dictated more by the operating system's implementation of the locale system than by Perl.</source>
          <target state="translated">로케일별로 비교하고 정렬하는 것은 일반적으로 기본 정렬보다 느립니다. 2 ~ 4 배의 감속이 관찰되었습니다. 또한 더 많은 메모리를 소비합니다. Perl 스칼라 변수가 로케일 데이터 정렬 규칙을 따르는 문자열 비교 또는 정렬 작업에 참여하면 이전보다 3-15 배 더 많은 메모리가 필요합니다. (정확한 승수는 문자열의 내용, 운영 체제 및 로케일에 따라 다릅니다.) 이러한 단점은 Perl이 아닌 운영 체제의 로케일 시스템 구현에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0a71bcc03489928ee6825a22ad30e52059487a" translate="yes" xml:space="preserve">
          <source>Comparing eval'd strings with code references will give you inaccurate results: a code reference will show a slightly slower execution time than the equivalent eval'd string.</source>
          <target state="translated">eval의 문자열을 코드 참조와 비교하면 결과가 부정확합니다. 코드 참조는 동일한 eval의 문자열보다 실행 시간이 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="07ac02349f220b342a1d6f35982d496f173f647a" translate="yes" xml:space="preserve">
          <source>Comparing or matching a string case-insensitively. In Perl, it is implemented with the &lt;code&gt;/i&lt;/code&gt; pattern modifier, the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function, and the &lt;code&gt;\F&lt;/code&gt; double-quote translation escape.</source>
          <target state="translated">대소 문자를 구분하지 않고 문자열 비교 또는 일치 Perl에서는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정 자, &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 함수 및 &lt;code&gt;\F&lt;/code&gt; 큰 따옴표 변환 이스케이프로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="80c2dde455c2c05f663d3e4f08b51ffa85278453" translate="yes" xml:space="preserve">
          <source>Compatibility functions:</source>
          <target state="translated">호환성 기능 :</target>
        </trans-unit>
        <trans-unit id="5b943666a01e98d02ba66c24633566eaaa275c3f" translate="yes" xml:space="preserve">
          <source>Compatibility with Unix compress/uncompress.</source>
          <target state="translated">유닉스 압축 / 압축 해제와의 호환성.</target>
        </trans-unit>
        <trans-unit id="aad755de429541e8ec1db943cf4102247f2bb5d3" translate="yes" xml:space="preserve">
          <source>Compilation</source>
          <target state="translated">Compilation</target>
        </trans-unit>
        <trans-unit id="61222b08840c5d756903ba61f2c94b08f72f00f1" translate="yes" xml:space="preserve">
          <source>Compilation errors will tell you the line number of the error, with an indication of the next token or token type that was to be examined. (In a script passed to Perl via &lt;b&gt;-e&lt;/b&gt; switches, each &lt;b&gt;-e&lt;/b&gt; is counted as one line.)</source>
          <target state="translated">컴파일 오류는 검사 할 다음 토큰 또는 토큰 유형을 표시하여 오류의 줄 번호를 알려줍니다. ( &lt;b&gt;-e&lt;/b&gt; 스위치 를 통해 Perl에 전달 된 스크립트 에서 각 &lt;b&gt;-e&lt;/b&gt; 는 한 줄로 계산됩니다.)</target>
        </trans-unit>
        <trans-unit id="acc9cabc1ceec333d13d3b9abb6ebf9a6c73a5f8" translate="yes" xml:space="preserve">
          <source>Compilation problems</source>
          <target state="translated">컴파일 문제</target>
        </trans-unit>
        <trans-unit id="e55924dc0dada3b1eb85a06e699cc43d910428cf" translate="yes" xml:space="preserve">
          <source>Compilation starts with &lt;code&gt;pregcomp()&lt;/code&gt; , which is mostly an initialisation wrapper which farms work out to two other routines for the heavy lifting: the first is &lt;code&gt;reg()&lt;/code&gt; , which is the start point for parsing; the second, &lt;code&gt;study_chunk()&lt;/code&gt; , is responsible for optimisation.</source>
          <target state="translated">컴파일은 &lt;code&gt;pregcomp()&lt;/code&gt; 시작합니다. pregcomp () 는 대부분 농장이 무거운 리프팅을 위해 두 가지 다른 루틴으로 작동하는 초기화 래퍼입니다. 첫 번째는 구문 분석의 시작점 인 &lt;code&gt;reg()&lt;/code&gt; . 두 번째, &lt;code&gt;study_chunk()&lt;/code&gt; 는 최적화를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="44ff6f247296e1f189e3389d776ef21cc85aecb1" translate="yes" xml:space="preserve">
          <source>Compile and execute code in restricted compartments</source>
          <target state="translated">제한된 구획에서 코드 컴파일 및 실행</target>
        </trans-unit>
        <trans-unit id="7d8b71307540ad88b5ce354792888a1fa8ac7b97" translate="yes" xml:space="preserve">
          <source>Compile and link C code for Perl modules</source>
          <target state="translated">Perl 모듈을위한 C 코드 컴파일 및 링크</target>
        </trans-unit>
        <trans-unit id="b5228203f0e6f671c5f4f6a9e10132ab1a69d71c" translate="yes" xml:space="preserve">
          <source>Compile and run:</source>
          <target state="translated">컴파일하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="527a73f377cb4327fd734d48795ab96620ea39d0" translate="yes" xml:space="preserve">
          <source>Compile as usual:</source>
          <target state="translated">평소와 같이 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="cdeeb661a0937ab7ad6e505a38d072a24f8b1609" translate="yes" xml:space="preserve">
          <source>Compile pass 1: check routines</source>
          <target state="translated">컴파일 패스 1 : 루틴 점검</target>
        </trans-unit>
        <trans-unit id="ad1d375b3a209f1d8455aec99a7200242837c043" translate="yes" xml:space="preserve">
          <source>Compile pass 1a: constant folding</source>
          <target state="translated">패스 1a 컴파일 : 일정한 폴딩</target>
        </trans-unit>
        <trans-unit id="7161db3a41fd5c2db89e47b0432b3cd9aaab4ad8" translate="yes" xml:space="preserve">
          <source>Compile pass 2: context propagation</source>
          <target state="translated">컴파일 패스 2 : 컨텍스트 전파</target>
        </trans-unit>
        <trans-unit id="87a46269fcd4885277b1fc9babaffbe09e6ff612" translate="yes" xml:space="preserve">
          <source>Compile pass 3: peephole optimization</source>
          <target state="translated">컴파일 패스 3 : 구멍 최적화</target>
        </trans-unit>
        <trans-unit id="8ca3fba27b3ae96fd6b344a588412c93d138dee1" translate="yes" xml:space="preserve">
          <source>Compile perl and extensions sources with AddressSanitizer.</source>
          <target state="translated">AddressSanitizer를 사용하여 perl 및 확장 소스를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="e9f217dff0c1cb84ca4c53ebcecee0f4ba366dbb" translate="yes" xml:space="preserve">
          <source>Compile the pattern stored in &lt;code&gt;pattern&lt;/code&gt; using the given &lt;code&gt;flags&lt;/code&gt; and return a pointer to a prepared &lt;code&gt;REGEXP&lt;/code&gt; structure that can perform the match. See &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;The REGEXP structure&lt;/a&gt; below for an explanation of the individual fields in the REGEXP struct.</source>
          <target state="translated">저장된 패턴 컴파일 &lt;code&gt;pattern&lt;/code&gt; 주어진 사용 &lt;code&gt;flags&lt;/code&gt; 및 제조에 대한 포인터를 리턴 &lt;code&gt;REGEXP&lt;/code&gt; 의 경기를 수행 할 수있는 구조. &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;REGEXP 구조를&lt;/a&gt; 참조하십시오 의 개별 필드에 대한 설명은 아래 .</target>
        </trans-unit>
        <trans-unit id="52c41fd78e57b0ea9c7edd279f09324e8febcf36" translate="yes" xml:space="preserve">
          <source>Compile this wrapper into a binary executable and then make</source>
          <target state="translated">이 래퍼를 이진 실행 파일로 컴파일 한 다음</target>
        </trans-unit>
        <trans-unit id="5e2892ae20c461e25a70a7b9ce2cc0ca3e806286" translate="yes" xml:space="preserve">
          <source>Compile-time Output</source>
          <target state="translated">컴파일 타임 출력</target>
        </trans-unit>
        <trans-unit id="316b6940ee7ff98d0c91d6eed52347ec98e1cebd" translate="yes" xml:space="preserve">
          <source>Compile-time class fields</source>
          <target state="translated">컴파일 타임 클래스 필드</target>
        </trans-unit>
        <trans-unit id="b224a19e379a66e5216e1e3a4c23fb529c4ffd00" translate="yes" xml:space="preserve">
          <source>Compile-time options</source>
          <target state="translated">컴파일 타임 옵션</target>
        </trans-unit>
        <trans-unit id="f6133097eb347671ef54899d886f2ecc59f839b5" translate="yes" xml:space="preserve">
          <source>Compile-time scope hooks</source>
          <target state="translated">컴파일 시간 범위 후크</target>
        </trans-unit>
        <trans-unit id="9a1874d143fe11d6c914d3925623b8d4023c98fe" translate="yes" xml:space="preserve">
          <source>Compiled Encodings</source>
          <target state="translated">컴파일 된 인코딩</target>
        </trans-unit>
        <trans-unit id="1d37a3ea5df0706c7c9b42fdc4c2ef0fe0a0aa99" translate="yes" xml:space="preserve">
          <source>Compiled code</source>
          <target state="translated">컴파일 된 코드</target>
        </trans-unit>
        <trans-unit id="5c415c80469833c9cf270c47e731b8c7453f9dbd" translate="yes" xml:space="preserve">
          <source>Compiled program. Inlined into the structure so the entire struct can be treated as a single blob.</source>
          <target state="translated">컴파일 된 프로그램. 구조에 인라인되어 전체 구조체를 단일 얼룩으로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="208f16ae59394d8539a13277bb3ef361462a3b2b" translate="yes" xml:space="preserve">
          <source>Compiler and Related Tools on Solaris.</source>
          <target state="translated">Solaris의 컴파일러 및 관련 도구</target>
        </trans-unit>
        <trans-unit id="34f24cbbea7db0e43a9c0993c8373a846789f46b" translate="yes" xml:space="preserve">
          <source>Compiles a C source file and produces an object file. The name of the object file is returned. The source file is specified in a &lt;code&gt;source&lt;/code&gt; parameter, which is required; the other parameters listed below are optional.</source>
          <target state="translated">C 소스 파일을 컴파일하고 오브젝트 파일을 생성합니다. 오브젝트 파일의 이름이 리턴됩니다. 소스 파일은 &lt;code&gt;source&lt;/code&gt; 매개 변수에 지정되며 필수입니다. 아래에 나열된 다른 매개 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e24918face3ac9c1b717001b232debfe6ee36a5c" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on AIX</source>
          <target state="translated">AIX에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="c22ae861a5bf3dbdbae654f91cbd81651f885935" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on AIX 7.1.0</source>
          <target state="translated">AIX 7.1.0에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="9c229fda73fdbf38e74af7c957910e2ab6e8ac38" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on HP-UX</source>
          <target state="translated">HP-UX에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="4367b922eaae098fdd83c24f81fe1e73e3dcc108" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on Tru64</source>
          <target state="translated">Tru64에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="0ab72b58debfaa78bed9b0dabffd26a67134a0a0" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on older AIX versions up to 4.3.3</source>
          <target state="translated">최대 4.3.3 이전 AIX 버전에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="b9b693c192dd1710f2e9e413a10dac38987acc04" translate="yes" xml:space="preserve">
          <source>Compiling Perl for OS/400 PASE</source>
          <target state="translated">OS / 400 PASE 용 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="89c4a07bdd1b063c8640e5cb7f79fc20fab27cc4" translate="yes" xml:space="preserve">
          <source>Compiling Perl on BS2000</source>
          <target state="translated">BS2000에서 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="7f945a02f351065a45ab543615ac08775ab27ccb" translate="yes" xml:space="preserve">
          <source>Compiling Perl on Symbian</source>
          <target state="translated">Symbian에서 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="cea78e017dd3458f4890e6e74a3e6990888adbfd" translate="yes" xml:space="preserve">
          <source>Compiling and saving regular expressions</source>
          <target state="translated">정규식 컴파일 및 저장</target>
        </trans-unit>
        <trans-unit id="73da9444429f3393b9a36999cf3b31965029c0e7" translate="yes" xml:space="preserve">
          <source>Compiling with threading (-Duseithreads) completely rewrites the function prototypes of Perl. You better try your changes with that. Related to this is the difference between &quot;Perl_-less&quot; and &quot;Perl_-ly&quot; APIs, for example:</source>
          <target state="translated">스레딩 (-Duseithreads)으로 컴파일하면 Perl의 함수 프로토 타입이 완전히 다시 작성됩니다. 그것으로 변경을 시도하는 것이 좋습니다. 이와 관련하여 &quot;Perl_-less&quot;및 &quot;Perl_-ly&quot;API의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce33e80de717ad8f29fa7b0d95b6100971d4a1f5" translate="yes" xml:space="preserve">
          <source>Compiling your C program</source>
          <target state="translated">C 프로그램 컴파일</target>
        </trans-unit>
        <trans-unit id="4a85048775fa0a61ab607374e9f2ae3d47a74e50" translate="yes" xml:space="preserve">
          <source>Complete Dissociation of Child from Parent</source>
          <target state="translated">부모로부터 자녀의 완전한 분리</target>
        </trans-unit>
        <trans-unit id="c18b6d49a703c470c73b112b479a086dc7896837" translate="yes" xml:space="preserve">
          <source>Complete applications rarely belong in the Perl Module Library.</source>
          <target state="translated">완전한 애플리케이션은 거의 Perl 모듈 라이브러리에 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74c1508ef341d68c6231bb4d7d525101aab30f53" translate="yes" xml:space="preserve">
          <source>Complex data structures</source>
          <target state="translated">복잡한 데이터 구조</target>
        </trans-unit>
        <trans-unit id="ffe6248574dae7c5af853909dcd998ffa5a77c65" translate="yes" xml:space="preserve">
          <source>Complex numbers and associated mathematical functions</source>
          <target state="translated">복소수 및 관련 수학 함수</target>
        </trans-unit>
        <trans-unit id="cc43311382c470cc090f7797edbba8e531a9d677" translate="yes" xml:space="preserve">
          <source>Complex numbers are numbers that have both a real part and an imaginary part, and are usually noted:</source>
          <target state="translated">복소수는 실수 부와 허수 부를 모두 갖는 숫자이며 일반적으로 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="48b933ad5b59e3f82ebc999f039fd64112dc79e5" translate="yes" xml:space="preserve">
          <source>Compliant parsers must not treat &quot;-&amp;gt;&quot; as special.</source>
          <target state="translated">호환 파서는 &quot;-&amp;gt;&quot;를 특별하게 취급해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e13848c14cd38c0bce075ad2fa8690d5d9a71b" translate="yes" xml:space="preserve">
          <source>Complicated stuff for Win32 that I don't understand. :(</source>
          <target state="translated">이해할 수없는 Win32의 복잡한 것들. :(</target>
        </trans-unit>
        <trans-unit id="f9088d8d7c9d5789f609c18210cfd55fd0924e55" translate="yes" xml:space="preserve">
          <source>Composing regular expressions at runtime</source>
          <target state="translated">런타임에 정규식 작성</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="63df8303c717b29c266d23df163b1b18d7225c3d" translate="yes" xml:space="preserve">
          <source>Composition Exclusion Table</source>
          <target state="translated">구성 제외 표</target>
        </trans-unit>
        <trans-unit id="fb6884eb8992b62c7c1af30d600b40339c50155a" translate="yes" xml:space="preserve">
          <source>Compound Statements</source>
          <target state="translated">복합 진술</target>
        </trans-unit>
        <trans-unit id="485ff8d4769defdc95809b50d74f993442a7e521" translate="yes" xml:space="preserve">
          <source>Compress all the DLLs with</source>
          <target state="translated">모든 DLL을 압축</target>
        </trans-unit>
        <trans-unit id="9fd56668bd5f18daaa0b667a0debd58feedac101" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Bzip2</source>
          <target state="translated">Compress::Raw::Bzip2</target>
        </trans-unit>
        <trans-unit id="18d94e1500a428c004428df46c1953161a32df03" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library</source>
          <target state="translated">Compress :: Raw :: Bzip2-bzip2 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="45bc572c9ec4512947eadc206937635681bf6c11" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib</source>
          <target state="translated">Compress::Raw::Zlib</target>
        </trans-unit>
        <trans-unit id="c076710bf2d12402a0edf3b2175c1d82039053a0" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib - Low-Level Interface to zlib compression library</source>
          <target state="translated">Compress :: Raw :: Zlib-zlib 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="35464ef9d0e6b29547404c53959f74fe619d2fa0" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib::Deflate</source>
          <target state="translated">Compress::Raw::Zlib::Deflate</target>
        </trans-unit>
        <trans-unit id="9da283b891dfecdc74e74f383b66cc8440ffe8da" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib::Inflate</source>
          <target state="translated">Compress::Raw::Zlib::Inflate</target>
        </trans-unit>
        <trans-unit id="0a6571e5bcd046dfe8f32f7d79b4f6bae3366dd5" translate="yes" xml:space="preserve">
          <source>Compress::Zlib</source>
          <target state="translated">Compress::Zlib</target>
        </trans-unit>
        <trans-unit id="96c20806a0d6c0bf54bc6c1767bdc331836742ff" translate="yes" xml:space="preserve">
          <source>Compress::Zlib - Interface to zlib compression library</source>
          <target state="translated">Compress :: Zlib-zlib 압축 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="b27c649ac2489267a35287d00edb05f007c3c52e" translate="yes" xml:space="preserve">
          <source>Compress::Zlib::memGunzip</source>
          <target state="translated">Compress::Zlib::memGunzip</target>
        </trans-unit>
        <trans-unit id="6729436703929444a364247fdaaf90b9905bdce6" translate="yes" xml:space="preserve">
          <source>Compress::Zlib::memGzip</source>
          <target state="translated">Compress::Zlib::memGzip</target>
        </trans-unit>
        <trans-unit id="ee774a21a0a3c5ce8303c3d53424d9997d3a1a40" translate="yes" xml:space="preserve">
          <source>Compresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the compressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축 합니다 . 성공하면 압축 된 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="f4abdd87ed061063a95a2ba22a68b1517b4fb78e" translate="yes" xml:space="preserve">
          <source>Compresses and outputs the contents of the &lt;code&gt;$data&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;$data&lt;/code&gt; 매개 변수 의 내용을 압축하고 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="bae9119119ae4847de6084005870d7cd27c57d09" translate="yes" xml:space="preserve">
          <source>Compresses and outputs the contents of the &lt;code&gt;$data&lt;/code&gt; parameter. This has the same behaviour as the &lt;code&gt;&lt;a href=&quot;../../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; built-in.</source>
          <target state="translated">&lt;code&gt;$data&lt;/code&gt; 매개 변수 의 내용을 압축하고 출력합니다 . 이것은 내장 &lt;code&gt;&lt;a href=&quot;../../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="61322d91de1a1c9dd976decc2eac0656945186ef" translate="yes" xml:space="preserve">
          <source>Compute $x ** $y.</source>
          <target state="translated">$ x ** $ y를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="b0e6b1f79c9f3294396b346171031d6eefb80388" translate="yes" xml:space="preserve">
          <source>Computers are good at being predictable and bad at being random (despite appearances caused by bugs in your programs :-). The</source>
          <target state="translated">컴퓨터는 예측 가능하고 무작위로 나쁘다 (프로그램의 버그로 인해 발생하지만 :-). 그만큼</target>
        </trans-unit>
        <trans-unit id="08d9ea43c28304526180b5a57915a96d4c9ac81d" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;$x&lt;/code&gt; raised to the power &lt;code&gt;$exponent&lt;/code&gt; .</source>
          <target state="translated">계산하여 &lt;code&gt;$x&lt;/code&gt; 전원에 제기 &lt;code&gt;$exponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57ac7c8e25d01d0b70814899b6ae00d4e8d209cf" translate="yes" xml:space="preserve">
          <source>Computing MROs can be expensive. The implementation provides a cache, in which you can store a single &lt;code&gt;SV *&lt;/code&gt; , or anything that can be cast to &lt;code&gt;SV *&lt;/code&gt; , such as &lt;code&gt;AV *&lt;/code&gt; . To read your private value, use the macro &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt; , passing it the &lt;code&gt;mro_meta&lt;/code&gt; structure from the stash, and a pointer to your &lt;code&gt;mro_alg&lt;/code&gt; structure:</source>
          <target state="translated">컴퓨팅 MRO는 비쌀 수 있습니다. 이 구현은 단일 &lt;code&gt;SV *&lt;/code&gt; 또는 &lt;code&gt;AV *&lt;/code&gt; 와 같이 &lt;code&gt;SV *&lt;/code&gt; 로 캐스트 할 수있는 모든 것을 저장할 수있는 캐시를 제공합니다 . 개인 값을 읽으려면 매크로 사용 &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt; 그것에게 전달 &lt;code&gt;mro_meta&lt;/code&gt; 의 숨김에서 구조를하고 포인터 &lt;code&gt;mro_alg&lt;/code&gt; 의 구조를 :</target>
        </trans-unit>
        <trans-unit id="cb3a0dfbaecfd882d35c67f5f3bd704631194aab" translate="yes" xml:space="preserve">
          <source>Concatenate one or more directory names and a filename to form a complete path ending with a filename</source>
          <target state="translated">하나 이상의 디렉토리 이름과 파일 이름을 연결하여 파일 이름으로 끝나는 완전한 경로를 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="047b05311f0dc34982a56cd2fb9ad1f922dcbd7c" translate="yes" xml:space="preserve">
          <source>Concatenate one or more directory names and a filename to form a complete path ending with a filename. Resulting paths are &lt;b&gt;relative&lt;/b&gt; by default, but can be forced to be absolute (but avoid this).</source>
          <target state="translated">하나 이상의 디렉토리 이름과 파일 이름을 연결하여 파일 이름으로 끝나는 완전한 경로를 형성하십시오. 결과 경로는 기본적 &lt;b&gt;으로 상대적&lt;/b&gt; 이지만 절대 경로가 되도록 강제 할 수 있습니다 (그러나이를 피하십시오).</target>
        </trans-unit>
        <trans-unit id="f35597adc56e5ce25242327211e537bda9c2f250" translate="yes" xml:space="preserve">
          <source>Concatenate the lists of ops contained directly within two list-type ops, returning the combined list.</source>
          <target state="translated">두 개의 목록 유형 op에 직접 포함 된 op 목록을 연결하여 결합 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="649e67e9503162d4b5271ac24839b4dd127f4a0a" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a complete path ending with a directory. But remove the trailing slash from the resulting string, because it doesn't look good, isn't necessary and confuses OS/2. Of course, if this is the root directory, don't cut off the trailing slash :-)</source>
          <target state="translated">디렉토리로 끝나는 완전한 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 그러나 결과 문자열에서 후행 슬래시를 제거하십시오. 잘 보이지 않고 필요하지 않으며 OS / 2를 혼란스럽게하기 때문입니다. 물론 이것이 루트 디렉토리라면, 후행 슬래시를 잘라 내지 마십시오 :-)</target>
        </trans-unit>
        <trans-unit id="55de8a490d5d9aa9964bf82d52f080f49c22f141" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a complete path ending with a directory. But remove the trailing slash from the resulting string, because it doesn't look good, isn't necessary and confuses OS2. Of course, if this is the root directory, don't cut off the trailing slash :-)</source>
          <target state="translated">디렉토리로 끝나는 완전한 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 그러나 결과 문자열에서 후행 슬래시를 제거하십시오. 잘 보이지 않고 필요하지 않으며 OS2를 혼동합니다. 물론 이것이 루트 디렉토리라면, 후행 슬래시를 잘라 내지 마십시오 :-)</target>
        </trans-unit>
        <trans-unit id="7d067b3996ede67611d936f0cc0594b33d12b143" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a path separated by colons (&quot;:&quot;) ending with a directory. Resulting paths are &lt;b&gt;relative&lt;/b&gt; by default, but can be forced to be absolute (but avoid this, see below). Automatically puts a trailing &quot;:&quot; on the end of the complete path, because that's what's done in MacPerl's environment and helps to distinguish a file path from a directory path.</source>
          <target state="translated">디렉토리로 끝나는 콜론 ( &quot;:&quot;)으로 구분 된 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 결과 경로는 기본적 &lt;b&gt;으로 상대적&lt;/b&gt; 이지만 절대 경로가 될 수 있습니다 (그러나이를 피하십시오 (아래 참조)). MacPerl 환경에서 수행되는 파일이므로 디렉토리 경로와 파일 경로를 구별하는 데 도움이되기 때문에 전체 경로의 끝에 자동으로 &quot;:&quot;를 붙입니다.</target>
        </trans-unit>
        <trans-unit id="1f92bbd0599928bde109c94dcff53b7718e50962" translate="yes" xml:space="preserve">
          <source>Concatenates a list of directory specifications with a filename specification to build a path.</source>
          <target state="translated">디렉토리 스펙 목록을 파일 이름 스펙과 결합하여 경로를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="443b92cba56de5e426bb70ed2661bc12a7f0aa5f" translate="yes" xml:space="preserve">
          <source>Concatenates a list of file specifications, and returns the result as a native directory specification unless the Unix filename reporting feature has been enabled. No check is made for &quot;impossible&quot; cases (e.g. elements other than the first being absolute filespecs).</source>
          <target state="translated">파일 스펙 목록을 연결하고 Unix 파일 이름보고 기능을 사용하지 않는 한 결과를 기본 디렉토리 스펙으로 리턴합니다. &quot;불가능한&quot;경우에 대해서는 점검하지 않습니다 (예 : 첫 번째 이외의 요소는 절대 파일 스펙).</target>
        </trans-unit>
        <trans-unit id="a1064ed1ab12c5551a61949efb23c2a0fe5e1b5a" translate="yes" xml:space="preserve">
          <source>Concatenates all files mentioned on command line to STDOUT.</source>
          <target state="translated">명령 행에 언급 된 모든 파일을 STDOUT에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aeaf86da2ac135282bf22834043d6e62fbe3a826" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt; -terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;sv_catpv_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 'get'마법을 처리하지만 'set'마법은 처리하지 않습니다. &lt;code&gt;sv_catpv_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14b45eaa62bb9cbc2fd55f55bbeff1b25f09af1b" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt; -terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on the modified SV if appropriate.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_set&lt;/code&gt; 수정 SV 해당되는 경우에.</target>
        </trans-unit>
        <trans-unit id="eb1ee548c525e9ae72200cea308c51a15c04e05b" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt; . Handles 'get' magic on both SVs, but no 'set' magic. See &lt;code&gt;sv_catsv_mg&lt;/code&gt; and &lt;code&gt;sv_catsv_nomg&lt;/code&gt; .</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 두 SV 모두에서 'get'매직을 처리하지만 'set'매직은 처리하지 않습니다. &lt;code&gt;sv_catsv_mg&lt;/code&gt; 및 &lt;code&gt;sv_catsv_nomg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="638b5971cabc9806aa9868b5283e2415ea8bede6" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;flags&lt;/code&gt; include &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will call &lt;code&gt;mg_get&lt;/code&gt; on both SVs if appropriate. If &lt;code&gt;flags&lt;/code&gt; include &lt;code&gt;SV_SMAGIC&lt;/code&gt; , &lt;code&gt;mg_set&lt;/code&gt; will be called on the modified SV afterward, if appropriate. &lt;code&gt;sv_catsv&lt;/code&gt; , &lt;code&gt;sv_catsv_nomg&lt;/code&gt; , and &lt;code&gt;sv_catsv_mg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 이 세트 비트, 호출 &lt;code&gt;mg_get&lt;/code&gt; 을 적절한 경우 모두의 SV에. 경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 을 , &lt;code&gt;mg_set&lt;/code&gt; 이 필요한 경우, 이후에 수정 된 SV에 호출됩니다. &lt;code&gt;sv_catsv&lt;/code&gt; , &lt;code&gt;sv_catsv_nomg&lt;/code&gt; 및 &lt;code&gt;sv_catsv_mg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="32fe76b48251f7900129b9480f9210b340fdc9af" translate="yes" xml:space="preserve">
          <source>Concatenates the string onto the end of the string which is in the SV. The &lt;code&gt;len&lt;/code&gt; indicates number of bytes to copy.</source>
          <target state="translated">문자열을 SV에있는 문자열의 끝에 연결합니다. &lt;code&gt;len&lt;/code&gt; 복사 할 바이트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9552a0de5c0babf6573b77f8cdd2583744fe375e" translate="yes" xml:space="preserve">
          <source>Concatenates the string onto the end of the string which is in the SV. The &lt;code&gt;len&lt;/code&gt; indicates number of bytes to copy. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;sv_catpvn_mg&lt;/code&gt; .</source>
          <target state="translated">문자열을 SV에있는 문자열의 끝에 연결합니다. &lt;code&gt;len&lt;/code&gt; 복사 할 바이트 수를 나타냅니다. SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 'get'마법을 처리하지만 'set'마법은 처리하지 않습니다. &lt;code&gt;sv_catpvn_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdcfedf7534d333df8380db86be3ac2ea169364e" translate="yes" xml:space="preserve">
          <source>Conceptually, the easiest way to count the lines in a file is to simply read them and count them:</source>
          <target state="translated">개념적으로 파일에서 행을 계산하는 가장 쉬운 방법은 단순히 행을 읽고 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="0dbde46110575d19c57e331505cceacbb06fd5c7" translate="yes" xml:space="preserve">
          <source>Conditional Operator</source>
          <target state="translated">조건부 연산자</target>
        </trans-unit>
        <trans-unit id="80a3a5f034865959dc043303f8d87089be9bec1e" translate="yes" xml:space="preserve">
          <source>Conditional and looping constructs</source>
          <target state="translated">조건부 및 반복 구성</target>
        </trans-unit>
        <trans-unit id="96632c17c857e0c02d178649142fafe7584b5abf" translate="yes" xml:space="preserve">
          <source>Conditional expression. Matches &lt;code&gt;yes-pattern&lt;/code&gt; if &lt;code&gt;condition&lt;/code&gt; yields a true value, matches &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-pattern&lt;/a&gt;&lt;/code&gt; otherwise. A missing pattern always matches.</source>
          <target state="translated">조건식. 일치의 &lt;code&gt;yes-pattern&lt;/code&gt; 경우 &lt;code&gt;condition&lt;/code&gt; true 값을 산출이 일치하지 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-pattern&lt;/a&gt;&lt;/code&gt; 달리. 누락 된 패턴은 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="a343c81c0a2492332b5fb3f41392ce89176105c4" translate="yes" xml:space="preserve">
          <source>Conditional tests</source>
          <target state="translated">조건부 테스트</target>
        </trans-unit>
        <trans-unit id="cf037e3922672487abb4fdf8a9fb64c629078717" translate="yes" xml:space="preserve">
          <source>Conditionally does &lt;code&gt;OpMORESIB_set&lt;/code&gt; or &lt;code&gt;OpLASTSIB_set&lt;/code&gt; depending on whether sib is non-null. For a higher-level interface, see &lt;code&gt;op_sibling_splice&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;OpMORESIB_set&lt;/code&gt; 가 널이 아닌지 여부에 따라 조건부로 OpMORESIB_set 또는 &lt;code&gt;OpLASTSIB_set&lt;/code&gt; 을 수행합니다. 고급 인터페이스는 &lt;code&gt;op_sibling_splice&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8851142da56fd885ce668a165b33fee7003e858d" translate="yes" xml:space="preserve">
          <source>Config</source>
          <target state="translated">Config</target>
        </trans-unit>
        <trans-unit id="ecd4bd981dd9c138dc910d68320acc6b8da803ca" translate="yes" xml:space="preserve">
          <source>Config - access Perl configuration information</source>
          <target state="translated">구성-Perl 구성 정보에 액세스</target>
        </trans-unit>
        <trans-unit id="fbb49b6e5c194d0312a905696c20f6b5d8a43c67" translate="yes" xml:space="preserve">
          <source>Config Variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="2c6df16e95af35ad3cf55abb04956aab698aea9b" translate="yes" xml:space="preserve">
          <source>Config.pm</source>
          <target state="translated">Config.pm</target>
        </trans-unit>
        <trans-unit id="3784c094667e63aa78e7304ec87ad01e622ad79e" translate="yes" xml:space="preserve">
          <source>Config.sys</source>
          <target state="translated">Config.sys</target>
        </trans-unit>
        <trans-unit id="61386747172506a6ac768b51dbad3d57554bb149" translate="yes" xml:space="preserve">
          <source>Config::Extensions</source>
          <target state="translated">Config::Extensions</target>
        </trans-unit>
        <trans-unit id="fb7f1d1b07ade815b9ca8129a9e4d8f0870938dc" translate="yes" xml:space="preserve">
          <source>Configurable Options</source>
          <target state="translated">구성 가능한 옵션</target>
        </trans-unit>
        <trans-unit id="56f4add64bfc676813ad28c07cc79f57bf4381eb" translate="yes" xml:space="preserve">
          <source>Configurable error handling can be very useful to your users. Consider offering a choice of levels for warning and debug messages, an option to send messages to a separate file, a way to specify an error-handling routine, or other such features. Be sure to default all these options to the commonest use.</source>
          <target state="translated">구성 가능한 오류 처리는 사용자에게 매우 유용 할 수 있습니다. 경고 및 디버그 메시지 레벨 선택, 메시지를 별도의 파일로 보내는 옵션, 오류 처리 루틴 지정 방법 또는 기타 기능을 고려하십시오. 이러한 모든 옵션을 가장 일반적으로 사용하도록 기본 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="81fb8746ddaba4745cb47bc6c868c238d3f12698" translate="yes" xml:space="preserve">
          <source>Configuration Variables or Methods</source>
          <target state="translated">구성 변수 또는 방법</target>
        </trans-unit>
        <trans-unit id="d2fcd0c469689696cdc57b270bd37400e3e0e6c1" translate="yes" xml:space="preserve">
          <source>Configuration errors and errors in the option definitions are signalled using die() and will terminate the calling program unless the call to Getopt::Long::GetOptions() was embedded in &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; { ...
}&lt;/code&gt; , or die() was trapped using &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; .</source>
          <target state="translated">옵션 정의의 구성 오류 및 오류는 die ()를 사용하여 신호를 보내며 Getopt :: Long :: GetOptions ()에 대한 호출이 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; { ... }&lt;/code&gt; 에 포함되거나 die ()가 트랩 되지 않은 경우 호출 프로그램을 종료합니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01782ddc9fc1147edd83eb2ff115b31fada6fafa" translate="yes" xml:space="preserve">
          <source>Configuration for individual distributions (</source>
          <target state="translated">개별 배포판 구성 (</target>
        </trans-unit>
        <trans-unit id="620eedd56ce9ab6e57edf826ebebcc6cc23b9756" translate="yes" xml:space="preserve">
          <source>Configuration for individual distributions (_Distroprefs_)</source>
          <target state="translated">개별 분포 구성 (_Distroprefs_)</target>
        </trans-unit>
        <trans-unit id="5394ae422bdb720639203760041881561ff41485" translate="yes" xml:space="preserve">
          <source>Configuration options can be passed to the constructor:</source>
          <target state="translated">구성 옵션은 생성자에게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b23d1375544f4a68ea9228188041f47459e054" translate="yes" xml:space="preserve">
          <source>Configuration variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="792c81a4cfdcb5b45d688cb03c2fd2e816f86d44" translate="yes" xml:space="preserve">
          <source>Configure</source>
          <target state="translated">Configure</target>
        </trans-unit>
        <trans-unit id="5319105d548748be6bfc04e58d097068e24ec3c4" translate="yes" xml:space="preserve">
          <source>Configure Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl 구성</target>
        </trans-unit>
        <trans-unit id="8c3578dc7c3bfda9e6cafe0a3dcc7133abe34a4d" translate="yes" xml:space="preserve">
          <source>Configure and perl need a way to invoke a C preprocessor. I have created a simple cover for cc which does the right thing. Without this, Configure will create its own wrapper which works, but it doesn't handle some of the command line arguments that perl will throw at it.</source>
          <target state="translated">구성 및 perl은 C 프리 프로세서를 호출하는 방법이 필요합니다. 올바른 일을하는 cc에 대한 간단한 표지를 만들었습니다. 이것이 없으면 Configure는 작동하는 자체 래퍼를 만들지 만 perl이 던질 명령 줄 인수는 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42f3effdfaee1be1f099b1b5ad94e5c21896a110" translate="yes" xml:space="preserve">
          <source>Configure notes: This function is called 'Perl_signbit' instead of a plain 'signbit' because it is easy to imagine a system having a signbit() function or macro that doesn't happen to work with our particular choice of NVs. We shouldn't just re-#define signbit as Perl_signbit and expect the standard system headers to be happy. Also, this is a no-context function (no pTHX_) because Perl_signbit() is usually re-#defined in perl.h as a simple macro call to the system's signbit(). Users should just always call Perl_signbit().</source>
          <target state="translated">메모 구성 :이 함수는 일반 'signbit'대신 'Perl_signbit'이라고하며, 특정 NV 선택에서 작동하지 않는 signbit () 함수 또는 매크로가있는 시스템을 쉽게 상상할 수 있기 때문입니다. 우리는 부호 비트를 Perl_signbit로 재정의하지 말고 표준 시스템 헤더가 행복 할 것으로 기대해야합니다. 또한 Perl_signbit ()는 일반적으로 시스템의 signbit ()에 대한 간단한 매크로 호출로 perl.h에서 재정의되기 때문에 컨텍스트가없는 함수 (pTHX_ 없음)입니다. 사용자는 항상 Perl_signbit ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f6173a649f1483a99a4687a3ffadbcdca70587d" translate="yes" xml:space="preserve">
          <source>Configure-time Options for Perl on Cygwin</source>
          <target state="translated">Cygwin에서 Perl의 구성 시간 옵션</target>
        </trans-unit>
        <trans-unit id="9df8ff6ed6cb175291b798f1b94a9c669317082c" translate="yes" xml:space="preserve">
          <source>Configured this way, single-character options can be bundled but long options &lt;b&gt;must&lt;/b&gt; always start with a double dash &lt;code&gt;--&lt;/code&gt; to avoid ambiguity. For example, when &lt;code&gt;vax&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">이런 식으로 구성, 단일 문자 옵션은 번들로 제공 할 수 있지만 긴 옵션은 &lt;b&gt;해야한다&lt;/b&gt; 항상 이중 대시로 시작 &lt;code&gt;--&lt;/code&gt; 피하고 모호성에. 예를 들어, &lt;code&gt;vax&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="95e3547b156067af12afba08b6daf72fe4ff1b22" translate="yes" xml:space="preserve">
          <source>Configuring Getopt::Long</source>
          <target state="translated">Getopt :: Long 구성</target>
        </trans-unit>
        <trans-unit id="205f634664a81d583aebe4d32b4cfaa368eaa173" translate="yes" xml:space="preserve">
          <source>Configuring lynx or ncftp for going through a firewall</source>
          <target state="translated">방화벽을 통과하도록 lynx 또는 ncftp 구성</target>
        </trans-unit>
        <trans-unit id="a90ca9c9438d0e03c655e7e421109dc9a2965820" translate="yes" xml:space="preserve">
          <source>Conflicting storage orders make an utter mess out of the numbers. If a little-endian host (Intel, VAX) stores 0x12345678 (305419896 in decimal), a big-endian host (Motorola, Sparc, PA) reads it as 0x78563412 (2018915346 in decimal). Alpha and MIPS can be either: Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses them in big-endian mode. To avoid this problem in network (socket) connections use the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; formats &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; , the &quot;network&quot; orders. These are guaranteed to be portable.</source>
          <target state="translated">충돌하는 스토리지 주문은 숫자를 완전히 엉망으로 만듭니다. 리틀 엔디안 호스트 (Intel, VAX)가 0x12345678 (10 진수로 305419896)을 저장하면 빅 엔디안 호스트 (Motorola, Sparc, PA)는이를 0x78563412 (10 진수로 2018915346)로 읽습니다. Alpha 및 MIPS는 다음 중 하나 일 수 있습니다. Digital / Compaq은 리틀 엔디안 모드에서 사용 / 사용합니다. SGI / Cray는 빅 엔디안 모드에서 사용합니다. 네트워크 (소켓) 연결에서이 문제를 피하려면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 형식 &lt;code&gt;n&lt;/code&gt; 및 &lt;code&gt;N&lt;/code&gt; 을 사용하십시오 ( &quot;네트워크&quot;주문). 이들은 휴대용으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5523655003f964e64fb217f9f8e4a760dcd771" translate="yes" xml:space="preserve">
          <source>Conflicts between parameters LIB, PREFIX and the various INSTALL* arguments are resolved so that:</source>
          <target state="translated">매개 변수 LIB, PREFIX 및 다양한 INSTALL * 인수 사이의 충돌은 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="d58273d316d0bc21f48ecd5b6254bb29f9f6bf8e" translate="yes" xml:space="preserve">
          <source>Confused yet? It's time for an example program to show some of the things we've covered. This program finds prime numbers using threads.</source>
          <target state="translated">아직 혼란스러워? 예제 프로그램이 우리가 다룬 것들 중 일부를 보여줄 차례입니다. 이 프로그램은 스레드를 사용하여 소수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e96e2cb50db9a42b686132ae3630295f7ba8934b" translate="yes" xml:space="preserve">
          <source>Connecting to the server is only the first part of the process: once you have the connection, you have to use the server's language. Each server on the network has its own little command language that it expects as input. The string that we send to the server starting with &quot;GET&quot; is in HTTP syntax. In this case, we simply request each specified document. Yes, we really are making a new connection for each document, even though it's the same host. That's the way you always used to have to speak HTTP. Recent versions of web browsers may request that the remote server leave the connection open a little while, but the server doesn't have to honor such a request.</source>
          <target state="translated">서버 연결은 프로세스의 첫 번째 부분 일뿐입니다. 일단 연결되면 서버 언어를 사용해야합니다. 네트워크의 각 서버에는 입력으로 예상되는 자체 명령 언어가 있습니다. &quot;GET&quot;으로 시작하는 서버로 보내는 문자열은 HTTP 구문입니다. 이 경우 지정된 각 문서를 요청합니다. 예, 동일한 호스트 인 경우에도 각 문서마다 새로운 연결을 만들고 있습니다. 이것이 항상 HTTP를 사용하는 방식입니다. 최신 버전의 웹 브라우저는 원격 서버가 연결을 조금 열린 상태로 유지하도록 요청할 수 있지만 서버는 그러한 요청을 받아 들일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e64457037d72f3af7e4c98e763af1778685b4a7" translate="yes" xml:space="preserve">
          <source>Consequently, if the code in the</source>
          <target state="translated">결과적으로</target>
        </trans-unit>
        <trans-unit id="2aebd1c0023adb488842327316cfbc056a8738a1" translate="yes" xml:space="preserve">
          <source>Consider a character, say &lt;code&gt;H&lt;/code&gt; . It could appear with various marks around it, such as an acute accent, or a circumflex, or various hooks, circles, arrows,</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; 라고 말하는 캐릭터를 생각해보십시오 . 급성 악센트, 곡절 악센트 또는 다양한 고리, 원, 화살표 등 주변에 다양한 표시가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87b1aebc18642da43916d9c7c0029ba1587fd12" translate="yes" xml:space="preserve">
          <source>Consider a function foo() in package pkg compiled outside a compartment but shared with it. Assume the compartment has a root package called 'Root'. If foo() contains an eval statement like eval '$foo = 1' then, normally, $pkg::foo will be set to 1. If foo() is called from the compartment (by whatever means) then instead of setting $pkg::foo, the eval will actually set $Root::pkg::foo.</source>
          <target state="translated">구획 외부에서 컴파일되었지만 공유 된 패키지 pkg의 함수 foo ()를 고려하십시오. 구획에 'Root'라는 루트 패키지가 있다고 가정하십시오. foo ()에 eval '$ foo = 1'과 같은 eval 문이 포함되어 있으면 일반적으로 $ pkg :: foo가 1로 설정됩니다. pkg :: foo, eval은 실제로 $ Root :: pkg :: foo를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fa0726375d47145ef9cbf1c119c720175b5cdb39" translate="yes" xml:space="preserve">
          <source>Consider always blessing objects in CLASSNAMEs that are mixed case. Namespaces with all lowercase names are considered reserved for Perl pragmata. Builtin types have all uppercase names. To prevent confusion, you may wish to avoid such package names as well. Make sure that CLASSNAME is a true value.</source>
          <target state="translated">대소 문자가 혼합 된 CLASSNAME의 객체를 항상 축복하는 것을 고려하십시오. 모든 소문자 이름을 가진 네임 스페이스는 Perl pragmata에 예약 된 것으로 간주됩니다. 내장 유형은 모두 대문자입니다. 혼동을 피하기 위해 이러한 패키지 이름도 피할 수 있습니다. CLASSNAME이 실제 값인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="54bd3e39ecc1dc0a3103a2a4bb188aab06a6068e" translate="yes" xml:space="preserve">
          <source>Consider arguments as file names; no search in directories will be performed.</source>
          <target state="translated">파일 이름으로 인수를 고려하십시오. 디렉토리에서 검색이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b1d13cd5ce92e946f7ab5b33dc6419aff0f850f" translate="yes" xml:space="preserve">
          <source>Consider that &quot;division by zero&quot; of Encode :)</source>
          <target state="translated">Encode의 &quot;0으로 나누기&quot;를 고려하십시오. :)</target>
        </trans-unit>
        <trans-unit id="42926455b13e587b6e93dd752aad04492e788722" translate="yes" xml:space="preserve">
          <source>Consider the Perl code below</source>
          <target state="translated">아래의 Perl 코드를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="010e07e2525e9ccf7d06cb1256121da84a80d2b8" translate="yes" xml:space="preserve">
          <source>Consider the autogenerated files as skeletons only, you may invent better interfaces than what h2xs could guess.</source>
          <target state="translated">자동 생성 된 파일을 스켈레톤으로 만 고려하면 h2x가 추측 할 수있는 것보다 더 나은 인터페이스를 발명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8650ada785e6a05ab5925372ee6ad4e84e025768" translate="yes" xml:space="preserve">
          <source>Consider the following Perl code:</source>
          <target state="translated">다음 Perl 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7f74e12aabb1877452a7d53cc071e21357b26c18" translate="yes" xml:space="preserve">
          <source>Consider the following pattern. The numbers underneath show in which group the captured content will be stored.</source>
          <target state="translated">다음 패턴을 고려하십시오. 아래의 숫자는 캡처 한 콘텐츠가 저장 될 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5599b31813d52e72ab7b0f81e5b0ee2cd936fffb" translate="yes" xml:space="preserve">
          <source>Consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">다음 시나리오를 고려하십시오. 타사 C 애플리케이션과 공유해야하는 DBM 데이터베이스가 있습니다. C 애플리케이션은 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8fd75f493422859997cd7850cec39135120cb65b" translate="yes" xml:space="preserve">
          <source>Consider the implications.</source>
          <target state="translated">시사점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="72c370504fc887121d33e7c91d4e60dee9fc8d48" translate="yes" xml:space="preserve">
          <source>Consider the module &lt;code&gt;MyMod::Abc&lt;/code&gt; below.</source>
          <target state="translated">아래 의 모듈 &lt;code&gt;MyMod::Abc&lt;/code&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="91193a63d32f0407e30025add9e80a60522f7554" translate="yes" xml:space="preserve">
          <source>Consider these functions: &lt;code&gt;getusers&lt;/code&gt; returns a list of users somehow, and then &lt;code&gt;main&lt;/code&gt; throws away the first user on the list and prints the rest:</source>
          <target state="translated">이러한 기능을 고려 &lt;code&gt;getusers&lt;/code&gt; 의 다음 반환 어떻게 든 사용자의 목록 및 &lt;code&gt;main&lt;/code&gt; 목록에 첫 번째 사용자를 멀리 던져 나머지를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="a6af64455c7f7fc0377e14c06fd26c8d88bd4457" translate="yes" xml:space="preserve">
          <source>Consider this carefully</source>
          <target state="translated">이것을 신중하게 고려하십시오</target>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="translated">이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bfa3c3c6eb24f57753daa498c1da469254839e82" translate="yes" xml:space="preserve">
          <source>Consider this function:</source>
          <target state="translated">이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8941a9b985d7af8702f49a4f16ae94cca0faaad4" translate="yes" xml:space="preserve">
          <source>Consider this line:</source>
          <target state="translated">이 줄을 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="e6c30ae9cfc668295698d4bf00794eb1d360161b" translate="yes" xml:space="preserve">
          <source>Consider this pattern:</source>
          <target state="translated">이 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1933a50a57bf352434dc1e181b868210ee85c8c1" translate="yes" xml:space="preserve">
          <source>Consider this rather facetious example, where we have used an XS version of the call_Subtract example above inside a destructor:</source>
          <target state="translated">소멸자 안에서 위의 call_Subtract 예제의 XS 버전을 사용한이 겉보기 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6cb9a94e2bea8da922c3c19cf684a0e47677d4e9" translate="yes" xml:space="preserve">
          <source>Consider this script, which has an error you may not notice immediately.</source>
          <target state="translated">즉시 알 수없는 오류가있는이 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="221f972e292aedaaa9907f3e013cc1a6d1499997" translate="yes" xml:space="preserve">
          <source>Consider this section as a guideline only, some other options of h2xs may better suit your needs.</source>
          <target state="translated">이 섹션을 지침으로 만 고려하십시오. 다른 h2x 옵션은 사용자의 요구에 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef89846ebcc9e55f8e16c8d6eeaf74751bcc0834" translate="yes" xml:space="preserve">
          <source>Consider two possible matches, &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;A'B'&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;B'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;T&lt;/code&gt; .</source>
          <target state="translated">두 개의 가능한 일치 고려 &lt;code&gt;AB&lt;/code&gt; 와 &lt;code&gt;A'B'&lt;/code&gt; , 및 &lt;code&gt;A'&lt;/code&gt; 를 일치 될 수있는 문자열 &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;B'&lt;/code&gt; 일치 될 수있는 문자열 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9492d2cabe7fd9e4932b42a71ed433789fc97e73" translate="yes" xml:space="preserve">
          <source>Consider using &quot;real&quot; multidimensional arrays as described in &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perllol&quot;&gt;perllol에&lt;/a&gt; 설명 된대로 &quot;실제&quot;다차원 배열 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="88bf0b769dc7bb2c0aaed54218c7a09d588e237d" translate="yes" xml:space="preserve">
          <source>Consider what happens during execution of the BEGIN block. At this point the BEGIN block has already been compiled, but the body of &lt;code&gt;foo()&lt;/code&gt; is still being compiled. The new value of &lt;code&gt;$^H&lt;/code&gt; will therefore be visible only while the body of &lt;code&gt;foo()&lt;/code&gt; is being compiled.</source>
          <target state="translated">BEGIN 블록을 실행하는 동안 발생하는 상황을 고려하십시오. 이 시점에서 BEGIN 블록은 이미 컴파일되었지만 &lt;code&gt;foo()&lt;/code&gt; 본문 은 여전히 ​​컴파일되고 있습니다. 따라서 &lt;code&gt;$^H&lt;/code&gt; 의 새 값 은 &lt;code&gt;foo()&lt;/code&gt; 의 본문 동안에 만 표시됩니다. 이 컴파일되는 .</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="83e396f6992f0832c8075c73a610b8e2aaff7469" translate="yes" xml:space="preserve">
          <source>Considerations for module design and coding:</source>
          <target state="translated">모듈 설계 및 코딩에 대한 고려 사항 :</target>
        </trans-unit>
        <trans-unit id="5413348d3aaa513d685bd38624f77e878e74a24a" translate="yes" xml:space="preserve">
          <source>Consistent naming of subroutines or methods</source>
          <target state="translated">서브 루틴 또는 메소드의 일관된 이름 지정</target>
        </trans-unit>
        <trans-unit id="2d686acf592debeada13314ea153c3c8cc7487e9" translate="yes" xml:space="preserve">
          <source>Constant Folding</source>
          <target state="translated">일정한 접는</target>
        </trans-unit>
        <trans-unit id="20e7a47ab29e19ba135c447b4536a0bd6e1d82dd" translate="yes" xml:space="preserve">
          <source>Constant Functions</source>
          <target state="translated">상수 함수</target>
        </trans-unit>
        <trans-unit id="d83ebf1e43cbbe5eb7aa831bfb0f3e3251894c92" translate="yes" xml:space="preserve">
          <source>Constant Interface</source>
          <target state="translated">일정한 인터페이스</target>
        </trans-unit>
        <trans-unit id="05b0c81a6abce35ba0658d6d8b023f51626d6394" translate="yes" xml:space="preserve">
          <source>Constant subs can be created with &lt;code&gt;newCONSTSUB&lt;/code&gt; or as described in &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">상수 서브는 &lt;code&gt;newCONSTSUB&lt;/code&gt; 를 사용 하거나 perlsub의 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;상수 함수에&lt;/a&gt; 설명 된대로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="9e611a824a8183e220d4a7c0d0aa3bafaf2b538a" translate="yes" xml:space="preserve">
          <source>Constants belong to the package they are defined in. To refer to a constant defined in another package, specify the full package name, as in &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt; . Constants may be exported by modules, and may also be called as either class or instance methods, that is, as &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; or as &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; where &lt;code&gt;$obj&lt;/code&gt; is an instance of &lt;code&gt;Some::Package&lt;/code&gt; . Subclasses may define their own constants to override those in their base class.</source>
          <target state="translated">상수는 정의 된 패키지에 속합니다. 다른 패키지에 정의 된 상수를 참조하려면 &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt; 와 같이 전체 패키지 이름을 지정하십시오 . 상수는 모듈에 의해 익스포트 될 수 있으며 클래스 또는 인스턴스 메소드, 즉 &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; 또는 &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; 로 호출 될 수 있습니다. 여기서 &lt;code&gt;$obj&lt;/code&gt; 는 &lt;code&gt;Some::Package&lt;/code&gt; 의 인스턴스입니다 . 서브 클래스는 자신의 상수를 정의하여 기본 클래스의 상수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21cfbc2db87f9182c549bff7c8f35745bf20234" translate="yes" xml:space="preserve">
          <source>Constants defined using this module cannot be interpolated into strings like variables. However, concatenation works just fine:</source>
          <target state="translated">이 모듈을 사용하여 정의 된 상수는 변수와 같은 문자열로 보간 할 수 없습니다. 그러나 연결은 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ece936e7325f2407cd17ba720f075223bee4d90" translate="yes" xml:space="preserve">
          <source>Constants for Locale codes</source>
          <target state="translated">로캘 코드의 상수</target>
        </trans-unit>
        <trans-unit id="90018db3a64f1b35ef89d41c0084cc18166e6bd9" translate="yes" xml:space="preserve">
          <source>Constants giving the special &lt;code&gt;AF_INET6&lt;/code&gt; addresses for wildcard and local loopback.</source>
          <target state="translated">와일드 카드 및 로컬 루프백에 특별한 &lt;code&gt;AF_INET6&lt;/code&gt; 주소를 제공하는 상수 .</target>
        </trans-unit>
        <trans-unit id="3f844ade6411f17a07d09e25894b5b9acfe42b33" translate="yes" xml:space="preserve">
          <source>Constants giving the special &lt;code&gt;AF_INET&lt;/code&gt; addresses for wildcard, broadcast, local loopback, and invalid addresses.</source>
          <target state="translated">와일드 카드, 브로드 캐스트, 로컬 루프백 및 유효하지 않은 주소에 대한 특수 &lt;code&gt;AF_INET&lt;/code&gt; 주소를 제공하는 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="7f1778f60074f1115e51de3d87a3332a8d7fc830" translate="yes" xml:space="preserve">
          <source>Constants may be lists of more (or less) than one value. A constant with no values evaluates to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context. Note that constants with more than one value do</source>
          <target state="translated">상수는 하나 이상의 값 목록 일 수 있습니다. 값이없는 상수 는 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 평가됩니다 . 하나 이상의 값을 가진 상수는</target>
        </trans-unit>
        <trans-unit id="355a3d53a7e14f7a729e8f91686b85505d33df33" translate="yes" xml:space="preserve">
          <source>Construct a complete filespec.</source>
          <target state="translated">완전한 파일 스펙을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="aec9f3529c9af4370344830a20d26a1ac2ddabe7" translate="yes" xml:space="preserve">
          <source>Construct and return cache object.</source>
          <target state="translated">캐시 객체를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da33e1b7e0c4eae1911ee4a15280f0990e1a6115" translate="yes" xml:space="preserve">
          <source>Construction</source>
          <target state="translated">Construction</target>
        </trans-unit>
        <trans-unit id="0c9d593aa97f6e3f26bb7e4cf664176f5ffd4019" translate="yes" xml:space="preserve">
          <source>Construction Methods</source>
          <target state="translated">건축 방법</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="ef269264e27df02b9462bb6740ca823b7e335569" translate="yes" xml:space="preserve">
          <source>Constructor Options</source>
          <target state="translated">생성자 옵션</target>
        </trans-unit>
        <trans-unit id="94b976a5ab3f62f6c26557a2c4dbf4bbae664372" translate="yes" xml:space="preserve">
          <source>Constructor and Tailoring</source>
          <target state="translated">생성자 및 조정</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="d746fdc33e3789e1ca29174d30fb76d7df4e6835" translate="yes" xml:space="preserve">
          <source>Constructs a state op (COP). The state op is normally a &lt;code&gt;nextstate&lt;/code&gt; op, but will be a &lt;code&gt;dbstate&lt;/code&gt; op if debugging is enabled for currently-compiled code. The state op is populated from &lt;code&gt;PL_curcop&lt;/code&gt; (or &lt;code&gt;PL_compiling&lt;/code&gt; ). If</source>
          <target state="translated">상태 연산 (COP)을 구성합니다. 상태 op는 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; op이지만 현재 컴파일 된 코드에 대해 디버깅이 활성화 된 경우 &lt;code&gt;dbstate&lt;/code&gt; op가됩니다. 상태 op는 &lt;code&gt;PL_curcop&lt;/code&gt; (또는 &lt;code&gt;PL_compiling&lt;/code&gt; ) 에서 채워집니다 . 만약</target>
        </trans-unit>
        <trans-unit id="252503586ad552246e785267ad1b402b11d9c378" translate="yes" xml:space="preserve">
          <source>Constructs and returns a &lt;code&gt;range&lt;/code&gt; op, with subordinate &lt;code&gt;flip&lt;/code&gt; and &lt;code&gt;flop&lt;/code&gt; ops.</source>
          <target state="translated">종속 &lt;code&gt;flip&lt;/code&gt; 및 &lt;code&gt;flop&lt;/code&gt; 연산을 사용 하여 &lt;code&gt;range&lt;/code&gt; 연산을 구성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7931ff4d1b3865a020bb44b64b70244e6b1d8e26" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name.</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="957cf4dcc64056248a5fc94c4f5122d5b4253099" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name. Only use this function for names that refer to outer lexicals. (See also &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;newPADNAMEpvn&lt;/a&gt;.)</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다. 외부 어휘를 참조하는 이름에만이 기능을 사용하십시오. ( &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;newPADNAMEpvn&lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2e65b217a955ea30db7dba5262fee4bb7d3f1ee4" translate="yes" xml:space="preserve">
          <source>Constructs and returns an op to access &lt;code&gt;$_&lt;/code&gt; , either as a lexical variable (if declared as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ) in the current scope, or the global &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">현재 범위에서 어휘 변수 ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; $ _ 로 선언 된 경우 ) 또는 전역 &lt;code&gt;$_&lt;/code&gt; 로 &lt;code&gt;$_&lt;/code&gt; 에 액세스하기위한 op를 구성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2a4f89b89092a94b632bbcc30495e0f779fb1b98" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a conditional-expression (&lt;code&gt;cond_expr&lt;/code&gt; ) op.</source>
          <target state="translated">조건부 표현식 ( &lt;code&gt;cond_expr&lt;/code&gt; ) op를 구성, 확인 및 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a15e166f7981a3b6de1c8fa20addbc3d348e0378" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a logical (flow control) op.</source>
          <target state="translated">논리적 인 (흐름 제어) op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0264af3189ddcf2b7f625626d2ac18862a78a27" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a loop-exiting op (such as &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">루프 종료 op (예 : &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; )를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30e773cac5de3784659768f91ee0dd8d9488d2fc" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a new &lt;code&gt;stub&lt;/code&gt; op, which represents an empty list expression.</source>
          <target state="translated">빈리스트 표현을 나타내는 새로운 &lt;code&gt;stub&lt;/code&gt; op를 구축, 확인 및 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="c12d66e7978fb577b34088dcb70b91bfaa6d01da" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an &lt;code&gt;lslice&lt;/code&gt; (list slice) op.</source>
          <target state="translated">&lt;code&gt;lslice&lt;/code&gt; (목록 슬라이스) op를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ba48f5f9a71999341342f24283dfacd3a8b711b1" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an assignment op.</source>
          <target state="translated">과제 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9f565e2e42ef02d170588ec129f3ce0451ec355" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any base type (any type that has no extra fields).</source>
          <target state="translated">기본 유형 (추가 필드가없는 유형)의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="01c70184d1741ef212b465d435e97985417a8b0c" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any binary type.</source>
          <target state="translated">모든 이진 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaa434ea30a23789450d348f36bdecb9028e1240" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any list type.</source>
          <target state="translated">모든 목록 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f0e39d7609ebd71139a1fdb8c22c888dbc1b3832" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any pattern matching type.</source>
          <target state="translated">패턴 일치 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5458dc98c9452c937824a796bdb326f5e0961a85" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves a reference to a pad element.</source>
          <target state="translated">pad 요소에 대한 참조가 포함 된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40ba5d8fe10410945734740719237761dd251d13" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded C-level pointer (PV).</source>
          <target state="translated">임베디드 C 레벨 포인터 (PV)를 포함하는 모든 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97dc9643deaf81478aaf21202427a04fd76571a8" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded SV.</source>
          <target state="translated">내장 된 SV와 관련된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11846120c71e3d2b822e351f27e91e0b600f0d70" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded reference to a GV.</source>
          <target state="translated">GV에 대한 참조가 포함 된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1d063b1956e56be8e0dab06b4dad3b2a72f8365" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any unary type.</source>
          <target state="translated">단항 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be6ef2fa148c74ce9131470cb7120ad15eeee6a2" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a constant method name.</source>
          <target state="translated">상수 메소드 이름을 사용하여 메소드 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3dad86210e9b0dd94c41f8743c265b479cf1818" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a method name evaluated at runtime.</source>
          <target state="translated">런타임에 평가 된 메소드 이름을 사용하여 메소드 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4ac910e3116c4e1a0b4ad7257fc6a8a1ad7ea627" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;foreach&lt;/code&gt; loop (iteration through a list of values). This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프를 표현하는 op 트리 (값 목록을 통한 반복)를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 루프를 빠져 나갈 수있는 구조를 가진 헤비급 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="55a13424c4ba2a08e5a59cecb68e29d3affe0ee4" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 블록을 표현하는 op 트리를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fa87d1a87fb2d4ab5d631e62f196faf139c56915" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;when&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 블록을 나타내는 op 트리를 구성, 확인 및 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e9e325766c242f95f44aebbca8d081041fa05bdb" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;while&lt;/code&gt; loop. This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프를 나타내는 op 트리를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 루프를 빠져 나갈 수있는 구조를 가진 헤비급 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="c90b8188bc17094c3efa9918fac996ca1396dace" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a loop. This is only a loop in the control flow through the op tree; it does not have the heavyweight loop structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">루프를 표현하는 op 트리를 구성, 확인 및 반환합니다. 이것은 op 트리를 통한 제어 흐름의 루프 일뿐입니다. 루프 등을 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 나갈 수있는 헤비급 루프 구조가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8c8c9bb3c9bf3bfa59be4b5278462422ffe70ce9" translate="yes" xml:space="preserve">
          <source>Consult &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 및 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ec12aed4c398eee706a2f38aa675e4e5cfbdd63" translate="yes" xml:space="preserve">
          <source>Consult the match table in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; for details of when overloading is invoked.</source>
          <target state="translated">오버로드가 호출되는시기에 대한 세부 사항은 &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop의 Smartmatch Operator에서&lt;/a&gt; 일치 테이블을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca43cc0a723d7c90161c4e5b539040ca4d3086b1" translate="yes" xml:space="preserve">
          <source>Consume text in the lexer buffer, from &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; up to</source>
          <target state="translated">에서, 렉서 버퍼에 텍스트를 소비 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;&amp;gt; PL_parser- bufptr&lt;/a&gt; 까지</target>
        </trans-unit>
        <trans-unit id="712ade694782b4208a7818ba8fcb3c706be82adc" translate="yes" xml:space="preserve">
          <source>Consuming all (or nearly all) available memory.</source>
          <target state="translated">사용 가능한 모든 (또는 거의 모든) 메모리를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="bda96c5452873306650630c6976f525d6dc4916b" translate="yes" xml:space="preserve">
          <source>Contact a system administrator (preferably your own) and report the exact error message you get, and ask them to read this same documentation you are now reading. They should be able to check whether there is something wrong with the locale configuration of the system. The &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt; section is unfortunately a bit vague about the exact commands and places because these things are not that standardized.</source>
          <target state="translated">시스템 관리자 (바람직하게는 본인의 시스템 관리자)에게 연락하여 정확한 오류 메시지를보고하고 지금 읽고있는 것과 동일한 문서를 읽도록 요청하십시오. 시스템의 로케일 구성에 문제가 있는지 확인할 수 있어야합니다. &lt;a href=&quot;#Finding-locales&quot;&gt;찾기 로케일&lt;/a&gt; 이 일이 표준화되지 않습니다 때문에 섹션은 불행하게도 정확한 명령과 장소에 대한 약간 모호합니다.</target>
        </trans-unit>
        <trans-unit id="5a0be3e3d687fc1f8934755e52704c0c7e6471d4" translate="yes" xml:space="preserve">
          <source>Contact the author on &lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt; 로 저자에게 연락하십시오 .</target>
        </trans-unit>
        <trans-unit id="d62bfc367abe11a79b1d86ac7e31441eab7366c1" translate="yes" xml:space="preserve">
          <source>Contained in the file specified by the first filename on the command line. (Note that systems supporting the &lt;code&gt;#!&lt;/code&gt; notation invoke interpreters this way. See &lt;a href=&quot;#Location-of-Perl&quot;&gt;Location of Perl&lt;/a&gt;.)</source>
          <target state="translated">명령 행에서 첫 번째 파일 이름으로 지정된 파일에 포함됩니다. ( &lt;code&gt;#!&lt;/code&gt; 표기법을 지원하는 시스템 은 이러한 방식으로 인터프리터를 호출합니다. &lt;a href=&quot;#Location-of-Perl&quot;&gt;Perl의 위치를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="537701da726a37f50cd1190981e9266174458d7a" translate="yes" xml:space="preserve">
          <source>Contains routines that emulate low-level math functions in BigInt, e.g. optional routines the low-level math package does not provide on its own.</source>
          <target state="translated">BigInt에서 하위 수준 수학 함수를 에뮬레이트하는 루틴 (예 : 하위 수준 수학 패키지가 자체적으로 제공하지 않는 선택적 루틴)을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a8140068c6564fc99ecc142e17f391b1e09f6ccb" translate="yes" xml:space="preserve">
          <source>Contains the arguments of current subroutine, or the &lt;code&gt;@ARGV&lt;/code&gt; array if in the toplevel context.</source>
          <target state="translated">현재 서브 루틴의 인수 또는 최상위 컨텍스트에있는 경우 &lt;code&gt;@ARGV&lt;/code&gt; 배열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9f2a5da0585f47140af9323564aa8fb7d1d06cc4" translate="yes" xml:space="preserve">
          <source>Contains the name of the current file when reading from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 읽을 때 현재 파일의 이름을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="6178dce23f2a4c5ea5896dcce1de535426b55d99" translate="yes" xml:space="preserve">
          <source>Contains the name of the header to be included to get va_dcl definition. Typically one of</source>
          <target state="translated">va_dcl 정의를 얻기 위해 포함 할 헤더의 이름을 포함합니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="d1e0c34957a016a1b3c12f032cd551c8908cd506" translate="yes" xml:space="preserve">
          <source>Contains the name of the program being executed.</source>
          <target state="translated">실행중인 프로그램의 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2d63762428e57520df2f4f29a1e038ab7994558" translate="yes" xml:space="preserve">
          <source>Contains the prefix to use for tagging variable names in the output. The default is &quot;VAR&quot;.</source>
          <target state="translated">출력에서 변수 이름에 태그를 지정하는 데 사용할 접 두부를 포함합니다. 기본값은 &quot;VAR&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0e2da210cc9bb0a18aac5aab8614cb8e5b7b6dff" translate="yes" xml:space="preserve">
          <source>Contains the subpattern from the corresponding set of capturing parentheses from the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="translated">마지막으로 성공한 패턴 일치에서 해당 캡처 캡처 괄호 세트의 하위 패턴을 포함하며 이미 종료 된 중첩 블록과 일치하는 패턴은 계산하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="9cb23f093a42f57fb6e20b27af11bf8e322e39c5" translate="yes" xml:space="preserve">
          <source>Continent | |--&amp;gt;Country | |--&amp;gt;[state/province] | |--&amp;gt;ftp | |--&amp;gt;[http]</source>
          <target state="translated">대륙 | |-&amp;gt; 국가 | |-&amp;gt; [주 /도] | |-&amp;gt; ftp | |-&amp;gt; [http]</target>
        </trans-unit>
        <trans-unit id="5eba0b3f0a46323a9b3b38a065a8cf6fcd45e0eb" translate="yes" xml:space="preserve">
          <source>Continue until the return from the current subroutine. Dump the return value if the &lt;code&gt;PrintRet&lt;/code&gt; option is set (default).</source>
          <target state="translated">현재 서브 루틴에서 돌아올 때까지 계속하십시오. &lt;code&gt;PrintRet&lt;/code&gt; 옵션이 설정된 경우 리턴 값을 덤프하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="8cfbf2d4c02ef7cbf2f81d0785ff1541fec7f195" translate="yes" xml:space="preserve">
          <source>Continue, optionally inserting a one-time-only breakpoint at the specified line or subroutine.</source>
          <target state="translated">선택적으로 지정된 라인 또는 서브 루틴에 한 번만 중단 점을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7a39f29f66ddaa64957e3237a6a6d6ce7714c5" translate="yes" xml:space="preserve">
          <source>Contractions beginning with the specified characters are suppressed, even if those contractions are defined in &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">지정된 문자로 시작하는 수축은 수축이 &lt;code&gt;table&lt;/code&gt; 에 정의되어 있어도 억제 됩니다.</target>
        </trans-unit>
        <trans-unit id="f182d17ce2e9b56202114ddc3d06d6361dea7a8d" translate="yes" xml:space="preserve">
          <source>Contrary to popular belief, Perl 6 and Perl 5 peacefully coexist with one another. Perl 6 has proven to be a fascinating source of ideas for those using Perl 5 (the &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; object system is a well-known example). There is overlap in the communities, and this overlap fosters the tradition of sharing and borrowing that have been instrumental to Perl's success. The current leading implementation of Perl 6 is Rakudo, and you can learn more about it at &lt;a href=&quot;http://rakudo.org&quot;&gt;http://rakudo.org&lt;/a&gt;.</source>
          <target state="translated">대중의 믿음과는 달리, Perl 6과 Perl 5는 서로 평화롭게 공존합니다. Perl 6은 Perl 5를 사용하는 사람들에게 매력적인 아이디어 소스로 입증되었습니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; 객체 시스템은 잘 알려진 예입니다). 지역 사회에는 중복이 있으며,이 중복은 Perl의 성공에 도움이 된 공유 및 차용의 전통을 조성합니다. 현재 Perl 6의 주요 구현은 Rakudo이며 &lt;a href=&quot;http://rakudo.org&quot;&gt;http://rakudo.org&lt;/a&gt; 에서 이에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cc2fb5710ee22531776c8ba9e55098e2618c67c" translate="yes" xml:space="preserve">
          <source>Contrast that with an independent subexpression:</source>
          <target state="translated">독립 하위 표현식을 사용하여 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="69735e4ec537e4e29ad052c50c3613321af3383c" translate="yes" xml:space="preserve">
          <source>Contrast this with the following make_adder() function, in which the returned anonymous function contains a reference to a lexical variable outside the scope of that function itself. Such a reference requires that Perl return a proper closure, thus locking in for all time the value that the lexical had when the function was created.</source>
          <target state="translated">이것을 다음의 make_adder () 함수와 대조하십시오. 여기에서 반환 된 익명 함수는 그 함수 자체의 범위를 벗어난 어휘 변수에 대한 참조를 포함합니다. 이러한 참조는 Perl이 적절한 클로저를 리턴해야하므로 항상 함수가 작성 될 때 어휘가 갖는 값을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="e16f6173d03c0c8b09cdd1d2ddfa6f13bebfd052" translate="yes" xml:space="preserve">
          <source>Control Flow Utilities (callbacks and exceptions etc)</source>
          <target state="translated">제어 흐름 유틸리티 (콜백 및 예외 등)</target>
        </trans-unit>
        <trans-unit id="d8e3def8f1fded2e3eff4c8ea59924177caf98dc" translate="yes" xml:space="preserve">
          <source>Control VMS-specific language features</source>
          <target state="translated">VMS 관련 언어 기능 제어</target>
        </trans-unit>
        <trans-unit id="bce115b0c925643288d6d66089149032ada8c603" translate="yes" xml:space="preserve">
          <source>Control characters</source>
          <target state="translated">제어 문자</target>
        </trans-unit>
        <trans-unit id="b7fe68fe8faa99ef764732f95206a72acbe672ba" translate="yes" xml:space="preserve">
          <source>Control characters can be escaped with &lt;code&gt;\c&lt;/code&gt; , so that a control-Z character would be matched with &lt;code&gt;\cZ&lt;/code&gt; . The escape sequence &lt;code&gt;\Q&lt;/code&gt; ...&lt;code&gt;\E&lt;/code&gt; quotes, or protects most non-alphabetic characters. For instance,</source>
          <target state="translated">제어 문자는 &lt;code&gt;\c&lt;/code&gt; 로 이스케이프 할 수 있으므로 제어 Z 문자는 &lt;code&gt;\cZ&lt;/code&gt; 와 일치 합니다. 이스케이프 시퀀스 &lt;code&gt;\Q&lt;/code&gt; ... &lt;code&gt;\E&lt;/code&gt; 는 대부분의 알파벳이 아닌 문자를 인용하거나 보호합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="021626ea5dbee24ff07ea2691bf82bb74b7a5674" translate="yes" xml:space="preserve">
          <source>Control characters don't produce output as such, but instead usually control the terminal somehow: for example, newline and backspace are control characters. On ASCII platforms, in the ASCII range, characters whose code points are between 0 and 31 inclusive, plus 127 (&lt;code&gt;DEL&lt;/code&gt; ) are control characters; on EBCDIC platforms, their counterparts are control characters.</source>
          <target state="translated">제어 문자는 출력을 생성하지 않지만 대신 보통 터미널을 제어합니다. 예를 들어, 개행 및 백 스페이스는 제어 문자입니다. ASCII 플랫폼의 ASCII 범위에서 코드 포인트가 0에서 31 사이 인 문자에 127 ( &lt;code&gt;DEL&lt;/code&gt; )을 더한 문자는 제어 문자입니다. EBCDIC 플랫폼에서 해당 플랫폼은 제어 문자입니다.</target>
        </trans-unit>
        <trans-unit id="c0323bcd19431aa40d48a7a04e563e491b5de2b5" translate="yes" xml:space="preserve">
          <source>Control sort() behaviour</source>
          <target state="translated">sort () 동작 제어</target>
        </trans-unit>
        <trans-unit id="6eed236126d30fd4de8e539b1434bde859966005" translate="yes" xml:space="preserve">
          <source>Control the filetest permission operators</source>
          <target state="translated">파일 테스트 권한 연산자 제어</target>
        </trans-unit>
        <trans-unit id="1a2eedb1b60e1d8a80a133e954e55be108ac924a" translate="yes" xml:space="preserve">
          <source>Control whether the file is unlinked when the object goes out of scope. The file is removed if this value is true and $KEEP_ALL is not.</source>
          <target state="translated">객체가 범위를 벗어날 때 파일이 연결 해제되는지 여부를 제어합니다. 이 값이 true이고 $ KEEP_ALL이 아닌 경우 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e9597894a326a5dddbc5dee41019e4d31b7362ce" translate="yes" xml:space="preserve">
          <source>Controlling Warnings from the Command Line</source>
          <target state="translated">명령 줄에서 경고 제어</target>
        </trans-unit>
        <trans-unit id="68987a6a2f290ee6ca2caa6b3e7b36432344b22a" translate="yes" xml:space="preserve">
          <source>Controlling access: lock()</source>
          <target state="translated">액세스 제어 : lock ()</target>
        </trans-unit>
        <trans-unit id="a1e94cef9625b439090d57cc70615fae34127ab7" translate="yes" xml:space="preserve">
          <source>Controlling input buffering is a remarkably system-dependent matter. On many systems, you can just use the &lt;b&gt;stty&lt;/b&gt; command as shown in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;, but as you see, that's already getting you into portability snags.</source>
          <target state="translated">입력 버퍼링 제어는 시스템에 따라 크게 달라집니다. 많은 시스템 에서 &lt;a href=&quot;functions/getc&quot;&gt;getc에&lt;/a&gt; 표시된 것처럼 &lt;b&gt;stty&lt;/b&gt; 명령을 사용할 수 있지만, 이미 알 수 있듯이 이식성 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d20f10fc399adc1e8262f1893ceb51478f185a6b" translate="yes" xml:space="preserve">
          <source>Controlling where the test output goes.</source>
          <target state="translated">테스트 출력 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="07da5ac1184a4498e39e115db900514920d805cf" translate="yes" xml:space="preserve">
          <source>Controls how certain regex optimisations are applied and how much memory they utilize. This value by default is 65536 which corresponds to a 512kB temporary cache. Set this to a higher value to trade memory for speed when matching large alternations. Set it to a lower value if you want the optimisations to be as conservative of memory as possible but still occur, and set it to a negative value to prevent the optimisation and conserve the most memory. Under normal situations this variable should be of no interest to you.</source>
          <target state="translated">특정 정규식 최적화가 적용되는 방식과 이들이 사용하는 메모리 양을 제어합니다. 기본적으로이 값은 65536이며 512kB 임시 캐시에 해당합니다. 큰 교대를 일치시킬 때 속도를 위해 메모리를 교환하려면이 값을 더 높은 값으로 설정하십시오. 최적화가 가능한 한 메모리를 보존하지만 여전히 발생하게하려면 더 낮은 값으로 설정하고 최적화를 방지하고 최대 메모리를 보존하려면 음수 값으로 설정하십시오. 정상적인 상황에서이 변수는 관심이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="554cef6ea070153a4ee1bebb92008fd6058cf45d" translate="yes" xml:space="preserve">
          <source>Controls the degree to which the output can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to recreate the supplied reference structures. Setting it to 1 will output additional perl statements that will correctly recreate nested references. The default is 0.</source>
          <target state="translated">제공된 참조 구조를 재생성하기 위해 출력을 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 수있는 정도를 제어합니다 . 1로 설정하면 중첩 된 참조를 올바르게 다시 작성하는 추가 perl 문이 출력됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="acfa684e2caf08a3da5e3ef30109246db004e5da" translate="yes" xml:space="preserve">
          <source>Controls the lengths to which the module will go to check the safety of the temporary file or directory before proceeding. Options are:</source>
          <target state="translated">계속하기 전에 모듈이 임시 파일 또는 디렉토리의 안전성을 확인하는 데 걸리는 길이를 제어합니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ca7717f12fe26367883aafa8d3fbe334c1b18a2" translate="yes" xml:space="preserve">
          <source>Controls the style of indentation. It can be set to 0, 1, 2 or 3. Style 0 spews output without any newlines, indentation, or spaces between list items. It is the most compact format possible that can still be called valid perl. Style 1 outputs a readable form with newlines but no fancy indentation (each level in the structure is simply indented by a fixed amount of whitespace). Style 2 (the default) outputs a very readable form which takes into account the length of hash keys (so the hash value lines up). Style 3 is like style 2, but also annotates the elements of arrays with their index (but the comment is on its own line, so array output consumes twice the number of lines). Style 2 is the default.</source>
          <target state="translated">들여 쓰기 스타일을 조정합니다. 0, 1, 2 또는 3으로 설정할 수 있습니다. 스타일 0은 개행, 들여 쓰기 또는 목록 항목 사이의 공백없이 출력을 분출합니다. 여전히 유효한 perl이라고 할 수있는 가장 컴팩트 한 형식입니다. 스타일 1은 개행과 함께 읽을 수있는 형식을 출력하지만 멋진 들여 쓰기는 없습니다 (구조의 각 레벨은 고정 된 양의 공백으로 들여 쓰기됩니다). 스타일 2 (기본값)는 해시 키의 길이 (해시 값이 정렬 됨)를 고려하여 읽기 쉬운 형식을 출력합니다. 스타일 3은 스타일 2와 유사하지만 인덱스의 배열 요소에 주석을 추가합니다 (하지만 주석은 자체 행에 있으므로 배열 출력은 행 수의 두 배를 소비합니다). 스타일 2가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="22a31fdc3bd2e052c43c5ff90f54688767846776" translate="yes" xml:space="preserve">
          <source>Controls whether debugging messages should be enabled.</source>
          <target state="translated">디버깅 메시지를 사용할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e34cd6a1d6fc0675d9cf236e50c7a40d4f7e0985" translate="yes" xml:space="preserve">
          <source>Controls whether temporary files and directories should be retained regardless of any instructions in the program to remove them automatically. This is useful for debugging but should not be used in production code.</source>
          <target state="translated">프로그램의 지시 사항에 상관없이 임시 파일 및 디렉토리를 자동으로 제거할지 여부를 제어합니다. 디버깅에는 유용하지만 프로덕션 코드에서는 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7787de4ed8d37741fa377fafe5fdafa8b3011126" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzdeflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">압축 된 데이터가 &lt;code&gt;bzdeflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메소드 의 출력 버퍼에 추가되는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="f221020431f51974b32a3b5e2fbd634d97908661" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzinflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">압축 된 데이터가 &lt;code&gt;bzinflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메소드 의 출력 버퍼에 추가되는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="c4245dd2343e96e7d4aa52338568c9fd8977b600" translate="yes" xml:space="preserve">
          <source>Controls which compression method is used. At present four compression methods are supported, namely Store (no compression at all), Deflate, Bzip2 and Lzma.</source>
          <target state="translated">사용되는 압축 방법을 제어합니다. 현재 4 가지 압축 방법, 즉 Store (압축 없음), Deflate, Bzip2 및 Lzma가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb06b69bb4c9f83f42cb55738cfe404434afd67" translate="yes" xml:space="preserve">
          <source>Convenience macro to get the REGEXP from a SV. This is approximately equivalent to the following snippet:</source>
          <target state="translated">SV에서 REGEXP를 가져 오는 편의 매크로 이것은 다음 스 니펫과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="197b239c74a71f263a8d75330c22e4fc91bea1ec" translate="yes" xml:space="preserve">
          <source>Convenience method for building testing functions that take regular expressions as arguments.</source>
          <target state="translated">정규식을 인수로 사용하는 테스트 함수를 작성하기위한 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1f619076858d6ded347f81f166e575080deac279" translate="yes" xml:space="preserve">
          <source>Convenience methods</source>
          <target state="translated">편의 방법</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="643e483203bf1176839f0449bd1086c5d82b2884" translate="yes" xml:space="preserve">
          <source>Conversely for &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) mapping, the function named &lt;code&gt;XS_unpack_$ntype&lt;/code&gt; is called with the input Perl scalar as argument and the return value is cast to the mapped C type and assigned to the output C variable.</source>
          <target state="translated">반대로 &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) 맵핑의 경우 &lt;code&gt;XS_unpack_$ntype&lt;/code&gt; 이라는 함수 가 입력 Perl 스칼라를 인수로 사용하여 호출되며 리턴 값은 맵핑 된 C 유형으로 캐스트되고 출력 C 변수에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="12d9c05ad456b2e9dfbd26729c7d5a4582ad8668" translate="yes" xml:space="preserve">
          <source>Conversely when &lt;code&gt;Append&lt;/code&gt; is not specified, or it is present and is set to false, it will operate as follows.</source>
          <target state="translated">반대로 &lt;code&gt;Append&lt;/code&gt; 가 지정되지 않았거나 존재하고 false로 설정되면 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1099367c0a33e0960cc2a79b8c82b72aa819293c" translate="yes" xml:space="preserve">
          <source>Conversely, here is a partial solution for the task of encoding such a URL in any EBCDIC code page:</source>
          <target state="translated">반대로, 다음은 EBCDIC 코드 페이지에서 이러한 URL을 인코딩하는 작업에 대한 부분 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="0cdc49909eca70fcdaa9911c75b9017083c28375" translate="yes" xml:space="preserve">
          <source>Conversely, when setting &lt;code&gt;$?&lt;/code&gt; in an END block, an attempt is made to convert the POSIX value into a native status intelligible to the operating system upon exiting Perl. What this boils down to is that setting &lt;code&gt;$?&lt;/code&gt; to zero results in the generic success value SS$_NORMAL, and setting &lt;code&gt;$?&lt;/code&gt; to a non-zero value results in the generic failure status SS$_ABORT. See also &lt;a href=&quot;perlport#exit&quot;&gt;exit in perlport&lt;/a&gt;.</source>
          <target state="translated">반대로 &lt;code&gt;$?&lt;/code&gt; 설정할 때 ? END 블록에서 POSIX 값을 Perl 종료시 운영 체제가 이해할 수있는 기본 상태로 변환하려고 시도합니다. 이것으로 요약하면 설정은 &lt;code&gt;$?&lt;/code&gt; 0으로 설정하면 일반 성공 값 SS $ _NORMAL이 발생하고 &lt;code&gt;$?&lt;/code&gt; 0이 아닌 값으로 설정하면 일반 실패 상태 SS $ _ABORT가 발생합니다. &lt;a href=&quot;perlport#exit&quot;&gt;perlport의 exit&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42f99a69b0dbcdf11a6d0337c05dbfa48ee474e9" translate="yes" xml:space="preserve">
          <source>Conversions to and from spherical and cylindrical coordinates are available. Please notice that the conversions are not necessarily reversible because of the equalities like</source>
          <target state="translated">구면 및 원통 좌표와의 변환이 가능합니다. 다음과 같은 평등으로 인해 전환이 반드시 되돌릴 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf35c8b871a1fb1996c50ba5b0b5ab5801039529" translate="yes" xml:space="preserve">
          <source>Convert CPAN distribution metadata structures</source>
          <target state="translated">CPAN 배포 메타 데이터 구조 변환</target>
        </trans-unit>
        <trans-unit id="21841a84ce705fac7522bc0e5a625ceef2574143" translate="yes" xml:space="preserve">
          <source>Convert POD data to ASCII text with format escapes</source>
          <target state="translated">형식 이스케이프를 사용하여 POD 데이터를 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="26d9ff3691abc55fd6770d630e2e5af82498a473" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted *roff input</source>
          <target state="translated">POD 데이터를 형식화 된 * roff 입력으로 변환</target>
        </trans-unit>
        <trans-unit id="04c7609219077dfc8d84b97d557ad0e72666eb9b" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted ASCII text</source>
          <target state="translated">POD 데이터를 형식이 지정된 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="db9fd6e0fab456fdc8445a16cbc6756038a981de" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted color ASCII text</source>
          <target state="translated">POD 데이터를 형식이 지정된 색상 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="112d5a9d03872dcf431cd72fd930ebba527fc129" translate="yes" xml:space="preserve">
          <source>Convert Pod to HTML</source>
          <target state="translated">포드를 HTML로 변환</target>
        </trans-unit>
        <trans-unit id="025ffb8bfa07a8087fac34adc747a7743f7ef294" translate="yes" xml:space="preserve">
          <source>Convert a string representing an unsigned decimal number to an object representing the same number. The input is normalize, i.e., it matches &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt; .</source>
          <target state="translated">부호없는 10 진수를 나타내는 문자열을 같은 숫자를 나타내는 객체로 변환합니다. 입력은 정규화됩니다. 즉, &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="1c765e62f3e179084fe5d84bf0b2c3905b911ee2" translate="yes" xml:space="preserve">
          <source>Convert all keys to lowercase</source>
          <target state="translated">모든 키를 소문자로 변환</target>
        </trans-unit>
        <trans-unit id="7fc597b2a41ac67e1656734e7eb3b3a11b24ebbf" translate="yes" xml:space="preserve">
          <source>Convert between VMS and Unix file specification syntax</source>
          <target state="translated">VMS와 Unix 파일 사양 구문 간 변환</target>
        </trans-unit>
        <trans-unit id="22551a6fa56e0b088f54f393df223d0617c9d7fd" translate="yes" xml:space="preserve">
          <source>Convert date and time information to string. Returns the string.</source>
          <target state="translated">날짜 및 시간 정보를 문자열로 변환하십시오. 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9dcc937b46bf0f95b02e92f32e357340020b79bb" translate="yes" xml:space="preserve">
          <source>Convert date/time info to a calendar time.</source>
          <target state="translated">날짜 / 시간 정보를 달력 시간으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="c755a3bc45c556fa5a645d889408aa48ca046b43" translate="yes" xml:space="preserve">
          <source>Convert several Pod files to several HTML files</source>
          <target state="translated">여러 포드 파일을 여러 HTML 파일로 변환</target>
        </trans-unit>
        <trans-unit id="e36fcb46538b5f65c12d8c2a4fdc9c5ba89e1e4c" translate="yes" xml:space="preserve">
          <source>Convert the items to a normalised form. For 8 bit and Unicode values converts the item to an array of 1 or 2 items, both 8 bit and UTF-8 encoded.</source>
          <target state="translated">항목을 정규화 된 양식으로 변환하십시오. 8 비트 및 유니 코드 값의 경우 항목을 8 비트 및 UTF-8로 인코딩 된 1 또는 2 개의 항목 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6a89fde6d6a92b19247264815bcda3f0b2c24bd4" translate="yes" xml:space="preserve">
          <source>Converters</source>
          <target state="translated">Converters</target>
        </trans-unit>
        <trans-unit id="e602181f27c8b76305cde3933fa7a93bda7e1d5f" translate="yes" xml:space="preserve">
          <source>Converting a text string into an alternate but equivalent &lt;b&gt;canonical&lt;/b&gt; (or compatible) representation that can then be compared for equivalence. Unicode recognizes four different normalization forms: NFD, NFC, NFKD, and NFKC.</source>
          <target state="translated">텍스트 문자열을 대체하지만 동등한 &lt;b&gt;표준&lt;/b&gt; (또는 호환 가능한) 표현 으로 변환 한 후 동등성을 비교할 수 있습니다. 유니 코드는 NFD, NFC, NFKD 및 NFKC의 네 가지 정규화 형식을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a905d8ec528f352ed045a0e47323b3f945f63fbc" translate="yes" xml:space="preserve">
          <source>Converting data from one type to another. C permits this. Perl does not need it. Nor want it.</source>
          <target state="translated">한 유형에서 다른 유형으로 데이터 변환 C는 이것을 허용합니다. 펄은 필요하지 않습니다. 그것을 원하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff10e616cf0cab260f69d9d71be4dea1b4105184" translate="yes" xml:space="preserve">
          <source>Converting neutral double quotes to properly matched double quotes doesn't work unless there are no formatting codes between the quote marks. This only matters for troff output.</source>
          <target state="translated">따옴표 사이에 서식 코드가 없으면 중립 큰 따옴표를 올바르게 일치하는 큰 따옴표로 변환 할 수 없습니다. 이것은 troff 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="39ed30f1fb153d42aedc1603d4595d899a1c4eb9" translate="yes" xml:space="preserve">
          <source>Converting these two bytes to a string can be done with the unpack template &lt;code&gt;'b16'&lt;/code&gt; . To obtain the individual bit values from the bit string we use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; with the &quot;empty&quot; separator pattern which dissects into individual characters. Bit values from the &quot;reserved&quot; positions are simply assigned to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, a convenient notation for &quot;I don't care where this goes&quot;.</source>
          <target state="translated">압축 해제 템플릿 &lt;code&gt;'b16'&lt;/code&gt; 으로이 두 바이트를 문자열로 변환 할 수 있습니다 . 비트 문자열에서 개별 비트 값을 얻기 위해 개별 문자로 분리되는 &quot;빈&quot;구분 기호 패턴으로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용 합니다. &quot;예약 된&quot;위치의 비트 값은 단순히 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 할당되며 , &quot;이것은 어디로 가는지 상관하지 않습니다&quot;라는 편리한 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="872d9a7e434a3f8eac01f8a956be9ef98e1065ef" translate="yes" xml:space="preserve">
          <source>Converts</source>
          <target state="translated">Converts</target>
        </trans-unit>
        <trans-unit id="f1b0ff19255621f0cc44bdfb4998d413782b614b" translate="yes" xml:space="preserve">
          <source>Converts DOS and OS/2 linefeeds to Unix style recursively.</source>
          <target state="translated">DOS 및 OS / 2 줄 바꿈을 유닉스 스타일로 재귀 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="10562257cdade00a6b21d5534b7a854fb31311ef" translate="yes" xml:space="preserve">
          <source>Converts Perl XS code into C code</source>
          <target state="translated">Perl XS 코드를 C 코드로 변환</target>
        </trans-unit>
        <trans-unit id="3b4c118ffecc90a457e623e35d47e06d75541310" translate="yes" xml:space="preserve">
          <source>Converts a list into a string wrapped at approximately 80 columns.</source>
          <target state="translated">목록을 약 80 개의 열로 감싼 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="68b9e6f5ba88d84e905a481b6520ce3880c387ca" translate="yes" xml:space="preserve">
          <source>Converts a pod section specification to a suitable section specification for HTML. Note that we keep spaces and special characters except &lt;code&gt;&quot;, ?&lt;/code&gt; (Netscape problem) and the hyphen (writer's problem...).</source>
          <target state="translated">포드 섹션 사양을 HTML에 적합한 섹션 사양으로 변환합니다. &lt;code&gt;&quot;, ?&lt;/code&gt; (Netscape problem) 및 하이픈 (writer 's problem ...)을 제외한 공백과 특수 문자를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="49497595bfccaed317aa3b3b73a4144bb41b64d6" translate="yes" xml:space="preserve">
          <source>Converts a relative path to an absolute path.</source>
          <target state="translated">상대 경로를 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9d892d6020931849ea5043d615d0a40eee45b982" translate="yes" xml:space="preserve">
          <source>Converts a relative path to an absolute path:</source>
          <target state="translated">상대 경로를 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="66b5dd91e7acb7cb912818ec494442452642d20c" translate="yes" xml:space="preserve">
          <source>Converts a scalar into a typeglob. This is an incoercible typeglob; assigning a reference to it will assign to one of its slots, instead of overwriting it as happens with typeglobs created by SvSetSV. Converting any scalar that is SvOK() may produce unpredictable results and is reserved for perl's internal use.</source>
          <target state="translated">스칼라를 타입 글로브로 변환합니다. 이것은 강압 형 글로브입니다. 참조를 할당하면 SvSetSV에서 생성 한 typeglob에서 발생하는 것처럼 덮어 쓰지 않고 슬롯 중 하나에 할당됩니다. SvOK () 인 스칼라를 변환하면 예측할 수없는 결과가 생성 될 수 있으며 perl의 내부 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf47bd965a32350de298ea4a1bd9d84f13c4c78" translate="yes" xml:space="preserve">
          <source>Converts a sorting key into its representation form. If &lt;code&gt;UCA_Version&lt;/code&gt; is 8, the output is slightly different.</source>
          <target state="translated">정렬 키를 표현 형식으로 변환합니다. 경우 &lt;code&gt;UCA_Version&lt;/code&gt; 는 8, 출력은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e09251ed3a676eb23e02a6f2269b32e4facc6e9a" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; bytes from the native encoding into UTF-8. Returns a pointer to the newly-created string, and sets &lt;code&gt;len&lt;/code&gt; to reflect the new length in bytes.</source>
          <target state="translated">변환 된 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; UTF-8로 기본 인코딩 바이트. 새로 만든 문자열에 대한 포인터를 반환하고 &lt;code&gt;len&lt;/code&gt; 을 설정 하여 새 길이를 바이트 단위로 반영합니다.</target>
        </trans-unit>
        <trans-unit id="25e23f0e18e40bbf0fb5c8f36fb8ccc5209e18d9" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; from UTF-8 into native byte encoding. Unlike &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt;, this over-writes the original string, and updates &lt;code&gt;len&lt;/code&gt; to contain the new length. Returns zero on failure, setting &lt;code&gt;len&lt;/code&gt; to -1.</source>
          <target state="translated">변환 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; 네이티브 바이트 인코딩으로 UTF-8로. &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt; 과 달리 원래 문자열을 덮어 쓰고 &lt;code&gt;len&lt;/code&gt; 을 업데이트 하여 새 길이를 포함합니다. 실패시 0을 반환하고 &lt;code&gt;len&lt;/code&gt; 을 -1로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c9aaa9139532e77f8d3100c51e3d0b848d4c571b" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; from UTF-8 into native byte encoding. Unlike &lt;a href=&quot;#utf8_to_bytes&quot;&gt;utf8_to_bytes&lt;/a&gt; but like &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt;, returns a pointer to the newly-created string, and updates &lt;code&gt;len&lt;/code&gt; to contain the new length. Returns the original string if no conversion occurs, &lt;code&gt;len&lt;/code&gt; is unchanged. Do nothing if &lt;code&gt;is_utf8&lt;/code&gt; points to 0. Sets &lt;code&gt;is_utf8&lt;/code&gt; to 0 if &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is converted or consisted entirely of characters that are invariant in utf8 (i.e., US-ASCII on non-EBCDIC machines).</source>
          <target state="translated">변환 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; 네이티브 바이트 인코딩으로 UTF-8로. 달리 &lt;a href=&quot;#utf8_to_bytes&quot;&gt;utf8_to_bytes&lt;/a&gt; 하지만 같은 &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt; , 새로 만든 문자열에 대한 포인터를 반환하고 업데이트 &lt;code&gt;len&lt;/code&gt; 새 길이를 포함 할 수 있습니다. 변환이 발생하지 않으면 원래 문자열을 반환하고 &lt;code&gt;len&lt;/code&gt; 은 변경되지 않습니다. 경우 아무것도하지 &lt;code&gt;is_utf8&lt;/code&gt; 0으로 세트 포인트 &lt;code&gt;is_utf8&lt;/code&gt; 경우 0 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 변환 또는 완전히 UTF8에서 일정 문자로 구성되어있다 (즉, US-ASCII가 아닌 EBCDIC 기계에).</target>
        </trans-unit>
        <trans-unit id="57ad9fed6045b19b9f737301c45af3031d5885f4" translate="yes" xml:space="preserve">
          <source>Converts a string into something presentable, handling escaping via pv_escape() and supporting quoting and ellipses.</source>
          <target state="translated">pv_escape ()를 통한 이스케이프 처리 및 인용 부호와 생략 부호를 지원하여 문자열을 표현 가능한 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="985fbcc4acdc3a7d9cb06fa3db4de16008517d11" translate="yes" xml:space="preserve">
          <source>Converts a time as returned by the time function to a 9-element list with the time analyzed for the local time zone. Typically used as follows:</source>
          <target state="translated">시간 함수에 의해 반환 된 시간을 현지 시간대에 대해 분석 된 시간이있는 9 요소 목록으로 변환합니다. 일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df456bac0ead4ef5d6822c04fb63b24887c0fcbb" translate="yes" xml:space="preserve">
          <source>Converts die(...) to croak(...)</source>
          <target state="translated">die (...)를 croak (...)로 변환</target>
        </trans-unit>
        <trans-unit id="ab7d6db5ad0a6af07725954c367981536f9b78b6" translate="yes" xml:space="preserve">
          <source>Converts files from pod format (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) to HTML format. It can automatically generate indexes and cross-references, and it keeps a cache of things it knows how to cross-reference.</source>
          <target state="translated">파일을 포드 형식 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )에서 HTML 형식 으로 변환합니다 . 인덱스와 상호 참조를 자동으로 생성 할 수 있으며 상호 참조 방법을 알고있는 것들의 캐시를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0d36251afb146d0c47c8632d04ba280e7678c879" translate="yes" xml:space="preserve">
          <source>Converts files from pod format (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) to HTML format.</source>
          <target state="translated">파일을 포드 형식 ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )에서 HTML 형식 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4c3911f04371bd3f5a9edcc045060266cb007b3" translate="yes" xml:space="preserve">
          <source>Converts in-place the character sequence to the corresponding octet sequence in</source>
          <target state="translated">현재 위치에서 문자 시퀀스를 해당 옥텟 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1f8d941153ff67ac1c72faf751cbeb55c8bc3ffd" translate="yes" xml:space="preserve">
          <source>Converts in-place the internal representation of the string from</source>
          <target state="translated">내부에서 문자열의 내부 표현을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d8b721335ac74a399b53a4c7b83d6d6e77dad793" translate="yes" xml:space="preserve">
          <source>Converts in-place the internal representation of the string from an octet sequence in the native encoding (Latin-1 or EBCDIC) to</source>
          <target state="translated">네이티브 인코딩 (Latin-1 또는 EBCDIC)의 옥텟 시퀀스에서 문자열의 내부 표현을 제자리로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="693d5393f2c198b06d62ba43ecdf4f6431cd33c1" translate="yes" xml:space="preserve">
          <source>Converts package specifiers from ' to ::</source>
          <target state="translated">패키지 지정자를 '에서 ::로 변환</target>
        </trans-unit>
        <trans-unit id="75d0a666542f6f624e396b88276d95cb7e5e33ef" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to UTF-8, but then turns the &lt;code&gt;SvUTF8&lt;/code&gt; flag off so that it looks like octets again.</source>
          <target state="translated">SV의 PV를 UTF-8로 변환 한 다음 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 끄고 다시 옥텟처럼 보이게합니다.</target>
        </trans-unit>
        <trans-unit id="8e31e6f885da29a23f47b2b49d056556f7053dad" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to string form if it is not already. Always sets the SvUTF8 flag to avoid future validity checks even if all the bytes are invariant in UTF-8. If &lt;code&gt;flags&lt;/code&gt; has &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate, else not.</source>
          <target state="translated">SV의 PV를 UTF-8 인코딩 형식으로 변환합니다. SV가 문자열 형식이 아닌 경우이를 강제로 문자열로 만듭니다. 모든 바이트가 UTF-8에서 변하지 않더라도 향후 유효성 검사를 피하기 위해 항상 SvUTF8 플래그를 설정합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 가 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당하는 경우, 다른 없습니다.</target>
        </trans-unit>
        <trans-unit id="2eaeedbacb6754f3bf67d2ff185622d62fb661fa" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to string form if it is not already. Will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate. Always sets the SvUTF8 flag to avoid future validity checks even if the whole string is the same in UTF-8 as not. Returns the number of bytes in the converted string</source>
          <target state="translated">SV의 PV를 UTF-8 인코딩 형식으로 변환합니다. SV가 문자열 형식이 아닌 경우이를 강제로 문자열로 만듭니다. 윌 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당되는 경우. 전체 문자열이 UTF-8에서 동일하지 않더라도 향후 유효성 검사를 피하도록 항상 SvUTF8 플래그를 설정하십시오. 변환 된 문자열의 바이트 수를 반환합니다</target>
        </trans-unit>
        <trans-unit id="d858a4518b8e2b0edbb72d67957101032b8b2eb8" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 foldcase 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 접는 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="52e572e9590b1d15237c9891ad99225648f02174" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 소문자 버전으로 변환하고 UTF-8로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 소문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1a058c8fc2f6f2b47b13e70622269534e295cc45" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its titlecase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the titlecase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 제목 케이스 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 타이틀 케이스 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="fe4a9e2cd918385161f10e124e4741e692641e86" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its uppercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the uppercase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 대문자 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 대문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c3a3eb4c108a356b7fa84675b8535c22195fbd62" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 foldcase 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 접는 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d979a580aaef23727c36debd38227c49408a9b47" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 소문자 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 소문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="26f7f9dab73dba77fbe7d1b19eddf8f73d1b5671" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its titlecase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the titlecase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 제목 케이스 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트 단위로 저장 합니다. 타이틀 케이스 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="45a23ff030e1856fb80fa2a5c1977970b50af607" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its uppercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the uppercase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 대문자 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 대문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c3d6ca1c2f0c8dcb86d38412b232b00c790cee63" translate="yes" xml:space="preserve">
          <source>Converts the distdir into a shell archive.</source>
          <target state="translated">distdir을 쉘 아카이브로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0cf90c7998d2448281ddcaab8fbf0e0504c17afc" translate="yes" xml:space="preserve">
          <source>Converts the name of a C source file to the most natural name of an output object file to create from it. For instance, on Unix the source file</source>
          <target state="translated">C 소스 파일의 이름을 생성 할 출력 오브젝트 파일의 가장 자연스러운 이름으로 변환합니다. 예를 들어, 유닉스에서 소스 파일</target>
        </trans-unit>
        <trans-unit id="294bcf2fccd9227784487d719b1402d9277e26d7" translate="yes" xml:space="preserve">
          <source>Converts the name of an object file to the most natural name of a output library file to create from it. For instance, on Mac OS X the object file</source>
          <target state="translated">오브젝트 파일 이름을 작성하기 위해 가장 자연스러운 출력 라이브러리 파일 이름으로 변환합니다. 예를 들어, Mac OS X에서 객체 파일</target>
        </trans-unit>
        <trans-unit id="a88553ec1e53f9448f2a6cf55dbbb5a77e63eaea" translate="yes" xml:space="preserve">
          <source>Converts the name of an object file to the most natural name of an executable file to create from it. For instance, on Mac OS X the object file</source>
          <target state="translated">객체 파일 이름을 생성 할 수있는 가장 자연스러운 실행 파일 이름으로 변환합니다. 예를 들어, Mac OS X에서 객체 파일</target>
        </trans-unit>
        <trans-unit id="bd026beb328c8d2f6c169ba8bd729c19b9c13311" translate="yes" xml:space="preserve">
          <source>Converts the offset from a count of UTF-8 chars from the start of the string, to a count of the equivalent number of bytes; if lenp is non-zero, it does the same to lenp, but this time starting from the offset, rather than from the start of the string. Handles type coercion.</source>
          <target state="translated">문자열의 시작 부분에서 UTF-8 문자 수의 오프셋을 동등한 바이트 수로 변환합니다. lenp가 0이 아닌 경우 lenp와 동일하지만 이번에는 문자열의 시작이 아니라 오프셋에서 시작합니다. 유형 강제를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="00d51fe700c6a5db38a413be18aee4d817d83eb5" translate="yes" xml:space="preserve">
          <source>Converts the offset from a count of bytes from the start of the string, to a count of the equivalent number of UTF-8 chars. Handles type coercion.</source>
          <target state="translated">문자열의 시작에서 바이트 수에서 오프셋을 동등한 수의 UTF-8 문자 수로 변환합니다. 유형 강제를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="29fc75feba3b4414c8baae81dd1c2325b9e8ab51" translate="yes" xml:space="preserve">
          <source>Converts the specified Latin1 character to lowercase. The results are undefined if the input doesn't fit in a byte.</source>
          <target state="translated">지정된 Latin1 문자를 소문자로 변환합니다. 입력이 바이트에 맞지 않으면 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c20384152ac3c169167a164a1d915c66eb3398e" translate="yes" xml:space="preserve">
          <source>Converts the specified character to foldcase. If the input is anything but an ASCII uppercase character, that input character itself is returned. Variant &lt;code&gt;toFOLD_A&lt;/code&gt; is equivalent. (There is no equivalent &lt;code&gt;to_FOLD_L1&lt;/code&gt; for the full Latin1 range, as the full generality of &lt;a href=&quot;#toFOLD_uni&quot;&gt;toFOLD_uni&lt;/a&gt; is needed there.)</source>
          <target state="translated">지정된 문자를 소문자로 변환합니다. 입력이 ASCII 대문자 이외의 문자 인 경우 해당 입력 문자 자체가 반환됩니다. &lt;code&gt;toFOLD_A&lt;/code&gt; 변형 은 동일합니다. (상응 없다 &lt;code&gt;to_FOLD_L1&lt;/code&gt; 의 전체 일반성으로 전체 라틴어 범위는 &lt;a href=&quot;#toFOLD_uni&quot;&gt;toFOLD_uni이&lt;/a&gt; 가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="7775e6edae290c80035bdde5ee180cafb1a95c9a" translate="yes" xml:space="preserve">
          <source>Converts the specified character to lowercase using the current locale's rules, if possible; otherwise returns the input character itself.</source>
          <target state="translated">가능한 경우 현재 로캘의 규칙을 사용하여 지정된 문자를 소문자로 변환합니다. 그렇지 않으면 입력 문자 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f3b386523ea039f2b6d6f2c24bea443697341ca" translate="yes" xml:space="preserve">
          <source>Converts the specified character to lowercase. If the input is anything but an ASCII uppercase character, that input character itself is returned. Variant &lt;code&gt;toLOWER_A&lt;/code&gt; is equivalent.</source>
          <target state="translated">지정된 문자를 소문자로 변환합니다. 입력이 ASCII 대문자 이외의 문자 인 경우 해당 입력 문자 자체가 반환됩니다. &lt;code&gt;toLOWER_A&lt;/code&gt; 에 대한 변형 은 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c7f73f6dc4ef675e0ea0c8a1169c8b80eea8488" translate="yes" xml:space="preserve">
          <source>Converts the specified character to titlecase. If the input is anything but an ASCII lowercase character, that input character itself is returned. Variant &lt;code&gt;toTITLE_A&lt;/code&gt; is equivalent. (There is no &lt;code&gt;toTITLE_L1&lt;/code&gt; for the full Latin1 range, as the full generality of &lt;a href=&quot;#toTITLE_uni&quot;&gt;toTITLE_uni&lt;/a&gt; is needed there. Titlecase is not a concept used in locale handling, so there is no functionality for that.)</source>
          <target state="translated">지정된 문자를 제목으로 변환합니다. 입력이 ASCII 소문자 이외의 입력 인 경우 해당 입력 문자 자체가 반환됩니다. &lt;code&gt;toTITLE_A&lt;/code&gt; 변형 은 동일합니다. (전혀 없다 &lt;code&gt;toTITLE_L1&lt;/code&gt; 의 전체 일반성으로 전체 라틴어 범위는 &lt;a href=&quot;#toTITLE_uni&quot;&gt;toTITLE_uni이&lt;/a&gt; 가 필요합니다. 타이틀 케이스 로케일 처리에 사용되는 개념이 아니다, 그래서에 대한 기능이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="38943cd0db5a909d68224b0f5858aec10b5fbd97" translate="yes" xml:space="preserve">
          <source>Converts the specified character to uppercase. If the input is anything but an ASCII lowercase character, that input character itself is returned. Variant &lt;code&gt;toUPPER_A&lt;/code&gt; is equivalent.</source>
          <target state="translated">지정된 문자를 대문자로 변환합니다. 입력이 ASCII 소문자 이외의 입력 인 경우 해당 입력 문자 자체가 반환됩니다. &lt;code&gt;toUPPER_A&lt;/code&gt; 변형 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cbfe95a5d57e473ed974a2c8dd7b4c3a3dc6f133" translate="yes" xml:space="preserve">
          <source>Converts the tarfile into a uuencoded file</source>
          <target state="translated">tarfile을 uuencoded 파일로 변환</target>
        </trans-unit>
        <trans-unit id="8105a421b149b241dd9345f828f8405806dc4509" translate="yes" xml:space="preserve">
          <source>Converts the value pointed to by offsetp from a count of UTF-8 chars from the start of the string, to a count of the equivalent number of bytes; if lenp is non-zero, it does the same to lenp, but this time starting from the offset, rather than from the start of the string. Handles magic and type coercion.</source>
          <target state="translated">문자열의 시작 부분에서 UTF-8 문자 수에서 offsetp가 가리키는 값을 동등한 바이트 수로 변환합니다. lenp가 0이 아닌 경우 lenp와 동일하지만 이번에는 문자열의 시작이 아니라 오프셋에서 시작합니다. 마법과 유형 강압을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="40b55cad996caa19ed6d279ac88d5fa4b681b529" translate="yes" xml:space="preserve">
          <source>Converts the value pointed to by offsetp from a count of bytes from the start of the string, to a count of the equivalent number of UTF-8 chars. Handles magic and type coercion.</source>
          <target state="translated">문자열 시작에서 바이트 수에서 offsetp로 가리키는 값을 동등한 UTF-8 문자 수로 변환합니다. 마법과 유형 강압을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a9134f42b0fc69f710ef38795745edc87cc85d2d" translate="yes" xml:space="preserve">
          <source>Cooperative multitasking systems have running threads give up control if one of two things happen. If a thread calls a yield function, it gives up control. It also gives up control if the thread does something that would cause it to block, such as perform I/O. In a cooperative multitasking implementation, one thread can starve all the others for CPU time if it so chooses.</source>
          <target state="translated">협력적인 멀티 태스킹 시스템에는 실행중인 스레드가있어 두 가지 중 하나가 발생하면 제어권을 포기합니다. 스레드가 yield 함수를 호출하면 제어를 포기합니다. 또한 스레드가 I / O 수행과 같이 스레드를 차단할 수있는 작업을 수행하는지 제어합니다. 협력적인 멀티 태스킹 구현에서 하나의 스레드는 다른 스레드가 원하는 경우 CPU 시간 동안 모든 스레드를 고갈시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d032796f15a64112e4e06fa18894fca88d7a2f99" translate="yes" xml:space="preserve">
          <source>Copied from &lt;a href=&quot;../ipc/cmd#%24path-%3d-can_run(-PROGRAM-)%3b&quot;&gt;IPC::Cmd&lt;/a&gt;, but modified into a method (and removed &lt;code&gt;$INSTANCES&lt;/code&gt; capability).</source>
          <target state="translated">&lt;a href=&quot;../ipc/cmd#%24path-%3d-can_run(-PROGRAM-)%3b&quot;&gt;IPC :: Cmd&lt;/a&gt; 에서 복사 되었지만 메소드로 수정되었으며 &lt;code&gt;$INSTANCES&lt;/code&gt; 기능이 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="58da612a1bc6d614d12d58ef8797a656a94e658e" translate="yes" xml:space="preserve">
          <source>Copies a double into a new SV, optionally blessing the SV. The &lt;code&gt;rv&lt;/code&gt; argument will be upgraded to an RV. That RV will be modified to point to the new SV. The &lt;code&gt;classname&lt;/code&gt; argument indicates the package for the blessing. Set &lt;code&gt;classname&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt; to avoid the blessing. The new SV will have a reference count of 1, and the RV will be returned.</source>
          <target state="translated">선택적으로 SV를 축복하여 새 SV에 이중을 복사합니다. &lt;code&gt;rv&lt;/code&gt; 인수는 RV로 업그레이드됩니다. 그 RV는 새로운 SV를 가리 키도록 수정 될 것입니다. &lt;code&gt;classname&lt;/code&gt; 인수는 축복의 패키지를 나타냅니다. 축복을 피하려면 &lt;code&gt;classname&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 새로운 SV의 참조 카운트는 1이며 RV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c347bb9b827a2334958f6bf2f2ca6f534daeac0e" translate="yes" xml:space="preserve">
          <source>Copies a double into the given SV, upgrading first if necessary. Does not handle 'set' magic. See also &lt;code&gt;sv_setnv_mg&lt;/code&gt; .</source>
          <target state="translated">주어진 SV에 이중을 복사하여 필요한 경우 먼저 업그레이드합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setnv_mg&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b27095a6cd52e5d6134280b02b569beed020d999" translate="yes" xml:space="preserve">
          <source>Copies a pointer into a new SV, optionally blessing the SV. The &lt;code&gt;rv&lt;/code&gt; argument will be upgraded to an RV. That RV will be modified to point to the new SV. If the &lt;code&gt;pv&lt;/code&gt; argument is NULL then &lt;code&gt;PL_sv_undef&lt;/code&gt; will be placed into the SV. The &lt;code&gt;classname&lt;/code&gt; argument indicates the package for the blessing. Set &lt;code&gt;classname&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt; to avoid the blessing. The new SV will have a reference count of 1, and the RV will be returned.</source>
          <target state="translated">선택적으로 SV를 축복하여 새 SV에 포인터를 복사합니다. &lt;code&gt;rv&lt;/code&gt; 인수는 RV로 업그레이드됩니다. 그 RV는 새로운 SV를 가리 키도록 수정 될 것입니다. 는 IF &lt;code&gt;pv&lt;/code&gt; 인수가 다음 NULL &lt;code&gt;PL_sv_undef&lt;/code&gt; 는 목표 값에 배치됩니다. &lt;code&gt;classname&lt;/code&gt; 인수는 축복의 패키지를 나타냅니다. 축복을 피하려면 &lt;code&gt;classname&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 새로운 SV의 참조 카운트는 1이며 RV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1786cfa4001f16d4465ff1be0891e50c99f2c03f" translate="yes" xml:space="preserve">
          <source>Copies a string (possibly containing embedded &lt;code&gt;NUL&lt;/code&gt; characters) into an SV. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to be copied. If the &lt;code&gt;ptr&lt;/code&gt; argument is NULL the SV will become undefined. Does not handle 'set' magic. See &lt;code&gt;sv_setpvn_mg&lt;/code&gt; .</source>
          <target state="translated">문자열 (포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자 를 포함 할 수 있음 )을 SV에 복사합니다 . &lt;code&gt;len&lt;/code&gt; 매개 변수는 바이트 수를 복사 할 나타냅니다. 는 IF &lt;code&gt;ptr&lt;/code&gt; 인수가 NULL 인 SV는 정의 될 것이다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setpvn_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d174a878d53f27a45b16e4832647c4bb0c4f91eb" translate="yes" xml:space="preserve">
          <source>Copies a string into a new SV, optionally blessing the SV. The length of the string must be specified with &lt;code&gt;n&lt;/code&gt; . The &lt;code&gt;rv&lt;/code&gt; argument will be upgraded to an RV. That RV will be modified to point to the new SV. The &lt;code&gt;classname&lt;/code&gt; argument indicates the package for the blessing. Set &lt;code&gt;classname&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt; to avoid the blessing. The new SV will have a reference count of 1, and the RV will be returned.</source>
          <target state="translated">문자열을 새 SV에 복사하고 선택적으로 SV를 축복합니다. 문자열의 길이는 &lt;code&gt;n&lt;/code&gt; 으로 지정해야합니다 . &lt;code&gt;rv&lt;/code&gt; 인수는 RV로 업그레이드됩니다. 그 RV는 새로운 SV를 가리 키도록 수정 될 것입니다. &lt;code&gt;classname&lt;/code&gt; 인수는 축복의 패키지를 나타냅니다. 축복을 피하려면 &lt;code&gt;classname&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 새로운 SV의 참조 카운트는 1이며 RV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2cc17ff1663cdcd5ccc34774a29afbe226d6bde7" translate="yes" xml:space="preserve">
          <source>Copies a string into an SV. The string must be terminated with a &lt;code&gt;NUL&lt;/code&gt; character. Does not handle 'set' magic. See &lt;code&gt;sv_setpv_mg&lt;/code&gt; .</source>
          <target state="translated">문자열을 SV에 복사합니다. 문자열은 &lt;code&gt;NUL&lt;/code&gt; 문자 로 끝나야합니다 . '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setpv_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acd7e631f37132f2461a9f4128a317eb4d34d689" translate="yes" xml:space="preserve">
          <source>Copies a stringified representation of the source SV into the destination SV. Automatically performs any necessary mg_get and coercion of numeric values into strings. Guaranteed to preserve UTF8 flag even from overloaded objects. Similar in nature to sv_2pv[_flags] but operates directly on an SV instead of just the string. Mostly uses sv_2pv_flags to do its work, except when that would lose the UTF-8'ness of the PV.</source>
          <target state="translated">소스 SV의 문자열 화 된 표현을 대상 SV에 복사합니다. 필요한 mg_get 및 숫자 값을 문자열로 강제 변환합니다. 오버로드 된 오브젝트에서도 UTF8 플래그를 보존합니다. 본질적으로 sv_2pv [_flags]와 유사하지만 문자열 대신 SV에서 직접 작동합니다. PV의 UTF-8을 잃을 때를 제외하고는 대부분 sv_2pv_flags를 사용하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1ceb5498aa08b64599a670ddd20b40acf24c2850" translate="yes" xml:space="preserve">
          <source>Copies all the files that are in the MANIFEST file to a newly created directory with the name &lt;code&gt;$(DISTNAME)-$(VERSION)&lt;/code&gt;. If that directory exists, it will be removed first.</source>
          <target state="translated">MANIFEST 파일에있는 모든 파일을 이름이 &lt;code&gt;$(DISTNAME)-$(VERSION)&lt;/code&gt; 새로 작성된 디렉토리에 복사합니다 . 해당 디렉토리가 존재하면 먼저 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5a43cdae0ae6da25d7ce8fda19fe8a78a5ff5d" translate="yes" xml:space="preserve">
          <source>Copies an integer into a new SV, optionally blessing the SV. The &lt;code&gt;rv&lt;/code&gt; argument will be upgraded to an RV. That RV will be modified to point to the new SV. The &lt;code&gt;classname&lt;/code&gt; argument indicates the package for the blessing. Set &lt;code&gt;classname&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt; to avoid the blessing. The new SV will have a reference count of 1, and the RV will be returned.</source>
          <target state="translated">정수를 새 SV에 복사하고 선택적으로 SV를 축복합니다. &lt;code&gt;rv&lt;/code&gt; 인수는 RV로 업그레이드됩니다. 그 RV는 새로운 SV를 가리 키도록 수정 될 것입니다. &lt;code&gt;classname&lt;/code&gt; 인수는 축복의 패키지를 나타냅니다. 축복을 피하려면 &lt;code&gt;classname&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 새로운 SV의 참조 카운트는 1이며 RV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="87655bfb9567748496e5eaf66f62a786876d2425" translate="yes" xml:space="preserve">
          <source>Copies an integer into the given SV, also updating its string value. Does not handle 'set' magic. See &lt;code&gt;sv_setpviv_mg&lt;/code&gt; .</source>
          <target state="translated">주어진 SV에 정수를 복사하고 문자열 값도 업데이트합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setpviv_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f2eb4580cc9eaa76949e7acc7122330f226683c" translate="yes" xml:space="preserve">
          <source>Copies an integer into the given SV, upgrading first if necessary. Does not handle 'set' magic. See also &lt;code&gt;sv_setiv_mg&lt;/code&gt; .</source>
          <target state="translated">주어진 SV에 정수를 복사하여 필요한 경우 먼저 업그레이드합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setiv_mg&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3984d0cef29ac256b94baf888dc25a6bab8951" translate="yes" xml:space="preserve">
          <source>Copies an unsigned integer into a new SV, optionally blessing the SV. The &lt;code&gt;rv&lt;/code&gt; argument will be upgraded to an RV. That RV will be modified to point to the new SV. The &lt;code&gt;classname&lt;/code&gt; argument indicates the package for the blessing. Set &lt;code&gt;classname&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt; to avoid the blessing. The new SV will have a reference count of 1, and the RV will be returned.</source>
          <target state="translated">부호없는 정수를 새 SV에 복사하고 선택적으로 SV를 축복합니다. &lt;code&gt;rv&lt;/code&gt; 인수는 RV로 업그레이드됩니다. 그 RV는 새로운 SV를 가리 키도록 수정 될 것입니다. &lt;code&gt;classname&lt;/code&gt; 인수는 축복의 패키지를 나타냅니다. 축복을 피하려면 &lt;code&gt;classname&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정하십시오 . 새로운 SV의 참조 카운트는 1이며 RV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="817708bbdae5a3bc2e1729daf57c7384a8ed11df" translate="yes" xml:space="preserve">
          <source>Copies an unsigned integer into the given SV, upgrading first if necessary. Does not handle 'set' magic. See also &lt;code&gt;sv_setuv_mg&lt;/code&gt; .</source>
          <target state="translated">부호없는 정수를 지정된 SV에 복사하고 필요한 경우 먼저 업그레이드합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setuv_mg&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f42b69b0be33ffa2663dc670be8d62b1f6b76a37" translate="yes" xml:space="preserve">
          <source>Copies each directory tree of %from_to to its corresponding value preserving timestamps and permissions.</source>
          <target state="translated">타임 스탬프 및 권한을 유지하는 % from_to의 각 디렉토리 트리를 해당 값으로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="547ef09412d01381bdd77f45cd22559f6b5f129c" translate="yes" xml:space="preserve">
          <source>Copies each key of %from_to to its corresponding value efficiently. Filenames with the extension .pm are autosplit into the $autosplit_dir. Any destination directories are created.</source>
          <target state="translated">% from_to의 각 키를 해당 값으로 효율적으로 복사합니다. 확장자가 .pm 인 파일 이름은 $ autosplit_dir에 자동 분할됩니다. 모든 대상 디렉토리가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8b4556d985cc8c666fe1310a61eb0e2bd704d901" translate="yes" xml:space="preserve">
          <source>Copies sources to the destination. Multiple sources are allowed if destination is an existing directory.</source>
          <target state="translated">소스를 대상에 복사합니다. 대상이 기존 디렉토리 인 경우 여러 소스가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="22aa8bfe9c7cb3953e35f5697eea8150b160ffab" translate="yes" xml:space="preserve">
          <source>Copies the contents of the source SV &lt;code&gt;ssv&lt;/code&gt; into the destination SV &lt;code&gt;dsv&lt;/code&gt; . The source SV may be destroyed if it is mortal, so don't use this function if the source SV needs to be reused. Does not handle 'set' magic on destination SV. Calls 'get' magic on source SV. Loosely speaking, it performs a copy-by-value, obliterating any previous content of the destination.</source>
          <target state="translated">소스 SV &lt;code&gt;ssv&lt;/code&gt; 의 내용을 대상 SV &lt;code&gt;dsv&lt;/code&gt; 에 복사 합니다. 소스 SV는 필멸의 경우 소멸 될 수 있으므로 소스 SV를 재사용해야하는 경우이 기능을 사용하지 마십시오. 대상 SV에서 '설정'마법을 처리하지 않습니다. 소스 SV에서 'get'매직을 호출합니다. 느슨하게 말하면 값으로 복사를 수행하여 대상의 이전 내용을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="60fc994ce68e4c7b21a4843b708d86bf7c3db663" translate="yes" xml:space="preserve">
          <source>Copies the contents of the source SV &lt;code&gt;ssv&lt;/code&gt; into the destination SV &lt;code&gt;dsv&lt;/code&gt; . The source SV may be destroyed if it is mortal, so don't use this function if the source SV needs to be reused. Does not handle 'set' magic. Loosely speaking, it performs a copy-by-value, obliterating any previous content of the destination. If the &lt;code&gt;flags&lt;/code&gt; parameter has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;ssv&lt;/code&gt; if appropriate, else not. If the &lt;code&gt;flags&lt;/code&gt; parameter has the &lt;code&gt;SV_NOSTEAL&lt;/code&gt; bit set then the buffers of temps will not be stolen. &amp;lt;sv_setsv&amp;gt; and &lt;code&gt;sv_setsv_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">소스 SV &lt;code&gt;ssv&lt;/code&gt; 의 내용을 대상 SV &lt;code&gt;dsv&lt;/code&gt; 에 복사 합니다. 소스 SV는 필멸의 경우 소멸 될 수 있으므로 소스 SV를 재사용해야하는 경우이 기능을 사용하지 마십시오. '세트'마법을 처리하지 않습니다. 느슨하게 말하면 값으로 복사를 수행하여 대상의 이전 내용을 제거합니다. 는 IF &lt;code&gt;flags&lt;/code&gt; 이 매개 변수 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 의 비트 세트는 것 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;ssv&lt;/code&gt; 적절한 경우, 다른 없습니다. 경우 &lt;code&gt;flags&lt;/code&gt; 이 매개 변수 &lt;code&gt;SV_NOSTEAL&lt;/code&gt; 의 비트 세트는 다음 임시 직원의 버퍼가 도난되지 않습니다. &amp;lt;sv_setsv&amp;gt; 및 &lt;code&gt;sv_setsv_nomg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="847212512bee6cfe3c2fc61106e5643ef825dc7e" translate="yes" xml:space="preserve">
          <source>Copies the files that are the keys in %src to the $dest_dir. %src is typically returned by the maniread() function.</source>
          <target state="translated">% src의 키인 파일을 $ dest_dir에 복사합니다. % src는 일반적으로 maniread () 함수에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e68b585bfbe265f09cd9d4efb3e0feed1b83417" translate="yes" xml:space="preserve">
          <source>Copies the magic from one SV to another. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">한 SV에서 다른 SV로 마술을 복사합니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="844182ad4ab003932666f9c6d69d92cbb8e46845" translate="yes" xml:space="preserve">
          <source>Coping with duplicate mappings</source>
          <target state="translated">중복 매핑 처리</target>
        </trans-unit>
        <trans-unit id="82e1de5d54543510504259bd75e1005b5001c11a" translate="yes" xml:space="preserve">
          <source>Copy Constructor</source>
          <target state="translated">생성자 복사</target>
        </trans-unit>
        <trans-unit id="5534252cfc67f8ea30c5aeb4b712455aa3844020" translate="yes" xml:space="preserve">
          <source>Copy files or filehandles</source>
          <target state="translated">파일 또는 파일 핸들 복사</target>
        </trans-unit>
        <trans-unit id="8f8861ebe6be1c187f524367a7e8796012ce6621" translate="yes" xml:space="preserve">
          <source>Copy it from there to %PlatformSDKDir%\Bin</source>
          <target state="translated">거기에서 % PlatformSDKDir % \ Bin으로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="262ea28b5df50512a45d54b1fa1054f3be93e5d2" translate="yes" xml:space="preserve">
          <source>Copy on Write</source>
          <target state="translated">쓰기시 복사</target>
        </trans-unit>
        <trans-unit id="a4bc97f3ddf500700682ce93b45d0b65e29cc177" translate="yes" xml:space="preserve">
          <source>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic doesn't (eg taint, pos).</source>
          <target state="translated">기존 SV의 일부 마법을 해당 SV의 현지화 된 새 버전으로 복사하십시오. 컨테이너 마법 (예 : % ENV, $ 1, tie)이 복사되고 가치 마법 (예 : 오염, 위치)이 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d73bd4397739daf068f0e0c81f47887b133737c" translate="yes" xml:space="preserve">
          <source>Copy the miniperl executable from the native build done earlier to replace the cross compiled miniperl.</source>
          <target state="translated">이전에 수행 한 기본 빌드에서 miniperl 실행 파일을 복사하여 크로스 컴파일 된 miniperl을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="944d3ba1daacc35a1c39f04db6c6016f8a5e0184" translate="yes" xml:space="preserve">
          <source>Copy your Perl executable to a BS2000 LLM using bs2cp:</source>
          <target state="translated">bs2cp를 사용하여 Perl 실행 파일을 BS2000 LLM에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="2d7ed2211bbc181246d723daf7d8159780f901a4" translate="yes" xml:space="preserve">
          <source>Copy your header files and C files to this directory</source>
          <target state="translated">헤더 파일과 C 파일을이 디렉토리로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="704f751eff0d0b505d7bf92d8e801e4d308664b6" translate="yes" xml:space="preserve">
          <source>Copying and pasting code without understanding it, while superstitiously believing in its value. This term originated from preindustrial cultures dealing with the detritus of explorers and colonizers of technologically advanced cultures. See</source>
          <target state="translated">코드를 이해하지 않고 복사 및 붙여 넣기를하면서 미신적으로 그 가치를 믿습니다. 이 용어는 기술적으로 진보 된 문화의 탐험가들과 식민지들을 다루는 산업화 이전 문화에서 유래했다. 보다</target>
        </trans-unit>
        <trans-unit id="f48221dc8de0edb298f93c3d9ea0b286f39f81ac" translate="yes" xml:space="preserve">
          <source>Copying private information out of your system. Even something as simple as your user name is of value to others. Much useful information could be gleaned from your environment variables for example.</source>
          <target state="translated">시스템 외부에서 개인 정보를 복사합니다. 사용자 이름처럼 단순한 것조차도 다른 사람들에게 가치가 있습니다. 예를 들어 환경 변수에서 유용한 정보를 많이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba61f765e33a7dbdaa5dc699f7442584180fbf0c" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2012 Tom Christiansen.</source>
          <target state="translated">저작권 &amp;copy; 2012 Tom Christiansen.</target>
        </trans-unit>
        <trans-unit id="937d2f60d09c53d79a1381de58ec4983d7faadb3" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1990-2011 by Larry Wall and others.</source>
          <target state="translated">Larry Wall 및 기타에 의한 저작권 (C) 1990-2011.</target>
        </trans-unit>
        <trans-unit id="fb8450e1f5cfd8fc44ca561023832e2026e0d699" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1990-2012 by Larry Wall and others.</source>
          <target state="translated">Larry Wall 및 기타에 의한 저작권 (C) 1990-2012.</target>
        </trans-unit>
        <trans-unit id="866e8b342f220185b06062e3c92301f53f840c56" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All rights reserved.</source>
          <target state="translated">Copyright (C) 1991-2, RSA Data Security, Inc. 1991 년 설립. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="8fd1a6d880564bdc3ea1e763f953df5ebac7e46e" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1994-2013 Larry Wall</source>
          <target state="translated">저작권 (C) 1994-2013 Larry Wall</target>
        </trans-unit>
        <trans-unit id="1c0c559930ca4225e8816cff4ee2873c1c41a1ac" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant. All Rights Reserved.</source>
          <target state="translated">Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="292274a2b01d4df1c901b9114cee5b641d729f45" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1996-2002,2005,2006 David Muir Sharnoff. Copyright (C) 2005 Aristotle Pagaltzis Copyright (C) 2012-2013 Google, Inc. This module may be modified, used, copied, and redistributed at your own risk. Although allowed by the preceding license, please do not publicly redistribute modified versions of this code with the name &quot;Text::Tabs&quot; unless it passes the unmodified Text::Tabs test suite.</source>
          <target state="translated">저작권 (C) 1996-2002,2005,2006 David Muir Sharnoff. Copyright (C) 2005 Aristotle Pagaltzis 저작권 (C) 2012-2013 Google, Inc.이 모듈은 사용자 책임하에 수정, 사용, 복사 및 재배포 될 수 있습니다. 이전 라이센스에서 허용되었지만 수정되지 않은 Text :: Tabs 테스트 스위트를 통과하지 않으면이 코드의 수정 된 버전을 &quot;Text :: Tabs&quot;라는 이름으로 공개적으로 재배포하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="02bb538e3acc9fba7e66a4108eaa2f54189885d2" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1996-2009 David Muir Sharnoff. Copyright (C) 2012-2013 Google, Inc. This module may be modified, used, copied, and redistributed at your own risk. Although allowed by the preceding license, please do not publicly redistribute modified versions of this code with the name &quot;Text::Wrap&quot; unless it passes the unmodified Text::Wrap test suite.</source>
          <target state="translated">저작권 (C) 1996-2009 David Muir Sharnoff. Copyright (C) 2012-2013 Google, Inc.이 모듈은 사용자 책임하에 수정, 사용, 복사 및 재배포 될 수 있습니다. 이전 라이센스에서 허용되었지만 수정되지 않은 Text :: Wrap 테스트 스위트를 통과하지 않으면이 코드의 수정 된 버전을 &quot;Text :: Wrap&quot;이라는 이름으로 공개적으로 재배포하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="77d8ad6518ef8e3ffa4a429ac08f118904c382ac" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1997, 1999 Tom Phoenix</source>
          <target state="translated">저작권 (C) 1997, 1999 Tom Phoenix</target>
        </trans-unit>
        <trans-unit id="67e16ccb30ea63aa1d756ce57f18d2d7b5847ff8" translate="yes" xml:space="preserve">
          <source>Copyright (C) 1998, 2002, 2003 Jon Orwant. All Rights Reserved.</source>
          <target state="translated">저작권 (C) 1998, 2002, 2003 Jon Orwant. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="b90a8995c2bc16a451a02631a6a11820b0642403" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2002-2009 Richard Clamp. All Rights Reserved.</source>
          <target state="translated">저작권 (C) 2002-2009 Richard Clamp. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="066dc5f0420738b9ed994bc87aed4131e1192b32" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2003-2015 Mark Shelor</source>
          <target state="translated">저작권 (C) 2003-2015 Mark Shelor</target>
        </trans-unit>
        <trans-unit id="1c7f20037aad67be66061eee55047374368b5f2e" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2004, 2008 Matthijs van Duin. All rights reserved. Copyright (C) 2014 cPanel Inc. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">Copyright (C) 2004, 2008 Matthijs van Duin. 판권 소유. 저작권 (C) 2014 cPanel Inc. 모든 권리 보유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5def902ce53af0d66c9ae0b1a9f55a7bc540b36c" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2006-2007 by (Anno Siegel)</source>
          <target state="translated">(Anno Siegel)의 저작권 (C) 2006-2007</target>
        </trans-unit>
        <trans-unit id="d16dc4251e47686ff5ed08ba79678470456a743a" translate="yes" xml:space="preserve">
          <source>Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;</source>
          <target state="translated">Copyright (C) 2011, 2012, 2013 Andrew Main (제프 람) &amp;lt;zefram@fysh.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c99e15fbe5fafed3fe83907c942a8467ca2f0856" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1995 Graham Barr &amp;amp; Nick Ing-Simmons. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1995 Graham Barr &amp;amp; Nick Ing-Simmons. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d67aab425ae8ab541cdf2624605b8e79d554fe" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1995-2011 Paul Marquess. All rights reserved. Copyright (c) 2011-2014 Reini Urban. All rights reserved.</source>
          <target state="translated">저작권 (c) 1995-2011 Paul Marquess. 판권 소유. 저작권 (c) 2011-2014 Reini Urban. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="f9a66947e2ff3697bb460252be39f2139fd2dfb8" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1995-2012 Paul Marquess. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1995-2012 Paul Marquess. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a331cc5bbf130d1638077c14f80eecf3e2a52eaf" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1995-2014 Paul Marquess. All rights reserved.</source>
          <target state="translated">저작권 (c) 1995-2014 Paul Marquess. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="733de8f3f1ca09b5c9786044fb092e7f4c05f294" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1995-98 Ilya Zakharevich. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1995-98 Ilya Zakharevich. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecaed13460704998ba577e4c2d2468a151c24b30" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1996, 1997 Malcolm Beattie Copyright (c) 2008, 2010, 2013, 2014 Reini Urban</source>
          <target state="translated">저작권 (c) 1996, 1997 Malcolm Beattie 저작권 (c) 2008, 2010, 2013, 2014 Reini Urban</target>
        </trans-unit>
        <trans-unit id="1feb9747b49165f4eb65853775088ee0251ff609" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1996-2002 Douglas E. Wegscheid. All rights reserved.</source>
          <target state="translated">저작권 (c) 1996-2002 Douglas E. Wegscheid. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="cc400f4ad8917f7b799fd3975597a9810d8ce636" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1996-2014 Gurusamy Sarathy. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1996-2014 Gurusamy Sarathy. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="485f651d515be5bba642d42e474826a93f61bb6b" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1996-8 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1996-8 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e4cdda088cf550ea65b3bf4dc89aba9b493bbc" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2003 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1997-2003 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4887e8376b496893469d0bac43718dbc07ae1822" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2003 Graham Barr, 2003-2007 David Rolsky. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1997-2003 Graham Barr, 2003-2007 David Rolsky. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7245b2dcd573952f48717b9921c61d1e9b2c21e" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2007 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1997-2007 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d6af5defc144adda44580441213764dbdd5a579" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights reserved.</source>
          <target state="translated">Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington 및 기타 저자. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="96ab04550bbdbe3276e7b627e8ac745ea70c4e50" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-2013 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights reserved.</source>
          <target state="translated">Copyright (c) 1997-2013 Tom Christiansen, Nathan Torkington 및 기타 저자. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="b85bffc2f702e5a69d96edf1040c8231c9905e16" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-8 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1997-8 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a94533b6d04a11dc7e8f73fc628424ecae3fb0" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1997-8 Graham Barr. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 1997-8 Graham Barr. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422bbbfa2ebf0ecbc7060450d7441d3ab485a17c" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1998+ Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 1998+ Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="4c5d0fa3fbcbb72648eeb53bb25226cd8e07fc2d" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1998-2000 Joshua Nathaniel Pritikin.</source>
          <target state="translated">저작권 (c) 1998-2000 Joshua Nathaniel Pritikin.</target>
        </trans-unit>
        <trans-unit id="f70857aa7efdb3e62785ad1d300160624d1ca8c4" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1998-2004 Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 1998-2004 Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="7bf33c9fe762000df4df0dfadc70c956cdf17ba0" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1998-2004 Tom Hughes &amp;lt;</source>
          <target state="translated">저작권 (c) 1998-2004 Tom Hughes &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e0ae8e826ee43e27b9f80f2f471b56b206c7c868" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1999 Tuomas J. Lukka &amp;lt;lukka@iki.fi&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as perl itself.</source>
          <target state="translated">저작권 (c) 1999 Tuomas J. Lukka &amp;lt;lukka@iki.fi&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. 펄 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b26641bc7ea8de46aed22323cf3dc2c633f52e" translate="yes" xml:space="preserve">
          <source>Copyright (c) 1999-2004 Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 1999-2004 Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="61d2f566b03b65ebb8a473ade4f6c05ec2e7b7d6" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2000 Mark Kvale All rights reserved.</source>
          <target state="translated">저작권 (c) 2000 Mark Kvale 판권 소유.</target>
        </trans-unit>
        <trans-unit id="956588c9cff385547adb21a72fd25e005bd741ba" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2001+ Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 2001+ Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="101703b452cff466c3017bb8ed36a01aa5987d0f" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2001, Colin McMillen. All rights reserved.</source>
          <target state="translated">저작권 (c) 2001, Colin McMillen. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="4be1efc0ccc0981f45abf323878167441401a846" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2001-2002 Michael G. Schwern.</source>
          <target state="translated">저작권 (c) 2001-2002 Michael G. Schwern.</target>
        </trans-unit>
        <trans-unit id="745610c91808a145be6f46517082d4e57524612c" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2001-2004 Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 2001-2004 Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="943b9de4d5b00b8ab9c8008e42e2cad2c939e815" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002 Sean M. Burke.</source>
          <target state="translated">저작권 (c) 2002 Sean M. Burke.</target>
        </trans-unit>
        <trans-unit id="27329c3ca1bd874414fcb99c62900358075672d6" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002 Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 2002 Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="2b28a7c47cb1fc722aa93ca95ba51f4648d81356" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi. All rights reserved.</source>
          <target state="translated">Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko Hietaniemi. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="999355b8d02ad239f1c7f43da46147f2a00c43e4" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002, 2003, 2004, 2012 Elizabeth Mattijsen. All rights reserved. This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 2002, 2003, 2004, 2012 Elizabeth Mattijsen. 판권 소유. 이 라이브러리는 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baaf0433379f30ce563209428329e2d5328a5310" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002,3,4 Sean M. Burke. All rights reserved.</source>
          <target state="translated">저작권 (c) 2002,3,4 Sean M. Burke. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="bfb8ae6b5304e536dda7306d8f5e5b4e96abc310" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002-2003, Rob Brown. All rights reserved.</source>
          <target state="translated">Copyright (c) 2002-2003, Rob Brown. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="d3cf30d649786ddcd606f40863280a1c98090473" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002-2004 Sean M. Burke.</source>
          <target state="translated">저작권 (c) 2002-2004 Sean M. Burke.</target>
        </trans-unit>
        <trans-unit id="370a5e83a0a375fc863482e0f23b23bcc8829b4b" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002-2007 Sean M. Burke.</source>
          <target state="translated">저작권 (c) 2002-2007 Sean M. Burke.</target>
        </trans-unit>
        <trans-unit id="d20f5965d8d31028f9af0d7c9c2319d612d7cf7c" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2002-2007 by D.H. aka PodMaster</source>
          <target state="translated">DH 일명 PodMaster의 저작권 (c) 2002-2007</target>
        </trans-unit>
        <trans-unit id="1a96f1bac6842e525db311ea1fddc129e4e8347c" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2003-2005 Allison Randal.</source>
          <target state="translated">저작권 (c) 2003-2005 Allison Randal.</target>
        </trans-unit>
        <trans-unit id="739c0eceb4f80af2e4cb7f48ed65f0a345752cc6" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2003-2005 Ken Williams. All rights reserved.</source>
          <target state="translated">저작권 (c) 2003-2005 Ken Williams. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="2afe6350b059d07cb75bd42fe8c3e717187f030d" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2003-2015 Mark Shelor &amp;lt;mshelor@cpan.org&amp;gt;.</source>
          <target state="translated">Copyright (c) 2003-2015 Mark Shelor &amp;lt;mshelor@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="8cbc77258020bb73d4d2613484c0c85b25c299f1" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004 Sean M. Burke.</source>
          <target state="translated">저작권 (c) 2004 Sean M. Burke.</target>
        </trans-unit>
        <trans-unit id="68da7dd6a77efed4cbb3653f046ac6a3a62b384b" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004 by the Perl 5 Porters. All rights reserved.</source>
          <target state="translated">Perl 5 Porters의 저작권 (c) 2004. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="81397d758a65133b90ab0602bb70a5a4dd4563d7" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004,2007 by the Perl 5 Porters. All rights reserved.</source>
          <target state="translated">Perl 5 Porters의 저작권 (c) 2004,2007. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="3c8167cf442af8fc4f64de836da6cfdb60bde4e8" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004-14 by the Perl 5 Porters. All rights reserved.</source>
          <target state="translated">Perl 5 포터에 의한 저작권 (c) 2004-14. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="6b274ec54ed3e9fc14376e565d4163bda3b1ca64" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004-2005 Nokia. All rights reserved.</source>
          <target state="translated">저작권 (c) 2004-2005 Nokia. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="00c3184f7198be0bfec2c01f0ef09d44048c6235" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2004-2013 by the Perl 5 Porters. All rights reserved.</source>
          <target state="translated">Perl 5 Porters의 저작권 (c) 2004-2013. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="08da8c434007b220b2ae85c8f6ae67bced13a749" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2005 Paul Marquess. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 2005 Paul Marquess. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="626531bda13f14d08f7f1720b4b85c8df8972de4" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2005-2014 Paul Marquess. All rights reserved.</source>
          <target state="translated">저작권 (c) 2005-2014 Paul Marquess. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="f4b7861e56dd95d2fb72c43ec9bcffc12d2604f4" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2006-2007 Jarkko Hietaniemi.</source>
          <target state="translated">저작권 (c) 2006-2007 Jarkko Hietaniemi.</target>
        </trans-unit>
        <trans-unit id="ca4bb54bc6b524ec7b6211da633ce092f06642b6" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2007-10 Max Maischein &lt;code&gt;&amp;lt;corion@cpan.org&amp;gt;&lt;/code&gt; Based on the idea of &lt;code&gt;base.pm&lt;/code&gt; , which was introduced with Perl 5.004_04.</source>
          <target state="translated">Copyright (c) 2007-10 Max Maischein &lt;code&gt;&amp;lt;corion@cpan.org&amp;gt;&lt;/code&gt; Perl 5.004_04에서 소개 된 &lt;code&gt;base.pm&lt;/code&gt; 아이디어를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="99b55113ec04a69f163df98ad79820c69bf73427" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2007-2011, Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt; . All rights reserved.</source>
          <target state="translated">저작권 (c) 2007-2011, Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt; . 판권 소유.</target>
        </trans-unit>
        <trans-unit id="edf65b9e5034d506f64cda4d822d94cf071d2118" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2008 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 (c) 2008 Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;. 판권 소유. 이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2961ceaca647df086cd88aa0aa9059e913775ed" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2011 brian d foy. All rights reserved.</source>
          <target state="translated">저작권 (c) 2011 brian d foy. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="0a0578f5c0a1861e0a6616062cbeff94f9471da0" translate="yes" xml:space="preserve">
          <source>Copyright 1995-1997,2002-2004 Gisle Aas.</source>
          <target state="translated">저작권 1995-1997,2002-2004 Gisle Aas.</target>
        </trans-unit>
        <trans-unit id="40d0702e44bca347009394197d44a9e6c4610d74" translate="yes" xml:space="preserve">
          <source>Copyright 1995-1999, 2001-2004, 2010 Gisle Aas.</source>
          <target state="translated">저작권 1995-1999, 2001-2004, 2010 Gisle Aas.</target>
        </trans-unit>
        <trans-unit id="9f586c7c8d64bfd9e85b5c08564c28475c2476d0" translate="yes" xml:space="preserve">
          <source>Copyright 1996 Zenin. Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Russ Allbery &amp;lt;rra@cpan.org&amp;gt;. Copyright 2012 Kurt Starsinic &amp;lt;kstarsinic@gmail.com&amp;gt;. This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">저작권 1996 Zenin. Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Russ Allbery &amp;lt;rra@cpan.org&amp;gt;. 저작권 2012 Kurt Starsinic &amp;lt;kstarsinic@gmail.com&amp;gt;. 이 프로그램은 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2578ceec7e839432122171b06d2ebf101a0829d8" translate="yes" xml:space="preserve">
          <source>Copyright 1997 - 2001 Damian Conway. All Rights Reserved.</source>
          <target state="translated">저작권 1997-2001 Damian Conway. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="e24c0d040bccb06d10ccb3a57cbbc46e6ed0dddf" translate="yes" xml:space="preserve">
          <source>Copyright 1998 The Perl Journal.</source>
          <target state="translated">저작권 1998 Perl Journal.</target>
        </trans-unit>
        <trans-unit id="d52fcfe7bec45098d75b5470bde1a0d7ed1a805a" translate="yes" xml:space="preserve">
          <source>Copyright 1998, 1999, 2000, 2001, 2012 by Mark Jason Dominus</source>
          <target state="translated">Mark Jason Dominus의 1998 년, 1999 년, 2000 년, 2001 년, 2012 년 저작권</target>
        </trans-unit>
        <trans-unit id="25fd40d58410cd1696c803df7d48f5ed2513b4fb" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="beb00d2f951db1eb5afb7de8fb7c0bdeb6824fdf" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2000, 2001, 2002, 2004, 2006, 2008, 2009, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="a467ad5fa2d0aa209d23ad0c1537c33c44052bff" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d116660891649b2a4f34cbcb8ed7ded670e6b71e" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010, 2012, 2013 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="3b5d92e90abbe2d5c568afb5c521beac86f1e04e" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2001, 2002, 2004, 2006, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="24528ac4ae30b0fed790404fa53cadcc8ddc8c0c" translate="yes" xml:space="preserve">
          <source>Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 1999, 2001, 2004, 2006, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="233c7c72bfb3a12d36d9a0b1a2a2236732bf795f" translate="yes" xml:space="preserve">
          <source>Copyright 2000 by Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;. Copyright 2001, 2004, 2008 by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;의 저작권 2000. Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;의 저작권 2001, 2004, 2008.</target>
        </trans-unit>
        <trans-unit id="bac1b99511dfac3f040f153e32b31825485f6b22" translate="yes" xml:space="preserve">
          <source>Copyright 2001 by Jarkko Hietaniemi</source>
          <target state="translated">Jarkko Hietaniemi의 저작권 2001</target>
        </trans-unit>
        <trans-unit id="39f328bf52bbb81edfba43d285c298d3543ac18c" translate="yes" xml:space="preserve">
          <source>Copyright 2001, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Copyright 2001, 2008, 2009 Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7c959eb5c2acf1300054205c4d9f5d4cbb02d027" translate="yes" xml:space="preserve">
          <source>Copyright 2001, Larry Wall.</source>
          <target state="translated">저작권 2001, 래리 월.</target>
        </trans-unit>
        <trans-unit id="0e90130d5f5b2ccf88af0b6d57add0a492ab06a4" translate="yes" xml:space="preserve">
          <source>Copyright 2001-2008 by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;의 저작권 2001-2008.</target>
        </trans-unit>
        <trans-unit id="758760659ae9e9da078236b8c96e4f04f45e80be" translate="yes" xml:space="preserve">
          <source>Copyright 2001-2011 Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;. Now maintained by Perl 5 Porters.</source>
          <target state="translated">저작권 2001-2011 Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;. 이제 Perl 5 Porter가 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="24f4f8eae6a435477fe3bf3b0fd15810a567f325" translate="yes" xml:space="preserve">
          <source>Copyright 2002-2008 by chromatic &amp;lt;chromatic@wgz.org&amp;gt; and Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</source>
          <target state="translated">chromatic &amp;lt;chromatic@wgz.org&amp;gt; 및 Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;의 저작권 2002-2008.</target>
        </trans-unit>
        <trans-unit id="9ad00efbd2d58cad6bbe8ee8a6e69c0624704508" translate="yes" xml:space="preserve">
          <source>Copyright 2002-2014 Dan Kogai</source>
          <target state="translated">저작권 2002-2014 Dan Kogai</target>
        </trans-unit>
        <trans-unit id="adff1afaa96bc6908438762288df7e0c84cec743" translate="yes" xml:space="preserve">
          <source>Copyright 2002-2014 by Ken Williams, David Golden and other contributors. All rights reserved.</source>
          <target state="translated">Ken Williams, David Golden 및 기타 기고자에 의한 Copyright 2002-2014. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="718ed72e455fb194df80ae2d0693e8d68c4004c0" translate="yes" xml:space="preserve">
          <source>Copyright 2003, 2004, 2005, 2006 by Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;.</source>
          <target state="translated">Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;의 저작권 2003, 2004, 2005, 2006.</target>
        </trans-unit>
        <trans-unit id="03f9138fcf89a29043a1e2a727cfe2c79ab79b5d" translate="yes" xml:space="preserve">
          <source>Copyright 2006 Yves Orton and 2007 &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason.</source>
          <target state="translated">저작권 2006 Yves Orton 및 2007 &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason.</target>
        </trans-unit>
        <trans-unit id="a7b10ddec953c21d4f38ad07fa70d878c1a1f6b9" translate="yes" xml:space="preserve">
          <source>Copyright 2006-2008 Curtis &quot;Ovid&quot; Poe, all rights reserved.</source>
          <target state="translated">저작권 2006-2008 Curtis &quot;Ovid&quot;Poe, 모든 권리 보유.</target>
        </trans-unit>
        <trans-unit id="2dc2b4cddeffd8148859258dfa192ac667c79bfb" translate="yes" xml:space="preserve">
          <source>Copyright 2007-2011 Andy Armstrong.</source>
          <target state="translated">저작권 2007-2011 Andy Armstrong.</target>
        </trans-unit>
        <trans-unit id="eeaf3232c6892ccf2f411117d77f548428dc4ef2" translate="yes" xml:space="preserve">
          <source>Copyright 2008-2009, Paul Fenwick &amp;lt;pjf@perltraining.com.au&amp;gt;</source>
          <target state="translated">저작권 2008-2009, Paul Fenwick &amp;lt;pjf@perltraining.com.au&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4da493f5c04edefe46b0fd74ae429ad56b0dc531" translate="yes" xml:space="preserve">
          <source>Copyright 2010, brian d foy &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</source>
          <target state="translated">저작권 2010, brian d foy &lt;code&gt;&amp;lt;brian.d.foy@gmail.com&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b47a4389c364b8abd358a0f467c39b15dbdea1cb" translate="yes" xml:space="preserve">
          <source>Copyright 2013 Tom Christiansen.</source>
          <target state="translated">저작권 2013 Tom Christiansen.</target>
        </trans-unit>
        <trans-unit id="f64383541384dc3e2eb364fd68051f5f3748d4e0" translate="yes" xml:space="preserve">
          <source>Copyright Mark Fowler &amp;lt;mark@twoshortplanks.com&amp;gt; 2002, 2004.</source>
          <target state="translated">저작권 마크 파울러 &amp;lt;mark@twoshortplanks.com&amp;gt; 2002, 2004.</target>
        </trans-unit>
        <trans-unit id="2e7c31625c0b13304190ac801e54ebae59236c4f" translate="yes" xml:space="preserve">
          <source>Copyright Mark Fowler &amp;lt;mark@twoshortplanks.com&amp;gt; 2002.</source>
          <target state="translated">저작권 마크 파울러 &amp;lt;mark@twoshortplanks.com&amp;gt; 2002.</target>
        </trans-unit>
        <trans-unit id="a9f33cf7a4a5fda17e447238e45c4abe5cf41f08" translate="yes" xml:space="preserve">
          <source>Copyright(C) 2001-2012, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">Copyright (C) 2001-2012, SADAHIRO Tomoyuki. 일본. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="31e40e06c4bcb283edebf594f2bd7378bcf58ce9" translate="yes" xml:space="preserve">
          <source>Copyrights</source>
          <target state="translated">Copyrights</target>
        </trans-unit>
        <trans-unit id="97c1dd3ec24454b864720faa54a3abda989f1564" translate="yes" xml:space="preserve">
          <source>Core Images</source>
          <target state="translated">핵심 이미지</target>
        </trans-unit>
        <trans-unit id="99bb4f655f44c04dddda9615c8eb20527c7cc996" translate="yes" xml:space="preserve">
          <source>Core Layers</source>
          <target state="translated">핵심 레이어</target>
        </trans-unit>
        <trans-unit id="bc6e3a410aa372c2487ec123aa51c13c61ba9355" translate="yes" xml:space="preserve">
          <source>Core Modules</source>
          <target state="translated">핵심 모듈</target>
        </trans-unit>
        <trans-unit id="783102c8987eec788fa90e6f2de9f84f1caf1885" translate="yes" xml:space="preserve">
          <source>Core Perl does not have any support for the wide and multibyte characters of the C standards, except under UTF-8 locales, so this might be a rather useless function.</source>
          <target state="translated">Core Perl은 UTF-8 로켈을 제외하고 C 표준의 와이드 및 멀티 바이트 문자를 지원하지 않으므로 다소 쓸모없는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b87e196a65aa25a514c9ea7b2551d2cd6978d7" translate="yes" xml:space="preserve">
          <source>Core Perl modules</source>
          <target state="translated">코어 펄 모듈</target>
        </trans-unit>
        <trans-unit id="67d35c68c7df776a652523a80899e489b317a9b0" translate="yes" xml:space="preserve">
          <source>Core modules</source>
          <target state="translated">핵심 모듈</target>
        </trans-unit>
        <trans-unit id="ce831d7b130ca37b50a0ab62dd64d0056aa444db" translate="yes" xml:space="preserve">
          <source>Correspondingly, sending a signal to a thread does not disrupt the operation the thread is currently working on: The signal will be acted upon after the current operation has completed. For instance, if the thread is</source>
          <target state="translated">이에 따라 스레드에 신호를 보내도 스레드가 현재 작업중인 작업이 중단되지 않습니다. 현재 작업이 완료된 후에 신호가 작동합니다. 예를 들어 스레드가</target>
        </trans-unit>
        <trans-unit id="5d25cbf547052ef26b7bd5b301c3044498d75c9a" translate="yes" xml:space="preserve">
          <source>Could it be a module instead?</source>
          <target state="translated">대신 모듈이 될 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="09e55edb3e65ad6732e40f6cd984478db5d78fce" translate="yes" xml:space="preserve">
          <source>Counting Repetitions</source>
          <target state="translated">반복 계산</target>
        </trans-unit>
        <trans-unit id="6638251b6bc95fa3de20882497e46af5dda04835" translate="yes" xml:space="preserve">
          <source>Counting bytes and watching alignments in lengthy structures is bound to be a drag. Isn't there a way we can create the template with a simple program? Here's a C program that does the trick:</source>
          <target state="translated">긴 구조에서 바이트 수를 계산하고 정렬을 보는 것은 드래그해야합니다. 간단한 프로그램으로 템플릿을 만들 수있는 방법이 없습니까? 트릭을 수행하는 C 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cfd2770db664059c57a58368f587a061ac0b45a" translate="yes" xml:space="preserve">
          <source>Counting the number of entries in a hash via &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(keys(%hash))&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(values(%hash)&lt;/a&gt;&lt;/code&gt;) is inefficient since it needs to iterate through all the entries with FIRSTKEY/NEXTKEY.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(keys(%hash))&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(values(%hash)&lt;/a&gt;&lt;/code&gt; ) 를 통해 해시의 항목 수를 계산하는 것은 FIRSTKEY / NEXTKEY를 사용하여 모든 항목을 반복해야하기 때문에 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b4d6e94a784b6e291943d7b2c4e0fc93520909e7" translate="yes" xml:space="preserve">
          <source>Counting the opening parentheses to get the correct number for a backreference is error-prone as soon as there is more than one capturing group. A more convenient technique became available with Perl 5.10: relative backreferences. To refer to the immediately preceding capture group one now may write &lt;code&gt;\g{-1}&lt;/code&gt; , the next but last is available via &lt;code&gt;\g{-2}&lt;/code&gt; , and so on.</source>
          <target state="translated">역 참조에 대한 올바른 숫자를 얻기 위해 여는 괄호를 세면 캡처 그룹이 둘 이상 있으면 오류가 발생하기 쉽습니다. Perl 5.10 : 상대적 역 참조를 통해보다 편리한 기술을 사용할 수있게되었습니다. 바로 앞의 캡처 그룹을 참조하기 위해 이제 &lt;code&gt;\g{-1}&lt;/code&gt; 쓸 수 있으며, 다음은 마지막은 &lt;code&gt;\g{-2}&lt;/code&gt; 등을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2815297cdc53ede6ff2cb024503f24e17cc60a88" translate="yes" xml:space="preserve">
          <source>Coverity</source>
          <target state="translated">Coverity</target>
        </trans-unit>
        <trans-unit id="9fbbe918826f27bbfcf0ae0fdd88d18c0d6bd29a" translate="yes" xml:space="preserve">
          <source>Coverity (&lt;a href=&quot;http://www.coverity.com/&quot;&gt;http://www.coverity.com/&lt;/a&gt;) is a product similar to lint and as a testbed for their product they periodically check several open source projects, and they give out accounts to open source developers to the defect databases.</source>
          <target state="translated">Coverity ( &lt;a href=&quot;http://www.coverity.com/&quot;&gt;http://www.coverity.com/&lt;/a&gt; )는 lint와 유사한 제품이며 제품에 대한 테스트 베드로서 정기적으로 여러 오픈 소스 프로젝트를 확인하고 결함 데이터베이스에 대한 오픈 소스 개발자 계정을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30f10fb60094a5736894608b7733f1893682a3ec" translate="yes" xml:space="preserve">
          <source>Cppsym.U</source>
          <target state="translated">Cppsym.U</target>
        </trans-unit>
        <trans-unit id="5ebece852ecc4ea6150b191a89b2f264b38241db" translate="yes" xml:space="preserve">
          <source>Create VMS linker options files specifying universal symbols for this extension's shareable image, and listing other shareable images or libraries to which it should be linked.</source>
          <target state="translated">이 확장의 공유 가능 이미지에 대한 범용 기호를 지정하고 링크되어야하는 다른 공유 가능 이미지 또는 라이브러리를 나열하는 VMS 링커 옵션 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="02cd22cf6983deda3bb052ea3365661fc9cd4123" translate="yes" xml:space="preserve">
          <source>Create a &quot;symlink&quot; or copy your bash.exe to sh.exe in your &lt;code&gt;($DJDIR)/bin&lt;/code&gt; directory.</source>
          <target state="translated">&quot;symlink&quot;를 만들거나 bash.exe를 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 디렉토리의 sh.exe로 복사하십시오 .</target>
        </trans-unit>
        <trans-unit id="18cde0b66e2ee12909d4ed1d9eb6ea9c47f3f1a9" translate="yes" xml:space="preserve">
          <source>Create a BigRat from an hexadecimal, binary or octal number in string form.</source>
          <target state="translated">문자열 형식의 16 진, 2 진 또는 8 진 숫자로 BigRat을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="473f8f658940e07568176b34bfa435fa80921f41" translate="yes" xml:space="preserve">
          <source>Create a Zip64 zip file/buffer. This option is used if you want to store files larger than 4 Gig or store more than 64K files in a single zip archive..</source>
          <target state="translated">Zip64 zip 파일 / 버퍼를 작성하십시오. 이 옵션은 4 Gig보다 큰 파일을 저장하거나 단일 zip 아카이브에 64K 이상의 파일을 저장하려는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11130cde618dc2de912450499554a974016ed7af" translate="yes" xml:space="preserve">
          <source>Create a batch file to run your program, and codify it in &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; (see the</source>
          <target state="translated">프로그램을 실행할 배치 파일을 작성하고 &lt;code&gt;ALTERNATE_SHEBANG&lt;/code&gt; 에 코드화 하십시오 (</target>
        </trans-unit>
        <trans-unit id="bc3d1ef79a98971d38e02b76ce890553cad199f4" translate="yes" xml:space="preserve">
          <source>Create a class for the language your internal keys are in. Name the class after the language-tag for that language, in lowercase, with dashes changed to underscores. Assuming your project's first language is US English, you should call this Projname::L10N::en_us. It should consist minimally of:</source>
          <target state="translated">내부 키가있는 언어에 대한 클래스를 작성하십시오. 대시를 밑줄로 변경하여 해당 언어의 언어 태그 뒤에 소문자로 클래스 이름을 지정하십시오. 프로젝트의 첫 번째 언어가 미국 영어라고 가정하면이 Projname :: L10N :: en_us를 호출해야합니다. 최소한으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="af5af99f136ed2ceb6678c03a38a42040f4ea033" translate="yes" xml:space="preserve">
          <source>Create a class for your localization project. This is the name of the class that you'll use in the idiom:</source>
          <target state="translated">현지화 프로젝트를위한 클래스를 만듭니다. 이것은 관용구에서 사용할 수업의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d140dda80edfdc914d774a5fe6e3ebbdbcd954b7" translate="yes" xml:space="preserve">
          <source>Create a directory from a template. The template must end in X's that are replaced by the routine.</source>
          <target state="translated">템플리트에서 디렉토리를 작성하십시오. 템플릿은 루틴으로 대체 된 X로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="87942e6092afa4288ce7b6b61b23174e2b70e314" translate="yes" xml:space="preserve">
          <source>Create a directory from the supplied template. This template is similar to that described for tempfile(). `X' characters at the end of the template are replaced with random letters to construct the directory name. At least four `X' characters must be in the template.</source>
          <target state="translated">제공된 템플리트에서 디렉토리를 작성하십시오. 이 템플릿은 tempfile ()에서 설명한 것과 비슷합니다. 템플릿 끝의`X '문자는 임의의 문자로 대체되어 디렉토리 이름을 구성합니다. 템플릿에는 최소 4 개의`X '문자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="97bd03e560de52beb6792bf090df2f8c408c1b3d" translate="yes" xml:space="preserve">
          <source>Create a directory in tmpdir() (see L&amp;lt;:spec&amp;gt;).</source>
          <target state="translated">tmpdir ()에 디렉토리를 작성하십시오 (L &amp;lt;: spec&amp;gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4362437c4dee6826064eba29335269a256a16b4f" translate="yes" xml:space="preserve">
          <source>Create a module Makefile</source>
          <target state="translated">모듈 Makefile 만들기</target>
        </trans-unit>
        <trans-unit id="50c598518f68bf9f28b1793bfb579fbc50559040" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;App::Prove&lt;/code&gt; . Optionally a hash ref of attribute initializers may be passed.</source>
          <target state="translated">새 &lt;code&gt;App::Prove&lt;/code&gt; 작성하십시오 . 선택적으로 속성 이니셜 라이저의 해시 참조가 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="637b03561b650422dbca5301699123a3114e7256" translate="yes" xml:space="preserve">
          <source>Create a new Math::BigRat object. Input can come in various forms:</source>
          <target state="translated">새로운 Math :: BigRat 객체를 만듭니다. 입력은 다양한 형태로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37ec6f7cf703eb7c8d20ea11f3b6a2d9d8f1bdf2" translate="yes" xml:space="preserve">
          <source>Create a new Perl external subroutine named $perl_name using $symref as a pointer to the function which implements the routine. This is simply a direct call to newXSUB(). Returns a reference to the installed function.</source>
          <target state="translated">루틴을 구현하는 함수에 대한 포인터로 $ symref를 사용하여 $ perl_name이라는 새 Perl 외부 서브 루틴을 작성하십시오. 이것은 단순히 newXSUB ()에 대한 직접 호출입니다. 설치된 함수에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8b815122ea1b53bab2fea52aa82c0738dc639ea2" translate="yes" xml:space="preserve">
          <source>Create a new SigSet object. This object will be destroyed automatically when it is no longer needed. Arguments may be supplied to initialize the set.</source>
          <target state="translated">새 SigSet 객체를 만듭니다. 이 오브젝트는 더 이상 필요하지 않으면 자동으로 삭제됩니다. 세트를 초기화하기 위해 인수가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f2191aaab0a2fe03dd235f940c62b8ea3693cca" translate="yes" xml:space="preserve">
          <source>Create a new Termios object. This object will be destroyed automatically when it is no longer needed. A Termios object corresponds to the &lt;code&gt;termios&lt;/code&gt; C struct. &lt;code&gt;new()&lt;/code&gt; mallocs a new one, &lt;code&gt;getattr()&lt;/code&gt; fills it from a file descriptor, and &lt;code&gt;setattr()&lt;/code&gt; sets a file descriptor's parameters to match Termios' contents.</source>
          <target state="translated">새로운 Termios 객체를 만듭니다. 이 오브젝트는 더 이상 필요하지 않으면 자동으로 삭제됩니다. Termios 객체는 &lt;code&gt;termios&lt;/code&gt; C 구조체에 해당합니다 . &lt;code&gt;new()&lt;/code&gt; 는 새로운 것을 mallocs하고, &lt;code&gt;getattr()&lt;/code&gt; 은 파일 디스크립터에서 그것을 채우고, &lt;code&gt;setattr()&lt;/code&gt; 은 Termios의 내용과 일치하도록 파일 디스크립터의 매개 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e8e14e0bd357803bf052153bab4c0a139ecb8716" translate="yes" xml:space="preserve">
          <source>Create a new cache object. This object can hold an arbitrary number of POD documents of class Pod::Cache::Item.</source>
          <target state="translated">새 캐시 오브젝트를 작성하십시오. 이 객체는 Pod :: Cache :: Item 클래스의 임의 개수의 POD 문서를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7234e7b8446d88bd6969be5e67b0f7bcc7d431e8" translate="yes" xml:space="preserve">
          <source>Create a new directory called Mytest2 at the same level as the directory Mytest. In the Mytest2 directory, create another directory called mylib, and cd into that directory.</source>
          <target state="translated">Mytest 디렉토리와 같은 레벨에서 Mytest2라는 새 디렉토리를 작성하십시오. Mytest2 디렉토리에서 mylib라는 다른 디렉토리를 작성하고 해당 디렉토리로 cd하십시오.</target>
        </trans-unit>
        <trans-unit id="31384a4a0ee35aebb04c1c58d30d768f683e1f93" translate="yes" xml:space="preserve">
          <source>Create a new directory with the name &lt;code&gt;DIR&lt;/code&gt; . If &lt;code&gt;RECURSE&lt;/code&gt; is</source>
          <target state="translated">이름이 &lt;code&gt;DIR&lt;/code&gt; 인 새 디렉토리를 작성하십시오 . 경우 &lt;code&gt;RECURSE&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="d7b61de6466590ec52305327e27f85b32bce01c7" translate="yes" xml:space="preserve">
          <source>Create a new file with mode 0640. Set up the file for writing.</source>
          <target state="translated">0640 모드로 새 파일을 작성하십시오. 기록 할 파일을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a881eb9aa6d20d6d909d029e4c81928e7bc18391" translate="yes" xml:space="preserve">
          <source>Create a new file. This returns a file descriptor like the ones returned by &lt;code&gt;POSIX::open&lt;/code&gt; . Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">새 파일을 작성하십시오. &lt;code&gt;POSIX::open&lt;/code&gt; 의해 리턴 된 것과 같은 파일 디스크립터를 리턴합니다 . &lt;code&gt;POSIX::close&lt;/code&gt; 를 사용 하여 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="74dd602c7c6a1f1cb930e156dfc79f8193fd0b55" translate="yes" xml:space="preserve">
          <source>Create a new instance of the specified class.</source>
          <target state="translated">지정된 클래스의 새 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6cc585773d59263f24bc1ca5a399b6f4d519e67f" translate="yes" xml:space="preserve">
          <source>Create a new list object. Properties may be specified through a hash reference like this:</source>
          <target state="translated">새 목록 객체를 만듭니다. 다음과 같이 해시 참조를 통해 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ba7c62c943cded5489456e206c446db08d870de" translate="yes" xml:space="preserve">
          <source>Create a new object.</source>
          <target state="translated">새 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fcb9d9d9881e78822adfe0bbac4eee7555066ecb" translate="yes" xml:space="preserve">
          <source>Create a new object. Any arguments passed to &lt;code&gt;new&lt;/code&gt; will be passed on to the &lt;a href=&quot;#_initialize&quot;&gt;_initialize&lt;/a&gt; method. Returns a new object.</source>
          <target state="translated">새 객체를 만듭니다. &lt;code&gt;new&lt;/code&gt; 로 전달 된 모든 인수 는 &lt;a href=&quot;#_initialize&quot;&gt;_initialize&lt;/a&gt; 메소드 로 전달됩니다 . 새로운 객체를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="0a8a658289cee30e5b27a60292e471ac179b2181" translate="yes" xml:space="preserve">
          <source>Create a new padlist, updating the global variables for the currently-compiling padlist to point to the new padlist. The following flags can be OR'ed together:</source>
          <target state="translated">현재 편집중인 패드리스트에 대한 전역 변수를 업데이트하여 새 패드리스트를 가리 키도록 새 패드리스트를 작성하십시오. 다음 플래그는 함께 OR 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2261993683f4a99c0cc5814cbab351173c8386" translate="yes" xml:space="preserve">
          <source>Create a new ping object. All of the parameters are optional. $proto specifies the protocol to use when doing a ping. The current choices are &quot;tcp&quot;, &quot;udp&quot;, &quot;icmp&quot;, &quot;stream&quot;, &quot;syn&quot;, or &quot;external&quot;. The default is &quot;tcp&quot;.</source>
          <target state="translated">새 핑 개체를 만듭니다. 모든 매개 변수는 선택 사항입니다. $ proto는 핑을 수행 할 때 사용할 프로토콜을 지정합니다. 현재 선택은 &quot;tcp&quot;, &quot;udp&quot;, &quot;icmp&quot;, &quot;stream&quot;, &quot;syn&quot;또는 &quot;external&quot;입니다. 기본값은 &quot;tcp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3430e716a61ae83b9e144c2c5c8622a75ae88917" translate="yes" xml:space="preserve">
          <source>Create a new semaphore set associated with &lt;code&gt;KEY&lt;/code&gt; . &lt;code&gt;NSEMS&lt;/code&gt; is the number of semaphores in the set. A new set is created if</source>
          <target state="translated">&lt;code&gt;KEY&lt;/code&gt; 와 연관된 새 세마포어 세트를 작성하십시오 . &lt;code&gt;NSEMS&lt;/code&gt; 는 세트의 세마포어 수입니다. 새로운 세트가 생성되면</target>
        </trans-unit>
        <trans-unit id="4a7ef28ba91fedd9a746c8523a72dbcb8eb69fb7" translate="yes" xml:space="preserve">
          <source>Create a perl subroutine for the specified macros rather than autoload with the constant() subroutine. These macros are assumed to have a return type of &lt;b&gt;char *&lt;/b&gt;, e.g., -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid.</source>
          <target state="translated">constant () 서브 루틴을 사용하여 자동로드하는 대신 지정된 매크로에 대해 perl 서브 루틴을 작성하십시오. 이 매크로는 리턴 유형이 &lt;b&gt;char *&lt;/b&gt; 인 것으로 가정합니다 ( 예 : -s sec_rgy_wildcard_name, sec_rgy_wildcard_sid).</target>
        </trans-unit>
        <trans-unit id="481a60ee3395b3b1cf7945f04080acc645acd340" translate="yes" xml:space="preserve">
          <source>Create a reverse hash:</source>
          <target state="translated">역 해시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0e04e4f20e56fddcf662a44731769084042c59e" translate="yes" xml:space="preserve">
          <source>Create a set with &lt;code&gt;SIGUSR1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SIGUSR1&lt;/code&gt; 으로 세트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ac62f075bf8001f6525a8640c77b2f7fb60c81b" translate="yes" xml:space="preserve">
          <source>Create a temporary directory using an object oriented interface.</source>
          <target state="translated">객체 지향 인터페이스를 사용하여 임시 디렉토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="303ec3c6180101ba95b912105da0ce7bfcb1deb4" translate="yes" xml:space="preserve">
          <source>Create a temporary directory using the supplied template, but attempt to remove it (and all files inside it) when the program exits. Note that an attempt will be made to remove all files from the directory even if they were not created by this module (otherwise why ask to clean it up?). The directory removal is made with the rmtree() function from the L&amp;lt;:path&amp;gt; module. Of course, if the template is not specified, the temporary directory will be created in tmpdir() and will also be removed at program exit.</source>
          <target state="translated">제공된 템플리트를 사용하여 임시 디렉토리를 작성하십시오. 그러나 프로그램이 종료되면 해당 템플리트 (및 그 안의 모든 파일)를 제거하십시오. 이 모듈에 의해 작성되지 않은 경우에도 디렉토리에서 모든 파일을 제거하려고 시도합니다 (그렇지 않으면 정리를 요청하는 이유는 무엇입니까?). 디렉토리 제거는 L &amp;lt;: path&amp;gt; 모듈의 rmtree () 함수로 수행됩니다. 물론 템플릿을 지정하지 않으면 tmpdir ()에 임시 디렉토리가 생성되고 프로그램 종료시 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="55698f6a3601555bd654382a0b288d1302315bd9" translate="yes" xml:space="preserve">
          <source>Create a temporary file in the current directory using the supplied template. Trailing `X' characters are replaced with random letters to generate the filename. At least four `X' characters must be present at the end of the template.</source>
          <target state="translated">제공된 템플리트를 사용하여 현재 디렉토리에 임시 파일을 작성하십시오. 후행 'X'문자는 임의의 문자로 대체되어 파일 이름을 생성합니다. 템플릿 끝에 최소한 4 개의`X '문자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bc36137f6fa982d9a92b93d4881687f9cba40176" translate="yes" xml:space="preserve">
          <source>Create a temporary file in the directory specified for temporary files, as specified by the tmpdir() function in L&amp;lt;:spec&amp;gt;.</source>
          <target state="translated">L &amp;lt;: spec&amp;gt;의 tmpdir () 함수에 의해 지정된대로 임시 파일 용으로 지정된 디렉토리에 임시 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="24495d1f7765573877dcd812b1a4948cc60660ee" translate="yes" xml:space="preserve">
          <source>Create a temporary file object.</source>
          <target state="translated">임시 파일 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="69935c6719cc9d9adfa0d718baf1f913522468e6" translate="yes" xml:space="preserve">
          <source>Create an empty set.</source>
          <target state="translated">빈 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36282f608207859c78f549fdddb59df654b98999" translate="yes" xml:space="preserve">
          <source>Create an interprocess channel. This returns file descriptors like those returned by &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">프로세스 간 채널을 만듭니다. &lt;code&gt;POSIX::open&lt;/code&gt; 의해 리턴 된 것과 같은 파일 디스크립터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ff79fe2c6259816c55880a8381a93476c6afdffb" translate="yes" xml:space="preserve">
          <source>Create an iterator. Expects one argument containing a filehandle.</source>
          <target state="translated">이터레이터를 만듭니다. 파일 핸들을 포함하는 하나의 인수를 예상합니다.</target>
        </trans-unit>
        <trans-unit id="616caec393d0885ab17bf7298761058cad98107e" translate="yes" xml:space="preserve">
          <source>Create an iterator. Expects one argument containing a hashref of the form:</source>
          <target state="translated">이터레이터를 만듭니다. 다음 형식의 해시 참조를 포함하는 하나의 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7016a4d543732a6745b00979a34621bd52cd3c30" translate="yes" xml:space="preserve">
          <source>Create an iterator. Provided by &lt;a href=&quot;../object&quot;&gt;TAP::Object&lt;/a&gt;.</source>
          <target state="translated">이터레이터를 만듭니다. 에 의해 제공 &lt;a href=&quot;../object&quot;&gt;TAP :: 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a61216ea6bd1172096b7e521d63d97ec506b32" translate="yes" xml:space="preserve">
          <source>Create an iterator. Takes one argument: an &lt;code&gt;$array_ref&lt;/code&gt;</source>
          <target state="translated">이터레이터를 만듭니다. 하나의 인수를 취합니다 : &lt;code&gt;$array_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d452463d593e43e7b412e932435358550d3459d0" translate="yes" xml:space="preserve">
          <source>Create an object to store the state of a deparsing operation and any options. The options are the same as those that can be given on the command line (see &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt;); options that are separated by commas after &lt;b&gt;-MO=Deparse&lt;/b&gt; should be given as separate strings.</source>
          <target state="translated">deparsing 작업의 상태와 옵션을 저장할 객체를 만듭니다. 옵션은 명령 행에 제공 될 수있는 옵션과 동일합니다 ( &lt;a href=&quot;#OPTIONS&quot;&gt;옵션&lt;/a&gt; 참조 ). &lt;b&gt;-MO = Deparse&lt;/b&gt; 뒤에 쉼표로 구분 된 옵션은 별도의 문자열로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9112787448a0b0a1b976b8609db263871f034c88" translate="yes" xml:space="preserve">
          <source>Create and return a new interpreter by cloning the current one.</source>
          <target state="translated">현재 통역사를 복제하여 새 통역사를 작성하고 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="681f59f5e6812683ee0d03597d9f2b4876cee8dc" translate="yes" xml:space="preserve">
          <source>Create header and footer blocks containing the text of the &quot;NAME&quot; section.</source>
          <target state="translated">&quot;NAME&quot;섹션의 텍스트가 포함 된 머리글 및 바닥 글 블록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2d5ca272bf9f8abe24e8b1f4fd428df6751e11d3" translate="yes" xml:space="preserve">
          <source>Create or remove directory trees</source>
          <target state="translated">디렉토리 트리 작성 또는 제거</target>
        </trans-unit>
        <trans-unit id="896a63b966c3b07644d559d9c2dce6fddbbfbefe" translate="yes" xml:space="preserve">
          <source>Create simple getter/setters.</source>
          <target state="translated">간단한 게터 / 세터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="82149e5249dc1d6a3b9690dd546cd84a48533f50" translate="yes" xml:space="preserve">
          <source>Created - 18 Jan 2001</source>
          <target state="translated">Created-2001 년 1 월 18 일</target>
        </trans-unit>
        <trans-unit id="33db1a73ae0e0d1852a295cdab91f536d92a8891" translate="yes" xml:space="preserve">
          <source>Created by Tom Hughes &amp;lt;</source>
          <target state="translated">Tom Hughes 제작 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e6cdaaaee22d0c4e6b235592749143d45c2fe9b7" translate="yes" xml:space="preserve">
          <source>Creates a constant sub equivalent to Perl &lt;code&gt;sub FOO () { 123 }&lt;/code&gt; which is eligible for inlining at compile-time.</source>
          <target state="translated">컴파일 타임에 인라인 할 수있는 Perl &lt;code&gt;sub FOO () { 123 }&lt;/code&gt; 해당하는 상수 하위를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="7f75da7fd0f98bc8dc84b4b1a932c3f5aea3cd14" translate="yes" xml:space="preserve">
          <source>Creates a digest string exactly like the crypt(3) function in the C library (assuming that you actually have a version there that has not been extirpated as a potential munition).</source>
          <target state="translated">C 라이브러리의 crypt (3) 함수와 정확히 같은 다이제스트 문자열을 만듭니다 (잠재 탄약으로 소멸되지 않은 버전이 있다고 가정).</target>
        </trans-unit>
        <trans-unit id="eac496469522ef212783107cb6f208d37140024c" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;IO::Handle&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;IO::Handle&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="950a7fce8052aa44e77d67eb7cce6a9b17f503cc" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;POSIX::SigAction&lt;/code&gt; object which corresponds to the C &lt;code&gt;struct sigaction&lt;/code&gt; . This object will be destroyed automatically when it is no longer needed. The first parameter is the handler, a sub reference. The second parameter is a &lt;code&gt;POSIX::SigSet&lt;/code&gt; object, it defaults to the empty set. The third parameter contains the &lt;code&gt;sa_flags&lt;/code&gt; , it defaults to 0.</source>
          <target state="translated">C &lt;code&gt;struct sigaction&lt;/code&gt; 해당 하는 새로운 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 객체를 만듭니다 . 이 오브젝트는 더 이상 필요하지 않으면 자동으로 삭제됩니다. 첫 번째 매개 변수는 하위 참조 인 핸들러입니다. 두 번째 매개 변수는 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 객체이며 기본값은 빈 세트입니다. 세 번째 매개 변수에는 &lt;code&gt;sa_flags&lt;/code&gt; 가 포함되며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4409ce2d7a51f583ec857ef63305d9c328af09b3" translate="yes" xml:space="preserve">
          <source>Creates a new &lt;code&gt;refcounted_he&lt;/code&gt; . This consists of a single key/value pair and a reference to an existing &lt;code&gt;refcounted_he&lt;/code&gt; chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</source>
          <target state="translated">새로운 &lt;code&gt;refcounted_he&lt;/code&gt; 를 작성 합니다. 단일 키 / 값 쌍과 기존 &lt;code&gt;refcounted_he&lt;/code&gt; 체인 (비어있을 수 있음)에 대한 참조로 구성되어 더 긴 체인을 형성합니다. 더 긴 체인을 사용하면 새로운 키 / 값 쌍이 체인을 따라 동일한 키에 대한 항목보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="50f1aadb519c6f1717d95b45f0702486fa9496f0" translate="yes" xml:space="preserve">
          <source>Creates a new AV and populates it with a list of SVs. The SVs are copied into the array, so they may be freed after the call to av_make. The new AV will have a reference count of 1.</source>
          <target state="translated">새 AV를 생성하고 SV 목록으로 채 웁니다. SV는 어레이에 복사되므로 av_make를 호출 한 후 해제 될 수 있습니다. 새로운 AV의 참조 카운트는 1입니다.</target>
        </trans-unit>
        <trans-unit id="33114a24c831591f9857c8f08551925f33fb6511" translate="yes" xml:space="preserve">
          <source>Creates a new AV. The reference count is set to 1.</source>
          <target state="translated">새로운 AV를 만듭니다. 참조 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1ac2ca7a7bb62339b5b238de6e909b22341ab0" translate="yes" xml:space="preserve">
          <source>Creates a new BigInt object from a scalar or another BigInt object. The input is accepted as decimal, hex (with leading '0x') or binary (with leading '0b').</source>
          <target state="translated">스칼라 또는 다른 BigInt 오브젝트에서 새 BigInt 오브젝트를 작성합니다. 입력은 10 진수, 16 진 (앞에 '0x') 또는 2 진 (앞에 '0b')으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0f0aa1d0ba94cb717a19862e381519302e9596" translate="yes" xml:space="preserve">
          <source>Creates a new BigInt object representing NaN (Not A Number). If used on an object, it will set it to NaN:</source>
          <target state="translated">NaN (Not A Number)을 나타내는 새 BigInt 객체를 만듭니다. 객체에 사용되면 NaN으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9de9810e6c72332db75b8fa66a77cdf8fc6dc8ae" translate="yes" xml:space="preserve">
          <source>Creates a new BigInt object representing infinity. The optional argument is either '-' or '+', indicating whether you want infinity or minus infinity. If used on an object, it will set it to infinity:</source>
          <target state="translated">무한대를 나타내는 새로운 BigInt 객체를 작성합니다. 선택적 인수는 '-'또는 '+'이며 무한대 또는 마이너스 무한대를 원하는지 여부를 나타냅니다. 객체에 사용되면 무한대로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef067d4e1aa5d4de6db6fbb3fdb193a34b25bcd5" translate="yes" xml:space="preserve">
          <source>Creates a new BigInt object representing one. The optional argument is either '-' or '+', indicating whether you want one or minus one. If used on an object, it will set it to one:</source>
          <target state="translated">하나를 나타내는 새 BigInt 오브젝트를 작성합니다. 선택적인 인수는 '-'또는 '+'이며, 하나를 원하는지 또는 빼기를 원하는지 나타냅니다. 객체에 사용되면 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d66a0e771c364720b98473ea0bd85073686ef36" translate="yes" xml:space="preserve">
          <source>Creates a new BigInt object representing zero. If used on an object, it will set it to zero:</source>
          <target state="translated">0을 나타내는 새로운 BigInt 객체를 작성합니다. 객체에 사용되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f27ebfb7f2c2069457b323e2292201c271ad4602" translate="yes" xml:space="preserve">
          <source>Creates a new HV. The reference count is set to 1.</source>
          <target state="translated">새로운 HV를 만듭니다. 참조 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4c9fc922e6f0fc2c8c0dc9a56aa12406f49a23" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies a floating point value into it. The reference count for the SV is set to 1.</source>
          <target state="translated">새 SV를 작성하고 부동 소수점 값을 여기에 복사합니다. SV의 기준 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a706dc63eba9f9d97a63992d45f33ffaa0260f8" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies a string (which may contain &lt;code&gt;NUL&lt;/code&gt; (&lt;code&gt;\0&lt;/code&gt; ) characters) into it. If utf8 is true, calls &lt;code&gt;SvUTF8_on&lt;/code&gt; on the new SV. Implemented as a wrapper around &lt;code&gt;newSVpvn_flags&lt;/code&gt; .</source>
          <target state="translated">새 SV를 작성하고 문자열 ( &lt;code&gt;NUL&lt;/code&gt; ( &lt;code&gt;\0&lt;/code&gt; ) 문자를 포함 할 수 있음)을 복사 합니다. utf8이 true이면 새 SV에서 &lt;code&gt;SvUTF8_on&lt;/code&gt; 을 호출합니다 . &lt;code&gt;newSVpvn_flags&lt;/code&gt; 주위를 래퍼로 구현했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2d40d3f42edeb3193c212e63e131081199c97e" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies a string (which may contain &lt;code&gt;NUL&lt;/code&gt; (&lt;code&gt;\0&lt;/code&gt; ) characters) into it. The reference count for the SV is set to 1. If &lt;code&gt;len&lt;/code&gt; is zero, Perl will compute the length using strlen(), (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">새 SV를 작성하고 문자열 ( &lt;code&gt;NUL&lt;/code&gt; ( &lt;code&gt;\0&lt;/code&gt; ) 문자를 포함 할 수 있음)을 여기에 복사 합니다. SV의 참조 카운트는 1로 설정됩니다. &lt;code&gt;len&lt;/code&gt; 이 0 인 경우 Perl은 strlen ()을 사용하여 길이를 계산합니다. 즉,이 옵션을 사용하면 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;NUL&lt;/code&gt; 문자를 포함 할 수 없으며 종료해야합니다. &lt;code&gt;NUL&lt;/code&gt; 바이트).</target>
        </trans-unit>
        <trans-unit id="b321a7140bf968fa858a05cea608e9cde629793f" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies a string (which may contain &lt;code&gt;NUL&lt;/code&gt; (&lt;code&gt;\0&lt;/code&gt; ) characters) into it. The reference count for the SV is set to 1. Note that if &lt;code&gt;len&lt;/code&gt; is zero, Perl will create a zero length string. You are responsible for ensuring that the source string is at least &lt;code&gt;len&lt;/code&gt; bytes long. If the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; argument is NULL the new SV will be undefined. Currently the only flag bits accepted are &lt;code&gt;SVf_UTF8&lt;/code&gt; and &lt;code&gt;SVs_TEMP&lt;/code&gt; . If &lt;code&gt;SVs_TEMP&lt;/code&gt; is set, then &lt;code&gt;sv_2mortal()&lt;/code&gt; is called on the result before returning. If &lt;code&gt;SVf_UTF8&lt;/code&gt; is set, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is considered to be in UTF-8 and the &lt;code&gt;SVf_UTF8&lt;/code&gt; flag will be set on the new SV. &lt;code&gt;newSVpvn_utf8()&lt;/code&gt; is a convenience wrapper for this function, defined as</source>
          <target state="translated">새 SV를 작성하고 문자열 ( &lt;code&gt;NUL&lt;/code&gt; ( &lt;code&gt;\0&lt;/code&gt; ) 문자를 포함 할 수 있음)을 복사 합니다. SV의 참조 카운트는 1로 설정됩니다. &lt;code&gt;len&lt;/code&gt; 이 0이면 Perl은 길이가 0 인 문자열을 만듭니다. 소스 문자열의 길이가 적어도 &lt;code&gt;len&lt;/code&gt; 바이트 인지 확인해야합니다 . 는 IF &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 인수가 NULL 인 새 SV는 정의되지 않습니다. 현재 허용되는 유일한 플래그 비트는 &lt;code&gt;SVf_UTF8&lt;/code&gt; 및 &lt;code&gt;SVs_TEMP&lt;/code&gt; 입니다. 경우 &lt;code&gt;SVs_TEMP&lt;/code&gt; 가 설정되어, 다음 &lt;code&gt;sv_2mortal()&lt;/code&gt; 반환하기 전에 결과에 호출된다. 경우 &lt;code&gt;SVf_UTF8&lt;/code&gt; 가 설정되어, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; UTF-8과에로 간주됩니다 &lt;code&gt;SVf_UTF8&lt;/code&gt; 플래그가 새 SV에 설정됩니다. &lt;code&gt;newSVpvn_utf8()&lt;/code&gt; 은 다음과 같이 정의 된이 함수의 편의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="564cfa2529586958403f4ae104186110ddb6158c" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies a string into it, which may contain &lt;code&gt;NUL&lt;/code&gt; characters (&lt;code&gt;\0&lt;/code&gt; ) and other binary data. The reference count for the SV is set to 1. Note that if &lt;code&gt;len&lt;/code&gt; is zero, Perl will create a zero length (Perl) string. You are responsible for ensuring that the source buffer is at least &lt;code&gt;len&lt;/code&gt; bytes long. If the &lt;code&gt;buffer&lt;/code&gt; argument is NULL the new SV will be undefined.</source>
          <target state="translated">새로운 SV를 생성하고 문자열을 복사합니다. 여기에는 &lt;code&gt;NUL&lt;/code&gt; 문자 ( &lt;code&gt;\0&lt;/code&gt; ) 및 기타 이진 데이터 가 포함될 수 있습니다 . SV의 참조 카운트는 1로 설정됩니다. &lt;code&gt;len&lt;/code&gt; 이 0이면 Perl은 길이가 0 인 문자열을 생성합니다. 소스 버퍼 길이가 &lt;code&gt;len&lt;/code&gt; 바이트 이상인지 확인해야합니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 인수가 NULL 새로운 SV는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9de1b0a97a64089b618097ac3dffb046bfdc6779" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies an integer into it. The reference count for the SV is set to 1.</source>
          <target state="translated">새로운 SV를 생성하고 정수를 SV에 복사합니다. SV의 기준 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0aaf0d14999388a8de7db8b3ae47db90806dcf" translate="yes" xml:space="preserve">
          <source>Creates a new SV and copies an unsigned integer into it. The reference count for the SV is set to 1.</source>
          <target state="translated">새 SV를 작성하고 부호없는 정수를 복사합니다. SV의 기준 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e144449cf71b321cfaa7ad7d73caee74bd802815" translate="yes" xml:space="preserve">
          <source>Creates a new SV and initializes it with the string formatted like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새 SV를 생성하고 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 같은 형식의 문자열로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe580b8ead3e78b800fd8ca819c064553dc4b84" translate="yes" xml:space="preserve">
          <source>Creates a new SV containing the pad name.</source>
          <target state="translated">패드 이름이 포함 된 새 SV를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fdde1c5ef502eaafbff9afbbccd3fe8baa5b7fc2" translate="yes" xml:space="preserve">
          <source>Creates a new SV for the existing RV, &lt;code&gt;rv&lt;/code&gt; , to point to. If &lt;code&gt;rv&lt;/code&gt; is not an RV then it will be upgraded to one. If &lt;code&gt;classname&lt;/code&gt; is non-null then the new SV will be blessed in the specified package. The new SV is returned and its reference count is 1. The reference count 1 is owned by &lt;code&gt;rv&lt;/code&gt; .</source>
          <target state="translated">기존 RV &lt;code&gt;rv&lt;/code&gt; 에 대한 새 SV 를 가리 킵니다. 경우 &lt;code&gt;rv&lt;/code&gt; 캠핑카하지 않습니다 다음은 하나에 업그레이드됩니다. &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 지정된 패키지에서 새 SV가 제공됩니다. 새로운 SV가 반환되고 참조 카운트는 1입니다. 참조 카운트 1은 &lt;code&gt;rv&lt;/code&gt; 가 소유합니다 .</target>
        </trans-unit>
        <trans-unit id="639f7c9a254704d094942032f6f23eecd10dcb3d" translate="yes" xml:space="preserve">
          <source>Creates a new SV from the hash key structure. It will generate scalars that point to the shared string table where possible. Returns a new (undefined) SV if the hek is NULL.</source>
          <target state="translated">해시 키 구조에서 새 SV를 만듭니다. 가능한 경우 공유 문자열 테이블을 가리키는 스칼라를 생성합니다. hek가 NULL 인 경우 새로운 (정의되지 않은) SV를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1cd7ce4c785336645dd9ca8151db8dfa4fd5a1c4" translate="yes" xml:space="preserve">
          <source>Creates a new SV which is a copy of the original SV (using &lt;code&gt;sv_setsv&lt;/code&gt; ). The new SV is marked as mortal. It will be destroyed &quot;soon&quot;, either by an explicit call to FREETMPS, or by an implicit call at places such as statement boundaries. See also &lt;code&gt;sv_newmortal&lt;/code&gt; and &lt;code&gt;sv_2mortal&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_setsv&lt;/code&gt; 를 사용하여 원래 SV의 사본 인 새 SV를 작성 합니다. 새로운 SV는 필사자로 표시됩니다. FREETMPS를 명시 적으로 호출하거나 명령문 경계와 같은 위치에서 암시 적으로 호출하면 &quot;곧&quot;파괴됩니다. &lt;code&gt;sv_newmortal&lt;/code&gt; 및 &lt;code&gt;sv_2mortal&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04a78f404d15207cad1d1bd98de9d1a89be2f47d" translate="yes" xml:space="preserve">
          <source>Creates a new SV which is an exact duplicate of the original SV. (Uses &lt;code&gt;sv_setsv&lt;/code&gt; .)</source>
          <target state="translated">원래 SV의 정확한 복제 본인 새 SV를 작성합니다. &lt;code&gt;sv_setsv&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f878a6fda000644884fdbc9cf596c38a8f7b65c4" translate="yes" xml:space="preserve">
          <source>Creates a new SV with its SvPVX_const pointing to a shared string in the string table. If the string does not already exist in the table, it is created first. Turns on the SvIsCOW flag (or READONLY and FAKE in 5.16 and earlier). If the &lt;code&gt;hash&lt;/code&gt; parameter is non-zero, that value is used; otherwise the hash is computed. The string's hash can later be retrieved from the SV with the &lt;code&gt;SvSHARED_HASH()&lt;/code&gt; macro. The idea here is that as the string table is used for shared hash keys these strings will have SvPVX_const == HeKEY and hash lookup will avoid string compare.</source>
          <target state="translated">SvPVX_const가 문자열 테이블에서 공유 문자열을 가리키는 새 SV를 작성합니다. 문자열이 테이블에 존재하지 않으면 먼저 작성됩니다. SvIsCOW 플래그 (또는 5.16 이하의 READONLY and FAKE)를 켭니다. 경우] &lt;code&gt;hash&lt;/code&gt; 파라미터는 비 제로이고, 그 값이 사용된다; 그렇지 않으면 해시가 계산됩니다. 문자열의 해시는 나중에 &lt;code&gt;SvSHARED_HASH()&lt;/code&gt; 매크로 를 사용하여 SV에서 검색 할 수 있습니다 . 여기서 문자열 테이블은 공유 해시 키에 사용되므로 이러한 문자열에는 SvPVX_const == HeKEY가 있고 해시 조회는 문자열 비교를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c74397b44268e30b14c395c9db4f9d4c75043d98" translate="yes" xml:space="preserve">
          <source>Creates a new SV, of the type specified. The reference count for the new SV is set to 1.</source>
          <target state="translated">지정된 유형의 새 SV를 만듭니다. 새로운 SV의 기준 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d12e4b3cc81eba03f26cff30464e8b479b1d58a2" translate="yes" xml:space="preserve">
          <source>Creates a new SV. A non-zero &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes of preallocated string space the SV should have. An extra byte for a trailing &lt;code&gt;NUL&lt;/code&gt; is also reserved. (SvPOK is not set for the SV even if string space is allocated.) The reference count for the new SV is set to 1.</source>
          <target state="translated">새로운 SV를 만듭니다. &lt;code&gt;len&lt;/code&gt; 이 아닌 매개 변수는 SV에 미리 할당 된 문자열 공간의 바이트 수를 나타냅니다. 후행 &lt;code&gt;NUL&lt;/code&gt; 에 대한 추가 바이트 도 예약되어 있습니다. (문자열 공간이 할당 된 경우에도 SVPOK는 SV에 대해 설정되지 않습니다.) 새 SV의 참조 카운트는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a57493668fe58cacf785eda42f6ca83298c5e7" translate="yes" xml:space="preserve">
          <source>Creates a new compression object.</source>
          <target state="translated">새로운 압축 객체를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5d1118553623fb7729c552dfc670d49ec70f74e5" translate="yes" xml:space="preserve">
          <source>Creates a new empty queue.</source>
          <target state="translated">빈 대기열을 새로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="453a7438c9a0abf2f411dfc88ef08eeb919af43f" translate="yes" xml:space="preserve">
          <source>Creates a new factory class.</source>
          <target state="translated">새로운 팩토리 클래스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1df3f928ae77e486f8fc4331645875637263feb9" translate="yes" xml:space="preserve">
          <source>Creates a new factory class:</source>
          <target state="translated">새로운 팩토리 클래스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f4b3ad0f4845756e7eb366403f2b64a035efb137" translate="yes" xml:space="preserve">
          <source>Creates a new filename linked to the old filename. Returns true for success, false otherwise.</source>
          <target state="translated">이전 파일 이름에 연결된 새 파일 이름을 만듭니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83f895542990ab6651e9706888c2de08e523dee6" translate="yes" xml:space="preserve">
          <source>Creates a new filename symbolically linked to the old filename. Returns &lt;code&gt;1&lt;/code&gt; for success, &lt;code&gt;0&lt;/code&gt; otherwise. On systems that don't support symbolic links, raises an exception. To check for that, use eval:</source>
          <target state="translated">이전 파일 이름에 심볼릭으로 연결된 새 파일 이름을 만듭니다. 반환 &lt;code&gt;1&lt;/code&gt; 성공, &lt;code&gt;0&lt;/code&gt; , 그렇지 않으면. 심볼릭 링크를 지원하지 않는 시스템에서는 예외가 발생합니다. 이를 확인하려면 eval을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c51b3b07b0600d4054dee0c964ac75e53c578450" translate="yes" xml:space="preserve">
          <source>Creates a new message queue associated with &lt;code&gt;KEY&lt;/code&gt; . A new queue is created if</source>
          <target state="translated">&lt;code&gt;KEY&lt;/code&gt; 와 연관된 새 메시지 큐를 작성 합니다. 다음과 같은 경우 새 대기열이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="b254f69cf661a8637fb6b526c326443550777a61" translate="yes" xml:space="preserve">
          <source>Creates a new null SV which is mortal. The reference count of the SV is set to 1. It will be destroyed &quot;soon&quot;, either by an explicit call to FREETMPS, or by an implicit call at places such as statement boundaries. See also &lt;code&gt;sv_mortalcopy&lt;/code&gt; and &lt;code&gt;sv_2mortal&lt;/code&gt; .</source>
          <target state="translated">필멸의 새로운 null SV를 작성합니다. SV의 참조 횟수는 1로 설정됩니다. FREETMPS를 명시 적으로 호출하거나 명령문 경계와 같은 위치에서 암시 적 호출을 수행하면 &quot;곧&quot;소멸됩니다. &lt;code&gt;sv_mortalcopy&lt;/code&gt; 및 &lt;code&gt;sv_2mortal&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c5d61aab7b4b2bae3ae0cd3fa405a1453e48d56" translate="yes" xml:space="preserve">
          <source>Creates a new pad name list. &lt;code&gt;max&lt;/code&gt; is the highest index for which space is allocated.</source>
          <target state="translated">새로운 패드 이름 목록을 만듭니다. &lt;code&gt;max&lt;/code&gt; 는 공간이 할당 된 가장 높은 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="a518faeb54384b75b7b16380f67e97a55f19fb8d" translate="yes" xml:space="preserve">
          <source>Creates a new queue pre-populated with the provided list of items.</source>
          <target state="translated">제공된 항목 목록으로 미리 채워진 새 대기열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="97776043490921bb3f4e1a2aa4a3d94c8dd73946" translate="yes" xml:space="preserve">
          <source>Creates a new shared memory segment of &lt;code&gt;SIZE&lt;/code&gt; bytes size associated with &lt;code&gt;KEY&lt;/code&gt; . A new segment is created if</source>
          <target state="translated">&lt;code&gt;KEY&lt;/code&gt; 와 연관된 &lt;code&gt;SIZE&lt;/code&gt; 바이트 크기 의 새 공유 메모리 세그먼트를 작성 합니다. 새로운 세그먼트가 생성되면</target>
        </trans-unit>
        <trans-unit id="ad8744084b0140499061b16f2e692d8d12d06891" translate="yes" xml:space="preserve">
          <source>Creates a new warnings category with the same name as the package where the call to the pragma is used.</source>
          <target state="translated">pragma에 대한 호출이 사용되는 패키지와 동일한 이름으로 새 경고 범주를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5a27d8b72cf141aebe58f87546d0d0c019b88e6f" translate="yes" xml:space="preserve">
          <source>Creates a single fieldhash. The argument must be a hash. Returns a reference to the given hash if successful, otherwise nothing.</source>
          <target state="translated">단일 fieldhash를 만듭니다. 인수는 해시 여야합니다. 성공하면 주어진 해시에 대한 참조를 반환하고, 그렇지 않으면 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6753f8b68917c94c7ceeba08d8a64a68bec41531" translate="yes" xml:space="preserve">
          <source>Creates a tar file from the list of files provided. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference).</source>
          <target state="translated">제공된 파일 목록에서 tar 파일을 작성합니다. 첫 번째 인수는 작성할 tar 파일의 이름이거나 열린 파일 핸들에 대한 참조 (예 : GLOB 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c586f81366892d7608cff1caa98747fac265568" translate="yes" xml:space="preserve">
          <source>Creates a warnings category with the same name as the current package.</source>
          <target state="translated">현재 패키지와 이름이 같은 경고 범주를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="70531cb628a95443a0bc996522c80ed3a1612eec" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::File&lt;/code&gt; . If it receives any parameters, they are passed to the method &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;; if the open fails, the object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="translated">&lt;code&gt;IO::File&lt;/code&gt; 만듭니다 . 매개 변수를 수신하면 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 메소드로 전달됩니다 . 열리지 않으면 객체가 파괴됩니다. 그렇지 않으면 발신자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f206ecd7edeba7b8082544ed88fc391c7aee72" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::File&lt;/code&gt; opened for read/write on a newly created temporary file. On systems where this is possible, the temporary file is anonymous (i.e. it is unlinked after creation, but held open). If the temporary file cannot be created or opened, the &lt;code&gt;IO::File&lt;/code&gt; object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="translated">새로 만든 임시 파일에서 읽기 / 쓰기를 위해 열린 &lt;code&gt;IO::File&lt;/code&gt; 만듭니다 . 이것이 가능한 시스템에서 임시 파일은 익명입니다 (즉, 생성 후 링크 해제되었지만 열린 상태로 유지됨). 임시 파일을 만들거나 열 수 없으면 &lt;code&gt;IO::File&lt;/code&gt; 개체가 손상됩니다. 그렇지 않으면 발신자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c5557a6d1ee1551613908cbc27f931101ce8ae4e" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Handle&lt;/code&gt; like &lt;code&gt;new&lt;/code&gt; does. It requires two parameters, which are passed to the method &lt;code&gt;fdopen&lt;/code&gt; ; if the fdopen fails, the object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 것처럼 &lt;code&gt;IO::Handle&lt;/code&gt; 만듭니다 . &lt;code&gt;fdopen&lt;/code&gt; 메소드에 전달되는 두 개의 매개 변수가 필요합니다 . fdopen이 실패하면 객체가 파괴됩니다. 그렇지 않으면 발신자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7d510d5075facd036fd1af77938045b2ecd2fd" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Pipe&lt;/code&gt; , which is a reference to a newly created symbol (see the &lt;code&gt;Symbol&lt;/code&gt; package). &lt;code&gt;IO::Pipe::new&lt;/code&gt; optionally takes two arguments, which should be objects blessed into &lt;code&gt;IO::Handle&lt;/code&gt; , or a subclass thereof. These two objects will be used for the system call to &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;. If no arguments are given then method &lt;code&gt;handles&lt;/code&gt; is called on the new &lt;code&gt;IO::Pipe&lt;/code&gt; object.</source>
          <target state="translated">새로 만든 심볼에 대한 참조 인 &lt;code&gt;IO::Pipe&lt;/code&gt; 만듭니다 ( &lt;code&gt;Symbol&lt;/code&gt; 패키지 참조 ). &lt;code&gt;IO::Pipe::new&lt;/code&gt; 선택적으로 두 개의 인수를 취하는데, 이는 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 그 서브 클래스에 축복 된 객체 여야합니다 . 이 두 객체는 ​​시스템 호출 &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 됩니다. 인수가 제공되지 않으면 새 &lt;code&gt;IO::Pipe&lt;/code&gt; 오브젝트 에서 메소드 &lt;code&gt;handles&lt;/code&gt; 이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="047841e1943658ae57257fef4f133cd272fd4811" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Socket::INET&lt;/code&gt; object, which is a reference to a newly created symbol (see the &lt;code&gt;Symbol&lt;/code&gt; package). &lt;code&gt;new&lt;/code&gt; optionally takes arguments, these arguments are in key-value pairs.</source>
          <target state="translated">새로 만든 심볼에 대한 참조 인 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 객체를 만듭니다 ( &lt;code&gt;Symbol&lt;/code&gt; 패키지 참조 ). &lt;code&gt;new&lt;/code&gt; 는 선택적으로 인수를 취하는데,이 인수는 키-값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="fab2be9faf86fae0e4bd5b1cd1283009b201bf09" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; object, which is a reference to a newly created symbol (see the &lt;code&gt;Symbol&lt;/code&gt; package). &lt;code&gt;new&lt;/code&gt; optionally takes arguments, these arguments are in key-value pairs.</source>
          <target state="translated">새로 만든 심볼에 대한 참조 인 &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 객체를 만듭니다 ( &lt;code&gt;Symbol&lt;/code&gt; 패키지 참조 ). &lt;code&gt;new&lt;/code&gt; 는 선택적으로 인수를 취하는데,이 인수는 키-값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="a250b42b4dd05b62200f3a07cb3c80166c30a874" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Socket&lt;/code&gt; , which is a reference to a newly created symbol (see the &lt;code&gt;Symbol&lt;/code&gt; package). &lt;code&gt;new&lt;/code&gt; optionally takes arguments, these arguments are in key-value pairs. &lt;code&gt;new&lt;/code&gt; only looks for one key &lt;code&gt;Domain&lt;/code&gt; which tells new which domain the socket will be in. All other arguments will be passed to the configuration method of the package for that domain, See below.</source>
          <target state="translated">새로 만든 심볼에 대한 참조 인 &lt;code&gt;IO::Socket&lt;/code&gt; 만듭니다 ( &lt;code&gt;Symbol&lt;/code&gt; 패키지 참조 ). &lt;code&gt;new&lt;/code&gt; 는 선택적으로 인수를 취하는데,이 인수는 키-값 쌍입니다. &lt;code&gt;new&lt;/code&gt; 는 소켓이 들어있는 도메인을 new에게 알려주는 하나의 키 &lt;code&gt;Domain&lt;/code&gt; 만 찾습니다 . 다른 모든 인수는 해당 도메인에 대한 패키지의 구성 방법으로 전달됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="f1fb9d0f6d66fb3d087378bdbe9232327d60e9d1" translate="yes" xml:space="preserve">
          <source>Creates an &lt;code&gt;IO::Zlib&lt;/code&gt; object. If it receives any parameters, they are passed to the method &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;; if the open fails, the object is destroyed. Otherwise, it is returned to the caller.</source>
          <target state="translated">&lt;code&gt;IO::Zlib&lt;/code&gt; 객체를 만듭니다 . 매개 변수를 수신하면 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 메소드로 전달됩니다 . 열리지 않으면 객체가 파괴됩니다. 그렇지 않으면 발신자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="119c0a1aef44d3b6314c9a2aeed4485068748984" translate="yes" xml:space="preserve">
          <source>Creates an RV wrapper for an SV. The reference count for the original SV is &lt;b&gt;not&lt;/b&gt; incremented.</source>
          <target state="translated">SV에 대한 RV 래퍼를 만듭니다. 원래 SV의 참조 카운트는 증가 &lt;b&gt;하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9a2099bcbcca20ca005321683291f2d84f8f9fa9" translate="yes" xml:space="preserve">
          <source>Creates an RV wrapper for an SV. The reference count for the original SV is incremented.</source>
          <target state="translated">SV에 대한 RV 래퍼를 만듭니다. 원래 SV의 참조 카운트가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="583c7b0e3437e1faffd9da7f44fbc7a044be2a1d" translate="yes" xml:space="preserve">
          <source>Creates an unnamed pair of sockets in the specified domain, of the specified type. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. If unimplemented, raises an exception. Returns true if successful.</source>
          <target state="translated">지정된 도메인에서 지정된 유형의 이름없는 소켓 쌍을 만듭니다. DOMAIN, TYPE 및 PROTOCOL은 동일한 이름의 syscall과 동일하게 지정됩니다. 구현되지 않은 경우 예외가 발생합니다. 성공하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3305aabab05db99f8bfc2b84c2d73fe46ce45fee" translate="yes" xml:space="preserve">
          <source>Creates and initialises a new lexer/parser state object, supplying a context in which to lex and parse from a new source of Perl code. A pointer to the new state object is placed in &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt;. An entry is made on the save stack so that upon unwinding the new state object will be destroyed and the former value of &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; will be restored. Nothing else need be done to clean up the parsing context.</source>
          <target state="translated">새로운 렉서 / 파서 상태 객체를 생성하고 초기화하여 새로운 Perl 코드 소스를 분석하고 분석 할 수있는 컨텍스트를 제공합니다. 새로운 상태 객체에 대한 포인터는 &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser에&lt;/a&gt; 위치 합니다. 풀기시 새 상태 오브젝트가 삭제되고 &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; 의 이전 값 이 복원 되도록 저장 스택에 항목이 작성됩니다 . 구문 분석 컨텍스트를 정리하기 위해 수행 할 다른 작업은 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f3dfed1a964ab0db38fbf8138ec0f7abbedf2e8" translate="yes" xml:space="preserve">
          <source>Creates any number of field hashes. Arguments must be hash references. Returns the converted hashrefs in list context, their number in scalar context.</source>
          <target state="translated">여러 필드 해시를 만듭니다. 인수는 해시 참조 여야합니다. 변환 된 해시 참조를 목록 컨텍스트에서 스칼라 컨텍스트의 수로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c592704db2b29209bd7ddf205e6af585a4f99b67" translate="yes" xml:space="preserve">
          <source>Creates directories, including any parent directories.</source>
          <target state="translated">상위 디렉토리를 포함하여 디렉토리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ad1d92000326b7959a82dfb9dc22227bf6a2e0c5" translate="yes" xml:space="preserve">
          <source>Creates header and footer blocks containing the text of the &lt;code&gt;NAME&lt;/code&gt; section. By default, no headers are generated.</source>
          <target state="translated">&lt;code&gt;NAME&lt;/code&gt; 섹션 의 텍스트를 포함하는 머리글 및 바닥 글 블록을 만듭니다 . 기본적으로 헤더는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="530e5ca354f68101b7370c2ecfbbf80ed760e37a" translate="yes" xml:space="preserve">
          <source>Creates many idhashes from its hashref arguments. Returns those arguments that could be converted or their number in scalar context.</source>
          <target state="translated">hashref 인수에서 많은 idhash를 작성합니다. 스칼라 컨텍스트에서 변환 될 수있는 인수 또는 해당 숫자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="83ad3819309f6108b72bbb402ce3a8c80083d9b4" translate="yes" xml:space="preserve">
          <source>Creates the blibdirs target which creates all the directories we use in blib/.</source>
          <target state="translated">blib /에서 사용하는 모든 디렉토리를 작성하는 blibdirs 대상을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="621a860874ef631fda40d3dbd09752ecf44fe523" translate="yes" xml:space="preserve">
          <source>Creates the directory cache in the given directory.</source>
          <target state="translated">지정된 디렉토리에 디렉토리 캐시를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="de22bdbde2d4398a6a9a9d6284383fd915d03734" translate="yes" xml:space="preserve">
          <source>Creates the directory specified by FILENAME, with permissions specified by MASK (as modified by &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;). If it succeeds it returns true; otherwise it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno). MASK defaults to 0777 if omitted, and FILENAME defaults to &lt;code&gt;$_&lt;/code&gt; if omitted.</source>
          <target state="translated">MASK에 의해 지정된 권한 ( &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정 된 ) 으로 FILENAME에 의해 지정된 디렉토리를 작성합니다 . 성공하면 true를 반환합니다. 그렇지 않으면 false를 반환하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno). 생략하면 MASK의 기본값은 0777이고, 생략하면 FILENAME의 기본값은 &lt;code&gt;$_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb7b117514892c7c30b3fe9f7719849bbac44c0c" translate="yes" xml:space="preserve">
          <source>Creates the directory specified by FILENAME, with permissions specified by MASK (as modified by &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;). If it succeeds it returns true; otherwise it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno). MASK defaults to 0777 if omitted, and FILENAME defaults to &lt;code&gt;$_&lt;/code&gt; if omitted.</source>
          <target state="translated">MASK에 의해 지정된 권한 ( &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정 된 ) 으로 FILENAME에 의해 지정된 디렉토리를 작성합니다 . 성공하면 true를 반환합니다. 그렇지 않으면 false를 반환하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno). 생략하면 MASK의 기본값은 0777이고, 생략하면 FILENAME의 기본값은 &lt;code&gt;$_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3cac7695a4d3664891070ffa2341b3035d0f19e8" translate="yes" xml:space="preserve">
          <source>Creating Custom RE Engines</source>
          <target state="translated">커스텀 RE 엔진 생성</target>
        </trans-unit>
        <trans-unit id="76d93a113b300b303dad480ac2a300eb6051aa71" translate="yes" xml:space="preserve">
          <source>Creating New Variables</source>
          <target state="translated">새로운 변수 만들기</target>
        </trans-unit>
        <trans-unit id="ca3daf69e2f937f89c7b4c76bccdabe68e3b34bf" translate="yes" xml:space="preserve">
          <source>Creating Threads</source>
          <target state="translated">스레드 만들기</target>
        </trans-unit>
        <trans-unit id="00c8935ea8223dcafffacb17ecb8c41069921e4c" translate="yes" xml:space="preserve">
          <source>Creating Unicode</source>
          <target state="translated">유니 코드 만들기</target>
        </trans-unit>
        <trans-unit id="9a6874111f18f654b4c464c7232a28e3e371a0c4" translate="yes" xml:space="preserve">
          <source>Creating and Calling an Anonymous Subroutine in C</source>
          <target state="translated">C에서 익명 서브 루틴 작성 및 호출</target>
        </trans-unit>
        <trans-unit id="57dbae3986bf4e92740a80829b68126452d91265" translate="yes" xml:space="preserve">
          <source>Creating threads inside &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;INIT&lt;/code&gt; blocks should not be relied upon. Depending on the Perl version and the application code, results may range from success, to (apparently harmless) warnings of leaked scalar, or all the way up to crashing of the Perl interpreter.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;INIT&lt;/code&gt; 블록 내에 스레드를 작성 해서는 안됩니다. Perl 버전과 응용 프로그램 코드에 따라 결과는 성공에서 누출 된 스칼라에 대한 경고 (아마도 무해한) 경고 또는 Perl 인터프리터 충돌까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="e13e0554f557ba882751e261b5a60777b337bea6" translate="yes" xml:space="preserve">
          <source>Creation</source>
          <target state="translated">Creation</target>
        </trans-unit>
        <trans-unit id="bfac50d6424b5166c3ee2808c85ae7c139b5182f" translate="yes" xml:space="preserve">
          <source>Credits</source>
          <target state="translated">Credits</target>
        </trans-unit>
        <trans-unit id="dbfe7362b2b881e1e5fb877d5c3a4872cad26c3a" translate="yes" xml:space="preserve">
          <source>Cross</source>
          <target state="translated">Cross</target>
        </trans-unit>
        <trans-unit id="beaa2e9dbdf1ef3ec15f5de471f07f4851c7dc4d" translate="yes" xml:space="preserve">
          <source>Cross-compilation</source>
          <target state="translated">Cross-compilation</target>
        </trans-unit>
        <trans-unit id="c43833b5347e1426f60796becda4f61af3fd0923" translate="yes" xml:space="preserve">
          <source>Cross-platform helper methods</source>
          <target state="translated">크로스 플랫폼 헬퍼 메소드</target>
        </trans-unit>
        <trans-unit id="011ef13d181b36064597a661d4df564056d4ff83" translate="yes" xml:space="preserve">
          <source>Cross-platform methods are being moved into MM_Any. If you can't find something that used to be in here, look in MM_Any.</source>
          <target state="translated">플랫폼 간 메소드가 MM_Any로 이동 중입니다. 여기에 있던 것을 찾을 수 없다면 MM_Any를보십시오.</target>
        </trans-unit>
        <trans-unit id="57799b23e7a710965dddb84cacd4ec89c1bbb1f6" translate="yes" xml:space="preserve">
          <source>Cross.U</source>
          <target state="translated">Cross.U</target>
        </trans-unit>
        <trans-unit id="ef9075f5545abec4dcc7e79d15c590cae4255eac" translate="yes" xml:space="preserve">
          <source>Cross.pm</source>
          <target state="translated">Cross.pm</target>
        </trans-unit>
        <trans-unit id="74c3c4ec5d65e9bc6995543581db9cbe363527f7" translate="yes" xml:space="preserve">
          <source>Cross/README</source>
          <target state="translated">Cross/README</target>
        </trans-unit>
        <trans-unit id="cef80d77f8c81ee5266d145a95eedb7c0a3f235f" translate="yes" xml:space="preserve">
          <source>Crypt</source>
          <target state="translated">Crypt</target>
        </trans-unit>
        <trans-unit id="ad96a37a856f346a15c53478f77eb332fbfa2f2b" translate="yes" xml:space="preserve">
          <source>Cryptographically signed modules</source>
          <target state="translated">암호화 서명 모듈</target>
        </trans-unit>
        <trans-unit id="0141138dc5196a48315b4577e2fbfbeecad52362" translate="yes" xml:space="preserve">
          <source>Csym.U</source>
          <target state="translated">Csym.U</target>
        </trans-unit>
        <trans-unit id="52962f195b14aa22c7fc6a7f9b3d2ee383096fec" translate="yes" xml:space="preserve">
          <source>Cuddle &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;../functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; blocks. For example, print</source>
          <target state="translated">안아 &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록을. 예를 들어, 인쇄</target>
        </trans-unit>
        <trans-unit id="d64219b5f8b4b745bbd46c3a32d3c7d8682cff39" translate="yes" xml:space="preserve">
          <source>Curious/ambitious users are welcome to propose additional features they wish to see in &lt;b&gt;Pod::Checker&lt;/b&gt; and &lt;b&gt;podchecker&lt;/b&gt; and verify that the checks are consistent with &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">호기심 / 야심 찬 사용자는 추가 자신들이보고 싶은 기능 제안 환영 &lt;b&gt;포드 :: 검사&lt;/b&gt; 및 &lt;b&gt;podchecker을&lt;/b&gt; 하고, 검사와 일치하는지 확인 &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c48ab463ed0ddf5261f0effba0a08bda055eaeb3" translate="yes" xml:space="preserve">
          <source>Curly brackets are required on &lt;code&gt;if&lt;/code&gt; 's and &lt;code&gt;while&lt;/code&gt; 's.</source>
          <target state="translated">곱슬 브래킷에 필요한 &lt;code&gt;if&lt;/code&gt; 의와 &lt;code&gt;while&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="25cb75f4de27b7e8de98e7a40cc8ed9bcd201ef1" translate="yes" xml:space="preserve">
          <source>Curly brackets are required on &lt;code&gt;if&lt;/code&gt; s and &lt;code&gt;while&lt;/code&gt; s.</source>
          <target state="translated">중괄호에 필요한 &lt;code&gt;if&lt;/code&gt; s와 &lt;code&gt;while&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="9ba0ffd4b3f7127883810edb9b6f993db6663d0a" translate="yes" xml:space="preserve">
          <source>Current EMX environment does not allow</source>
          <target state="translated">현재 EMX 환경은 허용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="993eca74c49b7893afb4ab9ac873257ea5c190b4" translate="yes" xml:space="preserve">
          <source>Current EMX environment does not allow DLLs compiled using Unixish &lt;code&gt;a.out&lt;/code&gt; format to export symbols for data (or at least some types of data). This forces &lt;code&gt;omf&lt;/code&gt; -style compile of</source>
          <target state="translated">현재 EMX 환경에서는 Unixish &lt;code&gt;a.out&lt;/code&gt; 형식을 사용하여 컴파일 된 DLL 이 데이터 (또는 적어도 일부 유형의 데이터)의 심볼을 내보낼 수 없습니다 . 이것은 &lt;code&gt;omf&lt;/code&gt; 스타일의 컴파일을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="68015f6bd2846a758438e4878547c94c08e2b442" translate="yes" xml:space="preserve">
          <source>Current experiments</source>
          <target state="translated">현재 실험</target>
        </trans-unit>
        <trans-unit id="2bb8d55eba9da4a81fde3753ae5baa7eec0d36a4" translate="yes" xml:space="preserve">
          <source>Current line number for the last filehandle accessed.</source>
          <target state="translated">마지막으로 액세스 한 파일 핸들의 현재 줄 번호.</target>
        </trans-unit>
        <trans-unit id="5550dac4e1e7661323b4986a995e2ca80043241b" translate="yes" xml:space="preserve">
          <source>Current maintainer: Jesse Vincent. &amp;lt;jesse@bestpractical.com&amp;gt;</source>
          <target state="translated">현재 관리자 : Jesse Vincent. &amp;lt;jesse@bestpractical.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c2eb4542085ed4c82b742e8aee8a24a813f00ba2" translate="yes" xml:space="preserve">
          <source>Current maintainer: Mark Allen &lt;code&gt;&amp;lt;mallen@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">현재 관리자 : Mark Allen &lt;code&gt;&amp;lt;mallen@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c582ebd636905458cf86a650443a01ac6fd3e11" translate="yes" xml:space="preserve">
          <source>Current maintainer: Mark Allen &lt;code&gt;&amp;lt;mallencpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">현재 관리자 : Mark Allen &lt;code&gt;&amp;lt;mallencpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b3ecd8cd4c7443afc115b419ddb924ddd90e1b" translate="yes" xml:space="preserve">
          <source>Current state of the interpreter.</source>
          <target state="translated">통역사의 현재 상태.</target>
        </trans-unit>
        <trans-unit id="196ba394fbe2cd700609c257874291b9dd014bf4" translate="yes" xml:space="preserve">
          <source>Currently $dir can only go down one level. &quot;foo&quot; is fine. &quot;foo/bar&quot; is not. &quot;../foo&quot; is right out.</source>
          <target state="translated">현재 $ dir은 한 수준 아래로 내려갈 수 있습니다. &quot;foo&quot;는 괜찮습니다. &quot;foo / bar&quot;는 아닙니다. &quot;../foo&quot;가 바로 나옵니다.</target>
        </trans-unit>
        <trans-unit id="7596cea97372e37b0806dba55a5df461274d6e60" translate="yes" xml:space="preserve">
          <source>Currently (October 2001), that's these three:</source>
          <target state="translated">현재 (2001 년 10 월) 다음 세 가지입니다.</target>
        </trans-unit>
        <trans-unit id="d0628d165c5886578d03829e62f234c1c39d03ea" translate="yes" xml:space="preserve">
          <source>Currently (as of perl version 5.004), use of the hash and array access functions requires the user to be aware of whether they are operating on &quot;normal&quot; hashes and arrays, or on their tied variants. The API may be changed to provide more transparent access to both tied and normal data types in future versions. [/MAYCHANGE]</source>
          <target state="translated">현재 (perl 버전 5.004 기준) 해시 및 어레이 액세스 기능을 사용하려면 사용자가 &quot;일반&quot;해시 및 어레이에서 작동하는지 또는 연결된 변형에서 작동 하는지를 알아야합니다. 향후 버전에서는 연결 및 일반 데이터 유형 모두에보다 투명하게 액세스 할 수 있도록 API가 변경 될 수 있습니다. [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="a2eb1a3bc586c516867d29f387fd017886e0b406" translate="yes" xml:space="preserve">
          <source>Currently I don't know of any portable pure perl way to do this. Suggestions welcome.</source>
          <target state="translated">현재이 작업을 수행하는 휴대용 순수한 펄 방법을 모르겠습니다. 제안을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="d97947adc89187fe49c51cd883b8269beca4ae8c" translate="yes" xml:space="preserve">
          <source>Currently NAME is restricted to simple identifiers only. In other words, it must match &lt;code&gt;/^[_A-Za-z][_A-Za-z0-9]*\z/&lt;/code&gt; or its Unicode extension (see &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;), though it isn't extended by the locale (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;).</source>
          <target state="translated">현재 NAME은 간단한 식별자로만 제한됩니다. 즉, 로케일로 확장되지는 않지만 &lt;code&gt;/^[_A-Za-z][_A-Za-z0-9]*\z/&lt;/code&gt; 또는 해당 유니 코드 확장명 ( &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 참조 ) 과 일치해야합니다 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ). ).</target>
        </trans-unit>
        <trans-unit id="834c134ad81c4eaed0abb95e07ecfa3c6f7ccea9" translate="yes" xml:space="preserve">
          <source>Currently all versions of IBM's &quot;xlc&quot;, &quot;xlc_r&quot;, &quot;cc&quot;, &quot;cc_r&quot; or &quot;vac&quot; ANSI/C compiler will work for building Perl if that compiler works on your system.</source>
          <target state="translated">현재 IBM의 &quot;xlc&quot;, &quot;xlc_r&quot;, &quot;cc&quot;, &quot;cc_r&quot;또는 &quot;vac&quot;ANSI / C 컴파일러의 모든 버전은 해당 컴파일러가 시스템에서 작동하는 경우 Perl을 빌드하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="074b7a0d7926b13bdd6a6c1a7f2bd6fd96a950ef" translate="yes" xml:space="preserve">
          <source>Currently doesn't do anything at all. This flag has been a no-op for many versions of perl, at least as far back as perl5.003_07. It's allowed here for backwards compatibility.</source>
          <target state="translated">현재는 아무것도하지 않습니다. 이 플래그는 최소한 perl5.003_07로 거슬러 올라가는 많은 버전의 perl에 대해서는 no-op입니다. 이전 버전과의 호환성을 위해 여기에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6aff6e1789a080263345630866061a6188dd023" translate="yes" xml:space="preserve">
          <source>Currently experimental, strongly object-oriented, built for speed and intended as a toolkit for building micro web apps, custom frameworks or for tieing together existing Plack-compatible web applications with one central dispatcher.</source>
          <target state="translated">현재 실험적이고 강력하게 객체 지향적이며 속도를 높이기 위해 제작되었으며 마이크로 웹 앱, 사용자 지정 프레임 워크를 구축하거나 기존 Plack 호환 웹 응용 프로그램을 하나의 중앙 디스패처와 연결하기위한 툴킷으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09e5d195957c36cd6b2d43df6986ebc708f4c278" translate="yes" xml:space="preserve">
          <source>Currently installation instructions are at &lt;a href=&quot;http://perlce.sourceforge.net/&quot;&gt;http://perlce.sourceforge.net/&lt;/a&gt;.</source>
          <target state="translated">현재 설치 지침은 &lt;a href=&quot;http://perlce.sourceforge.net/&quot;&gt;http://perlce.sourceforge.net/에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e0d0b77d9ca938b7c7fd7206793cd1d22b949a5" translate="yes" xml:space="preserve">
          <source>Currently internal buffer lengths are limited to 32-bit only.</source>
          <target state="translated">현재 내부 버퍼 길이는 32 비트로 만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2589b2340931b7a94577d8448f79f08344610895" translate="yes" xml:space="preserve">
          <source>Currently it is too complicated to parse your command for IO redirections. For capturing STDOUT or STDERR there is a work around however, since you can just inspect your buffers for the contents.</source>
          <target state="translated">현재 IO 리디렉션에 대한 명령을 구문 분석하는 것은 너무 복잡합니다. STDOUT 또는 STDERR을 캡처하려면 버퍼의 내용을 검사하기 만하면 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ce11c20e5c9e26183b7df1f1d378e8843b7728" translate="yes" xml:space="preserve">
          <source>Currently loaded filename.</source>
          <target state="translated">현재로드 된 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5e94b5b9580ddc9978e1586fd290c6a0085eaca0" translate="yes" xml:space="preserve">
          <source>Currently maintained by Jonathan &quot;Duke&quot; Leto &amp;lt;jonathan@leto.net&amp;gt; &lt;a href=&quot;http://leto.net&quot;&gt;http://leto.net&lt;/a&gt;</source>
          <target state="translated">현재 Jonathan &quot;Duke&quot;Leto &amp;lt;jonathan@leto.net&amp;gt; &lt;a href=&quot;http://leto.net&quot;&gt;http://leto.net에서 관리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f84d89a92a777c50292f613277c843d0fca069e" translate="yes" xml:space="preserve">
          <source>Currently maintained by Ken Williams &lt;code&gt;&amp;lt;KWILLIAMS@cpan.org&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">현재 Ken Williams &lt;code&gt;&amp;lt;KWILLIAMS@cpan.org&amp;gt;&lt;/code&gt; 에서 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="3d499a420a8ad407cfcc7909e99725791aecb83a" translate="yes" xml:space="preserve">
          <source>Currently maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt;</source>
          <target state="translated">현재 Michael G Schwern이 관리합니다. &lt;code&gt;schwern@pobox.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64518f708c077132fb6c81bb482b7c41112aa09f" translate="yes" xml:space="preserve">
          <source>Currently maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; .</source>
          <target state="translated">현재 Michael G Schwern이 &lt;code&gt;schwern@pobox.com&lt;/code&gt; 합니다. schwern@pobox.com .</target>
        </trans-unit>
        <trans-unit id="ac278ddc5ecea025d9c9b038420a6a20095c0d36" translate="yes" xml:space="preserve">
          <source>Currently maintained by Sullivan Beck (sbeck@cpan.org).</source>
          <target state="translated">현재 Sullivan Beck (sbeck@cpan.org)가 관리합니다.</target>
        </trans-unit>
        <trans-unit id="832ca62474658800234e1409a0265d04df2848bc" translate="yes" xml:space="preserve">
          <source>Currently maintained by the Perl 5 Porters, &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">현재 Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;에서 관리합니다.</target>
        </trans-unit>
        <trans-unit id="70916c857e67092afc3818c0725979a17bb2bc7e" translate="yes" xml:space="preserve">
          <source>Currently maintained by the Perl Toolchain Gang.</source>
          <target state="translated">현재 Perl Toolchain Gang이 유지 관리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b5ae24b9fd013adf87b86fd8614fe4c5e78cae" translate="yes" xml:space="preserve">
          <source>Currently maintained by the perl 5 porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">현재 perl 5 포터 &amp;lt;perl5-porters@perl.org&amp;gt;에서 관리합니다.</target>
        </trans-unit>
        <trans-unit id="805cd2c1f1ca0def4cfd6434add453f59f15d8ad" translate="yes" xml:space="preserve">
          <source>Currently only &lt;code&gt;INDENT&lt;/code&gt; , &lt;code&gt;NAME&lt;/code&gt; , &lt;code&gt;DEFAULT_TYPE&lt;/code&gt; , &lt;code&gt;NAMES&lt;/code&gt; , &lt;code&gt;C_FILE&lt;/code&gt; and &lt;code&gt;XS_FILE&lt;/code&gt; are recognised.</source>
          <target state="translated">현재 &lt;code&gt;INDENT&lt;/code&gt; , &lt;code&gt;NAME&lt;/code&gt; , &lt;code&gt;DEFAULT_TYPE&lt;/code&gt; , &lt;code&gt;NAMES&lt;/code&gt; , &lt;code&gt;C_FILE&lt;/code&gt; 및 &lt;code&gt;XS_FILE&lt;/code&gt; 만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="7d9f8fb10567a5f5b286e925fe020ed9ddbe898d" translate="yes" xml:space="preserve">
          <source>Currently only emitted when a printf-type format required more arguments than were supplied, but might be used in the future for other cases where we can statically determine that arguments to functions are missing, e.g. for the &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; function.</source>
          <target state="translated">현재 printf 형식 형식이 제공된 것보다 많은 인수를 필요로 할 때만 방출되지만 &lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; 함수와 같이 함수에 대한 인수가 누락되었다고 정적으로 결정할 수있는 다른 경우에는 나중에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c06671bbb84a6f3c0a5e03cc037107c5b937b959" translate="yes" xml:space="preserve">
          <source>Currently the base class does nothing and returns an empty string.</source>
          <target state="translated">현재 기본 클래스는 아무것도하지 않고 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e65fb55b89a16a6ff17064471534fc5b44c3a09" translate="yes" xml:space="preserve">
          <source>Currently the cache manager only keeps track of the build directory ($CPAN::Config-&amp;gt;{build_dir}). It is a simple FIFO mechanism that deletes complete directories below &lt;code&gt;build_dir&lt;/code&gt; as soon as the size of all directories there gets bigger than $CPAN::Config-&amp;gt;{build_cache} (in MB). The contents of this cache may be used for later re-installations that you intend to do manually, but will never be trusted by CPAN itself. This is due to the fact that the user might use these directories for building modules on different architectures.</source>
          <target state="translated">현재 캐시 관리자는 빌드 디렉토리 ($ CPAN :: Config-&amp;gt; {build_dir}) 만 추적합니다. 모든 디렉토리의 크기가 $ CPAN :: Config-&amp;gt; {build_cache} (MB)보다 커지면 &lt;code&gt;build_dir&lt;/code&gt; 아래의 완전한 디렉토리를 삭제하는 간단한 FIFO 메커니즘입니다 . 이 캐시의 내용은 수동으로 수행하려는 나중에 다시 설치하는 데 사용될 수 있지만 CPAN 자체는 절대 신뢰하지 않습니다. 이는 사용자가이 디렉토리를 사용하여 다른 아키텍처에서 모듈을 빌드 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="85cb1004cde4eafeabb526e7c97d06160b9bc9ea" translate="yes" xml:space="preserve">
          <source>Currently the example could be something like this:</source>
          <target state="translated">현재 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ed938fc9ec074335a5a14ff39713fa96e2a44d4" translate="yes" xml:space="preserve">
          <source>Currently the first argument to define_alias() can be specified in the following ways:</source>
          <target state="translated">현재 define_alias ()의 첫 번째 인수는 다음과 같은 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9bf96de0559faf3b7e1d096d1d8a5e2e4453bbc" translate="yes" xml:space="preserve">
          <source>Currently the following two build types are tested on NetWare:</source>
          <target state="translated">현재 다음 두 가지 빌드 유형이 NetWare에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="0dfd46b204fb5d45e8f29132257a9dee7ed55c16" translate="yes" xml:space="preserve">
          <source>Currently the mantissa is reduced as much as possible, favouring higher exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0). This might change in the future, so do not depend on it.</source>
          <target state="translated">현재 가수는 가능한 한 많이 감소되어 낮은 것보다 높은 지수를 선호합니다 (예 : 10e6 또는 10000000e0 대신 1e7을 반환). 향후에 변경 될 수 있으므로 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc52fa0221b520eb9cba69f5a8200cdef9bbc7cb" translate="yes" xml:space="preserve">
          <source>Currently the methods aren't as efficient as they could be, for reasons of clarity. This is probably a bad idea.</source>
          <target state="translated">현재이 방법은 명확성으로 인해 효율적이지 않습니다. 이것은 아마도 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="f8b020b4d907e7d336baf4a7bd1d21f0a642b241" translate="yes" xml:space="preserve">
          <source>Currently the only significant values are 'dmake' and 'nmake' for Windows users, instructing MakeMaker to generate a Makefile in the flavour of DMake (&quot;Dennis Vadura's Make&quot;) or Microsoft NMake respectively.</source>
          <target state="translated">현재 유일하게 중요한 값은 Windows 사용자를위한 'dmake'및 'nmake'이며, MakeMaker가 DMake ( &quot;Dennis Vadura 's Make&quot;) 또는 Microsoft NMake의 풍미로 Makefile을 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f00b6778578143fea75a49ef468f9d31966e2d9a" translate="yes" xml:space="preserve">
          <source>Currently the value of &lt;code&gt;DISPLAY&lt;/code&gt; is ignored. It is recommended that it be set to be the hostname of the display, the server and screen in Unix notation. In the future the value of DISPLAY may be honored by Perl instead of using the default display.</source>
          <target state="translated">현재 &lt;code&gt;DISPLAY&lt;/code&gt; 값 은 무시됩니다. 유닉스 표기법에서 디스플레이, 서버 및 화면의 호스트 이름으로 설정하는 것이 좋습니다. 앞으로 DISPLAY의 값은 기본 디스플레이를 사용하는 대신 Perl에 의해 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8768013178cf8fe711f0d308fff8053c79e45b7a" translate="yes" xml:space="preserve">
          <source>Currently there is no way to specify more than one library on the command line. This means the following does not work:</source>
          <target state="translated">현재 명령 행에 둘 이상의 라이브러리를 지정할 수있는 방법이 없습니다. 이것은 다음이 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a39b8349c59ac646b8af631b5ad977955e371ebf" translate="yes" xml:space="preserve">
          <source>Currently there is only one type of field hash, and only the boolean value of the mode makes a difference, but that may change.</source>
          <target state="translated">현재 필드 해시에는 한 가지 유형 만 있으며 모드의 부울 값만 차이가 있지만 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3b9b162a3784fe295b868497fbb629b1ddd426" translate="yes" xml:space="preserve">
          <source>Currently this OS-specific stuff consists of looking in the environment variables &quot;LANG&quot; and &quot;LANGUAGE&quot;; and on MSWin machines (where those variables are typically unused), this also tries using the module Win32::Locale to get a language-tag for whatever language/locale is currently selected in the &quot;Regional Settings&quot; (or &quot;International&quot;?) Control Panel. I welcome further suggestions for making this do the Right Thing under other operating systems that support localization.</source>
          <target state="translated">현재이 OS 특정 항목은 환경 변수 &quot;LANG&quot;및 &quot;LANGUAGE&quot;로 구성됩니다. MSWin 컴퓨터 (이러한 변수는 일반적으로 사용되지 않는)에서는 Win32 :: Locale 모듈을 사용하여 현재 &quot;지역 설정&quot;(또는 &quot;국제&quot;?)에서 선택한 언어 / 로캘에 대한 언어 태그를 가져옵니다. 제어판. 현지화를 지원하는 다른 운영 체제에서 올바른 작업을 수행하기위한 추가 제안을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="1b78daa9cb8c8ba0c96aabebf728d92ea741a97c" translate="yes" xml:space="preserve">
          <source>Currently this always uses mergesort. See sortsv_flags for a more flexible routine.</source>
          <target state="translated">현재 이것은 항상 mergesort를 사용합니다. 보다 유연한 루틴에 대해서는 sortsv_flags를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99139b870fbe31ffb01aeaae72d3575f4248f3e1" translate="yes" xml:space="preserve">
          <source>Currently this class works by just filtering out the non-Pod stuff from a given input file.</source>
          <target state="translated">현재이 클래스는 특정 입력 파일에서 포드 이외의 항목을 필터링하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8c05bed42565fb273b3a58a2b778911f3dba48d8" translate="yes" xml:space="preserve">
          <source>Currently this has only been tested on Unix and doesn't contain any of the Windows-specific code from the &lt;code&gt;Module::Build&lt;/code&gt; project. I'll do that next.</source>
          <target state="translated">현재 이것은 유닉스에서만 테스트되었으며 &lt;code&gt;Module::Build&lt;/code&gt; 프로젝트 의 Windows 특정 코드를 포함하지 않습니다 . 다음에하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6c09a661f6643655325273d50b2f4ce06d5609d8" translate="yes" xml:space="preserve">
          <source>Currently this isn't used for anything, but it's provided (with default value of &lt;code&gt;(ref($language) &amp;amp;&amp;amp; $language-&amp;gt;{'encoding'})) or &quot;iso-8859-1&quot;&lt;/code&gt; ) as a sort of suggestion that it may be useful/necessary to associate encodings with your language handles (whether on a per-class or even per-handle basis.)</source>
          <target state="translated">현재 이것은 아무것도 사용되지 않지만 ((default &lt;code&gt;(ref($language) &amp;amp;&amp;amp; $language-&amp;gt;{'encoding'})) or &quot;iso-8859-1&quot;&lt;/code&gt; )은 일종의 제안으로 제공됩니다. 언어 클래스와 인코딩을 연결하는 것이 유용하거나 필요할 수 있습니다 (클래스 별 또는 심지어 핸들별로).</target>
        </trans-unit>
        <trans-unit id="2fe9e02e28a1376fbaaa825eb0420d6aa9001bf2" translate="yes" xml:space="preserve">
          <source>Currently this just takes the last bit of &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref($language)&lt;/a&gt;&lt;/code&gt;, turns underscores to dashes, and returns it. So if $language is an object of class Hee::HOO::Haw::en_us, $language-&amp;gt;language_tag() returns &quot;en-us&quot;. (Yes, the usual representation for that language tag is &quot;en-US&quot;, but case is</source>
          <target state="translated">현재 이것은 &lt;code&gt;&lt;a href=&quot;../functions/ref&quot;&gt;ref($language)&lt;/a&gt;&lt;/code&gt; 의 마지막 비트를 취하고 밑줄을 대시로 바꾼 다음 반환합니다. 따라서 $ language가 Hee :: HOO :: Haw :: en_us 클래스의 객체 인 경우 $ language-&amp;gt; language_tag ()는 &quot;en-us&quot;를 반환합니다. (예, 해당 언어 태그의 일반적인 표현은 &quot;en-US&quot;이지만 대소 문자는</target>
        </trans-unit>
        <trans-unit id="79f7485198cd482639db4f4626a9508a51ae8d0f" translate="yes" xml:space="preserve">
          <source>Currently this module understands the following types. h2xs may only know a subset. The sizes of the numeric types are chosen by the &lt;code&gt;Configure&lt;/code&gt; script at compile time.</source>
          <target state="translated">현재이 모듈은 다음 유형을 이해합니다. h2x는 하위 집합 만 알 수 있습니다. 숫자 유형의 크기는 컴파일 타임에 &lt;code&gt;Configure&lt;/code&gt; 스크립트에 의해 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2d377b4476a6e188762144f586ad2d608b464a9" translate="yes" xml:space="preserve">
          <source>Currently, &lt;code&gt;given&lt;/code&gt; blocks can't always be used as proper expressions. This may be addressed in a future version of Perl.</source>
          <target state="translated">현재 &lt;code&gt;given&lt;/code&gt; 블록을 항상 적절한 표현으로 사용할 수있는 것은 아닙니다. 이것은 향후 버전의 Perl에서 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d26c1593e61e13dda079b542bc00ebe32e1e263" translate="yes" xml:space="preserve">
          <source>Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('') results in 'NaN'. This might change in the future, so use always the following explicit forms to get a zero or NaN:</source>
          <target state="translated">현재 Math :: BigInt :: new ()의 기본값은 0이며 Math :: BigInt :: new ( '')의 결과는 'NaN'입니다. 앞으로 변경 될 수 있으므로 항상 다음 명시 적 양식을 사용하여 0 또는 NaN을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="5a3571347f1fb8b0138ff4086aa2cd9a390c3586" translate="yes" xml:space="preserve">
          <source>Currently, Perl deals with UTF-8 strings and non-UTF-8 strings slightly differently. A flag in the SV, &lt;code&gt;SVf_UTF8&lt;/code&gt; , indicates that the string is internally encoded as UTF-8. Without it, the byte value is the codepoint number and vice versa. This flag is only meaningful if the SV is &lt;code&gt;SvPOK&lt;/code&gt; or immediately after stringification via &lt;code&gt;SvPV&lt;/code&gt; or a similar macro. You can check and manipulate this flag with the following macros:</source>
          <target state="translated">현재 Perl은 UTF-8 문자열과 비 UTF-8 문자열을 약간 다르게 처리합니다. SV의 &lt;code&gt;SVf_UTF8&lt;/code&gt; 플래그 는 문자열이 내부적으로 UTF-8로 인코딩됨을 나타냅니다. 이를 사용하지 않으면 바이트 값은 코드 포인트 번호이며 그 반대도 마찬가지입니다. 이 플래그는 SV가 &lt;code&gt;SvPOK&lt;/code&gt; 이거나 &lt;code&gt;SvPV&lt;/code&gt; 또는 유사한 매크로 를 통한 스트링 화 직후에 의미가 있습니다. 다음 매크로를 사용하여이 플래그를 확인하고 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf064da20402a373389bd1e8534e66d897ddfb89" translate="yes" xml:space="preserve">
          <source>Currently, an unescaped &quot;~&quot; before a character other than a bracket or a comma is taken to mean just a &quot;~&quot; and that character. I.e., &quot;~X&quot; means the same as &quot;~~X&quot; -- i.e., one literal tilde, and then one literal &quot;X&quot;. However, by using &quot;~X&quot;, you are assuming that no future version of Maketext will use &quot;~X&quot; as a magic escape sequence. In practice this is not a great problem, since first off you can just write &quot;~~X&quot; and not worry about it; second off, I doubt I'll add lots of new magic characters to bracket notation; and third off, you aren't likely to want literal &quot;~&quot; characters in your messages anyway, since it's not a character with wide use in natural language text.</source>
          <target state="translated">현재 대괄호 나 쉼표 이외의 문자 앞에있는 이스케이프 처리되지 않은 &quot;~&quot;는 &quot;~&quot;와 해당 문자를 의미합니다. 즉, &quot;~ X&quot;는 &quot;~~ X&quot;와 동일 함을 의미합니다. 즉, 하나의 리터럴 물결표 다음에 하나의 리터럴 &quot;X&quot;입니다. 그러나 &quot;~ X&quot;를 사용하면 이후 버전의 Maketext에서 &quot;~ X&quot;를 매직 이스케이프 시퀀스로 사용하지 않을 것이라고 가정합니다. 실제로 이것은 &quot;~~ X&quot;라고 쓸 수 있고 걱정하지 않아도되므로 큰 문제는 아닙니다. 둘째, 대괄호 표기법에 많은 새로운 마법 캐릭터를 추가 할 것입니다. 셋째로, 어쨌든 메시지에 문자 &quot;~&quot;문자를 원하지 않을 것입니다. 자연어 텍스트에서 널리 사용되는 문자가 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="32c5c8dadaaaf31c38a9691666537875247237cb" translate="yes" xml:space="preserve">
          <source>Currently, bracket groups do not nest. That is, you &lt;b&gt;cannot&lt;/b&gt; say:</source>
          <target state="translated">현재 대괄호 그룹은 중첩되지 않습니다. 즉, 당신 &lt;b&gt;은&lt;/b&gt; 말할 &lt;b&gt;수 없습니다&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="c35cdca66e034e7f9a47d31a205334d612013eef" translate="yes" xml:space="preserve">
          <source>Currently, for BigInts &lt;code&gt;$e&lt;/code&gt; is always 0, except +inf and -inf, where it is &lt;code&gt;+inf&lt;/code&gt; ; and for NaN, where it is &lt;code&gt;NaN&lt;/code&gt; ; and for &lt;code&gt;$x == 0&lt;/code&gt; , where it is &lt;code&gt;1&lt;/code&gt; (to be compatible with Math::BigFloat's internal representation of a zero as &lt;code&gt;0E1&lt;/code&gt; ).</source>
          <target state="translated">현재 BigInts을 위해 &lt;code&gt;$e&lt;/code&gt; 그것이 + INF와 -INF를 제외하고 항상 0 &lt;code&gt;+inf&lt;/code&gt; ; NaN의 경우, &lt;code&gt;NaN&lt;/code&gt; 이고; 그리고 &lt;code&gt;$x == 0&lt;/code&gt; 이면 &lt;code&gt;1&lt;/code&gt; 입니다 (Math :: BigFloat의 0으로 &lt;code&gt;0E1&lt;/code&gt; 의 내부 표현과 호환 가능 ).</target>
        </trans-unit>
        <trans-unit id="beb5d0250d9ace27aad40903e5fff21089b05d9e" translate="yes" xml:space="preserve">
          <source>Currently, on all platforms except MSWin32, all</source>
          <target state="translated">현재 MSWin32를 제외한 모든 플랫폼에서</target>
        </trans-unit>
        <trans-unit id="93a247e0eef683aaac7910c01f3f928a9e46d78c" translate="yes" xml:space="preserve">
          <source>Currently, only the &lt;code&gt;access&lt;/code&gt; sub-pragma is implemented. It enables (or disables) the use of access() when available, that is, on most UNIX systems and other POSIX environments. See details below.</source>
          <target state="translated">현재는 &lt;code&gt;access&lt;/code&gt; 서브 프라 그마 만 구현됩니다. 사용 가능한 경우, 즉 대부분의 UNIX 시스템 및 기타 POSIX 환경에서 access () 사용을 활성화 (또는 비활성화)합니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12cb6e902a01a88f56d9045c1e314fafc987b2ba" translate="yes" xml:space="preserve">
          <source>Currently, the only significant value for &lt;code&gt;flags&lt;/code&gt; is SVf_UTF8.</source>
          <target state="translated">현재 &lt;code&gt;flags&lt;/code&gt; 중요한 값 은 SVf_UTF8입니다.</target>
        </trans-unit>
        <trans-unit id="c22d9a7fee9cae91b42a0d8e2cfac398a39a9b2b" translate="yes" xml:space="preserve">
          <source>Currently, the only useful value for &lt;code&gt;flags&lt;/code&gt; is SVf_UTF8.</source>
          <target state="translated">현재 &lt;code&gt;flags&lt;/code&gt; 유용한 유일한 값 은 SVf_UTF8입니다.</target>
        </trans-unit>
        <trans-unit id="2b251ef9a6ee9de77a03ddc9608c4a3c0db1c0a0" translate="yes" xml:space="preserve">
          <source>Currently, the outermost formatting instruction wins, so for example underlined text inside a region of bold text is displayed as simply bold. There may be some better approach possible.</source>
          <target state="translated">현재 가장 바깥 쪽 서식 명령이 성공하므로 예를 들어 굵은 텍스트 영역 내의 밑줄이있는 텍스트는 단순히 굵게 표시됩니다. 더 나은 접근 방법이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca8600ba039585f9f853e2c43bcdff7d5ab9e0b" translate="yes" xml:space="preserve">
          <source>Currently, the subroutine can be identified statically if the RV that the &lt;code&gt;rv2cv&lt;/code&gt; is to operate on is provided by a suitable &lt;code&gt;gv&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; op. A &lt;code&gt;gv&lt;/code&gt; op is suitable if the GV's CV slot is populated. A &lt;code&gt;const&lt;/code&gt; op is suitable if the constant value must be an RV pointing to a CV. Details of this process may change in future versions of Perl. If the &lt;code&gt;rv2cv&lt;/code&gt; op has the &lt;code&gt;OPpENTERSUB_AMPER&lt;/code&gt; flag set then no attempt is made to identify the subroutine statically: this flag is used to suppress compile-time magic on a subroutine call, forcing it to use default runtime behaviour.</source>
          <target state="translated">현재, &lt;code&gt;rv2cv&lt;/code&gt; 가 동작 할 RV가 적절한 &lt;code&gt;gv&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; op에 의해 제공 된다면 서브 루틴은 정적으로 식별 될 수있다 . &lt;code&gt;gv&lt;/code&gt; GV의 CV 슬롯이 채워지는 경우 영업 이익은 적합합니다. ㅏ &lt;code&gt;const&lt;/code&gt; 상수 값이 CV을 가리키는 RV 있어야한다면 OP가 적합하다. 이 프로세스의 세부 사항은 이후 버전의 Perl에서 변경 될 수 있습니다. 는 IF &lt;code&gt;rv2cv&lt;/code&gt; 의 영업 이익이있다 &lt;code&gt;OPpENTERSUB_AMPER&lt;/code&gt; 의 다음 시도가 정적 서브 루틴을 식별하기 위해 이루어지지 않습니다 플래그가 설정 :이 플래그는 기본 런타임 동작을 사용하도록 강제 서브 루틴 호출에 억제 컴파일시 마법 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e2d2e7b351cedc7ed2289316efdff5558012869" translate="yes" xml:space="preserve">
          <source>Currently, we only allow opened filehandles or filenames, but not strings. The internals would need some reworking to facilitate stringified archives.</source>
          <target state="translated">현재는 열린 파일 핸들 또는 파일 이름 만 허용하지만 문자열은 허용하지 않습니다. 내부는 문자열 아카이브를 용이하게하기 위해 약간의 재 작업이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="810afe6a34891b144a1f9e0ce40e9fc1217c35e6" translate="yes" xml:space="preserve">
          <source>Currently, we only support this if the filehandle is an IO::Zlib object. Environments, like apache, will present you with an opened filehandle to an uploaded file, which might be a compressed archive.</source>
          <target state="translated">현재 파일 핸들이 IO :: Zlib 객체 인 경우에만이 기능을 지원합니다. 아파치와 같은 환경에서는 압축 된 아카이브 일 수있는 업로드 된 파일에 열린 파일 핸들을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="261fc98a0206bd66bd4ad6212e54d2bfab7d8db4" translate="yes" xml:space="preserve">
          <source>Currently, whether or not the test suite passed with no 'problems' (such as TODO passed).</source>
          <target state="translated">현재 테스트 스위트가 '문제'없이 통과했는지 여부 (예 : TODO 통과)</target>
        </trans-unit>
        <trans-unit id="c505ffc91edd3f9012e8a66a72815302c62cb3ca" translate="yes" xml:space="preserve">
          <source>Currently, you must be running at least perl v5.6.0 in order to run with MEDIUM or HIGH security. This is simply because the safety tests use functions from L</source>
          <target state="translated">현재 MEDIUM 또는 HIGH 보안으로 실행하려면 perl v5.6.0 이상을 실행해야합니다. 안전 테스트는 L의 기능을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="19f401a7406fb2ade217c4c2d091602740509bb8" translate="yes" xml:space="preserve">
          <source>Curtis &quot;Ovid&quot; Poe &amp;lt;ovid@cpan.org&amp;gt;</source>
          <target state="translated">커티스 &quot;Ovid&quot;Poe &amp;lt;ovid@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7afc80af35ce6ee31ebae219a53944bd2652c7da" translate="yes" xml:space="preserve">
          <source>Custom Layers</source>
          <target state="translated">커스텀 레이어</target>
        </trans-unit>
        <trans-unit id="dbdaeda1e073966b4e479d9fff0e7793b0904106" translate="yes" xml:space="preserve">
          <source>Custom Operators</source>
          <target state="translated">맞춤 연산자</target>
        </trans-unit>
        <trans-unit id="d0eae33b0c090e3966d3c68512ada19e1528011c" translate="yes" xml:space="preserve">
          <source>Custom formatters can be loaded configured using the &lt;code&gt;formatter_class&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;formatter_class&lt;/code&gt; 매개 변수를 사용하여 사용자 정의 포맷터 를 &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; 로로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53cff91188bebb2a553103fb8e7b63cd42bccaa2" translate="yes" xml:space="preserve">
          <source>Custom operator support is an experimental feature that allows you to define your own ops. This is primarily to allow the building of interpreters for other languages in the Perl core, but it also allows optimizations through the creation of &quot;macro-ops&quot; (ops which perform the functions of multiple ops which are usually executed together, such as &lt;code&gt;gvsv, gvsv, add&lt;/code&gt; .)</source>
          <target state="translated">사용자 지정 연산자 지원은 실험 기능으로 자신 만의 작전을 정의 할 수 있습니다. 이는 주로 Perl 코어에서 다른 언어에 대한 통역사를 구축 할 수 있도록하기위한 것이지만, &quot;매크로-옵스&quot;( &lt;code&gt;gvsv, gvsv, add&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="b8a0f9b4738b676273a2a999093c300569cd6824" translate="yes" xml:space="preserve">
          <source>Customization of the dist targets can be done by specifying a hash reference to the dist attribute of the WriteMakefile call. The following parameters are recognized:</source>
          <target state="translated">dist 대상의 사용자 정의는 WriteMakefile 호출의 dist 속성에 대한 해시 참조를 지정하여 수행 할 수 있습니다. 다음과 같은 파라미터가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9b392a3be38eacab1a203c181ca6e780bde6d0" translate="yes" xml:space="preserve">
          <source>Customized option parser for Pod::Perldoc</source>
          <target state="translated">Pod :: Perldoc 용 맞춤형 옵션 파서</target>
        </trans-unit>
        <trans-unit id="d0f3d41e3c41ddc6cbc9c2daec27882d80caea71" translate="yes" xml:space="preserve">
          <source>Cwd</source>
          <target state="translated">Cwd</target>
        </trans-unit>
        <trans-unit id="fd9825bfa4c850e67c2151a6f5292a3e86f0c912" translate="yes" xml:space="preserve">
          <source>Cwd - get pathname of current working directory</source>
          <target state="translated">Cwd-현재 작업 디렉토리의 경로 이름 가져 오기</target>
        </trans-unit>
        <trans-unit id="160555969f1a8fde234517fab23669eee0ccbd1e" translate="yes" xml:space="preserve">
          <source>Cwd.xs</source>
          <target state="translated">Cwd.xs</target>
        </trans-unit>
        <trans-unit id="73fc7f50fdec5b6f0f95bef5f8e06196f92c8ab5" translate="yes" xml:space="preserve">
          <source>Cygwin = GNU+Cygnus+Windows (Don't leave UNIX without it)</source>
          <target state="translated">Cygwin = GNU + Cygnus + Windows (UNIX를 떠나지 마십시오)</target>
        </trans-unit>
        <trans-unit id="b410b02920a07e0c1b2f5517c0638087253c2758" translate="yes" xml:space="preserve">
          <source>Cygwin Configuration</source>
          <target state="translated">Cygwin 구성</target>
        </trans-unit>
        <trans-unit id="f2fd19eff84130ae501b7f66fc64ed3790d3e356" translate="yes" xml:space="preserve">
          <source>Cygwin does an outstanding job of providing UNIX-like semantics on top of Win32 systems. However, in addition to the items noted above, there are some differences that you should know about. This is a very brief guide to portability, more information can be found in the Cygwin documentation.</source>
          <target state="translated">Cygwin은 Win32 시스템에서 UNIX와 유사한 의미를 제공하는 뛰어난 작업을 수행합니다. 그러나 위에서 언급 한 항목 외에도 알아야 할 몇 가지 차이점이 있습니다. 이것은 이식성에 대한 매우 간단한 안내서이며, 자세한 내용은 Cygwin 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39bcb7dc63150f69c7968352d73ab68ec6457826" translate="yes" xml:space="preserve">
          <source>Cygwin does not initialize all original Win32 environment variables. See the bottom of this page &lt;a href=&quot;http://cygwin.com/cygwin-ug-net/setup-env.html&quot;&gt;http://cygwin.com/cygwin-ug-net/setup-env.html&lt;/a&gt; for &quot;Restricted Win32 environment&quot;.</source>
          <target state="translated">Cygwin은 모든 원래 Win32 환경 변수를 초기화하지 않습니다. &quot;제한된 Win32 환경&quot;에 대해서는 이 페이지 하단 &lt;a href=&quot;http://cygwin.com/cygwin-ug-net/setup-env.html&quot;&gt;http://cygwin.com/cygwin-ug-net/setup-env.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="81c2c7aa1db1394160b27a38c6928b843acda7e8" translate="yes" xml:space="preserve">
          <source>Cygwin is covered by the GNU General Public License (but that shouldn't matter for Perl use). Cygwin contains (in addition to the shell) a comprehensive set of standard Unix toolkit utilities.</source>
          <target state="translated">Cygwin은 GNU General Public License에 의해 보호됩니다 (그러나 Perl 사용에는 중요하지 않습니다). Cygwin에는 포괄적 인 표준 Unix 툴킷 유틸리티 세트 (쉘 외에도)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8258ca2d192f15ab780ba7a84929a7edb3f631ab" translate="yes" xml:space="preserve">
          <source>Cygwin pathnames are separated by forward (</source>
          <target state="translated">Cygwin 경로 이름은 앞으로 (</target>
        </trans-unit>
        <trans-unit id="9651770d389e8830b4b1e3539f723c1e80eca364" translate="yes" xml:space="preserve">
          <source>Cygwin processes have their own pid, which is different from the underlying windows pid. Most posix compliant Proc functions expect the cygwin pid, but several Win32::Process functions expect the winpid. E.g. &lt;code&gt;$$&lt;/code&gt; is the cygwin pid of</source>
          <target state="translated">Cygwin 프로세스에는 자체 pid가 있으며 기본 pid와 다릅니다. 대부분의 posix 호환 Proc 함수는 cygwin pid를 기대하지만 여러 Win32 :: Process 함수는 winpid를 기대합니다. 예 : &lt;code&gt;$$&lt;/code&gt; 는 cygwin pid입니다.</target>
        </trans-unit>
        <trans-unit id="05c0c2f636a8edb75c77d41c4c7bfc716236cfce" translate="yes" xml:space="preserve">
          <source>Cygwin uses 64-bit integers for internal size and position calculations, this will be correctly detected and defined by Configure.</source>
          <target state="translated">Cygwin은 내부 크기 및 위치 계산에 64 비트 정수를 사용합니다. 이는 Configure에 의해 올바르게 감지 및 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d140941c1521d2349d4bd6c64c31475654a7b43c" translate="yes" xml:space="preserve">
          <source>Cylindrical coordinates,</source>
          <target state="translated">원통형 좌표,</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="96f0e31b49aae2a6d915ae3b613e4575c8b6a5d9" translate="yes" xml:space="preserve">
          <source>D. INSTALL</source>
          <target state="translated">D. 설치</target>
        </trans-unit>
        <trans-unit id="7f2430aff77c078755160a61817f59ac5a442628" translate="yes" xml:space="preserve">
          <source>D. Wegscheid &amp;lt;wegscd@whirlpool.com&amp;gt; R. Schertler &amp;lt;roderick@argon.org&amp;gt; J. Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; G. Aas &amp;lt;gisle@aas.no&amp;gt;</source>
          <target state="translated">D. Wegscheid &amp;lt;wegscd@whirlpool.com&amp;gt; R. Schertler &amp;lt;roderick@argon.org&amp;gt; J. Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; G. Aas &amp;lt;gisle@aas.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a856f8342e4097ec46ec2ae4d0ef67ea993ed17d" translate="yes" xml:space="preserve">
          <source>D&lt;b&gt;1&lt;/b&gt;h</source>
          <target state="translated">D&lt;b&gt;1&lt;/b&gt;h</target>
        </trans-unit>
        <trans-unit id="cbcb89e55acdd88dfeeed3c5a12d75530af183e0" translate="yes" xml:space="preserve">
          <source>DATA STRUCTURES</source>
          <target state="translated">데이터 구조</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="c12b32a0cc17b3f8909c76d7b1bfe6c328500bd4" translate="yes" xml:space="preserve">
          <source>DB</source>
          <target state="translated">DB</target>
        </trans-unit>
        <trans-unit id="d3a3e481c8bad23af4b07c6a711d820269aa05e1" translate="yes" xml:space="preserve">
          <source>DB - programmatic interface to the Perl debugging API</source>
          <target state="translated">DB-Perl 디버깅 API에 대한 프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="f76a9cbb39dfd2541a72b35e7e8f4653016195c0" translate="yes" xml:space="preserve">
          <source>DBM Comparisons</source>
          <target state="translated">DBM 비교</target>
        </trans-unit>
        <trans-unit id="ca5f67a0ba0d8efff1637f1da816838257659ffd" translate="yes" xml:space="preserve">
          <source>DBM FILTERS</source>
          <target state="translated">DBM 필터</target>
        </trans-unit>
        <trans-unit id="89d82ce9435d1c0ea4a6bc6721d2f5690a7f92ea" translate="yes" xml:space="preserve">
          <source>DBM Filters are useful for a class of problems where you</source>
          <target state="translated">DBM 필터는 여러 가지 문제에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7578525c0394078f99ffd4a40edc277d75ad744f" translate="yes" xml:space="preserve">
          <source>DBM_Filter</source>
          <target state="translated">DBM_Filter</target>
        </trans-unit>
        <trans-unit id="b38c7d32f616c7556af3364ba66546ed0749f03b" translate="yes" xml:space="preserve">
          <source>DBM_Filter -- Filter DBM keys/values</source>
          <target state="translated">DBM_Filter-DBM 키 / 값 필터링</target>
        </trans-unit>
        <trans-unit id="b6b9b1dec59c3a08e8723935d64f316cd6ef56cc" translate="yes" xml:space="preserve">
          <source>DBM_Filter::compress</source>
          <target state="translated">DBM_Filter::compress</target>
        </trans-unit>
        <trans-unit id="017e1847be264d3b84ccfa3271d40094dd0bf1eb" translate="yes" xml:space="preserve">
          <source>DBM_Filter::compress - filter for DBM_Filter</source>
          <target state="translated">DBM_Filter :: compress-DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="e29bd395446d47ab211ec2e1146eefd14e1b20a3" translate="yes" xml:space="preserve">
          <source>DBM_Filter::encode</source>
          <target state="translated">DBM_Filter::encode</target>
        </trans-unit>
        <trans-unit id="f5e031e4b2f19789fcf7c2f3ba685f80663d177c" translate="yes" xml:space="preserve">
          <source>DBM_Filter::encode - filter for DBM_Filter</source>
          <target state="translated">DBM_Filter :: encode-DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="fcb2034b0ecd24b1bee4254c842bbb672bdbc7d6" translate="yes" xml:space="preserve">
          <source>DBM_Filter::int32</source>
          <target state="translated">DBM_Filter::int32</target>
        </trans-unit>
        <trans-unit id="5fe5fd365abd08f6af165c5d6a16911995a685a9" translate="yes" xml:space="preserve">
          <source>DBM_Filter::int32 - filter for DBM_Filter</source>
          <target state="translated">DBM_Filter :: int32-DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="4a3e906903359c539b73264aaf12312ed4cfcbb3" translate="yes" xml:space="preserve">
          <source>DBM_Filter::null</source>
          <target state="translated">DBM_Filter::null</target>
        </trans-unit>
        <trans-unit id="f2b61c34157f644580714175a9ac63fc9b039644" translate="yes" xml:space="preserve">
          <source>DBM_Filter::null - filter for DBM_Filter</source>
          <target state="translated">DBM_Filter :: null-DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="9bc092e44e5524b9cfa3d26c271d34f1880924e0" translate="yes" xml:space="preserve">
          <source>DBM_Filter::utf8</source>
          <target state="translated">DBM_Filter::utf8</target>
        </trans-unit>
        <trans-unit id="1bfbf4c2c625b28768968c9e40b648dd9c14d44d" translate="yes" xml:space="preserve">
          <source>DBM_Filter::utf8 - filter for DBM_Filter</source>
          <target state="translated">DBM_Filter :: utf8-DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="b02f6970eb3456617162054c6756321f766cb936" translate="yes" xml:space="preserve">
          <source>DB_BTREE</source>
          <target state="translated">DB_BTREE</target>
        </trans-unit>
        <trans-unit id="b33927ab202d8fc0904f1f9b9d856b0b54625b77" translate="yes" xml:space="preserve">
          <source>DB_File</source>
          <target state="translated">DB_File</target>
        </trans-unit>
        <trans-unit id="2c972e69463b8f58734f3a05c1368f9d2f81dba9" translate="yes" xml:space="preserve">
          <source>DB_File - Perl5 access to Berkeley DB version 1.x</source>
          <target state="translated">DB_File-Berkeley DB 버전 1.x에 대한 Perl5 액세스</target>
        </trans-unit>
        <trans-unit id="39dffad4b26fe77aef729449dbd757ed61bcfd3a" translate="yes" xml:space="preserve">
          <source>DB_File tests failing on Tru64</source>
          <target state="translated">Tru64에서 DB_File 테스트 실패</target>
        </trans-unit>
        <trans-unit id="70c0dec73cd04aa605d8521bd81cda83ad9852d0" translate="yes" xml:space="preserve">
          <source>DB_HASH</source>
          <target state="translated">DB_HASH</target>
        </trans-unit>
        <trans-unit id="a90a8db476a6644718df5c14fa00dae64a074e16" translate="yes" xml:space="preserve">
          <source>DB_RECNO</source>
          <target state="translated">DB_RECNO</target>
        </trans-unit>
        <trans-unit id="1214b29ce37cdd875514a6b9e684feaa105d5701" translate="yes" xml:space="preserve">
          <source>DB_RECNO allows both fixed-length and variable-length flat text files to be manipulated using the same key/value pair interface as in DB_HASH and DB_BTREE. In this case the key will consist of a record (line) number.</source>
          <target state="translated">DB_RECNO를 사용하면 고정 길이 및 가변 길이 플랫 텍스트 파일을 DB_HASH 및 DB_BTREE와 동일한 키 / 값 쌍 인터페이스를 사용하여 조작 할 수 있습니다. 이 경우 키는 레코드 (행) 번호로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="54300d66c5de040df830a07fcc62363319edc6b3" translate="yes" xml:space="preserve">
          <source>DB_RECNO provides an interface to flat text files. Both variable and fixed length records are supported.</source>
          <target state="translated">DB_RECNO는 일반 텍스트 파일에 대한 인터페이스를 제공합니다. 가변 길이 레코드와 고정 길이 레코드가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c84dd33284289aa30abfb4901524e660dc3f8fe1" translate="yes" xml:space="preserve">
          <source>DCL$PATH</source>
          <target state="translated">DCL$PATH</target>
        </trans-unit>
        <trans-unit id="0a9147164ebeee67def0458db65d380af3d847bd" translate="yes" xml:space="preserve">
          <source>DDD over gdb</source>
          <target state="translated">gdb를 통한 DDD</target>
        </trans-unit>
        <trans-unit id="bc02c571c975735551b89853409b435a7d2a911b" translate="yes" xml:space="preserve">
          <source>DEBUGGING</source>
          <target state="translated">DEBUGGING</target>
        </trans-unit>
        <trans-unit id="72e25783db89a734a8c44381188ac1bdfc0af08b" translate="yes" xml:space="preserve">
          <source>DEFINE_VERSION: -D line to set the module version when compiling</source>
          <target state="translated">DEFINE_VERSION : 컴파일 할 때 모듈 버전을 설정하는 -D 행</target>
        </trans-unit>
        <trans-unit id="fb047f1c6b1e76a02beec100d3b58403874139af" translate="yes" xml:space="preserve">
          <source>DEFINITIONS</source>
          <target state="translated">DEFINITIONS</target>
        </trans-unit>
        <trans-unit id="3cc8567954f6ca3e5e003d24429635955d1d02f9" translate="yes" xml:space="preserve">
          <source>DEFUNCT</source>
          <target state="translated">DEFUNCT</target>
        </trans-unit>
        <trans-unit id="83e39656dc7ac7175a510ee6558f6f575c96339a" translate="yes" xml:space="preserve">
          <source>DEPRECATED</source>
          <target state="translated">DEPRECATED</target>
        </trans-unit>
        <trans-unit id="e0dc4b2a8e17072634cdeee1910633cab2fa2010" translate="yes" xml:space="preserve">
          <source>DEPRECATED! It is planned to remove this function from a future release of Perl. Do not use it for new code; remove it from existing code.</source>
          <target state="translated">더 이상 사용되지 않습니다! 향후 Perl 릴리스에서이 기능을 제거 할 계획입니다. 새 코드에는 사용하지 마십시오. 기존 코드에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a157b2a5a436f4b25182b22c822a40b087fde127" translate="yes" xml:space="preserve">
          <source>DEPRECATED!!!</source>
          <target state="translated">DEPRECATED!!!</target>
        </trans-unit>
        <trans-unit id="0ceecbea9d37250860e1b3086c61f32787e7e837" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">DESCRIPTION</target>
        </trans-unit>
        <trans-unit id="e7e49a1a7cfc18f44f90aaf5e4c176c2211c9f16" translate="yes" xml:space="preserve">
          <source>DESIGNING AND WRITING YOUR MODULE</source>
          <target state="translated">모듈 설계 및 작성</target>
        </trans-unit>
        <trans-unit id="02f56a7bf01c1a870e819952336349625f50e2b7" translate="yes" xml:space="preserve">
          <source>DESTROY</source>
          <target state="translated">DESTROY</target>
        </trans-unit>
        <trans-unit id="1adeca5b77bafcb12821be20b10405718f410b83" translate="yes" xml:space="preserve">
          <source>DESTRUCT</source>
          <target state="translated">DESTRUCT</target>
        </trans-unit>
        <trans-unit id="9120423983b0359c503c676dadecd6bf8702131f" translate="yes" xml:space="preserve">
          <source>DETAILS</source>
          <target state="translated">DETAILS</target>
        </trans-unit>
        <trans-unit id="f459e7c8f3245e0293226ce8877ab5f73ac59297" translate="yes" xml:space="preserve">
          <source>DG/&lt;code&gt;UX&lt;/code&gt;</source>
          <target state="translated">DG/&lt;code&gt;UX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7563ce76d34297c6913b33a614a4437ccf7e6bb6" translate="yes" xml:space="preserve">
          <source>DIAGNOSTICS</source>
          <target state="translated">DIAGNOSTICS</target>
        </trans-unit>
        <trans-unit id="d61aaf2b8c8a0d55b1cee7b943d2035b67af0d4d" translate="yes" xml:space="preserve">
          <source>DISPLAYING</source>
          <target state="translated">DISPLAYING</target>
        </trans-unit>
        <trans-unit id="7f70d69b899f50f51b56a174e2446671d41836a8" translate="yes" xml:space="preserve">
          <source>DJGPP is a port of GNU C/C++ compiler and development tools to 32-bit, protected-mode environment on Intel 32-bit CPUs running MS-DOS and compatible operating systems, by DJ Delorie &amp;lt;dj@delorie.com&amp;gt; and friends.</source>
          <target state="translated">DJGPP는 DJ Delorie &amp;lt;dj@delorie.com&amp;gt; 및 친구들에 의해 MS-DOS 및 호환 운영 체제를 실행하는 Intel 32 비트 CPU에서 32 비트, 보호 모드 환경에 대한 GNU C / C ++ 컴파일러 및 개발 도구의 포트입니다.</target>
        </trans-unit>
        <trans-unit id="c7fcac2a520878c5b29e5384d7123ef0d8af803b" translate="yes" xml:space="preserve">
          <source>DLL forwarder generation</source>
          <target state="translated">DLL 전달자 생성</target>
        </trans-unit>
        <trans-unit id="961816e97938085c744d70524c7f8b51961bbf33" translate="yes" xml:space="preserve">
          <source>DLL is loaded when</source>
          <target state="translated">DLL이로드 될 때</target>
        </trans-unit>
        <trans-unit id="b8fba0e1a3b69795fd7aeeb5df67e417334bbc08" translate="yes" xml:space="preserve">
          <source>DLL name mangling: 5.6.2 and beyond</source>
          <target state="translated">DLL 이름 맹 글링 : 5.6.2 이상</target>
        </trans-unit>
        <trans-unit id="5103efb394e8f4c78963cefb65d442857e85fbb9" translate="yes" xml:space="preserve">
          <source>DLL name mangling: pre 5.6.2</source>
          <target state="translated">DLL 이름 맹 글링 : 5.6.2 이전</target>
        </trans-unit>
        <trans-unit id="4199b473b62a8d487f588ef5f17c8e1e79fdfedc" translate="yes" xml:space="preserve">
          <source>DLLs in the system to be available</source>
          <target state="translated">사용 가능한 시스템의 DLL</target>
        </trans-unit>
        <trans-unit id="978758ab9cc6f96cf7ec21b1d65444522ce20560" translate="yes" xml:space="preserve">
          <source>DLLs was done due to misunderstanding of the OS/2 dynaloading model. OS/2 (effectively) maintains two different tables of loaded DLL:</source>
          <target state="translated">OS / 2 dynaloading 모델에 대한 오해로 인해 DLL이 수행되었습니다. OS / 2는 (실제적으로)로드 된 DLL의 두 가지 다른 테이블을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="e72095491ba9a045230bfe18eae0af9d9f28e15a" translate="yes" xml:space="preserve">
          <source>DO NOT MIX MULTIPLE ENCODINGS</source>
          <target state="translated">여러 인코딩을 혼합하지 마십시오</target>
        </trans-unit>
        <trans-unit id="321641aef17a94c7440c8b75a28914642814b302" translate="yes" xml:space="preserve">
          <source>DO NOT PUT TOO MANY SUSPECTS! Don't you try something like this!</source>
          <target state="translated">너무 많은 의심을 가하지 마십시오! 이런 식으로 시도하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="96cc00d75846a718bd722cef8a33a50a6d0f5535" translate="yes" xml:space="preserve">
          <source>DOCUMENTATION</source>
          <target state="translated">DOCUMENTATION</target>
        </trans-unit>
        <trans-unit id="6ec3afab8faec77e185bbb803869543c5a657284" translate="yes" xml:space="preserve">
          <source>DOCUMENTING YOUR MODULE</source>
          <target state="translated">모듈 문서화</target>
        </trans-unit>
        <trans-unit id="2613d94608f3128686c4d00e8f6984910962bf29" translate="yes" xml:space="preserve">
          <source>DOS also treats several filenames as special, such as AUX, PRN, NUL, CON, COM1, LPT1, LPT2, etc. Unfortunately, sometimes these filenames won't even work if you include an explicit directory prefix. It is best to avoid such filenames, if you want your code to be portable to DOS and its derivatives. It's hard to know what these all are, unfortunately.</source>
          <target state="translated">DOS는 또한 AUX, PRN, NUL, CON, COM1, LPT1, LPT2 등과 같은 여러 파일 이름을 특수한 것으로 취급합니다. 불행히도 때로는 명시 적 디렉토리 접두사를 포함하면 이러한 파일 이름이 작동하지 않을 수도 있습니다. 코드를 DOS와 그 파생물로 이식 가능하게하려면 그러한 파일 이름을 사용하지 않는 것이 가장 좋습니다. 불행히도이 모든 것들이 무엇인지 아는 것은 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5340493a66303fc8d8a5c954e9bf8a43cd32f247" translate="yes" xml:space="preserve">
          <source>DOS and Derivatives</source>
          <target state="translated">DOS와 파생 상품</target>
        </trans-unit>
        <trans-unit id="9aa2dc24c805c53edba7676333ae68552dfd57a4" translate="yes" xml:space="preserve">
          <source>DOS like globbing and then some</source>
          <target state="translated">글 로빙과 같은 DOS</target>
        </trans-unit>
        <trans-unit id="7d8fd5f2c8edcce479637c27bb0e3ab518146c38" translate="yes" xml:space="preserve">
          <source>DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 DOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="473d3acc2af8ba63261a26a1b7f5515a6891c343" translate="yes" xml:space="preserve">
          <source>DOS, OS/2, VMS, VOS, and Windows can work similarly to Unix with &lt;code&gt;/&lt;/code&gt; as path separator, or in their own idiosyncratic ways (such as having several root directories and various &quot;unrooted&quot; device files such NIL: and LPT:).</source>
          <target state="translated">DOS, OS / 2, VMS, VOS 및 Windows는 경로 구분 기호 로 &lt;code&gt;/&lt;/code&gt; 를 사용하거나 고유 한 방식 (예 : 여러 루트 디렉토리 및 NIL : 및 LPT :와 같은 다양한 &quot;루팅되지 않은&quot;장치 파일을 갖는 등)으로 Unix와 유사하게 작동 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="654efd9c9792936a130d6037516309b5bdddee38" translate="yes" xml:space="preserve">
          <source>DPMI is required for RSX.</source>
          <target state="translated">RSX에는 DPMI가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2d2a24951ce705488575783be4472a26b333751c" translate="yes" xml:space="preserve">
          <source>DTrace is a framework for comprehensive system- and application-level tracing. Perl is a DTrace</source>
          <target state="translated">DTrace는 포괄적 인 시스템 및 응용 프로그램 수준 추적을위한 프레임 워크입니다. 펄은 DTrace입니다</target>
        </trans-unit>
        <trans-unit id="d5bf3f40de5d663351b116d65dea7bcc046dcb12" translate="yes" xml:space="preserve">
          <source>DWIM is an acronym for &amp;ldquo;Do What I Mean&amp;rdquo;, the principle that something should just do what you want it to do without an undue amount of fuss. A bit of code that does &amp;ldquo;dwimming&amp;rdquo; is a &amp;ldquo;dwimmer&amp;rdquo;. Dwimming can require a great deal of behind-the-scenes magic, which (if it doesn&amp;rsquo;t stay properly behind the scenes) is called a &lt;b&gt;dweomer&lt;/b&gt; instead.</source>
          <target state="translated">DWIM은&amp;ldquo;무엇을해야합니까?&amp;rdquo;의 약어로, 과도한 소란없이 무언가를 원하는대로해야한다는 원칙입니다. &amp;ldquo;떨림&amp;rdquo;을하는 약간의 코드는&amp;ldquo;돌 박이&amp;rdquo;입니다. Dwimming은 많은 비하인드 스토리 매직을 필요로 할 수 있습니다. (장면 뒤에 제대로 머물러 있지 않으면) 대신 &lt;b&gt;dweomer&lt;/b&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="85028126eeeaacb6fe3db27b148fabc61b38f172" translate="yes" xml:space="preserve">
          <source>Damian Conway</source>
          <target state="translated">데미안 콘웨이</target>
        </trans-unit>
        <trans-unit id="84aeaa4ed1041b265c8434cc722f5bbd7d82bf67" translate="yes" xml:space="preserve">
          <source>Damian Conway (damian@conway.org)</source>
          <target state="translated">Damian Conway (damian@conway.org)</target>
        </trans-unit>
        <trans-unit id="56a7a2a736c65870e75794d64c28905d7b7353ac" translate="yes" xml:space="preserve">
          <source>Damian Conway (damian@conway.org). The maintainer of this module is now Rafael Garcia-Suarez (rgarciasuarez@gmail.com).</source>
          <target state="translated">Damian Conway (damian@conway.org). 이 모듈의 관리자는 이제 Rafael Garcia-Suarez (rgarciasuarez@gmail.com)입니다.</target>
        </trans-unit>
        <trans-unit id="d1f605e1f77b8db2ab180142323e96f99783331d" translate="yes" xml:space="preserve">
          <source>Damian Conway's &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; handles all of the thinking for you.</source>
          <target state="translated">Damian Conway의 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt; 은 모든 생각을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2db3f6d7414ff15624d9a6080d6aa063705cba8a" translate="yes" xml:space="preserve">
          <source>Dan Sugalski &amp;lt;dan@sidhe.org&amp;lt;gt&amp;gt;</source>
          <target state="translated">댄 수갈 스키 &amp;lt;dan@sidhe.org &amp;lt;gt&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f5fbfc9cec6cd72e230b1bbe73cbb08d9ccf37da" translate="yes" xml:space="preserve">
          <source>Daniel S. Lewart &amp;lt;</source>
          <target state="translated">다니엘 에스 레 워트 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7fd1dfde23d6a5c5d15d0aee8437a3fd73417fd6" translate="yes" xml:space="preserve">
          <source>Daniel S. Sterling has written a script that uses &lt;code&gt;IO::Uncompress::UnZip&lt;/code&gt; to read a zip file and unzip its contents to disk.</source>
          <target state="translated">Daniel S. Sterling은 &lt;code&gt;IO::Uncompress::UnZip&lt;/code&gt; 을 사용하여 zip 파일을 읽고 내용을 디스크에 압축 해제 하는 스크립트를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed6fbf94844a47ecf83411b63cf050c8d28ac5b" translate="yes" xml:space="preserve">
          <source>Data Structures</source>
          <target state="translated">데이터 구조</target>
        </trans-unit>
        <trans-unit id="5cf272d33425f40ddbde3e44d761e3fc7c061ec7" translate="yes" xml:space="preserve">
          <source>Data Types and Data Type Utilities</source>
          <target state="translated">데이터 유형 및 데이터 유형 유틸리티</target>
        </trans-unit>
        <trans-unit id="6a99f8e09e7fe8334e0578359f60485516d4d7ce" translate="yes" xml:space="preserve">
          <source>Data after the &lt;code&gt;__DATA__&lt;/code&gt; token in a module is read using the FOOBAR::DATA filehandle. &lt;code&gt;__END__&lt;/code&gt; can still be used to denote the end of the &lt;code&gt;__DATA__&lt;/code&gt; section if followed by the token DATA - this is supported by the &lt;b&gt;SelfLoader&lt;/b&gt;. The &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is left open if an &lt;code&gt;__END__&lt;/code&gt; followed by a DATA is found, with the filehandle positioned at the start of the line after the &lt;code&gt;__END__&lt;/code&gt; token. If no &lt;code&gt;__END__&lt;/code&gt; token is present, or an &lt;code&gt;__END__&lt;/code&gt; token with no DATA token on the same line, then the filehandle is closed.</source>
          <target state="translated">모듈에서 &lt;code&gt;__DATA__&lt;/code&gt; 토큰 뒤의 데이터 는 FOOBAR :: DATA 파일 핸들을 사용하여 읽습니다. &lt;code&gt;__END__&lt;/code&gt; 는 토큰 DATA가 뒤에 오는 경우 &lt;code&gt;__DATA__&lt;/code&gt; 섹션 의 끝을 나타내는 데 계속 사용할 수 있습니다 . 이는 &lt;b&gt;SelfLoader에서&lt;/b&gt; 지원됩니다 . &lt;code&gt;FOOBAR::DATA&lt;/code&gt; 는 IF 핸들은 개방되어 &lt;code&gt;__END__&lt;/code&gt; 는 애프터 라인의 시작 부분에 위치하는 핸들과, 발견 된 DATA 하였다 &lt;code&gt;__END__&lt;/code&gt; 의 토큰. 어떠한 경우 &lt;code&gt;__END__&lt;/code&gt; 의 토큰이 존재하지 않는, 또는 &lt;code&gt;__END__&lt;/code&gt; 동일 라인 데이터 토큰으로 토큰을 그 핸들이 폐쇄된다.</target>
        </trans-unit>
        <trans-unit id="b652ad0a603cd7b47d334614ee31233474c9ab8d" translate="yes" xml:space="preserve">
          <source>Data flows through filters in the same order they appear in the source file. The uudecode filter appeared before the uncompress filter, so the source file will be uudecoded before it's uncompressed.</source>
          <target state="translated">데이터는 소스 파일에 나타나는 순서대로 필터를 통과합니다. uudecode 필터는 압축 해제 필터 앞에 나타 났으므로 소스 파일은 압축 해제되기 전에 uudecode됩니다.</target>
        </trans-unit>
        <trans-unit id="0f54a276a0206593cde1683f28ef51b63c547eda" translate="yes" xml:space="preserve">
          <source>Data mode (the default if you redirect or pipe output). This prints out your configuration data, without mailing anything. You can use this with &lt;b&gt;-v&lt;/b&gt; to get more complete data.</source>
          <target state="translated">데이터 모드 (출력을 리디렉션하거나 파이프하는 경우 기본값) 메일을 보내지 않고 구성 데이터를 인쇄합니다. 이를 &lt;b&gt;-v&lt;/b&gt; 와 함께 사용 하면보다 완전한 데이터를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6afd37625bc0367f512a035f9204374b0b5ded2" translate="yes" xml:space="preserve">
          <source>Data paragraphs are typically used for inlining non-Pod data that is to be used (typically passed through) when rendering the document to a specific format:</source>
          <target state="translated">데이터 단락은 일반적으로 문서를 특정 형식으로 렌더링 할 때 사용되는 (일반적으로 전달되는) 포드 이외의 데이터를 인라인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94e20e5cd2604e57e9a0d23f02d2cd5d929f4af9" translate="yes" xml:space="preserve">
          <source>Data written to this layer should be UTF-8 encoded; data provided by this layer should be considered UTF-8 encoded. Can be set on any layer by &quot;:utf8&quot; dummy layer. Also set on &quot;:encoding&quot; layer.</source>
          <target state="translated">이 계층에 기록 된 데이터는 UTF-8로 인코딩되어야합니다. 이 계층에서 제공하는 데이터는 UTF-8로 인코딩 된 것으로 간주해야합니다. &quot;: utf8&quot;더미 레이어로 모든 레이어에서 설정할 수 있습니다. &quot;: encoding&quot;레이어에서도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="97f1bb92da1e5e7c46dc020b7ec63efc045c0a68" translate="yes" xml:space="preserve">
          <source>Data: Arrays</source>
          <target state="translated">데이터 : 배열</target>
        </trans-unit>
        <trans-unit id="de5afcac5fbd23280f46d7161af449533e2cceda" translate="yes" xml:space="preserve">
          <source>Data: Dates</source>
          <target state="translated">데이터 : 날짜</target>
        </trans-unit>
        <trans-unit id="c411e3f24a5ba1334882780f16f3e9dbf1c659d9" translate="yes" xml:space="preserve">
          <source>Data: Hashes (Associative Arrays)</source>
          <target state="translated">데이터 : 해시 (연관 배열)</target>
        </trans-unit>
        <trans-unit id="fa7113830ed5a59d6505a9385c9ea0bd8127836a" translate="yes" xml:space="preserve">
          <source>Data: Misc</source>
          <target state="translated">데이터 : 기타</target>
        </trans-unit>
        <trans-unit id="3e48ca0ae51772567ede6f2a3afe45cb0267ef60" translate="yes" xml:space="preserve">
          <source>Data: Numbers</source>
          <target state="translated">데이터 : 숫자</target>
        </trans-unit>
        <trans-unit id="58c8a967dc7612bd6e8f1483414d85eb62228a36" translate="yes" xml:space="preserve">
          <source>Data: Strings</source>
          <target state="translated">데이터 : 문자열</target>
        </trans-unit>
        <trans-unit id="7d6e21c84e9451a0cec29192edeff8e21b85f25a" translate="yes" xml:space="preserve">
          <source>Data::Dumper</source>
          <target state="translated">Data::Dumper</target>
        </trans-unit>
        <trans-unit id="8c7c47d5705e647c7c4327d92117a5533391f0d0" translate="yes" xml:space="preserve">
          <source>Data::Dumper - stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Data :: Dumper-인쇄 및 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 모두 적합한 문자열 화 된 펄 데이터 구조</target>
        </trans-unit>
        <trans-unit id="ff7ea8e9cb1cf0ef3310359653bd8d014b4e17b6" translate="yes" xml:space="preserve">
          <source>Data::Dumper doesn't restore the UTF8 flag; is it broken?</source>
          <target state="translated">Data :: Dumper는 UTF8 플래그를 복원하지 않습니다. 고장났어?</target>
        </trans-unit>
        <trans-unit id="ab7ab098392e93c21506df2dbe7e96ac2b061b9d" translate="yes" xml:space="preserve">
          <source>Data::Dumper will catalog all references encountered while dumping the values. Cross-references (in the form of names of substructures in perl syntax) will be inserted at all possible points, preserving any structural interdependencies in the original set of values. Structure traversal is depth-first, and proceeds in order from the first supplied value to the last.</source>
          <target state="translated">Data :: Dumper는 값을 덤프하는 동안 발생한 모든 참조를 카탈로그합니다. 상호 참조 (perl 구문의 하위 구조 이름 형식)는 가능한 모든 지점에 삽입되어 원래 값 세트의 구조적 상호 종속성을 유지합니다. 구조 순회는 깊이 우선이며 처음 제공된 값에서 마지막 순으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="5db04e397940af8e76d0eac5bf08574521dd22ae" translate="yes" xml:space="preserve">
          <source>Database Interfaces</source>
          <target state="translated">데이터베이스 인터페이스</target>
        </trans-unit>
        <trans-unit id="a109465d898ba0dfa0c491af35be82208576d8f0" translate="yes" xml:space="preserve">
          <source>Database Ties</source>
          <target state="translated">데이터베이스 타이</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="08bd72896a609a3391d219b4992ef11ec132d222" translate="yes" xml:space="preserve">
          <source>Date Calculations</source>
          <target state="translated">날짜 계산</target>
        </trans-unit>
        <trans-unit id="b79e7a3976aeb6614f1bdda5b3b2eeb809fac6f4" translate="yes" xml:space="preserve">
          <source>Date Comparisons</source>
          <target state="translated">날짜 비교</target>
        </trans-unit>
        <trans-unit id="6cd8d0e8ff629adf381174818e2158887210c59a" translate="yes" xml:space="preserve">
          <source>Date Parsing</source>
          <target state="translated">날짜 파싱</target>
        </trans-unit>
        <trans-unit id="27c49fc3479babc6dc4d9bc2dbc4c3a52288b570" translate="yes" xml:space="preserve">
          <source>Date comparisons are also possible, using the full suite of &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt;=&quot;, &quot;&amp;lt;=&amp;gt;&quot;, &quot;==&quot; and &quot;!=&quot;.</source>
          <target state="translated">&quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt; =&quot;, &quot;&amp;lt;=&amp;gt;&quot;, &quot;==&quot;및 &quot;! =&quot;의 전체 제품군을 사용하여 날짜 비교도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0474fa39a613bd7eeec7bea46ccb23c0ca12e724" translate="yes" xml:space="preserve">
          <source>David Fiander and Peter Prymmer with thanks to Dennis Longnecker and William Raffloer for valuable reports, LPAR and PTF feedback. Thanks to Mike MacIsaac and Egon Terwedow for SG24-5944-00. Thanks to Ignasi Roca for pointing out the floating point problems. Thanks to John Goodyear for dynamic loading help.</source>
          <target state="translated">귀중한 보고서, LPAR 및 PTF 피드백에 대해 Dennis Longnecker와 William Raffloer에게 감사하는 David Fiander와 Peter Prymmer. SG24-5944-00을위한 Mike MacIsaac과 Egon Terwedow에게 감사합니다. 부동 소수점 문제를 지적 해 준 Ignasi Roca에게 감사합니다. 동적 로딩 도움말에 대해 John Goodyear에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="2723c98cfbb72ae38f478d52e32129d9547f0fba" translate="yes" xml:space="preserve">
          <source>David Golden</source>
          <target state="translated">데이비드 골든</target>
        </trans-unit>
        <trans-unit id="cd5088267e514d749afe6cca6fd8c81585cd5cf6" translate="yes" xml:space="preserve">
          <source>David Golden &amp;lt;dagolden@cpan.org&amp;gt;</source>
          <target state="translated">데이비드 골든 &amp;lt;dagolden@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d950594e5e25062fc0607cb94f5625028946e5a7" translate="yes" xml:space="preserve">
          <source>David Golden, &amp;lt;dagolden@cpan.org&amp;gt;</source>
          <target state="translated">데이비드 골든, &amp;lt;dagolden@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8d95407bff3307b97ca4e8eedc2eced84a4438ae" translate="yes" xml:space="preserve">
          <source>David Muir Sharnoff &amp;lt;cpan@dave.sharnoff.org&amp;gt; with help from Tim Pierce and many many others.</source>
          <target state="translated">팀 피어스와 다른 많은 사람들의 도움을받은 David Muir Sharnoff &amp;lt;cpan@dave.sharnoff.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="e8377f90fb8277814679b9bc2dc6627a930eb98a" translate="yes" xml:space="preserve">
          <source>David P.C. Wollmann, Richard Soderberg, Sean M. Burke, Tom Christiansen, Jim Cromie, and Jeffrey Goff for useful advice.</source>
          <target state="translated">David PC Wollmann, Richard Soderberg, Sean M. Burke, Tom Christiansen, Jim Cromie 및 Jeffrey Goff가 유용한 조언을 구했습니다.</target>
        </trans-unit>
        <trans-unit id="c7b3466055eaf20f2cad818f5843a292b4ca2d80" translate="yes" xml:space="preserve">
          <source>David Steinbrunner</source>
          <target state="translated">데이비드 스타 인 브루너</target>
        </trans-unit>
        <trans-unit id="229d59d93e7e712ab429ce8580c0bd67e38e34f6" translate="yes" xml:space="preserve">
          <source>David Sundstrom &amp;lt;</source>
          <target state="translated">데이비드 선 스트롬 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f0503142592629f2769705a0fac2de70daef3980" translate="yes" xml:space="preserve">
          <source>Dealing with Endian-ness</source>
          <target state="translated">엔디안을 다루기</target>
        </trans-unit>
        <trans-unit id="c3570d3bcf3e90fdaa0791aacca802822c577102" translate="yes" xml:space="preserve">
          <source>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</source>
          <target state="translated">모든 경기장에서 사용되는 메모리를 할당 해제하십시오. 경기장 내 모든 개별 SV 헤드와 바디는 이미 해제되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b05ceded49f425c214f9e2db173be8c8e1a3a8d6" translate="yes" xml:space="preserve">
          <source>Deallocates a backtrace received from get_c_bracktrace.</source>
          <target state="translated">get_c_bracktrace에서 수신 한 역 추적을 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="da8e6981129a80511c8976bfcddbe201d3626924" translate="yes" xml:space="preserve">
          <source>Dean Arnold &amp;lt;darnold AT presicient DOT com&amp;gt; - Stack size API</source>
          <target state="translated">Dean Arnold &amp;lt;darnold AT presicient DOT com&amp;gt;-스택 크기 API</target>
        </trans-unit>
        <trans-unit id="36ea2a10971530d1f3b41de8bb6af5b551a6ff3c" translate="yes" xml:space="preserve">
          <source>Debian GNU/kFreeBSD systems also used LinuxThreads up until and including the 6.0 release, but after that moved to FreeBSD thread semantics, which are POSIX-like.</source>
          <target state="translated">데비안 GNU / kFreeBSD 시스템은 6.0 릴리스까지 LinuxThreads를 사용했지만 그 이후 POSIX와 같은 FreeBSD 스레드 의미론으로 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="d7013dc1690e39306f211d819fa32173c56252c9" translate="yes" xml:space="preserve">
          <source>Debug Output</source>
          <target state="translated">디버그 출력</target>
        </trans-unit>
        <trans-unit id="b05fb520e7c0513f4478767235e0d3c4b22c35e6" translate="yes" xml:space="preserve">
          <source>Debug a given program using threads (experimental).</source>
          <target state="translated">스레드를 사용하여 지정된 프로그램을 디버깅하십시오 (실험적).</target>
        </trans-unit>
        <trans-unit id="5f7d3acbef3ce732ed02816b2d1048d41d127c3b" translate="yes" xml:space="preserve">
          <source>Debug a given program via the &lt;code&gt;Devel::ptkdb&lt;/code&gt; GUI.</source>
          <target state="translated">&lt;code&gt;Devel::ptkdb&lt;/code&gt; GUI 를 통해 주어진 프로그램을 디버그하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd4cb2194799882c3c66213892a49639bae1936c" translate="yes" xml:space="preserve">
          <source>Debug subroutine enter/exit.</source>
          <target state="translated">서브 루틴 입 / 출력 디버그.</target>
        </trans-unit>
        <trans-unit id="4333709c02ad553298735787840db205447e4bf6" translate="yes" xml:space="preserve">
          <source>Debugger Commands</source>
          <target state="translated">디버거 명령</target>
        </trans-unit>
        <trans-unit id="9914c0d0aed65ea8f1d64b044cdff2c3fddecc0d" translate="yes" xml:space="preserve">
          <source>Debugger Customization</source>
          <target state="translated">디버거 사용자 정의</target>
        </trans-unit>
        <trans-unit id="99ecabc4479d51c9a08930be819ce0858218cf75" translate="yes" xml:space="preserve">
          <source>Debugger Customization Functions</source>
          <target state="translated">디버거 사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="666cf254f85ea5d057a4582c5d8d5fdd8a5b7e41" translate="yes" xml:space="preserve">
          <source>Debugger Input/Output</source>
          <target state="translated">디버거 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="9751ba81f798bbd7760a0c6d24e8d83eb20c30ba" translate="yes" xml:space="preserve">
          <source>Debugger Internal Variables</source>
          <target state="translated">디버거 내부 변수</target>
        </trans-unit>
        <trans-unit id="d026646d6b3410bc5de0b3ffc654c93e730dbd4e" translate="yes" xml:space="preserve">
          <source>Debugger Internals</source>
          <target state="translated">디버거 내부</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="b77aa217c50f6fe5bfd3f17727cebc255c68a2ca" translate="yes" xml:space="preserve">
          <source>Debugging Compile-Time Statements</source>
          <target state="translated">컴파일 타임 문 디버깅</target>
        </trans-unit>
        <trans-unit id="56a3daa806e9216f2f247d92a9789167d765ab05" translate="yes" xml:space="preserve">
          <source>Debugging Memory Usage</source>
          <target state="translated">메모리 사용량 디버깅</target>
        </trans-unit>
        <trans-unit id="7f9818adf8fc8493412c933de791d9f5c9b959e2" translate="yes" xml:space="preserve">
          <source>Debugging Perl Memory Usage</source>
          <target state="translated">펄 메모리 사용 디버깅</target>
        </trans-unit>
        <trans-unit id="9e08887136b7961fe7c673b82471c4d25acee0d8" translate="yes" xml:space="preserve">
          <source>Debugging Regular Expressions</source>
          <target state="translated">정규식 디버깅</target>
        </trans-unit>
        <trans-unit id="a55f46b26d2e609b7ed7dd3dcdfe13f913890ab9" translate="yes" xml:space="preserve">
          <source>Debugging Regular Expressions in perldebug</source>
          <target state="translated">perldebug에서 정규식 디버깅</target>
        </trans-unit>
        <trans-unit id="b148c2d0cd84634d55a9ffc8e11de74f37399218" translate="yes" xml:space="preserve">
          <source>Debugging Utilities</source>
          <target state="translated">디버깅 유틸리티</target>
        </trans-unit>
        <trans-unit id="8057c32aee1676af868f8f55325f1ae849dbb6de" translate="yes" xml:space="preserve">
          <source>Debugging this module is more than a bit complex due to interference from the software producing the indices on CPAN, the mirroring process on CPAN, packaging, configuration, synchronicity, and even (gasp!) due to bugs within the CPAN.pm module itself.</source>
          <target state="translated">이 모듈을 디버깅하는 것은 CPAN에서 인덱스를 생성하는 소프트웨어, CPAN에서 미러링 프로세스, 패키징, 구성, 동기화 및 CPAN.pm 모듈 자체의 버그로 인한 심지어 짝수 (!)로 인한 간섭으로 인해 약간 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="8c401279896f59c9ac4daaaace09acb4863e72b5" translate="yes" xml:space="preserve">
          <source>December, 2001; by Nicholas Clark: make timestr() recognise the style 'none' and return an empty string. If cmpthese is calling timethese, make it pass the style in. (so that 'none' will suppress output). Make sub new dump its debugging output to STDERR, to be consistent with everything else. All bugs found while writing a regression test.</source>
          <target state="translated">2001 년 12 월; 작성자 : Nicholas Clark : timestr ()이 '없음'스타일을 인식하고 빈 문자열을 반환합니다. cmpthese가 timethese를 호출하는 경우 스타일을 전달하십시오. 'none'은 출력을 억제합니다. sub new를 디버깅 결과를 STDERR에 덤프하여 다른 모든 것과 일치시킵니다. 회귀 테스트를 작성하는 동안 발견 된 모든 버그</target>
        </trans-unit>
        <trans-unit id="a39a923b41cc5f61bf60cc9e5e68a22cae934912" translate="yes" xml:space="preserve">
          <source>Decide what system you'll use for lexicon keys. If you insist, you can use opaque IDs (if you're nostalgic for &lt;code&gt;catgets&lt;/code&gt; ), but I have better suggestions in the section &quot;Entries in Each Lexicon&quot;, above. Assuming you opt for meaningful keys that double as values (like &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;), you'll have to settle on what language those should be in. For the sake of argument, I'll call this English, specifically American English, &quot;en-US&quot;.</source>
          <target state="translated">사전 키에 사용할 시스템을 결정하십시오. 주장한다면 불투명 한 ID를 사용할 수 있지만 ( &lt;code&gt;catgets&lt;/code&gt; 에 대해 향수가있는 경우 ) 위의 &quot;각 어휘집에있는 항목&quot;섹션에 더 나은 제안이 있습니다. &quot;최소 ([_1])가 최대 ([_2])! \ n&quot;와 같이 값으로 두 배가되는 의미있는 키를 선택한다고 가정하면 어떤 언어를 사용해야하는지 결정해야합니다. 논쟁을 위해서, 나는이 영어, 특히 미국 영어를 &quot;en-US&quot;라고 부를 것이다.</target>
        </trans-unit>
        <trans-unit id="d6f37721bc043c8dd7475e584d1b0bdd4b256c24" translate="yes" xml:space="preserve">
          <source>Declaration</source>
          <target state="translated">Declaration</target>
        </trans-unit>
        <trans-unit id="c2604e0c48edbf848a6d96ba3a8037bd0dc24ff4" translate="yes" xml:space="preserve">
          <source>Declaration and Access of Arrays of Arrays</source>
          <target state="translated">배열 배열의 선언 및 액세스</target>
        </trans-unit>
        <trans-unit id="ebfaff41dd116e96392e7550a2b66d9d22027082" translate="yes" xml:space="preserve">
          <source>Declaration of MORE ELABORATE RECORDS</source>
          <target state="translated">더 많은 우아한 기록의 선언</target>
        </trans-unit>
        <trans-unit id="5ec1670ea8c424f5ee15a9e695d0c44630da018c" translate="yes" xml:space="preserve">
          <source>Declaration of a HASH OF ARRAYS</source>
          <target state="translated">배열 해시 선언</target>
        </trans-unit>
        <trans-unit id="b8c8706e060a6811d69b8d2fd72320a3142d6844" translate="yes" xml:space="preserve">
          <source>Declaration of a HASH OF COMPLEX RECORDS</source>
          <target state="translated">복잡한 기록의 해시 선언</target>
        </trans-unit>
        <trans-unit id="4ce4e4163cd30ea8c4a041080be1e50e00906890" translate="yes" xml:space="preserve">
          <source>Declaration of a HASH OF HASHES</source>
          <target state="translated">해시 선언</target>
        </trans-unit>
        <trans-unit id="968cb53513edaef6840cbb9bd46e4ba68cbf91c3" translate="yes" xml:space="preserve">
          <source>Declaration of an ARRAY OF ARRAYS</source>
          <target state="translated">배열의 배열의 선언</target>
        </trans-unit>
        <trans-unit id="43a23bde1fe732a75628839289c49e738219d5a3" translate="yes" xml:space="preserve">
          <source>Declaration of an ARRAY OF HASHES</source>
          <target state="translated">해시 배열 선언</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="01b95bbd7c9d60ecf5c5308055fe69e1d280f03c" translate="yes" xml:space="preserve">
          <source>Declare &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; as a build-time dependency in &lt;code&gt;Makefile.PL&lt;/code&gt; (use &lt;code&gt;BUILD_REQUIRES&lt;/code&gt; ), or in your &lt;code&gt;Build.PL&lt;/code&gt; (use &lt;code&gt;build_requires&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; 을 &lt;code&gt;Makefile.PL&lt;/code&gt; ( &lt;code&gt;BUILD_REQUIRES&lt;/code&gt; 사용 ) 또는 &lt;code&gt;Build.PL&lt;/code&gt; ( &lt;code&gt;build_requires&lt;/code&gt; 사용 ) 에서 빌드 시간 종속성으로 선언 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b76a6d1632adb267d07f45f92fbd92ddebb3c0e" translate="yes" xml:space="preserve">
          <source>Declare Just &lt;code&gt;SP&lt;/code&gt; . This is actually identical to &lt;code&gt;dSP&lt;/code&gt; , and declares a local copy of perl's stack pointer, available via the &lt;code&gt;SP&lt;/code&gt; macro. See &lt;code&gt;SP&lt;/code&gt; . (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; 를 선언하십시오 . 이것은 실제로 &lt;code&gt;dSP&lt;/code&gt; 와 동일 하며 &lt;code&gt;SP&lt;/code&gt; 매크로 를 통해 사용 가능한 perl 스택 포인터의 로컬 사본을 선언합니다 . &lt;code&gt;SP&lt;/code&gt; 를 참조하십시오 . (이전 (Perl 5.005) 스레드 모델과의 하위 소스 코드 호환성에 사용 가능)</target>
        </trans-unit>
        <trans-unit id="b246d2c3a34b0309dc705ab2bf6fd78585237723" translate="yes" xml:space="preserve">
          <source>Declare a picture format for use by the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 기능 에서 사용할 그림 형식을 선언하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1337e532e08b8945e760914191518070a82f311f" translate="yes" xml:space="preserve">
          <source>Declare a picture format for use by the &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 기능 에서 사용할 그림 형식을 선언하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79b9fcb83aaabac99dc56e38a306c39d5ceed2f1" translate="yes" xml:space="preserve">
          <source>Declare a stack marker variable, &lt;code&gt;mark&lt;/code&gt; , for the XSUB. See &lt;code&gt;MARK&lt;/code&gt; and &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB에 대해 스택 마커 변수 인 &lt;code&gt;mark&lt;/code&gt; 를 선언하십시오 . &lt;code&gt;MARK&lt;/code&gt; 및 &lt;code&gt;dORIGMARK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bc325f65b062b55c0a046c697861918ab5ba8a6" translate="yes" xml:space="preserve">
          <source>Declare a typedef named &lt;code&gt;my_cxt_t&lt;/code&gt; that is a structure that contains all the data that needs to be interpreter-local.</source>
          <target state="translated">인터프리터 로컬이어야하는 모든 데이터를 포함하는 구조 인 &lt;code&gt;my_cxt_t&lt;/code&gt; 라는 typedef를 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f3343311ea82b57cf2a91faf914e7146706bc4b" translate="yes" xml:space="preserve">
          <source>Declare constants</source>
          <target state="translated">상수 선언</target>
        </trans-unit>
        <trans-unit id="e90d1629cda5e7b6f31494a6b20b0b96a93f8fec" translate="yes" xml:space="preserve">
          <source>Declare local variables for a multicall. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">다중 호출에 대한 지역 변수를 선언하십시오. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe8095595a1e11e48a82985239de9e9b7e44058b" translate="yes" xml:space="preserve">
          <source>Declare struct-like datatypes as Perl classes</source>
          <target state="translated">구조체와 유사한 데이터 유형을 Perl 클래스로 선언</target>
        </trans-unit>
        <trans-unit id="fd95c3fe676cb80336a8b7970197ea750ed934e1" translate="yes" xml:space="preserve">
          <source>Declares a block of tests you expect to fail and $why. Perhaps it's because you haven't fixed a bug or haven't finished a new feature:</source>
          <target state="translated">실패 할 것으로 예상되는 테스트 블록과 $ why를 선언합니다. 버그를 수정하지 않았거나 새로운 기능을 완료하지 않았기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b08be3bcb055a5bfcdfe0f7e147c5f7a01a9af4" translate="yes" xml:space="preserve">
          <source>Declares a local copy of perl's stack pointer for the XSUB, available via the &lt;code&gt;SP&lt;/code&gt; macro. See &lt;code&gt;SP&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; 매크로 를 통해 사용 가능한 XSUB에 대한 perl의 스택 포인터의 로컬 사본을 선언합니다 . &lt;code&gt;SP&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="775811626d86d0489442dc9b97620d79f2638c9b" translate="yes" xml:space="preserve">
          <source>Declares that no more items will be added to the queue.</source>
          <target state="translated">더 이상 항목이 대기열에 추가되지 않도록 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a88496a0e111c684a669138708549e2de67d1e28" translate="yes" xml:space="preserve">
          <source>Declares that the stream accepts perl's</source>
          <target state="translated">스트림이 펄을 수락 함을 선언</target>
        </trans-unit>
        <trans-unit id="97a2147f033bc70f2e20dfc8e311b01cc7c8c8f3" translate="yes" xml:space="preserve">
          <source>Declares that this test will run an indeterminate number of tests.</source>
          <target state="translated">이 테스트는 불확실한 수의 테스트를 실행할 것이라고 선언합니다.</target>
        </trans-unit>
        <trans-unit id="6da56154a8de563d222245d4af173f8b457c59e3" translate="yes" xml:space="preserve">
          <source>Declares that you are done testing, no more tests will be run after this point.</source>
          <target state="translated">테스트가 완료되었다고 선언하면이 시점 이후에는 더 이상 테스트가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd4907e397ad786d964786ed678ccb6ec918a061" translate="yes" xml:space="preserve">
          <source>Declares the BLOCK or the rest of the compilation unit as being in the given namespace. The scope of the package declaration is either the supplied code BLOCK or, in the absence of a BLOCK, from the declaration itself through the end of current scope (the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;). That is, the forms without a BLOCK are operative through the end of the current scope, just like the &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; operators. All unqualified dynamic identifiers in this scope will be in the given namespace, except where overridden by another &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declaration or when they're one of the special identifiers that qualify into &lt;code&gt;main::&lt;/code&gt; , like &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; , &lt;code&gt;ENV&lt;/code&gt; , and the punctuation variables.</source>
          <target state="translated">지정된 네임 스페이스에있는 것으로 BLOCK 또는 나머지 컴파일 단위를 선언합니다. 패키지 선언의 범위는 제공된 코드 BLOCK이거나 BLOCK이없는 경우 선언 자체에서 현재 범위의 끝 (포괄 블록, 파일 또는 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; )까지입니다. 즉, 블록이없는 형태의 단지처럼 현재 범위의 끝 부분을 통해 수술입니다 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 운영자. 다른 &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 선언으로 대체 되거나 &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; 와 같이 &lt;code&gt;main::&lt;/code&gt; 한정되는 특수 식별자 중 하나 인 경우를 제외하고이 범위의 모든 규정되지 않은 동적 식별자는 지정된 네임 스페이스에 있습니다., &lt;code&gt;ENV&lt;/code&gt; 및 구두점 변수</target>
        </trans-unit>
        <trans-unit id="f8c0173916c6e4ea3e07071d4b7dde09c327c03c" translate="yes" xml:space="preserve">
          <source>Declares the BLOCK or the rest of the compilation unit as being in the given namespace. The scope of the package declaration is either the supplied code BLOCK or, in the absence of a BLOCK, from the declaration itself through the end of current scope (the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;). That is, the forms without a BLOCK are operative through the end of the current scope, just like the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; operators. All unqualified dynamic identifiers in this scope will be in the given namespace, except where overridden by another &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declaration or when they're one of the special identifiers that qualify into &lt;code&gt;main::&lt;/code&gt; , like &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; , &lt;code&gt;ENV&lt;/code&gt; , and the punctuation variables.</source>
          <target state="translated">지정된 네임 스페이스에있는 것으로 BLOCK 또는 나머지 컴파일 단위를 선언합니다. 패키지 선언의 범위는 제공된 코드 BLOCK이거나 BLOCK이없는 경우 선언 자체에서 현재 범위의 끝 (포괄 블록, 파일 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; )까지입니다. 즉, 블록이없는 형태의 단지처럼 현재 범위의 끝 부분을 통해 수술입니다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 운영자. 다른 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 선언으로 대체 되거나 &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; 와 같이 &lt;code&gt;main::&lt;/code&gt; 한정되는 특수 식별자 중 하나 인 경우를 제외하고이 범위의 모든 규정되지 않은 동적 식별자는 지정된 네임 스페이스에 있습니다., &lt;code&gt;ENV&lt;/code&gt; 및 문장 부호 변수</target>
        </trans-unit>
        <trans-unit id="f1da10a5e5d78d8ddd42db2cd6041c8878256f5e" translate="yes" xml:space="preserve">
          <source>Declaring &lt;code&gt;@EXPORT_OK&lt;/code&gt; and Friends</source>
          <target state="translated">&lt;code&gt;@EXPORT_OK&lt;/code&gt; 및 친구들 선언</target>
        </trans-unit>
        <trans-unit id="bf1e27173b2b61ad7cc8d4e35225eb9ac31e3c57" translate="yes" xml:space="preserve">
          <source>Declaring @EXPORT_OK and Friends</source>
          <target state="translated">@EXPORT_OK 및 친구들 선언</target>
        </trans-unit>
        <trans-unit id="fde084d9565bae036b5f20474e01a929023e39bf" translate="yes" xml:space="preserve">
          <source>Declaring a subroutine allows a subroutine name to be used as if it were a list operator from that point forward in the program. You can declare a subroutine without defining it by saying &lt;code&gt;sub name&lt;/code&gt; , thus:</source>
          <target state="translated">서브 루틴을 선언하면 서브 루틴 이름을 마치 프로그램의 해당 시점부터 목록 연산자 인 것처럼 사용할 수 있습니다. &lt;code&gt;sub name&lt;/code&gt; 을 말하여 서브 루틴을 정의하지 않고 서브 루틴을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df50d3b937b66b95438db0baeefd22f2c1fa73b6" translate="yes" xml:space="preserve">
          <source>Decode</source>
          <target state="translated">Decode</target>
        </trans-unit>
        <trans-unit id="2baf8b86f083c5626552d12ceb5f07d33eee642a" translate="yes" xml:space="preserve">
          <source>Decode a base64 string by calling the decode_base64() function. This function takes a single argument which is the string to decode and returns the decoded data.</source>
          <target state="translated">decode_base64 () 함수를 호출하여 base64 문자열을 디코딩하십시오. 이 함수는 디코딩 할 문자열 인 단일 인수를 사용하여 디코딩 된 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="109d6d8d7f79aeac2b306278d0d11f591a9ace1e" translate="yes" xml:space="preserve">
          <source>Decode everything you receive, encode everything you send out. (If it's text data.)</source>
          <target state="translated">수신 한 모든 내용을 디코딩하고 발송 한 모든 내용을 인코딩하십시오. (텍스트 데이터 인 경우)</target>
        </trans-unit>
        <trans-unit id="4b9d36d83c06e37782d740af6424903230486d88" translate="yes" xml:space="preserve">
          <source>Decoding</source>
          <target state="translated">Decoding</target>
        </trans-unit>
        <trans-unit id="7569471cdb884355544f0d363051bcbdd3ab3bd3" translate="yes" xml:space="preserve">
          <source>Decoding can't happen reliably if you don't know how the data was encoded. If you get to choose, it's a good idea to standardize on UTF-8.</source>
          <target state="translated">데이터의 인코딩 방식을 모르는 경우 디코딩을 안정적으로 수행 할 수 없습니다. 선택하려면 UTF-8을 표준화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="abcb42a9bd28ce7905619e5495e33ddc378d15e2" translate="yes" xml:space="preserve">
          <source>Decoding does not need slurp mode if every line contains a multiple of four base64 chars:</source>
          <target state="translated">모든 줄에 4 개의 base64 문자가 여러 개 포함 된 경우 디코딩에 slurp 모드가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d2fb28c0e5d9fe827a3bd469e59cbc0c5460a44" translate="yes" xml:space="preserve">
          <source>Decomposition and Composition</source>
          <target state="translated">분해 및 조성</target>
        </trans-unit>
        <trans-unit id="1b059e79c07fd4e42a0c8736733855e555b987de" translate="yes" xml:space="preserve">
          <source>Decompress the file with &lt;code&gt;gzip -d yourmodule.tar.gz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gzip -d yourmodule.tar.gz&lt;/code&gt; 로 파일을 압축 해제하십시오</target>
        </trans-unit>
        <trans-unit id="fecfe7ecbf358f7b0d7f78df884a86cc9366776a" translate="yes" xml:space="preserve">
          <source>Decrement OBJ by one.</source>
          <target state="translated">OBJ를 1 씩 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f9e1ce708a313bdfe9eca73b07a0b2fbd7af57f3" translate="yes" xml:space="preserve">
          <source>Decrement an SV's reference count, and if it drops to zero, call &lt;code&gt;sv_clear&lt;/code&gt; to invoke destructors and free up any memory used by the body; finally, deallocate the SV's head itself. Normally called via a wrapper macro &lt;code&gt;SvREFCNT_dec&lt;/code&gt; .</source>
          <target state="translated">SV의 참조 횟수를 &lt;code&gt;sv_clear&lt;/code&gt; , 0으로 떨어지면 sv_clear 를 호출하여 소멸자를 호출하고 본문에서 사용하는 메모리를 비 웁니다 . 마지막으로 SV의 헤드 자체를 할당 해제하십시오. 일반적으로 래퍼 매크로 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 를 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a67ea7e86c28199b5df339f2ac9cbaf49e99821" translate="yes" xml:space="preserve">
          <source>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</source>
          <target state="translated">남아있는 각 SV의 refcnt를 줄이면 정리가 트리거 될 수 있습니다. 복잡한 자체 참조 계층 구조에있는 SV를 해제하려면이 기능을 여러 번 호출해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e7e93f2b8e3284df557787a48d088c384708e2" translate="yes" xml:space="preserve">
          <source>Decrements the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; by one. If the reference count reaches zero the structure's memory is freed, which (recursively) causes a reduction of its parent &lt;code&gt;refcounted_he&lt;/code&gt; 's reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; 의 참조 횟수를 1 씩 줄입니다. 참조 카운트가 0에 도달하면 구조의 메모리가 해제되어 (재귀 적으로) 부모 &lt;code&gt;refcounted_he&lt;/code&gt; 의 참조 카운트 가 감소 합니다. 이 함수에 널 포인터를 전달하는 것이 안전합니다.이 경우 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcec4515414c7f15a726073898aabc532b3d39f1" translate="yes" xml:space="preserve">
          <source>Decrements the reference count of the given SV.</source>
          <target state="translated">주어진 SV의 참조 카운트를 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="fad89dfcee27e9d87d909c911b20e8fe884012e9" translate="yes" xml:space="preserve">
          <source>Deep Cloning</source>
          <target state="translated">딥 클로닝</target>
        </trans-unit>
        <trans-unit id="c84353cad8816e49b138a483d1ebb30bfc16441f" translate="yes" xml:space="preserve">
          <source>Default Makefile Behaviour</source>
          <target state="translated">기본 메이크 파일 동작</target>
        </trans-unit>
        <trans-unit id="f5a8076e567450c53999f5638b343fac686a825d" translate="yes" xml:space="preserve">
          <source>Default Parameter Values</source>
          <target state="translated">기본 매개 변수 값</target>
        </trans-unit>
        <trans-unit id="4753d9b7084053c5089d49a71f2cde5d97a9c631" translate="yes" xml:space="preserve">
          <source>Default Parameters</source>
          <target state="translated">기본 매개 변수</target>
        </trans-unit>
        <trans-unit id="cc0e201c7029269ea6e8c9f6874c0179cc038bae" translate="yes" xml:space="preserve">
          <source>Default Test Directory</source>
          <target state="translated">기본 테스트 디렉토리</target>
        </trans-unit>
        <trans-unit id="44ec713d2a53a2de818adaf52eb763f357d09499" translate="yes" xml:space="preserve">
          <source>Default Warnings and Optional Warnings</source>
          <target state="translated">기본 경고 및 선택적 경고</target>
        </trans-unit>
        <trans-unit id="0566f3b85322f529cf1661115aa7b73ed4d004bc" translate="yes" xml:space="preserve">
          <source>Default destinations</source>
          <target state="translated">기본 목적지</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">기본 수출</target>
        </trans-unit>
        <trans-unit id="47421e2559e43abd036e2b184dadd2357238a719" translate="yes" xml:space="preserve">
          <source>Default is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;. If your keys contain binary data there might not be any safe value for &lt;code&gt;$;&lt;/code&gt; .</source>
          <target state="translated">기본값은 &quot;\ 034&quot;이며 &lt;b&gt;awk의&lt;/b&gt; SUBSEP와 동일 합니다. 키에 이진 데이터가 포함되어 있으면 &lt;code&gt;$;&lt;/code&gt; 안전한 값이 없을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="ffe4ea797d5b8a7f8cfde90ab339db72e2e542a2" translate="yes" xml:space="preserve">
          <source>Default is 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="3614d667188f70abf848a06aa0652a05a7980f2d" translate="yes" xml:space="preserve">
          <source>Default is 0;</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="117a6bf24c7268f690b354be18d70dcb8affc433" translate="yes" xml:space="preserve">
          <source>Default is 1;</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="94d18537fb9880b0b3a9844f6456e7041684d68a" translate="yes" xml:space="preserve">
          <source>Default is 4096.</source>
          <target state="translated">기본값은 4096입니다.</target>
        </trans-unit>
        <trans-unit id="6e26841758dcad7e26700059748889a29326c77f" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;File-Fetch@example.com&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;File-Fetch@example.com&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="4b21f25856f196d843b44afb04b8ac6eaef661e6" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;File::Fetch/$VERSION&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;File::Fetch/$VERSION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da032bd647313ecd583e516886d8ef8538d9001f" translate="yes" xml:space="preserve">
          <source>Default is false, meaning that when you use &lt;code&gt;store&lt;/code&gt; as a template key, &lt;code&gt;check&lt;/code&gt; will put it both in the scalar you supplied, as well as in the hashref it returns.</source>
          <target state="translated">기본값은 false입니다 . 템플릿 키로 &lt;code&gt;store&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;check&lt;/code&gt; 는 제공 한 스칼라와 반환 된 해시 참조에 둘 다 넣습니다.</target>
        </trans-unit>
        <trans-unit id="f23dbfcfc00cfaaa5823861693969bf14d49d57a" translate="yes" xml:space="preserve">
          <source>Default is for debugging mode to be disabled.</source>
          <target state="translated">기본값은 디버깅 모드를 비활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d09b4e9a70d326b80a3705a2d07cf6295402aa8f" translate="yes" xml:space="preserve">
          <source>Default is for files to be removed as requested by the caller.</source>
          <target state="translated">기본값은 호출자가 요청한대로 파일을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c92cef06212a1842160f64b786f629e6d8ef460" translate="yes" xml:space="preserve">
          <source>Default is for the file to be removed.</source>
          <target state="translated">기본값은 파일을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="611ca2ae870bcb7431782f0c4440d0df69e48190" translate="yes" xml:space="preserve">
          <source>Default is to assume that any UID less than or equal to 10 is a root UID.</source>
          <target state="translated">기본값은 10보다 작거나 같은 UID가 루트 UID라고 가정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fca13ec107ea72b752cc1954e7362fa3edfc913" translate="yes" xml:space="preserve">
          <source>Default is: &lt;code&gt; =&amp;gt; &lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt; =&amp;gt; &lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8820a54076d664561edd70760e8e08a8256672de" translate="yes" xml:space="preserve">
          <source>Default value is 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ff65fb164557c4cda7887f6d0b88d9af2694a1c4" translate="yes" xml:space="preserve">
          <source>Default value is 1.</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="041ad125ee75e430d661eb85a0aa9a66653995a9" translate="yes" xml:space="preserve">
          <source>Default value to use (instead of &lt;code&gt;croak&lt;/code&gt; ing with &quot;your vendor has not defined...&quot;) to return if the macro isn't defined. Specify a reference to an array with type followed by value(s).</source>
          <target state="translated">&lt;code&gt;croak&lt;/code&gt; 대신 사용할 기본값 매크로가 정의되지 않은 경우와 ING &quot;공급 업체가 ... 정의되지 않은&quot;)가 돌아갑니다. 유형과 값으로 배열에 대한 참조를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fe91ba1dc4d3dc98854423373895e4709f7bcaf4" translate="yes" xml:space="preserve">
          <source>Default values defined in the CPAN/Config.pm file can be overridden in a user specific file: CPAN/MyConfig.pm. Such a file is best placed in &lt;code&gt;$HOME/.cpan/CPAN/MyConfig.pm&lt;/code&gt;, because &lt;code&gt;$HOME/.cpan&lt;/code&gt; is added to the search path of the CPAN module before the use() or require() statements. The mkmyconfig command writes this file for you.</source>
          <target state="translated">CPAN / Config.pm 파일에 정의 된 기본값은 사용자 특정 파일 CPAN / MyConfig.pm에서 대체 될 수 있습니다. &lt;code&gt;$HOME/.cpan&lt;/code&gt; 은 use () 또는 require () 문 전에 CPAN 모듈의 검색 경로에 추가 되므로 이러한 파일은 &lt;code&gt;$HOME/.cpan/CPAN/MyConfig.pm&lt;/code&gt; 배치하는 것이 가장 좋습니다 . mkmyconfig 명령은이 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2390e056e940a5d1d57f0dfd7aeb859feb7ef003" translate="yes" xml:space="preserve">
          <source>Default values for XSUB arguments can be specified by placing an assignment statement in the parameter list. The default value may be a number, a string or the special string &lt;code&gt;NO_INIT&lt;/code&gt; . Defaults should always be used on the right-most parameters only.</source>
          <target state="translated">매개 변수 목록에 지정 문을 배치하여 XSUB 인수의 기본값을 지정할 수 있습니다. 기본값은 숫자, 문자열 또는 특수 문자열 &lt;code&gt;NO_INIT&lt;/code&gt; 일 수 있습니다. 기본값은 항상 가장 오른쪽의 매개 변수에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff08b56fbed2f2f2f7b04ba5e78bf45aaa623f3a" translate="yes" xml:space="preserve">
          <source>Defaults and how to override them</source>
          <target state="translated">기본값과이를 무시하는 방법</target>
        </trans-unit>
        <trans-unit id="e134e0139099634855fa20d262decd51a88d9996" translate="yes" xml:space="preserve">
          <source>Defaults to &quot;$(OBJECT)&quot; and is used in the ld command to specify what files to link/load from (also see dynamic_lib below for how to specify ld flags)</source>
          <target state="translated">기본값은 &quot;$ (OBJECT)&quot;이며 ld 명령에서 링크 /로드 할 파일을 지정하는 데 사용됩니다 (ld 플래그를 지정하는 방법은 아래 dynamic_lib 참조).</target>
        </trans-unit>
        <trans-unit id="7061416449de7f47367c9fcf92dab2f1e9008d0c" translate="yes" xml:space="preserve">
          <source>Defaults to &quot;unknown&quot;.</source>
          <target state="translated">기본값은 &quot;알 수 없음&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3afa08668c5c5dc51326fee541b5ff3c6d50395f" translate="yes" xml:space="preserve">
          <source>Defaults to $(DIST_DEFAULT) which in turn defaults to tardist.</source>
          <target state="translated">기본값은 $ (DIST_DEFAULT)이며 기본값은 tardist입니다.</target>
        </trans-unit>
        <trans-unit id="1e15a7e04559718dd148ec2dcf10c3805456f2a3" translate="yes" xml:space="preserve">
          <source>Defaults to $(FIRST_MAKEFILE).old or $(FIRST_MAKEFILE)_old on VMS.</source>
          <target state="translated">VMS의 기본값은 $ (FIRST_MAKEFILE) .old 또는 $ (FIRST_MAKEFILE) _old입니다.</target>
        </trans-unit>
        <trans-unit id="2f77e97345b6f70484f890ef33fb548347411e97" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{installprefixexp}, falling back to $Config{installprefix}, $Config{prefixexp} or $Config{prefix} should $Config{installprefixexp} not exist.</source>
          <target state="translated">$ Config {installprefixexp}가 없으면 $ Config {installprefixexp}, $ Config {prefixexp} 또는 $ Config {prefix}로 돌아가는 $ Config {installprefixexp}의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0d2a34019b39d0a59222f4965b474dc8e60e223a" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{installprivlib}.</source>
          <target state="translated">기본값은 $ Config {installprivlib}입니다.</target>
        </trans-unit>
        <trans-unit id="297039d02dfbd310b72f4d214dc03d0177d0f5ba" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{lddlflags}.</source>
          <target state="translated">기본값은 $ Config {lddlflags}입니다.</target>
        </trans-unit>
        <trans-unit id="1f5b612bc652d3b75be02b22a0c9c551d13e7785" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{ld}.</source>
          <target state="translated">기본값은 $ Config {ld}입니다.</target>
        </trans-unit>
        <trans-unit id="b736bfe876455ba787df5366a5e321959e9a06ef" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{make}, which may go looking for a Make program in your environment.</source>
          <target state="translated">기본적으로 $ Config {make}로, 환경에서 Make 프로그램을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a196b84e1a65651cad69ebad41443f48567f9d9" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{siteprefixexp}. Perls prior to 5.6.0 didn't have an explicit siteprefix in the Config. In those cases $Config{installprefix} will be used.</source>
          <target state="translated">기본값은 $ Config {siteprefixexp}입니다. 5.6.0 이전의 Perls에는 구성에 명시적인 사이트 접두사가 없습니다. 이 경우 $ Config {installprefix}가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e39813b2a929031c5d759deba757efe05e4152c9" translate="yes" xml:space="preserve">
          <source>Defaults to $Config{vendorprefixexp}.</source>
          <target state="translated">기본값은 $ Config {vendorprefixexp}입니다.</target>
        </trans-unit>
        <trans-unit id="e546dadcb8267744ab5961a80d3d0249f0af262e" translate="yes" xml:space="preserve">
          <source>Defaults to 'Makefile' or 'Descrip.MMS' on VMS.</source>
          <target state="translated">VMS의 기본값은 'Makefile'또는 'Descrip.MMS'입니다.</target>
        </trans-unit>
        <trans-unit id="36a3365955b62edce26a680e752008adf273fb56" translate="yes" xml:space="preserve">
          <source>Defaults to 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2178c999f5078fa159c89a3040ee28c0a0ab0555" translate="yes" xml:space="preserve">
          <source>Defaults to 1.</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="42b07f550144816ff7f9ad73156f6af2230242bf" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;-O&lt;/code&gt; . Set it to &lt;code&gt;-g&lt;/code&gt; to turn debugging on. The flag is passed to subdirectory makes.</source>
          <target state="translated">기본값은 &lt;code&gt;-O&lt;/code&gt; 입니다. 디버깅을 켜 려면 &lt;code&gt;-g&lt;/code&gt; 로 설정하십시오 . 플래그는 하위 디렉토리 제조업체로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4fbcc2fc6108b1d2b0294b983b1a9ad99a640450" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;0&lt;/code&gt; , meaning no timeout is set.</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; 이며 시간 초과가 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d988114015a6a9816c9d51daa92e80b47086fad8" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146cfb515515d203c57c9c8aab0bc48f6d370409" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6371c4ed1bbd778c501d9b308a25089892c98692" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;64&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dd3b4ec101beb9f1857e77cfca0e6a41873cc62" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;8&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5da3821742eb234c04279ce3cc2f85314c99eb1" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;@&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;@&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a0b8a3adf1fd6fbd992cea8cf36981968d31e21" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; (6).</source>
          <target state="translated">기본값은 &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; (6)입니다.</target>
        </trans-unit>
        <trans-unit id="147274cdbe6f000456b5b99fb65832fa4f82af15" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;MAX_WBITS&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04dcb63c213f6d34c69ca1a67ff471d071e8f496" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c72a3e89d9401a68060eed25afb0d35d9676747" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;{ &quot;ExtUtils::MakeMaker&quot; =&amp;gt; 0 }&lt;/code&gt; if this attribute is not specified.</source>
          <target state="translated">이 속성이 지정되지 않은 경우 기본값은 &lt;code&gt;{ &quot;ExtUtils::MakeMaker&quot; =&amp;gt; 0 }&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbe6c62dfeedbe39bcaae924b83b87595c0727be" translate="yes" xml:space="preserve">
          <source>Defaults to DISTNAME-VERSION.</source>
          <target state="translated">기본값은 DISTNAME-VERSION입니다.</target>
        </trans-unit>
        <trans-unit id="e117bd432f26952da4f40820366fde65f2edc72e" translate="yes" xml:space="preserve">
          <source>Defaults to MAX_MEM_LEVEL.</source>
          <target state="translated">기본값은 MAX_MEM_LEVEL입니다.</target>
        </trans-unit>
        <trans-unit id="9671af0548359bae98f06615c832c689de5fb555" translate="yes" xml:space="preserve">
          <source>Defaults to MAX_WBITS.</source>
          <target state="translated">기본값은 MAX_WBITS입니다.</target>
        </trans-unit>
        <trans-unit id="658dfec16a6b505da6e2bd38b1f2e25f8f18da74" translate="yes" xml:space="preserve">
          <source>Defaults to NAME below but with :: replaced with -.</source>
          <target state="translated">아래의 기본값은 NAME이지만 ::는-로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="0031bae010e59fe54ba067d872d7762129c8aa52" translate="yes" xml:space="preserve">
          <source>Defaults to STDERR.</source>
          <target state="translated">기본값은 STDERR입니다.</target>
        </trans-unit>
        <trans-unit id="5a78e74b3a77143d8c71cfa329a6e542084b340e" translate="yes" xml:space="preserve">
          <source>Defaults to STDOUT.</source>
          <target state="translated">기본값은 STDOUT입니다.</target>
        </trans-unit>
        <trans-unit id="a238dcad55848cd42cd0ed2c0201eceef53c02cf" translate="yes" xml:space="preserve">
          <source>Defaults to false, set to true to enable the described behaviour.</source>
          <target state="translated">설명 된 동작을 가능하게하려면 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="ecd31712dbbddfd1fe36a725d021309cb2a8b7de" translate="yes" xml:space="preserve">
          <source>Defaults to false, so it will remove null arguments. Set to true to allow them.</source>
          <target state="translated">기본값은 false이므로 null 인수를 제거합니다. 허용하려면 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="83771af0d9e990cfd4209b40879c5dd720b86a4b" translate="yes" xml:space="preserve">
          <source>Defaults to false.</source>
          <target state="translated">기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="18d301270448347decdf5cb69be9723a550b7cb5" translate="yes" xml:space="preserve">
          <source>Defaults to on.</source>
          <target state="translated">기본값은 on입니다.</target>
        </trans-unit>
        <trans-unit id="2b3470c82dabd8d59a7a8d6175578fc38bf7d623" translate="yes" xml:space="preserve">
          <source>Defaults to true. Turn this off at your own risk.</source>
          <target state="translated">기본값은 true입니다. 자신의 책임하에 이것을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="19d3228f23c29d1d70307e4e28b3e13d0ba13b19" translate="yes" xml:space="preserve">
          <source>Deferencing Method Call</source>
          <target state="translated">디 퍼런 싱 메소드 호출</target>
        </trans-unit>
        <trans-unit id="87a045f3d65fd182c7b238c413050e4d1b888897" translate="yes" xml:space="preserve">
          <source>Deferred Signals (Safe Signals)</source>
          <target state="translated">지연된 신호 (안전 신호)</target>
        </trans-unit>
        <trans-unit id="f67da11f1ea091fa4522255eade09d8d8a4672ae" translate="yes" xml:space="preserve">
          <source>Deferred Writing</source>
          <target state="translated">연기 된 글쓰기</target>
        </trans-unit>
        <trans-unit id="f16543b2bfaf8c9f85b87e700f4cb4c04d588365" translate="yes" xml:space="preserve">
          <source>Deferred writes are cached in memory up to the limit specified by the &lt;code&gt;dw_size&lt;/code&gt; option (see above). If the deferred-write buffer is full and you try to write still more deferred data, the buffer will be flushed. All buffered data will be written immediately, the buffer will be emptied, and the now-empty space will be used for future deferred writes.</source>
          <target state="translated">지연된 쓰기는 &lt;code&gt;dw_size&lt;/code&gt; 옵션에 의해 지정된 한계까지 메모리에 캐시됩니다 (위 참조). 지연 쓰기 버퍼가 가득 차서 더 지연된 데이터를 쓰려고하면 버퍼가 플러시됩니다. 버퍼링 된 모든 데이터가 즉시 기록되고 버퍼가 비워지며, 현재 비어있는 공간이 향후 지연된 쓰기에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b09e3bbab301107bd10474a2528bb3ad4a99662e" translate="yes" xml:space="preserve">
          <source>Define DL_FUNCS and DL_VARS and write the *.exp files.</source>
          <target state="translated">DL_FUNCS 및 DL_VARS를 정의하고 * .exp 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="12da81497a7167741d2b29f763f0e078260a1250" translate="yes" xml:space="preserve">
          <source>Define OPTAG as a symbolic name for OPSET. Optag names always start with a colon &lt;code&gt;:&lt;/code&gt; .</source>
          <target state="translated">OPTAG를 OPSET의 기호 이름으로 정의하십시오. 옵텍 이름은 항상 콜론으로 시작 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b358b3f5282189ce82f741fa330a8ab3125c3533" translate="yes" xml:space="preserve">
          <source>Define TO_UNIX to convert OS2 linefeeds to Unix style.</source>
          <target state="translated">OS2 줄 바꿈을 Unix 스타일로 변환하려면 TO_UNIX를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="25a3e54cd9dd2ac97b6cf9da4fc775b0fd09bf4f" translate="yes" xml:space="preserve">
          <source>Define a command alias, like</source>
          <target state="translated">다음과 같이 명령 별명을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="5393ccb5285b32c0372bdc2ca13e7ffc258abe0f" translate="yes" xml:space="preserve">
          <source>Define a macro. &lt;code&gt;Net::Netrc&lt;/code&gt; only parses this field to be compatible with</source>
          <target state="translated">매크로를 정의하십시오. &lt;code&gt;Net::Netrc&lt;/code&gt; 는이 필드 만 호환 가능하도록 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="4f7d921c7430791d35aa71dd9a7604bd56ac3756" translate="yes" xml:space="preserve">
          <source>Define a named capture group. Equivalent to &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt;.</source>
          <target state="translated">명명 된 캡처 그룹을 정의하십시오. 상당 &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51cc1c473eb56c40ad07bc0030ce03dcaeba9ef9" translate="yes" xml:space="preserve">
          <source>Define at compile-time your own custom character properties for use in regexes.</source>
          <target state="translated">정규식에 사용할 고유 한 사용자 정의 문자 속성을 컴파일 타임에 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e319203d5fc86ef244e3b22f31ca80388261db" translate="yes" xml:space="preserve">
          <source>Define this symbol if you want not-threaded faster perl.</source>
          <target state="translated">스레드되지 않은 더 빠른 perl을 원하면이 기호를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="47e540fd76e635df75335773557a724d22e221f7" translate="yes" xml:space="preserve">
          <source>Defined Falsehood. (&lt;code&gt;PL_sv_no&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">정의 된 거짓. ( &lt;code&gt;PL_sv_no&lt;/code&gt; ) 값이 필요하지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a264576fd62b5306a0590e9ebcaaeb8b9ebd00c2" translate="yes" xml:space="preserve">
          <source>Defined as a Make macro, it is invoked with file and directory arguments; &lt;code&gt;autosplit&lt;/code&gt; will split the specified file into the specified directory and delete obsolete &lt;code&gt;.al&lt;/code&gt; files, after checking first that the module does use the AutoLoader, and ensuring that the module is not already currently split in its current form (the modtime test).</source>
          <target state="translated">Make 매크로로 정의되며 파일 및 디렉토리 인수로 호출됩니다. &lt;code&gt;autosplit&lt;/code&gt; 지정된 디렉토리에 지정된 파일을 분할하고 오래된 삭제합니다 &lt;code&gt;.al&lt;/code&gt; 모듈이 자동로드를 사용한다는 것을 처음으로 확인하고, 모듈은 현재 이미 현재의 형태합니다 (modtime 시험)에 분할하지했는지 확인한 후, 파일을.</target>
        </trans-unit>
        <trans-unit id="0f9705fadf1dfeea4d0b965d304ecf0e1287b32a" translate="yes" xml:space="preserve">
          <source>Defined if $procselfexe is symlink to the absolute pathname of the executing program.</source>
          <target state="translated">$ procselfexe가 실행중인 프로그램의 절대 경로 이름에 심볼릭 링크되는 경우 정의됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
