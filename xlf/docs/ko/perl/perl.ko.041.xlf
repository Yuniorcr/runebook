<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">CPAN dist의 분배 메타 데이터</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">번들 배포는 ​​다른 배포와 동일한 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">의 distroprefs 시스템 &lt;code&gt;CPAN.pm&lt;/code&gt; 은 하나에 YAML 파일에 추가 정보와 요리법을 지정하는 사용자를 허용함으로써이 문제를 해결</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">나누기 (/) 및 다음 기능</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">DOS, 대한 DJGPP 환경 &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; 및 &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">do-or-die 등가물은 간단히 Fatal의 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 루틴 을 호출 하여 대체 될 함수의 이름을 전달하여 설정됩니다. 이 방법으로 사용자 정의 함수와 재정의 가능한 CORE 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 또는 프로토 타입을 통해 표현할 수없는 기타 내장 제외)를 모두 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Perl API에 대한 문서는 소스에서 사용되는 많은 매크로뿐만 아니라 일부 내부 함수의 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="translated">도트</target>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">도트 (또는 기간) &lt;code&gt;.&lt;/code&gt; 아마도 가장 많이 사용되는 문자 클래스 일 것입니다. 기본적으로 점은 개행을 제외한 모든 문자와 일치합니다. 이 기본값을 사용하여 줄 바꿈과 일치하도록 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">정규식 변수의 동적 인 특성은이 코드 비트에서 알 수 있듯이 해당 값이 포함 된 블록으로 제한됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">&lt;code&gt;newgetopt.pl&lt;/code&gt; 의 초기 개발은 1990 년 Perl 버전 4에서 시작되었습니다. 그 결과 개발 및 Getopt :: Long의 개발은 여러 단계를 거쳤습니다. 이전 버전과의 호환성은 항상 매우 중요했기 때문에 현재 버전의 Getopt :: Long은 오늘날 더 이상 필요하지 않거나 원하지 않는 많은 구성을 계속 지원합니다. 이 섹션에서는 이러한 '기능'중 일부에 대해 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">버그를 재현하는 것이 쉬울수록 수정 될 가능성이 높습니다. 문제를 복제 할 수있는 사람이 없으면 해결되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">재현 가능한 버그를 이해하기 쉬울수록 수정 될 가능성이 높습니다. 문제에 대한 통찰력은 많은 도움이 될 것입니다. 다시 말해, 문제를 분석하고 (가능한 한) 발견을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">자신 만의 소스 필터를 만들 수있는 가장 쉽고 이식성이 뛰어난 옵션은 Perl로 완전히 작성하는 것입니다. 이를 이전의 두 기술과 구별하기 위해이를 Perl 소스 필터라고합니다.</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">가장 쉬운 개념적 해결책은 파일의 행을 계산 한 다음 처음부터 시작하여 행 수 (마지막 N 빼기)를 새 파일로 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">가장 쉬운 방법은 Perl과 함께 제공 되는 &lt;code&gt;cpan&lt;/code&gt; 명령을 사용하여 CPAN이라는 모듈을 사용 하는 것입니다. 설치할 모듈 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">이를 수행하는 가장 쉬운 방법은 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey를&lt;/a&gt; 사용하여 비 차단 모드에서 키를 읽는 것입니다. 은 CPAN 모듈을 -1의 인수를 전달하여 차단하지 않도록 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">op 트리를 검사하는 가장 쉬운 방법은 구문 분석이 끝난 후 Perl을 중지하고 트리를 덤프하는 것입니다. 이것은 컴파일러가 &lt;a href=&quot;b/terse&quot;&gt;B :: Terse&lt;/a&gt; , &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 및 &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; 백엔드와 정확히 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">사용할 매크로의 템플리트 세트를 얻는 가장 쉬운 방법 은 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 와 함께 &lt;code&gt;-g&lt;/code&gt; ( &lt;code&gt;--global&lt;/code&gt; ) 옵션을 지정하는 것입니다 (h2xs 참조 ).</target>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">입력 가능한 개별 문자를 지정하는 가장 쉬운 방법은 대괄호로 묶는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">서브 루틴이 인라인되었는지 확인하는 가장 쉬운 방법은 &lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse를 사용하는 것&lt;/a&gt; 입니다. &lt;code&gt;1&lt;/code&gt; 을 반환하는 두 개의 서브 루틴의 예를 고려하십시오 . 하나는 &lt;code&gt;()&lt;/code&gt; 프로토 타입을 사용하여 인라인되고 다른 하나는 (명확성을 위해 출력이 잘리지 않습니다) :</target>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">쉬운 대답은 &quot;하지 마십시오!&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">&quot;failure_auto_handler&quot;를 사용하는 효과는 1) &quot;_&quot;로 시작하더라도 $ key를 컴파일하고 2) 새로운 hashref $ lh-&amp;gt; { 'failure_lex'}에 레코드가 있다는 점을 제외하면 AUTO 사전과 같습니다. 이 객체에 실패한 모든 키 중 키가 실제로 브라켓 코드처럼 유효하지 않고 존재하지 않는 메소드를 호출하지 않는 한 프로그램이 죽지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">이 과정의 효과적인 방법. 당신이 컴퓨터에있는 경우 동시에 여러 그룹에서 지원하는 회원은 공간이 당신에있는 그룹의 목록을 분리 준다. 첫 번째 숫자에 의해 반환되는 것과 &lt;code&gt;getegid()&lt;/code&gt; , 그리고에 의해 이후의 것들 &lt;code&gt;getgroups()&lt;/code&gt; , 하나의 수도 첫 번째 숫자와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">이 과정의 효과적인 UID. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">&lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; 요소 는 특별합니다. 읽을 때 Perl의 현재 기본 장치 및 디렉토리를 반환하며, 설정되면 정의에 관계없이 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">이 요소는 해시이며 기본적으로 &lt;code&gt;()&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">요소는 스칼라이며 기본적으로 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 초기화됩니다 (그러나 &lt;a href=&quot;#Initializing-with-new&quot;&gt;new로 초기화&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">요소는 배열이며 기본적으로 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">요소의 값은 명명 된 클래스 또는 해당 서브 클래스 중 하나에 축복 된 참조 여야합니다. 요소는 기본적으로 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">배열에서 얻는 요소는 배열 에서 단일 값을 가져 오기 때문에 &lt;code&gt;$&lt;/code&gt; 로 시작 합니다. 스칼라를 요청하면 스칼라를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 은 또한 플립 플롭 연산자의 3 도트 버전 이기 때문에 타원형 명령문은 더 큰 명령문의 일부인 표현식을 나타낼 수 없습니다 ( &lt;a href=&quot;perlop#Range-Operators&quot;&gt;perlop의 범위 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">CPAN ID를 받았을 때받은 이메일은 Perl Authors Upload SErver 인 PAUSE에 로그인하는 방법을 알려줍니다. 거기의 메뉴에서 모듈을 CPAN에 업로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">인코딩은 Encode 객체로 가정하고, 입력시 sv의 PV는 해당 인코딩에서 8 진수로 가정되며 sv는 유니 코드 (및 UTF-8)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">인코딩은 Encode 객체로 가정되며, ssv의 PV는 인코딩 및 디코딩이 입력에서 (PV + * offset)이 가리키는 위치에서 시작되는 옥텟으로 가정됩니다. dsv는 ssv에서 디코딩 된 UTF-8 문자열을 연결합니다. 디코딩 출력에 문자열 tstr이 나타나거나 ssv의 PV에서 입력이 종료되면 디코딩이 종료됩니다. 오프셋 포인트가 ssv의 마지막 입력 위치로 수정 될 값입니다.</target>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">EBCDIC 플랫폼에서는 인코딩 pragma가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">요청 된 인코딩은 Encode 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 의 인코딩은 pragma에 대한 매개 변수로 개별적으로 설정 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">이 모든 것의 최종 결과는 파일 이름 쌍의 목록입니다. 기본적으로 &lt;code&gt;globmap&lt;/code&gt; 이 반환합니다 . 이 예제에서 반환 된 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">엔진 구현 pack () Perl 함수.</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">엔진 구현 pack () Perl 함수. 참고 : next_in_list 매개 변수 및 플래그는 사용되지 않습니다. 이 호출을 사용해서는 안됩니다. 대신 packlist를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">unpack () Perl 함수를 구현하는 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">unpack () Perl 함수를 구현하는 엔진. 참고 : 매개 변수 strbeg, new_s 및 ocnt는 사용되지 않습니다. 이 호출을 사용해서는 안됩니다. 대신 unpackstring을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">패턴이 컴파일 된 플래그의 엔진 전용 사본. 엔진이 하나를 수정하도록 선택하지 않는 한 일반적으로 이것은 &lt;code&gt;extflags&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">태그를 사용하여 전체 getaddrinfo () 서브 시스템을 내보낼 수 있습니다 &lt;code&gt;:addrinfo&lt;/code&gt; ; getaddrinfo () 및 getnameinfo () 함수와 모든 &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; 및 &lt;code&gt;EAI_*&lt;/code&gt; 상수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">프로그램이 실행되는 전체 하드웨어 및 소프트웨어 컨텍스트. 기계, 운영 체제, 라이브러리, 컴파일러 또는 시스템 구성 중 하나를 변경하면 플랫폼 종속 언어로 작성된 프로그램이 중단 될 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">전체 업그레이드 / 다운 그레이드는 아직 실험 중이며 예상대로 작동하지 않거나 버그가있을 수 있습니다. 다음과 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">환경은 별도의 스칼라 변수로 자동으로 사용 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_RL&lt;/code&gt; 은로드되는 ReadLine 클론을 제어합니다. 값이 false이면 더미 인터페이스가 사용됩니다. 값이 true이면 사용할 패키지 이름의 꼬리 (예 : &lt;code&gt;Perl&lt;/code&gt; 또는 &lt;code&gt;Gnu&lt;/code&gt; ) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">에러 기능 [C99].</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">오류 수준은 '경고'또는 '오류'여야합니다.</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지 또는 객체는 기본적으로 가장 가까운 엔 클로징 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 제어를 리턴 하지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 때 예외로 사용됩니다 . 어떤 경우에, &lt;code&gt;croak_sv&lt;/code&gt; 기능이 정상적으로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">오류 메시지 또는 오브젝트는 기본적으로 표준 오류로 작성되지만 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지는 기본적으로 제어를 가장 가까운 엔 클로징 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 리턴하여 예외로 사용 되지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다. 어쨌든 &lt;code&gt;croak&lt;/code&gt; 함수는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">실패했을 때 &lt;b&gt;syscall에&lt;/b&gt; 의해 리턴 된 오류 번호 . Perl은 &lt;code&gt;$!&lt;/code&gt; 라는 이름으로 오류를 나타냅니다 . (또는 영어 모듈을 사용하는 경우 &lt;code&gt;$OS_ERROR&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">오류 값은 이중 변수입니다. &lt;code&gt;EI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 오류가 발생하지 않으면 숫자로 0이되고 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">오류 값은 이중 변수입니다. &lt;code&gt;EI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 호스트 및 서비스 이름은 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">평가 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 대체 문자열을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; 감싸고 평가 된 결과는 일치하는 하위 문자열로 대체됩니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">이 매크로의 정확한 구현은 아키텍처 및 버전의 perl에 따라 다르며 반환 값은 호출마다 변경 될 수 있으므로 단일 perl 프로세스 기간 동안 만 값이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">정확한 줄 번호는 다를 수 있지만 경고 (W)가 줄 줄에서 오는 경우</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">정확한 줄 번호는 Perl 릴리스마다 다를 수 있습니다. 경고는 양성이며 무시할 수 있습니다. 나중의 C 컴파일러 릴리스에서는 경고가 사라져야합니다.</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">주소가 $ symref로 반환되는 정확한 방법은 현재 정의되어 있지 않습니다. 초기 요구 사항은 $ symref가 dl_install_xsub ()로 전달되고 이해 될 수 있어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos 필드의 정확한 의미는 다양하지만 일반적으로 사용자의 실제 이름 (로그인 이름과 반대) 및 사용자와 관련된 기타 정보를 포함합니다. 그러나 많은 시스템 사용자가이 정보를 변경할 수 있으므로 신뢰할 수 없으므로 $ gcos가 오염됩니다 ( &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). 같은 이유로 사용자의 암호화 된 비밀번호 및 로그인 쉘인 $ passwd 및 $ shell도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos 필드의 정확한 의미는 다양하지만 일반적으로 사용자의 실제 이름 (로그인 이름과 반대) 및 사용자와 관련된 기타 정보를 포함합니다. 그러나 많은 시스템 사용자가이 정보를 변경할 수 있으므로 신뢰할 수 없으므로 $ gcos가 오염됩니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). 같은 이유로 사용자의 암호화 된 비밀번호 및 로그인 쉘인 $ passwd 및 $ shell도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">패턴에서 (?? {}) 및 (? {})가 얼마나 자주 실행되는지에 대한 정확한 규칙은 지정되지 않습니다. 성공적으로 일치하는 경우 DWIM이라고 가정 할 수 있으며 다른 메타 패턴과 마찬가지로 패턴의 허용 경로에서 적절한 횟수만큼 왼쪽에서 오른쪽으로 실행됩니다. 허용되지 않는 경로와 일치 실패가 패턴이 실행되는 횟수에 영향을주는 방식은 구체적으로 지정되지 않으며 패턴에 적용 할 수있는 최적화에 따라 다를 수 있으며 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">단 하나의 &quot;= for&quot;단락을 사용하면 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 Perl 5.8.0부터 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;../fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;../attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 Perl 5.8.0부터 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 로 선언 된 상수 또는 __PACKAGE__ 일 수 있습니다. 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 Perl 5.8.0부터 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 로 선언 된 상수 또는 __PACKAGE__ 일 수 있습니다. 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 Perl 5.8.0부터 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;../fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;../attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 정확한 문자 세트는 다양한 pragma 및 정규식 수정 자에 따라 다릅니다. &lt;code&gt;/a&lt;/code&gt; 정규식 수정자를 사용하여 일치를 ASCII 범위로 제한 할 수 있습니다 . &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">아래 예는 앞에서 제시 한 부동 소수점 숫자에 대한 패턴을 사용하여이 기능을 보여줍니다. 두 번 이상 사용되는 세 개의 하위 패턴은 선택적 부호, 정수의 숫자 시퀀스 및 소수입니다. 패턴 끝에있는 DEFINE 그룹에는 해당 정의가 포함됩니다. 소수 패턴은 정수 패턴을 재사용 할 수있는 첫 번째 위치입니다.</target>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 와 일치하는 문자 가 로케일에 의해 결정 되므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우이 예제는 &lt;code&gt;$data&lt;/code&gt; 를 포함하지 않습니다 . Perl은 로케일 정의가 프로그램 외부의 데이터를 포함하므로 신뢰할 수없는 것으로 간주합니다. 당신이 로케일 인식 프로그램을 작성하고, 포함하는 정규 표현식과 론더 데이터를 원하는 경우 &lt;code&gt;\w&lt;/code&gt; 삽입하지 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 로케일을 같은 블록에 표현 앞서. 추가 토론 및 예 &lt;a href=&quot;perllocale#SECURITY&quot;&gt;는 perllocale의 보안을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">위의 예제는 펄 인터프리터에 대한 상대 경로를 사용하여 사용자 경로에서 첫 번째 버전을 가져옵니다. 예를 들어 perl5.14.1과 같은 특정 버전의 Perl을 원한다면 &lt;code&gt;#!&lt;/code&gt; 직접 배치해야합니다 ! 라인의 경로.</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">문서 시작 부분에 제공된 예제 (오류 처리기 및 이벤트 기반 프로그램)는 콜백에서 발생할 수있는 두 가지 주요 종류의 흐름 제어의 전형적인 예입니다. 그들 사이에는 매우 중요한 차이점이 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">예제는 몇 가지 측면을 보여줍니다. 처음 세 개의 쿼리는 모듈, 작성자 또는 배포를 직접 대상으로하며 정확히 하나의 결과를 산출합니다. 마지막 두 개는 정규 표현식을 사용하고 여러 결과를 산출합니다. 마지막은 모든 번들, 모듈, 작성자 및 배포를 동시에 대상으로합니다. 사용 가능한 결과가 두 개 이상인 경우 한 줄 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">이전 섹션의 예제는 성가신 약점을 보여줍니다. 우리는 3 글자 단어 나 4 글자 이하의 단어 만 일치 시켰습니다. &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; 와 같은 지루한 대안을 작성하지 않고 단어 또는 더 일반적으로 길이가 긴 문자열과 일치시킬 수 있기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">예제는 다음을 구현하는 매우 간단한 클래스를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">예제는이 클래스가 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 의해 서로 다른 수준의 지원으로 구현 되었음을 보여줍니다 . 지원되는 모든 조합이 표시됩니다. 구현 간의 차이는 종종 매우 작습니다. 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt; 의 우수한 캘린더 FAQ</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">뛰어난 Filter :: Util :: Call 모듈 (Paul Marquess 제작)은 소스 필터링에 유용한 Perl 인터페이스를 제공하지만, 너무 강력하고 단순하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">프로그램에서 정책을 체계화 할 수있는 조직 별 이메일 (예 : foo@yourcompany.com)은 예외입니다. 이 경우, 다음과 같이 스칼라 컨텍스트에서 $ ENV {USER}, $ ENV {LOGNAME} 및 getpwuid ($ &amp;lt;)를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">&quot;하나의 오염 된 값이 전체 표현을 오염시킨다&quot;는 원칙은 예외적으로 삼항 조건 연산자 &lt;code&gt;?:&lt;/code&gt; 입니다. 삼항 조건을 가진 코드부터</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">이 규칙의 예외는</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">이 규칙의 예외는 XSUB 함수에서 직접 Perl 서브 루틴을 호출하는 경우입니다. 이 경우 &lt;code&gt;dSP&lt;/code&gt; 매크로를 명시 적으로 사용할 필요가 없으며 자동으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">실행 순서는 &lt;code&gt;===&amp;gt;&lt;/code&gt; 마크로 표시되므로 &lt;code&gt;3 4 5 6&lt;/code&gt; (노드 &lt;code&gt;6&lt;/code&gt; 은 위 목록에 포함되지 않음)입니다. 즉, &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">요약 : 파일 시스템 작동 방식을 익히십시오. 파일에 대한 권한은 해당 파일의 데이터에 발생할 수있는 일을 말합니다. 디렉토리에 대한 권한은 해당 디렉토리의 파일 목록에서 발생할 수있는 작업을 나타냅니다. 파일을 삭제하면 디렉토리에서 파일 이름이 제거됩니다 (따라서 작업은 파일이 아닌 디렉토리의 권한에 따라 다릅니다). 파일에 쓰려고하면 파일의 권한이 허용 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">실행 된 프로그램의 종료 코드</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">종료 상태 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit () 함수가 항상 즉시 종료되는 것은 아닙니다. 정의 된 &lt;code&gt;END&lt;/code&gt; 루틴을 먼저 호출 하지만이 &lt;code&gt;END&lt;/code&gt; 루틴 자체가 종료를 중단 할 수는 없습니다. 마찬가지로 호출해야하는 객체 소멸자가 실제 종료 전에 호출됩니다. &lt;code&gt;END&lt;/code&gt; 루틴 및 소멸자는 &lt;code&gt;$?&lt;/code&gt; 를 수정하여 종료 상태를 변경할 수 있습니다 . . 이것이 문제이면 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 를 호출 하여 END 및 소멸자 처리를 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit () 함수가 항상 즉시 종료되는 것은 아닙니다. 정의 된 &lt;code&gt;END&lt;/code&gt; 루틴을 먼저 호출 하지만이 &lt;code&gt;END&lt;/code&gt; 루틴 자체가 종료를 중단 할 수는 없습니다. 마찬가지로 호출해야하는 객체 소멸자가 실제 종료 전에 호출됩니다. &lt;code&gt;END&lt;/code&gt; 루틴 및 소멸자는 &lt;code&gt;$?&lt;/code&gt; 를 수정하여 종료 상태를 변경할 수 있습니다 . . 이것이 문제이면 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 를 호출 하여 END 및 소멸자 처리를 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">실험적으로 &lt;code&gt;given&lt;/code&gt; 진술은</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">실험 &lt;code&gt;legacy&lt;/code&gt; 프라그 마는 &lt;code&gt;feature&lt;/code&gt; 프라그 마에 의해 삼켰다 .</target>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">지수는 &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 이며 정수가 뒤에옵니다. 지수 정규 표현식은</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">지수 연산자는 &quot;^&quot;가 아니라 &quot;**&quot;입니다. &quot;^&quot;는 C에서와 같이 XOR 연산자입니다. &lt;b&gt;awk&lt;/b&gt; 가 기본적으로 C와 호환되지 않는다는 느낌을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">식은 스칼라 컨텍스트에서 평가됩니다. 따라서 다음이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">ext / ODBM_File / odbm은 Tru64의 정적 libdbm 라이브러리의 알려진 버그로 인해 정적 빌드 (Configure -Uusedl)와 함께 실패하는 것으로 알려져 있습니다. 좋은 소식은 고급 DB2_File은 말할 것도없고 고급 NDBM_File도 제대로 작동하기 때문에 ODBM_File 확장명을 사용할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">확장 된 파일 테스트 기능은 파일 핸들이 아닌 연산자의 인수가 파일 이름 인 경우에만 Perl에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">확장은 동적으로 연결됩니다</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">확장명은 순수한 perl이므로 perl 실행 파일에 연결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">확장은 정적으로 펄 바이너리에 연결됩니다</target>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 구분자를 포함하여 추출 된 문자열 추출에 실패하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">추출 된 termcap 항목은 오브젝트에서 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">추출 프로세스는 각 추출기를 순차적으로 텍스트 문자열에 적용하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">이러한 FILE *이 '내 보낸'사실은 (일반적으로 PerlIO에 새로운 : stdio &quot;계층&quot;을 밀어 넣어 *) 기록됩니다. 이는 원래 PerlIO *의 향후 PerlIO 작동에 영향을 줄 수 있습니다. 당신은 호출하지 않아야합니다 &lt;code&gt;fclose()&lt;/code&gt; 당신이 필요하지 않은 경우 파일에 &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; 은 PerlIO에서 연결을 해제 할 *. 연결 해제를 위해 PerlIO_importFILE ()을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">공장 자체는 인스턴스화되지 않습니다 (이것은</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">fastgetcwd () 함수는 cwd ()의 동의어로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">기능 논리 이름 DECC $ FILENAME_UNIX_REPORT는 파일 스펙을 Unix에서 VMS 형식으로 변환 할 때 기존 Perl 동작을 수정하여 CRTL에 의해 현재 예상되는 확장 문자 처리 규칙을 따릅니다. &lt;code&gt;./.../&lt;/code&gt; 기능이 적용되면 Unix 경로 의 ./.../ 가 기존 VMS &lt;code&gt;[...]&lt;/code&gt; 대신 &lt;code&gt;[.^.^.^.]&lt;/code&gt; 로 변환 됩니다 . MakeMaker가 기대하는 것과 호환되도록 VMS 경로를 Unix 경로로 변환 할 수 없으면 변경되지 않은 상태로 전달되므로 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; 는 &lt;code&gt;[...]&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">이 기능은 &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; 로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">당신이 당신의 어머니와 아버지로부터 얻은 특징은, 예측할 수없이 혼합되었습니다. ( &lt;b&gt;상속&lt;/b&gt; 및 &lt;b&gt;단일 상속&lt;/b&gt; 도 참조하십시오 .) 컴퓨터 언어 (Perl 포함)에서 주어진 클래스에 여러 개의 직계 조상이나 &lt;b&gt;기본 클래스&lt;/b&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">아버지가 없다고 말하면 어머니에게서받은 특징. ( &lt;b&gt;상속&lt;/b&gt; 및 &lt;b&gt;다중 상속&lt;/b&gt; 도 참조하십시오 .) 컴퓨터 언어에서, 주어진 클래스가 하나의 직계 조상 또는 &lt;b&gt;기본 클래스를&lt;/b&gt; 가질 수 있도록 &lt;b&gt;클래스가&lt;/b&gt; 무성 생식 한다는 생각 . Perl은 그러한 제한을 제공하지 않지만, 원하는 경우 확실히 Perl을 프로그래밍 할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">&quot;@ *&quot;필드는 여러 줄의 잘리지 않은 값을 인쇄하는 데 사용할 수 있습니다. 그것은 그 자체로 줄에 나타나야하지만 (필요하지는 않지만) 마지막 줄 바꿈이 끊어 지지만 다른 모든 문자는 그대로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">필드는 아래에서 더 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">필드는 탭으로 구분됩니다. 첫 번째 열은 깊이입니다 (가장 튀지 않은 가장 안쪽의 프레임은 0 임). hex : offset에서 16 진은 프로그램 카운터가 S_parse_body에있는 위치이며, : offset (없을 수 있음)은 S_parse_body 내부에서 프로그램 카운터의 양을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">이 줄에 나타날 수있는 관심 분야는</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">파일</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">오류가 발생한 파일 (이름)</target>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">&lt;code&gt;perlio.c&lt;/code&gt; 파일 은 다음 레이어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">MANIFEST.SKIP 파일은 mkmanifest () 및 filecheck ()에 의해 무시되어야하는 파일의 정규식을 포함 할 수 있습니다. 정규식은 각 줄에 하나씩 표시되어야합니다. 빈 줄과 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 건너 뜁니다. 사용 &lt;code&gt;\#&lt;/code&gt; 당신은 시작하는 정규 표현식을 필요로하는 경우 &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">Makefile.PL 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Mytest.pm 파일은 다음과 같이 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">Unicode / Collate / allkeys.txt 파일은 &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt; 에서 그대로 복사되었습니다 . 이 파일에 대해 저작권 (C) 2001에서 2012 사이 유니 코드, 주식의 이용 약관에 따라 배포 &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">파일은</target>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">파일 핸들이 닫히거나 프로그램이 종료되면 파일이 제거됩니다. 파일 이름에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">파일은 초기화 코드의 성공적인 실행을 나타 내기 위해 마지막 명령문으로 true를 리턴해야하므로 이러한 파일을 &lt;code&gt;1;&lt;/code&gt; 로 종료하는 것이 일반적입니다 . 확실하지 않으면 그렇지 않으면 true를 반환합니다. 그러나 &lt;code&gt;1;&lt;/code&gt; 을 넣는 것이 좋습니다 . 문을 더 추가하는 경우</target>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">VERSION_FROM에 이름이 지정된 파일은 Makefile에 대한 종속성으로 추가되지 않습니다. 이것은 실제로 정확하지는 않지만 개발 과정에서 파일의 작은 변화에 대해 Makefile을 다시 작성해야하는 것은 큰 고통입니다. 파일을 변경 한 후 Makefile에 올바른 버전 매크로가 포함되도록하려면 다음과 같은 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">파일 리디렉션 문자 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;및 &quot;|&quot; 큰 따옴표로 인용 할 수 있습니다 (항상 그렇지는 않다는 제안이 있지만). 작은 따옴표는 쉘 또는 C 런타임에서 따옴표로 처리되지 않으며 쉘에 의해 제거되지 않습니다 (이 유형의 인용을 완전히 쓸모 없게 만들기 위해). 캐럿 &quot;^&quot;도 인용 문자로 작동하는 것으로 관찰되었지만 이는 쉘 기능인 것으로 보이며 캐럿이 명령 행에서 제거되지 않았으므로 Perl은 여전히이를 인식합니다 (C 런타임 단계는 처리하지 않습니다) 따옴표 문자로 캐럿).</target>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">File :: Temp에 의해 반환 된 파일은 이러한 모드를 사용할 수있는 경우 이진 모드로 열립니다. 정확하지 않으면 C를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">파일 형식 또는 확장명은 길이가 0 인 경우에도 항상 VMS 형식 파일 사양에 있습니다. 이것은 기본적으로 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 이 확장자없이 파일에 후행 점을 반환하므로 Unix에서 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 가 표시되면 &quot;a&quot; 가 표시 &lt;code&gt;&quot;a.&quot;&lt;/code&gt; VMS에서. 그러나 환경에서 &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 기능을 사용 하면 후행 점이 표시되지 않을 수 있습니다 (기능 논리 이름에 대한 CRTL 문서 참조).</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">파일 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">파일 핸들은 일반적으로 부모에 대해 동작하지만 해당 파일 핸들에 대한 I / O는 자식 프로세스의 STDOUT / STDIN으로 파이프됩니다. 자식 프로세스에서는 파일 핸들이 열리지 않습니다. I / O는 새로운 STDOUT / STDIN에서 시작됩니다. 일반적으로 이는 setuid를 실행할 때와 같이 파이프 명령이 실행되는 방식을보다 세밀하게 제어하고 메타 문자에 대한 셸 명령을 스캔 할 필요가없는 경우 일반 파이프 열기와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">참조 횟수가 0에 도달하면 파일 핸들이 닫힙니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 범위 변수 인 경우 일반적으로 둘러싸는 범위의 끝을 의미합니다. 그러나이 자동 닫기는 오류를 확인하지 않으므로 파일 핸들, 특히 쓰기에 사용되는 파일 핸들을 명시 적으로 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">참조 횟수가 0에 도달하면 파일 핸들이 닫힙니다. &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 범위 변수 인 경우 일반적으로 둘러싸는 범위의 끝을 의미합니다. 그러나이 자동 닫기는 오류를 확인하지 않으므로 파일 핸들, 특히 쓰기에 사용되는 파일 핸들을 명시 적으로 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">파일 핸들 STDIN, STDOUT 및 STDERR이 사전 정의되어 있습니다. (파일 핸들은 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 또한 지역 식별자가 아닌 글로벌로 해석 될 것이다 패키지를 제외하고 작동합니다.합니다) 추가 파일 핸들은 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 다른 사람의 사이에, 기능. 참조 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 과 &lt;a href=&quot;functions/open&quot;&gt;열&lt;/a&gt; 이에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">파일 핸들은 정수일 수도 있으며,이 경우 파일 디스크립터로 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">App :: Prove :: State가 읽는 데이터가 들어있는 데이터 저장소의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">이 확장과 함께 사용될 perllibrary의 파일 이름. 기본값은 libperl.a입니다.</target>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">open ()의 한 인수 및 두 인수 형식으로 전달 된 파일 이름에는 선행 및 후행 공백이 삭제되고 일반 리디렉션 문자가 적용됩니다. &quot;매직 오픈&quot;이라고하는이 속성은 종종 좋은 효과를 내기 위해 사용될 수 있습니다. 사용자는 파일 이름을</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">파일들</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">&quot;qnx&quot;디렉토리의 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">파일 시스템은 액세스 타임 스탬프 나 변경 타임 스탬프 (휴대용 타임 스탬프가 수정 타임 스탬프임을 의미) 또는 타임 스탬프의 1 초 단위 (예 : FAT 파일 시스템은 시간 단위를 2 초로 제한 함)를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파일 시스템은 하드 링크 ( &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ) 또는 기호 링크 ( &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; )를 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Symbian 장치의 파일 시스템은 DOSish 구문, 콜론으로 경로와 구분 된 &quot;드라이브&quot;및 경로에 대한 백 슬래시를 사용합니다. 드라이브의 정확한 할당은 플랫폼마다 다를 수 있지만, 예를 들어 Series 60에서 C :는 (플래시) 기본 메모리로, D :는 RAM 드라이브로, E :는 메모리 카드 (MMC), Z :는 ROM. Series 80 D :는 메모리 카드입니다. 장치가 NUL :까지는 비트 버킷, COMx :는 직렬 회선, IRCOMx :는 IR 포트, TMP :는 C : \ System \ Temp 일 수 있습니다. 큰 따옴표로 묶인 백 슬래시를 두 배로 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">파일 테스트 연산자 &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 단순한 통계 버퍼보다 ​​더 많은 정보가 필요하므로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">필터는 Perl 이 &lt;code&gt;DEBUG&lt;/code&gt; 환경 변수가 존재하는 경우에만 &amp;lt;DEBUG_BEGIN&amp;gt;과 &lt;code&gt;DEBUG_END&lt;/code&gt; 마커 사이의 코드를 구문 분석하도록 합니다. 즉 , &lt;code&gt;DEBUG&lt;/code&gt; 가 존재하면 위의 코드는 변경없이 필터를 통과해야합니다. Perl 파서는 그것들을 주석 라인으로 볼 것이기 때문에 마커 라인은있는 그대로 통과 될 수도 있습니다. 하면 &lt;code&gt;DEBUG&lt;/code&gt; 가 설정되어 있지 않은, 우리는 디버그 코드를 해제하는 방법이 필요합니다. 이를 달성하는 간단한 방법은 두 마커 사이의 선을 주석으로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">포함 된 필터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">필터가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">필터는 키에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">필터가 값에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">최종 &lt;code&gt;PUTBACK&lt;/code&gt; 은 함수를 종료하기 전에 Perl 스택을 일관된 상태로 두는 데 사용됩니다. &lt;code&gt;POPi&lt;/code&gt; 를 사용하여 스택의 반환 값을 팝했을 때 스택 포인터의 로컬 복사본 만 업데이트 했기 때문에이 작업이 필요 합니다. 기억 &lt;code&gt;PUTBACK&lt;/code&gt; 는 우리의 로컬 복사본와 동일하게 글로벌 스택 포인터를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">마지막 문자는 하이픈, 콜론 또는 마침표 일 수 없습니다. 이러한 문자로 끝나는 URL은 XHTML에서 허용하지만 일반 텍스트에서 추출하기 어색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">정규 괄호로 묶인 문자 클래스와 이것의 최종 차이점은 다중 문자 접기와 일치시킬 수 없다는 것입니다. 그러므로,</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">목록 할당의 마지막 요소는 배열 또는 해시 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">마지막 줄 (인덱스 [242] 사용)은 유효한 유니 코드 최대 코드 포인트를 초과하는 모든 코드 포인트의 값에 &quot;No_Block&quot;값이 있음을 의미합니다. 이는 유니 코드가 존재하지 않는 블록에 사용하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">마지막 작업은 백 슬래시 문자를 사용하여 열린 대괄호 &lt;code&gt;[&lt;/code&gt; , 별표, 백 슬래시 또는 물음표 의 특수한 의미를 무효화합니다 . 순서대로 두 개의 백 슬래시는 특별한 의미가없는 문자로 백 슬래시를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">블록의 마지막 세미콜론은 목록의 마지막 쉼표와 마찬가지로 선택 사항입니다. 좋은 스타일 ( &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 참조 )은 한 줄짜리를 제외하고는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">마지막 세미콜론 (있는 경우)은 EXPR 값에서 또는 BLOCK 내에서 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">마지막 단계는 &lt;code&gt;test_test&lt;/code&gt; 를 호출 하여 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder가&lt;/a&gt; 실제로 출력 한 것과 미리 선언 한 것을 비교 하고 결과를 &quot;ok&quot;또는 &quot;not ok&quot;(디버깅 사용)로 정상 출력에 다시보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">마지막 단계는 &lt;code&gt;*.tar.gz&lt;/code&gt; 파일 glob 과 일치하는 각 파일 이름을 파생 된 Perl 정규식을 통해 차례로 전달하고이를 사용하여 출력 fileglob를 확장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">여기서 논의 할 마지막 두 수정자인 &lt;code&gt;//g&lt;/code&gt; 및 &lt;code&gt;//c&lt;/code&gt; 는 여러 개의 일치 항목과 관련됩니다. 수정 자 &lt;code&gt;//g&lt;/code&gt; 는 전역 일치를 나타내며 일치 연산자가 문자열 내에서 가능한 한 많이 일치하도록합니다. 스칼라 문맥에서 문자열에 대한 연속 호출 은 일치 하는 문자열 에서 &lt;code&gt;//g&lt;/code&gt; 점프하여 문자열의 위치를 ​​추적합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">이 함수에 의해 반환 된 네 개의 요소 목록에서 마지막 네 번째 요소 ( &quot;block&quot;예제에서 &lt;code&gt;$default&lt;/code&gt; 에 할당 된 인덱스 [3] )는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 형식 유형 과 함께 사용됩니다 . 반환 된 반전 맵 데이터 구조를 해시와 같은 다른 것으로 변환하려는 응용 프로그램에도 유용 할 수 있습니다. 대부분의 코드 포인트가 속성 아래에 매핑되는 매핑을 제공합니다. 데이터 구조에 명시 적으로 나열되지 않은 코드 포인트가이 값에 매핑되는 규칙을 설정하면 데이터 구조를 훨씬 더 작게 만들 수 있습니다. 이 함수에서 반환 된 데이터 구조에서 데이터 구조를 구성 할 때이 값에 매핑되는 범위를 무시하십시오. 예를 들어 &lt;a href=&quot;#charinrange()&quot;&gt;charinrange ()로&lt;/a&gt; 검색 가능한 데이터 구조로 변환하려면조정이 필요없는 속성의 경우이 레시피를 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">find_dup () 메소드</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">유니 코드의 첫 번째 (현재는 실패한) 목표는 모든 문자 레퍼토리를 고정 길이 정수로 매핑하여 프로그래머가 만족할 수 있도록하는 것이 었습니다. 각 문자는</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">&lt;b&gt;네임 스페이스&lt;/b&gt; 를 업로드 한 첫 번째 &lt;b&gt;PAUSE&lt;/b&gt; 작성자는 자동으로 해당 네임 스페이스 의 &lt;b&gt;기본 관리자&lt;/b&gt; 가됩니다 . &quot;선착순&quot;권한 은 해당 역할이 지정된 &lt;b&gt;기본 관리자&lt;/b&gt; 와 자동으로받은 &lt;b&gt;관리자&lt;/b&gt; 를 구별합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">이 함수의 첫 번째 Perl 인수는 문자로 취급되고 변수 a에 지정되며 해당 주소는 함수 foo로 전달됩니다. 두 번째 Perl 인수는 문자열 포인터로 취급되어 변수 b에 지정됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">첫 번째와 두 번째 인수는 문자열, typeglob, typeglob 참조 또는 IO :: Handle;에서 상속되는 객체 일 수 있습니다. 그들은 모든 경우에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">첫 번째와 두 번째 양식은 작성중인 클래스의 이름을 명시 적으로 식별합니다. 세 번째 형식은 현재 패키지 이름을 클래스 이름으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;pointer&lt;/code&gt; 는 새로 할당 된 메모리를 가리키는 변수의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">&lt;code&gt;setlocale()&lt;/code&gt; 의 첫 번째 인수 는 &lt;b&gt;category를&lt;/b&gt; 제공하고 두 번째 인수 는 &lt;b&gt;locale을 제공&lt;/b&gt; 합니다. 이 범주는 로케일 별 규칙을 적용하려는 데이터 처리 측면을 알려줍니다. 카테고리 이름은 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; 및 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 에서 설명 합니다. 로케일은 언어, 국가 또는 지역 및 코드 세트의 특정 조합에 해당하는 사용자 정의 정보 콜렉션의 이름입니다. 로케일 이름 지정에 대한 힌트를 읽으십시오 (예에서와 같이 모든 시스템의 이름이 로케일 인 것은 아님).</target>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 의 첫 번째 인수 는 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 함수에 대한 코드 참조 이거나 각 파일에 대해 수행 할 작업을 설명하는 해시 참조입니다. 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;의 원하는 기능에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">첫 번째 호출은 값이없는 필사자 SV를 작성하고 두 번째 호출은 기존 SV를 필사자 SV로 변환하여 ( &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 에 대한 호출을 연기 함 ) 세 번째 호출 은 기존 SV의 필사본 사본을 작성합니다. &lt;code&gt;sv_newmortal&lt;/code&gt; 은 새로운 SV에 값을주지 않기 때문에 일반적으로 &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; 등을 통해 값을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">첫 번째 호출은 결과, 즉 37을 스칼라 캐시에 캐시합니다. 두 번째는 목록 캐시에서 목록 &lt;code&gt;(37)&lt;/code&gt; 을 캐시합니다. 세 번째 호출은 실제 &lt;code&gt;complicated&lt;/code&gt; 함수를 호출하지 않습니다 . 스칼라 캐시에서 값 37을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">등록 된 첫 번째 콜백은 대기를위한 콜백입니다. 콜백은 입력 파일 핸들을 기다리는 무언가가있을 때까지 현재 이벤트 루프를 호출 할 것으로 예상됩니다. 전달 된 매개 변수는 두 번째 콜백의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">접힌 버전의 첫 번째 코드 포인트가 반환됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">소문자 버전의 첫 번째 코드 포인트가 리턴됩니다 (단, 위에서 설명한대로 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">제목이 지정된 버전의 첫 번째 코드 포인트가 반환됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">대문자 버전의 첫 번째 코드 포인트가 리턴됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">첫 번째 열은 문자의 유니 코드 코드 포인트 (16 진 형식)를 제공하고 두 번째 열은 (유니 코드) 이름을 제공합니다. 세 번째 열은 문자와 일치하는 클래스를 나타냅니다 ( &lt;code&gt;\s&lt;/code&gt; 일치 를 변경하는 로케일이 없다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">표의 첫 번째 열은 속성의 이름입니다. 두 번째 열은 대체 이름 (있는 경우)과 주석 일 수 있습니다. 대체 이름은 첫 번째 열을 단순히 반복하지 않는 한 속성의 전체 이름입니다.이 경우 두 번째 열은 속성의 짧은 이름 (다른 경우)을 나타냅니다. 주석은 전체 이름의 항목에만 제공됩니다. 속성이 더 이상 사용되지 않는 경우 항목은 &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;위 섹션&lt;/a&gt; 의 표에서 사용 된 것과 같은 문자 ( 예 : &lt;b&gt;D&lt;/b&gt; 또는 &lt;b&gt;S)&lt;/b&gt; 로 플래그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">첫 번째 명령은 표준 출력과 표준 오류를 모두 임시 파일로 보냅니다. 두 번째 명령은 이전 표준 출력 만 전송하고 이전 표준 오류는 이전 표준 출력에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">@os_flavor의 첫 번째 요소는 주요 패밀리 (예 : Unix, Windows, VMS, OS / 2 등)이고 나머지는 하위 패밀리입니다.</target>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">첫 번째 예제는 CPAN :: Module 클래스의 오브젝트에 의해 구동되고 두 번째 예제는 CPAN :: Distribution 클래스의 오브젝트에 의해 구동됩니다.</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">첫 번째 확장명은 포함 된 주석 &lt;code&gt;(?#text)&lt;/code&gt; 입니다. 이것은 의미에 영향을주지 않으면 서 주석을 정규 표현식에 포함시킵니다. 주석은 텍스트에 닫는 괄호가 없어야합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">첫 번째 추가 명령어는 DJGPP의 FNCASE 환경 변수를 설정하여 XS 유형 모듈에 대해 빌드해야하는 새 perl 바이너리가 올바르게 빌드되도록합니다. 두 번째 추가 명령어는 &quot;make test&quot;를 실행하기 전에 모듈 디렉토리에 perl 바이너리를 다시 빌드하므로 &quot;make&quot;로 빌드 한 새 모듈 코드로 테스트합니다. 세 번째 추가 명령어는 모듈 디렉토리에서 perl 바이너리를 표준 DJGPP 바이너리 디렉토리 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 에 설치하여 이전 perl 바이너리를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">구조체의 처음 몇 멤버는 레이어의 호환성 검사 &quot;name&quot;, 인스턴스 별 데이터의 &lt;code&gt;malloc&lt;/code&gt; 크기 및 클래스의 속성 인 일부 플래그 (예 : 여부 등)에 대한 함수 테이블 크기를 제공합니다. 버퍼링 레이어), 다음 네 가지 기본 그룹에 속하는 기능을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">이들 중 처음 5 개는 이스케이프 시퀀스 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\F&lt;/code&gt; . 타이틀 케이스의 경우, 참조 &lt;a href=&quot;#Titlecase&quot;&gt;타이틀 케이스를&lt;/a&gt; ; Foldcase을 참조 &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">첫 번째 형태는 가장 중요합니다</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">첫 번째 양식은</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">첫 번째 양식은 CPAN에 분배 된 CHECKSUMS 파일에 저장된 저자의 CPAN 디렉토리 내부 및 아래에 모든 분배 파일을 나열합니다. 리스팅이 서브 디렉토리로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">첫 번째 함수는 &lt;code&gt;strlen&lt;/code&gt; 을 사용하여 추가 할 문자열의 길이를 계산합니다 . 두 번째에서는 문자열 길이를 직접 지정합니다. 세 번째 함수는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 같은 인수를 처리하고 형식화 된 출력을 추가합니다. 네 번째 함수는 &lt;code&gt;vsprintf&lt;/code&gt; 처럼 작동합니다 . va_list 인수 대신 SV 배열의 주소와 길이를 지정할 수 있습니다. 다섯 번째 기능은 첫 번째 SV에 저장된 문자열을 두 번째 SV에 저장된 문자열로 확장합니다. 또한 두 번째 SV가 문자열로 해석되도록합니다.</target>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">첫 번째 함수는 리터럴 문자열을 사용하고 두 번째 함수는 SV에 저장된 문자열을 사용합니다. 숨김은 해시 테이블이므로 &lt;code&gt;HV*&lt;/code&gt; 다시 얻습니다 . &lt;code&gt;flags&lt;/code&gt; 가 GV_ADD로 설정되어있는 경우 플래그는 새 패키지를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">첫 번째는 버킷 체인 길이에 대한 데이터를 제공하고 페치 * miss *가 얼마나 많은 작업을 수행하는지에 대한 통찰력을 제공합니다. 이 경우 항목이 목록에 없는지 확인하기 전에 버킷의 모든 항목을 검사해야합니다. 항목이 해시에없는 삭제와 마찬가지로 삽입 성능도이 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">첫 번째 인터페이스는 객체 접근입니다. &lt;code&gt;IO::Dir&lt;/code&gt; 은 펄의 내장 디렉토리 읽기 루틴을 감싸는 래퍼 인 객체 생성자와 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">첫 번째는 0 개 이상의 문자 시퀀스와 일치 하는 별표 &lt;code&gt;*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">첫 번째는 '*'메타 문자입니다. 이것은 입력 파일 글로브와 일치하는 완전한 파일 이름으로 대체됩니다. 그래서</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">첫 번째는 '기본'형식이며 기본 및 실행 모드에서 모든 opcode를 인쇄하는 데 사용됩니다. 두 번째 goto-format은 분기가 발생할 때 실행 모드에서 사용됩니다. 실제 opcode가 아니며 닫는 중괄호처럼 보이도록 삽입됩니다. 트리 형식은 트리마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">첫 번째 줄 (색인 [0] 포함)은 코드 포인트 0의 값이 &quot;기본 라틴어&quot;임을 의미합니다. 두 번째 줄의 @blocks_ranges 열에서 &quot;0x0080&quot;항목은 첫 번째 줄 &quot;Basic Latin&quot;의 값이 0에서 0x0080까지, 즉 127까지의 모든 코드 포인트까지 확장됨을 의미합니다. 즉, 0에서 127까지의 코드 포인트는 모두 &quot;기본 라틴어&quot;블록에 있습니다. 마찬가지로, 등 &quot;라틴 -1 보충&quot;라는 이름의 블록에있는 0x0100은 0x0080까지의 (포함되지하지만)의 범위에있는 모든 코드 포인트 (공지 반환은 이전 스타일 블록 이름이라고는; 참조 &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;대 이전 스타일을 새로운 스타일의 블록 이름&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">위의 첫 번째 행은 &lt;code&gt;TIMESTAMP&lt;/code&gt; 를 9 개의 요소 목록으로 정의 하며, 목록 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 에 의해 리턴됩니다 . 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 리턴 한 문자열로 설정하려면 명시 적 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 키워드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">첫 번째 행은 인수 스펙의 오류가 조기에 발견되도록합니다. 응용 프로그램을 배송 할 때 첫 번째 줄은 주석 처리해야합니다. 두 번째 줄은 쓸모가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">여기서 첫 번째 행은 오프셋 / 길이 테이블에 45 개의 항목이 포함되어 있음을 나타냅니다. 각 항목은 &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; 로 표시된 정수 쌍입니다 . 항목은 1부터 시작하여 번호가 매겨 지므로 여기서 # 1 항목은 &lt;code&gt;1[4]&lt;/code&gt; 이고 항목 # 12는 &lt;code&gt;5[1]&lt;/code&gt; 입니다. &lt;code&gt;1[4]&lt;/code&gt; 는 레이블이 &lt;code&gt;1:&lt;/code&gt; ( &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ) 인 노드 가 사전 컴파일 된 정규식의 문자 위치 1에서 시작하며 길이가 4 자임을 나타냅니다 . 위치 12의 &lt;code&gt;5[1]&lt;/code&gt; 은 레이블이 &lt;code&gt;12:&lt;/code&gt; ( &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ) 인 노드 가 사전 컴파일 된 정규식의 문자 위치 5에서 시작하며 길이는 1 자임을 나타냅니다. &lt;code&gt;12[1]&lt;/code&gt; 위치 14의 12 [1] 은 &lt;code&gt;14:&lt;/code&gt; 레이블이 지정된 노드 ( &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; )가 사전 컴파일 된 정규식의 문자 위치 12에서 시작하며 길이는 1 자임을 나타냅니다 . --- 즉 , 사전 컴파일 된 정규식 의 &lt;code&gt;+&lt;/code&gt; 기호에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">첫 번째 줄은 불필요한 배열 변수 &lt;code&gt;@array&lt;/code&gt; 를 만들지 않는다는 점을 제외하고 다음 두 줄의 줄임말 입니다.</target>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">커밋 메시지의 첫 번째 줄은 마침표가없는 간단한 설명이어야합니다. 전자 메일의 제목 줄보다 길어서는 안됩니다 (50 자 정도).</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">첫 번째 줄은 미리 컴파일 된 형식의 정규식을 보여줍니다. 두 번째는 컴파일 된 폼의 크기 (임의의 단위, 보통 4 바이트 워드)와 오프셋 / 길이 테이블에 할당 된 총 바이트 수 (보통 4+ &lt;code&gt;size&lt;/code&gt; * 8)를 보여줍니다. 다음 줄은 라벨을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">첫 번째 방법은 CPU 프로그램 카운터의 샘플을 주기적으로 가져 오며, 프로그램 카운터는 함수에 대해 생성 된 코드와 상관 될 수 있으므로 프로그램이 어떤 함수를 사용하고 있는지 통계적으로 볼 수 있습니다. 매우 작은 / 빠른 기능은 프로파일에 나타날 확률이 낮으며 주기적으로 프로그램을 중단 (일반적으로 밀리 초 단위로 다소 자주 수행됨)하여 결과를 왜곡시킬 수있는 추가 오버 헤드가 발생한다는 점에주의해야합니다. 첫 번째 문제는 코드를 더 오랫동안 실행하여 완화 할 수 있으며 (일반적으로 이것은 프로파일 링에 대한 좋은 아이디어입니다) 두 번째 문제는 일반적으로 프로파일 링 도구 자체에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">이름은</target>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">사용 가능한 세 가지 기술 중 첫 번째는 C로 필터를 완전히 작성하는 것입니다. 외부 모듈은 Perl에서 제공하는 소스 필터 후크와 직접 인터페이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">이들 중 첫 번째는 오버로드 된 연산자 구현을 제공하는 피연산자입니다.이 경우 &lt;code&gt;minus()&lt;/code&gt; 메서드가 호출되는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">이 두 함수 중 첫 번째 함수는 해시 테이블 항목이 있는지 확인하고 두 번째 함수는 해시 테이블 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">첫 번째 것은 컨텍스트에서 명시 적으로 전달되며, 예를 들어 스레드 빌드에 필요합니다. 두 번째는 암묵적으로 그렇게합니다. 혼합하지 마십시오. aTHX_를 전달하지 않으면 함수에서 첫 번째로 dTHX (또는 dVAR)를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째는 &lt;code&gt;&quot;format&quot;&lt;/code&gt; 입니다 . 이것은 복소수의 두 숫자 부분에 사용되는 sprintf () 스타일 형식 문자열입니다. 다소 시스템에 따라 다르지만 가장 자주 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; 해당합니다 . &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하여 기본값으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">첫 번째는 Perl 5.22의 B :: PADNAMELIST이고 이전 버전의 B :: AV입니다. 나머지는 현재 B :: AV 개체이지만 이후 버전에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">&lt;code&gt;globmap&lt;/code&gt; 의 첫 번째 매개 변수 인 &lt;code&gt;*.tar.gz&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">각 항목의 첫 번째 부분은 {...} 사이의 언어 태그입니다. 그 뒤에 언어 또는 언어 그룹의 영어 이름이옵니다. 일반적으로 사용하지 않는 언어 태그는 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">보고서의 첫 부분에는 이미 어떤 서브 루틴을 가장 많이 사용하는지에 대한 중요한 정보가 표시되어 있습니다. 다음은 프로파일 링 된 소스 파일에 대한 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">첫 번째 단계는 인용 된 구문의 끝을 찾는 것입니다. 따라서 원본 구분 기호가 무엇인지 알 필요가 없도록 정규화 된 시작 및 끝 구분 기호 사이의 텍스트 복사본을 안전한 위치에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">첫 번째 수량 자 '. *'는 전체 문자열 '모자에있는 고양이'를 일치시켜 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 정규식 일치를 유지하면서 가능한 한 많은 문자열을 가져옵니다. 두 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 에는 문자열이 없으므로 0 번 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">첫 번째 이유는이 기술이</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">정규 표현식 은 대소 문자를 구분하므로 첫 번째 정규 표현식 &lt;code&gt;world&lt;/code&gt; 는 일치하지 않습니다. 문자열 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 에서 하위 문자열 &lt;code&gt;'o W'&lt;/code&gt; 가 발생 하기 때문에 두 번째 정규 표현식이 일치 합니다 . 공백 문자 ''는 정규 표현식에서 다른 문자와 같이 취급되며이 경우 일치해야합니다. 공백 문자가 없기 때문에 세 번째 정규 표현식 &lt;code&gt;'oW'&lt;/code&gt; 가 일치하지 않습니다. 네 번째 정규 표현식 &lt;code&gt;'World '&lt;/code&gt; 는 정규 표현식 의 끝에 공백이 있지만 문자열의 끝에는 없기 때문에 일치하지 않습니다. 여기서 교훈은 정규 표현식이 문자열의 일부와 일치해야한다는 것입니다</target>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">문자열이 &lt;code&gt;keep&lt;/code&gt; 보다 많기 때문에 첫 번째 정규 표현식이 일치하지 않습니다 . 두 번째 정규 표현식은 정확히 문자열이므로 일치합니다. 정규 표현식에서 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 를 모두 사용 하면 전체 문자열이 일치하므로 일치하는 문자열과 일치하지 않는 문자열을 완벽하게 제어 할 수 있습니다. bert라는 이름의 동료를 찾고 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">첫 번째는 두 해시 모두 동일한 데이터를 포함하고 두 번째는 그렇지 않은 것으로보고합니다. 당신이 선호하는 것은 독자에게 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">첫 번째 섹션에서는 1003.1 사양의 POSIX 기능에 대해 설명합니다. 두 번째 섹션에서는 신호 객체, TTY 객체 및 기타 기타 객체에 대한 클래스를 설명합니다. 나머지 섹션에는 IEEE Std 1003.1b-1993을 따르는 조직의 다양한 상수 및 매크로가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">첫 번째 섹션은 다양한 C 데이터 유형을 이름에 맵핑하는데, ​​이는 다양한 Perl 유형과 다소 일치합니다. 두 번째 섹션에는 &lt;b&gt;xsubpp&lt;/b&gt; 가 입력 매개 변수를 처리 하는 데 사용 하는 C 코드가 포함되어 있습니다 . 세 번째 섹션에는 &lt;b&gt;xsubpp&lt;/b&gt; 가 출력 매개 변수를 처리 하는 데 사용 하는 C 코드가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">이 문서의 첫 번째 섹션은 항목 별 체크리스트를 제공합니다. 다음 섹션에서는 목록에있는 항목에 대한 자세한 설명을 제공합니다. 마지막 섹션 인 &quot;일반적인 함정&quot;은 CPAN 작성자가 가장 많이 저지른 실수 중 일부를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">첫 번째 통계 세트는 &quot;Good&quot;, &quot;Poor&quot;및 &quot;Bad&quot;로 변환 된 품질 점수 (점수 &amp;lt;= 1.05, 점수 &amp;lt;= 1.2, 점수&amp;gt; 1.2)를 포함하여 몇 가지 요약 통계 정보를 제공합니다. 자세한 내용은 bucket_stats ()의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">첫 번째 상황이 훨씬 더 자주 발생하므로 상용구를 다음과 같이 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">첫 번째 상태는 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 및 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러 에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">첫 번째 단계는 다음 줄을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">이러한 행을 처리하는 첫 번째 단계는 16 진 데이터를 2 진으로 변환하여 체크섬을 확인하면서 4 개의 필드를 얻는 것입니다. 놀랍지 않습니다. 모든 것을 이진으로 변환 하는 간단한 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 호출로 시작할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">이 정규 표현식과 일치하는 첫 번째 문자열 위치 는 &lt;code&gt;programming&lt;/code&gt; 의 첫 번째 &lt;code&gt;'m'&lt;/code&gt; 입니다 . 이 위치에서 최소 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; 하나의 &lt;code&gt;'m'&lt;/code&gt; 과 일치합니다 . 두 번째 수량자는 &lt;code&gt;.*?&lt;/code&gt; 문자와 일치하지 않는 것을 선호한다면 문자열의 끝 앵커 &lt;code&gt;$&lt;/code&gt; 에 의해 제한되어 나머지 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">정규 표현식을 작성하는 첫 번째 작업은 일치시킬 항목과 제외 할 대상을 결정하는 것입니다. 이 경우 정수와 부동 소수점 숫자를 모두 일치시키고 숫자가 아닌 문자열을 거부하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">이 &quot;= over&quot;... &quot;= back&quot;영역에 항목이 전혀없는 경우가 아니라면 &quot;= over&quot;명령 다음에 나오는 첫 번째 항목은 &quot;= item&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">첫 번째 스레드는 &lt;code&gt;$x&lt;/code&gt; 에서 잠금을 잡은 다음 두 번째 스레드가 약간의 작업을 수행 할 시간이있는 일시 정지 후에 &lt;code&gt;$y&lt;/code&gt; 에서 잠금을 잡으려고 시도합니다 . 한편 두 번째 스레드는 &lt;code&gt;$y&lt;/code&gt; 에서 잠금을 잡고 나중에 &lt;code&gt;$x&lt;/code&gt; 에서 잠금을 잡으려고 시도합니다 . 두 스레드에 대한 두 번째 잠금 시도가 차단되며 각 스레드는 다른 스레드가 잠금을 해제 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">루프를 처음으로 수행하면 줄 0부터 끝까지 전체 파일을 다시 작성합니다. 루프를 두 번째로 수행하면 줄 1부터 끝까지 전체 파일을 다시 씁니다. 루프를 통해 세 번째로 전체 파일을 2 행에서 끝까지 다시 작성합니다. 등등.</target>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">처음 두 필드는 sbrk (2) ed (ess-broken? :-)의 총 메모리 양과 사용 된 sbrk (2)의 수를 나타냅니다. 세 번째 숫자는 펄이 리턴 된 청크의 연속성에 대해 생각하는 것입니다. 이 숫자가 양수인 한 malloc ()은 sbrk (2)가 연속 메모리를 제공 할 가능성이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">첫 번째 두 가지 형태로 반환 &lt;b&gt;진정한&lt;/b&gt; 경우 생성 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수가&lt;/a&gt; 구성 정상화 발생하지 않음. 마지막 두 형식이 &lt;b&gt;true&lt;/b&gt; 를 반환 하려면 유니 코드 데이터베이스에서이 사실을 판별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">출력 문자열에서 대체 될 첫 번째 값 (일반적으로 커서 주소 지정 기능의 열)</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">명시적인 버전 번호를 포함하는 첫 번째 TAP 버전은 13입니다.</target>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">이 문서의 첫 번째 버전은 여러 사람들이 유용한 제안을 한 Perl Monks에 게재되었습니다. 감사합니다, 펄 몽크 스</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">간접 객체가없는 첫 번째 버전은</target>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">완전 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">완전 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">my ()가 실행될 때마다 어휘에서 SVs_PADSTALE 플래그가 지워지고 범위 종료시 설정됩니다. 이를 통해 다음과 같은 evals에서 'Variable $ x is not available'경고가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR 및 UTF8_WARN_SUPER 플래그는 해당 범주에 대해 경고 메시지가 발생하지만 그렇지 않으면 코드 포인트가 유효한 것으로 간주됩니다 (기형이 아님). 카테고리를 기형으로 취급하고 경고를 발생 시키려면 WARN 및 DISALLOW 플래그를 모두 지정하십시오. (단, 사 전적으로 사용하지 않거나 UTF8_CHECK_ONLY도 지정하면 경고가 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">다른 것을 원하면 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 을 사용 하거나 POSIX :: SigRt에서 파생하여 자신 만의 &lt;code&gt;new()&lt;/code&gt; (연결된 해시 STORE 메소드를 정의 할 수 있음 ) &lt;code&gt;%SIGRT&lt;/code&gt; 는 &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; . 여기서 &lt;code&gt;$rtsig&lt;/code&gt; 범위는 0에서 &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">flags 매개 변수는 필수입니다. 유효한 플래그 값은 R_CURSOR, R_FIRST, R_LAST, R_NEXT 및 R_PREV입니다.</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">플래그는 사전 순서와 대소 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">맛</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">부동 소수점 무한대는 서브 루틴 Inf ()로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">모듈 개발자 만 볼 수있는 부분보다는 모듈 사용자에게 표시되는 스타일 요소에 중점을 둡니다. 그러나이 문서에 제시된 많은 지침을 외삽하여 모듈 내부에 성공적으로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">이 API의 클라이언트는 다음 &quot;공용&quot;전역 이름을 읽을 수 있습니다. 이것들은 &quot;읽기 전용&quot;으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">클라이언트가 다음 &quot;가상&quot;메소드를 정의 할 수 있습니다. 적절한 시점에 API에 의해 호출됩니다. 달리 지정하지 않는 한 디버그 API는 이러한 메소드의 비어 있고 작동하지 않는 기본 버전 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">다음은 % HASH 및 @ARRAY의 모든 값을 비효율적으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">다음 API 목록에는 함수가 포함되어 있으므로 수정 가능한 데이터에 대한 포인터를 명시 적으로 제공해야합니다 (C 포인터 또는 Perlish &lt;code&gt;GV *&lt;/code&gt; s). 위의 매크로가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 를 사용하는 경우 비슷한 함수가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">다음 API는 현재 구현에서 Perl 내부의 일부를 사용합니다. 따라서 효율적이지만 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">다음 NNTP 명령은 패키지에서 지원되지 않으므로 그렇게 할 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">다음 RFC959 명령이 구현되지 않았습니다 :</target>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">다음 VMS 특정 정보는 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 의 일반 정보 외에도 표시된 &quot;특별한&quot;Perl 변수에 적용 됩니다. 충돌이있는 경우이 정보가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">다음과 같은 Win32 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">다음 XS 코드는 ONC + TIRPC와 함께 사용되는 getnetconfigent () 함수를 보여줍니다. getnetconfigent () 함수는 C 구조에 대한 포인터를 리턴하며 아래에 표시된 C 프로토 타입을 갖습니다. 이 예제는 C 포인터가 Perl 참조가되는 방법을 보여줍니다. 펄은이 참조를 복된 대상에 대한 포인터라고 생각하고 대상에 대한 소멸자를 호출하려고 시도합니다. XS 소스에 소멸자가 제공되어 getnetconfigent ()가 사용하는 메모리를 비 웁니다. 이름이 &lt;b&gt;DESTROY로&lt;/b&gt; 끝나는 XSUB 함수를 지정하여 XS의 소멸자를 작성할 수 있습니다 . XS 소멸자를 사용하여 다른 XSUB에서 malloc 한 메모리를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">다음 XS 파일은 rpcb_gettime () 함수에 대한 가능한 인터페이스를 보여주는 XS 서브 루틴 또는 XSUB를 보여줍니다. 이 XSUB는 C와 Perl 간의 직접 변환을 나타내므로 Perl에서도 인터페이스를 유지합니다. 이 XSUB는 위에 표시된 사용법으로 Perl에서 호출됩니다. &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; 및 &lt;code&gt;XSUB.h&lt;/code&gt; 에 대한 처음 세 개의 #include 문 은 항상 XS 파일의 시작 부분에 있습니다. 이 방법과 다른 방법은이 문서의 뒷부분에서 확장 될 것입니다. 인터프리터 컨텍스트를보다 효율적으로 가져 오려면 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 에 #define이 있어야합니다 . 자세한 내용 은 &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">다음 XSUB를 사용하면 Perl 프로그램이 sin ()이라는 C 라이브러리 함수에 액세스 할 수 있습니다. XSUB는 단일 인수를 사용하고 단일 값을 반환하는 C 함수를 모방합니다.</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">다음 XSUB는 매개 변수를 특수하게 처리해야하는 C 함수용입니다. Perl 사용법이 먼저 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">다음 XSUB는 &lt;code&gt;SV *&lt;/code&gt; 리턴 유형을 니모닉으로 만 사용하고 CODE : 블록을 사용하여 프로그래머가 필요한 모든 코드를 제공했음을 컴파일러에 표시합니다. sv_newmortal () 호출은 반환 값을 undef로 초기화하여 기본 반환 값으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">다음 XSUB는 C rpcb_gettime () 함수를 호출하고 두 개의 출력 값인 timep 및 status를 Perl에 단일 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">다음 XSUB는 잘못된 C 코드를 생성합니다. &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러는 호출하는 코드로이 켜집니다 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 매개 변수 &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; 하지만, 실제 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 원하는 &lt;code&gt;timep&lt;/code&gt; 의 매개 변수 타입의 수 &lt;code&gt;time_t*&lt;/code&gt; 보다는 &lt;code&gt;time_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">다음은 Perl을 지원하는 Win32 다국어 편집기 / IDE입니다.</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">다음은 요청 된 추가 사항이지만 펄에서 구현하기가 매우 간단하여 추가를 꺼려했습니다.</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">다음은 모든 접근 자 메서드입니다. 즉, 자체적으로 작업을 수행하지 않고이 특정 일괄 변환에 대한 옵션을 포함하는 변환 개체의 내용 만 변경하면됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">다음은 POSIX / SUSv3에서도 정의되지만 불행히도 널리 구현되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">다음은 컴파일 및 / 또는 실행 실패의 일반적인 원인이며 Perl에는 일반적이지 않습니다. C FAQ는 취침 시간이 좋습니다. 가능한 한 많은 C 컴파일러와 플랫폼으로 변경 사항을 테스트하십시오. 어쨌든 우리는 공개적인 당황에서 자신을 구하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">다음이 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">다음은 ISO 8859-1 (Latin-1) 바이트에서 UTF-8 바이트로의 빠른 변환 및 그 이전 코드이며, 이전 Perl 5 버전에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">다음은 DB 기본 클래스의 메소드입니다. API는 상속 메커니즘을 통해 클라이언트를 추적하므로 클라이언트는 상속을 통해 이러한 메소드에 액세스해야합니다 (* 직접 호출하지 않음).</target>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">다음은 그러한 인터페이스입니다. 또한 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그를&lt;/a&gt; 참조하십시오 . 이러한 모든 인터페이스에서 Perl은 현재 (v5.16.0 기준) 바이트 문자열을 인수 및 결과 또는 (더 이상 사용되지 않는) &lt;code&gt;encoding&lt;/code&gt; pragma가 사용 된 경우 UTF-8 문자열로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">다음은 서브 루틴의 내장 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">다음은 변수에 내장 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">다음은 유효합니다 ($ t1 및 $ t2는 Time :: Piece 객체 임).</target>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">다음 속성은 WriteMakefile ()에 대한 인수 또는 명령 행에서 NAME = VALUE 쌍으로 지정 될 수 있습니다. 이후 버전의 MakeMaker에서 사용할 수있는 속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">다음 블록은 다소 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">다음 부울 메소드는 다음을 판별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">이 모듈에서 다음 bzip2 상수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">현재 다음 점검이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">다음 코드는 함수 매개 변수에 초기화 코드를 제공하는 방법을 보여줍니다. 초기화 코드는 출력에 추가되기 전에 컴파일러에서 큰 따옴표 안에 평가되므로 문자 그대로 [주로 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;\\&lt;/code&gt; ] 로 해석 해야하는 것은 백 슬래시로 보호해야합니다. 변수 &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; 및 &lt;code&gt;$type&lt;/code&gt; 은 typemaps에서와 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">다음 코드는 모든 출력을 출력 바이트의 16 진수 덤프로 변환하는 출력 핸들을 엽니 다. 예를 들어 &quot;A&quot;는 &quot;41&quot;로 변환됩니다 (ASCII 기반 시스템의 경우 EBCDIC 플랫폼에서 &quot;A&quot;는 &quot;c1&quot;)</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">다음 코드는 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; 이라는 ASCII 문자열을 작성합니다 . 주석은 각 단계 후 문자열을 보여줍니다. 이 코드는 big-endian 또는 little-endian 시스템에서 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">다음 코드는 단일 레벨 배열에서 작동합니다. 문자열 비교를 사용하며 정의 된 빈 문자열과 정의되지 않은 빈 문자열을 구별하지 않습니다. 다른 요구 사항이 있으면 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">다음 데이터 정렬은 모두 의미가 있으며 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 하는 경우 &quot;를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">다음과 같은 명령 문자가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">다음 명령 행 스위치는 VMS에서 &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 설명 된 것과 다르게 작동합니다 . CRTL이 인용되지 않은 모든 문자열을 다운 케이스하기 때문에 대문자 스위치를 Perl에 전달하려면 명령 행에서 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">다음 명령은 NIST 테스트 벡터 &quot;abc&quot;와 같은 일반적인 입력에 대한 다이제스트를 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">다음 컴파일 경고는 11.31 이전의 HP-UX 릴리즈에서 발생할 수 있지만 무해합니다.</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">다음 컴파일러 버전은 현재 IBM에서 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">다음의 복합 명령문을 사용하여 흐름을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">getaddrinfo () 또는 getnameinfo ()에 의해 다음 상수가 리턴 될 수 있습니다. 다른 것들은 OS에 의해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">다음 상수는 $ xflags로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">다음 디버거가 실제로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">다음과 같은 방법 설명은 아직 개발 중입니다. 적절하게 문서화되지 않은 섹션은 코드를 참조하고 makemaker@perl.org 메일 링리스트에 큰 소리로 불평하십시오. 더 나은 패치를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">다음 문서는 치명적 경고를 사용하는 방법을 설명하지만 perl5 포터는 다운 스트림 사용자가 치명적인 범주의 선택을 변경할 수있는 방법이 없기 때문에 특히 다른 사람이 사용할 라이브러리 코드에 대한 위험을 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">다음은 비트 벡터에서 설정된 비트 수를 효율적으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">다음 항목은 libnet 패키지에서 설치 및 테스트 중에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">다음 환경 변수는 Perl에만 해당되지 않습니다 . 데이터에 대한 애플리케이션의 의견을 제어하기위한 표준화 된 (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; 메소드의 일부입니다. Windows는 POSIX가 아니지만 Perl은 다음과 같이 설명합니다. 환경 변수에 의해 주어진 로케일이 유효하지 않으면, Perl은 우선 순위가 낮은 다음 로케일을 시도합니다. 유효하지 않은 경우 Windows에서 시스템 기본 로케일이 시도됩니다. 다른 모든 방법이 실패하면 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로캘이 사용됩니다. 그래도 작동하지 않으면 무언가가 잘못되었지만 Perl은 로케일 설정에 관계없이 앞서 나 가려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">다음과 같은 동등성 ( &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; 가정 )</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">다음 오류 처리 메커니즘은 실험적인 것으로 간주되며 사용자의 보류중인 피드백에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;_LONG_DOUBLE&lt;/code&gt; 의 Cygwin &lt;code&gt;#define&lt;/code&gt; 으로 인해 다음 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">보간하는 구문과 음역에서 다음 이스케이프 시퀀스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">다음 이스케이프 시퀀스는 음역에서는 보간하지 않는 구성에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">다음 예 는 &lt;code&gt;expect&lt;/code&gt; 대신 사용될 수있는 &lt;code&gt;eexpect&lt;/code&gt; 를 제외하고 지원되는 모든 키워드 및 구조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">다음 예제는 패턴에서 가능한 일치하는 모든 문자열을 계산합니다 (실제로 일치하지는 않음).</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">다음 예는 &lt;code&gt;SIGHUP&lt;/code&gt; 신호가 수신 될 때마다 자체 재시작되는 간단한 데몬을 구현합니다 . 실제 코드는 서브 루틴 &lt;code&gt;code()&lt;/code&gt; 에 있으며 디버깅 정보를 인쇄하여 작동한다는 것을 보여줍니다. 실제 코드로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">다음 예제는 rpcb_gettime () 함수의 변형을 보여줍니다. 이 함수는 timep 변수를 출력 변수로만 사용하며 초기 내용은 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">다음 예는 PREINIT 후 입력 매개 변수 &lt;code&gt;timep&lt;/code&gt; 를 늦게 평가 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">다음 예제는 이 함수에 대한 별명 &lt;code&gt;FOO::gettime()&lt;/code&gt; 및 &lt;code&gt;BAR::getit()&lt;/code&gt; 를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">다음 예제는 &lt;code&gt;langinfo()&lt;/code&gt; 함수 자체와 &lt;code&gt;langinfo()&lt;/code&gt; 대한 인수로 사용할 세 개의 상수를 가져옵니다. 약식 첫 요일에 대한 상수 (일요일 번호는 일요일 = 1에서 시작 함) 및 긍정에 대한 두 개의 상수 현재 로케일의 예 / 아니오에 대한 부정적인 답변.</target>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">다음 예는 langinfo () 함수 자체와 langinfo ()에 대한 인수로 사용할 세 개의 상수를 가져옵니다. 약식 첫 요일에 대한 상수 (일요일 번호는 일요일 = 1에서 시작) 및 긍정에 대한 두 개의 상수 현재 로케일의 예 / 아니오에 대한 부정적인 답변.</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">다음 예제는 XS 코드를 시작하고 RPC라는 패키지에 모든 기능을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">다음 예제 는 모두이 모듈에서 다른 목록 축소 기능을 구현하기 &lt;code&gt;reduce&lt;/code&gt; 사용 하는 방법을 보여줍니다 . (실제로는 이와 같이 구현되지 않고 개별 C 함수에서보다 효율적인 방식으로 구현됩니다).</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">다음 예제는 동일하지만 코드가 복잡한 유형 맵을 사용하는 경우 첫 번째 예제가 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">다음 예제는 가정</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">다음 예제는 모든 작업을 기념비적 인 작업으로 보여 주려고하지 않으며 솔직히이 맨 페이지가 Perl의 내부 문서가되기를 원하지 않습니다. 이 예제는 원시 Perl 데이터 유형의 몇 가지 기본 사항을 보여 주며 대부분의 결정된 사람들이 길을 가기에 충분합니다. 가이드 와이어 나 안전망도없고 뾰족한 길도 없으므로이 시점부터 혼자 여행 할 수 있도록 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">다음 확장 계층은 perl과 함께 번들로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">실수와 복소수 모두에서 다음과 같은 추가 연산이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">다음과 같은 기능 번들을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">다음 파일은 런타임과 컴파일 타임에 약간의 오류를 유발할 것입니다.</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">다음과 같은 파일이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">다음 플래그 상수는 $ flags로 인식됩니다. OS가 제공하는 다른 플래그 상수가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">다음 플래그 상수는 $ hints 해시에서 인식됩니다. OS가 제공하는 다른 플래그 상수가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">csh 호환성을 위해 Perl 구현에 다음 플래그가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">다음 깃발은 좋을 것이지만 먼저 자신의 Augean 안정 마스터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">다음 네 파일은 지금까지 설명한 모든 세부 정보를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 함수는 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV에 문자열을 복사합니다 . Perl이 문자열 길이를 계산할 수 있도록 length를 0으로 설정하십시오. &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">다음 함수는 포인터 값을 복사합니다 (</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">다음 기능은 ODS-5 형식의 빌드 디스크에서 하드 링크가 활성화 된 64 비트 OpenVMS v8.2에서 빌드 된 Perls에서 사용할 수 있습니다. CRTL 지원은 기본적으로 OpenVMS v7.3-1부터 제공되며 더 나은 구성 지원으로이를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">다음 함수는 SV가 축복 된 객체에 대한 참조인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">다음 함수는 SV가 지정된 클래스에 축복이 있는지 테스트합니다. 상속 관계는 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">다음 함수는 SV가 지정된 클래스에서 파생되는지 테스트합니다. SV는 축복 된 객체에 대한 참조이거나 클래스 이름을 포함하는 문자열 일 수 있습니다. &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; 기능을 구현하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">다음 함수는 rv를 아직 업그레이드하지 않은 경우 참조로 업그레이드합니다. rv가 가리킬 새 SV를 만듭니다. &lt;code&gt;classname&lt;/code&gt; 이 널이 아닌 경우 SV는 지정된 클래스에 축복됩니다. SV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">다음과 같은 기능</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">다음 함수는 모두 참조 값에서 유용한 활동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">다음 함수는 임시 파일 생성 시스템 호출의 mktemp () 제품군의 Perl 구현입니다.</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">64 비트 OpenVMS v8.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">64 비트 OpenVMS v8.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다. CRTL 지원은 기본적으로 OpenVMS v7.3-2부터 제공되며 더 나은 구성 지원으로이를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">VMS 7.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">Dec C 5.2 이상으로 컴파일되고 VMS 7.0 이상을 실행하는 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">다음과 같은 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">다음 기능은 현재 문서화되어 있지 않습니다. 그중 하나를 사용하는 경우 문서를 작성하고 제출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">다음 기능은 &lt;code&gt;utf8::&lt;/code&gt; 패키지에서 Perl 코어 로 정의됩니다 . 이것들을 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 을 사용할 필요는 없으며 실제로 UTF-8 소스 코드를 원하지 않는다면 말하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Filter::Util::Call&lt;/code&gt; 의해 다음 기능이 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">다음 기능이 기본적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">이 모듈에서 다음 기능을 내 보냅니다. 따라서 이러한 기능 (하지 방법) 참고주세요 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; 암시 첫 번째 인수를 취할.</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">이 모듈은 &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; 및 &lt;code&gt;cond_broadcast&lt;/code&gt; 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">다음 기능은 요청에 의해서만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">다음 함수는 이제 FastCalc.xs에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">다음 기능은 &lt;code&gt;Digest::MD5&lt;/code&gt; 모듈 에서 제공 합니다. 기본적으로 이러한 기능 중 어느 것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">다음과 같은 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">다음과 같은 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">이 모듈에서 다음 기능을 가져올 수 있습니다. 기본적으로 함수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">다음 함수는 문자열이 해당 정규화 형식인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">다음 함수는 Perl 값 목록과 구조를 나타내는 팩형 이진 문자열 사이를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">다음 함수는 공개 API의 일부로 플래그가 지정되었지만 현재 문서화되어 있지 않습니다. 인터페이스는 변경 될 수 있으므로 위험에 따라 사용하십시오. 이 문서에 나열되지 않은 기능은 공용으로 사용되지 않으며 어떤 상황에서도 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">Perl 사본에 내장 된 소켓 지원 유형에 따라 다음 기능이 구현되거나 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">다음 함수는 &lt;code&gt;$_&lt;/code&gt; 를 기본 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">다음 함수는 VMS 포트에서 구현되지 않았으며이를 호출하면 치명적 오류 (보통) 또는 정의되지 않은 동작 (드물게 희망)이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">다음 함수는 모두 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">다음과 같은 전역 변수가 경기장과 관련되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">다음은 벤치 마크 객체 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">다음 정보는 gcc 버전 2에 적용됩니다. gcc 버전 3에 맞게 적절하게 업데이트하는 자원 봉사자에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">기존 API와의 호환성을 위해 다음 인터페이스가 제공됩니다. 그것들은 새로운 코드에서 사용되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">다음은 포드 처리와 관련된 기타 요구 사항 및 제안의 긴 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">다음은이 C ++ 예제에 사용할 수있는 유형 맵의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">다음은 Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;의 오래된 c2ph.doc 문서입니다. 날짜 : 25 Jul 91 08:10:21 GMT</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">다음은 특정 버전의 Perl &lt;a href=&quot;deprecate&quot;&gt;이상으로&lt;/a&gt; 코어 모듈 을 폐기 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">콜백에 다음 키가 허용되었습니다. 이 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">다음 키는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">옵션 해시에서 다음 키가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">해시 참조 $ CPAN :: Config의 다음 키가 현재 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">현재 다음 레이어가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Map&lt;/a&gt; 의 testsuite에서 다음 행을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">다음 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">다음 정규식에 대한 유니 코드 지원 기능 목록은 코어 Perl에서 현재 직접 지원하는 모든 기능을 설명합니다. &quot;레벨 N&quot;및 섹션 번호는 2008 년 8 월부터 유니 코드 기술 표준 # 18, &quot;유니 코드 정규 표현식&quot;, 버전 13을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">해시 항목의 내용에 액세스하려면 항상 다음 매크로를 사용해야합니다. 이 매크로에 대한 인수는 두 번 이상 평가 될 수 있으므로 간단한 변수 여야합니다. 이 매크로에 대한 자세한 설명은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">다음 메소드는 모두 부울 값을 리턴하며 해당 서브 클래스에서 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">모든 &lt;code&gt;Digest::&lt;/code&gt; 모듈에 대해 다음 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">다음과 같은 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="translated">다음 방법은 파일 핸들별로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="translated">다음 메소드는 &lt;code&gt;TAP::Harness&lt;/code&gt; 를 서브 클래스하려는 경우 대체 할 수있는 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="translated">다음 방법은 선택 사항이며 기본 lib에 빠른 방법이있는 경우 정의 할 수 있습니다. 정의되지 않은 경우 Math :: BigInt는 순수한 Perl (따라서 느린) 폴백 루틴을 사용하여 다음을 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="translated">이 모듈에는 다음과 같은 방법이 제공됩니다. 각각은 객체 자체에 대한 참조를 암시 적 첫 번째 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="translated">다음과 같은 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="translated">2 이상의 API 버전에는 다음 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">다음 메소드는 perl에 내장 된 디렉토리 관련 기능에 대한 랩퍼입니다 (후행 'dir'은 이름에서 제거되었습니다). 이 기능에 대한 자세한 내용은 &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="translated">다음 방법을 사용하여 대기열의 어느 곳에서나 항목을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="translated">다음 두 방법을 사용하여 두 원격 서버간에 파일을 전송하여이 두 서버를 서로 직접 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="translated">다음 메소드는 호출 방식에 따라 다른 결과를 리턴 할 수 있습니다. 사용자가 명시 적으로 &lt;code&gt;pasv&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 메소드 중 하나를 호출하면 이 메소드는</target>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="translated">그런 다음 위의 생성자가 반환 한 구획 객체에서 다음 방법을 사용할 수 있습니다. 개체 인수는 각 경우에 암시 적입니다.</target>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="translated">다음 방법은 FIFO를 기준으로 큐를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="translated">Math :: BigInt v1.70 이상에서 사용할 수 있도록 다음 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="translated">다음 방법은 무조건 업그레이드됩니다. 즉, 업그레이드가 적용되는 경우 항상 작업을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="translated">다음 모듈은 현재 bigint에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="translated">다음 모듈은 현재 bignum에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="translated">다음 이름은 Perl에 특별한 의미가 있습니다. 대부분의 문장 부호 이름에는 적절한 니모닉 또는 쉘의 유사체가 있습니다. 그럼에도 불구하고 긴 변수 이름을 사용하려면 다음과 같이 말하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">다음 옵션은 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 명령 에서 발생하는 영향에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="translated">다음 옵션은 쌍으로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="translated">다음 옵션은 기본 텍스트 포맷터로 전달됩니다. 자세한 내용은이 모듈의 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="translated">다음 옵션이 지원됩니다 : 중심점, 날짜, 고정식, 고정형, 고정형, 고정형, 따옴표, 릴리스, 섹션</target>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="translated">다음 패턴은 인수로 균형 괄호를 포함 할 수있는 foo () 함수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="translated">다음 패턴은 괄호로 묶은 그룹과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="translated">다음 플랫폼은 &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src에&lt;/a&gt; 있는 표준 소스 코드 배포에서 Perl 5.12 (릴리스 릴리스 날짜 기준)를 빌드하는 것으로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="translated">다음 플랫폼은 과거 (5.005_03 이전) 소스에서 Perl을 빌드하는 것으로 알려져 있지만 하드웨어 / 소프트웨어 플랫폼이 드물거나 우리가 현재 버전으로 인해 현재 릴리스의 상태를 확인할 수 없었습니다. 이 플랫폼 또는 둘 다에서 적극적인 챔피언이 없습니다. 그들은 예전에는 일을 했으므로 계속해서 컴파일을 시도하고 perlbug@perl.org에 문제를 일으킨다.</target>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="translated">다음 플랫폼에는 &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html을&lt;/a&gt; 통해 사용 가능한 바이너리 만 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="translated">다음 플랫폼에는 &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; 를 통해 사용할 수있는 자체 소스 코드 배포 및 바이너리가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="translated">다음 플랫폼은 이전 버전의 Perl에서 지원되었지만 공식적으로 5.12부터 Perl의 소스 코드에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="translated">다음 플랫폼은 이전 버전의 Perl에서 지원되었지만 공식적으로 5.20부터 Perl의 소스 코드에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="translated">다음 플랫폼은 5.10까지 지원되었습니다. 그들은 여전히 ​​5.12에서 작동했지만 지원 코드는 5.14에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="translated">다음 플랫폼은 이전 릴리스 (5.6 및 5.7)와 함께 작동했지만 5.8.0 릴리스의 경우 시간에 맞춰 수정하거나 테스트하지 않았습니다. 이 중 다수가 5.8.0에서 제대로 작동 할 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="translated">다음 pragma는 정의되어 있으며 자체 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="translated">다음과 같은 기본 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="translated">Haiku 개정판 28311에서는 다음과 같은 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="translated">다음은 파일 핸들에서 PerlIO 레이어 의 &lt;b&gt;이름&lt;/b&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="translated">다음 개정판이 지원됩니다. 기본값은 30입니다.</target>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="translated">다음 루틴을 가져 오도록 특별히 요청하면 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="translated">벤치 마크 모듈을 사용하는 경우 다음 루틴이 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="translated">다음 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="translated">&lt;code&gt;minus()&lt;/code&gt; 의 다음 샘플 구현 ( &lt;code&gt;Number&lt;/code&gt; 객체는 단순히 스칼라에 대한 참조로 축복받은 것으로 가정 )은 호출 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">다음 시퀀스 ( &lt;code&gt;\N&lt;/code&gt; 제외 )는 문자 클래스 내에서 또는 문자 클래스없이 작동합니다. 처음 6 개는 로캘을 인식하고 모두 유니 코드를 인식합니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="translated">다음 함수 세트는 모두 목록을 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt; 에서 영감을 얻은 다음 함수 세트 는 짝수 크기의 쌍 목록을 사용합니다. 쌍은 해시의 키 / 값 연결 또는 값 목록 일 수 있습니다. 이 함수는 모두 원래 쌍의 순서를 유지하며 동일한 &quot;키&quot;값을 가진 여러 쌍으로 혼동되지 않으며 각 쌍의 첫 번째 문자열이 일반 문자열 일 필요도 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="translated">히스토리, 중단 점, 조치, 디버거 옵션 및 Perl 명령 행 옵션 &lt;b&gt;-w&lt;/b&gt; , &lt;b&gt;-I&lt;/b&gt; 및 &lt;b&gt;-e&lt;/b&gt; 설정이 현재 보존 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="translated">다음은 음의 인덱싱을 사용하여 나중에 사용하기 위해 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 구문 안에 재귀 패턴을 더 쉽게 포함시키는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="translated">다음은 해시에 대한 원시 참조 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="translated">다음과 같은 단일 진술 :</target>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="translated">다음과 같은 표준 정량자가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="translated">다음 구조는 perl의 정규식 엔진 에서 &lt;code&gt;pprivate&lt;/code&gt; 구조로 사용됩니다 . 펄에만 적용되기 때문에 다른 엔진 구현에 대한 호기심의 가치에 지나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="translated">이 모듈이로드되면 다음 서브 루틴을 일반적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">다음 하위 섹션에서는 기본 로캘 범주에 대해 설명합니다. 이 외에도 일부 조합 범주를 사용하면 한 번에 둘 이상의 기본 범주를 조작 할 수 있습니다. 이에 대한 설명은 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="translated">다음 시스템에는 PA-RISC 1.1 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="translated">다음 시스템에는 PA-RISC 1.0 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="translated">다음 표는 유니 코드 6.3에서 &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\v&lt;/code&gt; 와 일치하는 전체 문자 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="translated">다음 표는 유니 코드 3.2에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="translated">다음 표는 나눗셈의 결과와 나머지를 보여 주므로 위의 방정식이 적용됩니다. 일부 &quot;일반적인&quot;사례는 다음과 같은 추론을보다 명확하게 보여주기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="translated">다음 표는 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 설정에 따라 UNIX 및 DOS와 같은 플랫폼의 기본 계층을 요약합니다. .</target>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="translated">다음 표에는 C0 컨트롤 (0..31), ASCII 그래픽 (32..7e), 삭제 (7f), C1 컨트롤 (80..9f) 및 Latin- 1 (일명 ISO 8859-1) (a0..ff). ASCII에 대한 라틴어 1 확장자의 테이블 이름에는 대략적으로 해당하는 문자 이름이 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="translated">QNX 6.2.0에서 Perl 5.8.1에 대해 다음 테스트가 여전히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="translated">다음 테스트는 QNX4에서 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 세 함수는 정수, 부호없는 정수 또는 double을 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV로 복사합니다 . &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="translated">다음 세 가지 매크로는 처음에 메모리를 할당하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="translated">다음 두 호출은 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="translated">다음과 같은 유형의 변경은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="translated">다음 유형의 변경은 아래에 명시된 &quot;허용 할 수없는&quot;범주에 속하지 않는 한 허용 가능한 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="translated">&lt;code&gt;config()&lt;/code&gt; 를 전달하여 다음 값을 설정할 수 있습니다 에 해시에 대한 참조를 .</target>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="translated">다음 변수는 B :: Concise에 의해 정의됩니다. 그것들이 스타일로 사용될 때, 그들의 각각의 값은 각각의 opcode의 렌더링에 연결된다.</target>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="translated">다음 변수를 설정 &lt;b&gt;해야합니다&lt;/b&gt;-&amp;gt; new 생성자를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="translated">다음 변수는 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="translated">다음과 같이 구현되었습니다</target>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="translated">다음은 파일 시스템에서 허용되는 가장 긴 경로 이름의 최대 길이를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;/var&lt;/code&gt; 를 보유하는 파일 시스템에서 허용되는 가장 긴 경로 이름의 최대 길이를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">다음은 기계의 클럭 속도를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">다음은 아마 당신이 기대하는 것을하지 않을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">다음은 예상대로 인쇄되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">다음은 현재 &lt;code&gt;LC_CTYPE&lt;/code&gt; 범주를 쿼리합니다 . (두 번째 인수는 'query'를 의미하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">다음은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 동작을 아르헨티나 스페인어로 설정합니다 . &lt;b&gt;참고&lt;/b&gt; : 로캘의 이름과 사용 가능성은 운영 체제에 따라 다릅니다. 시스템에서 사용 가능한 로케일을 찾는 방법은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">다음은 로케일 환경 변수 (두 번째 인수 &lt;code&gt;&quot;&quot;&lt;/code&gt; ) 에 따라 &lt;code&gt;LC_CTYPE&lt;/code&gt; 동작 을 설정합니다 . 로케일 환경 변수의 의미에 대해서는 시스템의 &lt;code&gt;setlocale(3)&lt;/code&gt; 문서를 참조하거나 &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">다음은 일반적인 UNIX 시스템 로케일 동작 (두 번째 인수 &lt;code&gt;&quot;C&quot;&lt;/code&gt; )을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">다음은 먼저 Math :: BigInt :: Foo를 찾은 다음 Math :: BigInt :: Bar를 찾으려고 시도하는데 실패하면 Math :: BigInt :: Calc로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">다음과 같은:</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">다음 항목은 주로 참조 및 일반적인 유니 코드 지식을위한 것으로 Perl은 이러한 구성을 내부적으로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">내장 기능을 재정의하는 전술 한 메커니즘은 가져 오기를 요청하는 패키지로 제한되어 있습니다. 네임 스페이스 경계에 관계없이 모든 곳에서 내장을 재정의하려는 경우에 적용 할 수있는 두 번째 방법이 있습니다. 서브 우퍼를 특수 네임 스페이스 &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; 로 가져 와서 달성됩니다 . 다음은 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자를 정규 표현식을 이해하는 것으로 대담하게 대체하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">fork () 에뮬레이션은 Perl 인터프리터 수준에서 구현됩니다. 이것은 일반적으로 실행중인 fork ()가 실행중인 인터프리터와 모든 상태를 복제하고, 복제 된 인터프리터를 별도의 스레드에서 실행하여 fork ()가 호출 된 직후의 새 스레드에서 실행을 시작한다는 것을 의미합니다 부모. 이 자식 &quot;프로세스&quot;를 구현하는 스레드를 의사 프로세스라고합니다.</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">fork () 에뮬레이션은 Perl 인터프리터를 포함하고 Perl 코드의 비트를 평가할 수있는 Perl API를 호출하는 응용 프로그램에서 실행될 때 예상대로 작동하지 않을 수 있습니다. 이것은 에뮬레이션이 Perl 인터프리터 자신의 데이터 구조에 대한 지식 만 가지고 있고 포함하는 응용 프로그램의 상태에 대해서는 아무것도 모르기 때문입니다. 예를 들어, 응용 프로그램 자체의 호출 스택에서 수행 된 모든 상태에 도달하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">BEGIN 블록 내에서 호출 될 때 fork () 에뮬레이션이 완전히 작동하지 않습니다. 분기 된 사본은 BEGIN 블록의 내용을 실행하지만 BEGIN 블록 이후 소스 스트림 구문 분석을 계속하지 않습니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">프로세스 그룹 리더가되지 않도록하려면 fork ()가 setsid () 앞에 와야합니다. 그렇다면 setsid ()가 실패합니다. 시스템에 setsid () 함수가없는 경우</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">분기 된 디버거에서는 환경 변수 &lt;code&gt;TERM&lt;/code&gt; 이 &lt;code&gt;xterm&lt;/code&gt; 이고 환경 변수 &lt;code&gt;DISPLAY&lt;/code&gt; 가 있어야합니다. &lt;code&gt;xterm&lt;/code&gt; 은 소문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">폼 &lt;code&gt;$x **= $y&lt;/code&gt; 빠르다보다 &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , 그러나.</target>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Perl 4에서 사용 가능한 &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; 양식 은 더 이상 사용할 수 없습니다. 의 발생을 교체 &lt;code&gt;if BLOCK&lt;/code&gt; 가 &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">섹션 스펙의 공식 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">대체 플래그를 제외하고 형식은 헤더 섹션과 거의 동일합니다. | 뒤에 0..3. 가능한 값의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">형식은 PREREQ_PM과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 의 생성자 형식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">IO :: Uncompress :: AnyInflate의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">IO :: Uncompress :: AnyUncompress의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">IO :: Uncompress :: Bunzip2의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">IO :: Uncompress :: Gunzip의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">IO :: Uncompress :: Inflate의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">IO :: Uncompress :: RawInflate 생성자의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">IO :: Uncompress :: Unzip의 생성자 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">이 스칼라 값의 형식은 &lt;b&gt;없습니다&lt;/b&gt; 로케일에 의존하지만 펄에 내장. 현지 시간 대신 GMT의 경우 &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; 내장을 사용하십시오 . 또한 참조 &lt;code&gt;Time::Local&lt;/code&gt; 모듈 (변환 초, 분, 시간, 시간에 의해 반환되는 정수 값 ()에 같은 다시를 들어), 그리고 &lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈의의 strftime (3)에서는 mktime (3) 기능.</target>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">이 스칼라 값의 형식은 &lt;b&gt;없습니다&lt;/b&gt; 로케일에 의존하지만 펄에 내장. 현지 시간 대신 GMT의 경우 &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; 내장을 사용하십시오 . 또한 참조 &lt;code&gt;Time::Local&lt;/code&gt; 모듈 (변환 초, 분, 시간, 시간에 의해 반환되는 정수 값 ()에 같은 다시를 들어), 그리고 &lt;a href=&quot;../posix&quot;&gt;POSIX의&lt;/a&gt; 모듈의의 strftime (3)에서는 mktime (3) 기능.</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">형식 지정자 감지는 완전한 printf 구문 감지가 아니지만 가장 일반적인 경우를 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">지원되는 형식은</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">지원되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">문자를 숫자로 변환하거나 그 반대로 변환 할 수있는 형식은 EBCDIC 플랫폼에서 실행될 때 ASCII 형식과 다릅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">Perl이 항상 UTF-8의 느슨한 해석을 사용하는 이전 기본값은 이제 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">전자는 유니 코드 처리를 의미합니다. 후자는 유니 코드 로케일을 나타내므로 그 안에있는 모든 문자열의 유니 코드 해석입니다.</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">이전에 문서화되지 않은 STRICT 인수는 엄격 성을 설정합니다. if true 'use strict;' 그렇지 않으면 '엄격하지 않음'을 사용합니다. &lt;b&gt;노트&lt;/b&gt; : STRICT를 생략하면 '엄격하지 않습니다.' 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">양식 &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">공식은 Red Dragon 서적 (사용 가능한 데이터를 사용하도록 재구성 됨)에 있으며 &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions에&lt;/a&gt; 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">네 &lt;code&gt;CPAN::*&lt;/code&gt; 클래스 : 작성자, 번들, 모듈, 배포</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">네 개의 &lt;code&gt;filter_*&lt;/code&gt; 위에 표시된 메소드는 Perl과 함께 제공되는 모든 DBM 모듈, 즉 DB_File, GDBM_File, NDBM_File, ODBM_File 및 SDBM_File에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">4 가지 CPAN :: * 클래스 : 작성자, 번들, 모듈, 배포</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">스칼라, 배열, 해시 및 클래스의 네 가지 요소 유형은 문자열 ( &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; 및 클래스 이름) (선택적으로 &lt;code&gt;'*'&lt;/code&gt; 이 앞에옵니다) .</target>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">이 형식에 대해 리턴 된 목록 의 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">이 형식에 대해 리턴 된 목록에서 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">이 형식에 대해 리턴 된 목록에서 네 번째 (index [3]) 요소 ( &lt;code&gt;$default&lt;/code&gt; )는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">네 번째 논쟁은</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">네 번째 작업은 세 번째 작업이 아닌 논리와 동일 하며 열린 대괄호 안에 테스트 문자열의 시작 부분에 캐럿 문자 &lt;code&gt;^&lt;/code&gt; 를 추가하여 세 번째 작업과 같은 방식으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;M$&lt;/code&gt; 세계에 빠진 친구들 은이 실행 파일이 적절한 익스텐더와 함께 DOS, Win0.3 *, Win0.95 및 WinNT에서 실행된다는 사실에 감사 할 것입니다. &lt;a href=&quot;#Other-OSes&quot;&gt;다른 OS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">전체 원은 2</target>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">대안의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">라이센스의 전체 텍스트는이 모듈에 포함 된 LICENSE 파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">이 패키지의 전체 버전 번호 (예 : 5.6.1 (또는 5_6_1)) 수정 버전, 패치 수준 및 하위 버전을 결합하여 가능한 하위 버전을 포함한 전체 버전 번호를 얻습니다. 이것은 디렉토리 이름으로 사용하기에 적합하므로 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">호출 된 완전한 메소드 이름은 클래스 의 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 패키지 전역에서 사용 가능합니다. 이것이 전역 &lt;code&gt;strict 'vars'&lt;/code&gt; 아래에 패키지 이름 접두어없이 참조 하려면 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="translated">함수</target>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade ()&lt;/a&gt; 함수를 명시 적으로 사용하여 (이후 &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; 가 호출 되지 않는 한 ) 문자열을 유니 코드로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">&lt;b&gt;pod_find&lt;/b&gt; 함수 는 주어진 파일 및 / 또는 디렉토리 세트에서 POD 문서를 검색합니다. 파일 이름을 키로, POD 이름을 값으로 사용하여 해시를 리턴합니다. POD 이름은 파일 이름과 디렉토리 트리에서의 위치에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">&lt;b&gt;단순화&lt;/b&gt; _ 이름 함수 는 &lt;b&gt;basename&lt;/b&gt; 과 동일 하지만 Perl과 유사한 확장자 (.pm, .pl, .pod)와 같은 확장자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수 는 더 이상 사용되지 않으므로 호출 모듈에서 &quot;사용되지 않는&quot;경고 범주를 활성화 할 때마다 경고 메시지를 표시하는 코드가 포함되었습니다. 이런 식으로 말합니다.</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">&lt;code&gt;filter_read&lt;/code&gt; 함수 는 두 가지 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">I18N :: LangTags :: List :: name (...) 함수는 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">이 함수는 작성할 디렉토리 목록을 승인합니다. 호출의 마지막 매개 변수로 나타나는 선택적 hashref에 의해 동작이 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">이 함수는 제거 할 디렉토리 목록을 승인합니다. 호출의 마지막 매개 변수로 나타나는 선택적 hashref에 의해 동작이 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">함수 호출 &lt;code&gt;shell&lt;/code&gt; 은 두 개의 선택적 인수를 취합니다. 하나는 프롬프트이고, 두 번째는 기본 초기 명령 행입니다 (후자는 실제 ReadLine 인터페이스 모듈이 설치된 경우에만 작동 함).</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">함수 선언은 컴파일 타임에 보여야합니다. 프로토 타입은 함수에 대한 새 스타일 호출 해석에만 영향을 미치며, 새 스타일은 &lt;code&gt;&amp;amp;&lt;/code&gt; 문자를 사용하지 않는 것으로 정의됩니다 . 즉, 내장 함수처럼 호출하면 내장 함수처럼 동작합니다. 구식 서브 루틴처럼 호출하면 구식 서브 루틴처럼 작동합니다. 프로토 타입이 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 와 같은 서브 루틴 참조 또는 &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; 또는 &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; 와 같은 간접 서브 루틴 호출에 영향을 미치지 않는다는 것은 당연히이 규칙에서 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">이 함수는 지정된 터미널 유형의 항목을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">함수 인터페이스는 속성 문자열을 사용하여 텍스트에 지정할 색상 및 텍스트 속성을 설명합니다. 인식 된 비 색상 속성은 선명하고 재설정되며 굵게 표시되고 어둡고 희미하고 기울임 꼴, 밑줄, 밑줄, 깜박임, 반전 및 은폐됩니다. 지우기 및 재설정 (기본 속성으로 재설정), 어둡고 희미한 (흐리게 및 채도), 밑줄 및 밑줄은 동일하므로 가장 직관적 인 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">가능한 키워드가 표시 될 때마다 토큰 화기에서 함수가 호출됩니다. &lt;code&gt;keyword_ptr&lt;/code&gt; 은 구문 분석기의 입력 버퍼에서 단어를 가리키고 &lt;code&gt;keyword_len&lt;/code&gt; 은 길이를 제공합니다. null로 끝나지 않습니다. 이 함수는 단어를 확장 키워드로 처리할지 여부를 결정 하기 위해 단어 및 &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;% ^ H&lt;/a&gt; 와 같은 다른 상태를 검사해야합니다 . 그렇지 않은 경우 함수는 &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; 을 반환해야 하며 정상적인 파서 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">이 함수는 변수 또는 서브 루틴 (SCALAR, ARRAY, HASH 또는 CODE)에 대한 &lt;code&gt;$referent&lt;/code&gt; 인 $ referent 의 typeglob에 대한 &lt;code&gt;$package&lt;/code&gt; 의 기호 테이블을 찾습니다 . typeglob을 찾으면 반환합니다. 그렇지 않으면 undef를 반환합니다. 참고 것을 &lt;code&gt;findsym&lt;/code&gt; 가 이전에 성공적으로 발견 한 typeglobs을 memoizes, 같은 인수를 너무 후속 호출은 훨씬 더 빨리해야한다.</target>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">함수 이름과 반환 유형은 별도의 줄에 배치해야하며 왼쪽으로 플러시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">이 함수는 선택적으로 &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; 쌍 으로 지정된 여러 명명 된 옵션을 사용합니다 . 이를 통해 개별 옵션을 매개 변수 목록에서 모두 지정할 필요없이 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">함수 반환 &lt;code&gt;TRUE&lt;/code&gt; 입력 문자열이 비어있는 경우, 또는 대응하는 C 함수 돌아 가면 &lt;code&gt;TRUE&lt;/code&gt; 스트링의 모든 바이트.</target>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">이 기능은 또는, 요청 된 소켓 옵션을 나타내는 포장 된 문자열을 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 배치 오류의 원인과 오류에 &lt;code&gt;$!&lt;/code&gt; . 압축 문자열에있는 것은 LEVEL 및 OPTNAME에 따라 다릅니다. 자세한 내용은 getsockopt (2)를 참조하십시오. 일반적인 경우는 옵션이 정수이고,이 경우 결과는 팩형 정수이며, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; (또는 &lt;code&gt;I&lt;/code&gt; ) 형식으로 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">이 기능은 또는, 요청 된 소켓 옵션을 나타내는 포장 된 문자열을 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 배치 오류의 원인과 오류에 &lt;code&gt;$!&lt;/code&gt; . 압축 문자열에있는 것은 LEVEL 및 OPTNAME에 따라 다릅니다. 자세한 내용은 getsockopt (2)를 참조하십시오. 일반적인 경우는 옵션이 정수이고,이 경우 결과는 팩형 정수이며, &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; (또는 &lt;code&gt;I&lt;/code&gt; ) 형식으로 디코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">파일이 성공적으로 작성되면 함수는 true 값을 리턴합니다. 그렇지 않으면 거짓 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">이 함수는 호출 중에 실제로 작성된 디렉토리 목록을 리턴합니다. 스칼라 컨텍스트에서 작성된 디렉토리 수.</target>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">함수는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">이 함수는 부모 클래스를 포함하는 배열에 대한 참조를 순서대로 반환해야합니다. 클래스 이름은 숨김에서 &lt;code&gt;HvENAME()&lt;/code&gt; 을 호출 한 결과 여야합니다 . 이러한 경우 &lt;code&gt;HvENAME()&lt;/code&gt; 반환, 널 (null) &lt;code&gt;HvNAME()&lt;/code&gt; 대신 사용한다.</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">이 함수는 테스트 할 키를 첫 번째 인수로 &lt;code&gt;allow&lt;/code&gt; 하고 템플리트 의 allow 키에 의해 허용되는 모든 형태의 기준을 두 번째 인수로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">이 함수는 해시에 대한 참조 인 하나의 선택적 매개 변수를 사용합니다. 해시의 내용을 통해 수축 인터페이스를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">템플릿에서 &lt;code&gt;allow&lt;/code&gt; 키 를 처리하는 기능 도 독립적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">visit () 함수는 SV 아레나 목록을 스캔하고 각 SV에 대해 지정된 함수를 호출합니다. 즉, 여전히 존재하는 즉, 1 이외의 SvTYPE을 갖고 0이 아닌 SvREFCNT가 있습니다. visit ()는 다음 함수에서 사용됩니다 ([visit ()를 호출하는 함수] / [각 SV에 대해 visit ()에 의해 호출되는 함수]).</target>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">$ bytes에 코드가 255보다 큰 문자가 포함 된 경우 함수는 &quot;서브 루틴 항목의 넓은 문자&quot;로 표시됩니다. base64 인코딩은 1 바이트 문자에 대해서만 정의됩니다. 인코딩 모듈을 사용하여 원하는 바이트 인코딩을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">함수,</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">&lt;code&gt;filter_add&lt;/code&gt; 함수 는 실제로 필터를 설치합니다. 하나의 매개 변수를 가져야하며 참조해야합니다. 사용되는 기준의 종류에 따라 두 가지 필터 유형 중 어느 것이 사용 될지가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">&lt;code&gt;filter_del&lt;/code&gt; 함수 는 현재 필터를 비활성화하는 데 사용됩니다. 필터 작동에는 영향을 미치지 않습니다. 필터를 더 이상 호출하지 않도록 Perl에 지시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">기능 인터페이스는 알고리즘과 동일한 이름을 가진 가져 오기 가능한 함수입니다. 함수는 메시지를 인수로 사용하고 요약을 리턴합니다. 예:</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">기능적 인터페이스에는 Perl5.005 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="translated">기능</target>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;cond_wait()&lt;/code&gt; 및 &lt;code&gt;cond_signal()&lt;/code&gt; 함수 를 잠금과 함께 사용하여 자원을 사용할 수 있음을 협력 스레드에 알릴 수 있습니다. 그것들은 &lt;code&gt;pthreads&lt;/code&gt; 에있는 함수들과 매우 유사 합니다 . 그러나 대부분의 경우 대기열은 사용하기 쉽고 직관적입니다. 자세한 내용은 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">함수와 속성은 &lt;code&gt;PerlIOl&lt;/code&gt; 의 &quot;테이블&quot;(테이블 용) 멤버를 통해 액세스합니다 . 기능 (계층 &quot;클래스&quot;의 방법)은 고정되어 있으며 &lt;code&gt;PerlIO_funcs&lt;/code&gt; 유형으로 정의됩니다 . 그것들은 공개 &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; 함수 와 대체로 동일 합니다 :</target>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">&quot;계층 클래스&quot;의 기능 및 속성</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">기능은</target>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">이 섹션의 함수는 표현식에서 용어로 사용될 수 있습니다. 이들은 목록 연산자와 명명 된 단항 연산자라는 두 가지 주요 범주로 분류됩니다. 이들은 다음 쉼표와의 우선 순위 관계가 다릅니다. (우선 순위표의&lt;a href=&quot;perlop&quot;&gt; 퍼롭&lt;/a&gt;.)리스트 연산자는 하나 이상의 인수를 취하는 반면 단항 연산자는 하나 이상의 인수를 가질 수 없습니다. 따라서 쉼표는 단항 연산자의 인수를 종료하지만 목록 연산자의 인수 만 분리합니다. 단항 연산자는 일반적으로 인수에 스칼라 컨텍스트를 제공하는 반면 목록 연산자는 인수에 스칼라 또는 목록 컨텍스트를 제공 할 수 있습니다. 둘 다 수행하면 스칼라 인수가 먼저 나오고 목록 인수가 뒤 따르며 그러한 목록 인수는 하나만있을 수 있습니다. 예를 들어 splice ()에는 3 개의 스칼라 인수와리스트가 있고 gethostbyname ()에는 4 개의 스칼라 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">현재 구현되지 않은 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">이 함수는 성공적으로 삭제 된 파일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; 는 이러한 문제점을 스캔합니다 (기본적으로 Perl 5.9.4부터 시작).</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wendif-labels&lt;/code&gt; 는 잘못된 변형에 대해 경고합니다 (기본적으로 Perl 5.9.4부터 시작).</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">gcc 옵션 &lt;code&gt;-Wformat&lt;/code&gt; 은 이러한 문제를 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">생성 된 C ++ 코드는 &lt;code&gt;new&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">생성 된 Makefile을 사용하면 확장 사용자가 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">생성 된 싱글 톤은 인스턴스화에서 셸 세션이 끝날 때까지 유지됩니다. &amp;lt;plugin_list&amp;gt;는 런타임에 언제든지 재구성 할 수 있습니다. cpan 쉘이 실행되는 동안 위에 나열된 8 개의 참조 지점 각각에서 활성화 된 모든 플러그인을 확인하고 해당 오브젝트에 대해 구현 된 경우 해당 메소드를 실행합니다. 메소드는 인수로 전달 된 활성 CPAN :: Distribution 오브젝트와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">CODE : 섹션에 대해 생성 된 트레일러는 Perl에 표시되는 반환 값의 수가 0 또는 1임을 보장합니다 ( C 함수의 반환 값의 &lt;code&gt;void&lt;/code&gt; 및 &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL 변수에&lt;/a&gt; 언급 된 휴리스틱 에 따라 다름 ). PPCODE : 섹션에 대해 생성 된 트레일러는 반환 값의 수와 &lt;code&gt;SP&lt;/code&gt; 가 &lt;code&gt;[X]PUSH*()&lt;/code&gt; 매크로에 의해 업데이트 된 횟수를 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">현재 컴파일 패드의 오프셋 &lt;code&gt;po&lt;/code&gt; 에서 이름의 생성 번호 (lvalue). 참고 &lt;code&gt;SvUVX&lt;/code&gt; 는 이 목적을 위해 납치된다.</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">일반 플래그 비트는 &lt;code&gt;PerlIO_open()&lt;/code&gt; 전달 된 모드 문자열에서 추론 된 &lt;code&gt;O_XXXXX&lt;/code&gt; 스타일 플래그 와 일반적인 버퍼 계층의 상태 비트 의 하이브리드입니다 .</target>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;서브 루틴&lt;/b&gt; 이 &lt;b&gt;인수를&lt;/b&gt; 알고 있는 일반 이름 . 많은 언어에서 공식적인 논쟁은 항상 개별적인 이름으로 주어집니다. Perl에서 형식 인수는 배열의 요소 일뿐입니다. Perl 프로그램에 대한 공식 인수는 &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; 등입니다. 마찬가지로 Perl 서브 루틴에 대한 공식 인수는 &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; 등입니다. 값을 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 목록 에 지정하여 인수에 개별 이름을 지정할 수 있습니다 . &lt;b&gt;실제 인수&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">get_dup () 메소드</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">getaddrinfo () 함수는 호스트 이름과 서비스 이름을 구조 목록으로 변환합니다. 각 목록에는 명명 된 호스트의 명명 된 서비스에 연결할 수있는 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">getdcwd () 함수는 Windows가 각 드라이브에 대해 별도의 현재 작업 디렉토리를 유지 보수하므로 지정된 드라이브에서 현재 작업 디렉토리를 얻기 위해 Win32에 제공됩니다. 드라이브를 지정하지 않으면 현재 드라이브가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">gethost () 함수는 Socket :: inet_aton을 통해 숫자 인수를 gethostbyaddr ()에 전달하고 나머지는 gethostbyname ()에 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">gethost () 함수는 Perl 코어에서이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">getnameinfo () 함수는 getsockname () 또는 getpeername ()에 의해 리턴 된 소켓 주소를 주소와 서비스 이름을 나타내는 사람이 읽을 수있는 문자열 쌍으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">getnet () 함수는 숫자 인수를 getnetbyaddr ()에 전달하고 나머지는 getnetbyname ()에 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">getnet () 함수는 Perl 코어에서이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">getproto () 함수는 숫자 인수를 getprotobyport ()로 전달하고 나머지는 getprotobyname ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">getpw () 함수는 숫자 인수를 getpwuid ()로 전달하고 나머지는 getpwnam ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">getserv () 함수는 숫자 인수를 getservbyport ()로 전달하고 나머지는 getservbyname ()으로 전달하는 간단한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">주어진 인수는 &lt;code&gt;isdst&lt;/code&gt; 값이 영향을받지 않는 것을 제외하고 시스템의 &lt;code&gt;strftime()&lt;/code&gt; 함수 를 호출하기 전에 &lt;code&gt;mktime()&lt;/code&gt; 을 호출 하는 것처럼 일관성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">에 주어진 링크</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">glob 꺾쇠 괄호 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 Bourne 쉘 또는 C 쉘과 같은 Unix와 유사한 쉘에서 사용하는 파일 이름 패턴 일치 규칙을 구현하는 경로 이름 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">Perl 공간에서 출력 필드 구분 기호- &lt;code&gt;*,&lt;/code&gt; 포함하는 glob .</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">오류가 발생하여 글로브가 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">전역 &lt;code&gt;debug&lt;/code&gt; 및 디버그 &lt;code&gt;debugcolor&lt;/code&gt; pragma를 사용하면 정규 표현식 컴파일 및 실행에 대한 자세한 디버깅 정보를 얻을 수 있습니다. &lt;code&gt;debugcolor&lt;/code&gt; 은 디버깅 정보 TERMCAP 컬러 시퀀스를 표시 할 수있는 단말기에 색으로 표시되는 것을 제외하고, 디버그와 동일하다. 다음은 예제 출력입니다.</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">글로벌 변수 $ Devel :: Peek :: pv_limit는 다양한 문자열 값으로 인쇄되는 문자 수를 제한하도록 설정할 수 있습니다. 0으로 설정하면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">같은 글로벌 변수, &lt;code&gt;@ARGV&lt;/code&gt; 또는 구두점 변수가되어야 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 으로화된 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; . 이 블록은</target>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">글루 코드는 Perl 스택에서 인수를 가져 와서이 Perl 값을 C 함수에 의해 예상되는 형식으로 변환하고이 C 함수를 호출하며 C 함수의 반환 값을 Perl로 다시 전송합니다. 여기서 리턴 값은 일반적인 C 리턴 값이거나 출력 매개 변수로 사용될 수있는 C 함수 인수 일 수 있습니다. 이러한 리턴 값은 Perl 스택에 놓거나 Perl 측에서 제공된 인수를 수정하여 Perl로 다시 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">gmctime () 함수는 원래 CORE :: gmtime () 함수의 스칼라 감지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">여기서 목표는 기존의 Test.pm보다 더 많은 유연성을 제공하면서도 배우기 쉽고, 사용하기 쉽고, 스스로 학습하기 어려운 테스트 유틸리티를 사용하는 것입니다. 따라서 가장 일반적인 루틴의 이름은 작게 유지되고 특별한 경우와 마법의 부작용은 최소화됩니다. 위지 위그</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">CPAN 테스터 프로젝트 ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) 의 목표는 가능한 많은 플랫폼에서 가능한 많은 CPAN 패키지를 테스트하는 것입니다. 이는 모듈 작성자와 잠재적 사용자에게 버그 나 플랫폼 호환성 문제를 식별하고 CPAN의 전반적인 품질과 가치를 향상시키는 귀중한 피드백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">좋은 소식은 최소한 일부 DBM 모듈을 사용할 수 있어야하며 &lt;code&gt;AnyDBM_File&lt;/code&gt; 은 찾을 수있는 모듈을 사용 한다는 것입니다. 물론 코드는 매우 엄격해야하며 가장 큰 공통 요소 (예 : 각 레코드 당 1K를 초과하지 않음)로 떨어 지므로 모든 DBM 모듈에서 작동합니다. 자세한 내용은 &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">오래된 C 코드 품질 검사기 인 &lt;code&gt;lint&lt;/code&gt; 는 여러 플랫폼에서 사용할 수 있지만 여러 공급 업체에서 구현 한 여러 가지 구현이 있으므로 플래그가 다른 플랫폼에서 동일하지 않다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">문법은 다음과 같은 규칙을 제공합니다. 오른쪽에있는 모든 것을 순서대로 보면 콜론 왼쪽에있는 것을 만들 수 있습니다. 이것을 &quot;감소&quot;라고하며 구문 분석의 목적은 입력을 완전히 줄이는 것입니다. 수직 막대로 구분 당신이 감소를 수행 할 수있는 여러 가지 방법이 있습니다 : 그래서, &lt;code&gt;term&lt;/code&gt; 다음 &lt;code&gt;=&lt;/code&gt; 다음 &lt;code&gt;term&lt;/code&gt; 하게 &lt;code&gt;term&lt;/code&gt; 및 &lt;code&gt;term&lt;/code&gt; 다음 &lt;code&gt;+&lt;/code&gt; 는 다음 &lt;code&gt;term&lt;/code&gt; 도 할 수 있습니다 &lt;code&gt;term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">위의 스 니펫의 1 ~ 3 행에있는 문법은 더 복잡한 양식을 작성하는 방법을 알려줍니다. 이러한 복잡한 형태 &quot;비 터미널 기호&quot;는 일반적으로 소문자로 표시됩니다. 여기에서 사용 된 &lt;code&gt;term&lt;/code&gt; 는 단일 표현식을 나타내는 비 터미널 기호입니다.</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">great_circle_midpoint ()는 특별한 경우입니다</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">그룹 전체는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">파일을 소유 한 그룹 ID</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">파일을 소유 한 그룹 이름</target>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">그룹화는 \ g1에 값을 할당하므로 두 부분에 동일한 3 문자 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">그룹화 메타 문자 &lt;code&gt;()&lt;/code&gt; 를 사용하면 일치하는 문자열 부분을 추출 할 수도 있습니다. 각 그룹화에서 내부와 일치하는 부분은 특수 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 으로 들어갑니다 . 일반 변수처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">그룹화 메타 문자 &lt;code&gt;()&lt;/code&gt; 는 완전히 다른 기능을 제공합니다. 일치하는 문자열 부분을 추출 할 수 있습니다. 이것은 텍스트 처리와 일치하는 항목을 찾는 데 매우 유용합니다. 각 그룹화에서 내부와 일치하는 부분은 특수 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 으로 들어갑니다 . 일반 변수처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; 유틸리티 의 내장</target>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">핸들러 이름은 선언 된 변수의 기본 유형 또는 전달 된 참조를 기반으로합니다. 이러한 속성은 서브 루틴 또는 변수 선언과 연관되어 있기 때문에 일부 패키지에 축복이있을 가능성을 의도적으로 무시합니다. 따라서 서브 루틴 선언은 &quot;CODE&quot;를</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">이후에 설치된 신호에 사용 된 핸들러 는 어떤 신호가 포착되었는지를 나타내는 메시지와 함께 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (실제로 &lt;code&gt;croak&lt;/code&gt; )를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">이후에 설치된 신호에 사용 된 핸들러는 Perl 스택 추적을 STDERR에 출력 한 다음 코어 덤프를 시도합니다. 이것이 기본 신호 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">MBI / MBF (Perl 버전 &amp;lt;= 5.7.2와 함께 제공되는 이전 코어 코드)에서 A &amp;amp; P를 처리하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">계층 별 오류 처리가 지정되지 않았습니다. 예를 들어 $! 오류 처리를 최상위 계층에 위임해야하는 경우 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">하이픈과 엠 대시를 처리하는 것은 다소 취약하며 일부 상황에서는 잘못된 것을 얻을 수 있습니다. 이것은 &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">해시 &lt;code&gt;%ENV&lt;/code&gt; 에는 현재 환경이 포함되어 있습니다. &lt;code&gt;ENV&lt;/code&gt; 에 값을 설정 하면 이후에 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 해제 하는 모든 하위 프로세스의 환경이 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">해시 &lt;code&gt;%INC&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 를 통해 포함 된 각 파일 이름에 대한 항목을 포함합니다 연산자 . 키는 지정한 파일 이름 (모듈 이름이 경로 이름으로 변환 됨)이며 값은 찾은 파일의 위치입니다. 이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 운영자가 특정 파일이 이미 포함되었는지 여부를 확인하기 위해 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">해시 &lt;code&gt;%SIG&lt;/code&gt; 에는 신호에 대한 신호 처리기가 포함되어 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">해시 알고리즘은 &lt;code&gt;PERL_HASH&lt;/code&gt; 매크로에 .</target>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">위에서 설명한 해시는 로케일 독립적 인 케이스에 대해 리턴되며, 여기서 맵핑 중 하나 이상이 길이보다 깁니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 반환되는 코드 포인트는 매핑을 가질 수 있지만, 그래서 모든 길이 하나, 그리고에 의해 반환되는 경우 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; . 이 함수가 값을 반환하면 길이가 1 인 코드 포인트에 대한 전체 매핑 집합에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">해시는 exist ()를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">해시는 Storable :: file_magic ()에 의해 반환 된 것과 같은 구조를 가지고 있습니다. &lt;code&gt;file&lt;/code&gt; 이미지 파일 이미지의 경우 요소는 사실이다.</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">new () 함수가 반환 한 해시 참조를 사용하여 .packlist의 내용을 검사하고 수정할 수 있습니다. 해시를 수정하여 .packlist에서 항목을 추가 / 삭제할 수 있습니다. 해시 키와 연관된 값이 스칼라이면 후속 write ()에 의해 .packlist에 기록 된 항목은 간단한 파일 이름이됩니다. 값이 해시 인 경우 파일 이름 뒤에 해시의 key = value 쌍이 기록됩니다. .packlist를 다시 읽으면 원래 항목이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">반환 된 해시는 다음과 같은 요소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">묶고 싶은 해시 변수.</target>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">삭제 된 작업 체인의 헤드가 반환되거나 작업이 삭제되지 않은 경우 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">이 모듈에 의해 작성된 헤더 파일</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">헤더 섹션은 단어 CHARMAP를 포함하는 행까지 계속됩니다. 이 섹션은</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Storable의 핵심은 적절한 속도로 C로 작성되었습니다. 더 빠른 속도를 위해 캡슐화를 희생하기 위해 perl 내부를 조작 할 때 추가적인 저수준 최적화가 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 가 아니라면 16 진수에 &quot;0x&quot;또는 &quot;x&quot;를 접두사로 지정할 수 있습니다. 가 설정되어 .</target>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">상위 레벨 루프는 반복 사이에 추가 상태 (마지막 일치가 길이가 0인지 여부)를 유지합니다. 루프를 끊기 위해 길이가 0 인 일치 후 다음 일치는 길이가 0이되도록 금지됩니다. 되돌아와이 금지 상호 작용은 (참조 &lt;a href=&quot;#Backtracking&quot;&gt;역행을&lt;/a&gt; 하고 있으므로)</target>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">힌트 파일은 WriteMakefile에 주어진 인수가 해시 참조 $ self에 채워지지만이 참조가 축복되기 전에 eval ()됩니다. 따라서 속성을 재정의하거나 만들 때 동등한 작업을 수행하려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">Perl의 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 연산자가 사용하는 후크 . &lt;b&gt;ptype&lt;/b&gt; 은 IO의 종류에 대한 perl의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">getaddrinfo ()에 제공된 호스트 이름에 사용 가능한 주소 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">getaddrinfo ()에 제공된 호스트 이름이 없거나 getnameinfo ()에 제공된 주소가 호스트 이름과 연관되어 있지 않으며 &lt;code&gt;NI_NAMEREQD&lt;/code&gt; 플래그가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">URI의 호스트 이름입니다. 호스트가 원래 'file : //'URL에 대해 'localhost'인 경우 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">쌍곡 사인, 코사인 및 탄젠트</target>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">icmp 프로토콜을 사용하려면 프로그램을 루트로 실행하거나 루트로 설정해야합니다. 다른 프로토콜에는 특별한 권한이 필요하지 않지만 모든 네트워크 장치가 tcp 또는 udp echo를 구현하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">ID는 문자 (az 또는 AZ)로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">그것에 대해 생각할 필요가없는 이상적인 (그러나 조금 추한) 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 을 사용하는 것입니다 . 따라서 &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 코드 의 첫 부분은 다음 과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">즉각적인 이전 릴리스 (즉, perl5.14.x)는 일반적으로 현재 릴리스와 동일한 레벨이 아니지만 한동안 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 의 구현은 &quot;푸시 (pushed)&quot;될 때 자체적으로 이진 데이터에 적합하다고 선언하지 않는 모든 계층 인 의사 계층입니다. (Unuting : utf8 및 : crlf는 레이어를 팝하는 대신 플래그를 지우는 방식으로 구현되지만 구현 세부 사항입니다.)</target>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">시스템의 개별 구성 요소 구현은 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">Perl 코어 내에서 C3 MRO 및 전환 가능한 MRO의 구현은 Brandon L Black에 의해 작성되었습니다. Nicholas Clark은 플러그 형 인터페이스를 만들고 Brandon의 구현을 리팩토링하여이 문서를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">위의 설명의 의미는 중첩 괄호를 포함하는 패턴이 &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; 를 순환하는 호출 그래프를 생성한다는 것입니다</target>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 함수 의 암시 적 반복자 변수</target>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">암시 적 변수 &lt;code&gt;given()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">이 테스트의 중요성은 모듈의 안정성에 비례합니다. 안정적으로 사용되거나 광범위하게 사용되기를 희망하는 모듈은 가능한 한 엄격한 테스트 체제를 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">좋은 테스트 스크립트 작성의 중요성은 아무리 강조해도 지나치지 않습니다. Perl 자체가 사용하는 &quot;ok / not ok&quot;스타일을 밀접하게 따라야하므로 각 테스트 사례의 결과를 매우 쉽고 명확하게 파악할 수 있습니다. 버그를 찾아 수정하면 테스트 케이스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">run_forked의 중요하고 구별되는 기능은 처음에는 꽤 간단한 작업 인 것처럼 보이는 실행 시간 초과입니다. 그러나 생성하는 프로그램이 일부 자식 자체를 생성 할 수 있다고 생각하면 (그러면 차례로 동일하게 할 수 있음) 그것은 단순한 문제가 아닌 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">이것의 중요한 부분은 HEAP에 대한 두 번째 인수 (증분)이며 스택이 &quot;(16M) 라인 이상&quot;이되도록합니다. 힙 증분이 너무 작 으면 perl (예 : unicode / Name.pl로드)이 &quot;큰&quot;(400K +) 문자열을 만들려고 할 때 단일 세그먼트에 맞지 않고 &quot;메모리 부족!&quot; -여전히 사용 가능한 메모리가 충분하더라도.</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">포함 된 내용은 MANIFEST.SKIP 파일 사이에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">독립 하위 표현식 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 은 나머지 정규 표현식에 신경 쓰지 않으므로 &lt;code&gt;a&lt;/code&gt; 를 보고 가져 옵니다. 그런 다음 나머지 정규 표현식 &lt;code&gt;ab&lt;/code&gt; 는 일치 할 수 없습니다. 때문에 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 독립적 인,이 더 되돌아없고 독립적 인 표현식은 포기하지 않는 &lt;code&gt;a&lt;/code&gt; . 따라서 정규 표현식의 전체 일치가 실패합니다. 완전히 독립적 인 정규 표현식에서도 비슷한 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">지정된 색인 항목에는 공백 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">인덱스 함수는 다른 문자열 내에서 하나의 문자열을 검색하지만 완전한 정규식 패턴 일치의 와일드 카드와 유사한 동작은 없습니다. POSITION 또는 그 이후에 STR에서 SUBSTR이 처음 나타나는 위치를 리턴합니다. POSITION을 생략하면 문자열의 처음부터 검색을 시작합니다. 문자열의 시작 전 또는 끝의 POSITION은 각각 시작 또는 끝인 것처럼 처리됩니다. POSITION과 반환 값은 0을 기준으로합니다. 부분 문자열이 없으면 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">인덱스 함수는 다른 문자열 내에서 하나의 문자열을 검색하지만 완전한 정규식 패턴 일치의 와일드 카드와 유사한 동작은 없습니다. POSITION 또는 그 이후에 STR에서 SUBSTR이 처음 나타나는 위치를 리턴합니다. POSITION을 생략하면 문자열의 처음부터 검색을 시작합니다. 문자열의 시작 전 또는 끝의 POSITION은 각각 시작 또는 끝인 것처럼 처리됩니다. POSITION과 반환 값은 0을 기준으로합니다. 부분 문자열이 없으면 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">padlist에서 마지막으로 할당 된 공간의 색인입니다. 마지막 패드는 이전 슬롯에있을 수 있습니다. 이 경우 뒤에 오는 모든 항목은 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">마지막 패드 항목의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">마지막 패드 이름의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">인덱싱 은 각 주요 페이지, 섹션, 하위 섹션, 항목 및 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 지시문 에 대해 &lt;code&gt;.tm&lt;/code&gt; 을 통해 메시지를 출력하기 만합니다 . 자세한 내용은 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">유추 된 앵커 텍스트는 &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec에&lt;/a&gt; 따라 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">무한대와 숫자가 아닌 숫자에는 고유 한 산술 규칙이 있습니다. 일반적인 규칙은 &quot;전염성&quot;이라는 것입니다. &lt;code&gt;Inf&lt;/code&gt; plus one은 &lt;code&gt;Inf&lt;/code&gt; 이고 &lt;code&gt;NaN&lt;/code&gt; plus one은 &lt;code&gt;NaN&lt;/code&gt; 입니다. 당신이 무한하지-A-번호를 결합 할 때 어디에서 일이 흥미로워하는 것은 : &lt;code&gt;Inf&lt;/code&gt; 를 뺀 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;Inf&lt;/code&gt; 를 나눈 &lt;code&gt;INf&lt;/code&gt; 하다 &lt;code&gt;NaN&lt;/code&gt; 이을 (동안 &lt;code&gt;Inf&lt;/code&gt; 를 플러스 &lt;code&gt;Inf&lt;/code&gt; 를가 한다 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;Inf&lt;/code&gt; 를 배 &lt;code&gt;Inf&lt;/code&gt; 를이 입니다 &lt;code&gt;Inf&lt;/code&gt; 를 ). &lt;code&gt;NaN&lt;/code&gt; 은 또한 숫자와 같지 않다는 점에서 궁금합니다.</target>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">무한대는 9 ** 9 ** 9와 같이 부동 소수점 범위를 오버플로하는 특정 수학 연산의 결과입니다. 숫자가 아님은 결과가 정의되지 않았거나 표현할 수없는 경우의 결과입니다. Perl은 치명적인 오류를 생성하기 때문에 0으로 나누기 또는 음수의 제곱근과 같은 일반적인 &quot;정의되지 않은&quot;또는 &quot;범위를 벗어난&quot;작업에서 &lt;code&gt;NaN&lt;/code&gt; 을 얻을 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">정보</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">init 루틴은 몇 가지 질문을하고 CPAN / Config.pm 또는 CPAN / MyConfig.pm 파일을 작성합니다 (현재 사용중인 파일에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">초기 Haiku 포트는 Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;에 의해 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">초기 의견은 생각 나고 위험한 예를 보여줍니다. &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 전역 적으로 재정의 하면 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 연산자에 대해 새로운 (그리고 파괴적인) 동작을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">클래스 요소의 이니셜 라이저는 해당 클래스 또는 해당 서브 클래스 중 하나의 객체이거나 요소의 생성자에 전달할 명명 된 인수가 포함 된 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 입력 문자 가 올바른 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">입력 데이터는 각 파일에서 차례로 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">입력 번호는 음이 아닌 정수이거나 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 로 시작하는 문자열 이어야하며 나머지는 16 진수 정수로 간주됩니다. 리터럴 숫자 상수는 부호가 없어야합니다. 앞에 0이 있거나 16 진이 아닌 16 진수가 포함 된 경우 16 진으로 해석됩니다. 그렇지 않으면 십진수로 해석됩니다. &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 시작 하면 유니 코드 코드 포인트로 해석됩니다. 그렇지 않으면 기본으로 해석됩니다. (256 미만의 코드 포인트 만 유니 코드와 네이티브간에 다를 수 있습니다.) 따라서 &lt;code&gt;U+41&lt;/code&gt; 은 항상 라틴 문자 &quot;A&quot;입니다. EBCDIC 플랫폼 에서는 &lt;code&gt;0x41&lt;/code&gt; 이 &quot;NO-BREAK SPACE&quot;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">입력 매개 변수 이름이 느슨하게 일치합니다. 즉, 공백, 하이픈 및 밑줄은 무시됩니다 (old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 제외하고 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 더 잘 작성되며 둘 다 의미 함) &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">입력 레코드 구분 기호 -Perl 공간에서 &lt;code&gt;$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">입력 레코드 구분 기호 (기본적으로 줄 바꾸기). 이것은 &quot;선&quot;이 무엇인지에 대한 Perl의 아이디어에 영향을 미칩니다. null 문자열로 설정된 경우 빈 줄을 종료 자로 처리하는 것을 포함하여 &lt;b&gt;awk&lt;/b&gt; 의 RS 변수 처럼 작동 합니다 (빈 줄은 공백이나 탭을 포함 할 수 없음). 다중 문자 터미네이터와 일치 시키거나 파일 끝을 읽 도록 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 하도록 다중 문자 문자열로 설정할 수 있습니다 . 로 설정 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 로 설정하는 것보다 약간 다른 의미 뭔가 &lt;code&gt;&quot;&quot;&lt;/code&gt; 파일이 연속 빈 줄이 포함 된 경우. &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정하면 연속 된 두 개 이상의 빈 줄이 하나의 빈 줄로 취급됩니다. 로 설정 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 다음 입력 문자가 개행 문자 인 경우에도 다음 입력 문자가 다음 단락에 속한다고 맹목적으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">다른 값의 중간에 스칼라 또는 목록 값을 삽입하여 모든 값이있는 것처럼 보입니다. Perl에서 변수 보간은 큰 따옴표로 묶인 문자열과 패턴에서 발생하며, 목록 보간은 목록 연산자 또는 다음과 같은 다른 구문에 전달할 값 목록을 구성 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">코돈 DNA 중지 예제에 대한 영감은 7 장의 우편 번호 예제에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">빌드 중에 설정 한 설치 경로가 perl로 컴파일되므로 해당 perl을 사용하기 위해 추가 경로를 수행 할 필요가 없습니다 (PATH 변수에 위치 추가 제외).</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">설치 프로그램은 고대 버전이며 사용 경로에 몇 가지 버그가 있습니다. 나중에 수정해야합니다. 기본적으로 일부는 &quot;C : / Program Files / Windows CE Tools&quot;로, 다른 것은 &quot;설치 프로그램에 제공 한 경로에 관계없이&quot;C : / Windows CE Tools &quot;로 이동합니다 (기본값은&quot;C : / Windows CE Tools &quot;입니다). &quot;). 설치 프로그램을 계속 진행하려면 재부팅이 필요합니다. 또한 EVC4를 설치할 때 Visual Studio와의 .c 및 .h 연결이 무시 될 수 있습니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">installman 스크립트는 OS / 390에서 실행을 시도합니다. roff 유틸리티가 설치되어 있으면 오류가 줄어 듭니다. Redbook SG24-5944-00 ftp 사이트에서 GNU groff를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">컴퓨터가 주어진 문자를 나타내는 데 사용하는 정수. ASCII 코드 포인트의 범위는 0 ~ 127입니다. 유니 코드 코드 포인트의 범위는 0 ~ 0x1F_FFFF입니다. Perl 코드 포인트는 기본 정수 크기에 따라 0 ~ 2&amp;sup3;&amp;sup2;-1 또는 0 ~ 2⁶⁴-1 범위입니다. Perl Culture에서 &lt;b&gt;서수&lt;/b&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">정수 형식 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 는 기본 바이트 순서 및 엔디안을 준수하기 때문에 프로세서와 운영 체제간에 본질적으로 이식성이 없습니다. 예를 들어, 4 바이트 정수 0x12345678 (10 진수 305419896)은 기본적으로 (CPU 레지스터에서 정렬 및 처리) 바이트 단위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">정수 형식 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 는 기본 바이트 순서 및 엔디안을 준수하기 때문에 프로세서와 운영 체제간에 본질적으로 이식성이 없습니다. 예를 들어, 4 바이트 정수 0x12345678 (10 진수 305419896)은 기본적으로 (CPU 레지스터에서 정렬 및 처리) 바이트 단위로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">Tom이 가장 좋아하는 편집기 6과 혼동하지 않는 정수 4입니다. IV는 또한 &lt;b&gt;스칼라&lt;/b&gt; 가 보유 할 수 있는 유형의 내부 정수 값을 의미 하며 &lt;b&gt;NV&lt;/b&gt; 와 혼동하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">의 정수 또는 이름 형식 &lt;code&gt;condition&lt;/code&gt; 우리가 더 유연하게 선택할 수 있으며, 정규 표현식에서 이전의 일치 내용을 기반으로 일치하는 것. &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; 형식의 단어를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">정수 유형 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;L&lt;/code&gt; 뒤에는 &lt;code&gt;!&lt;/code&gt; 기본 반바지 또는 길이를 지정하는 수정 자입니다. 위의 예에서 볼 수 있듯이 , 베어 &lt;code&gt;l&lt;/code&gt; 은 정확히 32 비트를 의미하지만 로컬 C 컴파일러에서 볼 수 있는 기본 &lt;code&gt;long&lt;/code&gt; 가 더 클 수도 있습니다. 이것은 주로 64 비트 플랫폼에서 발생하는 문제입니다. 당신은 사용 여부를 볼 수 있습니다 &lt;code&gt;!&lt;/code&gt; 이런 식으로 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">정수 유형 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;L&lt;/code&gt; 뒤에는 &lt;code&gt;!&lt;/code&gt; 기본 반바지 또는 길이를 지정하는 수정 자입니다. 위의 예에서 볼 수 있듯이 , 베어 &lt;code&gt;l&lt;/code&gt; 은 정확히 32 비트를 의미하지만 로컬 C 컴파일러에서 볼 수 있는 기본 &lt;code&gt;long&lt;/code&gt; 가 더 클 수도 있습니다. 이것은 주로 64 비트 플랫폼에서 발생하는 문제입니다. 당신은 사용 여부를 볼 수 있습니다 &lt;code&gt;!&lt;/code&gt; 이런 식으로 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">이 루틴의 목적은 연결하는 것입니다</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">의도는 표현력이 아니라 사용의 단순성입니다. 단락은 시각적으로 눈에 띄는 그래서, 단락 (블록 형식)처럼, 그래서 나는 통해 실행할 수 &lt;code&gt;fmt&lt;/code&gt; (내 버전에서 F7을의 저를 다시 포맷 쉽게 &lt;b&gt;VI&lt;/b&gt; 의 내 버전, 또는 Esc Q &lt;b&gt;이맥스&lt;/b&gt; ). 난 항상에 번역자가 떠날 원 &lt;code&gt;'&lt;/code&gt; 및 &lt;code&gt;`&lt;/code&gt; 와 &lt;code&gt;&quot;&lt;/code&gt; 나는 모노 스페이스에 그대로. 그리고 아마도, 어, 작업 프로그램에 후루룩 소리 내며 먹기 네 개의 공간에 그것을 이동, 그리고 그것을 인쇄 할 수 있도록, 그대로 모드, 혼자 따옴표 폰트.</target>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">시스템 종료 코드의 제한된 공간에 가능한 원인에 대한 가능한 많은 정보를 압축하는 것이 목적입니다. 그러나 &lt;code&gt;$!&lt;/code&gt; 는 시스템 호출에 의해 설정 될 수있는 C의 &lt;code&gt;errno&lt;/code&gt; 값입니다 . 이는 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 에서 사용하는 종료 코드의 값을 예측할 수 없으므로 0이 아닌 값에 의존해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">시스템 종료 코드의 제한된 공간에 가능한 원인에 대한 가능한 많은 정보를 압축하는 것이 목적입니다. 그러나 &lt;code&gt;$!&lt;/code&gt; 는 시스템 호출에 의해 설정 될 수있는 C의 &lt;code&gt;errno&lt;/code&gt; 값입니다 . 이는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 에서 사용하는 종료 코드의 값을 예측할 수 없으므로 0이 아닌 값에 의존해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">Perl 컴파일과의 상호 작용은 &lt;code&gt;myint&lt;/code&gt; 패키지 내에서 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">대화식 디버거는 다음 명령을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 의 흥미로운 점은 초기 위치에있는 경우 새 구문을 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">이 모듈에 의해 정의 된 인터페이스에 나중에 perl의 디버깅 기능에 추가 된 일부가 누락되었습니다. 따라서이 인터페이스는 고도로 실험적이며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">이 모듈에 의해 노출되는 인터페이스는 현재 제한된 해시 구현과 매우 유사합니다. 시간이 지남에 따라이 동작이 확장되고 인터페이스가 더 추상화 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">인터페이스는 빠른 리팩토링의 결과이기 때문에 조금 이상합니다. 그것에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">이 모듈의 버전 2에서 제공하는 인터페이스는 버전 1과 100 % 역 호환되어야합니다. 예상되는 동작에 차이가있는 경우 작성자에게 문의하십시오 ( &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; 참조 ). &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP 인터페이스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">이 인터페이스는 다이제스트를 계산하는 두 가지 방법, 즉 한 번에 또는 단계로 제공합니다. 다음 짧은 프로그램은 각 방법을 사용하여 &quot;hello world&quot;의 SHA-256 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">내부 권고 잠금은 Perl의 flock () 루틴을 사용하여 구현됩니다. 시스템이 flock () 형식을 지원하지 않거나 NFS를 통해 파일을 공유하는 경우 파일 시스템 항목을 사용하여 파일을 잠그는 LockFile :: Simple과 같은 모듈을 사용하여 다른 형식의 잠금을 사용할 수 있습니다. 파일 디스크립터 잠금</target>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">디버깅 지원을위한 내부 변수입니다. 다양한 비트의 의미는 변경 될 수 있지만 현재 다음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">내부는 문자 128-255이지만 256+ (예 : 바이트 또는 utf8 일 수 없음)의 이름은 utf8로 인코딩 된 두 번째 항목에 자동으로 복제합니다.</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">Perl에서 조작 및 값의 해석은 때때로 조작 또는 값에 대한 컨텍스트의 요구 사항에 따라 다릅니다. 리스트와 스칼라라는 두 가지 주요 컨텍스트가 있습니다. 특정 연산은 목록을 원하는 컨텍스트에서 목록 값을 반환하고 그렇지 않으면 스칼라 값을 반환합니다. 이것이 조작에 해당되는 경우 해당 조작에 대한 문서에서 언급됩니다. 다시 말해, Perl은 예상 반환 값이 단수인지 또는 복수인지에 따라 특정 연산에 과부하를가합니다. 영어로 된 일부 단어는 &quot;물고기&quot;및 &quot;양&quot;과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">파일 권한 연산자 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 해석은 기본적으로 파일 모드와 사용자의 uid 및 gid에만 기반합니다. 실제로 파일을 읽거나 쓰거나 실행할 수없는 다른 이유가있을 수 있습니다 (예 : 네트워크 파일 시스템 액세스 제어, ACL (액세스 제어 목록), 읽기 전용 파일 시스템 및 인식 할 수없는 실행 파일 형식). 이 6 개의 특정 연산자를 사용하여 일부 작업이 가능한지 확인하는 것은 경쟁 조건에 개방적 일 수 있으므로 일반적으로 실수입니다.</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">파일 권한 연산자 &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 해석은 기본적으로 파일 모드와 사용자의 uid 및 gid에만 기반합니다. 실제로 파일을 읽거나 쓰거나 실행할 수없는 다른 이유가있을 수 있습니다 (예 : 네트워크 파일 시스템 액세스 제어, ACL (액세스 제어 목록), 읽기 전용 파일 시스템 및 인식 할 수없는 실행 파일 형식). 이 6 개의 특정 연산자를 사용하여 일부 작업이 가능한지 확인하는 것은 경쟁 조건에 개방적 일 수 있으므로 일반적으로 실수입니다.</target>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">16 진수 문자열에서 바이트 내용을 패킹하는 역 연산도 쉽게 작성할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">Storable 헤더가 차지하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">해시 또는 해시 참조에서 인수를 전달할지 여부는 주로 개인 스타일의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">조회 할 항목입니다. 중첩 모듈 (예 : &lt;code&gt;File::Basename&lt;/code&gt; )은 &lt;code&gt;File::Basename&lt;/code&gt; 또는 &lt;code&gt;File/Basename&lt;/code&gt; 으로 지정 됩니다. &lt;code&gt;perlfunc&lt;/code&gt; 와 같이 페이지의 설명 이름을 제공 할 수도 있습니다 . URL의 경우 현재 지원되는 유일한 종류는 HTTP 및 HTTPS입니다.</target>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">핵심은 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 당신이 사용하는 스마트 매칭 논리를 대체 할 수 있습니다 &lt;code&gt;~~&lt;/code&gt; (연산자와 스위치 구조를 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; ). &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn&lt;/a&gt; 및 &lt;a href=&quot;feature&quot;&gt;feature의 &lt;/a&gt;스위치 명령문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">키 &lt;code&gt;'-X'&lt;/code&gt; 는 모든 파일 테스트 연산자를 처리하기위한 서브 루틴을 지정하는 데 사용됩니다 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 등 : 전체 목록 은 &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 참조 ). 파일 테스트 연산자를 개별적으로 오버로드 할 수 없습니다. 구분하기 위해 '-'뒤에 오는 문자가 두 번째 인수로 전달됩니다 (즉, 2 진 연산자의 경우 두 번째 피연산자를 전달하는 데 사용되는 슬롯에서).</target>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">핵심 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;hv&lt;/code&gt; 말에 삭제</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">주요 &lt;code&gt;neg&lt;/code&gt; 바이너리에서 그것을 명확하게하기 위해 단항 마이너스에 사용됩니다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">핵심 기능은</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">여기서 핵심은 &lt;code&gt;nss_delete&lt;/code&gt; 호출입니다. 이 버그에 대한 한 가지 해결 방법은 파일에 add를 만드는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">키는</target>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">이러한 사전 정의 된 각 참조에서 허용되는 키는 동등한 C 구조에서 사용되는 이름으로 제한됩니다. 예를 들어 $ DB_HASH 참조는 &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; 및 &lt;code&gt;nelem&lt;/code&gt; 이라는 키만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">하단 레이어 해시의 키 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">해시의 키 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; -like 해시 의 키 는 정규식에서 찾은 모든 버퍼 이름에 해당합니다. &lt;code&gt;%+&lt;/code&gt; 와 유사한 해시 의 키 는 캡처 된 버퍼 이름 만 정의하므로 정의 된 값과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 해시 의 키 는 캡처 된 (및 정의 된 값과 연관된) 버퍼 이름 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; 해시 의 키 는 정규식에서 찾은 모든 버퍼 이름에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">해시의 키는 디렉토리의 항목 이름입니다. 해시에서 값을 읽으면 &lt;code&gt;File::stat::lstat&lt;/code&gt; 를 호출 한 결과입니다 . &lt;code&gt;DIR_UNLINK&lt;/code&gt; 가 &lt;code&gt;OPTIONS&lt;/code&gt; 에 포함되어 있으면 해시에서 요소를 삭제하면 해당 파일 또는 서브 디렉토리가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">이 해시의 키는 알려진 모든 서브 루틴의 이름입니다. 각 값은 sprintf (3) 형식 &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; 을 갖는 인코딩 된 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">&quot;컴퓨터 종류&quot;중 하나는 호환되는 컴퓨터 언어를 공유하는 모든 컴퓨터를 의미합니다. Perl 프로그램은 실행 가능한 이미지가 아닌 (일반적으로) 간단한 텍스트 파일이기 때문에 Perl 프로그램은 머신 코드로 &lt;b&gt;컴파일 된&lt;/b&gt; C와 같은 다른 언어의 프로그램보다 실행중인 아키텍처에 훨씬 덜 민감 합니다. &lt;b&gt;플랫폼&lt;/b&gt; 및 &lt;b&gt;운영 체제를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">알려진 가져 오기 기호는 &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; 및 &lt;code&gt;:gzip_write_open&lt;/code&gt; 입니다. 다른 것은 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">명세서의 레이블 또는 OP가 시작되는 블록을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 처리가 부족 하면 사후 처리 된 텍스트에 특정 제한이 생깁니다. 분리 문자가 &lt;code&gt;/&lt;/code&gt; 이면 이 단계의 결과로 &lt;code&gt;\/&lt;/code&gt; 조합을 얻을 수 없습니다 . &lt;code&gt;/&lt;/code&gt; 는 정규식을 끝내고 &lt;code&gt;\/&lt;/code&gt; 는 이전 단계에서 &lt;code&gt;/&lt;/code&gt; 로 제거 되고 &lt;code&gt;\\/&lt;/code&gt; 는 그대로 남아 있습니다. 때문에 &lt;code&gt;/&lt;/code&gt; 이 동등에 &lt;code&gt;\/&lt;/code&gt; 구분 기호는에서와 같이, RE 엔진에 문자 특별 될 일이없는 한 정규 표현식 내에서,이 문제가되지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;?foo?&lt;/code&gt; ; 또는 다음과 같이 영숫자 문자</target>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">langinfo () 함수는 출력 및 사용자 인터페이스를 지역화하는 데 사용할 수있는 다양한 로케일 정보를 조회합니다. langinfo ()에는 쿼리 할 로캘 상수를 식별하는 하나의 숫자 인수가 필요합니다. 인수가 제공되지 않으면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다. 인수로 사용하기에 적합한 숫자 상수는 I18N :: Langinfo에서 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo ()는 C nl_langinfo () 인터페이스의 래퍼 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">이 언어는 아름답고 (작고, 우아하며, 최소한) 실제적이지 않고 (사용하기 쉽고, 효율적이며, 완전하게) 사용됩니다. 어쨌든 &lt;b&gt;sed&lt;/b&gt; , &lt;b&gt;awk&lt;/b&gt; 및 &lt;b&gt;sh&lt;/b&gt; 의 최고의 기능 중 일부를 작성하여 (유익한 의견으로) Unix 사용자가 성가신 문제에 대한 빠른 해결책을 쉽게 익힐 수 있습니다. 범용 프로그래밍 기능은 절차 적, 기능적, 객체 지향 프로그래밍 패러다임을 지원하므로 Perl은 구부러진 주요 프로젝트에서 장거리 여행을위한 편안한 언어가됩니다.</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">이 언어는 아름답고 (작고, 우아하며, 최소한) 실제적이지 않고 (사용하기 쉽고, 효율적이며, 완전하게) 사용됩니다. 주요 기능은 사용하기 쉽고 절차 적 및 객체 지향 (OO) 프로그래밍을 모두 지원하며 텍스트 처리를위한 강력한 내장 지원 기능을 갖추고 있으며 세계에서 가장 인상적인 타사 모듈 모음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">사용 된 언어는 loc_lang 호출에서 선택됩니다. 조회가 불가능하면 i- 기본 언어가 사용됩니다. 조회가 i- 기본 언어가 아닌 경우 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">큰 파일 컴파일 환경은</target>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC에서 표시 할 수있는 가장 큰 코드 포인트는 U + 7FFF_FFFF입니다. 더 큰 값에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 을 수행 하면 런타임 오류 (0으로 나누기와 유사한)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC에서 표시 할 수있는 가장 큰 코드 포인트는 U + 7FFF_FFFF입니다. 더 큰 값을 문자로 묶으려고하면 런타임 오류 (0으로 나누기와 비슷한)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; ; 로 지정된 마지막 &lt;b&gt;파일 핸들&lt;/b&gt; ; 파일 핸들이 선택되지 않은 경우 &lt;code&gt;STDOUT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">마지막 인수는 항상 파일 부분으로 간주됩니다. 이후 &lt;code&gt;catfile()&lt;/code&gt; 사용 &lt;code&gt;catdir()&lt;/code&gt; 디렉토리 부의 연접 (있는 경우), 상대 및 절대 경로와 관련하여 다음에 해당하는 경우 (상기 참조) :</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">마지막 예는 스레드의 다른 기능을 보여줍니다. 동일한 서브 루틴을 사용하여 여러 스레드를 생성 할 수 있습니다. 각 스레드는 동일한 서브 루틴을 실행하지만 별도의 환경과 잠재적으로 별도의 인수가있는 별도의 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">마지막 예제는 매우 느리고 결과의 정렬을 깨뜨리는 추가 진행 표시기를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">마지막 예는 문자 클래스가 문자의 교대와 유사하다는 것을 나타냅니다. 주어진 문자 위치에서 정규 표현식 일치를 허용하는 첫 번째 대안은 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">마지막 예는 다음을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">마지막 예는 &lt;code&gt;'i'&lt;/code&gt; &lt;b&gt;수정 자&lt;/b&gt; 와의 일치를 보여 주므로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">마지막 예를 보여줍니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 같은 다른 구분 기호를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 및 심지어 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . 작은 따옴표가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 인 경우 정규 표현식과 대체는 작은 따옴표로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">Perl 5.14에 추가 된 위에 나열된 마지막 네 개의 수정자는 문자 세트 규칙을 제어하지만 &lt;code&gt;/a&lt;/code&gt; 는 명시 적으로 지정하려는 유일한 것입니다. 다른 세 개는 다양한 pragma에 의해 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">마지막은 머신 ​​종속 아키텍처에 대해 알고 있기 때문에 특히 유용합니다. &lt;code&gt;lib.pm&lt;/code&gt; 실용적인 모듈은 첫번째 펄의 5.002 릴리스에 포함되었다.</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">나열된 마지막 항목 (이 예에서는 SUNWhea)이 필요한 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">죽은 자식 프로세스를 대신하여 부모 &lt;b&gt;프로세스가&lt;/b&gt; 수행 한 마지막 의식 은 &lt;b&gt;좀비로&lt;/b&gt; 남아 있지 않습니다 . &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 함수 호출을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">마지막 3 개의 슬롯은 최근에 추가 된 것이므로 소스 코드 호환성을 위해 3 개의 플래그 MGf_COPY, MGf_DUP 또는 MGf_LOCAL 중 하나가 mg_flags에 설정된 경우에만 확인됩니다. 이것은 대부분의 코드가 vtable을 5 요소 값으로 계속 선언 할 수 있음을 의미합니다. 이 세 가지는 현재 스레딩 코드에서만 사용되며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">테스트 프로그램이 마지막으로 경과 한 시간 (초).</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">신기원에서 초 단위로 테스트 스위트가 실패한 시간.</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">Part 1의 마지막 주제는 정규 표현식이 Perl 프로그램에서 사용되는 방법을 간략하게 설명합니다. 그것들은 어디에 Perl 문법에 맞습니까?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">마지막 두 개는 조금 까다 롭습니다. 에서 &lt;code&gt;[\$x]&lt;/code&gt; 문자 클래스는 두 멤버가 있으므로, 백 슬래시, 달러 기호를 보호 &lt;code&gt;$&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; . 에서는 &lt;code&gt;[\\$x]&lt;/code&gt; , 백 슬래시가 보호되므로 &lt;code&gt;$x&lt;/code&gt; 변수로서 취급되고, 따옴표 방식으로 치환.</target>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">마지막 두 구성은 대부분의 사람들에게 직관적이지 않은 것처럼 보일 수 있습니다. 첫 번째는 문자열을 반복적으로 증가시키는 반면, 두 번째는 한 번에 많은 양의 메모리를 할당합니다. 일부 시스템에서는 두 번째 시스템이 첫 번째 시스템보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">각 블록의 마지막 두 예는 파이프를 &quot;목록 형식&quot;으로 표시하며 일부 플랫폼에서는 아직 지원되지 않습니다. 일반적으로 플랫폼에 실제 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가있는 경우 (즉, 플랫폼이 Linux 및 MacOS X를 포함하여 Unix 인 경우) 목록 양식을 사용할 수 있습니다. 파이프의 목록 형식을 사용하여 쉘에서 쉘 메타 문자를 해석하지 않고 리터럴 인수를 명령에 전달할 수 있습니다. 그러나 이것은 파이프 열기에서 의도적으로 쉘 메타 문자를 포함하는 명령으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">각 블록의 마지막 두 예는 파이프를 &quot;목록 형식&quot;으로 표시하며 일부 플랫폼에서는 아직 지원되지 않습니다. 일반적으로 플랫폼에 실제 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가있는 경우 (즉, 플랫폼이 Linux 및 MacOS X를 포함하여 Unix 인 경우) 목록 양식을 사용할 수 있습니다. 파이프의 목록 형식을 사용하여 쉘에서 쉘 메타 문자를 해석하지 않고 리터럴 인수를 명령에 전달할 수 있습니다. 그러나 이것은 파이프 열기에서 의도적으로 쉘 메타 문자를 포함하는 명령으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">마지막 두 개는 Perl 5.22에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">후자는 실패한 것에 대한 아이디어를 제공합니다. 또한 스크립트에서 테스트를보다 쉽게 ​​찾을 수 있도록 &quot;간단 지수&quot;를 검색하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">최신</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">최신 Net :: Ping 릴리스는 CPAN에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">최신 Perl 릴리즈 (이 글을 쓰는 시점에서 5.22.0)는 10.3 &quot;Panther&quot;이후의 모든 Mac OS X 버전에서 변경없이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">최신 소스 트리는 cvs를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">최신 버전은 배포가 가장 적고 널리 테스트 된 것일 수 있으므로 릴리스 후 몇 개월을 기다렸다가 위험에 처한 경우 다른 문제가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">최신 버전의 perl에는 더 많은 버그 수정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">후자의 패턴은 콜론과 문자 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;h&lt;/code&gt; 로 구성된 문자 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">이 계층은 binmode (FH) 스택에 포함 할 수 있습니다. 즉,이를 통과하는 바이트를 변환하지 않습니다 (또는 자체적으로 구성하지 않음).</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">레이어가 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">레이어는 open () 또는 binmode () 호출에서 사용하는 순서대로 반환됩니다. &quot;기본 스택&quot;은 운영 체제 및 Perl 버전 및 Perl의 컴파일 타임 및 런타임 구성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">lddlflags 덧셈은 유일한 비정상 비트입니다.</target>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">최고의 &lt;code&gt;+{&lt;/code&gt; 와 &lt;code&gt;{;&lt;/code&gt; 항상 해시 참조 또는 블록을 의미하도록 표현을 명확하게하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">메소드 호출 (또는 화살표) 연산자의 왼쪽은 오브젝트 (또는 클래스 이름)이고 오른쪽은 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">화살표의 왼쪽은 이전 역 참조를 포함하여 참조를 리턴하는 표현식 일 수 있습니다. 참고 &lt;code&gt;$array[$x]&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">왼쪽의 문자는 함수가 호출 된 컨텍스트를 나타내며, &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 는 각각 스칼라 또는 목록 컨텍스트를 의미하고 및를 나타냅니다 &lt;code&gt;.&lt;/code&gt; void context (실제로 스칼라 컨텍스트의 일종)를 의미합니다. 위의 디스플레이 는 스택 덤프를 실행할 때 &lt;code&gt;main::infested&lt;/code&gt; 함수에 있었고 파일의 10 행에서 스칼라 컨텍스트로 호출되었다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">내부 텍스트에서 인수 텍스트를 시작하는 가장 왼쪽 구분 기호 ( &quot;&amp;lt;&quot;여야 함)</target>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">인수 목록이 잘리는 길이는 다음 옵션에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">배열의 길이는 스칼라 값입니다. &lt;b&gt;csh&lt;/b&gt; 에서처럼 &lt;code&gt;$#days&lt;/code&gt; days를 평가하여 @days 배열의 길이를 찾을 수 있습니다 . 그러나 이것은 배열의 길이가 아닙니다. 마지막 요소의 첨자입니다. 일반적으로 0 번째 요소가 있기 때문에 다른 값입니다. &lt;code&gt;$#days&lt;/code&gt; 에 할당하면 실제로 배열의 길이가 변경됩니다. 이런 식으로 배열을 줄이면 값이 잘리지 않습니다. 이전에 단축 된 배열을 늘려도 해당 요소에 있던 값은 복구되지 않습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">필드의 길이는 여러 개의 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;또는 &quot;|&quot;로 필드를 채워서 제공됩니다. 왼쪽 자리 맞추기, 오른쪽 자리 맞추기 또는 가운데 맞춤을 사용하여 숫자가 아닌 필드를 지정하는 문자 일반 필드의 경우 값 (첫 번째 줄 바꿈까지)이 선택한 자리 맞추기에 따라 값을 가져와 인쇄하여 초과 문자를 자릅니다. &quot;...&quot;로 텍스트 필드를 종료하면 값이 잘 리면 3 개의 점이 표시됩니다. 초보적인 여러 줄로 된 텍스트 블록 채우기를 위해 특수 텍스트 필드를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;채우기 모드 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">이름의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">길이 (NAME) 키워드</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">레벨은 다음과 같이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">레벨 상수는 모듈에서 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Perl 모듈 문서의 세부 사항 레벨은 일반적으로 덜 자세하고 더 자세합니다. SYNOPSIS 섹션에는 최소한의 사용 예가 포함되어 있어야합니다 (한 줄의 코드만으로도 가능합니다. 비정상적인 사용 사례 나 대부분의 사용자에게 필요하지 않은 것은 생략). DESCRIPTION은 일반적으로 몇 단락으로 모듈을 광범위한 용어로 설명해야합니다. 모듈의 루틴이나 방법, 긴 코드 예제 또는 기타 심층 자료에 대한 자세한 내용은 다음 섹션에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">더 작은 구성 요소에서 패턴을 작성하여 어휘 분석기를 우회 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">어휘 분석기 는 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 버퍼 에있는 것들에 대한 다양한 &lt;code&gt;char*&lt;/code&gt; 포인터를 유지 합니다. 경우 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; 가 적 재 할당되고,이 포인터의 모든 업데이트해야합니다. 이 작업을 수동으로 시도하지 말고 버퍼를 재 할당해야하는 경우 &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr을&lt;/a&gt; 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">libnetcfg 유틸리티를 사용하여 libnet을 구성 할 수 있습니다. perl 5.8부터 libnet은 표준 Perl 배포의 일부이지만 libnetcfg는 모든 libnet 설치에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">지정된 라이브러리는 정적 라이브러리와 가져 오기 라이브러리 (DLL과 링크하기 위해)를 혼합 한 것일 수 있습니다. 두 종류 모두 Win32 플랫폼에서 매우 투명하게 사용되기 때문에 두 종류를 구별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">마지막으로로드 된 라이브러리가 사용됩니다. 다른 라이브러리를로드하여 언제든지 덮어 쓸 수 있으며 다른 라이브러리로 구성된 숫자는 수학 연산에서 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">배포 라이센스 조건. 일반적으로 Perl과 동일한 라이센스의 경우 &quot;perl_5&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">위의 줄은 현재 사용중인 버킷의 제한을 설명합니다. 각 버킷에는 메모리 공간과이 버킷에 맞는 최대 사용자 데이터 크기라는 두 가지 크기가 있습니다. 위의 예에서 가장 작은 버킷의 크기는 4라고 가정합니다. 가장 큰 버킷의 크기는 8188이고 메모리 사용량은 8192입니다.</target>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">오류가 발생한 줄 번호</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">표시된 행은 &lt;b&gt;다음&lt;/b&gt; 에 실행될 &lt;b&gt;예정&lt;/b&gt; 이며 아직 발생하지 않았습니다. 따라서 문자 ' &lt;b&gt;p&lt;/b&gt; '를 사용하여 변수를 인쇄 할 수 있지만 이 시점에서 얻을 수있는 것은 빈 (정의되지 않은) 값입니다. 우리가해야 할 일은 ' &lt;b&gt;s&lt;/b&gt; '로 다음 실행 문을 단계별로 실행하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">클래스의 선형화 된 MRO는 클래스 자체에서 시작하여 해당 클래스의 메소드를 해석 할 때 검색 할 모든 클래스의 정렬 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">발견 된 링크는 &lt;a href=&quot;../perlpod&quot;&gt;perlpod에&lt;/a&gt; 설명 된 구문을 따르지 않으므로 구문 분석 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">링크 텍스트 없는 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이어야합니다 . (예 : &quot;L &amp;lt;Perl Functions | perlfunc&amp;gt;&quot;에서 링크 텍스트는 &quot;Perl Functions&quot;입니다. &quot;L &amp;lt;Time :: HiRes&amp;gt;&quot;및 &quot;L &amp;lt;| Time :: HiRes&amp;gt;&quot;에는 없습니다. 링크 텍스트에는 서식이 포함될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">목록이 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">두 번째 인수의 목록은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">일부 장소에서는 목록이 불완전하거나 잘못되었을 수 있습니다. 확실하지 않은 경우 Perl 소스 배포판의 플랫폼 별 README 파일 및 지정된 포트와 함께 제공되는 기타 설명서 리소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">시스템이 &lt;b&gt;실행&lt;/b&gt; 하려는 프로그램을 찾기 위해 검색하는 &lt;b&gt;디렉토리&lt;/b&gt; 목록 . 이 목록은 Perl에서 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 로 액세스 할 수있는 &lt;b&gt;환경 변수&lt;/b&gt; 중 하나로 저장됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">이 모듈이 지원하는 기능 목록.</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">다시 컴파일해야 할 함수 목록은 creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev입니다. , tmpfile, 잘라 내기, getrlimit, setrlimit</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">Perl 만 필요한 라이브러리 목록 (동적 로딩을 사용하는 경우 확장에 필요한 모든 라이브러리 만 삭제됨).</target>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">중재자 목록은 공개 지식이됩니다. 현재는 Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller입니다.</target>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">출력 매개 변수 목록은 함수의 마지막에서 OUTPUT : 지시문 바로 다음에 발생합니다. RETVAL을 사용하면 Perl에게이 값을 XSUB 함수의 리턴 값으로 다시 보내려고합니다. 예제 3에서는 전달한 원래 변수에 &quot;반환 값&quot;을 배치하려고하므로 OUTPUT : 섹션에 RETVAL이 아닌 RETVAL이 나열되었습니다.</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">서브 필드 목록은 다음 형식 중 하나로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">등록 된 CPAN 사이트 목록은 다음과 같습니다. 정렬 순서는 필드에서 알파벳순입니다.</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">유효한 옵션 목록은 다음과 같습니다. 지정되지 않은 옵션은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 로 열린 목록 에는 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">리스트 참조는 다음과 같은 패턴을 지정하는 하나 이상의 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">목록 참조는 반드시 패턴을 지정하는 하나 이상의 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">아래 목록은 알파벳 순서이며 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">목록은 (거의) 순서가 정해 지므로 가장 선호되는 이름이 덜 선호되는 이름 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">정규식의 리터럴 문자열은 변수로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">regexp의 리터럴 문자열은 변수로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">출력 할 리터럴 문자열. 숫자로 시작하고 선택적인 '*'로 시작하면 패딩에이 숫자에 비해 금액이 증가합니다. '*'가 있으면이 금액에 $ cnt가 곱해집니다. $ string의이 부분은 출력 /</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변환되는 리터럴은 &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; 이며 v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 시작 합니다. 변환을 수행하는 연산에는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;utf8::upgrade&lt;/code&gt; ( &lt;code&gt;utf8::downgrade&lt;/code&gt; 아님) 및 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;운영 체제에서&lt;/b&gt; 말하는 열린 &lt;b&gt;파일&lt;/b&gt; 을 추적하는 데 사용하는 작은 숫자 입니다. Perl은 &lt;b&gt;표준 I / O&lt;/b&gt; 스트림 내부에서 파일 디스크립터를 숨기고 스트림을&lt;b&gt; 파일 핸들에&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">dl_load_file ()이 호출하는로드 함수에는 절대 경로 이름이 필요할 수 있습니다. dl_findfile () 함수 및 @dl_library_path를 사용하여로드하려는 라이브러리 / 객체의 절대 경로 이름을 검색하고 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">로드 된 모듈은 IO :: Handle, IO :: Seekable, IO :: File, IO :: Pipe, IO :: Socket, IO :: Dir입니다. 대신 원하는 IO 모듈을 명시 적으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">전역 이름을 완전히 규정하지 않고 만지므로 local ()에서 컴파일 타임 오류를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">localeconv 기능</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">잠금 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">감마 함수의 로그 [C99].</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; 의 논리는 다음 에 자세히 설명되어 있습니다.&lt;a href=&quot;encoding&quot;&gt; encoding에&lt;/a&gt; 있지만 간단히 nl_langinfo (CODESET)를 시도한 다음 LC_ALL 및 LANG 로케일 환경 변수를 추측합니다.</target>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">어떤 로케일을 찾는 논리 &lt;code&gt;:locale&lt;/code&gt; 사용 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">형식을 끝내는 고독한 점은 잘못 구성된 인터넷 메일러를 통과하는 메일 메시지를 조기에 종료 할 수도 있습니다 (경험에 따라 이러한 잘못된 구성은 예외가 아닌 규칙입니다). 따라서 메일을 통해 형식 코드를 보낼 때는 형식 끝 점이 왼쪽 여백에 있지 않도록 들여 쓰기를해야합니다. 이렇게하면 SMTP 차단이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">외로운 대쉬</target>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">긴 대답은 &quot;그것에 달려있다&quot;는 것이며, (적어도) 언어 문맥을 알지 못하면 좋은 대답을 할 수 없습니다. 참조 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: 부씩 인쇄를&lt;/a&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">긴 대답은 문자 정규화 및 대소 문자 문제를 고려해야한다는 것입니다. &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; , 유니 코드 기술 보고서 ​​# 15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;유니 코드 표준화 양식&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;유니 코드 표준의&lt;/a&gt; 사례 매핑 섹션을 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">긴 대답은 나머지 맨 페이지입니다 :-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">긴 이름은 대문자로 잘 인쇄 된 형태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">lookahead 및 lookbehind 어설 션은 앵커 개념의 일반화입니다. Lookahead와 Lookbehind는 테스트 할 문자를 지정할 수있는 폭이 0 인 어설 션입니다. 미리보기 어설 션은 &lt;code&gt;(?=regexp)&lt;/code&gt; 로 표시되고, 미리보기 어설 션은 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 로 표시됩니다. . 몇 가지 예는</target>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">뒤돌아보기 &lt;code&gt;condition&lt;/code&gt; 은 역 참조와 함께 매치의 초기 부분이 매치의 후반부에 영향을 줄 수 있도록합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">루프는 잠시 동안 옳은 일을하지만 예기치 않게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">루프는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">낮은 수준의 스택은 낮은 수준의 운영 체제 호출 (C의 파일 디스크립터)이 바이트를 가져오고 나가고, 스택 버퍼의 높은 계층은 I / O를 필터링 및 조작하고, 문자를 반환하고 (또는 바이트) 펄에. 자귀</target>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">하위 루프는</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">lvalue &lt;code&gt;$ref&lt;/code&gt; 는 약한 참조로 바뀝니다 . 이는 참조하는 객체에 대한 참조 횟수를 보유하지 않음을 의미합니다. 또한 해당 객체의 참조 횟수가 0에 도달하면 참조가 undef로 설정됩니다. 이 함수는 인수로 전달 된 lvalue를 변경하고 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">lvalue &lt;code&gt;REF&lt;/code&gt; 는 약한 참조에서 다시 정상 (강한) 참조로 바뀝니다. 이 함수는 인수로 전달 된 lvalue를 변경하고 값을 반환하지 않습니다. &lt;a href=&quot;#weaken&quot;&gt;약화로&lt;/a&gt; 수행 된 작업을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">이 대상을 스택에 배치하는 매크로는 &lt;code&gt;PUSHTARG&lt;/code&gt; 이며 일부 opcode에서 직접 사용되며 다른 일부에서는 간접적으로 사용되며 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 를 통해이를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">PERL_SYS_INIT3 () 및 PERL_SYS_TERM () 매크로는 Perl 인터프리터를 실행하는 데 필요한 C 런타임 환경의 시스템 특정 조정을 제공합니다. 얼마나 많은 통역사를 만들거나 파괴하든 관계없이 한 번만 호출해야합니다. 첫 번째 인터프리터를 작성하기 전에 PERL_SYS_INIT3 ()을 호출하고 마지막 인터프리터를 해제 한 후 PERL_SYS_TERM ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">이러한 유형의 오류 전파를 단순화하는 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">파이프와 통신하기 위해 perl이 작성할 수있는 메일 함 (MBX)은 기본적으로 64 비트 시스템에서 버퍼 크기는 8192, VAX에서는 512입니다. 기본 버퍼 크기는 논리 이름 PERL_MBX_SIZE를 통해 조정 가능하며 값이 128과 SYSGEN 매개 변수 MAXBUF를 포함하는 경우. 예를 들어, 사서함 크기를 32767으로 설정하려면 &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; 파이프 구조를 열고 사용하십시오. 대안은 다음 명령을 발행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">&lt;code&gt;$^V&lt;/code&gt; 비해 &lt;code&gt;$]&lt;/code&gt; 의 주요 장점은 모든 버전의 Perl에서 동일하게 작동한다는 것입니다. 단점은 다른 형식의 버전 (예 : 리터럴 v- 문자열, &quot;v1.2.3&quot;또는 버전 객체)과 쉽게 비교할 수없고 숫자 비교가 때때로 실패 할 수 있다는 것입니다. 문자열 리터럴 버전 검사에 적합하며 온 전성 검사되지 않은 변수와 비교하기에는 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">의 가장 큰 장점 &lt;code&gt;$^V&lt;/code&gt; 이상 &lt;code&gt;$]&lt;/code&gt; 는 펄 v5.10.0에 대한, 즉 이상, 다른 버전의 표현에 대하여 쉽게 비교할 수 있도록, 연산자를 오버로드 (예를 들어 진수, 문자 V-문자열, &quot;v1.2.3&quot;를, 또는 객체) . 단점은 v5.10.0 이전에는 문자 그대로의 v- 문자열이므로 쉽게 인쇄하거나 비교할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 버전 2.x 의 주요 변경 사항은 이제 zlib 라이브러리에 직접 인터페이스되지 않는다는 것입니다. 대신 gzip 파일 읽기 / 쓰기를 위해 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 모듈을 사용 하고 일부 저수준 zlib 액세스를 위해 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">이 형식의 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드와 이전 메소드 의 주요 차이점은이 메소드가 리턴하려고 시도한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">사용하여 코드의 주요 차이점 &lt;code&gt;LimitOutput&lt;/code&gt; 이 를 Where 경우 처리하는 데 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 여전히 몇 가지 압축되지 않은 데이터를 포함 &lt;code&gt;inflate&lt;/code&gt; 아직 처리되지 않았습니다. 에서 반환 된 상태 코드 &lt;code&gt;inflate&lt;/code&gt; 될 것입니다 &lt;code&gt;Z_OK&lt;/code&gt; 을 압축 해지가 장소와했다 경우 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 를 출력 버퍼가 가득합니다.</target>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">표준 DBM 필터 후크에 대한 주요 개선 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Perl의 문서에 대한 주요 인터페이스는 &lt;code&gt;perldoc&lt;/code&gt; 입니다 .이 글을 읽고 있다면 이미 찾은 것보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">코드의 기본 처리 루프는 STDIN에서 압축 된 데이터 읽기를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">주요 제한 사항은 모든 것이 메타 문자라는 것입니다. 따라서 다음과 같은 방법으로 단일 문자를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">주요 실행 시간, 실행, 즉 &lt;code&gt;PL_main_root&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">Perl을 비교할 때 명심해야 할 주요 사항</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">주요 두 표준 설치 프로그램 모듈은 Makefile.PL을 사용하는 오래되고 잘 확립 된 ExtUtils :: MakeMaker (약칭 : EUMM)입니다. 그리고 Build.PL과 함께 작동하는 차세대 설치 프로그램 Module :: Build (MB) (그리고 종종 Makefile.PL도 함께 제공됨). 모듈에 둘 중 하나만 제공되는 경우 해당 모듈을 사용하지만 둘 다 제공되는 경우 EUMM과 MB간에 결정을 내려야합니다. 올바른 기본값에 대한 설명은 &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; pass-through 기능 의 주된 용도는 다른 서브 루틴을 호출하는 것이 주요한 서브 루틴을 작성하는 것입니다. 자세한 내용은 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">현대 Perl에서 typeglob의 주요 용도는 심볼 테이블 별칭을 만드는 것입니다. 이 과제 :</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">이 작업을 수행하는 주요 방법은 솔루션을 Perl 모듈로 추상화하는 것입니다. 이 중 하나가 무엇인지 모른다면이 문서의 나머지 부분은 그다지 유용하지 않을 것입니다. 또한 유용한 코드가 많이 빠져 있습니다. 살펴 고려해 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; , &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 및 &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall을&lt;/a&gt; 여기로 오기 전에.</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">주된 일꾼. 이것은 키메라 실행 파일입니다. &lt;code&gt;a.out&lt;/code&gt; 스타일 실행 파일 로 컴파일 되지만 &lt;code&gt;omf&lt;/code&gt; 스타일 동적 라이브러리 와 연결됩니다</target>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">주요 헤더는 &lt;code&gt;=head1&lt;/code&gt; 지시문을 사용하여 설정해야하며 역사적으로 다소 놀라운 ALL UPPER CASE 형식으로 작성되었습니다. 이것은 필수 사항은 아니지만 섹션이 다른 소프트웨어 패키지에서 일관된 이름을 갖도록하는 것이 좋습니다. 마이너 헤더는 &lt;code&gt;=head2&lt;/code&gt; 를 사용하여 포함될 수 있으며 일반적으로 대소 문자를 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">Perl의 작성자가 작성한 Perl에 대한 주요 참조서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">위의 첫 세 분류 (W, D &amp;amp; S)에서 온 대부분의 메시지는 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">make 프로세스는 Perl 확장을 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">make 프로세스는 WinNT 셸에서만 실행됩니다. NetWare makefile은 NetWare 폴더 아래에 있습니다. 이것은 miniperl.exe를 사용하여 일부 Perl 스크립트를 실행합니다. miniperl.exe를 만들려면 먼저 명령 프롬프트에서 Visual c ++ 컴파일러의 필수 경로 (vcvars32 위치 지정)를 설정하십시오. 그런 다음 WinNT 명령 프롬프트를 통해 win32 폴더에서 nmake를 실행하십시오. miniperl.exe를 만든 후에 빌드 프로세스를 중지 할 수 있습니다. 그런 다음 WinNT 명령 프롬프트를 통해 NetWare 폴더에서 nmake를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">/ usr / ccs / bin 아래의 make는 perl을 빌드하는 데 적합합니다. Sun C 컴파일러가있는 경우 병렬 버전의 make (dmake)도 있습니다. 이것은 perl을 빌드하는 데 잘 작동하지만 다른 테스트 하네스 파일 사이의 종속성이 지정되지 않아 'make test'를 실행할 때 문제가 발생할 수 있습니다. 같은 문제가 일부 애드온 모듈의 빌드에도 영향을 줄 수 있으므로 이러한 경우 dmake 명령 줄에 '-m serial'을 지정하거나 / usr / ccs / bin / make를 대신 사용하십시오. GNU make를 사용하려면 set-group-id 비트가 설정되어 있지 않은지 확인하십시오. 그렇다면 / usr / ccs / bin / make가 GNU make 앞에 오거나 시스템 관리자가 GNU make에서 set-group-id 비트를 비활성화하도록 PATH를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">Win32 용 makefile은 NetWare 용 makefile을 작성하기위한 참조로 사용됩니다. 또한 NetWare 포트의 작성 프로세스는 miniperl.exe를 사용하여 작성 및 설치 프로세스 중에 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">매크로 세트를 문서화하는 매뉴얼 페이지는</target>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">man 매크로 세트를 문서화하는 man 페이지는</target>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">필수 매개 변수 &lt;code&gt;$input&lt;/code&gt; 은 압축 된 데이터의 소스를 판별하는 데 사용됩니다. 이 매개 변수는 세 가지 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">필수 매개 변수 &lt;code&gt;$output&lt;/code&gt; 은 압축 된 데이터의 대상을 제어하는 ​​데 사용됩니다. 이 매개 변수는 다음 양식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">GNU &lt;code&gt;gettext&lt;/code&gt; 매뉴얼 . gettext dist는 &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; 에서 사용할 수 있습니다 . 최근 gettext tarball을 가져 와서 &quot;doc /&quot;디렉토리를 보면 쉽게 찾아 볼 수있는 HTML 버전이 있습니다. gettext 문서는 일부 답변이 때로는 기발한 경우에도, 특히 복수화에 대해 이야기하기 시작할 때 생각할 가치가있는 많은 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">많은 &lt;code&gt;SO_*&lt;/code&gt; 및 기타 상수는 getsockopt () 및 setsockopt ()에 대한 소켓 옵션 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">사용하는 태그 대 이름의 맵은 % I18N :: LangTags :: List :: Name으로 액세스 할 수 있으며이 문서의 다음에 나오는 목록과 동일합니다. 이 모듈을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">이번에는 C 콜백과 Perl 간의 &lt;code&gt;Mapping&lt;/code&gt; 이 전역 해시 매핑에 저장됩니다 . 해시를 사용하면 무제한의 콜백을 등록 할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">C 콜백과 Perl에 상응하는 매핑은 전역 변수 &lt;code&gt;callback&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">&lt;code&gt;U+FFFD&lt;/code&gt; 의 매핑은 유니 코드 6.3.0에서 수정되었습니다. &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights(7.1.4&lt;/a&gt; 트레일 웨이트)를 참조 하십시오 . 이러한 수정은 이것에 의해 재현됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">거의 모든 속성에 대한 맵은 그대로 해석해야하는 간단한 스칼라입니다. 이러한 값은 유니 코드 제공 데이터 파일에 제공된 값으로, 대문자와 속성 값의 동의어가 일치하지 않을 수 있습니다. 를 사용하여 결과를 정규화 할 수 있습니다.&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">Perl 코드에 문서를 포함시키는 데 사용되는 마크 업입니다. 포드는 &quot;일반 문서화&quot;를 나타냅니다. 낙타 23 장 &quot;일반 문서&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">CPAN의 마스터 웹 사이트는 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html입니다.&lt;/a&gt; 은 모든 미러를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">경기는 욕심 많고 역 추적이 아니므로 클러스터가 더 작은 구성 요소로 나뉘 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">일치 연산자는 &quot;~&quot;가 아니라 &quot;= ~&quot;입니다. ( &quot;~&quot;는 C에서와 같이 보수 연산자입니다.)</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">일치 연산자는 큰 따옴표 컨텍스트이므로 큰 따옴표로 묶은 문자열처럼 변수를 보간 할 수 있습니다. 이 경우 정규식을 사용자 입력으로 읽고 &lt;code&gt;$regex&lt;/code&gt; 저장합니다 . &lt;code&gt;$regex&lt;/code&gt; 패턴이 있으면 일치 연산자에서 해당 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일치 연산자 &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">일치 연산자 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 정규 표현식 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">한 번만 일치하는 동작은 일치 구분 기호가 &lt;code&gt;?&lt;/code&gt; ; 다른 구분 기호를 사용하면 이것은 정상적인 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">일치 패턴 변수 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (사전 일치), &lt;code&gt;$'&lt;/code&gt; (사후 일치) 및 &lt;code&gt;$+&lt;/code&gt; (마지막 일치)도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">인코딩 이름의 일치가 느슨합니다. 대소 문자는 중요하지 않으며 많은 인코딩에는 여러 개의 별칭이 있습니다. 있습니다 &lt;code&gt;:utf8&lt;/code&gt; 층이 항상 똑같이 지정해야합니다; 그것은</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">인코딩 이름의 일치가 느슨합니다. 대소 문자는 중요하지 않으며 많은 인코딩에는 여러 개의 별칭이 있습니다. 자세한 내용과 지원되는 로캘 목록은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">아래 자료는 세 가지 주요 섹션으로 나뉩니다. 주요 이식성 &lt;a href=&quot;#ISSUES&quot;&gt;문제&lt;/a&gt; ( ISSUES ), 플랫폼 별 문제 ( &lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt; ) 및 다양한 포트에서 다르게 동작하는 내장 된 Perl 기능 ( &lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;기능 구현)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">최대 유니 코드 코드 포인트는 &lt;code&gt;U+10FFFF&lt;/code&gt; 이며 유니 코드는이를 통해 코드 포인트에 대한 작업 만 정의합니다. 그러나 Perl은 플랫폼에서 사용 가능한 최대 허용 부호없는 수까지 코드 포인트에서 작동합니다. 그러나 Perl은 lax 규칙을 사용하지 않는 한 입력 스트림에서 이들을 허용하지 않으며 출력되는 경우 경고 범주 ( &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; ( &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 하위 범주 ) 사용)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">언제든지 실행할 최대 병렬 테스트 수입니다. 병렬로 실행할 수있는 테스트는 &lt;code&gt;rules&lt;/code&gt; 의해 제어됩니다 . 기본값은 한 번에 하나의 테스트 만 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">이 구문이 표현할 수있는 최대 개수는 &lt;code&gt;\777&lt;/code&gt; 입니다. 더 큰 것이 필요하면 대신 &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt; 를 사용해야 합니다. 별개의 두 가지를 의미하는 경우 두 가지를 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Storable 헤더의 최대 크기는 현재 21 바이트입니다. 제공된 $ buffer가 Storable 이미지의 첫 번째 부분 일 경우 read_magic ()이이를 인식 할 수 있도록 최소한이 길이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">추가 필드의 최대 크기는 65535 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">추가 필드 65535 바이트의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">최대 시스템 파일 디스크립터, 일반적으로 2입니다. 시스템 파일 디스크립터는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 프로세스 로 전달 되지만 더 높은 파일 디스크립터는 전달되지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 이 실패 하더라도 시스템 파일 디스크립터는 유지됩니다 (일반 파일 디스크립터는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 시도). 파일 디스크립터의 close-on-exec 상태는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 시간이 아니라 해당 파일, 파이프 또는 소켓이 열렸을 때 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 결정됩니다. .</target>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 의 번역 메커니즘 이스케이프 은 일반적이며</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">이름이 &lt;code&gt;int_p_&lt;/code&gt; 및 &lt;code&gt;int_n_&lt;/code&gt; 로 시작하는 멤버 으로 POSIX.1-2008에 의해 추가되었으며 를 지원하는 시스템에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">메시지를 통해 전송 &lt;code&gt;datasend&lt;/code&gt; 또는 &lt;code&gt;MESSAGE&lt;/code&gt; 매개 변수 로 는 RFC822에 설명 된 형식이어야하며 From :, Newsgroups : 및 Subject : 헤더를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">메시지는 대문자 또는 소문자와 상관없이 알파벳 순서로되어 있습니다. 이러한 메시지 중 일부는 일반적인 것입니다. 다양한 스팟은 % s 또는 다른 printf 스타일 이스케이프로 표시됩니다. 이스케이프는 문자 이외의 모든 문자와 마찬가지로 알파벳 순서로 무시됩니다. 메시지를 찾으려면 글자가 아닌 것을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">Perl 코어 내부의 오류 엑시트 메시지는 일반적으로 더 심각하며 억제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">메타 설정 시스템에는 자체 자식 저장소가 있습니다. &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; 의 README 파일을 참조 하십시오 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">메타 노테이션 &lt;code&gt;a{b,c,d}e&lt;/code&gt; 는 &lt;code&gt;abe ace ade&lt;/code&gt; 의 약자입니다 . 왼쪽에서 오른쪽 순서는 유지되며 일치하는 결과는이 순서를 유지하기 위해 낮은 수준에서 개별적으로 정렬됩니다. 특별한 경우로 &lt;code&gt;{&lt;/code&gt; , &lt;code&gt;}&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt; 은 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">&lt;b&gt;단순화&lt;/b&gt; _ 이름 방법 은 &lt;b&gt;basename&lt;/b&gt; 과 동일 하지만 Perl과 유사한 확장자 (.pm, .pl, .pod)와 같은 확장자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">방법은 &lt;code&gt;pretty&lt;/code&gt; 는 연산자를 오버로드 자연하므로, 객체를 문자열로 변환하고있다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 방법을 사용. 그러나 그러한 방법 내에서 예쁘게 인쇄 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">방법 &lt;code&gt;survey&lt;/code&gt; 는 주어진 파일 및 / 또는 디렉토리 세트에서 POD 문서를 검색합니다. 위의 접근자가 설정 한 다양한 옵션에 따라 검색을 실행합니다. 예를 들어, &lt;code&gt;inc&lt;/code&gt; 속성이 켜져있는 경우 기본적으로 perl @INC 디렉토리는 사용자가 지정한 디렉토리 목록 (있는 경우)에 내재적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">메소드 폼은 인자와 함께 호출 될 때 객체 자체를 반환하므로 서로 잘 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 스칼라 인스턴스를 지정된 클래스와 연관시킵니다. &lt;code&gt;LIST&lt;/code&gt; 는 추가 인수를 나타냅니다 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 행과 함께 연결을 완료하는 데 필요한 및 compatriots .</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 해시 인스턴스를 지정된 클래스와 연결합니다. &lt;code&gt;LIST&lt;/code&gt; 는 연결을 완료하는 데 필요한 추가 인수 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 및 compatriots 행)를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; 명령으로 호출 된 메소드 . 새 glob 인스턴스를 지정된 클래스와 연관시킵니다. &lt;code&gt;LIST&lt;/code&gt; 는 추가 인수를 나타냅니다 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 행과 함께 연결을 완료하는 데 필요한 및 compatriots .</target>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">이 메소드는 함수 (이것은 레거시 인터페이스 임)로 호출 될 수 있으며 단일 톤을 호출자로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UNTIE&lt;/code&gt; 및 &lt;code&gt;DESTROY&lt;/code&gt; 메소드 는 &lt;b&gt;Tie :: Hash&lt;/b&gt; , &lt;b&gt;Tie :: StdHash&lt;/b&gt; 또는 &lt;b&gt;Tie :: ExtraHash에&lt;/b&gt; 정의되어 있지 않습니다 . 묶음 해시는 이러한 메소드가 필요하지 않지만 정의 된 경우 적절한 시간에 메소드가 호출됩니다 ( &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">해당 (그러나 소문자) 이름을 가진 perl 연산자가 연결된 배열에서 작동하려면 POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE 및 EXISTS 방법이 필요합니다. &lt;b&gt;타이 :: 배열&lt;/b&gt; 클래스는 위의 기본적인 방법의 측면에서 이들의 처음 다섯을 구현하는 기본 클래스로 사용할 수 있습니다. &lt;b&gt;Tie :: Array&lt;/b&gt; 에서 DELETE 및 EXISTS의 기본 구현은 간단하게 &lt;code&gt;croak&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일과 관련된 메소드에는 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">이 방법은 하루 24 시간, 주 7 일, 1 년 365.24225 일, 1 년에 12 개월이 있다고 가정합니다. ( &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt; 의 캘린더 FAQ에서 )</target>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">이 패키지에서 제공하는 방법은 ExtUtils :: MakeMaker와 함께 사용하도록 설계되었습니다. MakeMaker가 Makefile을 작성할 때 패키지 &lt;code&gt;MM&lt;/code&gt; 에서 메소드를 상속하는 하나 이상의 오브젝트를 작성합니다. . MM 자체는 메서드를 제공하지 않지만 ISA ExtUtils :: MM_Unix 클래스입니다. MM의 상속 트리를 사용하면 특정 패키지를 운영 할 때 MM_Unix에서 제공하는 모든 방법을 책임집니다. ExtUtils :: MM_Unix 내에서 다소 원시적 인 작업을 정의하여 필요한 재정의 횟수를 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">메소드는 상태 값을 리턴합니다. 성공하면 모두 0을 반환합니다. 모두 -1을 반환하여 오류를 나타내고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . 정확한 오류 코드. 리턴 코드 1은 일반적으로 (항상 그런 것은 아님) 지정된 키가 데이터베이스에 존재하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">인수가 각각 양수 또는 음수이면 메소드는 true를 리턴합니다. &lt;code&gt;NaN&lt;/code&gt; 은 양수도 음수도 아닌 반면 &lt;code&gt;+inf&lt;/code&gt; 는 양수로 계산되며 &lt;code&gt;-inf&lt;/code&gt; 는 음수입니다. &lt;code&gt;zero&lt;/code&gt; 도 긍정적이나 부정적이다.</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">런던과 도쿄의 중간 점</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">&lt;code&gt;MyMaths&lt;/code&gt; 패키지의 최소 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">경기의 최소 길이입니다.</target>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">문자열의 시작을 모두 수행 할 최소한의 문자열 &lt;code&gt;^&lt;/code&gt; 매치에 교대는 &lt;code&gt;Th&lt;/code&gt; 배타로, &lt;code&gt;e|r&lt;/code&gt; 일치하는 &lt;code&gt;e&lt;/code&gt; . 두 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 나머지 문자열을 자유롭게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">이 배포에 필요한 Perl의 최소 필수 버전입니다.</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 모드 에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 설정 한 최소 심각도 수준 은 테스트 결과 및 추가 검토 결과에 따라 향후 ERROR 이상으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">패턴이 일치하는 데 필요한 최소 문자열 길이 (문자)입니다. 일치하는 것을 허용하는 것보다 문자열의 끝에 더 가깝게 일치시키지 않고 검색 공간을 제거하는 데 사용됩니다. 예를 들어 minlen이 10이지만 문자열 길이가 5자인 경우 정규식 엔진을 시작할 때조차 아무런 의미가 없습니다. 패턴이 일치 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">mkpath () 함수는 make_path ()의 레거시 인터페이스에 전달 된 인수에 대한 다른 해석을 제공합니다. 함수의 동작 및 반환 값은 그렇지 않으면 make_path ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">모드 인수는 fopen / PerlIO_open에 전달 될 문자열이어야합니다. NULL 인 경우-레거시 지원의 경우-플랫폼 및 구현에 따라 코드는 경험적으로 모드를 결정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">OO 모듈에 대한 최신 규칙은 항상 &lt;code&gt;new&lt;/code&gt; 를 생성자의 이름으로 사용하는 것이지만 그렇게 할 필요는 없습니다. 데이터 구조를 클래스로 축복하는 모든 서브 루틴은 Perl의 유효한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">모듈</target>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">이 모듈은 실제로 perl5-porters 메일 링리스트에서 Larry Wall이 설명하는 대부분의 인터페이스를 구현합니다. &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">이 모듈을 사용하면 중간 SHA 상태를 문자열에 저장할 수도 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">모듈과 그 사용자는 계약을 가지고 있으며, 그 중 일부는 관습법이며 일부는 &quot;작성&quot;되어 있습니다. 관습법 계약의 일부는 모듈이 요청하지 않은 네임 스페이스를 오염시키지 않는다는 것입니다. 모듈에 대한 서면 계약 (AKA 문서)은 다른 조항을 만들 수 있습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용할&lt;/a&gt; 때 세상을 재정의하고 결과를 기꺼이 감수한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">현재 OS에 적합한 모듈은 File :: Spec에 의해 자동으로로드됩니다. VMS와 같은 일부 모듈은 해당 OS에서만 사용 가능한 기능을 사용하므로 모든 운영 체제에서 모든 모듈을로드하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">모듈 작성자는 &lt;code&gt;autodie&lt;/code&gt; 가 어떻게 당신의 인생을 더 좋게 (또는 더 나쁘게) 만들 었는지 듣고 싶어 합니다. 피드백은 &amp;lt;pjf@perltraining.com.au&amp;gt;로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">모듈 기능은 기호 참조를 사용하므로 '엄격한 &quot;참조&quot;도 지정하지 않으면'엄격한 사용 '에서 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">이 모듈은 일반적인 UNIX 명령을 대체하는 데 사용됩니다. 모든 경우에 함수는 인수를 취하는 것이 아니라 @ARGV에서 작동합니다. 이렇게하면 Makefile에서 다루기가 더 쉬워집니다. 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">모듈은 다음 경고를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">캔 필터를 구현하는 모듈은 두 가지 형식 중 하나를 취할 수 있습니다. 첫 번째 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">모듈은 지원되는 압축 형식 중 어떤 것이 사용되는지 자동 감지합니다.</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">월 ( &lt;code&gt;mon&lt;/code&gt; ), 요일 ( &lt;code&gt;wday&lt;/code&gt; ) 및 연도 ( &lt;code&gt;yday&lt;/code&gt; )는 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">빼기에는 월과 년이 음수 일 수 있습니다. 월말에 월을 더하거나 뺄 때 &quot;이상한&quot;동작이 있습니다. 일반적으로 결과 월이 시작 월보다 짧으면 겹치는 일 수가 추가됩니다. 예를 들어 2008-03-31에서 월을 빼면 불가능한 날짜이므로 2008-02-31이되지 않습니다. 대신 2008-03-02가 나옵니다. 이것은 다른 날짜 조작 도구와 일치하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">두 언어 사이의 인터페이스에 대해 더 많이 생각할수록 대부분의 프로그래머 노력은 관련된 언어 중 하나에 고유 한 데이터 구조 사이를 변환해야한다는 사실을 더 많이 깨닫게됩니다. 이것은 문제 공간이 훨씬 크기 때문에 다른 호출 규칙과 같은 다른 문제보다 우선합니다. 함수 호출을 구현하는 방법보다 데이터를 메모리에 저장하는 방법이 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">필멸의 일상은 단지 SV를위한 것이 아닙니다. AV 및 HV는 주소 ( &lt;code&gt;SV*&lt;/code&gt; 유형 캐스트 ​​됨 )를 &lt;code&gt;sv_2mortal&lt;/code&gt; 또는 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 루틴 으로 전달하여 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">가장 일반적인 CPAN 버전 번호 체계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">가장 일반적인 예는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 사용하여 현재 작업 디렉토리를 변경하는 것 입니다. 하나의 스레드는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 호출 하고 모든 스레드의 작업 디렉토리가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">대화식 모드의 가장 일반적인 용도는</target>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">이러한 기능 중 가장 일반적으로 사용되는 것은 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 입니다 . SV, AV, HV 및 CV를 덤프하는 데 사용됩니다. &lt;code&gt;Devel::Peek&lt;/code&gt; 모듈 호출 &lt;code&gt;sv_dump&lt;/code&gt; 해당 모듈의 사용자가 이미 포맷에 대해 잘 알고 있어야하므로, 펄 공간에서 디버깅 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">펄의 바이너리 배포판을 설치하는 가장 편리한 방법은 펄 설치 프로그램을 이용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">가장 효율적인 방법은 &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 및 &lt;a href=&quot;functions/unpack&quot;&gt;unpack을 사용하는 것&lt;/a&gt; 입니다. 많은 문자열을 사용할 때 &lt;a href=&quot;functions/substr&quot;&gt;substr을&lt;/a&gt; 사용하는 것보다 빠릅니다 . 몇 분만 더 느립니다.</target>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">가장 털이 많은 경우</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">가장 중요한 Perl 구문 분석 규칙은 아래에 논의 된 첫 번째 규칙입니다. 인용 된 구문을 처리 할 때 Perl은 먼저 해당 구문의 끝을 찾은 다음 그 내용을 해석합니다. 이 규칙을 이해하면 첫 번째 읽을 때이 섹션의 나머지 부분을 건너 뛸 수 있습니다. 다른 규칙은 첫 번째 규칙보다 사용자의 기대와 훨씬 덜 모순 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">전화의 전화 번호와 같은 소켓의 가장 중요한 속성입니다. 일반적으로 IP 주소입니다. &lt;b&gt;port&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">가장 중요한 것은 아마도 GV_ADD와 SVf_UTF8 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">가장 중요한 것은 항상 &lt;b&gt;-w&lt;/b&gt; 플래그로 프로그램을 실행하는 것입니다 . &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;code&gt;$^W&lt;/code&gt; 변수 를 통해 코드의 특정 부분에 대해 명시 적으로 끌 수 있습니다 ( 필요한 경우). 또한 항상 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 그 이유를 알아야합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; , 심지어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; 프라그 마를도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">다차원 배열을 포함하여 Perl의 모든 데이터 구조에 대해 이해해야 할 가장 중요한 것은 비록 다르게 나타날 수 있지만 Perl &lt;code&gt;@ARRAY&lt;/code&gt; 및 &lt;code&gt;%HASH&lt;/code&gt; 는 모두 내부적으로 1 차원이라는 것입니다. 스칼라 값만 보유 할 수 있습니다 (문자열, 숫자 또는 참조를 의미). 다른 배열이나 해시를 직접 포함 할 수는 없지만 대신</target>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">가장 인기있는 책</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">가장 실용적인 용도는 일부 테스트가 &quot;병렬-준비&quot;되지 않았 음을 지정할 수 있습니다. --rules가있는 파일을 언급해도 테스트로 실행되도록 선택되지 않으므로 .proverc 파일에서 일부 규칙 기본 설정을 &quot;설정하고 잊어 버릴 수&quot;있습니다. 그런 다음 병렬 테스트의 성능 이점을 최대한 활용할 수 있지만 일부 예외는 여전히 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">가장 바람직한 것은 유니 코드 컨소시엄 웹 사이트에서 제공하는 &quot;기본 유니 코드 데이터 정렬 요소 테이블&quot;(일명 DUCET)입니다.</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">Perl의 최신 개발 릴리스는 &quot;정상&quot;표준 I / O 제품군에 대한 Perl의 종속성을 제거하고 다른 stdio 구현을 사용할 수 있도록 실험하고 있습니다. 여기에는 새로운 추상화 계층을 생성 한 다음 stdio Perl의 구현이 컴파일 된 것을 호출합니다. 모든 XSUB는 이제 PerlIO 추상화 계층의 기능을 사용해야하며 어떤 종류의 stdio가 사용되는지에 대한 가정을하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">PA-RISC 설계의 최신 업그레이드로 64 비트 정수 데이터에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">설명서 및 중요 뉴스를 포함하여이 모듈의 최신 버전은</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">출력에서 가장 중요한 정보는</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">가장 간단한 옵션은 가치가없는 옵션입니다. 명령 행에 존재하는 것만으로도 옵션이 가능합니다. 인기있는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">상호 참조자가 갖는 가장 유용한 옵션은 보고서를 별도의 파일로 저장하는 것입니다. 예를 들어 보고서를</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">반환되는 가장 유용한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">컴퓨터 단어에서 비트의 왼쪽 또는 오른쪽 이동으로 2의 거듭 제곱으로 곱하거나 나누는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">다중 대괄호 형식은 형식화 코드 내용 해석에 영향을 미치지 않으며 종료 방법에만 영향을줍니다. 즉, 위의 예는 다음과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="translated">이름</target>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 이름 은 특별하지 않습니다. 생성자의 이름을 다른 것으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">이름은 필사자 SV로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">이름에는 E &amp;lt;&amp;gt; 및 Z &amp;lt;&amp;gt; 형식 코드가 포함되어있을 수 있으며 섹션, 앵커 텍스트 및 유추 된 앵커 텍스트에는 모든 형식 코드가 포함될 수 있습니다. 앞뒤 공백과 마찬가지로 섹션 주위의 큰 따옴표는 구문 분석의 일부로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">의 이름 &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; 패턴은 특별한 의미가있다. 경우 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 이 일치하는 상태가 발생하고, 그런 다음 &quot;지점을 이동&quot;으로 사용되는 위치이다. 어떤 경우 &lt;code&gt;(*MARK)&lt;/code&gt; 그 이름이 발견되지 않은 후 &lt;code&gt;(*SKIP)&lt;/code&gt; 연산자은 효과가 없다. 이름없이 사용될 때 &quot;건너 뛰기 지점&quot;은 (* SKIP) 패턴을 실행할 때의 일치 지점입니다.</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;result_class&lt;/code&gt; 의 이름입니다 . 기본값은 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">상수를 리턴 할 생성 된 C 서브 루틴의 이름. 디폴트는</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">생성 할 Makefile의 이름입니다. 이것은 MAP_TARGET에 대해 생성 될 두 번째 Makefile에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">OP의 이름이거나 OP가 foo 인 null 인 경우 'ex-foo'입니다.</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">명령 행 의 &lt;b&gt;인수 &lt;/b&gt;&lt;b&gt;벡터&lt;/b&gt; 를 포함하는 배열의 이름입니다 . 빈 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자 를 사용하는 경우 &lt;code&gt;ARGV&lt;/code&gt; 는 인수를 순회하는 데 사용되는 &lt;b&gt;파일 핸들&lt;/b&gt; 과 현재 입력 파일의 이름을 포함하는 &lt;b&gt;스칼라&lt;/b&gt; 의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">출력 할 기능의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">테스트 결과를 집계하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">출력을 형식화하는 데 사용할 클래스 이름입니다. 출력이 TTY가 아닌 경우 기본값은 &lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt; 또는 &lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">병렬 테스트 중에 멀티 플렉스 테스트에 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">TAP를 구문 분석하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">테스트 실행을 예약하는 데 사용할 클래스 이름입니다. 기본값은 &lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">Perl 코드에서 볼 수있는 상수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">현재 선택된 출력 채널에 대한 현재 보고서 형식의 이름입니다. 기본 형식 이름은 파일 핸들 이름과 동일합니다. 예를 들어, &lt;code&gt;STDOUT&lt;/code&gt; 파일 핸들 의 기본 형식 이름 은 &lt;code&gt;STDOUT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">현재 선택된 출력 채널에 대한 현재 페이지 상단 형식의 이름입니다. 기본값은 &lt;code&gt;_TOP&lt;/code&gt; 이 추가 된 파일 핸들의 이름입니다 . 예를 들어, &lt;code&gt;STDOUT&lt;/code&gt; 파일 핸들 의 기본 형식 최상위 이름 은 &lt;code&gt;STDOUT_TOP&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">기본 로컬 파일의 이름으로 $ ff-&amp;gt; output_file은 파일 이름을 반환하지 않으면 대체됩니다. 예를 들어 &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; 와 같은 URI를 가져올 때 검색된 내용은 'index.html'이라는 원격 파일에서 가져온 것일 수 있습니다. 이 속성의 기본값은 말 그대로 'file_default'입니다.</target>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">C 코드를 포함하여 쓸 파일의 이름입니다. 기본값은 &lt;code&gt;const-c.inc&lt;/code&gt; 입니다. &lt;code&gt;-&lt;/code&gt; 이름 보장하지만에있는 파일은 합법적 인 펄 패키지 이름과 관련된 어떤 착각하지, 파일 명명 할 수없는 &lt;code&gt;.c&lt;/code&gt; Makefile.PL의 오버라이드 (override)하는 것을 피합니다 &lt;code&gt;.xs&lt;/code&gt; 을 에 &lt;code&gt;.c&lt;/code&gt; 규칙을.</target>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">XS 코드를 포함하여 쓸 파일의 이름입니다. 기본값은 &lt;code&gt;const-xs.inc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">해시에 연결하려는 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">내부 시퀀스 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">레이블 이름은 새로운 스칼라 형식으로 반환됩니다. 선택적 레이블이 없으면 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">open () 메소드 Perl이 open ()에서 호출해야하는 레이어의 이름입니다. 예를 들어 레이어 이름이 APR 인 경우 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">방법의 이름</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">확인하려는 모듈의 이름-필수 키입니다</target>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">구성 프로세스 중에 판별 된대로이 Perl 사본이 빌드 된 운영 체제의 이름입니다. 예를 들어 &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;perlport의 PLATFORMS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">출력 파일의 이름입니다. 이것은 $ ff-&amp;gt; file과 동일하지만 모든 쿼리 매개 변수가 제거됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">문서화되는 프로그램의 이름은 모든 프로그램 옵션과 마찬가지로 일반적으로 B &amp;lt;&amp;gt;를 사용하여 굵게 표시됩니다. 인수는 이탤릭체로 작성해야합니다 (I &amp;lt;&amp;gt;). 함수 이름은 전통적으로 이탤릭체로 작성됩니다. function ()으로 함수를 작성하면 Pod :: Man이이를 처리합니다. 리터럴 코드 또는 명령은 C &amp;lt;&amp;gt;에 있어야합니다. 다른 매뉴얼 페이지에 대한 참조는 &lt;code&gt;manpage(section)&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; 형식이어야하며 Pod :: Man은 자동으로 적절하게 형식을 지정합니다. L &amp;lt;&amp;gt;이있는 두 번째 양식은 POD 포맷터가 가능하면 매뉴얼 페이지에 링크하도록 요청하는 데 사용됩니다. 예외적으로, 모듈 문서를 참조 할 때 일반적으로 해당 섹션을 생략하여 어떤 모듈 설명서가 포함될 것인지 명확하지 않기 때문에;사용하다 &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; 대신 모듈 참조를위한 L &amp;lt;Module :: Name&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">명령 행에 입력 된대로 현재 실행중인 프로그램의 이름입니다. C에서 &lt;b&gt;명령&lt;/b&gt; 이름은 첫 번째 명령 행 인수로 프로그램에 전달됩니다. Perl에서는 &lt;code&gt;$0&lt;/code&gt; 으로 별도로 제공됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
