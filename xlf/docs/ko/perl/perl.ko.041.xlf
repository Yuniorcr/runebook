<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">MAKE 환경 변수 또는 $ Config {make}에서 MAKE를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">플랫폼 전용으로 사용되는 매크로를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">MakeMaker 및 기타 도구 버전을 나타내는 매크로 초기화</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">링크와 관련된 매크로를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">SigSet 객체를 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">모든 신호를 포함하도록 SigSet 객체를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">를 초기화 AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_ * INSTALL * 된 installdirs, LIB_EXT, LIBPERL_A, MAP_TARGET 이름, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB , PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">EXE_FILES 목록에서 MAN1PODS를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">PM 파일 목록에서 MAN3PODS를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">PMLIBDIRS에서 PMLIBDIRS 및 PM을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">새로운 Perl 인터프리터를 초기화합니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">새 객체를 초기화합니다. 이 메소드는 기본적으로 스텁이므로 적절하게 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">파일 경로에서 디렉토리와 파일 이름 사이의 구분자 인 DIRFILESEP 매크로를 초기화합니다. 즉. / Unix에서는 \, Win32에서는 \, VMS에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">tools_other ()가 사용하는 컴파일 및 링크와 관련된 매크로 정의를 초기화하고 $ MM 객체에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">tools_other ()가 사용하는 간단한 매크로 정의를 초기화하고 $ MM 객체에 배치합니다. 이들은 보수적 인 크로스 플랫폼 버전을 사용하며 성능을 위해 플랫폼 별 버전으로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">일반적인 (그리고 빠른) Unix 명령을 사용하도록 도구를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">함수 매개 변수 초기화</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 초기화</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">새로운 것으로 초기화</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">현재 메시지에서 데이터 전송을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b6b3360634a6df83161df89335cce0e40b6cc3dd" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection, for a tcp ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">창 제한으로 인해 &lt;code&gt;perl -i.bak&lt;/code&gt; 파일을 편집하지 않고 파일의 &lt;code&gt;perl -i&lt;/code&gt; 편집 이 작동하지 않으므로 백업 확장자를 지정하지 않고 &lt;code&gt;perl -i&lt;/code&gt; 를 사용하면 Perl이 자동으로 접미사 &lt;code&gt;.bak&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">입력 파일 글롭</target>
        </trans-unit>
        <trans-unit id="b6852c995fba635b92f942abb161a06e4a4f682b" translate="yes" xml:space="preserve">
          <source>Input and Output Layers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">입력 및 출력 매개 변수</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4856593d1efd1c0cd8430882cae3851f3f706" translate="yes" xml:space="preserve">
          <source>Input and output functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">Perl 파일 핸들에 대한 입력 및 출력 파이프가 지원됩니다. &quot;파일 이름&quot;은 비동기 실행을 위해 lib $ spawn ()에 전달됩니다. Perl이 종료 될 때 &quot;분리 된&quot;서브 프로세스를 남기지 않도록 Perl 스크립트에서 연 파이프를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;장치&lt;/b&gt; 에서 입력 또는 출력 .</target>
        </trans-unit>
        <trans-unit id="78a923bcd93c4171316cc3a1bc09d0aa6f07ef83" translate="yes" xml:space="preserve">
          <source>Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">입력 라이브러리 및 경로 스펙은 Unix 링커에서 사용 하는 &lt;code&gt;-l&lt;/code&gt; 및 &lt;code&gt;-L&lt;/code&gt; 접두어를 사용 하거나 사용하지 않고 승인됩니다 .</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">입력 라이브러리 및 경로 스펙은 Unix 링커에서 사용 하는 &lt;code&gt;-l&lt;/code&gt; 및 &lt;code&gt;-L&lt;/code&gt; 접두어를 사용 하거나 사용하지 않고 승인됩니다 . 접두사가없는 경우 토큰은 실제로 디렉토리 인 경우 검색 할 디렉토리로, 그렇지 않으면 검색 할 라이브러리로 간주됩니다. ext ()의 Unix-OS / 2 버전이 필요하기 때문에 자신의 확장이 Unix 또는 OS / 2로 이식되기를 원하는 저자는 Unix 접두사를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">입력 문자열은 decode () d 다음 encode () d입니다. 간단한 2 단계 구현.</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">이러한 루틴의 입력은 BigFloat 오브젝트 또는 다음 네 가지 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="84961be9b7c2809d89e0848f01fd0ffc9df02327" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents a floating point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2156929b7310422c8528b3fc6dfc3918a5f73f99" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">이 루틴에 대한 입력 값은 숫자처럼 보이며 16 진 및 2 진 숫자를 포함하여 정수가되는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff508ce692e1254966736e47898113545150b2ac" translate="yes" xml:space="preserve">
          <source>Insecure $ENV{%s} while running %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2e8a9a0eb4ece5b87faf1da95aff5e83b5fa4" translate="yes" xml:space="preserve">
          <source>Insecure dependency in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931ce1c7f1f13e481922a26677a26bb4773219c6" translate="yes" xml:space="preserve">
          <source>Insecure directory in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb11eae387cd5cce06293624d01344e1072d48a" translate="yes" xml:space="preserve">
          <source>Insecure user-defined property %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">배열의 시작 부분에 LIST 요소를 삽입하여 기존 요소를 위로 이동하여 공간을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">배열의 시작 부분에 LIST 요소를 삽입하여 기존 요소를 위로 이동하여 공간을 확보하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="065f57756426a11d3de09e3d897a1322f51a5123" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">현재 lexing 포인트 ( &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; ) 바로 다음에 렉서 버퍼 ( &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; )에 문자를 삽입 하여 필요한 경우 버퍼를 재 할당하십시오. 이것은 나중에 실행되는 어휘 코드가 마치 입력에 나타난 것처럼 문자를 볼 수 있음을 의미합니다. 일반적인 구문 분석의 일부로이 작업을 수행하지 않는 것이 좋으며이 기능을 사용하면 대부분 삽입 된 문자가 의도하지 않은 방식으로 해석 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">POD, 주석 및 C 전 처리기 지시문 삽입</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">다음과 같은 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">SV 내에서 지정된 오프셋 / 길이에 문자열을 삽입합니다. Perl substr () 함수와 유사합니다. 손잡이는 마술을 얻는다.</target>
        </trans-unit>
        <trans-unit id="0ae14887402eb591db68a2439f3f3fdfb3b0176f" translate="yes" xml:space="preserve">
          <source>Inserts and/or replaces a string at the specified offset/length within the SV. Similar to the Perl &lt;code&gt;substr()&lt;/code&gt; function, with &lt;code&gt;littlelen&lt;/code&gt; bytes starting at &lt;code&gt;little&lt;/code&gt; replacing &lt;code&gt;len&lt;/code&gt; bytes of the string in &lt;code&gt;bigstr&lt;/code&gt; starting at &lt;code&gt;offset&lt;/code&gt;. Handles get magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">sharpbang 또는 동등한 매직 번호를 @file 세트에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">, 안쪽 &lt;code&gt;(?{...})&lt;/code&gt; 블록, &lt;code&gt;$_&lt;/code&gt; 정규식에 일치되는 문자열을 의미합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 를 사용 하여이 문자열 내에서 현재 일치 위치를 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e74660978326d8205b1966918b272dc20370085" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;pos()&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56e96c79858e86c827cc4e174ee077ce93a7306" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;ExtUtils::Installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Perl 프로그램 내에서 &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt; 모듈을 사용하여 설치된 모든 배포판을 표시 할 수 있지만 마법을 수행하는 데 시간이 걸릴 수 있습니다. Perl과 함께 제공되는 표준 라이브러리는 &quot;Perl&quot;로 표시됩니다 (단, &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList로 라이브러리를&lt;/a&gt; 얻을 수는 있음 ).</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 코드 블록 안에 &lt;code&gt;$?&lt;/code&gt; 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 로 전달할 값을 포함합니다 . &lt;code&gt;$?&lt;/code&gt; 를 수정할 수 있습니까? 프로그램의 종료 값을 변경합니다. &lt;code&gt;$?&lt;/code&gt; 변경에주의 ? 실수로 (예 : &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 통해 무언가 실행 ).</target>
        </trans-unit>
        <trans-unit id="bf5fff32ec45447a013d87f1e68934fda177610e" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">내부 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 주어질 값을 포함합니다 . &lt;code&gt;$?&lt;/code&gt; 를 수정할 수 있습니까? 에서 &lt;code&gt;END&lt;/code&gt; 의 서브 루틴 프로그램의 종료 상태를 변경합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad96dc469c005e6c9269282065dbe2d978332531" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">(A)의 내부 &lt;code&gt;CHECK&lt;/code&gt; 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ca3322bfb1e33afbca0ac9de2636f604c7b47b" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">(A)의 내부 &lt;code&gt;END&lt;/code&gt; 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40747b8f72c39fcb02dd5eb53c21ee80332129f2" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">의 내부 &lt;code&gt;INIT&lt;/code&gt; 의 블록의 값 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 될 것 &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dee2a938cbad68208b1a78048519d4dcb40a2614" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">그런 내부</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">Perl 코어 ( &lt;code&gt;PERL_CORE&lt;/code&gt; 정의) 내에서 &lt;code&gt;Perl_&lt;/code&gt; 접두사를 사용하거나 사용하지 않고 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">블록 안에서는 &lt;code&gt;;&lt;/code&gt; 줄임표 앞에 &lt;code&gt;{ ... }&lt;/code&gt; 가 해시 참조 생성자가 아니라 블록 임을 나타냅니다 . 이제 줄임표가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">인사이드 아웃 객체</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">인사이드 아웃 클래스는 상속의 자유를 제공하지만 평소와 같이 가격이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">명시 적 객체 레지스트리를 가진 &lt;code&gt;id()&lt;/code&gt; 함수를 기반으로 한 내부 구현 . 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수를 기반으로 한 내부 구현 . &lt;code&gt;DESTROY&lt;/code&gt; 메소드 가 필요합니다 . 스레드 지원을 위해서는 &lt;code&gt;CLONE&lt;/code&gt; 메소드 (표시되지 않음)도 필요합니다. 대신에 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; 함수는 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 약간의 기능 차이가 사용될 수있다. 이것은 인사이드 아웃 클래스의 기본 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="1c8b1c8f4d7d36ee82d3ac919c5d208501a0c13b" translate="yes" xml:space="preserve">
          <source>Insisting on hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516f54aa115effcfaabedad668e70675fab3e3bf" translate="yes" xml:space="preserve">
          <source>Insisting on hints is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$UTF8{Euro}&lt;/code&gt; 검사 하면 &quot;\ xe2 \ x82 \ xac&quot;의 3 바이트가 포함되어 있음을 알 수 있습니다. 그러나 숫자 0x20AC는 1 자만 포함합니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 으로 왕복 여행을 완료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b88041bde7425827d8e1b77e408079f51dbc6c2" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">Visual C ++ 2005를 먼저 설치 한 다음 Platform SDK를 설치하십시오. 기본 설치 위치를 선택한 것으로 가정하여 다음과 같이 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">Visual C ++ 2008-2013 Express를 설치 한 후 다음을 사용하여 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="64c681793c05d20d47748a1c4848dd27ecc92478" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2019 Express/Community, then setup your environment using, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">명명 된 이벤트에 대한 콜백을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">신호 마스크를 설치하고 신호가 도착할 때까지 프로세스를 일시 중단하십시오. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;signal_mask&lt;/code&gt; 의 인수. 자세한 내용은 시스템의 &lt;code&gt;sigsuspend&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">성공적으로 테스트되었지만 아직 설치되지 않은 모든 배포를 설치하십시오. &lt;code&gt;is_tested&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">여기에서 거기까지 파일 설치</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;정규 신호&lt;/b&gt; 의 핸들러로 my_handler ()를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">정규 신호의 처리기로 my_handler ()를 설치하고 오류 신호 중 하나를 수신하면 Perl 스택 추적을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">툴킷을 먼저 설치 한 다음 플랫폼 SDK, .NET Framework SDK를 설치하십시오. 기본 설치 위치를 선택한 것으로 가정하여 다음과 같이 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Bundle::OS2_default&lt;/code&gt; 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">첫 번째 단계에서 생성 한 번들 파일을 다음과 같이 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a00c681671c3322d47892ed0695f73370a27ed" translate="yes" xml:space="preserve">
          <source>Install the specified modules. With no other switches, this switch is implied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">Install은 파일을 NetWare Perl이 설치된 Windows 시스템으로 복사하므로이 파일은 NetWare 서버로 수동으로 복사해야합니다. 또는 통과</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용한 설치 이상</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">설치 접두사</target>
        </trans-unit>
        <trans-unit id="a45aaea883d55053b401f0d2cdd7b7f6799182e8" translate="yes" xml:space="preserve">
          <source>Installation of &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">DOS에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">Windows에서 Perl 설치</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">계획 9에 Perl 문서 설치</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">OS / 400 PASE에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">BS2000에 Perl 설치</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">동적 확장 설치</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">UNIVERSAL에 핸들러를 설치하면 ... err..universal이됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">정적 확장 설치</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">AmigaOS에 내장 된 Perl 설치</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">내장 된 perl 설치</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">확장 설치</target>
        </trans-unit>
        <trans-unit id="0f18cd63862f3975ca1e7ab7bda9fc335b20e2f1" translate="yes" xml:space="preserve">
          <source>Installs a source filter that substitutes &quot;e&quot; for &quot;o&quot; (witheut regard fer what it might be medifying).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="8d64e2312c9072080b4302e3445829998f7c6a99" translate="yes" xml:space="preserve">
          <source>Instance method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">대신 &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , 우리가 쓸 수 &lt;code&gt;$a[1][2]&lt;/code&gt; ; 그것은 같은 것을 의미합니다. 대신에 &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , 우리가 쓸 수 &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 그것은 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="593a1adb7d7043c40428f2f6f11f755e1eb8603d" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt;, we can write &lt;code&gt;$a[1][2]&lt;/code&gt;; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt;, we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt;; it means the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 대신 &lt;code&gt;:utf8&lt;/code&gt; 을 사용 하면 데이터가 이미 UTF8로 내부적으로 표현 된 경우 인코딩 단계를 건너 뜁니다. 이것은 쓸 때 좋은 동작으로 널리 받아 들여지지 만 읽을 때 위험한 바이트 시퀀스가있을 때 내부 불일치가 발생하기 때문에 위험 할 수 있습니다. 입력에 &lt;code&gt;:utf8&lt;/code&gt; 을 사용하면 보안 위반이 발생할 수 있으므로 대신 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7bfad6bde5b470a60206db3866234b6dfd103110" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, you can simply use &lt;code&gt;:utf8&lt;/code&gt;, which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 및 &lt;code&gt;encode&lt;/code&gt; 대신 &lt;code&gt;_utf8_on&lt;/code&gt; 및 &lt;code&gt;_utf8_off&lt;/code&gt; 사용할 수 있지만 이는 잘못된 스타일로 간주됩니다. 특히 &lt;code&gt;_utf8_on&lt;/code&gt; 은 &lt;code&gt;:utf8&lt;/code&gt; 과 같은 이유로 위험 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb3493ce203f52a331d6d2854f96ffed217a38c" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt;, you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt;, but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">파일 이름 대신 다른 아카이브 등 의 기존 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체에 파일 이름을 전달할 수도 있습니다. 객체는 복제되며 사실상 별칭이 아닌 원본의 사본이됩니다.</target>
        </trans-unit>
        <trans-unit id="124160cac15a4b540f3a3a995eeb45e15636d682" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you may specify an external command (plus an optional argument list) or a scalar reference, in order to open filehandles on commands or in-memory scalars, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">숫자 대신 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 &quot;남은 모든 것을 소비&quot;를 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dTHX&lt;/code&gt; 를 사용하여 스레드 컨텍스트를 페치 해야하는 실제 C 함수 대신 동일한 이름의 매크로를 정의하고 오버 헤드를 피할 수 있습니다. 또한 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; 에 의해 할당 된 메모리를 해제 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a07eba34499fa5596b47d75d14fe92d0d0178dc4" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt;, you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">대신 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">기능 번들을 이름별로로드하는 대신 Perl에서 기능 번들을 암시 적으로로드하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="19636d7e449d8e4352801adbe196c0e695eced0d" translate="yes" xml:space="preserve">
          <source>Instead of reading the Unicode Database directly from files, as you were able to do for a long time, you are encouraged to use the supplied functions. So, instead of reading &lt;code&gt;Name.pl&lt;/code&gt; directly, which changed formats in 5.32, and may do so again without notice in the future or even disappear, you ought to use &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;$SIG{ALRM}&lt;/code&gt; 을 설정하는 대신 :</target>
        </trans-unit>
        <trans-unit id="109c505d57edc356474583bd538981b34aae6661" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">Makefile.PL에 VERSION을 지정하는 대신 MakeMaker가 파일을 구문 분석하여 버전 번호를 결정할 수 있습니다. 구문 분석 루틴에서는 VERSION_FROM으로 이름 지정된 파일에 버전 번호를 계산하기위한 단일 행이 포함되어 있어야합니다. $ VERSION 할당 또는 &lt;code&gt;package Name VERSION&lt;/code&gt; 과 같은 것을 포함하는 파일의 첫 번째 라인 이 사용됩니다. 다음 줄은 정상적으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">위의 프로세스 대신 Filter :: Simple을 사용하면 소스 코드 필터를 설정하는 작업이 다음과 같이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">쉘의 &lt;code&gt;expand&lt;/code&gt; 명령 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">쉘의 &lt;code&gt;unexpand -a&lt;/code&gt; 명령 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">이 대신에 :</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; 를 사용하는 대신 &lt;code&gt;/m&lt;/code&gt; (및 아마도 &lt;code&gt;/s&lt;/code&gt; ) 정규식 수정자를 사용해야합니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 어휘 범위 (전체 파일도 포함)에 대해 &lt;code&gt;/m&lt;/code&gt; 을 활성화 할 수 있습니다 . (이전 버전의 경우 : &lt;code&gt;$*&lt;/code&gt; 가 true 값으로 설정되면 모든 정규식은 마치 마치 &lt;code&gt;/m&lt;/code&gt; 을 합니다.)</target>
        </trans-unit>
        <trans-unit id="d1566aff196e46eef40b411b3e40f33b2eca1868" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;. (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1168108b163850f03f0e7b84e90e2a3b75e09dc" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$Level&lt;/code&gt; to perform a backtrace, Test2 uses a context object. In this sample you create a context object and store it. This locks the context (errors report 1 level up from here) for all wrapped tools to find. You do not need to use the context object, but you do need to store it in a variable. Once the sub ends the &lt;code&gt;$ctx&lt;/code&gt; variable is destroyed which lets future tools find their own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;foreach()&lt;/code&gt; 사용할 수 있습니다 루프를 . 예를 들어, 배열에서 특정 문자열이 몇 번 발생하는지 계산하는 한 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="825297ab548b22ab92e503372aa9e1350b6ae1f8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt;, you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaff3d1d72214bb8cea47592fb5e3c306e475c28" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined in such a way as to accept the number of parameters supplied by perl's overload system. For most overload methods, it will be three parameters; for the &lt;code&gt;nomethod&lt;/code&gt; function it will be four. However, the bitwise operators &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; may be called with three</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">순수 Perl을 사용하여 오버로드 된 인터페이스를 작성하는 대신 OVERLOAD 키워드를 사용하여 함수에 대한 추가 Perl 이름 (위의 ALIAS : 키워드)을 정의 할 수도 있습니다. 그러나 오버로드 된 함수는 세 개의 매개 변수로 정의되어야합니다 (네 개의 매개 변수가 필요한 nomethod () 함수 제외). 함수에 OVERLOAD : 키워드가있는 경우 xsubpp에 의해 생성 된 c 파일에 여러 추가 행이 정의되어 과부하 마법에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">다중 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 명령문 을 작성하는 대신 상수 이름 대신 키가 정의 될 상수의 이름 인 해시에 대한 참조를 제공하여 단일 명령문에서 다중 상수를 정의 할 수 있습니다. 분명히이 방법을 사용하여 정의 된 모든 상수는 단일 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="df4a7dbc731cad321f60bc3be4e6304404421661" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;use constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8을&lt;/a&gt; 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">대신 &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; 또는 드물게 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5da1022fb23560c08ccb2175ba3ed7594365a4b" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot; in perlapi&lt;/a&gt;, or rarely, &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">대신 거의 확실하게 &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; 또는 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="3c1ab72749459dc4de544fac6868597b605f1005" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">대신 &lt;code&gt;bytes_to_utf8&lt;/code&gt; 은 문자열 인수 의 UTF-8 인코딩 &lt;b&gt;사본&lt;/b&gt; 을 제공합니다. 이는 원래 SV에 영향을주지 않으면 서 데이터를 비교 등에 사용할 수 있도록하는 데 유용합니다. &lt;code&gt;utf8_to_bytes&lt;/code&gt; 도 있습니다다른 방법으로 있지만 문자열에 단일 바이트로 표현할 수없는 255 이상의 문자가 포함되어 있으면 자연스럽게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">대신 Windows에서 일반 텍스트 파일을 실행하는 데 사용 가능한 모든 방법은 &quot;확장자&quot;파일을 사용합니다. 이것을 사용하여 펄 스크립트를 실행하는 세 가지 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">대신 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="c21043f535759255fae7da396e1a74414adc0df4" translate="yes" xml:space="preserve">
          <source>Instead, it's recommended one uses &lt;code&gt;state&lt;/code&gt; variables to achieve the same effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0ab28444eeb1a3b5d5448f3e8b2d9f9844879d" translate="yes" xml:space="preserve">
          <source>Instead, switch from &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; to &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;. &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does everything &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; does, and more! In fact, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">대신 다음 솔루션이 다소 효과적입니다. 이것에 대한 좋은 점은 1) 바로 사용할 수 있습니다. 2) * / * / *. c와 같은 패턴으로 올바른 작업을 수행하기 때문에 더 강력합니다. 3) 사용 여부를 결정할 수 있습니다. 4) 방법을 확장하여 모든 사용자 정의 (또는 완전히 다른 종류의 와일드 카드 확장)를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="029f2d96c54611243fd4f7123ebf76a0e7725aa0" translate="yes" xml:space="preserve">
          <source>Instead, the stack stores information in a variable-length encoding of &lt;code&gt;ANY&lt;/code&gt; structures. The final value pushed is stored in the &lt;code&gt;UV&lt;/code&gt; field which encodes the kind of item held by the preceeding items; the count and types of which will depend on what kind of item is being stored. The kind field is pushed last because that will be the first field to be popped when unwinding items from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">대신, 부울 검사에는 &lt;code&gt;blessed&lt;/code&gt; ( &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈에서), 특정 클래스 검사 에는 &lt;code&gt;isa&lt;/code&gt; , 유형 검사에는 &lt;code&gt;reftype&lt;/code&gt; ( &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; )도 사용하십시오. (자세한 내용과 &lt;code&gt;blessed/isa&lt;/code&gt; 예 는 &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">대신, 부울 검사에는 &lt;code&gt;blessed&lt;/code&gt; ( &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈에서), 특정 클래스 검사 에는 &lt;code&gt;isa&lt;/code&gt; , 유형 검사에는 &lt;code&gt;reftype&lt;/code&gt; ( &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; )도 사용하십시오. (자세한 내용과 &lt;code&gt;blessed/isa&lt;/code&gt; 예 는 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="88561bf4f68d300fba6b47877d2e1d88be295371" translate="yes" xml:space="preserve">
          <source>Instead, use a temporary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">대신 단일 백 슬래시와 함께 큰 따옴표를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">대신 IV, UV, IVSIZE, I32SIZE 등의 정의를 사용하십시오. 그것이 보장 &lt;b&gt;되지&lt;/b&gt; 않기 때문에 I32와 같은 것을 피하십시오</target>
        </trans-unit>
        <trans-unit id="f29af992c4a56bb38b3dfd00c903703bc13b8ea4" translate="yes" xml:space="preserve">
          <source>Instead, write this using a lexical variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">종속성과 함께 모듈을 설치하는 방법에 대한 지침. 여기에 포함 할 제안 정보 :</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">파일 스펙의 일부로 나타나는 콜론과 대상 구분 기호를 구분하기 위해 대상을 표시하는 콜론 앞에 공백이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">정수 산술</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">정수 이진 로그 [C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">정수 이진 로그 [C99].</target>
        </trans-unit>
        <trans-unit id="e9aa0af9187fd5006e57aa5fe9340c513694f8b0" translate="yes" xml:space="preserve">
          <source>Integer overflow in %s number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6b479cc505431a4dd13a180ea73dec5d1ae03c" translate="yes" xml:space="preserve">
          <source>Integer overflow in format string for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411c0a34661530dce26957f99bd67035b369dd12" translate="yes" xml:space="preserve">
          <source>Integer overflow in srand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e060e7583c7facbbad20094c9d4fc91b279e279" translate="yes" xml:space="preserve">
          <source>Integer overflow in version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0952c0d0ac1f6d4efaf83d1bb17a2ea9130956b" translate="yes" xml:space="preserve">
          <source>Integer overflow in version %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">정수. 선택적인 선행 더하기 또는 빼기 기호 다음에 일련의 숫자가옵니다.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">로컬 디렉토리 통합</target>
        </trans-unit>
        <trans-unit id="1c339f566d96dc4be124c8a012dc09ff7ba394ec" translate="yes" xml:space="preserve">
          <source>Intel C++ Compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">인텔 헥스</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEX는 바이너리 데이터를 나타내는 파일 형식으로, 주로 다양한 칩을 텍스트 파일로 프로그래밍하는 데 사용됩니다. (참조 &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex을&lt;/a&gt; 자세한 설명과 &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt; 풀어 할 수있는 모토로라 S 레코드 형식에 대한) (file_format를 각 줄은 콜론 ( ':')으로 시작하고 그 뒤에 바이트 수를 지정하는 일련의 16 진수 문자가옵니다.</target>
        </trans-unit>
        <trans-unit id="a856ee1a019faac6da0b8db428273065b2de2b57" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;https://en.wikipedia.org/wiki/.hex&quot;&gt;https://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;https://en.wikipedia.org/wiki/SREC_(file_format)&quot;&gt;https://en.wikipedia.org/wiki/SREC_(file_format)&lt;/a&gt; for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da544d1418799d25bfd09546e06754d3e5b1aeb3" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">제거 된 버전의 패키지에 대해 임의의 스크립트를 테스트하는 방법 으로 명령 줄에서 &lt;b&gt;-M&lt;/b&gt; 옵션 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">DCL (Digital Command Language) 쉘에서 Perl과 상호 작용하려면 종종 Unix 쉘과 다른 따옴표가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">확장과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">IO :: Socket이 포함 된 대화식 클라이언트</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">대화식 모드 :</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">대화식 세션은 기본적으로 &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 으로 잠금 파일을 유지합니다 . 자물쇠 . 배치 작업은 잠금 파일없이 실행될 수 있으며 서로 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 를 사용하여 임의의 &lt;code&gt;expression&lt;/code&gt; 을 대화식으로 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9612d7e5106a7533f6eeeb596274a84b741fb5b" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216f7ef95315bf7807890aa65847604f1201542d" translate="yes" xml:space="preserve">
          <source>Interal Utilities for autodie and Fatal! This module is not a part of autodie's public API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">흥미롭게도 결과 파일 형식이 같더라도 보고서를 생성하는 알고리즘이 다르기 때문에 결과가 약간 다릅니다. 경과 시간, 사용자 및 시스템 시간은 &lt;code&gt;Devel::Profiler&lt;/code&gt; 가 자체 실행을 실행 하는 데 걸린 시간을 명확하게 표시 하지만 열 목록은 이전의 것보다 더 정확하게 느껴집니다. &lt;code&gt;Devel::DProf&lt;/code&gt; . 예를 들어 102 % 수치가 사라졌습니다. 여기서 우리는 도구를 마음대로 사용할 수 있고 도구를 사용하기 전에 장단점을 인식해야합니다. 흥미롭게도, 각 서브 루틴에 대한 호출 수는 두 보고서에서 동일하며 백분율이 다릅니다. &lt;code&gt;Devel::Proviler&lt;/code&gt; 의 저자는 다음과 같이 말합니다 .</target>
        </trans-unit>
        <trans-unit id="80ae20ece05d487021ccd9de0a68139efa803e3c" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt;. The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">인터페이스 전략</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm과 Kwalify.pm 사이의 인터페이스</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">버클리 DB에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">EMX에서 cwd 로의 인터페이스. &lt;code&gt;Cwd::cwd&lt;/code&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5554dd630fd9035ebceb918f102c567832d75cf6" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adf7d5cbdb0f3010f3086f3f294d7023f460422" translate="yes" xml:space="preserve">
          <source>Interface to get/set environment variables. Returns the current value as a Unicode string. The $uni_key and $uni_value arguments are expected to be Unicode strings as well. Passing &lt;code&gt;undef&lt;/code&gt; as $uni_value deletes the environment variable named $uni_key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib 압축 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">다른 프로그래밍 언어의 인터페이스 / 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">일부 Win32 API 함수에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="79cc6bbe2327c1551d1e5d40f07d9b83bc80ae14" translate="yes" xml:space="preserve">
          <source>Interleaving STDOUT/STDERR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033764585e80fa1ca47c0451c08faf861b72f44d" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table for use in specialized &lt;a href=&quot;Test::API::Context&quot;&gt;Test::API::Context&lt;/a&gt; methods which generate &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3fe500d640cf31fd9a657a78f2b102d9181133" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="0cef48f59f7e2f51840fc46f9024c24cc33d8ed0" translate="yes" xml:space="preserve">
          <source>Internal Utility subroutines for autodie and Fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm의 내부 구성 처리</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm의 내부 디버깅</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">$ dl_debug가 true로 설정되면 내부 디버깅 메시지가 활성화됩니다. 현재 $ dl_debug를 설정하면 DynaLoader의 Perl 측에만 영향을줍니다. 이 메시지는 애플리케이션 개발자가 DynaLoader 사용 문제를 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c2682bb60ef046fd0af9a65133fafcb74ba078ce" translate="yes" xml:space="preserve">
          <source>Internal disaster in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49405ebb7fde7f417d0e5c600dc6fa4e232257c1" translate="yes" xml:space="preserve">
          <source>Internal error: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">내부 함수 Hash :: Util :: FieldHash :: _ fieldhash</target>
        </trans-unit>
        <trans-unit id="5f0c27e8b0c0bee621d0e3ce9073f2744d23dd75" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; 인수 유형 에 따라 필터를 추가하는 내부 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm에 대한 tar 아카이브의 내부 처리</target>
        </trans-unit>
        <trans-unit id="8e0c690a448500e398abe5fb8a070cf47a50330b" translate="yes" xml:space="preserve">
          <source>Internal inconsistency in tracking vforks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">오류 및 경고 인쇄를위한 내부 방법. 옵션이 없으면 단순히 &quot;@_&quot;를 인쇄합니다. 다음 옵션이 인식되어 출력을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time :: gmtime 및 Time :: localtime에서 사용하는 내부 객체</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm에 대한 내부 큐 지원</target>
        </trans-unit>
        <trans-unit id="237da84ead8405b42fa85a7e388ec997365ff6da" translate="yes" xml:space="preserve">
          <source>Internal urp in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e13d391ba568ec11cf915e5927275eb2d03a56" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">내부적으로 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 는 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 를 통해 실제 연결 인터페이스로 구현됩니다 . 해당 패키지의 메소드는 이러한 함수를 다시 호출합니다. 그러나이 목적 으로 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 의 사용은 다음 릴리스에서 변경 될 수 있습니다. 예를 들어, 이것은 대신 마술로 구현 될 수 있습니다 (mgvtbl의 확장이 필요함).</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">내부적으로 CPAN.pm은 UTF-8 문자 세트를 사용합니다. 터미널에 ISO-8859-1 문자 집합이 필요한 경우 구성 파일에서 term_is_latin을 true로 설정하여 변환기를 활성화 할 수 있습니다. 그렇게하는 한 가지 방법은</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">내부 인코딩-&amp;gt; 유니 코드 및 유니 코드-&amp;gt; 인코딩 맵은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0270a1a0f07e6453af1ad3d10386c0ad1d3a4e99" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;&quot;NOTES&quot;&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">내부적으로 벤치 마크 객체는 아래 &lt;a href=&quot;#NOTES&quot;&gt;참고에&lt;/a&gt; 설명 된 타이밍 값을 보유 합니다. 다음 방법을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">내부적으로 이것은 사용자 정의 엔진이 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 지정되어 있지 않으면 &lt;code&gt;NULL&lt;/code&gt; 로 설정되며 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; 에 의해 지시 되는 구조체에서 Perl의 자체 콜백 세트에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3120174b4db905355a8c95bdaa9494f155c0435" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt;, Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode :: ?? :: ISO_2022_ *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">Encode :: CN에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode :: JP에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode :: JP :: 2022_JP *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode :: KR에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">내부적으로 Perl은 현재 플랫폼의 기본 8 비트 문자 세트 (예 : Latin-1)를 UTF-8로 기본 설정하여 유니 코드 문자열을 인코딩합니다. 특히 문자열의 모든 코드 포인트가 &lt;code&gt;0xFF&lt;/code&gt; 이하인 경우 Perl은 기본 8 비트 문자 세트를 사용합니다. 그렇지 않으면 UTF-8을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">내부적으로 (C 컴파일러에서 제공 한) 기본 정수 산술이 사용됩니다. 이것은 산술 연산에 대한 Perl의 고유 한 의미가 보존되지 않을 수 있음을 의미합니다. 일반적인 문제의 원인 중 하나는 음수의 계수이며 Perl은 한 가지 방법이지만 하드웨어는 다른 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">내부적으로 이것을 종종 Pod :: Simple :: Progress 클래스의 객체로 설정합니다. 해당 클래스는 문서화되지 않았지만 소스를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">내부적으로 컴퓨터는 이진수로 부동 소수점 숫자를 나타냅니다. 디지털 (2의 거듭 제곱) 컴퓨터는 모든 숫자를 정확하게 저장할 수는 없습니다. 일부 실수는 프로세스에서 정밀도를 잃습니다. 이것은 컴퓨터가 숫자를 저장하는 방법과 Perl뿐만 아니라 모든 컴퓨터 언어에 영향을 미치는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="5b92377b87e725e0dd0672bfd114d434b8fa7df8" translate="yes" xml:space="preserve">
          <source>Internals - Reserved special namespace for internals related functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">내부 및 C 언어 인터페이스</target>
        </trans-unit>
        <trans-unit id="221f3b6d81d4077e193de47fb71efa7ac821cbb0" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization &lt;a href=&quot;http://www.iso.ch/&quot;&gt;http://www.iso.ch/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="8f2a515a6b360e659af1aa0a2bbe7a1464bcd610" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;&quot;OS ISSUES&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">국제화 (I18N) 및 현지화 (L10N)는 최소한 원칙적으로 EBCDIC 플랫폼에서도 지원됩니다. 세부 사항은 시스템에 따라 다르며 아래 &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS 문제&lt;/a&gt; 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">국제화 및 로캘</target>
        </trans-unit>
        <trans-unit id="46c7578271b4ab36db28528f49822a53c8afcb81" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete and ungainly. They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">C 및 POSIX 표준에 정의 된 국제화는 불완전하고 부적절하며 너무 큰 입도를 갖는 것으로 비판받을 수 있습니다. (로컬은 단일 스레드, 창 그룹 등에 적용하는 것이 더 유용한 경우 전체 프로세스에 적용됩니다.) 또한 표준 그룹과 같이 세계를 국가로 나누는 경향이 있습니다. 모두는 세계가 은행가, 자전거 타는 사람, 게이머 등으로 똑같이 나눌 수 있다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c150f55df149b9e7642e03589abcd3eb462548e7" translate="yes" xml:space="preserve">
          <source>Internet Assigned Numbers Authority &lt;a href=&quot;http://www.iana.org/&quot;&gt;http://www.iana.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">인터넷 라인 터미네이터</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">인터넷 프로토콜 또는 지적 재산권.</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">인터넷 TCP 클라이언트 및 서버</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">RFC 3066에 정의 된 인터넷 언어 태그는 인간 언어를 나타내는 형식입니다. 2 자로 된 ISO 639-1 언어 코드는 국가 코드 ( &quot;en-US&quot;)로 인증 된 형식과 마찬가지로 잘 알려져 있습니다 (영어의 경우 &quot;en&quot;). &quot;i-mingo&quot;와 같은 임의 길이의 비 ISO 코드는 잘 알려져 있지 않으며 최근 (2001 년) 3 글자 ISO-639-2 코드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="d1f27df0b0f458a0b4241c741d83baaaba6cee55" translate="yes" xml:space="preserve">
          <source>Interoperating with Pbzip2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">보간 된 스칼라 및 배열은 내부적으로 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 로 변환 됩니다. 담금질 작업. 따라서 &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; 는 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="7b7796550c9a05d4af98c0f9b17a2e334cf3e552" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">배열 또는 슬라이스 보간은 &lt;code&gt;$&quot;&lt;/code&gt; 값으로 구분 된 순서대로 요소 를 보간하므로 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 보간 과 같습니다 . &lt;code&gt;@*&lt;/code&gt; 와 같은 &quot;문구&quot;배열 은 일반적으로 이름이 중괄호 &lt;code&gt;@{*}&lt;/code&gt; 묶인 경우에만 보간 되지만 배열 &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; 및 &lt;code&gt;@-&lt;/code&gt; 는 중괄호없이 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="c89b1d270440efce1fe96c18e4bb21c6ce7e1f28" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt;, so is equivalent to interpolating &lt;code&gt;join $&quot;, @array&lt;/code&gt;. &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt;, and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">패턴 보간에는 몇 가지 단점이 있습니다. &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; 및 &lt;code&gt;@-&lt;/code&gt; 는 보간되지 않으며 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; 구문 은 여러 다른 추정값에 의해 배열 요소 또는 &lt;code&gt;$var&lt;/code&gt; 이어 RE 대안 으로 투표됩니다 . 여기서 &lt;code&gt;${arr[$bar]}&lt;/code&gt; 표기법 이 유용합니다. &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; 는 &lt;code&gt;$arr&lt;/code&gt; 변수의 정규 표현식 이 아닌 숫자 뒤에 배열 요소 &lt;code&gt;-9&lt;/code&gt; 로 해석됩니다 . 이것은 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; 의 해석입니다. 다른 견적 자 사이에 투표가 발생할 수 있으므로 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39ed28583e84f6b41afb2ccf6f513cf965009d02" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt;, &lt;code&gt;$(&lt;/code&gt;, &lt;code&gt;$)&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt;, not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt;. Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 16 진 문자열로 해석하십시오. &quot;0x&quot;또는 &quot;x&quot;접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e3c6ad2b94e17e8ed6ad8c9f4b49132292140f2b" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A prefix (&quot;0b&quot; or &quot;b&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ae7a8b8abddae828432695e232afb3455b5e34" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string.A prefix (&quot;0x&quot;, &quot;x&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72044a388d08d12a68e1993790c0be63bb048467" translate="yes" xml:space="preserve">
          <source>Interpret input as an octal string. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">결과를 엄격하게 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 이진 문자열로 해석하십시오. &quot;0b&quot;또는 &quot;b&quot;접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d76880ffa69808c7f715164c615fdf27a78c1785" translate="yes" xml:space="preserve">
          <source>Interpret the input as a byte string, assuming big endian byte order. The output is always a non-negative, finite integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453c8b8b13743efe964db57b55ed8957df8eedf7" translate="yes" xml:space="preserve">
          <source>Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte string, hex string or binary string. The input is assumed to be in big-endian byte-order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">입력을 8 진 문자열로 해석하고 해당 값을 리턴하십시오. &quot;0&quot;(영) 접두어는 선택 사항입니다. 접두사 바로 뒤에 (있는 경우) 또는 두 자리 사이에 단일 밑줄 문자를 배치 할 수 있습니다. 입력이 유효하지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; 필드의 해석은 시스템마다 다르지만 일반적으로 사용자의 전체 이름, 사무실 위치, 회사 전화 번호 및 집 전화 번호를 포함하는 4 개의 쉼표로 구분 된 필드를 보유합니다. gecos 필드 의 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 사용자의 대문자로 된 로그인 &lt;code&gt;name&lt;/code&gt; 으로 대체해야합니다 . &lt;code&gt;shell&lt;/code&gt; 필드가 빈 경우로 가정해야</target>
        </trans-unit>
        <trans-unit id="0976c6eb851bd29a7c13436a47fce586e64022a2" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt;. The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920aa278d5fde4bc26b94a177b294481884c28c0" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;&quot;lex_peek_unichar&quot;&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;&quot;lex_read_unichar&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">약간 더 높은 수준의 함수 &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; 및 &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt; 를 사용하여 버퍼의 옥텟 해석을 추상화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="b588c5a0249a1b98f3880c0e5147ba7d315538dd" translate="yes" xml:space="preserve">
          <source>Interpreter embedded in larger application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e94340be7381aa50cefb2bdc5e7587b72758de" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding numeric value. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 16 진 문자열로 해석하고 해당 값을 리턴합니다. &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작할 수있는 문자열을 변환하려면 &lt;a href=&quot;#oct&quot;&gt;oct를&lt;/a&gt; 참조하십시오 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 16 진 문자열로 해석하고 해당 값을 리턴합니다. &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작할 수있는 문자열을 변환하려면 &lt;a href=&quot;oct&quot;&gt;oct를&lt;/a&gt; 참조하십시오 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">EXPR을 8 진 문자열로 해석하고 해당 값을 리턴합니다. (EXPR이 &lt;code&gt;0x&lt;/code&gt; 로 시작 하면 16 진 문자열로 해석됩니다. EXPR이 &lt;code&gt;0b&lt;/code&gt; 로 시작 하면 2 진 문자열로 해석됩니다. 앞의 공백은 세 경우 모두 무시됩니다. 다음은 10 진수, 2 진수, 표준 Perl 표기법의 8 진 및 16 진 :</target>
        </trans-unit>
        <trans-unit id="ae1424465a8d50534920bcc14b8cbe5ef86892ac" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt;, interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">프로세스 간 통신 (IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">프로세스 간 통신.</target>
        </trans-unit>
        <trans-unit id="a5a495c9d0578a0494f49fc6ace5fd6e9fed4e9a" translate="yes" xml:space="preserve">
          <source>Interrupting IO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">교차는 일반적으로 두 개 이상의 클래스와 일치하는 공통 문자를 얻는 데 사용됩니다. 첫 번째 세트에 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 를 사용하지 않는 것이 중요합니다 . 그것은 아무것도 교차하지 않고 빈 세트가됩니다.</target>
        </trans-unit>
        <trans-unit id="d34174297460fdd67bf61d2f8749421841769688" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set. (Similarly using &lt;code&gt;&quot;-&quot;&lt;/code&gt; for the first set does nothing).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">소개</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">Perl 5.005에 도입</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">Perl 5.10.0에 도입</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">Perl 5.12에서 도입</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">Perl 5.14.0에 도입</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0에 도입</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0에 도입</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">Perl 5.6.0에서 도입</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">Perl 5.6.1에 도입</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0에서 도입</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">Perl 5.9.0에서 도입</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">Perl 5.9.2에서 도입</target>
        </trans-unit>
        <trans-unit id="091f1001c9d6a40187930fa44574a4f653880f2a" translate="yes" xml:space="preserve">
          <source>Introduced in perl 5.25.12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">소개 : 5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">소개 : Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">소개 : Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">소개 : Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">소개 : Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">perl5.7.0 직후에 도입 된이 추상화는 운영 체제와 C 라이브러리가 작업을 수행하는 방식에서 IO를 분리함으로써 IO가 수행되는 방식을 perl이 더 많이 제어 할 수 있도록하는 위 추상화를 다시 구현 한 것입니다. USE_PERLIO의 경우 PerlIO *에는 추가 간접 계층이 있습니다. 포인터를 가리키는 포인터입니다. 이를 통해 PerlIO *는 알려진 값을 유지하면서 구현을 스왑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2d2fa71d8eaea749023a72cddaf418fe1cb149" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">캐치 블록을 소개합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">(읽기 전용이 아닌) 글로벌 소개</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">&lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; ( &lt;code&gt;nm&lt;/code&gt; 에 BSD 스타일 출력이있는 경우)를 사용하여 추가 한 데이터가 실제로 읽혔는지 확인하는 한 읽기 전용 (const) 전역을 소개해도됩니다. 뿐. (있는 경우 해당 명령의 출력에 표시되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">for () 안에 변수 소개</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c3cbe25b5093a9e955ec87889df443c3c88a6700" translate="yes" xml:space="preserve">
          <source>Introduction to the context stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">서론</target>
        </trans-unit>
        <trans-unit id="35b4535865312e74cc4ee5fddabecf0f89eff7b1" translate="yes" xml:space="preserve">
          <source>Invalid %s attribute: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16e49525bf4e99622a920415ffb99daaab7bb8c" translate="yes" xml:space="preserve">
          <source>Invalid %s attributes: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f278621344da2113b386e7cf493f5b7effda7cb6" translate="yes" xml:space="preserve">
          <source>Invalid =encoding syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ccfdff90507fec490f3681db3843b0d6286ad3" translate="yes" xml:space="preserve">
          <source>Invalid [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ca1b8b000c05ddca3141e99f4a127d6bf62783" translate="yes" xml:space="preserve">
          <source>Invalid \0 character in %s for %s: %s\0%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5167b1a82e18cf454d4bc0f759f3a654b3597c1" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2a343ef8d4bd75601d86b329b7a01d8c329447" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ab829daff8a5e5f6392ceed1cb4afa7bad1191" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de5bc9920e09cfc5aa332c66ec4d5cfec265952" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e151899283ad3fa0d3b17b289c6f5652fe00d4" translate="yes" xml:space="preserve">
          <source>Invalid character in \N{...}; marked by &amp;lt;-- HERE in \N{%s}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2863c47889763b20775fa1947348a4c08ab6c002" translate="yes" xml:space="preserve">
          <source>Invalid character in charnames alias definition; marked by &amp;lt;-- HERE in '%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71b8ff5c88697d1a550d6673237e1107c606759" translate="yes" xml:space="preserve">
          <source>Invalid conversion in %s: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da241ea775f4ffbb146ef9175cab747e1e17f61" translate="yes" xml:space="preserve">
          <source>Invalid errors setting &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ec4ba5b78e52ef0ab2ed660f408ead1951cbe" translate="yes" xml:space="preserve">
          <source>Invalid escape in the specified encoding in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519c9635790d830978d5164b3ad7937b453ade67" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4e943158cfd55f7caa089383100312254493ec" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87131ca7be09c630d75c4fef49d87656455519cb" translate="yes" xml:space="preserve">
          <source>Invalid module name %s with -%c option: contains single ':'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafc147d5721e32ab438b2e1facd6104c69c8cdb" translate="yes" xml:space="preserve">
          <source>Invalid mro name: '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="997bb1def2a65589fb34cef75e7877e3c194aa47" translate="yes" xml:space="preserve">
          <source>Invalid negative number (%s) in chr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ebf8d124c561f25f30e95ab6d9cc2965fe72ff" translate="yes" xml:space="preserve">
          <source>Invalid number '%s' for -C option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b24f046499eeb08ade4a703bdfb2ca0850444e" translate="yes" xml:space="preserve">
          <source>Invalid quantifier in {,} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c55ed435afff8d41b70ade097c0698032d0c012" translate="yes" xml:space="preserve">
          <source>Invalid quote specification &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5c174cc04f03d39141a30a0cfc0c41bc31bb3f" translate="yes" xml:space="preserve">
          <source>Invalid range &quot;%s&quot; in transliteration operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bf96d82c63323749d7987b1d0a19d37b194c78" translate="yes" xml:space="preserve">
          <source>Invalid reference to group in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b451f3135fd8389070687455f7342fb7a8b6308" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in PerlIO layer specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97ba0ffc9967cd5abf07936f7edcde4477f44be" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in attribute list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132cab989b11d24a0daa70576a5563553614029c" translate="yes" xml:space="preserve">
          <source>Invalid strict version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac063110370f25128c7648841d4d47e40ca1a6f" translate="yes" xml:space="preserve">
          <source>Invalid type '%s' in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fac60217e12bb0c9148c5e13124cc1ea622f52" translate="yes" xml:space="preserve">
          <source>Invalid version format (%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a2b722bc1d83834529dc472a04775d93256603" translate="yes" xml:space="preserve">
          <source>Invalid version object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">지정된 숨김의 모든 하위 클래스에서 메소드 캐싱을 무효화하여이 클래스의 변경 사항을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">주어진 클래스에 따라 클래스의 메소드 캐시를 무효화합니다. 이것은 일반적으로 필요하지 않습니다. 순수 perl 코드가 메소드 캐시를 혼동시킬 수있는 유일한 경우는 &lt;a href=&quot;constant&quot;&gt;상수&lt;/a&gt; 내부와 같이 읽기 전용 스칼라 값을 사용하여 새 상수 서브 루틴을 수동으로 설치하는 경우 입니다. 다른 사례를 찾은 경우이를 수정하거나 예외를 여기에 기록 할 수 있도록 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">설치된 모듈의 재고 관리</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">반전 목록은 유니 코드 속성 값 정의를 지정하는 간단한 방법입니다. 목록의 0 번째 항목은 속성 값이있는 가장 낮은 코드 포인트입니다. 다음 항목 (항목 [1])은 속성 값이없는 항목을 넘어 가장 낮은 코드 포인트입니다. 그리고 그 다음에 나오는 다음 항목 ([2])은 속성 값 등이있는 것보다 가장 낮은 코드 포인트입니다. 달리 말하면 목록의 각 요소는 속성 값 (짝수 요소) 또는 속성 값 (홀수 요소)이없는 범위의 시작을 제공합니다. 이 데이터 구조의 이름은 목록의 각 요소가 해당 범위가 목록에 있는지 여부에 관계없이 토글 (또는 반전)한다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="65b853d505ac70a8422f3186ac06caa076307275" translate="yes" xml:space="preserve">
          <source>Inverting a character class which contains a multi-character sequence is illegal in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31204d44a5939448655207a55e393849306b131a" translate="yes" xml:space="preserve">
          <source>Investigate whether &lt;code&gt;POSIX::dup2&lt;/code&gt; upsets BSD's &lt;code&gt;kqueue&lt;/code&gt; watchers, and if so, consider what possible workarounds might be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">호출하려면 명령을 실행하거나 코드 참조 및 선택적으로 해시 참조 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">마술 방법 (FETCH와 같은)을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; 가 true를 반환 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; 가 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; 이 true를 리턴 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; 이 true를 반환 하면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad610951e9b392fd2e2ceadbb198a63f8613f82d" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">구문 분석 할 행이 더 이상 없을 때 호출됩니다. 함께 제공되는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 객체 가 없으므로 &lt;code&gt;TAP::Parser&lt;/code&gt; 객체가 대신 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">'get'매직이있는 경우 SV에서 &lt;code&gt;mg_get&lt;/code&gt; 을 호출 합니다. 예를 들어, 이것은 묶인 변수에서 &lt;code&gt;FETCH&lt;/code&gt; 를 호출 합니다. 이 매크로는 인수를 두 번 이상 평가합니다.</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">SV에 'set'매직이있는 경우 &lt;code&gt;mg_set&lt;/code&gt; 을 호출 합니다. &lt;code&gt;$|&lt;/code&gt; 와 같은 마법 변수 인 경우 스칼라를 수정 한 후에 필요합니다. 또는 묶인 변수 ( &lt;code&gt;STORE&lt;/code&gt; 호출 ). 이 매크로는 인수를 두 번 이상 평가합니다.</target>
        </trans-unit>
        <trans-unit id="d8df026416b8e868f3c4d19bec4e4735f833a540" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt;). This macro evaluates its argument more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">VMS 디버거를 호출합니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">디버깅 모드를 호출합니다. 주로 해커를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">링커를 호출하여 객체 파일에서 라이브러리 파일을 생성합니다. 스칼라 컨텍스트에서 라이브러리 파일의 이름이 리턴됩니다. 목록 컨텍스트에서 라이브러리 파일 및 작성된 모든 임시 파일이 리턴됩니다. 필수 &lt;code&gt;objects&lt;/code&gt; 매개 변수에는 처리 할 오브젝트 파일의 이름이 문자열 (하나의 오브젝트 파일의 경우) 또는 목록 참조 (하나 이상의 파일의 경우)로 포함됩니다. 다음 매개 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">링커를 호출하여 객체 파일에서 실행 파일을 생성합니다. 스칼라 컨텍스트에서 실행 파일 이름이 리턴됩니다. 목록 컨텍스트에서 실행 파일 및 작성된 모든 임시 파일이 리턴됩니다. 필수 &lt;code&gt;objects&lt;/code&gt; 매개 변수에는 처리 할 오브젝트 파일의 이름이 문자열 (하나의 오브젝트 파일) 또는 목록 참조 (하나 이상의 파일)로 포함됩니다. 선택적 매개 변수는 다음 을 제외 하고 &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="79f933cf2af8919cd4f873f791c92f88082706ff" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;link&lt;/code&gt; with exception for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="96cd3dba8626073590cef0284f10ba68d27dc29f" translate="yes" xml:space="preserve">
          <source>Invoking C-style &lt;code&gt;open&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">클래스 메소드 호출</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">펄 호출</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">한 번의 호출로 모든 버전의 메소드 호출</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 를 통해 테스트 스크립트를 호출하는 것은 매우 중요한 일이었습니다. 확장의 일부인 다양한 파일을 찾을 수 있도록 모든 &lt;code&gt;-I&lt;/code&gt; 인수 와 함께 perl을 호출 했습니다. 그것은</target>
        </trans-unit>
        <trans-unit id="2ecba9a37fd38e5bf42e93fcbe6104f64a6dc5ac" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt;&quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5657593a133551a2130d25fd548705e5a0d18d8" translate="yes" xml:space="preserve">
          <source>IoFLAGS</source>
          <target state="translated">IoFLAGS</target>
        </trans-unit>
        <trans-unit id="3bb882aae446ce0088800e6387a83d4c1329eedf" translate="yes" xml:space="preserve">
          <source>IoTYPE</source>
          <target state="translated">IoTYPE</target>
        </trans-unit>
        <trans-unit id="889224e3fca24a6ab17d01fe47a45bc82244e938" translate="yes" xml:space="preserve">
          <source>Iran</source>
          <target state="translated">Iran</target>
        </trans-unit>
        <trans-unit id="eb2131ece0efe78ee8bb1ae98af6099114a8df09" translate="yes" xml:space="preserve">
          <source>Ireland</source>
          <target state="translated">Ireland</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">McGillicuddy 전체를위한 아일랜드어. Perl 문화에서 &quot;sharp&quot;와 &quot;bang&quot;의 포트만 토는 &lt;code&gt;#!&lt;/code&gt; 의미합니다 ! 시스템에 인터프리터를 찾을 위치를 알려주는 순서.</target>
        </trans-unit>
        <trans-unit id="15b9752e24986e0f7c7c5303acc5a2830fc9afd6" translate="yes" xml:space="preserve">
          <source>Irix (6.5. What else?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">이 릭스 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이 여기의 모든 코드 예제는 공개 도메인에 있습니다. 귀하는이 코드와 그 파생어를 자신의 프로그램에서 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. FAQ에 신용을 부여하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이이 파일의 모든 코드 예제는 공개 도메인에 배치됩니다. 귀하는 자신의 프로그램에서이 코드를 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. 크레딧을 제공하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">배포와 상관없이이 파일의 모든 코드 예제는 공개 도메인에 배치됩니다. 귀하는 자신의 프로그램에서이 코드를 재미 나 이익을 위해 자신의 프로그램에서 사용하는 것이 허용되고 권장됩니다. 크레딧을 제공하는 코드의 간단한 설명은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">펄은 배우기가 어렵습니까?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">더 잘 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f9ed743f2c1371f19760689c4a59cf333c563af" translate="yes" xml:space="preserve">
          <source>Is it possible to change the file permissions of a file on an FTP server ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">로컬 또는 어휘 데이터에 대한 참조를 반환하는 것이 안전합니까?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">같은가요? 글쎄요, 어쩌면 아닐 수도 있습니다. 미묘한 차이점은 대괄호로 무언가를 할당 할 때 항상 새로운 것이있는 새로운 참조임을 알고 있다는 것입니다</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">프로세스 식별 번호 0 또는 음수에는 지원되지 않습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="85e623ea793b61351aedc1f6283751b7266d3791" translate="yes" xml:space="preserve">
          <source>Is supposed to be superseded by &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; but is still useful for determining the types of floppy diskette formats that can be produced by a given floppy drive. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed13e4ee416049073be2fb55253aff4db8cf0204" translate="yes" xml:space="preserve">
          <source>Is the disk signature, a unique number assigned by Disk Administrator [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">일반적인 기능입니까?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">구현이 이식성이 충분 할까?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">구현이 강력합니까?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">구현이 테스트 되었습니까?</target>
        </trans-unit>
        <trans-unit id="7ff173c83692442c34b8acc41b270ff651c2392a" translate="yes" xml:space="preserve">
          <source>Is the scalar handle opened on something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">Perl을위한 예쁜 프린터 (포맷터)가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">자동으로 디코딩하거나 인코딩하는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">&quot;ps&quot;와 같은 프로그램에서 perl의 명령 행을 숨길 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">IDE 또는 Windows Perl Editor가 있습니까?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">다른 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">알아야 할 다른 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">충분한 문서가 있습니까?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">제출자 만이 언어에 추가하기를 원하는 것입니까, 아니면 광범위하게 유용한가요? 때때로, 초점을 맞추는 기능을 추가하는 대신 포터는 누군가가보다 일반적인 기능을 구현할 때까지 기다리기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">이 문서가 당신이 쫓은 문서입니까?</target>
        </trans-unit>
        <trans-unit id="c801f4251dba57aee2f236238406c19df06e8971" translate="yes" xml:space="preserve">
          <source>Is this you? Is writing tests right up there with writing documentation and having your fingernails pulled out? Did you open up a test and read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243aed46fb67b26a47f5f82cb478ce344d097065" translate="yes" xml:space="preserve">
          <source>Is your program EMX-compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af501c530066fe2526868f8de57f9ed976517fd9" translate="yes" xml:space="preserve">
          <source>IsContainerPartition</source>
          <target state="translated">IsContainerPartition</target>
        </trans-unit>
        <trans-unit id="c6193261c02de21aac043fe2d15ff95fc2e34dca" translate="yes" xml:space="preserve">
          <source>IsRecognizedPartition</source>
          <target state="translated">IsRecognizedPartition</target>
        </trans-unit>
        <trans-unit id="d95874ba2baf2aa8c816605d15eea330b17427d2" translate="yes" xml:space="preserve">
          <source>IsSTD</source>
          <target state="translated">IsSTD</target>
        </trans-unit>
        <trans-unit id="9f55afe53a666115430d24161c215ea18ed5b9a0" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar heavier on memory than /bin/tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a285d7f91e6104f157a9d3d5748d7dac064dcf" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar slow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c197dfd67f1ed79d11a8b0218cc368bfcce6ccb" translate="yes" xml:space="preserve">
          <source>Israel</source>
          <target state="translated">Israel</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">다음과 같이 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="634b2e574e8681fa4bd024f62981fab9bb1e46c1" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03592f61d67d4b9df2c210af49940f16e407a6d4" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">&lt;code&gt;ualarm&lt;/code&gt; 호출을 발행합니다 . &lt;code&gt;$interval_useconds&lt;/code&gt; 선택 사항이며 지정되지 않은 경우의 결과로, 0이됩니다 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 행동 -like.</target>
        </trans-unit>
        <trans-unit id="451bb20dde9f17b91d4ea56d923babf92e6ab559" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm&lt;/code&gt;-like behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;rsync&lt;/code&gt; uri로 가리키는 파일 을 여러 가지 다른 방법 으로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f7f3deaf6b10a7e4949b31b699d2af4c0c5c2a4" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">템플릿을 통해 입력을 확인할 수 있습니다. 인수의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9dcbab629dab7b7bb8a9a5c305c5b7edec8fe86" translate="yes" xml:space="preserve">
          <source>It also causes &lt;code&gt;decode&lt;/code&gt; to parse such tagged JSON values and deserialise them via a call to the &lt;code&gt;THAW&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;$x&lt;/code&gt; 에서 참조를 활성화해야하는 &lt;code&gt;$$x = 5&lt;/code&gt; 와 같이 lvalue 컨텍스트에서 특수하게 작동해야하는 항목을 플래그 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f46a706382c3e7f690244335b6067ef888c4bc96" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">또한 설명서가 포함되어 있으므로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;IO::String&lt;/code&gt; 과 같은 실제 파일 시스템 파일과 관련되지 않은 perl 파일 핸들을 전달하는 것이 불가능했습니다 .</target>
        </trans-unit>
        <trans-unit id="affbbcabd9e89330cd688705cb152f75ac31dcc5" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">또한 MM 클래스를 통해 편리한 별칭을 제공합니다 (ExtUtils / 외부에서 MakeMaker 모듈을 원하지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">또한 MY 클래스를 통해 편리한 별명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">또한 모든 &lt;code&gt;HvENAME&lt;/code&gt; 유효한 이름 ( HvENAME )을 적절하게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fdd0b99c263719f6c7ac54250b06d02a9d280c92" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt;) on all the stashes as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b119a076af514e51ac37bcaf3aa61a59bc6514" translate="yes" xml:space="preserve">
          <source>It also supports tying via a win32 handle (for example, from &lt;code&gt;createFile()&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">또한 EBCDIC에는 ASCII / Latin1 C0 컨트롤 및 DELETE 컨트롤에 거의 동일한 기능이 있습니다. (C0 컨트롤은 ASCII 코드 포인트가 0..0x1F 인 탭, ACK, BEL 등입니다.) 이러한 ASCII / EBCDIC 컨트롤 사이에 매핑이 설정됩니다. ASCII 플랫폼의 C1 컨트롤과 나머지 EBCDIC 컨트롤 사이에는 정확한 매핑이 없습니다. 수행 된 작업은 이러한 컨트롤을 대부분 임의로 임의로 다른 문자 집합의 일치하지 않는 문자에 매핑하는 것입니다. 어쨌든 오늘날 대부분은 EBCDIC에서 거의 사용되지 않으며 많은 불만없이 이름이 삭제되었습니다. 예를 들어 EO (Eight Ones) EBCDIC 컨트롤 (8 비트 1 비트 = 0xFF로 구성됨)은 C1 APC 컨트롤 (0x9F)에 ​​매핑되며 &quot;EO&quot;라는 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e72af9b0783d77ee6316a243e984feea8033ad2" translate="yes" xml:space="preserve">
          <source>It assumes that pat has the same utf8-ness as sv. It's the caller's responsibility to ensure that this is so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9e21d973b85a09332d5d3faae1a519ffea9ab5" translate="yes" xml:space="preserve">
          <source>It attempts to meet all &quot;MUST&quot; requirements of the specification, but does not implement all &quot;SHOULD&quot; requirements. (Note: it was developed against the earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235 spec.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd158a359289156ad701983e580703419c574eb4" translate="yes" xml:space="preserve">
          <source>It becomes more important for perl to know about all the possible locale categories on the platform, even if they aren't apparently used in your program. Perl knows all of the Linux ones. If your platform has others, you can submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; for inclusion of it in the next release. In the meantime, it is possible to edit the Perl source to teach it about the category, and then recompile. Search for instances of, say, &lt;code&gt;LC_PAPER&lt;/code&gt; in the source, and use that as a template to add the omitted one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">실패시 &lt;code&gt;croak&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">Fast Boyer Moore 일치를 &lt;code&gt;find_byclass()&lt;/code&gt; 하는 fbm_instr () 및 프로그램에서 첫 번째 필수 regop을 사용하여 시작을 찾는 &lt;code&gt;fbm_instr()&lt;/code&gt; 와 같은 몇 가지 다른 루틴을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">또한에서 애플리케이션으로 확장 될 수 &lt;b&gt;C&lt;/b&gt; 에 &lt;b&gt;C&lt;/b&gt; 에 그 제한하면서, &lt;b&gt;R의&lt;/b&gt; 다음의 정의를 이용하여 앞에서 정의한 바와 같이 동작합니다</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">긴 복식과 복식은 같은 것이 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">리소스를 파일에 직접 저장할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">물론 객체 나 클래스에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">이미지를 작성해야하는 파일 이름과 함께 저장 될 오브젝트에 대한 참조로 &lt;code&gt;store&lt;/code&gt; 를 호출하여 정기적 인 절차 적 방식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">다음과 같이 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">perl 동적 확장을로드 할 수 있으며 fork () 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3c2d30ca072f4084789964fe3766438b6284d3" translate="yes" xml:space="preserve">
          <source>It can lose track of whether something should be encoded as UTF-8 or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">그러나 다른 클래스의 수퍼 클래스로 사용될 수 있습니다. 이를 용이하게하기 위해 생성 된 생성자 메소드는 두 개의 인수 축복을 사용합니다. 또한 클래스가 해시 기반 인 경우 각 요소의 키 앞에 클래스 이름이 붙습니다 (참조</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">그것은의 기능을 결합</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">$ treewalker coderef를 생성하고 반환합니다.이 코드 참조는 호출, 트래버스 또는 걷을 때 주어진 인수의 optree를 STDOUT에 렌더링합니다. 이를 재사용 할 수 있으며 매번 사용되는 렌더링 스타일을 변경할 수 있습니다. 그 후 coderef는 새로운 스타일로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8ee601f689d3bf17ef24ff756daa44f51b167191" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">보고서로 전환 할 수있는 프로필 정보 데이터베이스를 만듭니다. &lt;code&gt;nytprofhtml&lt;/code&gt; 명령은 유사한 HTML 보고서에 데이터를 회전 &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;(STABLE) : 커버&lt;/a&gt; 보고서 :</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">그것은 현재</target>
        </trans-unit>
        <trans-unit id="e547a28181c8513c90dab654ebd4bf8ae08d6f97" translate="yes" xml:space="preserve">
          <source>It delivers the correct results for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; items, without you having to write extra code. The reason for the extra code would be because these are from the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale category, which is normally kept set by Perl so that the radix is a dot, and the separator is the empty string, no matter what the underlying locale is supposed to be, and so to get the expected results, you have to temporarily toggle into the underlying locale, and later toggle back. (You could use plain &lt;code&gt;nl_langinfo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt;&lt;/code&gt; for this but then you wouldn't get the other advantages of &lt;code&gt;Perl_langinfo()&lt;/code&gt;; not keeping &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the C (or equivalent) locale would break a lot of CPAN, which is expecting the radix (decimal point) character to be a dot.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">&quot;탈출&quot;의 의미에 따라 다릅니다. URL 이스케이프는 &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 에서 처리됩니다 . 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 문자가 있는 쉘 이스케이프 는</target>
        </trans-unit>
        <trans-unit id="cdac17a54a39be9556592ce5c191473c9ecfd72c" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt;) character are removed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">$-[0] 및 $ + [0]에 잘못된 것을 넣는 단점이 있지만 일반적으로이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">전체 UTS # 18 그룹화, 교차, 결합 및 제거 (빼기) 구문을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="25a28128ab3b4005d07e5b53db8c8141489e82c0" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="053e3e1bd8bbb865867e84abe6ea50be636b0060" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd843b35cf6f524d8898789fded24bf5b532aee" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">이 같은 않습니다 &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfa9126aa95883d132daa2d80bb8c833bb459ad" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">변수를 여전히 대체 할 수 있도록 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 를 보호하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c7a5ea655e7023099d39c28a9e780a041767575" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;'$'&lt;/code&gt; or &lt;code&gt;'@'&lt;/code&gt;, so that variables can still be substituted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">모든 C 구문을 처리하지는 않지만 에바 내부에서 정의를 분리하려고 시도하므로 변환 할 수있는 정의를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">해당 요소가 이미 있는지 여부는 중요하지 않습니다. 중간에 요소를 필요에 따라 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하여 기쁘게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae5276d8d54bb235b88eecab0650a76f813b6ff" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;undef&lt;/code&gt; as need be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">서브 루틴에서 리턴 된 모든 항목에 제어가 리턴 될 때 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">서브 루틴에서 실제로 리턴되는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">서브 루틴에서 스칼라 만 실제로 리턴되도록합니다. 물론 서브 루틴은</target>
        </trans-unit>
        <trans-unit id="c5a8cac5521955b5cf81a85b7f0157a0da48a8fd" translate="yes" xml:space="preserve">
          <source>It evaluates to TRUE if, besides those 4 words, any of the sequences &quot;feed&quot;, &quot;field&quot;, &quot;Defoe&quot;, &quot;fume&quot;, and many others are in &lt;code&gt;$foo&lt;/code&gt;. By judicious use of &lt;code&gt;\b&lt;/code&gt; (or better (because it is designed to handle natural language) &lt;code&gt;\b{wb}&lt;/code&gt;), we can make sure that only the Giant's words are matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">다음 변수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">번들링은 상당히 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd9057379828dbfc73545c27db82f9785af3f5b" translate="yes" xml:space="preserve">
          <source>It has not been extensively tested yet and buffered I/O is not yet implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">배열을 관리하기 위해 매우 간단한 클래스 만 구현합니다. &lt;code&gt;new&lt;/code&gt; 생성자 외에도 정적 및 가상의 메소드를 선언합니다. 정적 메소드 &lt;code&gt;PrintID&lt;/code&gt; 는 단순히 클래스 이름과 버전 번호를 인쇄합니다. 가상 메소드 인 &lt;code&gt;Display&lt;/code&gt; 는 배열의 단일 요소를 인쇄합니다. 다음은 그것을 사용하는 모든 Perl 예제입니다.</target>
        </trans-unit>
        <trans-unit id="194ff250d804880fa7aa6c2644ae6036e2023968" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt;, it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt;, prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt;, prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">여기에는 TAP :: Parser Cookbook이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">리스트 컨텍스트에서 실행 중이라는 서브 루틴을 표시합니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">서브 루틴이 스칼라 컨텍스트에서 실행 중임을 표시합니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">호출 된 서브 루틴이 void 컨텍스트에서 실행 중임을 나타냅니다 (실행중인 경우).</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">응용 프로그램의 &quot;직접 실행 또는 웹을 통해 실행되는&quot;응용 프로그램이 &quot;현지화&quot;될 수 있도록하는 공통 기능입니다. 등 프로그래밍 된 모든 언어에 적용됩니다. Locale :: Maketext는 소프트웨어 현지화를위한 프레임 워크입니다. 현지화 된 응용 프로그램을 작성하는 데 필요한 텍스트 및 텍스트 처리 코드를 구성하고 액세스하기위한 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">사용자가 어떤 언어로 출력을 선호하는지 감지하는 것은 일반적인 문제입니다.</target>
        </trans-unit>
        <trans-unit id="84d9ffe2b782da4eace968e860a68bb94a1236cb" translate="yes" xml:space="preserve">
          <source>It is a fatal error if an operand contains a character whose ordinal value is above 0xFF, and hence not expressible except in UTF-8. The operation is performed on a non-UTF-8 copy for other operands encoded in UTF-8. See &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;&quot;Byte and Character Semantics&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1950 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1951 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; 이 RFC 1952 데이터 스트림이 아닌 경우이 옵션을 사용하는 것은 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">목록 컨텍스트를 제외하고이 함수를 호출하는 것은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">비 참조 $ obj를 등록하는 것은 치명적인 오류입니다. 다음 인수 중 비해시 참조는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">그것은 펄 버전에 키가 해시의 해시입니다. 각 키 해시는 다음 키를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">그렇게하는 것이 조금 더 쉽습니다</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">속성 값이있는 모든 코드 포인트의 전체 목록으로 반전 목록을 확장하는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">그것은 사용에 구문 오류입니다 &lt;code&gt;\N{NAME}&lt;/code&gt; 여기서 &lt;code&gt;NAME&lt;/code&gt; 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">여러 모듈을 한 번에로드 할 수 있거나 그 중 하나를로드 할 수없는 경우 전혀로드 할 수 없습니다. 또한 오류 점검 등을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">형식 이름은 정규식 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; -a -zA-Z0-9 _] + \ z / 와 일치하는 것이 좋습니다 . formatname 다음의 공백 뒤에 오는 모든 것은이 영역을 다룰 때 포맷터가 사용할 수있는 매개 변수입니다. 이 매개 변수는 &quot;= end&quot;단락에서 반복해서는 안됩니다. 구현자는 첫 ​​번째 매개 변수의 의미와 구문에서 &quot;= begin&quot;/ &quot;= end&quot;/ &quot;= for&quot;로 확장 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="e650500b6f0231025bf8e8986cda639228e156b4" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">인코딩 클래스는 &lt;code&gt;Encode::Encoding&lt;/code&gt; 에서 기본 클래스로 상속하는 것이 매우 바람직합니다 . 이를 통해 해당 클래스는 모든 인코딩 객체에 대한 추가 동작을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">또한 인터페이스가 OS / 2, NT 등의 요구를 충족하고 의사 동적 링크 ( 런타임에 &lt;code&gt;ld -A&lt;/code&gt; 사용)를 허용 할 것으로 기대됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">또한 이것이 기본 경계 정의이며 구현시 특정 목적과 로케일에 맞게 결과를 조정하기를 원할 수도 있음을 인식하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="71ce07ae3818cf03055cfa783a2edee6c6d417e8" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales. For example, some languages, such as Japanese and Thai, require dictionary lookup to accurately determine word boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">반대로 일어날 수도 있습니다 : &lt;code&gt;prop_aliases('isc')&lt;/code&gt; 는리스트를 반환합니다 &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; 반면 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 반환 &lt;code&gt;(C, Other)&lt;/code&gt; (후자는 의미 펄 확장자 &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;속성 접근 유니 코드 : UCD를 통해 perluniprops의에서&lt;/a&gt; 목록들 사용에서 낙담하는 포함 가능한 형태를.</target>
        </trans-unit>
        <trans-unit id="46b4ec4d35947f03a43a47b65cb8093dc3e99125" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt;; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt;. &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;&quot;Properties accessible through Unicode::UCD&quot; in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">&quot;miniperl&quot;및 &quot;perl&quot;에 대한 Symbian 실행 파일을 생성 할 수도 있지만 Symbian에 대한 표준 명령 줄 인터페이스 (장치의 전체 키보드도 아님)가 없기 때문에 주로 데모로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; 및 &lt;code&gt;cplxe&lt;/code&gt; 의 인수로 복소수를 가질 수도 있습니다. 인수의 적절한 구성 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f695912980907c9e4ce8ee64fb36b966f74913d" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt;: the appropriate component of the argument will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">대신 일치하지 않는 문자를 나열 할 수도 있습니다. 캐럿 ( &lt;code&gt;^&lt;/code&gt; )을 문자 클래스의 첫 번째 문자로 사용하면됩니다. 예를 들어, &lt;code&gt;[^a-z]&lt;/code&gt; 는 소문자 ASCII 문자가 아닌 모든 문자와 일치하므로 백만 개 이상의 유니 코드 코드 포인트가 포함됩니다. 이 클래스는 &quot;부정적&quot;또는 &quot;거꾸로&quot;있다고합니다.</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">Math :: BigFloat 만 요구할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fa6ca91de346d776bfa7cb7677e64152ae10a28" translate="yes" xml:space="preserve">
          <source>It is also possible to keep &lt;code&gt;origin&lt;/code&gt; as a git remote, and add a new remote for ssh access:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">filename 매개 변수도 생략 할 수 있으므로 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">매개 변수 목록을 통해 직접 값을 반환 할 수도 있습니다. 실제로 전체적으로 다른 작업을하는 것이 바람직한 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">옵션이 취하는 최소 및 최대 인수 수를 지정할 수도 있습니다. &lt;code&gt;foo=s{2,4}&lt;/code&gt; 는 최소 2 개에서 최대 4 개의 인수를 취하는 옵션을 나타냅니다. &lt;code&gt;foo=s{1,}&lt;/code&gt; 는 하나 이상의 값을 나타냅니다. &lt;code&gt;foo:s{,}&lt;/code&gt; 는 0 개 이상의 옵션 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">사전 정의 된 경고 범주가 &lt;code&gt;warnings::enabled&lt;/code&gt; 기능을 사용 하여 호출 모듈에 설정되어 있는지 테스트 할 수도 있습니다 . 이 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">또한 다른 모든 Perl 연산자는 피연산자에 컨텍스트 (일반적으로 문자열 또는 숫자 컨텍스트)를 적용하여 해당 피연산자를 부과 된 컨텍스트로 자동 변환합니다. 대조적으로, 스마트 매치</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">또한 &lt;code&gt;nextStream&lt;/code&gt; 은 언제든지 호출 할 수 있다는 점에 주목할 필요가 있습니다. 다음 데이터로 건너 뛰기 전에 압축 된 데이터 스트림을 모두 사용할 때까지 기다릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe6480e97532361598fcacd4a646c8dd90b848cc" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">패턴 &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; 의 (? &amp;lt;NAME&amp;gt;)에 의해 정의되지 않은 이름을 참조하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">패턴 어딘가에 선언되지 않은 이름을 참조하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">시도하는 것은 오류입니다</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">모듈 이름이 제공되면 해당 이름이 파일 이름과 일치한다고 가정합니다. 'NAME'항목을 확인하기 위해 포드가 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">이 단계에서 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;/^/&lt;/code&gt; 을 자동으로 최적화 하여 &lt;code&gt;/^/m&lt;/code&gt; 을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="0f53779f0c0d37544de988c790844edfe4fdb773" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;split()&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">이 단계 에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 대체 텍스트에서 &lt;code&gt;\1&lt;/code&gt; 을 &lt;code&gt;$1&lt;/code&gt; 로 변환하여 변환 할 수 없는 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="5668f9f099405dc43b82952ae4d9de3551af43ad" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;s///&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3008b3fc272ebfbc9d46dd564fe851829fe13a2" translate="yes" xml:space="preserve">
          <source>It is better to restructure your code so the end pointer is passed down so that you know what it actually is at the point of this call, but if that isn't possible, &lt;a href=&quot;#UTF8_CHK_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt;&quot;&lt;/a&gt; can minimize the chance of accessing beyond the end of the input buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">인라인 코드는 오버 헤드가 적기 때문에 서브 루틴 또는 메소드 호출보다 빠를 것이 분명하지만,이 접근 방식은 유지 관리가 쉽지 않고 메모리 사용량이 증가한다는 단점이 있습니다. 무료 점심 식사. 목록에서 요소를 검색하는 경우 해시 구조에 데이터를 저장 한 다음 grep ()을 사용하여 전체 배열을 반복하는 것보다 키가 정의되어 있는지 확인하는 것이 더 효율적일 수 있습니다. 예. substr ()은 grep ()보다 빠르지 만 유연하지는 않으므로 액세스 할 수있는 또 다른 단점이 있습니다. 코드에는 실행하는 데 0.01 초가 걸리는 행이 포함될 수 있습니다. 1,000 번 호출하면 중간 크기의 파일을 파싱하는 프로그램에서 단일 코드 위치에서 이미 10 초 지연이 발생합니다.그 라인을 100,000 번 호출하면 전체 프로그램이 견딜 수없는 크롤링으로 느려집니다.</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">@INC (well, scriptdir) 디렉토리 만 검색되도록 &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; new- &amp;gt; find ( &quot;perlvar&quot;) 라고 말하는 것이 일반적 입니다. 이것은 &lt;code&gt;inc&lt;/code&gt; 속성이 기본적으로 true 이기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">일반적으로 시스템에 라이브러리를 동적으로로드 할 수있는 기능이 없으면 XSUB를 빌드 할 수 없습니다. 이것은 올바르지 않습니다. 당신</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">간접 연산자 &lt;code&gt;*&lt;/code&gt; 는 유형의 일부로, 주소 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 변수 의 일부로 간주되어야 한다고 생각하는 것이 편리 합니다. C 유형의 한정자 및 단항 연산자 처리에 대한 자세한 내용은 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">변수 &quot;속성&quot;과의 유사성을 강조하기 위해 콜론 (예 &lt;code&gt;:perlio&lt;/code&gt; )으로 레이어 이름을 시작하는 것이 일반적 입니다. 그러나 PERLIO 환경 변수를 디코딩하는 데 사용되는 레이어 사양 문자열을 구문 분석하는 코드는 콜론을 구분 기호로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0a6add6b8448b0bfc8e6cd8b6eca23cb56fc1aa2" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt;) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">열심히 미래에, 형식 (및 포맷터)의 수를 증가 시키면 직접 유니 코드 문자를 지원 될 것으로 기대된다 (같은 (X) HTML과 수행 &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; ), 특이 체질의 필요성을 줄여 유니 코드 대 매핑</target>
        </trans-unit>
        <trans-unit id="11bfea9ea83d9dc8ba6d1c8b2251fc92f5e63836" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">주석으로 보는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">서브 루틴이 프로토 타입과 서명을 모두 가질 수 있습니다. 프로토 타입은 서브 루틴에 대한 호출 컴파일에 영향을 미치며 서명은 런타임에 인수 값을 어휘 변수에 넣습니다. 그러므로 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="63ae6e7127f1e6349a2992ac6b857022220dd1af" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences by using the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module. These custom names are lexically scoped, and so a given code point may have different names in different scopes. The name used is what is in effect at the time the &lt;code&gt;\N{}&lt;/code&gt; is expanded. For patterns in double-quotish context, that means at the time the pattern is parsed. But for patterns that are delimitted by single quotes, the expansion is deferred until pattern compilation time, which may very well have a different &lt;code&gt;charnames&lt;/code&gt; translator in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">문자와 문자 순서에 고유 한 이름을 지정할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">명시 적으로 변경되지 않아야하는 메소드에 대한 인수는 일정 할 것으로 예상됩니다 (그러나 적용되지는 않음).</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">우리가 경험을 쌓으면서 정확히 &lt;code&gt;'strict'&lt;/code&gt; 것이 시간이 지남에 따라 진화 할 것으로 예상 됩니다. 이것은 오늘날의 Perl에서 그 아래에서 컴파일되는 프로그램이 향후 Perls에서 컴파일되지 않거나 경고가 많거나 적을 수 있음을 의미합니다. 이와 관련하여 이전 버전과의 호환성 약속은 없습니다. 또한이를 활성화하기위한 대체 구문에 대한 제안이 이미 있습니다. 이러한 이유로, 카테고리를 끄지 않으면 &lt;code&gt;experimental::re_strict&lt;/code&gt; 클래스 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">요청에 따라 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">일반적으로 비 UTF-8 로케일과 유니 코드를 혼합하는 것은 좋지 않습니다.이 문제는 그 이유 중 하나입니다. 이 경고는 일반적으로 유니 코드 규칙으로 인해이 작업의 결과에 로캘 0..255로 지정된 범위에있는 문자가 포함되어 유니 코드가 아닌 로캘의 규칙이 적용되는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">보장된다</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">보장된다</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">&lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[0-9]&lt;/code&gt; 의 하위 집합 이외의 범위와 정확히 일치하는 항목을 파지 않으면 이해하기 어렵습니다 . 올바른 원칙은 동일한 대소 문자 ([ae], [AE]) 또는 숫자 ([0-9])의 알파벳 문자로 시작하고 끝나는 범위 만 사용하는 것입니다. 안전하지 않거나 불분명 한 것 의심 스러우면 범위를 완전히 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">새로운 인터페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">그러나 백 슬래시 또는 이스케이프 시퀀스는 현재 버전이 아닌 백 슬래시 다음에 구두점 문자를 사용하지 않으며 향후 Perl 5 버전에서는 사용되지 않습니다. 따라서 단어가 아닌 문자 앞에 백 슬래시를 두는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">표준 perl TIEHASH 인터페이스를 사용하여 구현됩니다. 자세한 내용은 perlfunc (1) 및 perltie (1) 의 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af6e31eac027382e54503e05f6d0085165cacf75" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;tie&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">자세한 정보, 특히 opname, optag 및 opset에 대한 자세한 정의를 보려면 &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; 모듈 설명서를 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">지원되는 'make'프로그램을 사용하고 Config.pm이 알고 있어야합니다. nmake가없는 경우 이전에 언급 한 위치에서 dmake를 얻거나 다음에서 제공되는 이전 버전의 nmake를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">가능한 빨리 &lt;code&gt;make dist&lt;/code&gt; 를 만드는 것이 중요 합니다. 이렇게하면 &lt;code&gt;.h&lt;/code&gt; 파일 을 편집 하고 h2x를 다시 실행 하기로 결정한 경우 자동으로 생성 된 파일에 대한 변경 사항을 쉽게 병합 (1) 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">명령 행에 특수 문자 (예 : 따옴표 또는 백 슬래시)가 포함 된 경우 이러한 CLI가 다르게 작동 할 수 있음을 알아야합니다. 예를 들어, 유닉스 셸에서는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )와 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; )를 사용하여 단어를 그룹화 할 수 있습니다. 다음 대안은 Unix에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">변수에 스레드 &lt;code&gt;cond_signal&lt;/code&gt; 또는 &lt;code&gt;cond_broadcast&lt;/code&gt; 가없는 경우에도 변수에 알릴 수 있다는 점에 유의해야합니다 . 따라서 변수 값을 확인하고 요구 사항이 충족되지 않으면 대기 상태로 돌아가는 것이 중요합니다. 예를 들어 공유 카운터가 0으로 떨어질 때까지 일시 중지하려면</target>
        </trans-unit>
        <trans-unit id="38610253c48ac1bf013b9d6e4c9a87cd05da4c30" translate="yes" xml:space="preserve">
          <source>It is important to note that when called with an item that is recovered by using &lt;code&gt;localeconv&lt;/code&gt;, the buffer from any previous explicit call to &lt;code&gt;localeconv&lt;/code&gt; will be overwritten. This means you must save that buffer's contents if you need to access them after a call to this function. (But note that you might not want to be using &lt;code&gt;localeconv()&lt;/code&gt; directly anyway, because of issues like the ones listed in the second item of this list (above) for &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt;. You can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; and avoid all the issues, but then you have a hash to unpack).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">이러한 유니 코드 경계를 사용할 때 이후 버전의 유니 코드 표준이 포함 된 이후 버전의 Perl이 코드를 작성할 때와 정확히 같은 방식으로 작동하지 않을 위험이 있다는 점을 인식하는 것이 중요합니다. 이 규칙은 안정적인 것으로 간주되지 않으며 표준의 나머지 부분보다 다소 변경 될 수 있습니다. 유니 코드는 마음대로 변경할 권리가 있으며 Perl은 자신의 구현을 유니 코드의 새로운 규칙으로 업데이트 할 권리가 있습니다. 과거에는 모든 이전 문자와 다른 특성을 가진 새 문자가 표준에 추가 되었기 때문에 일부 변경 사항이 있었으므로 새 문자를 처리하기 위해 새 규칙이 공식화되었습니다. 이전 버전과의 호환성 문제가 발생하지 않아야합니다.그러나 유니 코드 기술위원회는 어떤 이유로 든 변경이 보증된다고 결정했기 때문에 일부 변경으로 인해 기존 문자 처리가 변경되었습니다. 버그를 수정하거나 새로운 규칙으로 더 나은 결과를 얻을 수 있다고 생각하기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">것을 기억하는 것이 중요하다 &lt;code&gt;yield()&lt;/code&gt; , 그것은 하드웨어, OS 실제로 무슨 일 스레딩 라이브러리에 따라 CPU를 포기하는 유일한 힌트입니다. &lt;b&gt;많은 운영 체제에서 yield ()는 작동하지 않습니다. &lt;/b&gt;따라서 &lt;code&gt;yield()&lt;/code&gt; 호출 에 대한 스레드 스케줄링을 구축해서는 안된다는 점에 유의해야 합니다. 플랫폼에서는 작동하지만 다른 플랫폼에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229373f44a4516dbdfee3cc1ec19491aa465bff2" translate="yes" xml:space="preserve">
          <source>It is intended mainly for use in assignments to references (see &lt;a href=&quot;#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot;&lt;/a&gt;, above). It also allows the backslash to be used on just some items in a list of declared variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">다음과 같은 방식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c0729952a79f213dacf0ff4ae76e571d0559ed54" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;AV *&lt;/code&gt; variable, in which this function creates a new AV to contain any appropriate messages. The elements of the array are ordered so that the first message that would have been displayed is in the 0th element, and so on. Each element is a hash with three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b304ade153185375df945a6e52ec74226ffc08" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;HV *&lt;/code&gt; variable, in which this function creates a new HV to contain any appropriate messages. The hash has three key-value pairs, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; 와 &lt;code&gt;gzreadline&lt;/code&gt; 호출을 혼용하는 것은 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="310546f36d0b89e4ca2512f6a8bbbc58b3213ebb" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">결과를 완전히 계산 한 다음 명시 적으로 반올림하거나 추가 매개 변수를 수학 함수에 다음과 같이 사용하는 것이 혼란스럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a0e27e331f66d429f8d776eb7eea1b1dc292c9e" translate="yes" xml:space="preserve">
          <source>It is like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;errors&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;errors&lt;/code&gt; should be a pointer to a &lt;code&gt;U32&lt;/code&gt; variable, which this function sets to indicate any errors found. Upon return, if &lt;code&gt;*errors&lt;/code&gt; is 0, there were no errors found. Otherwise, &lt;code&gt;*errors&lt;/code&gt; is the bit-wise &lt;code&gt;OR&lt;/code&gt; of the bits described in the list below. Some of these bits will be set if a malformation is found, even if the input &lt;code&gt;flags&lt;/code&gt; parameter indicates that the given malformation is allowed; those exceptions are noted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2033e4ba80b8d679681b08231b45a9481613f" translate="yes" xml:space="preserve">
          <source>It is more correct and more complete than &lt;a href=&quot;HTTP::Lite&quot;&gt;HTTP::Lite&lt;/a&gt;. It supports proxies and redirection. It also correctly resumes after EINTR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프 에서 사용하는 것이 가장 편리합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">PA-RISC 1.1 또는 2.0 플랫폼에서 PA-RISC 1.0 실행 파일을 더 이상 컴파일 할 수 없습니다. 명령 줄 플래그는 허용되지만 결과 실행 파일은 PA-RISC 1.0 시스템으로 전송 될 때 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">명령 줄 플래그가 여전히 존재하더라도 PA-RISC 1.0 공유 라이브러리를 더 이상 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;EWOULDBLOCK&lt;/code&gt; (또는 동등한) 조건 으로 인해 실패하면 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 false를 리턴 하는 오류로 간주되지 않습니다 . 이것은 여전히 &lt;code&gt;LOCK_NB&lt;/code&gt; 옵션으로 호출 될 때 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 테스트하는 일반적인 규칙을 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5203d22c8328a2d0b2cff53631202830f7dc2011" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;flock&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;flock&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">&lt;code&gt;fieldhash&lt;/code&gt; 및 / 또는 &lt;code&gt;fieldhashes&lt;/code&gt; 함수 를 사용할 모든 클래스로 함수를 가져 오는 것은 바람직하지 않습니다 . 수업을 설정하는 데 한 번만 사용됩니다. 수업이 시작되면이 기능은 더 이상 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">이미 체리 피킹 한 변경 사항과 관련된 체리 피킹 펄 델타 항목에 투표를 실시 할 필요는 없습니다. 또는 메인 펌프가 필요한 변경 사항에 대한 투표권을 얻지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="27e3bb472e9cdfda94e8831e0977881e11fb42e5" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;&quot;Getting changes into a maint branch&quot;&lt;/a&gt; below).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">이러한 기준에 맞는 모든 변경 사항을 포함 할 필요는 없으며 일반적으로 보안 문제 해결, 버그 충돌, 회귀 및 심각한 설치 문제에 중점을 두어야합니다. 펄의 설치 또는 실행에 영향을 미치지 않는 (예를 들어 문서의 철자 수정) 과도하게 많은 사소한 변경 사항을 포함하려는 유혹은 무엇인가 간과되는 전반적인 위험을 줄이기 위해 저항해야합니다. 이는 가치가 있고 사용자가 안정성에 대해 완전히 확신 할 수있는 유지 보수 릴리스를 작성하는 것입니다. (두 번째 관심사는 maint-pumpking을 태우거나 포함 할 변경 사항에 투표하는 압도적 인 다른 커미터를 피하는 것입니다 ( 아래 &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;maint 브랜치에 변경하기&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">INCLUDE_EXT를 채울 때 DynaLoader 또는 현재 확장을 언급 할 필요는 없습니다. INCLUDE_EXT가 언급되었지만 비어 있으면 DynaLoader와 현재 확장 만 빌드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">동일한 패키지에 상수와 동일한 이름을 가진 서브 루틴 또는 키워드를 가질 수 없습니다. 이것은 아마도 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">비트 필드를 압축하거나 압축을 풀 수 없으며 정수 바이트 만 가능합니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 항상 다음 바이트 경계에서 시작하여 필요에 따라 0 비트를 추가하여 다음 8의 배수로 올림합니다. 비트 필드를 원하면 &lt;a href=&quot;functions/vec&quot;&gt;vec가&lt;/a&gt; 있습니다. 또는 압축 해제 된 비트 문자열에서 split, substr 및 concatenation을 사용하여 문자열 수준에서 비트 필드 처리를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a07790029fea0888a82dfcdbb3f4369b9da3f5" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;pack&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;perlfunc#vec&quot;&gt;&quot;vec&quot; in perlfunc&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">실행 파일에 필수 접미사가있는 일부 운영 체제에서는 명령을 호출 할 때 접미사를 사용할 필요가 없으므로 &lt;code&gt;$^X&lt;/code&gt; 값을 파일의 경로 이름 으로 사용하는 것은 안전 하지 않습니다. &lt;code&gt;$^X&lt;/code&gt; 값을 경로 이름으로 변환하려면 다음 명령문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">다양한 문자를 일치시키는 것은 드문 일이 아닙니다. 운 좋게도 범위 내의 모든 문자를 나열하는 대신 하이픈 ( &lt;code&gt;-&lt;/code&gt; )을 사용할 수 있습니다 . 대괄호로 묶은 문자 클래스 안에 하이픈으로 구분 된 두 문자가 있으면 두 문자 사이의 모든 문자가 클래스에있는 것처럼 처리됩니다. 예를 들어, &lt;code&gt;[0-9]&lt;/code&gt; 는 모든 ASCII 숫자와 일치하고 &lt;code&gt;[a-m]&lt;/code&gt; 은 ASCII 알파벳의 전반에서 소문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7607528bdce01b011f213f8ac77cd85f02fbbdd6" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt;). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">현재 Dave Rolsky (&amp;lt;autarch@urth.org&amp;gt;)가 Perl 코어와 별도로 유지 관리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">키 / 값 쌍 사이에 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 를 사용하는 것이 더 읽기 쉽습니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자는 주로 쉼표를위한 단지 시각적으로 독특한 동의어이지만, 법적 간단한 식별자가 될 것 bareword는 인 경우에 그 좌측에 그것은 또한 주선는 피연산자 문자열로 해석 될 수 있습니다. &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 이중 콜론을 포함하는 복합 식별자를 인용하지 않습니다. 이렇게하면 해시를 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c425383e0dcd08da6401882b3bf5fc73ffa2b23f" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, a shared object's destructor may get called multiple times, once for each thread's scope exit, or may not get called at all if it is embedded inside another shared object. Another issue is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">클래스 자체가 공유를 지원하도록 작성되지 않은 경우 객체를 공유하는 것이 현명하지 않은 경우가 많습니다. 예를 들어, 객체의 소멸자는 각 스레드의 범위 종료마다 한 번씩 여러 번 호출 될 수 있습니다. 또 다른 위험은 위에서 언급 한 제한으로 인해 해시 기반 개체의 내용이 손실 될 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">&quot;CODE :&quot;줄에서 시작하는 줄은 들여 쓰지 않아도됩니다. 그러나 가독성을 높이기 위해 CODE를 들여 쓰는 것이 좋습니다. 한 수준과 한 단계 더 다음 줄입니다.</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">OS / 2 및 Win32에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea8b006ce3e53db87407f2dbaa5815e87ff2f78" translate="yes" xml:space="preserve">
          <source>It is particularly important to have this graft line if any bisecting is done in the area of the &quot;merge&quot; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">쉘이나 C 런타임 모두 명령 줄 인수의 와일드 카드 확장을 수행하지 않으므로 와일드 카드를 인용 할 필요가 없습니다. 또한 셸 및 C 런타임의 인용 동작은 가장 기초적입니다 (비표준 셸을 사용하는 경우 일관성이 없을 수 있음). 유일하게 (유용한) 인용 부호는 큰 따옴표 ( &quot;)입니다. 인수에서 공백과 기타 특수 문자를 보호하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">호출하는 Perl 서브 루틴이 비정상적으로 종료 될 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">완료시 문자열의 모든 인수가 처리되지 않았을 수 있습니다. &lt;code&gt;GetOptionsFromString&lt;/code&gt; 은 목록 컨텍스트에서 호출 될 때 리턴 상태와 배열 참조를 나머지 인수에 모두 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="67c5b12c61d00e32b42a8983e07a796133ebb6eb" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;perlfunc#require-VERSION&quot;&gt;require&lt;/a&gt; or &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">적절한 코드로 &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; 또는 &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; 을 사용하여 스레드에 &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END 블록&lt;/a&gt; 을 추가 할 수 있습니다 . 이 &lt;code&gt;END&lt;/code&gt; 블록은 스레드의 인터프리터가 파괴 될 때 (즉, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 호출 중 또는 프로그램 종료시) 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma 를 사용하여 다른 분석법 순서를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">표준 Devel :: Peek 모듈에서 mstat () 함수를 사용하여 실행시 임의의 지점에서 이러한 통계를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">Solaris에서 스레드 버전의 perl을 빌드 할 수 있습니다. 전체 펄 스레드 구현은 여전히 ​​실험적이므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">10.30 이전의 모든 HP-UX 버전에서 스레드 Perl 버전을 컴파일 할 수 있지만 최소한 HP-UX 11.00에서 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">&lt;code&gt;$Text::Wrap::break&lt;/code&gt; 수정하여 단어를 종료하는 문자를 제어 할 수 있습니다. &lt;code&gt;'[\s:]'&lt;/code&gt; (공백 또는 콜론 앞쪽으로 나누기) 와 같은 문자열 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (공백 또는 아포스트로피 앞쪽으로 나누기) 와 같은 사전 컴파일 된 정규식으로 설정 하십시오. 기본값은 단순히 &lt;code&gt;'\s'&lt;/code&gt; . 즉, 단어는 공백으로 끝납니다. (이것은 무엇보다도 마침표 나 쉼표와 같은 후행 문장 부호가 &quot;첨부 된&quot;단어와 함께 유지됨을 의미합니다.) &lt;code&gt;$Text::Wrap::break&lt;/code&gt; 문자를 먹지 않는 정규식으로 설정 ( 어쩌면 그냥 앞선 주장이 경고를 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b27989d9b82508c46a4fe952eadfb7a10b89ae6" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt;. Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;qr/[\s']/&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt;; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">Perl에서 &quot;원형 참조&quot;를 만들면 메모리 누수가 발생할 수 있습니다. 순환 참조는 다음과 같이 두 참조가 서로 참조를 포함 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="194e4ce07b732bc978b1694be34e6655ffc1b7f6" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;&quot;Unicode and EBCDIC&quot; in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">작동중인 문자 세트를 판별 할 수 있습니다. 그러나 먼저이 작업을 수행해야한다는 것을 확신해야합니다. 문자 집합을 테스트하지 않고 다른 작업을 수행 할 필요가없는 경우 코드가 더 단순하고 이식성이 뛰어납니다. 실제로 모든 문자 세트에 대해 직선 코드를 이식하기가 쉽지 않은 상황은 거의 없습니다. 이식 가능하게 문자를 지정하는 방법 &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;은 perluniintro의 유니 코드 및 EBCDIC를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">자식에서 부모 메서드를 명시 적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0da326565896926df8bd9bb48dde0df4c98d8f9" translate="yes" xml:space="preserve">
          <source>It is possible to forbid or warn on non-Unicode code points, or those that may be problematic by using &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">고독한 대시에 대한 특별한 치료를받을 수 있습니다. 예를 들어, 이름이 비어있는 옵션 사양을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0e645006456f020c2cb729a6c316a213de718eec" translate="yes" xml:space="preserve">
          <source>It is possible to import autodie into a different namespace by using &lt;a href=&quot;Import::Into&quot;&gt;Import::Into&lt;/a&gt;. However, you have to pass a &quot;caller depth&quot; (rather than a package name) for this to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">RE 엔진에 주어진 문자열과 결과로 생성 된 유한 오토 마톤을 모두 검사 할 수 있습니다. &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;perlrun의 명령 스위치에&lt;/a&gt; 문서화 된 Perl의 &lt;b&gt;-Dr&lt;/b&gt; 명령 행 스위치 뿐만 아니라 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; pragma 의 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; 인수를 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2de0a7af99e757a8e8485b1376bbc31dd1cac31e" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt;/&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">동일한 출력 채널에서 print ()를 write ()와 혼합 할 수 있지만 &lt;code&gt;$-&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; )를 직접 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17a6fb8a364afc4c2bb94e7dfbe0964a25366786" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt;) yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">호출 할 &quot;다음&quot;메소드를 찾을 수없는 경우 재발견에서 예외가 발생 하도록 &lt;code&gt;NEXT&lt;/code&gt; 재발견을 더 까다로울 수 있습니다 (예 : &lt;code&gt;SUPER&lt;/code&gt; 처럼 ).</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 를 수동으로 설정할 수 있으며 이전 Perl 코드에서이를 볼 수 있습니다. 훨씬 오래된 코드는 &lt;a href=&quot;base&quot;&gt;기본&lt;/a&gt; pragma를 사용합니다 . 새 코드의 경우 &lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; pragma를 사용하여 부모 를 선언 하는 것이 좋습니다 . 이 pragma는 &lt;code&gt;@ISA&lt;/code&gt; 설정을 처리합니다 . 또한 부모 클래스를로드하고 패키지가 자체 클래스에서 상속되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출에서 마지막 4 개의 매개 변수 중 일부 또는 전부를 생략하고 기본값을 사용할 수 있습니다. DB_HASH가 가장 많이 사용되는 파일 형식이므로 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d77ffc116f1345ae65bcfab7b549b42a9b2529d7" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;tie&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4afc212139685087c461e85b80958ff6af0a50" translate="yes" xml:space="preserve">
          <source>It is possible to pass either a subroutine reference (recommended) or a fully qualified subroutine name as the first argument. This means you can set hints on modules that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b6e646490b1b0de97fffd24d0c15d8fcfff05" translate="yes" xml:space="preserve">
          <source>It is possible to predeclare a lexical subroutine. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;my sub;&lt;/code&gt; or &lt;code&gt;state sub;&lt;/code&gt; declaration. Using this to define recursive subroutines is a bad idea, however:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;[ $test, $alias ]&lt;/code&gt; 포함 된 배열에 대한 참조로 테스트를 제공하여 테스트 이름 대신 표시 될 별명을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47d1a50872b03930e2d6b45fee9f2467c56c1224" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">이러한 영숫자 이름을 적절한 유형에 대한 참조를 리턴하는 표현식으로 대체 할 수 있습니다. 이에 대한 설명은 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">서브 루틴에서 수정 가능한 값을 반환 할 수 있습니다. 이렇게하려면 lvalue를 반환하도록 서브 루틴을 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">여러 개의 here-doc을 연속으로 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">빌드 프로세스로 작성된 EXE 및 DLL을 제거 할 수 있습니다. 결과 바이너리는 훨씬 작습니다. 바이너리를 제거하려면 Configure (구성) 메시지가 표시 될 때 &lt;b&gt;-s&lt;/b&gt; 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">테스트에 인수를 제공 할 수 있습니다. 이를 위해서는 arisdottle '::'을 사용하여 prove 자체의 주장과 분리하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="843780a126a92b7260b78a50d262eb7d19529c37" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl, as a module named &lt;code&gt;PerlIO::&amp;lt;layer name&amp;gt;&lt;/code&gt;. Some custom layers come with the Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">C / XS 및 Perl 모두에서 위의 내장 레이어 외에 사용자 정의 레이어를 작성할 수 있습니다. 이러한 두 계층 (및 후자를 사용하여 Perl로 작성된 하나의 예)에는 Perl 분포가 있습니다.</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">다음과 같이 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3043edf54589d4a75af8ab5a83729379d66bb57a" translate="yes" xml:space="preserve">
          <source>It is possible, though hard to do, to call &lt;code&gt;POSIX::setlocale&lt;/code&gt; with a locale that it doesn't recognize as syntactically legal, but actually is legal on that system. This should happen only with embedded perls, or if you hand-craft a locale name yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d15f29d6da4dd3ad23f2444184a1dcb4a66f4b0" translate="yes" xml:space="preserve">
          <source>It is probably best to chose either the Decimal notation or the string notation and stick with it, to reduce confusion. Perl6 version objects &lt;b&gt;may&lt;/b&gt; only support Decimal comparisons. See also &lt;a href=&quot;#Quoting-Rules&quot;&gt;&quot;Quoting Rules&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(?{})&lt;/code&gt; 또는 &lt;code&gt;(??{})&lt;/code&gt; 와 결합 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="afaea2dff924e16be833d549ac45ba57d1ea538b" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">향후 Perl 릴리스에서이 동작을 변경하여 유니 코드 규칙이 적용되는지 여부에 따라 동작이 변경되지 않도록하는 것이 좋습니다. 로케일 외부에서 POSIX 클래스는 ASCII 범위의 클래스처럼 작동합니다. 이 제안에 대해 의견이 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 로 이메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">이 사용법에서는 패턴의 끝에 DEFINE 블록을 배치하고 그 안에 정의 된 하위 패턴의 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">비표준 Zip 파일을 실제로 만들어야하는 경우가 아니면이 옵션을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b5a6bde3e661db2000d4d1c6b83211f16182f9b2" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;code&gt;use Win32;&lt;/code&gt; before any of these functions; however, for backwards compatibility, those marked as [CORE] will automatically do this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">다음 아카이브에는 perl을 빌드하기에 충분한 유틸리티가 포함되어 있다고보고됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">소문자 이름은 Opcode 모듈에서 사용하도록 예약되어 있으므로 Opcode를 사용하는 응용 프로그램은 태그 이름에 선행 대문자를 사용해야합니다. 모듈 내에서 Opcode를 사용하는 경우 고유성을 보장하기 위해 태그 이름 앞에 모듈 이름을 붙여 다른 모듈과의 충돌을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">스크립트에서 가능한 빨리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 를 통해 스레드를 활성화하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="607d6dc00476120329bf70c7f37db42c62c363f4" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;use threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">Configure를 실행할 때이 플래그를 사용하는 것이 좋습니다. 이렇게하지 않으면 나중에 Configure에서 요청할 때 큰 파일에 대한 질문에 대답하면 컴파일 할 수 없거나 예상대로 작동하지 않는 구성이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">Perl과 함께 배포되는 malloc 버전을 사용하는 것이 좋습니다. 할당 요청을보다 빨리 충족시키기 위해 다양한 크기의 할당되지 않은 메모리 풀을 유지합니다. 그러나 일부 플랫폼에서는 가짜 malloc 또는 무료 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">padname 배열에서 어휘 변수의 이름을 가져와야하는 경우 사용하는 적절한 방법입니다. 어휘 변수 이름은 항상 널 종료 자로 저장되며 길이 필드 (CUR)는 다른 목적으로 오버로드되므로 여기에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">따라서 이러한 매크로는 정적 데이터를 사용하는 모든 XS 모듈에서 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">일반적으로 나중에 있도록 펄의 검색 경로에 추가 디렉토리를 추가하는 데 사용됩니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 펄의 기본 검색 경로에 위치하지 않는 모듈을 찾을 수 문을.</target>
        </trans-unit>
        <trans-unit id="231d3b33b22966aa08593496a49a29478f187fe4" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fbfb42d30ce39230261b344f6acdd15e39f445" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;Pod::Escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">렌더링 할 수없는 문자 (파서가 렌더링 할 수 있거나없는 것으로 해석 할 수없는 알 수없는 E &amp;lt;thing&amp;gt; 시퀀스와는 다른)에 직면 할 때 올바른 판단을 표시하는 것은 개별 포드 포맷터에 달려 있습니다. 분음 부호가있는 라틴 문자 (예 : &quot;E &amp;lt;eacute&amp;gt;&quot;/ &quot;E &amp;lt;233&amp;gt;&quot;)를 해당하는 액센트가없는 US-ASCII 문자 (단순 문자 101, &quot;e&quot;)에 매핑하는 것이 좋습니다. 종종 실현 불가능하고, 렌더링 불가능한 문자는 &quot;?&quot;등으로 표현 될 수있다. 정상적인 폴백을 시도 할 때 (E &amp;lt;233&amp;gt;에서 &quot;e&quot;로) 포드 포맷터는 사용 가능한 경우 &lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode&lt;/a&gt; 의 % Latin1Code_to_fallback 테이블을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">이 정보를 사용하여 채우는 것은 귀하의 책임입니다</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">일반적으로 @_을 통하지 않고 전역 변수 (일반적으로 하나의 매개 변수의 경우 $ _, 두 개의 매개 변수의 경우 $ a 및 $ b)를 사용하여 매개 변수를 전달하는 것이 일반적입니다. (지원되는 API가 없지만 수행중인 작업을 알고 있으면 @_ 메커니즘을 사용할 수 있습니다. 또한 본질적으로 느립니다.)</target>
        </trans-unit>
        <trans-unit id="91da970cd331ff859f8e77df6915a3ed4846b274" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; may be internally implemented on your system with &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보통의 인터에 실수 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 때문에, 통화 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 내부적으로 시스템에 구현 될 수있다 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">보통의 인터에 실수 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 때문에, 통화 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 내부적으로 시스템에 구현 될 수있다 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">기존의 일부 프로그램을 중단하지 않고 Perl에 새로운 구문을 추가하는 것은 일반적으로 불가능합니다. 이 pragma는 해당 위험을 최소화하는 방법을 제공합니다. 새로운 문법 구조, 또는 그 이상 구조에 새로운 의미 론적 의미에 의해 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; ,와 해당 기능 프라그가 범위에있는 경우에만 구문 분석됩니다. 그럼에도 불구하고 &lt;code&gt;CORE::&lt;/code&gt; 접두사는이 pragma에 관계없이 모든 Perl 키워드에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f612a30494cb1971874c3ee4fc77442da7514cc" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;use feature 'foo'&lt;/code&gt;, and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8825373ed061df5a7897772f25e6f03f473b0a3c" translate="yes" xml:space="preserve">
          <source>It is very common to want to do encoding transformations when reading or writing files, network connections, pipes etc. If Perl is configured to use the new 'perlio' IO system then &lt;code&gt;Encode&lt;/code&gt; provides a &quot;layer&quot; (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;) which can transform data as it is read or written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">소스를 필터링 할 때 코드의 비 문자열 부분에만 필터를 적용하거나 다른 방법으로 필터를 적용하려는 경우가 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7507ed7a14e59c863596321d293c86dd2f1471ac" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;&quot;Avoiding Pipe Deadlocks&quot;&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">이 형식의 open ()을 사용하거나 실제로 여러 하위 프로세스와 함께 pipe ()를 사용하면 프로세스를 교착 상태로 만드는 것이 매우 쉽습니다. 위의 예는 간단하고 exec ()를 호출하기 때문에 &quot;안전&quot;합니다. 일반적인 안전 원리는 &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;파이프 교착 상태 방지를&lt;/a&gt; 참조하십시오 . 그러나 안전한 파이프 개방에는 추가 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">사례 보존을 처리 할 수있는 다양한 상태의 다른 프로그램, 외부 유틸리티 및 Perl 스크립트를 혼합하여 사용하는 것은 매우 쉽습니다. 예를 들어, 이전 버전의 아카이브 유틸리티 또는 MMK 또는 MMS와 같은 빌드 유틸리티로 작성된 파일은 ODS-5 볼륨에서도 모두 대문자로 파일 이름을 생성 할 수 있습니다. 이 파일 이름이 나중에 케이스 보존 환경에서 Perl 스크립트 또는 모듈에 의해 검색되는 경우, 해당 대문자 이름은 Perl 코드의 대소 문자 예상과 일치하지 않을 수 있습니다. 최선의 방법은 사례 보존을 위해 전혀 또는 전혀 접근하지 않는 것입니다. 전혀 사용하지 않거나 전체 툴체인 및 응용 프로그램 환경이 지원하고 사용하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">Perl 프로그램의 소스를 복구하는 것은 매우 쉽습니다. 프로그램을 펄 인터프리터에 공급하고 B :: 계층의 모듈을 사용하면됩니다. B :: Deparse 모듈은 소스를 숨기려는 대부분의 시도를 물리 칠 수 있어야합니다. 다시, 이것은 Perl에 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 문서가 일반 독자에게는 유용하지 않을 가능성이 매우 높습니다. 독자는 &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; 의 처음 몇 섹션의 내용을 이해해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8bf9b3e35a922a415eaeb6feb2defbf0bc762198" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055458523774899083238688c776d433516198d1" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (i.e. 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공된 값의 예상 범위에 특히주의를 기울일 가치가 있습니다. 월의 값은 실제 날짜 (예 : 1..31)이고 월은 1 월 (0..11) 이후의 월 수입니다. 이것은 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 에서 반환 된 값과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 등은 완전한 숫자 나 단어가 아닌 단일 문자와 일치 한다는 점을 강조 할 가치가 있습니다. 숫자로 구성된 숫자와 일치 시키려면 &lt;code&gt;\d+&lt;/code&gt; . 단어를 일치 시키려면 &lt;code&gt;\w+&lt;/code&gt; . 그러나 위에서 언급했듯이 보안 고려 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="113a0e58d547793b729e9fa965a701228f317998" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt;; to match a word, use &lt;code&gt;\w+&lt;/code&gt;. But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;code&gt;\G&lt;/code&gt; 잘못 무한 루프가 발생할 수 있습니다 사용. 교체에 &lt;code&gt;\G&lt;/code&gt; 가 포함 된 패턴을 사용할 때는주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">유니 코드에는 0-9와 같 으며 정규식에서 &lt;code&gt;\d&lt;/code&gt; 와 일치하는 여러 가지 다른 숫자 세트가 있음을 강조 할 가치가 있습니다 . 단일 언어로만 사용되는 경우 해당 언어의 &lt;code&gt;Script&lt;/code&gt; 및 &lt;code&gt;Script_Extension&lt;/code&gt; 에 있습니다. 둘 이상의 스크립트에서 사용되는 경우 &lt;code&gt;sc=Common&lt;/code&gt; 에 있지만 많은 스크립트에서 사용되는 경우에만 &lt;code&gt;scx=Common&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0195b5ac1ee6ed9e15cca2ca1c3622950d2b3cb" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt;. If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt;, but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">결국 추측 일뿐입니다. 인코딩과 관련하여 항상 명시 적이어야합니다. 그러나 추측 코딩이 필수 인 일부 일본어 환경이 있습니다. 이 모듈은주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">그러나 매우 간단하고 순수한 Perl이며 핵심이 아닌 종속성이 없습니다. 또한 지원되는 기능에 대한 요청시 &quot;무스&quot;API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">백 슬래시 연산자를 사용하여 IO 핸들 (filehandle 또는 dirhandle)에 대한 실제 참조를 작성할 수 없습니다. 가장 많이 얻을 수있는 것은 실제로 완전한 기호 테이블 항목 인 typeglob에 대한 참조입니다. 그러나 아래 &lt;code&gt;*foo{THING}&lt;/code&gt; 구문에 대한 설명을 참조하십시오 . 그러나 유형 glob 및 globrefs는 마치 IO 핸들 인 것처럼 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">그것은에 의해 수 있습니다 &lt;code&gt;$(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">다음을 포함하는 C : \ Program Files \ Microsoft Visual C ++ Toolkit 2003 \ bin에 lib.bat라는 배치 파일을 만드는 것이 유용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">또한 철자가 틀린 것으로 해석 된 철자가 틀린 상수를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb79d7ce93f65d8007a6c3362149cd125568d552" translate="yes" xml:space="preserve">
          <source>It may be common (for example at your main lexicon) that the hash keys and values coincide. Like that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">숫자를 검색하는 함수 나 메소드를 추가하는 것이 편리 할 수 ​​있습니다. 모듈 (ModuleName-1.02.tar.Z)을 릴리스 할 때 공지 사항 및 아카이브 파일 이름의 번호를 사용하십시오. 자세한 내용은 perldoc ExtUtils :: MakeMaker.pm을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">스크립트 I / O가 디버거 I / O와 분리되도록 항상 분기 된 디버거를 사용하는 것이 도움이 될 수 있습니다. 프로세스 식별 번호가 아닌 논리 이름 &amp;lt;PERLDB_PIDS&amp;gt;에 값을 지정하여 디버거를 강제로 포크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c878552ffbfe93e8fcd546e6ba5f54b617695a5d" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;rename()&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을 대신 사용하는 것이 더 이식 가능할 수 있습니다 . 새 파일에 새 이름으로 복사하고 (반환 값 확인) 이전 파일을 삭제하면됩니다. 권한, 타임 스탬프, inode 정보 등과 같은 메타 정보를 보존 하는 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 과 실제로 의미 적으로 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">간단한 해결 방법을 코딩하는 것이 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt; 에서 제공되는 Entropy Gathering Daemon (Perl!로 작성)을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">분명히 말할 수 있지만 Perl은 사용자가 쉽게 찾을 수있는 경우에만 유용합니다. 가능하면 두 가지 모두에 좋습니다</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">아마도 chdir () 할 수없는 디렉토리에서 chdir () 할 수 있습니다. fastcwd에 문제가 발생하면 undef를 반환하지만 다른 디렉토리에 남겨 둘 것입니다. 모든 것이 나타납니다이 근무하는 경우 추가 보안의 측정, 들어, fastcwd () 함수는 그것에서 시작하는 것과 같은 디렉토리에 당신을 떠난다 확인합니다.이 변경된 경우는 것입니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 메시지 &quot;불안정 디렉토리 경로, 전류 디렉토리가 예기치 않게 변경되었습니다. &quot; 그런 일은 절대 일어나지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6269f7c0874b90d11b774dcb29c6ab77d94be05c" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;die&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a597e04d91d3290c6b9fa9abe20a400d22f03ff" translate="yes" xml:space="preserve">
          <source>It might seem possible eliminate slab reference counts altogether, by having all ops implicitly attached to &lt;code&gt;PL_compcv&lt;/code&gt; when allocated and freed when the CV is freed. That would also allow &lt;code&gt;op_free&lt;/code&gt; to skip &lt;code&gt;FreeOp&lt;/code&gt; altogether, and thus free ops faster. But that doesn't work in those cases where ops need to survive beyond their CVs, such as re-evals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642edf6b6e0c22a6bf4368f6631f6fe45a077e55" translate="yes" xml:space="preserve">
          <source>It monkeypatches Test::Builder, and calls it &quot;black magic&quot; in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">DynaLoader 자체는 Perl-to-C '접착제'를 거의 제공하지 않기 때문에 비 Perl 라이브러리에 액세스하는 데 실제로는 쓸모가 없다는 점을 강조해야합니다. 예를 들어, C 라이브러리 함수를 호출하거나 인수를 제공하는 메커니즘이 없습니다. AC :: DynaLib 모듈은 일부 일반적인 시스템 유형에 대해 해당 기능을 수행하는 CPAN 사이트에서 사용할 수 있습니다. 또한 2000 년 이후로 C에서 Perl 서브 루틴을 작성할 수있는 모듈 인 Inline :: C도 있습니다. 또한 현지 CPAN 사이트에서도 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8bc1cb6024aa942bd48b262d31d7cf7f97b8a25f" translate="yes" xml:space="preserve">
          <source>It occurs to you that this is not the prettiest code you've ever written, but this seems the way to go. You mail off to the translators asking for translations for these four cases. The Chinese guy replies with the one phrase that these all translate to in Chinese, and that phrase has two &quot;%g&quot;s in it, as it should -- but there's a problem. He translates it word-for-word back: &quot;In %g directories contains %g files match your query.&quot; The %g slots are in an order reverse to what they are in English. You wonder how you'll get gettext to handle that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">특히, 할당 된 모든 루틴에서 $ _ 를 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 것이 중요 합니다. 에서 암시 적 과제를 찾아보십시오 &lt;code&gt;while&lt;/code&gt; 조건문.</target>
        </trans-unit>
        <trans-unit id="e9fad7940bb559b8eb57657aa029f3c734e1bf6b" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;local&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">인쇄합니다 (줄 바꿈이 많지 않음)</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">print가 목록 컨텍스트에서 &lt;code&gt;bdiv()&lt;/code&gt; 를 호출하기 때문에 몫과 나머지를 모두 인쇄합니다 . 또한 &lt;code&gt;bdiv()&lt;/code&gt; 는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">인쇄가 목록 컨텍스트에서 작동하므로 몫과 나머지를 모두 인쇄합니다. 또한 bdiv ()는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">print가 목록 컨텍스트에서 &lt;code&gt;brsft()&lt;/code&gt; 를 호출하기 때문에 몫과 나머지를 모두 인쇄합니다 . 또한 &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; 는 $ c를 수정하므로주의하십시오. 아마도 사용하고 싶을 것입니다</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">print가리 스트 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 를 호출하기 때문에 숫자와 분수 부분의 자릿수를 모두 인쇄합니다 . 다음과 같은 것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="ae3e52e7991a13cb3327228cb99597bd25c0f239" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;length()&lt;/code&gt; in list context. Use something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">각 서브 루틴 호출의 순서 번호와 호출 된 서브 루틴의 이름을 인쇄합니다. 참고 것을 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 패키지로 컴파일되는 &lt;code&gt;DB&lt;/code&gt; 의 사용을 통해 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 지시어.</target>
        </trans-unit>
        <trans-unit id="9851cbd8d563f766b9710d226d03fcd351760c96" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;package&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc0745e2373dd8461369aabf029a5713236cbd6" translate="yes" xml:space="preserve">
          <source>It properly handles the locale radix character, meaning it expects a dot except when called from within the scope of &lt;code&gt;use locale&lt;/code&gt;, in which case the radix character should be that specified by the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">이 정보를 쿼리하기위한 여러 가지 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">메소드에 대한 기본 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">거의 발생하지 않지만 때로는 하네스에서 '결측 테스트가 누락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">파생 속성 Comp_Ex (Full_Composition_Exclusion)의 부울을 반환합니다. 이 특성은 컴포지션 제외 + 싱글 톤 + 비스타 터 분해에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">파생 속성 NFC_MAYBE의 부울 (NFC_Quick_Check = Maybe)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFC_NO (NFC_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFD_NO (NFD_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">파생 속성 NFKC_MAYBE (NFKC_Quick_Check = Maybe)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFKC_NO (NFKC_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">파생 속성 NFKD_NO (NFKD_Quick_Check = No)의 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">지정된 코드 포인트의 문자가 특정 컴포지션 (한글 컴포지션 포함, 컴포지션 제외 및 비스타 터 분해 제외)에서 이전 코드로 구성 될 수 있는지 여부를 부울 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">코드 포인트에 비스타 터 분해가 있는지 여부를 부울 값으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">코드 포인트가 컴포지션 제외인지 여부를 부울 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">코드 포인트가 싱글 톤인지 여부를 부울 값으로 반환</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공 하면 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 객체를 반환하고 실패하면 undef를 반환합니다 . &lt;code&gt;$Bzip2Error&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$DeflateError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공 하면 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 객체를 반환하고 실패하면 undef를 반환합니다 . &lt;code&gt;$GzipError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$RawDeflateError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">성공시 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 객체를 반환하고 실패시 undef를 반환합니다 . &lt;code&gt;$ZipError&lt;/code&gt; 변수 는 실패시 오류 메시지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH 및 선택적으로 실제 라이브러리의 파일 이름 배열에 대한 참조 인 4 개 또는 5 개의 스칼라 값 배열을 리턴합니다. 이 중 일부는 유닉스를 제외하고는 아무 의미가 없습니다. 아래의 플랫폼 별 세부 사항을 참조하십시오. 파일 이름 목록은 $ need_names 인수가 true 인 경우에만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">&lt;code&gt;PACKAGE&lt;/code&gt; 가 아직로드되지 않았고 성공적으로로드되었다고하는 위치 가 있으면 Fall 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">FCC 형식을 반환합니다 ( &quot;Fast C Contiguous&quot;; cf. UTN # 5).</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">정규화 형식 C (정식 분해와 정식 구성으로 구성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">정규화 형식 D (정식 분해에 의해 형성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">정규화 형식 KC (호환성 분해와 &lt;b&gt;정식&lt;/b&gt; 구성으로 구성)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">정규화 형식 KD (호환성 분해에 의해 형성됨)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">문자의 결합 클래스 (정수)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">문자열에서 각 문자의 분해 연결을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">정규화 양식 &lt;code&gt;$form_name&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bf3cd095961560034a7b6b2b8569541880d86696" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">나머지 &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; 입니다. &lt;code&gt;$r&lt;/code&gt; 동일 투표 &lt;code&gt;$x&lt;/code&gt; 이하의 크기보다와 절대치를 &lt;code&gt;$y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b96df5a323ccde59c4604283479ada0f880ece8b" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt;, where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt;. The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">분해를 적용하지 않고 정식 구성 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">정식 정렬 동작에 따라 결합 문자를 재정렬 한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0c7818f52644428114d7169367d50f2b1f7b0307" translate="yes" xml:space="preserve">
          <source>It returns the same values as run_tests, so you can further examine the test results if you need to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; 이면 true ( &lt;code&gt;1&lt;/code&gt; )를 리턴합니다 . &lt;code&gt;NO&lt;/code&gt; 이면 false ( &lt;code&gt;empty string&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; 이면 true ( &lt;code&gt;1&lt;/code&gt; )를 리턴합니다 . &lt;code&gt;NO&lt;/code&gt; 인 경우 거짓 ( &lt;code&gt;empty string&lt;/code&gt; ) ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;MAYBE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e07cc039b9bc283952fe2e0a04d4a341d590f3e7" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00917cf3a6843e18b27b643db79b6a4b69a6e3c" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;; &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">모든 것이 정상이면 true를 반환합니다. 그렇지 않으면 DIAGNOSTICS 섹션의 메시지 중 하나와 함께 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 가됩니다.</target>
        </trans-unit>
        <trans-unit id="7671ee7cfbfe57f504b6685d32d40a2c22391d50" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;die()&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">키가 기준과 일치하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">첫 번째 문자열 인 &lt;code&gt;$processed&lt;/code&gt; 는 마지막 시작 전 부분이고 두 번째 문자열 인 &lt;code&gt;$unprocessed&lt;/code&gt; 는 첫 번째 부분 다음의 또 다른 부분입니다. 스타터는 결합 클래스가 0 인 문자입니다 (UAX # 15 참조).</target>
        </trans-unit>
        <trans-unit id="bcda37fdc9f0662d168c30c5cdca4733a8dcb549" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt;, is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">구현 클래스 &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; 중 하나의 미러 인 클래스 &lt;code&gt;Name&lt;/code&gt; 을 설정합니다 . 실행되는 구현을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9e5fad0504d022f42c88d249188952052fecb50c" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt;, &lt;code&gt;Name_id&lt;/code&gt;, ..., &lt;code&gt;Name_fieldhash&lt;/code&gt;. That determines which implementation is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">&lt;code&gt;PerlIO *&lt;/code&gt; 의 이중 간접적 때문에 , &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;는&quot; &lt;code&gt;PerlIO *&lt;/code&gt; 이므로 어느 정도는 최소한 하나의 레이어가 다음 레이어에서 &quot;표준&quot;API를 사용할 수 있습니다. 하위.</target>
        </trans-unit>
        <trans-unit id="c7a2a8bb586f925da0807a643800b85b4622cd20" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt;, a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt;, and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">유의해야합니다</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">Makefile 생성 작업을 개별적으로 재정의 할 수있는 여러 서브 루틴으로 분할합니다. 각 서브 루틴은 Makefile에 쓰려고하는 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">패키지 선언과 $ VERSION 변수가있는 perl 모듈처럼 시작합니다. 그 후 포드 섹션은 다른 포드와 비슷하지만 유일한 차이점은</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">&lt;a href=&quot;../text&quot;&gt;Pod :: Text에&lt;/a&gt; 설명되어있는 다음 옵션을 지원합니다 . alt, indent, loose, quotes, 문장, 너비</target>
        </trans-unit>
        <trans-unit id="510b7b9b3f742ecce372251df0c084238337e534" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">&lt;code&gt;in CPAN file&lt;/code&gt; 의 열 에서 중복을 억제하여 업그레이드 가능한 모듈이 많은 분배가 한 번만 나열되도록합니다.</target>
        </trans-unit>
        <trans-unit id="408685ef311dbc3599ddc558bce5925c12aacf23" translate="yes" xml:space="preserve">
          <source>It takes a Win32 native file handle and returns the size in bytes. Since the size can be a 64 bit value, on non 64 bit integer Perls the value returned will be an object of type &lt;code&gt;Math::BigInt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">두 개의 선택적 키가있는 인수로 해시 참조가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b5a427be1727dabad24c941b3ce2ddc132315b17" translate="yes" xml:space="preserve">
          <source>It takes an optional hashref of options. Valid options include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0a17fd215b480661caff5f818c6d1a010f9c4c" translate="yes" xml:space="preserve">
          <source>It takes the same options as &lt;code&gt;new()&lt;/code&gt; but &lt;code&gt;lazy_validation&lt;/code&gt; defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">세 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">이전 구성 파일을 찾은 위치 (있는 경우)를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">실제로이 작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="674b7a92bd3974a32a6e0bc4ddce519662bb5c8a" translate="yes" xml:space="preserve">
          <source>It used to be legal to use &lt;code&gt;open()&lt;/code&gt; to associate both a filehandle and a dirhandle to the same symbol (glob or scalar). This idiom is likely to be confusing, and it was deprecated in Perl 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73ad695b4941117c2fa5c1a0fa146666ac448c3" translate="yes" xml:space="preserve">
          <source>It used to be possible to use &lt;code&gt;tie&lt;/code&gt;, &lt;code&gt;tied&lt;/code&gt; or &lt;code&gt;untie&lt;/code&gt; on a scalar while the scalar holds a typeglob. This caused its filehandle to be tied. It left no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dce3c39f57e7aba5158e57e9f8e31a1b80c94a8" translate="yes" xml:space="preserve">
          <source>It used to hold the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59c80ea628e681a66374b04e2b703dd5af8c0f4" translate="yes" xml:space="preserve">
          <source>It uses the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function to convert hostnames and service names or port numbers into sets of possible addresses to connect to or listen on. This allows it to work for IPv6 where the system supports it, while still falling back to IPv4-only on systems which don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">이 값을 사용하여 $ atime, $ mtime, $ ctime의 세 값을 사용하여 로컬 zip 헤더에서 확장 된 타임 스탬프 필드 (ID는 &quot;UT&quot;)를 설정합니다. 또한 &lt;code&gt;$mtime&lt;/code&gt; 사용하여 중앙 zip 헤더의 확장 타임 스탬프 필드를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="79a1b16fce6a4d25801f9ce9e038622522aac3da" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f46edc5cb632e7fccbb0705e4feec5f3263394" translate="yes" xml:space="preserve">
          <source>It was allowed to use a list of variables in a format, without separating them with commas. This usage has been deprecated for a long time, and as of Perl 5.28, this throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">Unix cat (1) 명령을 호출하면 작성하기 쉬웠지만 파일을 수동으로 (보다 다소 효율적으로) 여는 것이 더 이식성이 좋을 것입니다. 물론, 도트 파일은 Unixy 개념이므로 그다지 걱정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;에 의해 버전 1.95의 CPAN에서 이중 수명으로 추출되었습니다.</target>
        </trans-unit>
        <trans-unit id="166bbe1785a329a167c16e63945354e47d32b2c0" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;&quot;Disambiguation rules between old-style octal escapes and backreferences&quot;&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">모든 Perls에서 사용 가능한 다른 형식의 잠재적 문제를 피하기 위해 도입되었습니다. 이 형식은 백 슬래시와 3 개의 8 진수로 구성됩니다. 이 형식의 한 가지 문제점은 이전 스타일의 역 참조와 똑같이 보일 수 있다는 것입니다 (아래의 &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;이전 스타일 8 진 이스케이프와 역 참조 간의 명확성 규칙 참조&lt;/a&gt; ). 세 자리 중 첫 번째 숫자를 항상 0으로 설정하면이를 피할 수 있습니다. \ 077을 가장 큰 코드 포인트로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; 설치된 기본 유형 맵을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0759e45d98bb4647a58253ee97ba7b77b47a644c" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39ceb1fd2f53bed50ffdadfd8219def2a0114b8" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed and IGNORE_WIN32_LOCALE is not set to a true value in the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">설치된 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt; 모듈 도 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">항상 Perl에 의해 자동으로 전달되는 하나 이상의 매개 변수가 있습니다. 이것은 패키지 이름에 해당합니다. 위의 예에서는 &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ac1faf8f9d59ddb0b6351807f16102144c68a8" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">&lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; 의 전역 설정이 기본값이며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f9ce735c72f68600f9b73a9ad2fbc8f2efff3f41" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt;, which by default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">그것은 환경에서 볼 것입니다</target>
        </trans-unit>
        <trans-unit id="271dd95369c9033872c86c2ed2d28ba5b5a90105" translate="yes" xml:space="preserve">
          <source>It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">예를 들어 $ x의 사본을 만드는 등의 생각은하지 않습니다. 대신 &lt;b&gt;동일한&lt;/b&gt; 객체에 대한 두 번째 참조를 만들고 $ y에 저장합니다. 따라서 $ x를 수정하는 것은 오버로드 된 연산자를 제외하고 $ y를 수정하고 그 반대도 마찬가지입니다. 즉, &lt;code&gt;=&lt;/code&gt; 는 오버로드 된 수학을 통해서만 BigInts를 수정하는 경우에만 안전합니다. 메소드 호출을 사용하자마자 깨집니다.</target>
        </trans-unit>
        <trans-unit id="3da306523999d7f8b6c9832cd1c2497b109726eb" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">예를 들어 $ x의 사본을 만드는 등의 생각은하지 않습니다. 대신 &lt;b&gt;동일한&lt;/b&gt; 객체에 대한 두 번째 참조를 만들고 $ y에 저장합니다. 따라서 $ x를 수정하는 것은 $ y를 수정하고 (과도한 수학 연산자는 제외) 그 반대도 마찬가지입니다. 자세한 내용과이를 피하는 방법 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">'A'를 인쇄 한 다음 일치하는 너비를 0으로 간주하여 종료되므로 동일한 위치에서 두 번 연속 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">모듈이 설치된 위치를 찾을 수 없으면 undef를 반환하거나 파일을 찾을 수 있으면 다음 키를 사용하는 해시 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">그러나 문자열 참조의 일부인 검색된 객체의 주소가 원래 주소와 다를 수 있기 때문에 일련의 &lt;code&gt;store&lt;/code&gt; 및 &lt;code&gt;retrieve&lt;/code&gt; 작업에서는 작동하지 않습니다 . 구조의 토폴로지는 유지되지만 숨겨진 의미론은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">참조에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">Perl 5.18부터이 방식으로 작동합니다. 역사적으로 일관성이 없었으므로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">이런 식으로 쓰는 것이 훨씬 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">기본 응용 프로그램 코드에서 NULL 종료 문제를 무시하고 데이터베이스에 쓸 때마다 모든 키와 값에 종료 NULL을 자동으로 추가하고 데이터베이스에서 읽을 때 제거하는 메커니즘을 갖는 것이 훨씬 좋습니다. 이미 짐작했듯이 DBM 필터가 매우 쉽게 해결할 수있는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">&lt;code&gt;upcase_in()&lt;/code&gt; 함수를 사용하여 매개 변수를 변경하는 대신 매개 변수의 사본을 리턴하도록 작성하는 것이 훨씬 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">상수 주위에 쉼표를 완전히 남기고 다음과 같이 말하면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">한 번에이 작업을 수행 할 수 있다면 좋을 것입니다. 짧은 압축을 풀고 약간 백업 한 다음 2 바이트를 압축 해제하십시오. 펄 이후</target>
        </trans-unit>
        <trans-unit id="aaa6174f1be6c791e8b304262469e518ba0d9df6" translate="yes" xml:space="preserve">
          <source>It would be nice to just write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">=? ISO-2022-JP?와 같은 비 UTF8 로의 인코딩을 지원하는 것이 좋을 것입니다. 그리고 =? ISO-8859-1? = 그러나 그것은 구현을 너무 복잡하게 만듭니다. 요즘 주요 메일 에이전트는 모두 =? UTF-8? 충분하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">생성 된 파일을 필요한 위치에 넣습니다. 수동으로 넣어</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">시스템 네트워킹 상수 값을 정의하는 Perl 4 스타일 파일입니다. 때로는 Perl을 설치할 때 &lt;a href=&quot;h2ph&quot;&gt;h2ph를&lt;/a&gt; 사용하여 빌드 되지만 그렇지 않은 경우도 있습니다. 최신 프로그램은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; 사용해야 &lt;a href=&quot;functions/use&quot;&gt;합니다&lt;/a&gt; . 대신에.</target>
        </trans-unit>
        <trans-unit id="2788c8ed5f3ec3bf8bed1e36ab8dd36690fbf752" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;use Socket;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">기존 Perl 프로그램을 중단하는 것은 기본적인 죄입니다. 새로운 경고는 논쟁의 여지가 있습니다. 어떤 사람들은 경고를내는 프로그램이 깨지지 않았고 다른 사람들은 그렇게 말합니다. 키워드를 추가하면 프로그램이 중단 될 가능성이 있으며 기존 토큰 시퀀스 또는 함수의 의미를 변경하면 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">포함을 올바르게 가져와야하기 때문에 c2ph에는 약간의 속임수가 있습니다. 나는 당신의 시스템에 대해 이것을 알 수 없지만 일반적으로 너무 어렵지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">오염 된 값을 사용하는지 여부를 신경 쓰지 않는 다른 작업에 어려움을 겪을 수도 있습니다. 사용자 제공 파일 이름을 처리 할 때 파일 테스트를 신중하게 사용하십시오. 가능하면 특수 사용자 (또는 그룹!) 권한 &lt;b&gt;을&lt;/b&gt; 올바르게 삭제 &lt;b&gt;한 후&lt;/b&gt; 열어야합니다. Perl은 오염 된 파일 이름을 열지 못하도록 막지 않으므로 인쇄 할 때는주의하십시오. 오염 메커니즘은 어리석은 실수를 방지하고 사고의 필요성을 제거하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">또한 함수를 실행하거나 목록 컨텍스트에서 연산을 수행 한 다음 빈 목록에 할당 한 다음 스칼라 컨텍스트에서 해당 할당을 사용하여 반환 값 수를 계산하는 데 유용한 관용구의 소스이기도합니다. 예를 들어이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">또한 너무 느립니다 (캐싱에도 불구하고).</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">또한 숫자를 비교하고 &lt;code&gt;is()&lt;/code&gt; 의 &lt;code&gt;eq&lt;/code&gt; 사용 이 방해 하는 경우에도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f80232728d1a0e850ad2f6c5b3fdccf6e503f004" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt;'s use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">또한 복합 유형의 멤버 (예 : 배열 또는 해시 요소) 를 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화할 때 발생하는 상황을 설명하는 데 시간이 걸립니다 . 이 경우 요소는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화됩니다</target>
        </trans-unit>
        <trans-unit id="c2abe8691d5cb64abc6ccb815e6052901189c534" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;local&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;local&lt;/code&gt;ized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">모 놀리 식 몇 가지보다 많은 간단한 루틴을 갖는 것이 좋습니다. 루틴이 인수를 기반으로 동작을 크게 변경하는 경우 두 개 이상의 별도 루틴이 있어야한다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">편리한 명령 줄 유틸리티로 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">짧은 예제에서 문제를 쉽게 알 수 있지만 더 복잡한 코드에서는 특수 변수의 변경 사항을 현지화하지 않으면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">그것은 다시 한번 계란을 먹는 것입니다. 어떤 사람들은 이것을 비트 문자열로 &quot;10001100&quot;으로 기록해야한다고 생각합니다. 즉, 가장 중요한 비트로 시작하고 다른 사람들은 &quot;00110001&quot;을 고집합니다. 글쎄, Perl은 편향되어 있지 않기 때문에 두 개의 비트 문자열 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">값 사이의 관계를 비교할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">숫자 측정 값이 숫자 평균으로 설정되도록 타이밍 측정을 충분한 횟수로 실행해야합니다. 그렇지 않으면 환경의 변화로 인해 각 실행이 자연스럽게 변동되어 &lt;code&gt;CPU&lt;/code&gt; 리소스 및 네트워크 대역폭에 대한 경합의 영향을 줄 입니다. 백만 번 반복하여 위의 코드를 실행하면 &lt;code&gt;Benchmark&lt;/code&gt; 모듈 의 보고서 출력 을보고 어떤 접근 방식이 가장 효과적인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">comp.lang.perl.announce 유즈넷 뉴스 그룹에 모듈 (또는 작은 경우 모듈 자체)의 가용성에 대한 알림을 게시하는 것이 좋습니다. 이것은 최소한 매우 광범위한 일회용 배포를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">특정 인코딩 인 내부 형식에 의존해서는 안되므로 트랙을 잃어 버리는 것이 좋습니다. 그러나 요청한 이후 : 기본적으로 내부 형식은 문자열 기록에 따라 ISO-8859-1 (라틴 -1) 또는 utf8입니다. EBCDIC 플랫폼에서는이 기능이 다를 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">$ how_many가 SKIP 블록의 테스트 수를 정확하게 반영하는 것이 중요하므로 실행 된 테스트 수가 계획과 일치해야합니다. 계획이 &lt;code&gt;no_plan&lt;/code&gt; 인 경우 $ how_many는 선택 사항이며 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">사용자 지정 연산자가 무엇을하지 않는지 아는 것이 중요합니다. Perl에 새로운 구문을 직접 추가 할 수는 없습니다. 새 키워드를 직접 추가 할 수도 없습니다. 사실, 그들은 Perl이 프로그램을 컴파일하는 방식을 전혀 바꾸지 않을 것입니다. Perl이 프로그램을 컴파일 한 후에는 이러한 변경을 직접 수행해야합니다. &lt;code&gt;CHECK&lt;/code&gt; 블록과 &lt;code&gt;B::Generate&lt;/code&gt; 모듈을 사용하여 op 트리를 조작 하거나 &lt;code&gt;optimize&lt;/code&gt; 모듈 과 함께 맞춤 구멍 최적화기를 추가 하여이 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">잠금은 문제의 변수에 대한 액세스를 방해하지 않으며 잠금 시도 만한다는 점에 유의해야합니다. 이것은 Perl의 오랜 전통적 프로그래밍의 전통과 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 제공 하는 권고 파일 잠금을 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7c0c2bd9c27ab14c34335de35804fff201f2533" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;flock()&lt;/code&gt; gives you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b860229e93d14d8905681b2058fe74c37532fe8" translate="yes" xml:space="preserve">
          <source>It's important to note that specifying this parameter as non-null will cause any warnings this function would otherwise generate to be suppressed, and instead be placed in &lt;code&gt;*msgs&lt;/code&gt;. The caller can check the lexical warnings state (or not) when choosing what to do with the returned messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2459276db9d22fb9b53f0419f11fb94dbdc78be" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;&quot;PADDING OF BASE64 DIGESTS&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">결과 문자열에는 Base64 인코딩의 일반적인 패딩 문자가 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 이 생략은 의도적이며 CPAN 다이제스트 모듈 제품군과의 호환성을 유지하기 위해 수행됩니다. 자세한 내용은 &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;BASE64 수치의 패딩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b1efa7406cffc0cec49027fa169f45a3bd427b6" translate="yes" xml:space="preserve">
          <source>It's important to point out that if you want your subclass to be automatically used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; you'll have to and make sure it gets loaded somehow. If you're using &lt;a href=&quot;prove&quot;&gt;prove&lt;/a&gt; you can write an &lt;a href=&quot;App::Prove&quot;&gt;App::Prove&lt;/a&gt; plugin. If you're using &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; or &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly (e.g. through a custom script, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;, or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt;) you can use the &lt;code&gt;config&lt;/code&gt; option which will cause &lt;a href=&quot;TAP::Parser::IteratorFactory#load_sources&quot;&gt;&quot;load_sources&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; to load your subclass).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">텍스트 문자열에 바이트가 없다는 것을 인식하는 것이 중요합니다. 물론 Perl은 문자열을 메모리에 저장하기위한 내부 인코딩을 가지고 있지만 무시합니다. 바이트 수로 무언가를 해야하는 경우 문자열을 인코딩 한 직후에 해당 부분을 3 단계로 이동하는 것이 가장 좋습니다. 그런 다음 대상 문자열에 얼마나 많은 바이트가 있는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">몇 가지를 먼저 설정하는 것이 중요합니다. 이것은이 튜토리얼에서 가장 중요한 부분입니다. 이보기는 웹에서 찾은 다른 정보와 충돌 할 수 있지만 대부분의 출처가 잘못 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">우리가 구체적으로 있다는 것을 이해하는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">반드시 &lt;code&gt;[ ]&lt;/code&gt; 배열 참조 생성자 를 사용해야합니다 . 이것이 작동하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9fbefe7e70d26e99bc2294921c0de37542709163" translate="yes" xml:space="preserve">
          <source>It's just a first step, but it's usually a good first step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">나중에 새 데이터 유형을 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">공백과 공백이 아닌 경계가 아니며 문장을 만드는 데 사용하는 단어 사이의 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">이와 같이 중간에 구문을 분할하는 것은 좋지 않으며 여기서는 작동하지 않습니다. 대신 위의 솔루션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">보이는 것처럼 쉬운 문제는 아닙니다. 거기에 얼마나 많은 단어가 있다고 생각하십니까? 기다려 봐 ... 기다려 봐 .... 5라고 대답하면 맞아. 펄 단어는 &lt;code&gt;\w+&lt;/code&gt; 그룹 이지만 대문자로 표시하려는 것은 아닙니다. 어떻게 펄은 투자하지 알고 가정된다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 아포스트로피 후? 정규식을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a8bd2e0723c73ceda4c03acccc160b0debe5557" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt;, but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;s&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">&quot;더 빨리 실행되게 할 것&quot;이라고 말하면 충분하지 않으므로 확인해야합니다. 위의 첫 번째 단계에서 벤치마킹 또는 프로파일 링 모듈을 제어하여 코드를 다시 실행하고 새 코드가 &lt;b&gt;동일한 작업&lt;/b&gt; 을 실행했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">Perl에 대한 모든 성능 관련 코드를 개별적으로 보여줄 수는 없지만 CPAN의 간단한 모듈 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">이 모듈을 사용하여 Perl 형식을 사용하여 형식 및 색상 속성을 포함 할 수 없습니다. 이스케이프 문자를 공백으로 바꿉니다 (</target>
        </trans-unit>
        <trans-unit id="535d143f61fad023b3aec2dac42bd177c0d8265b" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in &lt;a href=&quot;http://man.he.net/man1/perlform&quot;&gt;perlform(1)&lt;/a&gt;), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">그것은 실제로 웃음의 배럴이 아닙니다. 실제로, 그것은 보이는 것보다 더 나쁩니다. 독수리 눈은 첫 번째 필드의 너비가 10 자 여야하며 오류는 다른 숫자를 통해 바로 전파되었음을 알 수 있습니다.이 숫자는 우리가 직접 계산해야했습니다. 따라서 오류가 발생하기 쉽고 비우호적입니다.</target>
        </trans-unit>
        <trans-unit id="e0ac4f099ce1bc3e2ec1419213f4e20eba107331" translate="yes" xml:space="preserve">
          <source>It's not scary. Come, hold my hand. We're going to give an example of testing a module. For our example, we'll be testing a date library, &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt;. It's on CPAN, so download a copy and follow along. [2]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">STDOUT 및 STDERR이 Test :: Builder의 기본 출력 설정에 영향을 미치지 않는 위치를 테스트에서 변경해도됩니다.</target>
        </trans-unit>
        <trans-unit id="fa762fbbddcd8f0e9e5679cef69f64552f7bd006" translate="yes" xml:space="preserve">
          <source>It's ok. That's all gone now. We've done all the black magic for you. And here are the tricks...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">거친 도구로만 사용됩니다. 생성 된 파일을 잘 살펴 봐야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">CPAN.pm 및 CPANPLUS.pm 모두에 대한 도우미 모듈로만 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">SKIP 블록을 중첩하는 것이 안전합니다. 각 SKIP 블록은 라벨이 있어야합니다 &lt;code&gt;SKIP&lt;/code&gt; 을 , 또는 테스트 :: 자세히 마법을 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="391da5d64075501c64aecf0b13f021943f8e3a31" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt;, or Test::More can't work its magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">아래 나열된 모든 모듈이 시스템에 설치되어 있지 않을 수 있습니다. 예를 들어, gdbm 라이브러리가 없으면 GDBM_File 모듈이 설치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">개요에 표시된대로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 아래 의 &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro :: set_mro&lt;/a&gt; 함수 를 사용 하여 지정된 클래스의 MRO를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef95c6240b3ebd6ee3881a4772ff7b1a355b2ea" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;use mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3A%3Aset_mro&quot;&gt;&quot;mro::set_mro&quot;&lt;/a&gt; function below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">공개적으로 설정 가능한 속성을 노출시키지 않는 클래스를 가질 수 있습니다. 모든 클래스에 속성과 메소드가있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">를 사용하여 여러 기능을 함께로드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">컴파일 타임 &lt;code&gt;DEBUG&lt;/code&gt; 상수를 사용하여 이전 아이디어를 조금 더 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">객체의 간단한 덧셈과 뺄셈을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7c04330ddf6941f6fc338e6607920a6ccb70bb26" translate="yes" xml:space="preserve">
          <source>It's preferable to patch against the latest blead version, since this is where new development occurs for all changes other than critical bug fixes. Critical bug fix patches should be made against the relevant maint branches, or should be submitted with a note indicating all the branches where the fix should be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">기존 runops 함수 중 하나를 복사하여 필요에 맞게 변경하는 것이 가장 좋습니다. 그런 다음 XS 파일의 BOOT 섹션에서 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">프로토 타입을 구형으로 개조하지 않고 새로운 기능을 프로토 타입하는 것이 가장 좋습니다. 리스트와 스칼라 컨텍스트가 다른 자동 임 포징에 특히주의해야하기 때문입니다. 예를 들어, 함수가 다음과 같이 하나의 매개 변수 만 가져야한다고 결정한 경우 :</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">다음 오류를 강제하기 위해 항상 상수 이름 뒤에 쉼표를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">readdir에서 리턴 값을 파일 테스트 할 경우 문제의 디렉토리를 앞에 추가하는 것이 좋습니다. 그렇지 않으면 거기에 chdir ()이 없기 때문에 잘못된 파일을 테스트했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">대상 시스템에 쉽게 사용할 수있는 / tmp가 없을 수 있으므로 다음과 같이하는 것이 일반적으로 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">BEGIN 블록 내에서 &lt;code&gt;use_ok()&lt;/code&gt; 를 실행 하여 해당 함수가 컴파일 타임에 내보내지고 프로토 타입이 올바르게 표시되도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">그러나 Perl은 단순히 익명 변수를 할당하기 때문에 문자열 리터럴을 P- 또는 p- 패킹하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">여전히 산문만큼 명확하지는 않지만 패턴의 각 부분의 의미를 설명하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">실제 변경 사항을 찾는 것은 여전히 ​​귀하의 몫이며 실제로는 없을 수도 있습니다. 마지막으로 확인한 이후의 모든 변경 사항이 서로를 취소하고 패키지를 이전 상태로 유지했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 이 아닌 큰 따옴표 입니다. 큰 따옴표 컨텍스트에서 배열을 보간 할 때마다 Perl은 공백으로 요소를 조인합니다 (또는 &lt;code&gt;$&quot;&lt;/code&gt; 에있는 것은 기본적으로 공백입니다).</target>
        </trans-unit>
        <trans-unit id="7e186193135a9027584138d266cd6dc740e3d523" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;print&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt;, which is a space by default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">변수 이름을 인쇄하려는 경우에 유용합니다. 컴파일 타임에 존재하는 glob로 자신을 제한하면 &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; 과 같은 코드 가 상수 문자열과 역 참조 (rv2gv)와 같이 두 개의 op로 컴파일되므로 결과는 분명해야합니다. 글로브는 런타임에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb10a58faaab36e9d6bfc07705548b7e33879f9" translate="yes" xml:space="preserve">
          <source>It's very simple to have your tests run under taint mode. Just throw a &lt;code&gt;-T&lt;/code&gt; into the &lt;code&gt;#!&lt;/code&gt; line. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will read the switches in &lt;code&gt;#!&lt;/code&gt; and use them to run your tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">소프트웨어 개발자는 일반적으로 자신이 작성하는 소프트웨어를 완전히 문서화하는 것으로 잘 알려져 있습니다. 그러나 전 세계에 소프트웨어가 긴급하게 필요하고 전체 문서를 작성할 시간이 충분하지 않은 경우 최소한 다음을 포함하는 README 파일을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 기울임 꼴 버전 (실제로 대부분의 고정 폭 글꼴은 기울임 꼴 버전이 아닌 기울임 버전 만 있으므로 잘못된 이름 임). 기본값은 &lt;code&gt;CI&lt;/code&gt; 입니다. &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 기울임 꼴 버전 (실제로 대부분의 고정 폭 글꼴은 기울임 꼴 버전이 아닌 기울임 버전 만 있으므로 잘못된 이름 임). 기본값은 &lt;code&gt;CI&lt;/code&gt; 입니다. troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a71960565a249a16493cbd47c7e62585cc7cdbc3" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d619f9e66322d8e23851c7238a0c1bf5b94557" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad79ef0f076d3a686ab9738925f4dd2c7e69d7d1" translate="yes" xml:space="preserve">
          <source>Italy</source>
          <target state="translated">Italy</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">아이테니엄 프로세서 제품군 (IPF) 및 HP-UX</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">아이테니엄, 아이테니엄 2 &amp;amp; 매디슨 6</target>
        </trans-unit>
        <trans-unit id="2644b5ac3389091857c1fa06a99019df89bdf067" translate="yes" xml:space="preserve">
          <source>Item called without tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">항목, 끝 및 뒤로는 약간 더 자세한 설명이 필요합니다. &quot;= over&quot;는 &quot;= item&quot;명령을 사용하여 목록을 생성하거나 일반 단락을 들여 쓰기 (indenting)하기 위해 영역을 시작합니다. 목록 끝에서 &quot;= back&quot;을 사용하여 목록을 종료하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="839a5a9f576aa03eb6484f3e36f4922e7b29ec1b" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by the &lt;code&gt;POPMARK&lt;/code&gt; macro. There is also a macro &lt;code&gt;TOPMARK&lt;/code&gt; that inspects the topmost item without removing it. These macros return I32 index values directly. There is also the &lt;code&gt;dMARK&lt;/code&gt; macro which declares a new SV double-pointer variable, called &lt;code&gt;mark&lt;/code&gt;, which points at the marked stack slot; this is the usual macro that C code will use when operating on lists given on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e4f40b0307417307709cb5473dc322f497e53" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by using the &lt;code&gt;POPs&lt;/code&gt; macro or its typed versions, There is also a macro &lt;code&gt;TOPs&lt;/code&gt; that inspects the topmost item without removing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2734858b1f6df00795c8577aa06b54f6e0816d" translate="yes" xml:space="preserve">
          <source>Items are pushed to the save stack by using the various &lt;code&gt;SAVE...()&lt;/code&gt; macros. Many of these macros take a variable and store both its address and current value on the save stack, ensuring that value gets restored on scope exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0e07dde86207db19bb7bb39fcc8f34c4917c7f" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHMARK()&lt;/code&gt; macro. Even though the stack itself stores (value) stack indices as integers, the &lt;code&gt;PUSHMARK&lt;/code&gt; macro should be given a stack pointer directly; it will calculate the index offset by comparing to the &lt;code&gt;PL_stack_sp&lt;/code&gt; variable. Thus almost always the code to perform this is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b956fed2d730024f43d841fa09eee15223cb553e" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHs()&lt;/code&gt; macro or its variants described above; &lt;code&gt;XPUSHs()&lt;/code&gt;, &lt;code&gt;mPUSHs()&lt;/code&gt;, &lt;code&gt;mXPUSHs()&lt;/code&gt; and the typed versions. Note carefully that the non-&lt;code&gt;X&lt;/code&gt; versions of these macros do not check the size of the stack and assume it to be big enough. These must be paired with a suitable check of the stack's size, such as the &lt;code&gt;EXTEND&lt;/code&gt; macro to ensure it is large enough. For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">기발한 입력 구문에 대한 수정 사항을 적용하지 않고 원시 입력을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">물론 그것을 통해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">물론 프로세스 출력을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="427ce88c1ea69b3f405aa4f0fa73689dcbd052f7" translate="yes" xml:space="preserve">
          <source>Iterates over necessary shared objects, calling &lt;code&gt;xs_make_dlsyms&lt;/code&gt; method for each with appropriate arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b5437f5a208443de379288c68fd64af0840d2" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (&lt;code&gt;SVs_PADTMP&lt;/code&gt;) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; &quot;names&quot; (see &lt;code&gt;&lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;&lt;/code&gt;). That &lt;code&gt;&amp;amp;PL_padname_undef&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">PADNAMELIST를 반복하면 가능한 모든 패드 항목을 반복합니다. 대상의 패드 슬롯 (SVs_PADTMP) 및 GV에는 &amp;amp; PL_padname_undef &quot;이름&quot;이 있고 상수의 슬롯에는 &amp;amp; PL_padname_const &quot;이름&quot;이 있습니다 (pad_alloc () 참조). &amp;amp; PL_padname_undef 및 &amp;amp; PL_padname_const가 사용됨은 구현 세부 사항이 변경 될 수 있습니다. 테스트하려면 &lt;code&gt;!PadnamePV(name)&lt;/code&gt; 및 &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; 을 각각 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">배열 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">파일 핸들 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">프로세스 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithread는 다른 스레드간에 데이터가 공유되지 않도록 데이터 트리를 복제하여 작동합니다. 이러한 스레드는 &lt;code&gt;threads&lt;/code&gt; 모듈을 사용하거나 win32 (fake fork () 지원)에서 fork ()를 수행 하여 사용할 수 있습니다 . 스레드가 복제되면 모든 Perl 데이터가 복제되지만 비 Perl 데이터는 자동으로 복제 할 수 없습니다. 5.8.0 이후의 Perl은 &lt;code&gt;CLONE&lt;/code&gt; 특수 서브 루틴을 지원합니다 . &lt;code&gt;CLONE&lt;/code&gt; 에서는 필요한 경우 비 Perl 데이터의 복제 처리와 같이 필요한 모든 작업을 수행 할 수 있습니다. &lt;code&gt;CLONE&lt;/code&gt; 정의 된 (또는 상속 된) 모든 패키지에 대해 클래스 메소드로 한 번 호출됩니다. 새 스레드의 컨텍스트에서 호출되므로 모든 수정이 새 영역에서 수행됩니다. 현재 CLONE은 호출자 패키지 이름 이외의 매개 변수없이 호출되지만, 코드는 복제 상태에 대한 추가 정보를 제공하기 위해 향후 추가 매개 변수가 전달 될 가능성이 있으므로 변경되지 않은 것으로 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">그 &lt;code&gt;pprivate&lt;/code&gt; 및 &lt;code&gt;intflags&lt;/code&gt; 필드는 각 엔진에 대한 데이터 특정 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">&lt;code&gt;SV*&lt;/code&gt; 가 필요할 때마다 해당 주소를 사용할 수 있습니다 . 임의의 sv와 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 비교하지 마십시오 . 예를 들어 Perl 코드를 인터페이스 할 때 다음과 같이 작동합니다</target>
        </trans-unit>
        <trans-unit id="09d223f73a742d40d37e0069338730ea57d94138" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;. For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 의 장점 은 테스트가 실패했을 때 $ got 및 $ expected가 무엇인지 알 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 대한 장점 은 &lt;code&gt;is()&lt;/code&gt; 및 &lt;code&gt;isnt()&lt;/code&gt; 의 장점 과 유사합니다 . 고장 진단 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c8e5bbdfc16ed39f18dc0db649a1798bde0ff44" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt;. Better diagnostics on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">동작은 XS에서 T_IV와 함께 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형 을 사용하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="78ff78bdd00c6e2cf21af3315183fda1a7d0aefd" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;int&lt;/code&gt; type in XS with T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">현재 매우 간단하며,보다 유연한 코드 및 스위치를 포함하도록 그림에서 언젠가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">형식이 시간이 지남에 따라 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab2643af88a544c3d8cf389888d3e8add44c6b63" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;&quot;|&quot;&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">그 이름은 대체 연산자 ( &lt;code&gt;|&lt;/code&gt; ) 와 결합 된이 조작을 사용하여 본질적으로 패턴 기반 if / then / else 블록을 작성하는 데 사용될 수 있다는 관찰에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="857df5ce623d367dca94803887ed2679c126a932" translate="yes" xml:space="preserve">
          <source>Its purpose was to allow your non-ASCII Perl scripts not to have to be written in UTF-8; this was useful before editors that worked on UTF-8 encoded text were common, but that was long ago. It caused problems, such as affecting the operation of other modules that weren't expecting it, causing general mayhem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f8c93b7e3928b82285ec3cb4baed8ba27c22ab" translate="yes" xml:space="preserve">
          <source>Its return buffer is per-thread, so it also is never overwritten by a call to this function from another thread; unlike the function it replaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">\ x1b (탈출) 사용도 매우 의문입니다.</target>
        </trans-unit>
        <trans-unit id="439b82c22fda8042c3800152aa28934c765e39cf" translate="yes" xml:space="preserve">
          <source>Its value grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">줄 바꿈은 &lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap에&lt;/a&gt; 의해 수행 되므로 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 를 원하는대로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8279d860cdcd8af715030eac4d6150f64676e6fe" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d4ca6fbb7f638a8b6b39592979f862bfb9bd67d1" translate="yes" xml:space="preserve">
          <source>J. Nick Koston &amp;lt;nick@cpanel.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0769e7614be3e4e1822db4f1f3c8b1ae2f3201ca" translate="yes" xml:space="preserve">
          <source>JAPH</source>
          <target state="translated">JAPH</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPH는 Randal Schwartz가 1980 년대 후반부터 이메일과 유즈넷 메시지에 서명하는 데 사용했던 &quot;다른 Perl 해커&quot;의 약자입니다. 그는 이전에 많은 주제 ( &quot;또 다른 x 해커&quot;)와 함께이 문구를 사용하여 JAPH를 구별하기 위해 Perl 프로그램으로 작성하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="7f3a84b51622bff154d5971f3af29fa8785e389f" translate="yes" xml:space="preserve">
          <source>JIS has not endorsed the full Microsoft standard however. The official &lt;code&gt;Shift_JIS&lt;/code&gt; includes only JIS X 0201 and JIS X 0208 character sets, while Microsoft has always used &lt;code&gt;Shift_JIS&lt;/code&gt; to encode a wider character repertoire. See &lt;code&gt;IANA&lt;/code&gt; registration for &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="ab81c25e1d8756ce41a1d0bd153f8a1a9cd26516" translate="yes" xml:space="preserve">
          <source>JSON -&amp;gt; PERL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085bf9967f7db3a1e36f211bc12e97fc9c8726e2" translate="yes" xml:space="preserve">
          <source>JSON object. If that is successful, it will return this object, otherwise it will return &lt;code&gt;undef&lt;/code&gt;. If there is a parse error, this method will croak just as &lt;code&gt;decode&lt;/code&gt; would do (one can then use &lt;code&gt;incr_skip&lt;/code&gt; to skip the erroneous part). This is the most common way of using the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca97a1ee6b474fcf8884b628a790828e390c7d4" translate="yes" xml:space="preserve">
          <source>JSON, &lt;a href=&quot;http://json.org/&quot;&gt;http://json.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c9214a804f5e0bb364aa23a074ce1bb72d3b90" translate="yes" xml:space="preserve">
          <source>JSON::PP</source>
          <target state="translated">JSON::PP</target>
        </trans-unit>
        <trans-unit id="bc2d16fc45f4fb15b4bd4ac1aaf8b68aeeba40dd" translate="yes" xml:space="preserve">
          <source>JSON::PP (and JSON::XS) trusts what you pass to &lt;code&gt;encode&lt;/code&gt; method (or &lt;code&gt;encode_json&lt;/code&gt; function) is a clean, validated data structure with values that can be represented as valid JSON values only, because it's not from an external data source (as opposed to JSON texts you pass to &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;decode_json&lt;/code&gt;, which JSON::PP considers tainted and doesn't trust). As JSON::PP doesn't know exactly what you and consumers of your JSON texts want the unexpected values to be (you may want to convert them into null, or to stringify them with or without normalisation (string representation of infinities/NaN may vary depending on platforms), or to croak without conversion), you're advised to do what you and your consumers need before you encode, and also not to numify values that may start with values that look like a number (including infinities/NaN), without validating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67000e5008a49c5764c9853d27cf57eee1416888" translate="yes" xml:space="preserve">
          <source>JSON::PP - JSON::XS compatible pure-Perl module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6a29e642ee039fc28b8f131cabd5029d088849" translate="yes" xml:space="preserve">
          <source>JSON::PP has been in the Perl core since Perl 5.14, mainly for CPAN toolchain modules to parse META.json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aaa45ea1b22edf7987707428a94f3b9ee14d933" translate="yes" xml:space="preserve">
          <source>JSON::PP is a pure perl JSON decoder/encoder, and (almost) compatible to much faster &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; written by Marc Lehmann in C. JSON::PP works as a fallback module when you use &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module without having installed JSON::XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1d3eff2890dd7bf9ac851e6d34ec3c432fa2a0" translate="yes" xml:space="preserve">
          <source>JSON::PP will only attempt to parse the JSON text once it is sure it has enough text to get a decisive result, using a very simple but truly incremental parser. This means that it sometimes won't stop as early as the full parser, for example, it doesn't detect mismatched parentheses. The only thing it guarantees is that it starts decoding as soon as a syntactically valid JSON text has been seen. This means you need to set resource limits (e.g. &lt;code&gt;max_size&lt;/code&gt;) to ensure the parser will stop parsing in the presence if syntax errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4762c702bf2677205442e48ee83f7fae4356feaa" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean</source>
          <target state="translated">JSON::PP::Boolean</target>
        </trans-unit>
        <trans-unit id="65c4433f9da239d7a8e60b68a81d180683b869c9" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean - dummy module providing JSON::PP::Boolean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a48e124df6419ac5c2d9d111fda43bf7f4a2ad" translate="yes" xml:space="preserve">
          <source>JSON::PP::is_bool</source>
          <target state="translated">JSON::PP::is_bool</target>
        </trans-unit>
        <trans-unit id="3dbefab7107beb14a9168d002d27c476d9979a2f" translate="yes" xml:space="preserve">
          <source>JSON::PP::null</source>
          <target state="translated">JSON::PP::null</target>
        </trans-unit>
        <trans-unit id="d245a16cb70b0da2f6ce2e1cc1b15f6f0108705d" translate="yes" xml:space="preserve">
          <source>JSON::PP::true, JSON::PP::false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON :: XS 호환 pure-Perl 모듈.</target>
        </trans-unit>
        <trans-unit id="67cff807001c7900c13019d99056e3c2c5564617" translate="yes" xml:space="preserve">
          <source>JSON::XS indents with three spaces when you &lt;code&gt;encode&lt;/code&gt; (if requested by &lt;code&gt;indent&lt;/code&gt; or &lt;code&gt;pretty&lt;/code&gt;), and the number cannot be changed. JSON::PP allows you to change/get the number of indent spaces with these mutator/accessor. The default number of spaces is three (the same as JSON::XS), and the acceptable range is from &lt;code&gt;0&lt;/code&gt; (no indentation; it'd be better to disable indentation by &lt;code&gt;indent(0)&lt;/code&gt;) to &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eeebe1b8d9c88c3dd6a874baff7c46254de947" translate="yes" xml:space="preserve">
          <source>Jacinta Richardson for translating much of my ideas into this documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ed50c6d4c26a90edb32bb01d8d5b13b356d708" translate="yes" xml:space="preserve">
          <source>James E Keenan &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">제임스이 키넌</target>
        </trans-unit>
        <trans-unit id="fad8357eef2bb53d17336573edc650a4cf157cf3" translate="yes" xml:space="preserve">
          <source>James E. Keenan &amp;lt;jkeen@verizon.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">제임스 키넌, &amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2c916c2a6f4627fbe67be340b96ec2857597184a" translate="yes" xml:space="preserve">
          <source>James Raspass &amp;lt;jraspass@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e4cd2d086a80816fd0c59891fecee24ad1a4c4" translate="yes" xml:space="preserve">
          <source>Jamo_Short_Name</source>
          <target state="translated">Jamo_Short_Name</target>
        </trans-unit>
        <trans-unit id="dc05d77338b63072590a6f49b15e48ec83a7bd95" translate="yes" xml:space="preserve">
          <source>Jan Dubois &amp;lt;jand@activestate.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf29f6cad3232704b33e962ef5194fad3b6817b" translate="yes" xml:space="preserve">
          <source>Japan</source>
          <target state="translated">Japan</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">일본어 인코딩</target>
        </trans-unit>
        <trans-unit id="f0fae5d9347791c2b844b690a046bfe7552e453c" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (-f).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6422bf1002562f4885ccb3e7c11949b9fc2f34" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (&lt;code&gt;-f&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">자르 코 히에 타니 에미</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">자르 코 히에 타니 에미 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">Jarkko Hietaniemi의 오리지널</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6f1f3b8aba1c1fb078ca69f70f0d3a32db2b05e" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;. Now maintained by Perl 5 porters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi, Perl 5.8에 포함시키기 위해 libnetcfg로 변환.</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Jarkko Hietaniemi. 이제 perl5 포터가 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">자바 스크립트 트랩</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Jean Delvare는 다음과 같은 다양한 공통 터미널 에뮬레이터 표를 제공했으며 다양한 속성 및 기타 속성에 대한 지원을 통해이를 육체적으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="27f5b59f8afefe05a200ff5c9949b24e5ca9ea36" translate="yes" xml:space="preserve">
          <source>Jed</source>
          <target state="translated">Jed</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">제프 오카모토 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy 및 Larry Wall.</target>
        </trans-unit>
        <trans-unit id="2425ad3a84d8960ab9c2915a943fd7e28d7c0291" translate="yes" xml:space="preserve">
          <source>Jeremy Mates &amp;lt;jmates@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52232653f25fa8c0538602bfc7945ebf9d9b79a7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Jerry D. Hedden과 Reini Urban 은 Cygwin에서 &lt;code&gt;Sys::Syslog&lt;/code&gt; 를 디버그하고 연마하는 데 크게 도움이되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5109d5f0b8672892d9cf43511b2568ff7ce2637" translate="yes" xml:space="preserve">
          <source>Jerry Gay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7ad312b85f19c8a09454b49798a0382227aa86" translate="yes" xml:space="preserve">
          <source>Jess Robinson &amp;lt;castaway@desert-island.me.uk&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f1b3fc35d7e705b8692294a866fb025bdc15b4" translate="yes" xml:space="preserve">
          <source>Jim Brandt suggest and provided the initial implementation for the up-to-date and Changes features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549b2243ef15345835dfd4eb22ac64d2df0ea3a8" translate="yes" xml:space="preserve">
          <source>Jim Keenan fixed up various issues with _download</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;에서 만든 프레임 워크를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">요한 브로 만 스 &amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="183447aad929b68cdb9a4bc6a0988222e172d912" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt; H. Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d401e67bf973d127449e78a2dab7a6e33bf82ed1" translate="yes" xml:space="preserve">
          <source>John Lightsey &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93554073e2a9ef40605d8eff344dac817dfa1a9" translate="yes" xml:space="preserve">
          <source>John Peacock &amp;lt;jpeacock@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">EXPR 값으로 구분 된 필드를 사용하여 LIST의 별도 문자열을 단일 문자열로 결합하고 새 문자열을 반환합니다. 예:</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">존 오완 트</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">존 오완 트 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e683318ce5a68c3c49c2481778c7d3eb5187cf39" translate="yes" xml:space="preserve">
          <source>Jonas B. Nielsen &amp;lt;jonasbn@hoarfrost.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b947fc83a952d44b7572b1e1134cb1af54db24" translate="yes" xml:space="preserve">
          <source>Josh Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Joshua Chamas의 Tie :: Cache 모듈은 만료 관리자로 유용 할 수 있습니다. (이 방법을 시도하면 작동 방식을 알려주십시오.)</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">조슈아 벤 조어 &amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">신중한 JavaScript 프로그래머는 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">많은 Perl 수도사의 도움으로 Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bd209361669e6039e2d46925b98964270ec9db84" translate="yes" xml:space="preserve">
          <source>July 26, 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b31aa739648b445f7448224142630d141a4270e" translate="yes" xml:space="preserve">
          <source>June 12, 2007</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a23786af78acf626cd4573fa13a06ed0180b91" translate="yes" xml:space="preserve">
          <source>June 2008</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d4e067e5679c035c82b3463849e985c82217de" translate="yes" xml:space="preserve">
          <source>June 2017, for Synology DSM 5.1.5022 and DSM 6.1-15101-4.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
