<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3f7b2356bc3c6cbdde72802a26b13714fd83fb6c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;perlpod&quot;&gt;plain old documentation&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e2d057fcf298f7072a9c254f5415e3ce42e39e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b53467807b9027de0ba1ae32437de79640c9fd" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; (표준 Perl 배포의 일부)을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="87276cc5955780242b6240d9ad22eaa36930d92c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:alias&lt;/code&gt; to give your own lexically scoped nicknames to existing characters, or even to give unnamed private-use characters useful names.</source>
          <target state="translated">&lt;code&gt;:alias&lt;/code&gt; 를 사용 하여 기존 문자에 고유 한 어휘 범위 별명을 지정하거나 이름이없는 개인용 문자에 유용한 이름을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="fdf71fcf7dcb9c3fbc3fc7c52735a70671018192" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; either in open() or binmode() to install a layer that transparently does character set and encoding transformations, for example from Shift-JIS to Unicode. Note that under &lt;code&gt;stdio&lt;/code&gt; an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt; . See &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="translated">사용 &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; 투명 예컨대 시프트 JIS-에서 유니 코드 문자 집합 부호화의 변환을 수행하는 층을 설치하는 오픈 () 또는 bin 파일 ()에서 행해도된다. 참고 아래의 것을 &lt;code&gt;stdio&lt;/code&gt; &lt;code&gt;:encoding&lt;/code&gt; 도하는 수 &lt;code&gt;:utf8&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0596c7e9304d40616582d7ad418a939b0b569b98" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; to transparently do character set and encoding transformations, for example from Shift-JIS to Unicode. Note that an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt;. See &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b32751627ad0f538a9c781523741b9c9689a81e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:via(MODULE)&lt;/code&gt; either in open() or binmode() to install a layer that does whatever transformation (for example compression / decompression, encryption / decryption) to the filehandle. See &lt;a href=&quot;perlio/via&quot;&gt;PerlIO::via&lt;/a&gt; for more information.</source>
          <target state="translated">사용 &lt;code&gt;:via(MODULE)&lt;/code&gt; 하나의 개방 () 또는 bin 파일 ()은 핸들에 (예를 들어, 압축 / 압축 해제, 암호화 / 복호화를위한) 어떤 변환을 수행하는 층을 설치하는. 자세한 내용은 &lt;a href=&quot;perlio/via&quot;&gt;PerlIO :: via&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9727d6cadefbfc6680b09de2a83ff6897fb06fc4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to check for Perl's extended UTF-8; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc6bcca8c8291fe091fc5eba0b5c978fb11554d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to restrict the acceptable code points to those defined by Unicode to be fully interchangeable across applications; &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to use the &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt; definition of allowable code points; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2594bc53acbb8193156330388d855a8adc6a6ea0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; to check for Perl's extended UTF-8; and &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR_flags&quot;&gt;&quot;isUTF8_CHAR_flags&quot;&lt;/a&gt;&lt;/code&gt; for a more customized definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1157d2d20dde5a15fbdf95d65ef85d099140d1ab" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loc&quot;&gt;&quot;is_c9strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string_loclen&quot;&gt;&quot;is_c9strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6aa5f83c56c2fc0dc5608f78102ee88a53475fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loc&quot;&gt;&quot;is_strict_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string_loclen&quot;&gt;&quot;is_strict_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f540d6d7b5ffa5ec6b09b9a4359e52e070a6b6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loc&quot;&gt;&quot;is_utf8_string_loc&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#is_utf8_string_loclen&quot;&gt;&quot;is_utf8_string_loclen&quot;&lt;/a&gt;&lt;/code&gt; to check entire strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c35f727c8e06fe9ff695531c994a06e6d32367e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="translated">지역 변수에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 를 사용 하면 멀리 갈 수 있습니다 (그러나 할 수없는 곳 은 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 사용하면 실제로 전역 변수에 지역 값이 주어 지므로 동적 범위 지정의 예기치 않은 부작용에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="c47d329f16fdbd745016d298559c2d16104952e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt;, or else &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; and the bitwise operations.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; , 또는 다른 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 와 비트 연산.</target>
        </trans-unit>
        <trans-unit id="e7d6c1efbb4fe6ed3d0e44682a7fdfcad4845a94" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하여 여러 데이터 조각에서 고정 너비 버전으로 이동하십시오. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용 하여 고정 너비 형식 문자열을 여러 데이터 조각으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="8fbc052d865293ed23949ab2e7f416dfadd5a776" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; 에 설명 된대로, 스칼라 문맥에서 &lt;a href=&quot;functions/reverse&quot;&gt;역&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27ae995888d29f8142b3c2932bd24cab6ea87cf6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt; , instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 대신 &lt;code&gt;@CARP_NOT&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="606cd34efaddb2638df681f99b6af26a22978dd9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt;, instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92183967ac97249aea7bc977e218502508a51699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should be:</source>
          <target state="translated">Perl 내장 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수 와 함께 &lt;code&gt;NDBM_File&lt;/code&gt; 을 사용 하여 변수와 파일 사이의 연결을 설정하십시오. &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 할 주장 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f242fee978e3dcd99181c765d0434e5812cdd5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;tie&lt;/code&gt; should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9423ac1af551ac690aef0474203af36011c9817e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ODBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;tie&lt;/code&gt; should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39f53bf0801332ad81a8e20b727e708ddef3b6b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt; , it comes with its own role implementation.</source>
          <target state="translated">다중 상속을 고려하고 있다면 &lt;code&gt;Class::Accessor&lt;/code&gt; 또는 &lt;code&gt;Class::Tiny&lt;/code&gt; &lt;code&gt;Role::Tiny&lt;/code&gt; 와 함께 Role :: Tiny 를 사용하십시오 . &lt;code&gt;Moose&lt;/code&gt; 와 함께 가면 자체 역할 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fabbc51b5191f6f0947ec18c66a1a930b3727711" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt;, it comes with its own role implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f06b5eddbf8d97d651f4831a1beb13b8718c8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="translated">Perl 내장 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수 와 함께 &lt;code&gt;SDBM_File&lt;/code&gt; 을 사용 하여 변수와 파일 사이의 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ae2becc725210179bc532cf645f737467fa7ad50" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;tie&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5ddb92a2e87aa696e71c88822af794ba04ff5b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5709fd5fee3c8f65a9f2b5ff4443b46d700ffd8b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;error&lt;/code&gt; to trap all that is reasonable (problems with permissions and the like), and let it die if things get out of hand. This is the safest course of action.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 를 사용 하여 합리적인 모든 권한 (권한 등의 문제)을 포착하고 문제가 해결되지 않으면 죽도록하십시오. 이것이 가장 안전한 행동 과정입니다.</target>
        </trans-unit>
        <trans-unit id="a7ae97b4dc032127dbdf525b36f3287eea7a74cc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt; /&lt;code&gt;foreach&lt;/code&gt; :</source>
          <target state="translated">사용 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="55bdf440a9f723ee43aebb77971d2e3eb2db4e84" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c996433c1b1c526a5c995da04a118c0ab560ab7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;my()&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;local()&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373cbc173d8d72760b4d82b2e0cd717919a95b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt;, or else &lt;code&gt;vec()&lt;/code&gt; and the bitwise operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9088d71cb197707818e551ff66050ee4db9e30a5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;pack&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;unpack&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f6d6f105dad51bdc7b3be73deb4316e5aa1573" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;reverse()&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;perlfunc#reverse&quot;&gt;&quot;reverse&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42448f158fc4cf33aed96fb909d73152cfab8a01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">2Gb보다 긴 문자열을 올바르게 처리하는 환경 설정에서 &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7227aee0b7448cf59bbacaf7f7fdbecd1aac240b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">2Gb보다 긴 문자열을 올바르게 처리하는 환경 설정에서 &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5cc90bbf1f42a53e21bdba9821c29aadf03b587" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the first parameter to this function to get the effect of passing NULL as the first parameter to &lt;code&gt;mblen&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;mbrlen&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f392458fbcc15b0a14e0e135484e6100755568d8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the first parameter to this function to get the effect of passing NULL as the first parameter to &lt;code&gt;wctomb&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;wcrtomb&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3b928d47a6b3cc4fc01ca2a0f7d31491bc6c38" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;undef&lt;/code&gt; as the second parameter to this function to get the effect of passing NULL as the second parameter to &lt;code&gt;mbtowc&lt;/code&gt;. This resets any shift state to its initial value. The return value is undefined if &lt;code&gt;mbrtowc&lt;/code&gt; was substituted, so you should never rely on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9174053d497c0bac4b0650a86818fe94eb1cad92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;utf8::encode()&lt;/code&gt; instead.</source>
          <target state="translated">사용 &lt;code&gt;utf8::encode()&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e974bf00a2d723dec73908b097ca121c9409a8e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;~pattern&lt;/code&gt; and &lt;code&gt;!pattern&lt;/code&gt; for positive and negative regexes.</source>
          <target state="translated">양수 및 음수 정규식에 &lt;code&gt;~pattern&lt;/code&gt; 및 &lt;code&gt;!pattern&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="061b1dc7990493487dde420be8fe1d319fffab9e" translate="yes" xml:space="preserve">
          <source>Use CPAN::SQLite if available? (yes/no)?</source>
          <target state="translated">가능한 경우 CPAN :: SQLite를 사용 하시겠습니까? (예 아니오)?</target>
        </trans-unit>
        <trans-unit id="714325381beb635775804a746adac93cfa93686a" translate="yes" xml:space="preserve">
          <source>Use Internet-domain sockets when you want to do client-server communication that might extend to machines outside of your own system.</source>
          <target state="translated">자체 시스템 외부의 시스템으로 확장 될 수있는 클라이언트-서버 통신을 수행하려면 인터넷 도메인 소켓을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b9b3669dfa437dd595e2562fc06d4aa9b5c2435" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros, and VMS command line for C compiler.</source>
          <target state="translated">C 컴파일러에는 MM [SK] 매크로와 VMS 명령 행을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4874b782f37efa4adbe580d7fbd195de341f05" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros.</source>
          <target state="translated">MM [SK] 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="566b4db3c362df6b71e0ff5dee0038deb7684d52" translate="yes" xml:space="preserve">
          <source>Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">MakeMaker의 제거 된 버전의 패키지 사용</target>
        </trans-unit>
        <trans-unit id="4f9fabedc3012949759d8b318f59e8e1f7ac6a68" translate="yes" xml:space="preserve">
          <source>Use Rule 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30cb9c4b707a0ea6318459e09b4f950a7aa56ec" translate="yes" xml:space="preserve">
          <source>Use Rule 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0e5dba70a90f698d3e0ca5e61baef285d0f01f" translate="yes" xml:space="preserve">
          <source>Use VMS Link command.</source>
          <target state="translated">VMS 링크 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="280948ed6505d39690e8bfb21e155eff171d0ef1" translate="yes" xml:space="preserve">
          <source>Use VMS commands to manipulate object library.</source>
          <target state="translated">VMS 명령을 사용하여 객체 라이브러리를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="bda9ca770225246f2160551c7450fb9367f1b262" translate="yes" xml:space="preserve">
          <source>Use VMS file specification syntax and CLI commands to find and invoke Perl images.</source>
          <target state="translated">VMS 파일 스펙 구문 및 CLI 명령을 사용하여 Perl 이미지를 찾아 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ede73fbf3b4744edf3efb586d91835b3d9ad9918" translate="yes" xml:space="preserve">
          <source>Use VMS syntax on command line. In particular, $(DEFINE) and $(PERL_INC) have been pulled into $(CCCMD). Also use MM[SK] macros.</source>
          <target state="translated">명령 행에서 VMS 구문을 사용하십시오. 특히 $ (DEFINE) 및 $ (PERL_INC)가 $ (CCCMD)로 가져 왔습니다. MM [SK] 매크로도 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b04910f58b3601dbb3123084b8efe1db2f3112cb" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;MM_Unix&lt;/a&gt; method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691de1dabff4e93d09d661b351d70e27dc9a3c25" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the MM_Unix method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="translated">파일에 VMS 스타일 구문을 사용하십시오. MM_Unix 메소드가 &lt;code&gt;catfile&lt;/code&gt; 을 반복적으로 호출하는 것보다 여기에서 직접 수행하는 것이 더 저렴합니다 . 또한 Config.pm을 다시 빌드해야하는 경우 MM [SK]를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e7289d77337b52e3e101220e2c02359e9406ba1" translate="yes" xml:space="preserve">
          <source>Use \x{...} for more than two hex characters in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21386b7269a32025e94fbc169460c22c01ed7e1f" translate="yes" xml:space="preserve">
          <source>Use a collator object to compare Unicode text by character instead of by codepoint.</source>
          <target state="translated">collator 객체를 사용하여 유니 코드 텍스트를 코드 포인트가 아닌 문자별로 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="af5688754fcfe001260b97f3d6228bac17ab8a5e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; explicitly:</source>
          <target state="translated">명령 행 옵션, 환경 변수를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="86512cacbdfebef905eeab5b1d6bac9c2f54b06e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;binmode&lt;/code&gt; explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba762ed342f4cf062ad179e99538aaf1e4c1ae60" translate="yes" xml:space="preserve">
          <source>Use a hash. Here's code to do both and more. It assumes that each element is unique in a given array:</source>
          <target state="translated">해시를 사용하십시오. 다음은 둘 다 수행하는 코드입니다. 주어진 배열에서 각 요소가 고유하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="271eac68025544545b6b8cda21c48f10de3e2be3" translate="yes" xml:space="preserve">
          <source>Use a hash. When you think the words &quot;unique&quot; or &quot;duplicated&quot;, think &quot;hash keys&quot;.</source>
          <target state="translated">해시를 사용하십시오. &quot;고유 한&quot;또는 &quot;중복 된&quot;이라는 단어를 생각할 때 &quot;해시 키&quot;를 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="fb4ec017e331a31a5b1abaea84089100f3dba15e" translate="yes" xml:space="preserve">
          <source>Use a sort helper function</source>
          <target state="translated">정렬 도우미 기능 사용</target>
        </trans-unit>
        <trans-unit id="f616a684cd386a4ea767461805601287970f5579" translate="yes" xml:space="preserve">
          <source>Use a tree format in which the minimum amount of space is used for the lines connecting nodes (one character in most cases). This squeezes out a few precious columns of screen real estate.</source>
          <target state="translated">노드를 연결하는 라인 (대부분의 경우 한 문자)에 최소 공간이 사용되는 트리 형식을 사용하십시오. 이것은 화면 공간의 몇 가지 귀중한 열을 압착합니다.</target>
        </trans-unit>
        <trans-unit id="5882a02b6e19732df1aac03e7c042980b0e32ff8" translate="yes" xml:space="preserve">
          <source>Use a tree format that uses longer edges to separate OP nodes. This format tends to look better than the compact one, especially in ASCII, and is the default.</source>
          <target state="translated">더 긴 가장자리를 사용하여 OP 노드를 분리하는 트리 형식을 사용하십시오. 이 형식은 특히 ASCII에서 컴팩트 한 형식보다보기 좋으며 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4b48f7ca244968605d46dde3055bd12f89577678" translate="yes" xml:space="preserve">
          <source>Use an alpha/beta style version number. Causes version number to be &quot;0.00_01&quot; unless &lt;b&gt;-v&lt;/b&gt; is specified.</source>
          <target state="translated">알파 / 베타 스타일 버전 번호를 사용하십시오. &lt;b&gt;-v&lt;/b&gt; 를 지정 하지 않으면 버전 번호가 &quot;0.00_01&quot; 이됩니다.</target>
        </trans-unit>
        <trans-unit id="6134c36e04029ff2453cb542046305a1f937b7f5" translate="yes" xml:space="preserve">
          <source>Use an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin.</source>
          <target state="translated">다른 표제 스타일을 사용 하고 왼쪽 여백에 콜론으로 &lt;code&gt;=item&lt;/code&gt; 항목을 표시하는 대체 출력 형식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcdeb0b163229c6ff03de5a0cdb9e6a57a7ea002" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . The</source>
          <target state="translated">인덱스가 있으면 사용하십시오. &lt;b&gt;-X&lt;/b&gt; 베이스 이름 파일의 명령 행에 주어진 이름과 일치하는 항목에 대한 옵션 외모 &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="ef5fba3e097676146fd184d39f8ee78df4f9bf53" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt;. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7e5fe5c728700cd50b3c52c6ee63480235da37" translate="yes" xml:space="preserve">
          <source>Use as separator a character which is legal in a VMS-syntax file name.</source>
          <target state="translated">VMS 구문 파일 이름에 유효한 문자를 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="672a1c76642ee42c51ebfa65fd5a5d1a95399678" translate="yes" xml:space="preserve">
          <source>Use autosplit so little used or newly added functions won't be a burden to programs that don't use them. Add test functions to the module after __END__ either using AutoSplit or by saying:</source>
          <target state="translated">자동 스플릿을 사용하면 사용하지 않거나 새로 추가 된 기능이 거의 사용되지 않는 프로그램에 부담이되지 않습니다. AutoSplit을 사용하거나 다음과 같이 말하여 __END__ 이후에 테스트 기능을 모듈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="317a05001ebb0c43c5b2e6eaa3b070114b0ab11b" translate="yes" xml:space="preserve">
          <source>Use blessed references. Use the two argument form of bless to bless into the class name given as the first parameter of the constructor, e.g.,:</source>
          <target state="translated">복된 참조를 사용하십시오. 생성자의 첫 번째 매개 변수로 주어진 클래스 이름을 축복하기 위해 bless의 두 인수 형식을 사용하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="ec95e04beca28ff76c489858d434dba58b46f4b7" translate="yes" xml:space="preserve">
          <source>Use both global and lexical variables.</source>
          <target state="translated">전역 변수와 어휘 변수를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ec0b24d1442368e951d28938a31c4007d000691" translate="yes" xml:space="preserve">
          <source>Use formatting conventions in which the name of each OP, rather than being written out in full, is represented by a one- or two-character abbreviation. This is mainly a joke.</source>
          <target state="translated">전체 OP가 아닌 각 OP의 이름이 1 자 또는 2 자 약어로 표시되는 형식 규칙을 사용하십시오. 이것은 주로 농담입니다.</target>
        </trans-unit>
        <trans-unit id="32e0435d286f4e0f5dea4e605f6ba74b7a19693a" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; , and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; .</source>
          <target state="translated">환경 변수 &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; 및 &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; 에서 읽은 형식 지정 규칙을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2b1ef34038ed8dfe09f9371921208e861dec82e" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt;, &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt;, and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fae2a54363441130a92de76cae86f65e4405daf" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="translated">&lt;b&gt;B :: Debug를&lt;/b&gt; 연상시키는 형식 규칙을 사용하십시오 . 이것들은 전혀 간결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ece1c683b89e2113c24ec60abd248372293805ff" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of CPAN module &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e51473a2aeb572e34290de332f54db3103274f" translate="yes" xml:space="preserve">
          <source>Use formatting conventions that emulate the output of &lt;b&gt;B::Terse&lt;/b&gt;. The basic mode is almost indistinguishable from the real &lt;b&gt;B::Terse&lt;/b&gt;, and the exec mode looks very similar, but is in a more logical order and lacks curly brackets. &lt;b&gt;B::Terse&lt;/b&gt; doesn't have a tree mode, so the tree mode is only vaguely reminiscent of &lt;b&gt;B::Terse&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;B :: Terse&lt;/b&gt; 의 출력을 에뮬레이트하는 형식 규칙을 사용하십시오 . 기본 모드는 실제 &lt;b&gt;B :: Terse&lt;/b&gt; 와 거의 구별 할 수 &lt;b&gt;없으며&lt;/b&gt; , exec 모드는 매우 유사 해 보이지만보다 논리적 인 순서이며 중괄호가 없습니다. &lt;b&gt;B :: Terse&lt;/b&gt; 에는 트리 모드가 없으므로 트리 모드는 &lt;b&gt;B :: Terse를&lt;/b&gt; 모호하게 연상 &lt;b&gt;시킵니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05e7e7257def62f44171c1ab5e1ea5739af490a1" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. atoi() has ill-defined behavior on overflows, and cannot be used for incremental parsing. It is also affected by locale, which is bad.</source>
          <target state="translated">대신 grok_atoUV ()를 사용하십시오. atoi ()는 오버플로에서 잘못 정의 된 동작을 가지며 증분 구문 분석에 사용할 수 없습니다. 또한 로케일의 영향을 받아 나쁜 상태입니다.</target>
        </trans-unit>
        <trans-unit id="49bfe15faf704565402bc75b321564e7f1a0847e" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. strtol() or strtoul() (or their IV/UV-friendly macro disguises, Strtol() and Strtoul(), or Atol() and Atoul() are affected by locale, which is bad.</source>
          <target state="translated">대신 grok_atoUV ()를 사용하십시오. strtol () 또는 strtoul () (또는 IV / UV에 적합한 매크로 변장, Strtol () 및 Strtoul () 또는 Atol () 및 Atoul ()은 로케일에 의해 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="fec2179657e1b299044343e0b89c5b33f2055639" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">반복되는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 문 대신 여기에 문서를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c440dc86e72fbc8e04ff6164f2628ef826b387c3" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;print()&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7408313f5feae22d66298e9df35a5c92afed0d81" translate="yes" xml:space="preserve">
          <source>Use integer arithmetic instead of floating point</source>
          <target state="translated">부동 소수점 대신 정수 산술을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2d0c065aebe88058e7899fe2b03390f5fd9ac8" translate="yes" xml:space="preserve">
          <source>Use it as follows:</source>
          <target state="translated">다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e4377f0ebd8feae0e428e1f69f4b88e9fe92f50" translate="yes" xml:space="preserve">
          <source>Use map and grep selectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2153ef63f7f49f92d87613b8e6086727534be7" translate="yes" xml:space="preserve">
          <source>Use mkstemp() instead.</source>
          <target state="translated">대신 mkstemp ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d215af52eba1c24168d3668f703076a6c44c6c8" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt;.</source>
          <target state="translated">mstat () 함수를 사용하여 메모리 상태 통계를 터미널로 내보내십시오. mstat ()의 출력 형식에 대한 자세한 정보는 perldebguts에서 &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;$ ENV {PERL_DEBUG_MSTATS} 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9090f5fa82f58c70e0a393ca1899abc0c7f56518" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;perldebguts#Using-%24ENV%7BPERL_DEBUG_MSTATS%7D&quot;&gt;&quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531c130b925ffd3120eb898dd244351239e437cf" translate="yes" xml:space="preserve">
          <source>Use my_strlcpy() and my_strlcat() instead: they either use the native implementation, or Perl's own implementation (borrowed from the public domain implementation of INN).</source>
          <target state="translated">대신 my_strlcpy () 및 my_strlcat ()을 사용하십시오. 네이티브 구현 또는 Perl 자체 구현 (INN의 퍼블릭 도메인 구현에서 차용)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c9671db7475e8358c84b51b41af26939a79a05c" translate="yes" xml:space="preserve">
          <source>Use named parameters (a hash or hashref) when there are more than two parameters</source>
          <target state="translated">둘 이상의 매개 변수가있는 경우 명명 된 매개 변수 (해시 또는 해시 참조) 사용</target>
        </trans-unit>
        <trans-unit id="6b1ab005a876449dcff824693329635ee0415484" translate="yes" xml:space="preserve">
          <source>Use named parameters. It's easier to use a hash like this:</source>
          <target state="translated">명명 된 매개 변수를 사용하십시오. 다음과 같이 해시를 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a7996c874ba5c6e6417be6c43ab584f3aaff6022" translate="yes" xml:space="preserve">
          <source>Use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">못생긴 구두점 변수에 멋진 영어 (또는 awk) 이름 사용</target>
        </trans-unit>
        <trans-unit id="8d5397d217e6f86d4205c68445ae6f732da49e78" translate="yes" xml:space="preserve">
          <source>Use non-standard idioms (otherwise you are not testing TIMTOWTDI).</source>
          <target state="translated">비표준 관용구를 사용하십시오 (그렇지 않으면 TIMTOWTDI를 테스트하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="6d784f6b71c910742ddb8c39366085d5eaa6b49a" translate="yes" xml:space="preserve">
          <source>Use of &quot;goto&quot; to jump into a construct is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c0ad194f86ef8c82abcd714574628241a1c276" translate="yes" xml:space="preserve">
          <source>Use of %s for non-UTF-8 locale is wrong. Assuming a UTF-8 locale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebafaa19d6fe670acf22d1cc6a431b641b74e89" translate="yes" xml:space="preserve">
          <source>Use of %s in printf format not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ca242f9217b9ece62afdc3280e0c2f1ce89fd5" translate="yes" xml:space="preserve">
          <source>Use of %s is not allowed in Unicode property wildcard subpatterns in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7a3eef2bfbbb30c9188767c64177f8e00781d5" translate="yes" xml:space="preserve">
          <source>Use of %s on a handle without * is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7c4737dfee83ab37645e9a00338ed68db9aa94" translate="yes" xml:space="preserve">
          <source>Use of '%s' in \p{} or \P{} is deprecated because: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c751876ef69d38b0b6a8bd312f51c65ad7867cd" translate="yes" xml:space="preserve">
          <source>Use of *glob{FILEHANDLE}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf1d32e71b080bd0e2166e3ce2c5596c1ae49fa" translate="yes" xml:space="preserve">
          <source>Use of -l on filehandle%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdcd0ba50f9a29dcb0b98dafb0194ca0fdfb139" translate="yes" xml:space="preserve">
          <source>Use of /c modifier is meaningless in s///</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09256ec5e382dc06ceda63430da57dffa9dad61" translate="yes" xml:space="preserve">
          <source>Use of /c modifier is meaningless without /g</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a582d342a6007eed483b9b338c2db031af137645" translate="yes" xml:space="preserve">
          <source>Use of /g modifier is meaningless in split</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7316ff47b19ccc203ee621904eb275b145a2994" translate="yes" xml:space="preserve">
          <source>Use of := for an empty attribute list is not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468e9917b59882eb3d8638fe67693df28c0d85ba" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; on aggregates (hashes and arrays) is no longer supported. It used to report whether memory for that aggregate had ever been allocated. You should instead use a simple test for size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18763d393ff0aca29ed275dd1c244f6eb5d9f3f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3e24eb7265f399128718cd4ed1d941275d4544" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;&quot;#&quot;&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt;) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; or &lt;code&gt;\p{name=...}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0cda525ac86ed2eeaa7f4035a68ab00df2e040" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;#&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt; ) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; 를 사용 하면 패턴에 실제 공백이나 &lt;code&gt;#&lt;/code&gt; 문자 를 원한다면 ( &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않는 괄호로 묶은 문자 클래스 외부 ) 백 슬래시 또는 &lt;code&gt;\Q...\E&lt;/code&gt; 사용하여 이스케이프 처리해야합니다 . \ E ) 또는 8 진, 16 진 또는 &lt;code&gt;\N{}&lt;/code&gt; 이스케이프를 사용하여 인코딩하십시오 . 백 슬래시 또는 &lt;code&gt;\Q&lt;/code&gt; &lt;code&gt;\n&lt;/code&gt; 을 이스케이프 처리하여 다음 줄에 주석을 계속 사용하는 것은 효과적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1cbbacbfb5cc1cd370b8cd67026b2e577274d54c" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">집계 (해시 및 배열) 에 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 사용 은 더 이상 사용되지 않습니다. 해당 집계에 대한 메모리가 할당되었는지 여부를보고하는 데 사용되었습니다. 이 문제는 이후 버전의 Perl에서 사라질 수 있습니다. 대신 크기에 대한 간단한 테스트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c575003ac8ed97c3c8c499c8985b645cc965dd9e" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">집계 (해시 및 배열) 에 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 사용 은 더 이상 사용되지 않습니다. 해당 집계에 대한 메모리가 할당되었는지 여부를보고하는 데 사용되었습니다. 이 문제는 이후 버전의 Perl에서 사라질 수 있습니다. 대신 크기에 대한 간단한 테스트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1452256e006f48ab16db831ff1d2bc55b7b495f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">의 사용 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 구성체로 뛰어가되지 않으며 경고를 발행합니다. 그럼에도 불구하고 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구성으로 들어가는 데 사용될 수 없습니다 . 또한 최적화 된 구문으로 들어가는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa03266aa6d88c654f206267c8022d408e9c245" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">의 사용 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 구성체로 뛰어가되지 않으며 경고를 발행합니다. 그럼에도 불구하고 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구성으로 들어가는 데 사용될 수 없습니다 . 또한 최적화 된 구문으로 들어가는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d32f8fbd86e7458e1a9f83eb5128d9b92159295d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;\N{}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a03f34c55feb99ac37237337b71f2bbb24cc722" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;\N{}&lt;/code&gt; with nothing between the braces was deprecated in Perl 5.24, and throws a fatal error as of Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5064a11ee17de7c6b4f525fb98c9de3471ad9b56" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dump()&lt;/code&gt; instead of &lt;code&gt;CORE::dump()&lt;/code&gt; was deprecated in Perl 5.8, and an unqualified &lt;code&gt;dump()&lt;/code&gt; will no longer be available in Perl 5.30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4b161f30574eaa433844bbaf4ce439759098dd" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;goto LABEL&lt;/code&gt; or &lt;code&gt;goto EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine, a &lt;code&gt;foreach&lt;/code&gt; loop, or a &lt;code&gt;given&lt;/code&gt; block. In general, it may not be used to jump into the parameter of a binary or list operator, but it may be used to jump into the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc7e9c1e65d2b2d7ee8473afb7a4367f93c333a" translate="yes" xml:space="preserve">
          <source>Use of \N{}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dfc1119fcc5888a5876ddb333f3d0fa91541d8" translate="yes" xml:space="preserve">
          <source>Use of a bare terminator was deprecated in Perl 5.000, and is a fatal error as of Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce1975659a74600b8f5d10e727a0e482e0ccb5e" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt; . For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , or just &lt;code&gt;name&lt;/code&gt; . How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="translated">접두사가 &lt;code&gt;*&lt;/code&gt; 로 된 단일 식별자 사용 . 예를 들어, &lt;code&gt;*name&lt;/code&gt; 의 일부 또는 전부를 의미 &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , 아니면 그냥 &lt;code&gt;name&lt;/code&gt; . 사용 방법에 따라 전체 또는 단일로 해석되는지 여부가 결정됩니다. Camel 2 장,&amp;ldquo;비트와 조각&amp;rdquo;의&amp;ldquo;타입 글로브와 파일 핸들&amp;rdquo;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9efe55d6316474228b943b01fd40260688802603" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt;. For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;@name&lt;/code&gt;, &lt;code&gt;%name&lt;/code&gt;, &lt;code&gt;&amp;amp;name&lt;/code&gt;, or just &lt;code&gt;name&lt;/code&gt;. How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3881272909d748ab2110f15f44ee735d764d9f5" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79921a859879ed1277d82b4cc80975d8402d69d3" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to exists() is an error.</source>
          <target state="translated">exist ()의 인수로 서브 루틴 이름이 아닌 서브 루틴 호출을 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86136067e812367f102852e0f2a4131e0073483c" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt; . What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="translated">위에 나열된 것 이외 의 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 다음에 나오는 다른 문자 는 사용하지 않는 것이 좋습니다. Perl v5.20부터는 실제로 허용되는 문자는 왼쪽 중괄호 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 를 제외한 인쇄 가능한 ASCII 문자입니다 . 허용 된 다른 문자에 대해 발생하는 것은 64 번째 비트 인 xor'ing에 의해 값이 도출되고 활성화 된 경우 경고가 발생한다는 것입니다. 허용되지 않는 문자를 사용하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3963c492ea44a849f2bbefe1df3ebc8f84c5b619" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt;. What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd42bdd625b8d0b9d131c2d5eabe222b4e385960" translate="yes" xml:space="preserve">
          <source>Use of bare &amp;lt;&amp;lt; to mean &amp;lt;&amp;lt;&quot;&quot; is forbidden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8df89669e693c3f41976f14858dbf5ac4daf98f" translate="yes" xml:space="preserve">
          <source>Use of code point 0x%s is not allowed; the permissible max is 0x%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce31c6fac1c3d88e21b9aa38b5da69bc1299dc6b" translate="yes" xml:space="preserve">
          <source>Use of code point 0x%s is not allowed; the permissible max is 0x%X in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc07c6c17cfacbbf506929ab43b45dc5c37c1366" translate="yes" xml:space="preserve">
          <source>Use of code points over 0xFF in string bitwise operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a4474ac4e2b4bfc6cd8e3f6568e69b02d635ec" translate="yes" xml:space="preserve">
          <source>Use of comma-less variable list in formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d322945b4e21e9e3602bafb5e497ecc98176eed" translate="yes" xml:space="preserve">
          <source>Use of each publically accessible method or subroutine, including parameters and return values</source>
          <target state="translated">매개 변수 및 리턴 값을 포함하여 공개적으로 액세스 가능한 각 메소드 또는 서브 루틴 사용</target>
        </trans-unit>
        <trans-unit id="74536623687a73612b6c9ed701fc462121dc7d7c" translate="yes" xml:space="preserve">
          <source>Use of each() on hash after insertion without resetting hash iterator results in undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4576ebd26dc37f362b412c956b1df320b83b3af" translate="yes" xml:space="preserve">
          <source>Use of epoch seconds</source>
          <target state="translated">에포크 초 사용</target>
        </trans-unit>
        <trans-unit id="89f0d1e04a6d485fb8a42962bb065aa11137cb06" translate="yes" xml:space="preserve">
          <source>Use of freed value in iteration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10577790a7e390e15c7076444b50c596890af4f3" translate="yes" xml:space="preserve">
          <source>Use of inherited AUTOLOAD for non-method %s::%s() is no longer allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1731aaf31968c5fdd9480f64d745beb19858cc51" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt; . In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="translated">간격 타이머를 사용하면 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;usleep()&lt;/code&gt; 방해 할 수 있습니다 . 표준 적으로 말하면 &quot;상호 작용이 지정되지 않았다&quot;는 것은</target>
        </trans-unit>
        <trans-unit id="9a36df45b998246d9d4e37166492fb54cb408d13" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;alarm()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt;. In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3805a9db13b60335dc548646c2acddd3a9ee7d48" translate="yes" xml:space="preserve">
          <source>Use of reference &quot;%s&quot; as array index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29d84c7fc62ad9de47d9754a6c77e8d33bc264" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to %s operator is not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfaec0f9336124278f7b817b28607323f021b97" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to &lt;code&gt;vec&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba1cfef52bf7da86cdcb08ec91920d8642a5df2" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to vec</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8754dd269d352f81b7e4e85b6cbc8d5f258959f" translate="yes" xml:space="preserve">
          <source>Use of strings with code points over 0xFF as arguments to vec is forbidden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb325453470b7ad07e18ee5e7b6fc85e5f7e98d0" translate="yes" xml:space="preserve">
          <source>Use of tainted arguments in %s is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5e7b759fe4fca36b18414600475c4a0965fdc9" translate="yes" xml:space="preserve">
          <source>Use of the &quot;Is&quot; Prefix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97acda1f5bdbca48a63d3dc657d3e8cb8a0224c" translate="yes" xml:space="preserve">
          <source>Use of the &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt; module is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ae8dc20ee7df48e5cc5d87f830521771a4c91c" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a808d3a7e8e48ea8bc89247be3129db920de8bf" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="translated">의 사용 &lt;code&gt;normalization&lt;/code&gt; 매개 변수는 필요 &lt;b&gt;유니 코드 : 표준화 된&lt;/b&gt; 모듈을합니다 ( &lt;a href=&quot;normalize&quot;&gt;유니 코드 : 표준화를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="64a7870ec498fba32689c035536b6cc73bacdad6" translate="yes" xml:space="preserve">
          <source>Use of the non-greedy modifier &lt;code&gt;&quot;?&quot;&lt;/code&gt; may not give you the expected results if it is within a capturing group within the construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0889f1efa2b019bc209b7679925ab3d28d4ef3fb" translate="yes" xml:space="preserve">
          <source>Use of this function is deprecated. It is equivalent with $ENV{PROCESSOR_ARCHITECTURE}. This might not work on Win9X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f32a60715fd5465681f84312a8ca313ee4ea13" translate="yes" xml:space="preserve">
          <source>Use of this variable will be a fatal error in Perl 5.30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e43122047a54a500c46cfca5d821a3b00fe4e2" translate="yes" xml:space="preserve">
          <source>Use of unassigned code point or non-standalone grapheme for a delimiter is not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d0d39a177af319c88c58039c6648bd0013da8c" translate="yes" xml:space="preserve">
          <source>Use of unassigned code point or non-standalone grapheme for a delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4a73f904c498fbe69f531f41a3817c889f80b4" translate="yes" xml:space="preserve">
          <source>Use of uninitialized value%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f49c2ebf95d755e5a6d2e5df09c73558f210f71" translate="yes" xml:space="preserve">
          <source>Use one of</source>
          <target state="translated">다음 중 하나를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="5c06bf7bc66bd95d8dadea94a66d540da42d6175" translate="yes" xml:space="preserve">
          <source>Use one of the RPC modules( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</source>
          <target state="translated">RPC 모듈 중 하나를 사용하십시오 ( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e43df0045591deb1920c698e1e06d9540206f44c" translate="yes" xml:space="preserve">
          <source>Use only modes 'rb' or 'wb' or /wb[1-9]/.</source>
          <target state="translated">'rb'또는 'wb'또는 / wb [1-9] / 모드 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="852a3fb75c58ea9ab6aee1d984501d31575dbe43" translate="yes" xml:space="preserve">
          <source>Use or avoid POSIX locales for built-in operations</source>
          <target state="translated">내장 조작에 POSIX 로케일 사용 또는 회피</target>
        </trans-unit>
        <trans-unit id="42549f09d2d3209d758990ebfc780be7cd9d6789" translate="yes" xml:space="preserve">
          <source>Use references as hash keys</source>
          <target state="translated">참조를 해시 키로 사용</target>
        </trans-unit>
        <trans-unit id="f9644a66bc0fc21fd3bf748f9ecc3ae4860c12aa" translate="yes" xml:space="preserve">
          <source>Use spaces for indentation, not tab characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24db154be0d68fd92b28271f4ccc60a8152b9d53" translate="yes" xml:space="preserve">
          <source>Use subroutine address instead of name when reporting.</source>
          <target state="translated">보고시 이름 대신 서브 루틴 주소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e65336030d621ad236216bbd262ac0c17be3ed80" translate="yes" xml:space="preserve">
          <source>Use tabs for each 8 columns of indent. The default is to use only spaces. For instance, if the style options are &lt;b&gt;-si4T&lt;/b&gt;, a line that's indented 3 times will be preceded by one tab and four spaces; if the options were &lt;b&gt;-si8T&lt;/b&gt;, the same line would be preceded by three tabs.</source>
          <target state="translated">들여 쓰기 열 8 개마다 탭을 사용하십시오. 기본값은 공백 만 사용하는 것입니다. 예를 들어, 스타일 옵션이 &lt;b&gt;-si4T&lt;/b&gt; 인 경우 세 번 들여 쓰기 된 행 앞에는 하나의 탭과 네 개의 공백이 있습니다. 옵션이 &lt;b&gt;-si8T&lt;/b&gt; 이면 동일한 행 앞에 세 개의 탭 &lt;b&gt;이옵니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="900e9cc0a9414f47ad3c3cf6cec86c687d5c9a3b" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="translated">&lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 문서화 된 &amp;lt;&amp;gt; ( &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; ) 연산자를 사용하십시오 . 5.6 이전의 Perl 버전에서는 물결표를 움켜 쥐는 쉘이 설치되어 있어야합니다. 최신 버전의 Perl에는이 기능이 내장되어 있습니다. CPAN에서 제공 하는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File :: KGlob&lt;/a&gt; 모듈은보다 편리한 glob 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef1e23d9fb4dd0e9ea38e4518e9591d60f56c77c" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;glob()&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5399c28d11debe8de46b2d5e2d58b2ab28722c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effb03bd829df4c475803f0a78cb260ed53ef280" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8be9c742f6803184d41f9ae31a05a0ac897f541" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8858e11145295902cfc4aa55f6e4e257bbd6ea" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Email::Stuffer&quot;&gt;Email::Stuffer&lt;/a&gt; module, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb431ef2247424046d831f2d66515a5a7c258889" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2675eaa63b6f203dbc762c633eb0b0a36528fb" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e1f2f13de1a40cd3f8f4989f2a1c9a14eedc5e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;pdl&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d15469d48b935a1500729c77a1b8e476196625" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b160440316452f340f816438a94ac57e43a80b" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을 사용하십시오 . Perl과 함께 제공되며 파일 시스템간에 실제 복사를 수행 할 수 있으며 휴대용 방식으로 마법을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e3fef79cbd4ceac4e867796d39b4567be99b7a0c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt; 모듈을 사용하십시오 . 예로서:</target>
        </trans-unit>
        <trans-unit id="d164af42cbef789ed1001f4b9517bb726a601d59" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="66505dab9f27e8ded0226b45047ac4d95ef19d93" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; modules, like so:</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;이메일 : MIME&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;이메일 : 보낸 사람을 :: 간단한&lt;/a&gt; 모듈과 같이를 :</target>
        </trans-unit>
        <trans-unit id="9cda4728e014cde6b4aa8b1e9ff60d1e00b00f30" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; 모듈을 사용하십시오 . 그것은 잘 테스트되었으며 실제 세계에서 볼 수있는 모든 괴짜 (설명 접는 공백, 인코딩, 주석 등)를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6c838954123651f7a7afc095c1c154c266d44966" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List :: Permutor&lt;/a&gt; 모듈을 사용하십시오 . 목록이 실제로 배열 인 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm :: Permute&lt;/a&gt; 모듈 (CPAN에도 해당)을 사용해보십시오 . XS 코드로 작성되었으며 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="65a351301ca14a96333147c8b3d3106e99e464c1" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;수학 :: 매트릭스&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;수학 :: MatrixReal&lt;/a&gt; (CPAN에서 구할 수) 모듈 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL의&lt;/a&gt; (CPAN에서도 가능) 확장을.</target>
        </trans-unit>
        <trans-unit id="9284406bbe8e82a3357e3616e641d1dd96c570f0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4377719087a150e546f9b7a3c98e50014f5748d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma to control the I/O layers used when reading the output of the command, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e1ce41fa321637cf3d64ebec09008a4c7342ad" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; , for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; 변수를 사용하십시오 (자세한 내용은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조). 빈 단락을 제거 하려면 &lt;code&gt;&quot;&quot;&lt;/code&gt; (예 : &lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; 는 3 개가 아닌 2 개의 단락으로 처리됨)를 제거하거나 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 을 사용하여 빈 단락을 승인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef5922afb613aad3b7939c077d2e25bb76fdb53" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt;, for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb28dd761b36a73acd489d9a060d0261a86e1b3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:encoding(...)&lt;/code&gt; layer to read from and write to filehandles using the specified encoding. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.)</source>
          <target state="translated">사용 &lt;code&gt;:encoding(...)&lt;/code&gt; 에서와 쓰기 지정된 인코딩을 사용하여 파일 핸들에게 책을 읽어 레이어를. ( &lt;a href=&quot;open&quot;&gt;열기&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1043c9bb577ccc31fca3b4929e685adcde02639a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="translated">&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 신호&lt;/a&gt; 및 Camel의 &quot;신호&quot;섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 함수를 아마도 신호 처리기와 함께 사용하십시오 . 대신 CPAN에서 사용 가능한 보다 유연한 &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys :: AlarmCall&lt;/a&gt; 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b06aec35cc8ae0b522498e65b1bb4f4583c757e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; function (see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;):</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; (참조 기능을 &lt;a href=&quot;functions/rand&quot;&gt;랜드를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="24977a0b1e006e0285b58c0302df8403248c380a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Encode&lt;/code&gt; package to try converting it. For example,</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; 패키지를 사용하여 변환하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="0dc5eef8749d48465cf33790a50fb27f748e0a9f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">대신 &lt;code&gt;SvPV_nolen&lt;/code&gt; 매크로를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="ef653b1e1ac17e7ebb2ebd7fe5cecc710ea855b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">대신 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 매크로를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="bfd1997217ebfcfd0b8127ecc2505173b83edb29" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; notation to get the character by that name for use in interpolated literals (double-quoted strings and regexes). In v5.16, there is an implicit</source>
          <target state="translated">사용 &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; 보간 리터럴 (큰 따옴표 문자열과 정규 표현식에)에 사용하는 이름으로 문자를 얻을 표기법을. v5.16에는 암시 적</target>
        </trans-unit>
        <trans-unit id="50bdc262f56d539538ccdf5dbc4b7829a0847bc1" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;alarm()&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4da56703364cf0ee0a03e41789d4d68cbdaa546" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;rand()&lt;/code&gt; function (see &lt;a href=&quot;perlfunc#rand&quot;&gt;&quot;rand&quot; in perlfunc&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d52ddc8b7977a545ad663296d7fb2fca1b0f239" translate="yes" xml:space="preserve">
          <source>Use the Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; flag to enable the gcc &lt;code&gt;-ansi
-pedantic&lt;/code&gt; flags which enforce stricter ANSI rules.</source>
          <target state="translated">보다 엄격한 ANSI 규칙을 적용 하는 gcc &lt;code&gt;-ansi -pedantic&lt;/code&gt; 플래그를 사용하려면 Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddf13da36f032e379ae4d2a3b1c1bae344b15223" translate="yes" xml:space="preserve">
          <source>Use the MY_CXT macro to access members of the &lt;code&gt;my_cxt_t&lt;/code&gt; struct. For example, if &lt;code&gt;my_cxt_t&lt;/code&gt; is</source>
          <target state="translated">의 액세스 회원들에게 MY_CXT 매크로를 사용 &lt;code&gt;my_cxt_t&lt;/code&gt; 의 구조체. 예를 들어, &lt;code&gt;my_cxt_t&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="209d781836e6b1246a37a402443979bfc102b6da" translate="yes" xml:space="preserve">
          <source>Use the alternate DATA command &quot;BDAT&quot; of the data chunking service extension defined in RFC1830 for efficiently sending large MIME messages.</source>
          <target state="translated">큰 MIME 메시지를 효율적으로 전송하려면 RFC1830에 정의 된 데이터 청킹 서비스 확장의 대체 DATA 명령 &quot;BDAT&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b568a8fe0839108748606587d3b5ef52fd93b31" translate="yes" xml:space="preserve">
          <source>Use the author's favorite set of formatting conventions. This is the default, of course.</source>
          <target state="translated">저자가 선호하는 형식 지정 규칙을 사용하십시오. 물론 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9ac34b7ac482595c74c32af79b7d65f665861078" translate="yes" xml:space="preserve">
          <source>Use the backslash ('\') character for quoting: every occurrence of a backslash followed by a character in the pattern is replaced by that character, avoiding any special interpretation of the character. (But see below for exceptions on DOSISH systems).</source>
          <target state="translated">인용에는 백 슬래시 ( '\') 문자를 사용하십시오. 백 슬래시 다음에 나타나는 문자는 패턴의 문자로 대체되며 문자의 특수 해석을 피합니다. (하지만 DOSISH 시스템의 예외는 아래를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="58c791ac75ac6f9811d7c1cd895cf02a99e988fc" translate="yes" xml:space="preserve">
          <source>Use the dMY_CXT macro (a declaration) in all the functions that access MY_CXT.</source>
          <target state="translated">MY_CXT에 액세스하는 모든 함수에서 dMY_CXT 매크로 (선언)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a11c34555178b87ed57024b7506fd7ffd640c9ab" translate="yes" xml:space="preserve">
          <source>Use the default &quot;cmd&quot; shell that comes with Windows. Some versions of the popular 4DOS/NT shell have incompatibilities that may cause you trouble. If the build fails under that shell, try building again with the cmd shell.</source>
          <target state="translated">Windows와 함께 제공되는 기본 &quot;cmd&quot;쉘을 사용하십시오. 널리 사용되는 4DOS / NT 셸의 일부 버전에는 비 호환성이있어 문제를 일으킬 수 있습니다. 해당 쉘에서 빌드가 실패하면 cmd 쉘로 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="e7eb918841419258515e4bb838ed4565f624f56c" translate="yes" xml:space="preserve">
          <source>Use the default answer for a prompted questions. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860daa28ec194a818f5b182bccd22928db406092" translate="yes" xml:space="preserve">
          <source>Use the default to produce the *.dll's. But for new archdir dll's use the same rebase address if the old exists.</source>
          <target state="translated">* .dll을 생성하려면 기본값을 사용하십시오. 그러나 새로운 archdir dll의 경우 이전 버전이 있으면 동일한 rebase 주소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e1fc4198386c0572da6a991c5d426478433e6323" translate="yes" xml:space="preserve">
          <source>Use the external tar program instead of Archive::Tar?</source>
          <target state="translated">Archive :: Tar? 대신 외부 tar 프로그램을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4bac2574d114ae82b8fd263b9459dca50bff3c24" translate="yes" xml:space="preserve">
          <source>Use the following simple functions:</source>
          <target state="translated">다음과 같은 간단한 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82c21f5742907cbf65bd7db33516fce8af244b3d" translate="yes" xml:space="preserve">
          <source>Use the force pragma like so</source>
          <target state="translated">힘 pragma를 이렇게 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d7f075c6e2b64b3ce706fb827bca3411e7b8504c" translate="yes" xml:space="preserve">
          <source>Use the key mentioned at</source>
          <target state="translated">에 언급 된 키를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="718a478ced25e8295348d28c5a0bc5741996efff" translate="yes" xml:space="preserve">
          <source>Use the libwww-perl distribution. The &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP::Simple&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="translated">libwww-perl 배포를 사용하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP :: 간단한&lt;/a&gt; 모듈은 웹 자원을 가져오고 문자열로 당신에게 자신의 콘텐츠 등을 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cb1603df2ef00841c0d9bacb479a841ff6e25e94" translate="yes" xml:space="preserve">
          <source>Use the macros STMT_START and STMT_END.</source>
          <target state="translated">STMT_START 및 STMT_END 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c888fae92abf19a81b4d142f09c5f461d8d9608c" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt; , as the warnings category.</source>
          <target state="translated">객체 참조에 대한 클래스 이름 인 &lt;code&gt;$object&lt;/code&gt; 를 경고 범주로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8491a8784c79488d26c7a0776126752e369c73a7" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt;, as the warnings category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b334d1699fa8ac1b699ca7fe59817de25916cf" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators to avoid having to parenthesize list operators so much, and to reduce the incidence of punctuation operators like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. Call your subroutines as if they were functions or list operators to avoid excessive ampersands and parentheses.</source>
          <target state="translated">리스트 연산자를 괄호로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 문장 부호 연산자의 발생률을 줄이려면 new &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 연산자를 사용하십시오. . 앰퍼샌드 및 괄호를 과도하게 피하기 위해 서브 루틴을 함수 또는리스트 연산자처럼 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="442188b51b5e18cf49fd3890247d5179d50e4049" translate="yes" xml:space="preserve">
          <source>Use the object-oriented interface if fine-grained control of when a file is removed is required.</source>
          <target state="translated">파일 제거시기를 세밀하게 제어해야하는 경우 객체 지향 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79265afb000f4991752261ca28217b5c373e53aa" translate="yes" xml:space="preserve">
          <source>Use the perlrebase or rebase utilities to resolve the conflicting dll addresses. The rebase package is included in the Cygwin setup. Use</source>
          <target state="translated">perlrebase 또는 rebase 유틸리티를 사용하여 충돌하는 dll 주소를 해결하십시오. Rebase 패키지는 Cygwin 설정에 포함되어 있습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="406dad7fa9a9b85a63a25268f65100875c7b49a3" translate="yes" xml:space="preserve">
          <source>Use the prototyped versions (see above) for a more generic alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62599a293da2f7d3226d049d02a58beb44cfc269" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; to call &lt;code&gt;wait()&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3F&quot;&gt;&quot;How do I start a process in the background?&quot; in perlfaq8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0801908980e9c580009d45c4098d1486f12c00b2" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; to call &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;How do I start a process in the background? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">SIGCHLD가 수신 될 때 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt; 에있는 신호의 리퍼 코드를 사용하여 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출 하거나 &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;백그라운드에서 프로세스를 시작하는 방법에&lt;/a&gt; 설명 된 이중 포크 기술을 사용하십시오 . perlfaq8에서 .</target>
        </trans-unit>
        <trans-unit id="4ab1865ade7c5cbdf616d9cfa7bc296cc942c842" translate="yes" xml:space="preserve">
          <source>Use the split function:</source>
          <target state="translated">split 기능을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="a9b5bca0abebc1d76df512275844e6baf7fca732" translate="yes" xml:space="preserve">
          <source>Use the three-argument form to open a file with arbitrary weird characters in it,</source>
          <target state="translated">임의의 이상한 문자가 포함 된 파일을 열려면 세 개의 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e2045ea69cf09267eda92b39d5360c52617d312" translate="yes" xml:space="preserve">
          <source>Use the warnings category with the same name as the current package.</source>
          <target state="translated">현재 패키지와 이름이 같은 경고 범주를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0293445fabb340233713c8257ab81530a2889bf1" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; . They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 대신 이들을 사용하십시오 . 변수가 아닌 &quot;함수 호출&quot;처럼 보이도록 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="78393279cde85921d8f8c6fd4c6e8e7d77ff04aa" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt;. They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81fa8275577903400d658f76e856afcaee1f2f2" translate="yes" xml:space="preserve">
          <source>Use these very, very, very sparingly.</source>
          <target state="translated">매우 아껴서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87ebb269f56a9a915023b69eabf6ff027e2f7e0c" translate="yes" xml:space="preserve">
          <source>Use this code, provided by Mark-Jason Dominus:</source>
          <target state="translated">Mark-Jason Dominus가 제공 한이 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="077f386270655a39a44d9dc249821c4b0ca20a1d" translate="yes" xml:space="preserve">
          <source>Use this if you need to write your own tool that wraps a call to &lt;code&gt;context()&lt;/code&gt; with the intent that it should return a context object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a99888f271041405f93aa8e81d9f5a2d2c20746" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl to work with modules. It will add things like -I$(INST_ARCH) and other necessary flags so perl can see the modules you're about to install.</source>
          <target state="translated">모듈 작업을 위해 perl을 실행하려면 $ (PERL) 대신 이것을 사용하십시오. -I $ (INST_ARCH) 및 기타 필요한 플래그를 추가하여 perl이 설치하려는 모듈을 볼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="388121ab9a82a1ad19377b89ac9de297ea8e7f2c" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl. It will set up extra necessary flags for you.</source>
          <target state="translated">perl을 실행하려면 $ (PERL) 대신 이것을 사용하십시오. 필요한 추가 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e6433f54cefa63ecf9e10e3ca3a566ca9eb8f9de" translate="yes" xml:space="preserve">
          <source>Use this instead:</source>
          <target state="translated">대신 이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="9482ca604a352c4ff781a10e825ea8768f370ffb" translate="yes" xml:space="preserve">
          <source>Use this module like this:</source>
          <target state="translated">이 모듈을 다음과 같이 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="97690b2f31ef7f268036c43fc7989b79968edf4d" translate="yes" xml:space="preserve">
          <source>Use this parameter if you want to obtain the context for a specific hub instead of whatever one happens to be at the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd556107fd0fb942951a496b76d8c5f95f2102d6" translate="yes" xml:space="preserve">
          <source>Use this to add behaviors that are called just before the hub is finalized. The only argument to your codeblock will be a &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fd134a2b3d96c5cbea104957e21046321bc6c3" translate="yes" xml:space="preserve">
          <source>Use this to build perl outside of the source tree. Details can be found in the</source>
          <target state="translated">이것을 사용하여 소스 트리 외부에 perl을 빌드하십시오. 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="163162b126000a656e356ab3254dffb8d7962901" translate="yes" xml:space="preserve">
          <source>Use this to disassociate a file from a PerlIO * that was associated using PerlIO_exportFILE().</source>
          <target state="translated">이를 사용하여 PerlIO_exportFILE ()을 사용하여 연관된 PerlIO *에서 파일을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="307626673e0bd7f8495318897a6981cd297178f1" translate="yes" xml:space="preserve">
          <source>Use to turn numbers on and off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03038b4251119aa1c25d1f79aa4a7d76f09e6350" translate="yes" xml:space="preserve">
          <source>Use tree connecting characters drawn from the VT100 line-drawing set. This looks better if your terminal supports it.</source>
          <target state="translated">VT100 라인 드로잉 세트에서 그린 트리 연결 문자를 사용하십시오. 터미널이 지원하면 더 좋아 보인다.</target>
        </trans-unit>
        <trans-unit id="5b877243c67d7922e8d87750811b66b31f1b397f" translate="yes" xml:space="preserve">
          <source>Use underscores to separate words. It is generally easier to read $var_names_like_this than $VarNamesLikeThis, especially for non-native speakers of English. It's also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.</source>
          <target state="translated">밑줄을 사용하여 단어를 구분하십시오. 일반적으로 영어가 모국어가 아닌 사용자의 경우 $ VarNamesLikeThis보다 $ var_names_like_this를 읽는 것이 일반적으로 더 쉽습니다. VAR_NAMES_LIKE_THIS와 일관되게 작동하는 간단한 규칙이기도합니다.</target>
        </trans-unit>
        <trans-unit id="a9f6d10a6d2104b7922abf95412d3e52031b3d8b" translate="yes" xml:space="preserve">
          <source>Use unrelated features (this will flush out bizarre interactions).</source>
          <target state="translated">관련없는 기능을 사용하십시오 (기괴한 상호 작용을 제거합니다).</target>
        </trans-unit>
        <trans-unit id="94264aa782503bfc93a9d2198fe0a7492052ef22" translate="yes" xml:space="preserve">
          <source>Use with older Unicode versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4735554e1398f969b06e194368a7ba44c81db126" translate="yes" xml:space="preserve">
          <source>Used as a custom trace message that will be used INSTEAD of &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; when calling &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b5116cfec58023d905fc9d5b3040b726593cef" translate="yes" xml:space="preserve">
          <source>Used as a noun in this case, this refers to a known way to compromise a program to get it to do something the author didn&amp;rsquo;t intend. Your task is to write unexploitable programs.</source>
          <target state="translated">이 경우 명사로 사용되는이 기능은 저작자가 의도하지 않은 작업을 수행하기 위해 프로그램을 손상시키는 알려진 방법을 나타냅니다. 당신의 임무는 악용 할 수없는 프로그램을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79c6d27106d07e0f5897103d8c6a8d8a85ec8bb1" translate="yes" xml:space="preserve">
          <source>Used as a noun, a name in a &lt;b&gt;directory&lt;/b&gt; that represents a &lt;b&gt;file&lt;/b&gt;. A given file can have multiple links to it. It&amp;rsquo;s like having the same phone number listed in the phone directory under different names. As a verb, to resolve a partially &lt;b&gt;compiled&lt;/b&gt; file&amp;rsquo;s unresolved symbols into a (nearly) executable image. Linking can generally be static or dynamic, which has nothing to do with static or dynamic scoping.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 을 나타내는 &lt;b&gt;디렉토리&lt;/b&gt; 의 이름 인 명사로 사용됩니다 . 주어진 파일에는 여러 개의 링크가있을 수 있습니다. 전화 번호부에 동일한 이름의 전화 번호가 같은 것과 같습니다. 동사로, 부분적으로 &lt;b&gt;컴파일 된&lt;/b&gt; 파일의 해석 되지 않은 기호를 (거의) 실행 가능 이미지 로 해석합니다 . 링크는 일반적으로 정적 또는 동적 일 수 있으며 정적 또는 동적 범위 지정과 관련이 없습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="156b1ffab2a8f1b730df4187d04674edf41a68c8" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e94bf506fd2ed1897d55415e2eda38e61b816ec" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">lvalue로 사용되는 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 사용하면 지정된 해시에 할당 된 해시 버킷 수를 늘릴 수 있습니다. 해시가 커질 것임을 알면 효율성을 측정 할 수 있습니다. (이것은 $ # array에 더 큰 숫자를 할당하여 배열을 미리 확장하는 것과 비슷합니다.)</target>
        </trans-unit>
        <trans-unit id="cfcd9d6e7d0af6a973640e08731f7579c85d2ca6" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">lvalue로 사용되는 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 사용하면 지정된 해시에 할당 된 해시 버킷 수를 늘릴 수 있습니다. 해시가 커질 것임을 알면 효율성을 측정 할 수 있습니다. (이것은 $ # array에 더 큰 숫자를 할당하여 배열을 미리 확장하는 것과 비슷합니다.)</target>
        </trans-unit>
        <trans-unit id="9d927fa8ae51a19f16800a69ce9d19da2c120815" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드가 생성 될 때 (이 경우 param이 NULL이 아님) 스트림이 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서 '&amp;amp;'를 통해 복제 될 때 &quot;복제&quot;프로세스의 일부로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="60459c86df13f14efd5dda77730301e787cdfe33" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251c18a90eefe3a719259f59bb8700c29e6c2e54" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0413527e465c4de8a077bbf425ed66e91381919a" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="976bda008ac56ae36683d29627c3f35a11dab1ca" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS=perl.</source>
          <target state="translated">INSTALLDIRS = perl 인 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37d1058a6b6ba0e70de245f908c09c85ed3a873d" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">INSTALLDIRS가 perl로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8402b50cbc218eeff1f81c3db2cda9adf3fffbd7" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c4c8328bf8916ab5fdd86eb62de06cc4f4230a70" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6ce5a40c4c3e0c16a95489eab9cd3e9eb723f24b" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor. Note that if you do not set this, the value of INSTALLVENDORLIB will be used, which is probably not what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0cddfea5d7479fbfb7a215e845b5a123be89bb" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_BIN에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eb49c11648bc66ca1d5846b99271ffd0d898ea32" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_BIN에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2b07ebb6cc38d7286ba9e956f3eba69a5ff528fe" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">INSTALLDIRS가 perl로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4c572796939181da5eba99b899ab05bfaac9e449" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="497f3b2bdeaf3749352a862b66d7233b6bb7365e" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="955b442432c35e6b42d1db59049e0e27c3353bce" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에서 XSUB를 Perl 하위로 연결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2c2e15661d8694f28fe98eab4f73a7c1f9a721" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. &lt;code&gt;filename&lt;/code&gt; needs to be static storage, as it is used directly as CvFILE(), without a copy being made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b701e8ad52984344882bfc710f4e3b41bfee3ae7" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. Adds Perl prototypes to the subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에서 XSUB를 Perl 하위로 연결하는 데 사용됩니다 . 서브에 Perl 프로토 타입을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bf413f31411cb5187dfc08c3a35d494612fab477" translate="yes" xml:space="preserve">
          <source>Used by Unicode internally for generating other properties and not intended to be used stand-alone</source>
          <target state="translated">다른 속성을 생성하기 위해 내부적으로 유니 코드에서 사용되며 독립형으로 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4e698d59aaba8e3ee1c30011c41b0b74d5937cc8" translate="yes" xml:space="preserve">
          <source>Used by a &lt;b&gt;standard I/O&lt;/b&gt; output stream that flushes its &lt;b&gt;buffer&lt;/b&gt; after every &lt;b&gt;newline&lt;/b&gt;. Many standard I/O libraries automatically set up line buffering on output that is going to the terminal.</source>
          <target state="translated">모든 &lt;b&gt;개행&lt;/b&gt; 후에 &lt;b&gt;버퍼&lt;/b&gt; 를 플러시 하는 &lt;b&gt;표준 I / O&lt;/b&gt; 출력 스트림에 의해 사용됩니다 . 많은 표준 I / O 라이브러리는 터미널로가는 출력에서 ​​라인 버퍼링을 자동으로 설정합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e00976e80fe78228b9297b3ddbd122a14f1abe1f" translate="yes" xml:space="preserve">
          <source>Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.</source>
          <target state="translated">일부 OS에서 DL_FUNCS 및 DL_VARS를 정의하고 * .exp 파일을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b189d5874fa8033758f781e723e54b376d23c484" translate="yes" xml:space="preserve">
          <source>Used by the &lt;code&gt;IS_SAFE_SYSCALL()&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba26d0698fc6f53589c3fcda2fd4a8860e0e9f9" translate="yes" xml:space="preserve">
          <source>Used by the IS_SAFE_SYSCALL() macro.</source>
          <target state="translated">IS_SAFE_SYSCALL () 매크로에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c2253cb286405345c16b81c3000c80dff0161abd" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; ), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="translated">검색 및 바꾸기 패턴을 관리하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; 등 의 텍스트를 제공하기 위해 실행 단계에서 사용됩니다 . &lt;code&gt;subbeg&lt;/code&gt; 는 버퍼 (원래 문자열 또는 &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; 의 경우 사본 ) 및 &lt;code&gt;sublen&lt;/code&gt; 을 가리 킵니다. 버퍼의 길이입니다. &lt;code&gt;RX_OFFS&lt;/code&gt; 는 시작과 끝이 버퍼 인덱스와 indices.</target>
        </trans-unit>
        <trans-unit id="651551117825faea8d09d9baa6928cc7c2bfd137" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt;), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11724fb66b5b88866c9924f1327c02f9213cd90" translate="yes" xml:space="preserve">
          <source>Used for asynchronous IO in Win32 to get the result of a pending IO operation, such as when a file operation returns &lt;code&gt;ERROR_IO_PENDING&lt;/code&gt;. Returns a false value on failure. The &lt;code&gt;$overlapped&lt;/code&gt; structure and &lt;code&gt;$numBytesTransferred&lt;/code&gt; will be modified with the results of the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07d1ff394d728bbcdaa2001c2857f1cf7faa30d" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) and parameters (&quot;&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)</source>
          <target state="translated">강조 ( &quot; &lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) 및 매개 변수 ( &quot; &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)에 사용</target>
        </trans-unit>
        <trans-unit id="79101ddce726e177f648ccb97fafe6e35ba41948" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt;&quot;) and parameters (&quot;&lt;code&gt;redo I&amp;lt;LABEL&amp;gt;&lt;/code&gt;&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3c574527f056e37525c76d104fc8a22ad9cc2b" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt; 's &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="translated">최적화에 사용됩니다. &lt;code&gt;precomp&lt;/code&gt; 는 컴파일 된 패턴의 사본을 보유 하고 길이를 &lt;code&gt;prelen&lt;/code&gt; 합니다. 루프 내부와 같은 새로운 패턴이 컴파일 될 때 내부 &lt;code&gt;regcomp&lt;/code&gt; 연산자는 마지막으로 컴파일 된 &lt;code&gt;REGEXP&lt;/code&gt; 의 &lt;code&gt;precomp&lt;/code&gt; 및 &lt;code&gt;prelen&lt;/code&gt; 이 새로운 패턴과 동일한 지 확인하고, 새로운 패턴을 컴파일하는 대신 이전 패턴을 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="865769afa1ae4a2862cdd9a060f4d353ff5ed9bc" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt;'s &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16a1dda4419ca1fa42a25c2f463240abdf22010" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;).</source>
          <target state="translated">스위치 ( &quot; &lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), 프로그램 ( &quot; &lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;에 대해 B &amp;lt;chfn&amp;gt;을 제공함 ), 강조 ( &quot; &lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) 등에 사용됩니다 ( &quot; &lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;)라고합니다.</target>
        </trans-unit>
        <trans-unit id="df0534ab5cb2156a670b02757216f26561c5b81d" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt;&quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt;&quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt;&quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt;&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d00f06e1f81e3c4218071563a3bababae3c7eab" translate="yes" xml:space="preserve">
          <source>Used for test.pl, since they don't always follow Test::Harness formatting.</source>
          <target state="translated">항상 Test :: Harness 형식을 따르지 않으므로 test.pl에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85f7caced82a8f0a4057356aaa1e87b6b4b7ead3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument and HOME is not set.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 에 인수가없고 HOME이 설정되지 않은 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5442b49ecc1bae306f70b5a25e1762fda194c70" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 에 인수가없는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d410f6de438cbb26b911cf2f15b03b4afc869a3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;chdir&lt;/code&gt; has no argument and &lt;a href=&quot;#HOME&quot;&gt;&quot;HOME&quot;&lt;/a&gt; is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e2be660d398830c6421721e5380bb05f4d11e3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;chdir&lt;/code&gt; has no argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b449b1e6003f0a47a3ac7a7f3e867aa4d2d04e46" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and &lt;a href=&quot;#HOME&quot;&gt;&quot;HOME&quot;&lt;/a&gt; and &lt;a href=&quot;#LOGDIR&quot;&gt;&quot;LOGDIR&quot;&lt;/a&gt; are not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5908b09f62d202af9a5d54ac62b509abf705e1f4" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and HOME and LOGDIR are not set.</source>
          <target state="translated">chdir에 인수가없고 HOME 및 LOGDIR이 설정되지 않은 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b97a5382104ef747655a54d5cf00ae2ece3ac3e" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 옵션 과 함께 사용 하여 테스트 프로그램에 전달할 인수 의 &lt;code&gt;@ARGV&lt;/code&gt; 스타일 배열에 대한 참조를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a38191bc46f4249b043c38ac454629a53d827f" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b4f9fcc830680942e63427a2c44eed84c782ab" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;&quot;strcoll&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477606f47e75aab0d16ae4c72010e54847d20bed" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;.</source>
          <target state="translated">와 함께 사용 &lt;code&gt;strcoll()&lt;/code&gt; 함수를 참조 &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a75b2e9b8ac8650e725e7c98fe7339411bb3bfc" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;a href=&quot;#-S&quot;&gt;&quot;-S&quot;&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0096c9408c39e5114a134ce424b3de68995688e0" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;b&gt;-S&lt;/b&gt; is used.</source>
          <target state="translated">&lt;b&gt;-S&lt;/b&gt; 가 사용 되는지 서브 프로세스를 실행하고 프로그램을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba44e70b36f71f9050217be51cd85d85bdb4c810" translate="yes" xml:space="preserve">
          <source>Used internally to perform logging; imported from Log::Contextual if Log::Contextual has already been loaded, otherwise simply calls warn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7e238a8b39d615018cf421f51aee97a59ca55c" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="translated">숫자로 사용되는 비트 연산자 ( &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; )는 항상 완전한 결과를 생성합니다. (그러나 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 단위 문자열 연산자&lt;/a&gt; 도 참조하십시오 .) 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 은 여전히 ​​의미가 있습니다. 기본적으로 결과는 부호없는 정수로 해석되지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우 결과는 부호있는 정수로 해석됩니다. 예를 들어 &lt;code&gt;~0&lt;/code&gt; 일반적으로 큰 정수 값으로 평가됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . 2의 보수 기계에서 ~ 0 은 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17440f7ceac2f06faa3db667512e4a58e695c9fb" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.) However, &lt;code&gt;use integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;use integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;use integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f1fcd6bfd2f48fba3948a9e62685e57c7db9d1" translate="yes" xml:space="preserve">
          <source>Used on the t/*.t files.</source>
          <target state="translated">t / *. t 파일에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a64dabf0b28b220a6076bc6a581b9356f3e76610" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_ARCHLIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">MakeMaker가 Perl 코어 배포의 확장을 빌드 할 때만 사용됩니다 (일반적으로 $ (PERL_ARCHLIB)는 @INC에 자동으로 추가되고 PERL5LIB를 방해하기 때문에).</target>
        </trans-unit>
        <trans-unit id="522904b951ae26afa223c455d7c6bd2555ea2781" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_LIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">MakeMaker가 Perl 코어 배포의 확장을 빌드 할 때만 사용됩니다 (일반적으로 $ (PERL_LIB)는 @INC에 자동으로 추가되고 PERL5LIB를 방해하기 때문에).</target>
        </trans-unit>
        <trans-unit id="f0b6e6daa054441299880d327c03ad5022b9eb54" translate="yes" xml:space="preserve">
          <source>Used to access elements on the XSUB's stack.</source>
          <target state="translated">XSUB의 스택에있는 요소에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e35e54c290e520db893e920267b9220db378f0a1" translate="yes" xml:space="preserve">
          <source>Used to check if any errata was seen.</source>
          <target state="translated">정오표가 보이는지 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87a9aa1ba364ad0831ad8d0593884f266cd7c93e" translate="yes" xml:space="preserve">
          <source>Used to choose the LZMA compression preset.</source>
          <target state="translated">LZMA 압축 사전 설정을 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95a475746591bd4adeab810bf6982b243a52a9b8" translate="yes" xml:space="preserve">
          <source>Used to collect events that have been sent to the specified hub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c52aa40f13bb513d24fe0ba0fa19d6fcc4a443a" translate="yes" xml:space="preserve">
          <source>Used to compare numbers.</source>
          <target state="translated">숫자를 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c48ef407eccd138f057ccc3292baa7a78dede864" translate="yes" xml:space="preserve">
          <source>Used to describe a &lt;b&gt;referent&lt;/b&gt; that is not directly accessible through a named &lt;b&gt;variable&lt;/b&gt;. Such a referent must be indirectly accessible through at least one &lt;b&gt;hard reference&lt;/b&gt;. When the last hard reference goes away, the anonymous referent is destroyed without pity.</source>
          <target state="translated">명명 된 &lt;b&gt;변수를&lt;/b&gt; 통해 직접 액세스 할 수없는 &lt;b&gt;참조&lt;/b&gt; 를 설명하는 데 사용됩니다 . 이러한 참조는 적어도 하나의 &lt;b&gt;하드 참조를&lt;/b&gt; 통해 간접적으로 액세스 가능해야합니다 . 마지막 하드 레퍼런스가 사라지면 익명의 리퍼 럴은 동정없이 파괴됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68eae2d00f0bb0e45444425d5ef88e0a25c713c4" translate="yes" xml:space="preserve">
          <source>Used to extend the argument stack for an XSUB's return values. Once used, guarantees that there is room for at least &lt;code&gt;nitems&lt;/code&gt; to be pushed onto the stack.</source>
          <target state="translated">XSUB의 반환 값에 대한 인수 스택을 확장하는 데 사용됩니다. 일단 사용되면 스택 에 최소한의 &lt;code&gt;nitems&lt;/code&gt; 를 넣을 수있는 공간이 확보됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9d6ff55b3e514bbe849f67e44d09a8a1f610db4" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백 주위에 Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 래퍼 를 강제하는 데 사용됩니다 . &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a32052445fd30952e9db91bbfd242c9623786635" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;eval&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de62f27495e3f33e099616750808f449be5f2cfc" translate="yes" xml:space="preserve">
          <source>Used to get a PerlIO * from a FILE *.</source>
          <target state="translated">FILE *에서 PerlIO *를 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7db1f3e9a417bfe913cd54ab43ac2c865165aafc" translate="yes" xml:space="preserve">
          <source>Used to get/set a custom trace message that will be used INSTEAD of &lt;code&gt;at &amp;lt;FILE&amp;gt; line &amp;lt;LINE&amp;gt;&lt;/code&gt; when calling &lt;code&gt;$trace-&amp;gt;debug&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea613d2ba362c35f2ce83afc90e661e1230c489c" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f86f7323575cf5c768f8e5109eb6cf3318d1d9" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">목록 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2cec7805880b122f75804dfbb39c718dc242d42" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#GIMME&quot;&gt;&quot;GIMME&quot;&lt;/a&gt;&lt;/code&gt;, and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a930c77deebf229f4a954c4d6804d1b626a7c0da" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; , and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">스칼라 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bf05fcf106f8a5c8937c4b2441e36694da0a3cf" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;&lt;a href=&quot;#GIMME_V&quot;&gt;&quot;GIMME_V&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d42cedd073f96c9a77c4270da2ab3e95ee0de9" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;GIMME_V&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">무효 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bb1d0a62eb268dccff9ee670a0b1ed19d224173" translate="yes" xml:space="preserve">
          <source>Used to negate the object in-place.</source>
          <target state="translated">개체를 제자리에서 무효화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab9fb9e2f57ebf6032a373e79745b71c5c594eb" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV.</source>
          <target state="translated">SV에 대한 참조를 전달하고 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02c1be0e858c6b96b18473855240486ec63fb69b" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV. This is a fixed variant of T_SVREF that decrements the refcount appropriately when returning a reference to an SV*. Introduced in perl 5.15.4.</source>
          <target state="translated">SV에 대한 참조를 전달하고 반환하는 데 사용됩니다. 이것은 SV *에 대한 참조를 반환 할 때 참조 횟수를 적절하게 감소시키는 T_SVREF의 고정 변형입니다. perl 5.15.4에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6329119f5669ee995c8c52570e1c5977a8800ad7" translate="yes" xml:space="preserve">
          <source>Used to send events from the current process/thread to the specified hub in its process+thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91a5082aa2e7c4d29d7e1b996780ca43a12407b" translate="yes" xml:space="preserve">
          <source>Used to shift numbers left/right.</source>
          <target state="translated">숫자를 왼쪽 / 오른쪽으로 이동하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68e033a11c06f9ce51ea9813275c9343d35e3bef" translate="yes" xml:space="preserve">
          <source>Used to signal that a phase change has occurred. Currently only the perl END phase is signaled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8dbe24f6294c1f64efbbb4b95eb12824022d6a" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;&lt;a href=&quot;#svtype&quot;&gt;&quot;svtype&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb258f4b48416c1a5909b948e6f301fdab02b0" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">SV를보다 복잡한 형태로 업그레이드하는 데 사용됩니다. 용도는 &lt;code&gt;sv_upgrade&lt;/code&gt; 필요한 경우 업그레이드를 수행 할 수 있습니다. 보다 &lt;code&gt;svtype&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fcb5d7f5c46a099246ea8a6f9905effe5c22e13c" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &quot;.&quot; match any character whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after and just before newlines within the string.</source>
          <target state="translated">같이 사용 &lt;code&gt;/ms&lt;/code&gt; 하면 &quot;.&quot; 문자열 내에서 개행 직전과 직후에 각각 &quot;^&quot;및 &quot;$&quot;가 일치하도록 허용하면서 모든 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a984f0517a02a95514aa7849e322ad2bba528af2" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &lt;code&gt;&quot;.&quot;&lt;/code&gt; match any character whatsoever, while still allowing &lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt; to match, respectively, just after and just before newlines within the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa27f5c1082734ec40392b2d9f3d19afd0775e2" translate="yes" xml:space="preserve">
          <source>Used when creating PPD files for binary packages. It can be set to a full or relative path or URL to the binary archive for a particular architecture. For example:</source>
          <target state="translated">이진 패키지에 대한 PPD 파일을 만들 때 사용됩니다. 특정 아키텍처의 바이너리 아카이브에 대한 전체 또는 상대 경로 또는 URL로 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0efa982fe3c01dc21ffac634d0623c22f8078dad" translate="yes" xml:space="preserve">
          <source>Used when the layer's open() accepts more arguments than usual. The extra arguments should come not before the &lt;code&gt;MODE&lt;/code&gt; argument. When this flag is used it's up to the layer to validate the args.</source>
          <target state="translated">레이어의 open ()이 평소보다 더 많은 인수를 허용 할 때 사용됩니다. 추가 인수는 &lt;code&gt;MODE&lt;/code&gt; 앞에 와서는 안됩니다 인수 . 이 플래그를 사용하면 args의 유효성을 검사하는 것은 레이어에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd67bcd97e446b57807bc47ce4d7da189f0ad26" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; (or &lt;code&gt;@$libfiles&lt;/code&gt; ) would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; , in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="translated">위의 예제와 함께 사용하면 &lt;code&gt;@libfiles&lt;/code&gt; (또는 &lt;code&gt;@$libfiles&lt;/code&gt; )에는 완료시 &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; 라는 두 개의 문자열이 포함됩니다. 이 순서대로 포함됩니다. 정수 또는 부동 소수점 숫자 만 허용되는 값으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="686b0cfb7edf72aaa48c42035c97b73729e54164" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; c.q. &lt;code&gt;@$libfiles&lt;/code&gt; would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt;, in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d539b8e87e848f4ea03e572c54286711be989ac8" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; reverses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32482e797407c687053869f8a4e7d0cfe24ca4f2" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, reverse() reverses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 인수없이 사용되는 reverse ()는 &lt;code&gt;$_&lt;/code&gt; 반대로 합니다.</target>
        </trans-unit>
        <trans-unit id="287fb92f0982907aa797c3b17e0824ad256b9b20" translate="yes" xml:space="preserve">
          <source>Useful functions for dealing with the filehandle and filename.</source>
          <target state="translated">파일 핸들 및 파일 이름을 처리하는 데 유용한 기능.</target>
        </trans-unit>
        <trans-unit id="f0b64588f00eed76bae59e12d25ea5d5e9aeab35" translate="yes" xml:space="preserve">
          <source>Useful modules to help you write tests (with minimum impact on your development process or your time) include Test::Simple, Carp::Assert and Test::Inline. For more sophisticated test suites there are Test::More and Test::MockObject.</source>
          <target state="translated">테스트 작성에 도움이되는 유용한 모듈 (개발 프로세스 또는 시간에 미치는 영향을 최소화)에는 Test :: Simple, Carp :: Assert 및 Test :: Inline이 있습니다. 보다 복잡한 테스트 스위트에는 Test :: More 및 Test :: MockObject가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04355f5678f3ad8646b491395f68bd676dba02d6" translate="yes" xml:space="preserve">
          <source>Useful options of</source>
          <target state="translated">유용한 옵션</target>
        </trans-unit>
        <trans-unit id="7705a5ed12704795a74e0deb45a6e2191d0de39a" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="translated">유용 값 &lt;code&gt;PERLDOC&lt;/code&gt; 포함 &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , 등등, 당신은 손에있는 모듈 내용에 따라; 또는 &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; 하여 포맷터 클래스를 정확하게 지정할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9b8aa89e83cee5e3ca309bd98b7ad5e6d2482f28" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt;, &lt;code&gt;-otext&lt;/code&gt;, &lt;code&gt;-ortf&lt;/code&gt;, &lt;code&gt;-oxml&lt;/code&gt;, and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108f6902446d675962ade16c5ef5d6ed95723631" translate="yes" xml:space="preserve">
          <source>Useful, huh? You can eval nearly anything in there, and experiment with bits of code or regexes until the cows come home:</source>
          <target state="translated">유용한가요? 거의 모든 것을 평가하고 소가 집에 돌아올 때까지 약간의 코드 또는 정규식을 실험 해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c71dc9b541dc8018b02adecc71f98a225f3ccc06" translate="yes" xml:space="preserve">
          <source>Useless (?%s) - use /%s modifier in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6a9e2eda3ea6c7d73f3e707e7ed5269aa14f73" translate="yes" xml:space="preserve">
          <source>Useless (?-%s) - don't use /%s modifier in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1a23dd36f92ed177c1832b7b7a0a0fece7983e" translate="yes" xml:space="preserve">
          <source>Useless assignment to a temporary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17842187d2df7f0082511c734a4e6cdd38eac818" translate="yes" xml:space="preserve">
          <source>Useless localization of %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5177755cd0fdb62c51f6b4485b79f58ffe1af79" translate="yes" xml:space="preserve">
          <source>Useless use of &quot;re&quot; pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cd952a4c24e6449dea1b01472de2758d858ccc" translate="yes" xml:space="preserve">
          <source>Useless use of %s in void context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531e23c28370cd335d5e05163d10e5c756434034" translate="yes" xml:space="preserve">
          <source>Useless use of %s with no values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2f0ba2f4ce0c9566542ca020616ad5b9098770" translate="yes" xml:space="preserve">
          <source>Useless use of (?-p) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae262acf9642fbcf83b9ac3bddb3c7a0b90b3044" translate="yes" xml:space="preserve">
          <source>Useless use of /d modifier in transliteration operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f322490cc9136ca5c6162d551690ef0e5090fce7" translate="yes" xml:space="preserve">
          <source>Useless use of \E</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e9290b890dbc7ea19bb7968869cd494c601fd1" translate="yes" xml:space="preserve">
          <source>Useless use of attribute &quot;const&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6f6c2ca209d2a1356342031126536b4e4ce875" translate="yes" xml:space="preserve">
          <source>Useless use of greediness modifier '%c' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acb52c27a42a9b152f7b16b1ae62e6068996ad1" translate="yes" xml:space="preserve">
          <source>Useless use of sort in scalar context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0da921253dc1698e885ee8fb4858aa3af66b911" translate="yes" xml:space="preserve">
          <source>User CPU Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3be132ee381a9663c71ca2a6207a31717e7705" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol, the typical way to send &lt;b&gt;datagrams&lt;/b&gt; over the Internet.</source>
          <target state="translated">인터넷을 통해 &lt;b&gt;데이터 그램&lt;/b&gt; 을 보내는 일반적인 방법 인 사용자 데이터 그램 프로토콜 .</target>
        </trans-unit>
        <trans-unit id="3056b101498f0c6196c04d621ba22bd3175219d6" translate="yes" xml:space="preserve">
          <source>User Groups</source>
          <target state="translated">사용자 그룹</target>
        </trans-unit>
        <trans-unit id="4325c61b581bf8fe6a3e2400d58928e7b9a55496" translate="yes" xml:space="preserve">
          <source>User Interfaces</source>
          <target state="translated">사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="84956701ef226c2e8ce9adf59fb3ab8347d15b4f" translate="yes" xml:space="preserve">
          <source>User mounts override system mounts.</source>
          <target state="translated">사용자 마운트는 시스템 마운트보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="158586304dc1eef989a278eac13c889b9d8fde82" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt; , hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt; , which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="translated">사용자 pragmata는 마법의 해시 &lt;code&gt;%^H&lt;/code&gt; 에 기록하여 상태를 저장하므로이 두 루틴이이를 조작합니다. &lt;code&gt;%^H&lt;/code&gt; 의 상태 정보 는 optree에 저장되며 런타임에 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 결과 목록의 인덱스 10 에서 읽기 전용으로 검색 할 수 있습니다 . 예제 pragma에서 검색은 &lt;code&gt;in_effect()&lt;/code&gt; 루틴으로 캡슐화되며 , 사용자 스크립트에서 pragma의 값을 찾기 위해 호출 프레임 수를 매개 변수로 사용합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 스크립트의 각 라인이 호출 될 때 &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; 의 값을 판별 하므로 과부하 된 추가를 구현하는 서브 루틴에 올바른 의미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f856a6046b9f6cae5f15c166d8fa49ca391fb027" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt;, hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;caller()&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt;, which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;caller()&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ffd06de7d6ceb23de314937b25f1039f95408e" translate="yes" xml:space="preserve">
          <source>User-Defined Case Mappings (for serious hackers only)</source>
          <target state="translated">사용자 정의 사례 매핑 (심각한 해커 만 해당)</target>
        </trans-unit>
        <trans-unit id="021fce3b8ed64c4c7ea81643b8e56e61d1fb88d9" translate="yes" xml:space="preserve">
          <source>User-Defined Character Properties</source>
          <target state="translated">사용자 정의 문자 속성</target>
        </trans-unit>
        <trans-unit id="d44dccc14b24e3c801b9e26a3683449430f65550" translate="yes" xml:space="preserve">
          <source>User-defined properties must begin with &quot;In&quot; or &quot;Is&quot;. These override any Unicode property of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdd4953a2aaaf5875fdc9a6599aaccd9331209f" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="translated">사용자 정의 서브 루틴은 void, 스칼라 또는 목록 컨텍스트에서 호출되는지 여부를 관리하도록 선택할 수 있습니다. 그러나 대부분의 서브 루틴은 귀찮게 할 필요가 없습니다. 스칼라와리스트가 자동으로리스트에 보간되기 때문입니다. 함수의 호출 컨텍스트를 동적으로 식별하는 방법에 대해서는 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b42037c5b1c84227a8152688f10f03ea3163be6" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;perlfunc#wantarray&quot;&gt;&quot;wantarray&quot; in perlfunc&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b3f7fd0444d60354dbca146d3a101a49d16754" translate="yes" xml:space="preserve">
          <source>User-defined subroutines to handle options</source>
          <target state="translated">옵션을 처리하기위한 사용자 정의 서브 루틴</target>
        </trans-unit>
        <trans-unit id="c2c8678cd5e840290be2cdc362d36d4139b6821c" translate="yes" xml:space="preserve">
          <source>User-mode threads are threads that live entirely within a program and its libraries. In this model, the OS knows nothing about threads. As far as it's concerned, your process is just a process.</source>
          <target state="translated">사용자 모드 스레드는 프로그램과 라이브러리 내에 완전히 존재하는 스레드입니다. 이 모델에서 OS는 스레드에 대해 아무것도 모릅니다. 문제가되는 한, 프로세스는 프로세스 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5e4e64aff0ba218cc4ec3a0635d41a38135e5b7e" translate="yes" xml:space="preserve">
          <source>User::grent</source>
          <target state="translated">User::grent</target>
        </trans-unit>
        <trans-unit id="5e0090a6a9d55bf78a5f019a9872cf7e4308c124" translate="yes" xml:space="preserve">
          <source>User::grent - by-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">User :: grent-Perl의 내장 getgr * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="a2bda03ecc876d5bf92fb7707c3e5918fe5160b9" translate="yes" xml:space="preserve">
          <source>User::pwent</source>
          <target state="translated">User::pwent</target>
        </trans-unit>
        <trans-unit id="c4a9575f1a385e0c0339a3155858dfaa2331a364" translate="yes" xml:space="preserve">
          <source>User::pwent - by-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">User :: pwent-Perl의 내장 getpw * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="7a5c186766f7254fdc2c4d1f6c57403c2bb4c28b" translate="yes" xml:space="preserve">
          <source>Users must ensure that URLs are properly escaped for unsafe characters and that international domain names are properly encoded to ASCII. See &lt;a href=&quot;URI::Escape&quot;&gt;URI::Escape&lt;/a&gt;, &lt;a href=&quot;URI::_punycode&quot;&gt;URI::_punycode&lt;/a&gt; and &lt;a href=&quot;Net::IDN::Encode&quot;&gt;Net::IDN::Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dc8b5002e114f1d2e85c5074d99f142b8068508" translate="yes" xml:space="preserve">
          <source>Users of &lt;b&gt;vi&lt;/b&gt; should also look into &lt;b&gt;vim&lt;/b&gt; and &lt;b&gt;gvim&lt;/b&gt;, the mousey and windy version, for coloring of Perl keywords.</source>
          <target state="translated">&lt;b&gt;vi&lt;/b&gt; 사용자는 펄 키워드의 색칠을 위해 마우스와 바람이 많은 버전 인 &lt;b&gt;vim&lt;/b&gt; 과 &lt;b&gt;gvim을&lt;/b&gt; 살펴 봐야 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4927255994b8f9be2cf9331a8ecd222ec16885" translate="yes" xml:space="preserve">
          <source>Users of &lt;code&gt;Emacs&lt;/code&gt; would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2info&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, prebuilt info pages.</source>
          <target state="translated">&lt;code&gt;Emacs&lt;/code&gt; 사용자는 특히 &lt;code&gt;CPerl&lt;/code&gt; 모드가로드 된 경우 매우 감사합니다 . &lt;code&gt;CPAN&lt;/code&gt; 에서 최신 &lt;code&gt;pod2info&lt;/code&gt; 또는 사전 빌드 된 정보 페이지를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="06b3fe1f4b99439f17ea2b119c5a26871e0414f8" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, the prebuilt info pages.</source>
          <target state="translated">Emacs 사용자는 특히 &lt;code&gt;CPerl&lt;/code&gt; 모드가로드 된 경우 매우 감사합니다 . &lt;code&gt;CPAN&lt;/code&gt; 또는 사전 빌드 된 정보 페이지 에서 최신 &lt;code&gt;pod2texi&lt;/code&gt; 를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="fdd1a93dfedc166d886bf8034f368577dba1721c" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt;, or, alternately, the prebuilt info pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a39b7d66f7225d4c692887cb8445ec8ecaf55a" translate="yes" xml:space="preserve">
          <source>Users of Sub::Name beware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d37ee7e83ea8423b48a5461ba1696b2c860b013" translate="yes" xml:space="preserve">
          <source>Users of these operating systems may also wish to make use of scripts such as</source>
          <target state="translated">이러한 운영 체제의 사용자는 다음과 같은 스크립트를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cc3fbd2d7ced57e1d64779d75050cbddcdc28da" translate="yes" xml:space="preserve">
          <source>Users who install modules and do not intend to look back, can free occupied disk space quickly by letting CPAN.pm cleanup each build directory immediately after a successful install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2a2d2f970a65c0f069bae958a29d5ba1eb82f2" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;$Config{pod2html}&lt;/code&gt; to setup default options.</source>
          <target state="translated">&lt;code&gt;$Config{pod2html}&lt;/code&gt; 을 사용 하여 기본 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1bd665ac74aefc48e3c1dedcb2f5bc582892064f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt; , then calls &lt;code&gt;get_cvn_flags&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;strlen&lt;/code&gt; 을 사용 하여 &lt;code&gt;name&lt;/code&gt; 의 길이를 얻은 다음 &lt;code&gt;get_cvn_flags&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="76193d1362ff8617d4996859b5e3b4d6f6ef6d9a" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt;, then calls &lt;code&gt;get_cvn_flags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d33b5a65c41c46d97dad83c368ba4c31fcb025" translate="yes" xml:space="preserve">
          <source>Uses Bourne shell from &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt; Bourne 쉘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8535753d5756d418d77c7eeafa2177abcd178411" translate="yes" xml:space="preserve">
          <source>Uses Encode::from_to for conversion. This is the default.</source>
          <target state="translated">변환에 Encode :: from_to를 사용합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a78266e003805d15484a613ae3192f24c4a5e63f" translate="yes" xml:space="preserve">
          <source>Uses a single private buffer so if you want to format several strings you must explicitly copy the earlier strings away (and free the copies when you are done).</source>
          <target state="translated">단일 개인 버퍼를 사용하므로 여러 문자열을 형식화하려면 이전 문자열을 명시 적으로 복사해야합니다 (완료되면 사본을 비우십시오).</target>
        </trans-unit>
        <trans-unit id="fce3093136a7d2638de72d1f6b19af95e4dd37ba" translate="yes" xml:space="preserve">
          <source>Uses for the &lt;code&gt;export_fail&lt;/code&gt; method include giving better error messages for some symbols and performing lazy architectural checks (put more symbols into &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; by default and then take them out if someone actually tries to use them and an expensive check shows that they are usable on that platform).</source>
          <target state="translated">에 사용 &lt;code&gt;export_fail&lt;/code&gt; 의 방법은 일부 기호에 대한 더 나은 오류 메시지를주고 게으른 건축 검사 (에 더 많은 문자를 넣어 수행을 포함 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 기본적으로 다음 사람이 실제로 그에 사용할 수 있음을 그들과 비싼 검사 프로그램을 사용하려고하는 경우를 꺼내 플랫폼).</target>
        </trans-unit>
        <trans-unit id="eac5d6a5ec3502600865ed0620f6a65c1c849fe7" translate="yes" xml:space="preserve">
          <source>Uses the RMS $PARSE and $SEARCH services to expand the input specification to its fully qualified form, except that a null type or version is not added unless it was present in either the original file specification or the default specification passed to &lt;code&gt;rmsexpand&lt;/code&gt;. (If the file does not exist, the input specification is expanded as much as possible.) If an error occurs, returns &lt;code&gt;undef&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff51dbb10de4f730c3d10cc9e64e2774f2375b58" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3).</source>
          <target state="translated">getcwd ()와 동일한 알고리즘을 사용합니다. 심볼릭 링크와 상대 경로 구성 요소 ( &quot;.&quot;및 &quot;..&quot;)는 realpath (3)와 같이 정식 경로 이름을 반환하도록 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="4365c50bdac565f572d333d6b72f03aff0ac251d" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3). On error returns &lt;code&gt;undef&lt;/code&gt;, with &lt;code&gt;$!&lt;/code&gt; set to indicate the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9086306446f5bee7eedc51873f977f5639cf3890" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script.</source>
          <target state="translated">EXPR의 값을 파일 이름으로 사용하고 파일의 내용을 Perl 스크립트로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0833769764b7443ea479805ee6f37b7caafeab0d" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b191f377109544e991562530e982f3ab20d97a29" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">이전 getpos 호출 값을 사용하여 이전에 방문한 위치로 돌아갑니다. 성공하면 &quot;0이지만 true&quot;를 반환 하고 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9f57754e44ef793b1363eb328e38c456df0e8c76" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="966e93b10e960e2cad1eb5a36830811e8adda0ef" translate="yes" xml:space="preserve">
          <source>Using !~ with %s doesn't make sense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2352b330d6ed131b0eecd5f3967c2801dc2e677c" translate="yes" xml:space="preserve">
          <source>Using &quot;#&quot; as a padding character specifies a numeric field, with right justification. An optional &quot;.&quot; defines the position of the decimal point. With a &quot;0&quot; (zero) instead of the first &quot;#&quot;, the formatted number will be padded with leading zeroes if necessary. A special numeric field is blanked out if the value is undefined. If the resulting value would exceed the width specified the field is filled with &quot;#&quot; as overflow evidence.</source>
          <target state="translated">패딩 문자로 &quot;#&quot;을 사용하면 오른쪽 자리 맞추기와 함께 숫자 필드가 지정됩니다. 선택적인 &quot;.&quot; 소수점 위치를 정의합니다. 첫 번째 &quot;#&quot;대신 &quot;0&quot;(영)을 사용하면 필요한 경우 형식이 지정된 숫자 앞에 선행 0이 채워집니다. 값이 정의되지 않은 경우 특수 숫자 필드는 비워집니다. 결과 값이 지정된 너비를 초과하면 필드가 오버플로 증거로 &quot;#&quot;으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4d195a30219da687f66f5ac2e4c6c839d91fc335" translate="yes" xml:space="preserve">
          <source>Using &quot;&amp;gt;&quot; always clobbers or creates. Using &quot;&amp;lt;&quot; never does either. The &quot;+&quot; doesn't change this.</source>
          <target state="translated">&quot;&amp;gt;&quot;를 사용하면 항상 방해를 받거나 생성됩니다. &quot;&amp;lt;&quot;를 사용하면 어느 것도 수행되지 않습니다. &quot;+&quot;는 이것을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16cc068fbb7f0118050467d326f37173d537b721" translate="yes" xml:space="preserve">
          <source>Using &quot;pl2bat&quot; has a few problems: the file name gets changed, so scripts that rely on &lt;code&gt;$0&lt;/code&gt; to find what they must do may not run properly; running &quot;pl2bat&quot; replicates the contents of the original script, and so this process can be maintenance intensive if the originals get updated often. A different approach that avoids both problems is possible.</source>
          <target state="translated">&quot;pl2bat&quot;를 사용하면 몇 가지 문제가 있습니다. 파일 이름이 변경되므로 &lt;code&gt;$0&lt;/code&gt; 에 의존하는 스크립트가 제대로 실행되지 않을 수 있습니다. &quot;pl2bat&quot;을 실행하면 원본 스크립트의 내용이 복제되므로 원본이 자주 업데이트되는 경우이 프로세스를 유지 관리해야 할 수도 있습니다. 두 가지 문제를 피하는 다른 접근법이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="05f631394c6e9641817e0e504fc7c43b66232fc2" translate="yes" xml:space="preserve">
          <source>Using $ENV{PERL_DEBUG_MSTATS}</source>
          <target state="translated">$ ENV {PERL_DEBUG_MSTATS} 사용</target>
        </trans-unit>
        <trans-unit id="369ff12968f332b6148e74df2b66edfe0b032cb0" translate="yes" xml:space="preserve">
          <source>Using 'X' and cousins requires you not to use the type identifiers ($@%), just the 'name':</source>
          <target state="translated">'X'와 사촌을 사용하려면 'name'만 형식 식별자 ($ @ %)를 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="2dfddf8d7a196c4e7f1fa3524316075003cbc8ac" translate="yes" xml:space="preserve">
          <source>Using *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">* AutoLoader *의 AUTOLOAD 서브 루틴 사용</target>
        </trans-unit>
        <trans-unit id="9094fd1811fd7f32bf808bb09cf11c4c4b959972" translate="yes" xml:space="preserve">
          <source>Using / for Unix. Called by init_main.</source>
          <target state="translated">유닉스에서 / 사용하기. init_main에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6fd37cde410d5e8c4989d291b7ed857f9e1011" translate="yes" xml:space="preserve">
          <source>Using //-comments</source>
          <target state="translated">//-코멘트 사용</target>
        </trans-unit>
        <trans-unit id="79809cc2376a530f4cdcf8b4b35d6c4db1c5702b" translate="yes" xml:space="preserve">
          <source>Using /u for '%s' instead of /%s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c61487f8204326408bdf1ae7270fc6e5521a082" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#newSVpvn&quot;&gt;&quot;newSVpvn&quot;&lt;/a&gt; is a safer alternative for non &lt;code&gt;NUL&lt;/code&gt; terminated strings. For string literals use &lt;a href=&quot;#newSVpvs&quot;&gt;&quot;newSVpvs&quot;&lt;/a&gt; instead. This function will work fine for &lt;code&gt;NUL&lt;/code&gt; terminated strings, but if you want to avoid the if statement on whether to call &lt;code&gt;strlen&lt;/code&gt; use &lt;code&gt;newSVpvn&lt;/code&gt; instead (calling &lt;code&gt;strlen&lt;/code&gt; yourself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5f6e9be6b3df2e9fbe8c1d9ff48b4e453e5870" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4a15910e3dadf2cc006c6867eda30e63f7dc0f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;비트를 :: 벡터&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="40cb646ced92b37d9010916926bfe1380a1696f2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6665571474aeb5014d9a2187041b82aa2b6cf9" translate="yes" xml:space="preserve">
          <source>Using &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">사용하여 &lt;b&gt;자동로드&lt;/b&gt; 의 AUTOLOAD 서브 루틴을</target>
        </trans-unit>
        <trans-unit id="5cfa1c0592cc7196c9a7f1e7194e067f8fe4c528" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;or&quot;&lt;/code&gt; for assignment is unlikely to do what you want; see below.</source>
          <target state="translated">할당을 위해 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 을 사용 하는 것은 원하는 것을 수행하지 않을 것입니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a303f25d71d0c242dc6c0e5ae7c606b1bec2045" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ff3dae92bc192e26ee0eb7af7182c12b0e7db8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; , input is read line-by-line and assembled into paragraphs or &quot;blocks&quot; (which are separated by lines containing nothing but whitespace). For each block of POD documentation encountered it will invoke a method to parse the given paragraph.</source>
          <target state="translated">&lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; 사용하여 입력을 한 줄씩 읽고 단락 또는 &quot;블록&quot;(공백 만 포함하는 행으로 구분)으로 조립합니다. 발생하는 POD 문서의 각 블록에 대해 주어진 단락을 구문 분석하는 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f2a68f677fc4720bdeb7e4f8032c1c375f4d6291" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt; . This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--verbose&lt;/code&gt; 를 사용하면 &lt;code&gt;$verbose&lt;/code&gt; 값이 증가합니다 . 이 방법으로 프로그램은 옵션이 명령 행에서 몇 번이나 발생했는지 추적 할 수 있습니다. 예를 들어, &lt;code&gt;--verbose&lt;/code&gt; 가 발생할 때마다 프로그램의 상세 수준이 높아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="017d2fafe54a43c9bad8e818f1629a740d67178f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt;. This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad1d7060df6581913c9f5f84ab874f296c32585" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; rather than &lt;code&gt;-Dusemultiplicity&lt;/code&gt; is more appropriate if you intend to run multiple interpreters concurrently in different threads, because it enables support for linking in the thread libraries of your system with the interpreter.</source>
          <target state="translated">&lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 사용 여러 스레드를 여러 스레드에서 동시에 실행하려는 경우 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 가 아닌 -Duseithreads 가 더 적합합니다. 이는 시스템의 스레드 라이브러리에서 인터프리터와의 링크 지원을 가능하게하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="61eab4185699c92641d9413479e73b37872fd212" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 여러 DLL을로드 한 후 다른 펄 밖으로 것은 DLL의 기본 주소 충돌에 발생할 수 있습니다. 내부 cygwin 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcca95252686536518c82a86f093a53ca5ff8ade" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in combination with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="translated">사용하여 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; A를의 조합 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; Perl 스크립트의 맨 위에는 인터프리터가 특정 프로그래밍 오류를 선택한다는 의미입니다. 예를 들어, 위의 예에서 최종 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; 는 컴파일 타임 오류를 발생시키고 프로그램 실행을 방해합니다. &lt;code&gt;strict&lt;/code&gt; 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6570099c968b1dac1aeada91a2fa62948e513fde" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="c4ee3a2331f58e1266f76a324d649c5e7a530542" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 또는 &lt;code&gt;p&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; 을 사용하여 &lt;code&gt;$x&lt;/code&gt; 가 실제로 저장된 주소를 얻으려면주의 를 기울여야합니다. Perl의 내부 기계는 변수와 해당 주소 간의 관계를 고유 한 사적인 문제로 간주하며 실제로 사본을 얻었는지 신경 쓰지 않습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="f64f7e3c602eac9f0cc5d3fae9a96d9a3eb0bb0b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5fe85d80b5d4e554e757435dadbee8779f515048" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; for larger strings:</source>
          <target state="translated">더 큰 문자열에 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="77bac2c89d98d4342e51014bdc1e5dfcf83f7405" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="9b2ba3ba2d555e75ce68454a406fe0f0433207e8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (or the operator form, &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ) as the conditional of a &lt;code&gt;for&lt;/code&gt; loop is shorthand for the following. This behaviour is the same as a &lt;code&gt;while&lt;/code&gt; loop conditional.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (또는 운영자 형태 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; (A)의 조건 등) &lt;code&gt;for&lt;/code&gt; 루프는 다음의 속기이다. 이 동작은 &lt;code&gt;while&lt;/code&gt; 루프 조건부 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="48ea9a8aca48a2ecece519f0da9a5610c9c21b22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (perl 5.6+):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 사용 (perl 5.6+) :</target>
        </trans-unit>
        <trans-unit id="672d9d441ef641164ca3c34a7892f3146881bd19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="46b9c6aa21d990c3320125b6b398a58171b824d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="c96b7be56d606a5173254b9ecaa85e8754516cc1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;C0&lt;/code&gt; to get Unicode characters while using &lt;code&gt;U0&lt;/code&gt; to get</source>
          <target state="translated">&lt;code&gt;C0&lt;/code&gt; 을 사용하여 유니 코드 문자를 가져 오는 동안 &lt;code&gt;U0&lt;/code&gt; 을 사용하여</target>
        </trans-unit>
        <trans-unit id="bd76d249b9cc849b475f04243607bd5ac606dc24" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;EVERY&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 방법 사용</target>
        </trans-unit>
        <trans-unit id="060b36ae2eafc535fc899ab4d0c43c28a110d442" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;InputLength&lt;/code&gt; avoids the use of temporary storage and means the application can cope with large compressed data streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cb598e3b72d4f21f30ade24958fec2725c2b36" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;InputLength&lt;/code&gt; to uncompress data embedded in a larger file/buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecd1ec7133eb6a574dc47a89387830a895fdc67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;autouse&lt;/code&gt; will move important steps of your program's execution from compile time to runtime. This can</source>
          <target state="translated">사용 &lt;code&gt;autouse&lt;/code&gt; 은 런타임에 컴파일 시간에서 프로그램의 실행의 중요한 단계를 이동합니다. 이것은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ddf6589db735a9f59292836b7b6ee26755c1a873" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;do&lt;/code&gt; with a relative path (except for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef84df941727116a5825b7a2a6765e3991fcd112" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;fork()&lt;/code&gt; or &lt;code&gt;system()&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c94e397182ad35f0199796c485d6c8aec54e54f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">사용 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 특정 태그에 대한 추출 기능을 만들려면 이러한 기능은 더 일반적인 목적은 그들의 성능이 좋은 두 배 일반적이기 때문에, 한 번 이상 호출 위하여려고하는 경우에 좋은 아이디어이다 &lt;code&gt;extract_tagged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5433b6a32cf1d604428ab16e7190967e95673e56" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15459b53ecb2c76cd94f0b94ae736e49e8484db" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b55d7735ea783b5e6004e758bd55af4f884bf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 를 사용 하면 지정된 라이브러리를 찾을 수없고 &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 가 기본 라이브러리 중 하나로 대체 됩니다. 이 경고를 표시하지 않으려면 대신 &lt;code&gt;try&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e629d4fa388da4d8ac7581ea3d526173f8b0ad2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;my&lt;/code&gt; in combination with a &lt;code&gt;use strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;print $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b7d2848f22bcc07eed4323aeaebde4299c41ef" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ef3ca19134d3f66249fa1483f651e7bd5d8f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a53bf2c5ceda1c9b4b4644412681b9465fd2ab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da26c3b2ee39d32013ceb92470d6b6f25d85226" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; for larger strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a8a932e33f385f4030a8352a7d3514d3cb726f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffd8ad58b1a0f4bd73c5c83cc872616c113bd7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;refaddr()&lt;/code&gt; is unreliable for testing whether or not two shared references are equivalent (e.g., when testing for circular references). Use &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared()&lt;/a&gt;, instead:</source>
          <target state="translated">사용 &lt;code&gt;refaddr()&lt;/code&gt; (예를 들어, 원형의 참조를 테스트 할 때) 두 개의 공유 참조 동일 여부 테스트 신뢰할. 대신 &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared ()를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c6974328aaa0d51c94208e65999d2c3c46bd958" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;sprintf&lt;/code&gt; (perl 5.6+):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591729639c3713bf822d3524e75de771d667b742" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;sprintf&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9d7582ed46e0d412f2d6595c39dd57224927a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;undef&lt;/code&gt; for temporary files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b7d0e5d79a2753c1c7b705ec6fe0b2755e9284" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef178ae90603162abddf22f7d9bb0fc3e898af5" translate="yes" xml:space="preserve">
          <source>Using Attributes and Parameters</source>
          <target state="translated">속성 및 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="7224556798c8e29a3e7917f3fcdea9b882c8dbbe" translate="yes" xml:space="preserve">
          <source>Using AutoLoader's AUTOLOAD Subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bf2717e06af78329e93ebf453e1e826613e2e4" translate="yes" xml:space="preserve">
          <source>Using B::Concise outside of the O framework</source>
          <target state="translated">O 프레임 워크 외부에서 B :: Concise 사용</target>
        </trans-unit>
        <trans-unit id="18bafced67519d44baeebd7cfdcaf662b62afabc" translate="yes" xml:space="preserve">
          <source>Using DB_File with Berkeley DB version 2 or greater</source>
          <target state="translated">Berkeley DB 버전 2 이상에서 DB_File 사용</target>
        </trans-unit>
        <trans-unit id="97e4ec7dc3ee57617b8c25e5da7b2620a2b30764" translate="yes" xml:space="preserve">
          <source>Using EVERY methods</source>
          <target state="translated">모든 방법 사용</target>
        </trans-unit>
        <trans-unit id="eaf5424654cdf470f964dbc03078a17cf18e6b68" translate="yes" xml:space="preserve">
          <source>Using Encode</source>
          <target state="translated">인코딩 사용</target>
        </trans-unit>
        <trans-unit id="b3c01fd9731ccf33cc32d289966ab7fb5c9b6f88" translate="yes" xml:space="preserve">
          <source>Using Fill Mode</source>
          <target state="translated">채우기 모드 사용</target>
        </trans-unit>
        <trans-unit id="5cb7c472310d76de5801b53745949b0358783728" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple and Exporter together</source>
          <target state="translated">Filter :: Simple과 Exporter를 함께 사용</target>
        </trans-unit>
        <trans-unit id="8adffc36e41ac8b6ef194fa0464f19be3d960928" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">명시 적 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 과 함께 Filter :: Simple 사용</target>
        </trans-unit>
        <trans-unit id="be645fc12b677ffc0811a1fbab93eecc047912a0" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fae20bc9d38356a2d17453bc9b205cc1c897f19" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit import subroutine</source>
          <target state="translated">명시 적 가져 오기 서브 루틴과 함께 Filter :: Simple 사용</target>
        </trans-unit>
        <trans-unit id="1ae3259ed8aaec135b40d3c0be57406133a41acb" translate="yes" xml:space="preserve">
          <source>Using GIMME_V</source>
          <target state="translated">GIMME_V 사용</target>
        </trans-unit>
        <trans-unit id="1d57725fba088f8b24d927a2eedcfd4e936a608f" translate="yes" xml:space="preserve">
          <source>Using GNU's gcc for building Perl</source>
          <target state="translated">Perl을 빌드하기 위해 GNU의 gcc 사용</target>
        </trans-unit>
        <trans-unit id="e882257535f024e0d015187d37538f63a8847fce" translate="yes" xml:space="preserve">
          <source>Using G_EVAL</source>
          <target state="translated">G_EVAL 사용</target>
        </trans-unit>
        <trans-unit id="295eff162915babd344155c6be19db49d4d64f02" translate="yes" xml:space="preserve">
          <source>Using G_KEEPERR</source>
          <target state="translated">G_KEEPERR 사용</target>
        </trans-unit>
        <trans-unit id="ba80e8a55a6de58b5cac5607f035e2bd86d99769" translate="yes" xml:space="preserve">
          <source>Using InputLength to uncompress data embedded in a larger file/buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d5f49af97261f97893047f771a98e55443d77c" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl</source>
          <target state="translated">Perl과 함께 큰 파일 사용</target>
        </trans-unit>
        <trans-unit id="317a1b556565aa526e2b302cc529d9bc9bad8e03" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl &amp;lt; 5L</source>
          <target state="translated">Perl &amp;lt;5L의 대용량 파일 사용</target>
        </trans-unit>
        <trans-unit id="4193d5877700c1da7cc3dc0d04426fb8e279c514" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on HP-UX</source>
          <target state="translated">HP-UX에서 Perl과 함께 대용량 파일 사용</target>
        </trans-unit>
        <trans-unit id="bb8e5976c90f08c21142951c3aacf31e66206c3b" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on Tru64</source>
          <target state="translated">Tru64에서 Perl과 함께 큰 파일 사용</target>
        </trans-unit>
        <trans-unit id="d35a8b92c0313948c8001f6e0f5a80140456f638" translate="yes" xml:space="preserve">
          <source>Using Math::BigInt::Lite</source>
          <target state="translated">Math :: BigInt :: Lite 사용</target>
        </trans-unit>
        <trans-unit id="d3ea25d5f31a035beb72e8f68cf347e89b109748" translate="yes" xml:space="preserve">
          <source>Using Net::FTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505b1ba51f7a380027ac8add47d55b866c5788d3" translate="yes" xml:space="preserve">
          <source>Using Net::SMTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a9198bb8db024f66e7beddb02099ae2c33e45d" translate="yes" xml:space="preserve">
          <source>Using POSIX::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="translated">POSIX :: ARG_MAX를 사용합니다. 그렇지 않으면 4096으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7f350838d7d6c4618cf4c3624992c0a5fa550ccf" translate="yes" xml:space="preserve">
          <source>Using Perl in &quot;native&quot; BS2000</source>
          <target state="translated">&quot;기본&quot;BS2000에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="adbb3dbb566652d469c92e143d370e6625a585c4" translate="yes" xml:space="preserve">
          <source>Using Perl in OS/400 PASE</source>
          <target state="translated">OS / 400 PASE에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="2f91327799ddf2016004ebaf8e8d6bedda20acf6" translate="yes" xml:space="preserve">
          <source>Using Perl in Symbian</source>
          <target state="translated">Symbian에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="6d719543bb32291214db915134a27443927a8c27" translate="yes" xml:space="preserve">
          <source>Using Perl in the Posix-Shell of BS2000</source>
          <target state="translated">BS2000의 Posix-Shell에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="84118c01838e699ac467fa37b8bb29a7f8370768" translate="yes" xml:space="preserve">
          <source>Using Perl modules</source>
          <target state="translated">Perl 모듈 사용</target>
        </trans-unit>
        <trans-unit id="028de32ca6d30212bfbce4a0c1bee8b8576b4e69" translate="yes" xml:space="preserve">
          <source>Using Perl modules, which themselves use C libraries, from your C program</source>
          <target state="translated">C 프로그램에서 C 라이브러리를 사용하는 Perl 모듈 사용</target>
        </trans-unit>
        <trans-unit id="0ff9818b99a67e75450030e8c7e7092cbe65f9c0" translate="yes" xml:space="preserve">
          <source>Using Perl on WinCE</source>
          <target state="translated">WinCE에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="a5580cc662de9455c8f221545dacc2b26132369a" translate="yes" xml:space="preserve">
          <source>Using Perl to Dispose of Temporaries</source>
          <target state="translated">Perl을 사용하여 임시 처리</target>
        </trans-unit>
        <trans-unit id="5320f15bf6dff40493f314bd488164951d124fee" translate="yes" xml:space="preserve">
          <source>Using Perl to dispose of temporaries</source>
          <target state="translated">Perl을 사용하여 임시 처리</target>
        </trans-unit>
        <trans-unit id="b797430b32d30f68c1ea4534b74218539d3aaf64" translate="yes" xml:space="preserve">
          <source>Using Perl's built in conversion of numbers with leading zeros:</source>
          <target state="translated">앞에 0이 붙은 숫자의 Perl 내장 변환 사용 :</target>
        </trans-unit>
        <trans-unit id="f15ed3b42ac67b1af9e23e97edaf317ed0b825a6" translate="yes" xml:space="preserve">
          <source>Using PerlIO and different encodings on ASCII and EBCDIC partitions</source>
          <target state="translated">ASCII 및 EBCDIC 파티션에서 PerlIO 및 다른 인코딩 사용</target>
        </trans-unit>
        <trans-unit id="36711385fbee8d56f23de9017ef392314347e2e0" translate="yes" xml:space="preserve">
          <source>Using References</source>
          <target state="translated">참조 사용</target>
        </trans-unit>
        <trans-unit id="f52e2f6da146b1affad48afad3cd39b28bc932df" translate="yes" xml:space="preserve">
          <source>Using Sudo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82685302632dac9e1fd31a13c0849aefa5124be7" translate="yes" xml:space="preserve">
          <source>Using Unicode in XS</source>
          <target state="translated">XS에서 유니 코드 사용</target>
        </trans-unit>
        <trans-unit id="998956ebf62d14d931cc7ad656bc083d855b7aba" translate="yes" xml:space="preserve">
          <source>Using XS With C++</source>
          <target state="translated">C ++에서 XS 사용</target>
        </trans-unit>
        <trans-unit id="dac1e6f7cf5fb38291cdecac855edeefdf437f99" translate="yes" xml:space="preserve">
          <source>Using \ for Windows, except for &quot;gmake&quot; where it is /.</source>
          <target state="translated">/ 인 &quot;gmake&quot;를 제외하고 Windows 용 \를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8137c8c1ed484dbce9760788d8ea8483549cf1f0" translate="yes" xml:space="preserve">
          <source>Using _t/harness_ for testing</source>
          <target state="translated">테스트에 _t / harness_ 사용</target>
        </trans-unit>
        <trans-unit id="4f4b906f20b028b71f5628fd6f90032d406f6155" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;__WARN__&lt;/code&gt; handler provides a powerful way to silence all warnings (even the so-called mandatory ones). An example:</source>
          <target state="translated">&lt;code&gt;__WARN__&lt;/code&gt; 핸들러를 사용하면 모든 경고 (소위 필수 경고 포함)를 침묵시키는 강력한 방법을 제공합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b4b4ca6e1deabca931233328798f7fbb48c8c07b" translate="yes" xml:space="preserve">
          <source>Using a closure as a function template allows us to generate many functions that act similarly. Suppose you wanted functions named after the colors that generated HTML font changes for the various colors:</source>
          <target state="translated">클로저를 함수 템플릿으로 사용하면 비슷하게 작동하는 많은 함수를 생성 할 수 있습니다. 다양한 색상에 대해 HTML 글꼴 변경을 생성 한 색상의 이름을 딴 함수를 원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3428ced333d3144f878ace997075432ead893fb6" translate="yes" xml:space="preserve">
          <source>Using a hash reference is</source>
          <target state="translated">해시 참조 사용은</target>
        </trans-unit>
        <trans-unit id="336ecaf20b3b819b2df81459841f824dd710f158" translate="yes" xml:space="preserve">
          <source>Using a lexical pragma to enable or disable legacy behavior should be considered when appropriate, and in the absence of any pragma legacy behavior should be enabled. Which backward-incompatible changes are controlled implicitly by a 'use v5.x.y' is a decision which should be made by the pumpking in consultation with the community.</source>
          <target state="translated">적절한 경우 어휘 pragma를 사용하여 레거시 동작을 활성화 또는 비활성화하는 것을 고려해야하며, pragma 레거시 동작이없는 경우 활성화해야합니다. 'use v5.xy'에 의해 이전 버전과 호환되지 않는 변경이 암시 적으로 제어되는 것은 커뮤니티와상의하여 pumpking에 의해 결정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="37d264a714cc8982079f31352e5a02a2d407c9ec" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; for details and examples of its use.</source>
          <target state="translated">참조를 문자열로 사용하면 &lt;a href=&quot;perlobj&quot;&gt;perlobj에&lt;/a&gt; 설명 된대로 패키지 축복과 16 진수로 표현 된 숫자 주소를 포함하여 참조 유형이 생성 됩니다. ref () 연산자는 주소없이 참조가 가리키는 유형 만 반환합니다. 자세한 사용법과 사용 예는 &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7048559c1137fab42b7f83dcde719d8123af44bd" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;perlfunc#ref&quot;&gt;&quot;ref&quot; in perlfunc&lt;/a&gt; for details and examples of its use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178dbf3b1655da796ad383968646cf6aaa7b961a" translate="yes" xml:space="preserve">
          <source>Using a regular Perl string as a key or value for a DBM hash will trigger a wide character exception if any codepoints won&amp;rsquo;t fit into a byte. Here&amp;rsquo;s how to manually manage the translation:</source>
          <target state="translated">코드 포인트가 바이트에 맞지 않으면 DBM 해시의 키 또는 값으로 일반 Perl 문자열을 사용하면 넓은 문자 예외가 트리거됩니다. 번역을 수동으로 관리하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="544cb5d954d39b68ec105da285e699133ee66333" translate="yes" xml:space="preserve">
          <source>Using a slice on the lefthand side of the assignment supplies list context to the righthand side. This can lead to unexpected results. For instance, if you want to read a single line from a filehandle, assigning to a scalar value is fine:</source>
          <target state="translated">과제의 왼쪽에있는 슬라이스를 사용하면 오른쪽에 목록 컨텍스트가 제공됩니다. 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 파일 핸들에서 단일 행을 읽으려면 스칼라 값을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4d64816ce71679faa0148bf687b3dd87ced39ea8" translate="yes" xml:space="preserve">
          <source>Using a smoke-me branch to test changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047ab6347496bdbb043bb75da5faf973242f2e7a" translate="yes" xml:space="preserve">
          <source>Using a source-level debugger</source>
          <target state="translated">소스 레벨 디버거 사용</target>
        </trans-unit>
        <trans-unit id="5e1e5b1c335e1407e117badbc02a20174cee06fd" translate="yes" xml:space="preserve">
          <source>Using a string or number as a reference produces a symbolic reference, as explained above. Using a reference as a number produces an integer representing its storage location in memory. The only useful thing to be done with this is to compare two references numerically to see whether they refer to the same location.</source>
          <target state="translated">문자열 또는 숫자를 참조로 사용하면 위에서 설명한대로 기호 참조가 생성됩니다. 참조를 숫자로 사용하면 메모리의 저장 위치를 ​​나타내는 정수가 생성됩니다. 이 작업을 수행하는 데 유용한 유일한 방법은 두 참조를 숫자로 비교하여 동일한 위치를 참조하는지 여부를 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="937545592134f4777c1d76d97432be42ef7d2470" translate="yes" xml:space="preserve">
          <source>Using a string that doesn't correspond to any existing function or a glob that doesn't contain a code slot is equivalent to &lt;code&gt;'IGNORE'&lt;/code&gt;, but a warning is emitted when the handler is being called (the warning is not emitted for the internal hooks described below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e91a5896764f48c6ace56fa4d53091e1acc312" translate="yes" xml:space="preserve">
          <source>Using a subroutine as part of your sort is a powerful way to get exactly what you want, but will usually be slower than the built-in</source>
          <target state="translated">서브 루틴을 정렬의 일부로 사용하는 것은 원하는 것을 정확하게 얻을 수있는 강력한 방법이지만 일반적으로 내장보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="2a79ecdd0e9982d50231f84c62b552b6746f4f38" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case.</source>
          <target state="translated">&lt;code&gt;'IGNORE'&lt;/code&gt; 값을 사용하면 일반적으로 &lt;code&gt;CHLD&lt;/code&gt; 신호를 제외하고 신호를 무시하는 효과가 있습니다. 이 특별한 경우에 대한 자세한 내용은 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69c690d04b9213eef35e158a45e78b34887853f6" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case. Using an empty string or &lt;code&gt;undef&lt;/code&gt; as the value has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcddbca973bdd2d4fec8195d0ee94f29f4dde64e" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; is also more secure. This usage (which also works fine with &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df5e3fd8acd272c23a1963f6dc8693fe3a9c164" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 함께 간접 객체를 사용하는 것이 더 안전합니다. 이 사용법 (system ()에서도 잘 작동 함)은 목록에 인수가 하나 뿐인 경우에도 인수를 다중 값 목록으로 해석합니다. 그렇게하면 쉘에서 와일드 카드를 확장하거나 공백이있는 단어를 나누는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="44d98963d401217f7be5255c87293a2853856e67" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 함께 간접 객체를 사용하는 것이 더 안전합니다. 이 사용법 (system ()에서도 잘 작동 함)은 목록에 인수가 하나 뿐인 경우에도 인수를 다중 값 목록으로 해석합니다. 그렇게하면 쉘에서 와일드 카드를 확장하거나 공백이있는 단어를 나누는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="604eef1aa9c7558fedd10f863a9440cef58a337c" translate="yes" xml:space="preserve">
          <source>Using an installation prefix of '/usr' will result in a directory layout that mirrors that of Apple's default Perl, with core modules stored in '/System/Library/Perl/${version}', CPAN modules stored in '/Library/Perl/${version}', and the addition of '/Network/Library/Perl/${version}' to @INC for modules that are stored on a file server and used by many Macs.</source>
          <target state="translated">설치 접두사 '/ usr'을 사용하면 디렉토리 레이아웃이 Apple의 기본 Perl과 동일하게 표시되고 코어 모듈은 '/ System / Library / Perl / $ {version}'에 저장되고 CPAN 모듈은 '/ Library /에 저장됩니다. 파일 서버에 저장되어 많은 Mac에서 사용하는 모듈을 위해 Perl / $ {version} '및 @INC에'/ Network / Library / Perl / $ {version} '추가.</target>
        </trans-unit>
        <trans-unit id="aa23c98317fa566c477de2941d147e87b315123e" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; operator returns. That means that</source>
          <target state="translated">유용하지는 않지만 왼쪽 피연산자로 객체를 사용할 수 있습니다. 스마트 매칭 규칙은 오버로드보다 우선합니다. 따라서 왼쪽 피연산자의 객체에 스마트 매치 오버로드가 있어도 무시됩니다. 오버로드되지 않은 객체 인 왼쪽 피연산자는 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 연산자가 반환 하는 것에 대한 문자열 또는 숫자 비교로 대체 됩니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="84909391edc56fe29eb99f999fdd4d50a409a946" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;ref&lt;/code&gt; operator returns. That means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3237ae31bb37c81782ea50be28770f0de2555e" translate="yes" xml:space="preserve">
          <source>Using any of the above invocations, the first argument to the constructor is always the corresponding package name (or object reference). No other arguments are required, but if desired, an associative array (or hash-table) my be passed to the &lt;b&gt;new()&lt;/b&gt; constructor, as in:</source>
          <target state="translated">위의 호출 중 하나를 사용하면 생성자에 대한 첫 번째 인수는 항상 해당 패키지 이름 (또는 객체 참조)입니다. 다른 인수는 필요하지 않지만 원하는 경우 연관 배열 (또는 해시 테이블)을 다음과 같이 &lt;b&gt;new ()&lt;/b&gt; 생성자에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="8097e70784bcbb030b53b18d1acb24cd21f46737" translate="yes" xml:space="preserve">
          <source>Using arguments of the form &lt;code&gt;-Ldir&lt;/code&gt; and &lt;code&gt;-lname&lt;/code&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;-Ldir&lt;/code&gt; 및 &lt;code&gt;-lname&lt;/code&gt; 형식의 인수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6161aa0cd787955761dec12d0177c3ac026e9b0" translate="yes" xml:space="preserve">
          <source>Using call_argv</source>
          <target state="translated">call_argv 사용</target>
        </trans-unit>
        <trans-unit id="9134163152acbc5710de0bd418aa078593a2b9c2" translate="yes" xml:space="preserve">
          <source>Using call_method</source>
          <target state="translated">call_method 사용</target>
        </trans-unit>
        <trans-unit id="b881b2dfc007740bbb57d40d5226f14e171509f9" translate="yes" xml:space="preserve">
          <source>Using call_sv</source>
          <target state="translated">call_sv 사용</target>
        </trans-unit>
        <trans-unit id="fa52cf5ccb980442f1ec3e9f0afd04690158c461" translate="yes" xml:space="preserve">
          <source>Using caret fields can produce lines where all fields are blank. You can suppress such lines by putting a &quot;~&quot; (tilde) character anywhere in the line. The tilde will be translated to a space upon output.</source>
          <target state="translated">캐럿 필드를 사용하면 모든 필드가 비어있는 행이 생성 될 수 있습니다. 줄의 아무 곳에 나 &quot;~&quot;(물결표) 문자를 넣어 이러한 줄을 표시하지 않을 수 있습니다. 물결표는 출력시 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b35e7b174dfce328e49d2c9b54ef677263d0168" translate="yes" xml:space="preserve">
          <source>Using caseless (&lt;code&gt;/i&lt;/code&gt;) regular expression matching.</source>
          <target state="translated">대소 문자를 구분하지 않는 ( &lt;code&gt;/i&lt;/code&gt; ) 정규식 일치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="912a2aec3bed273542aa33d8ea10bb43e6f23900" translate="yes" xml:space="preserve">
          <source>Using character classes</source>
          <target state="translated">캐릭터 클래스 사용</target>
        </trans-unit>
        <trans-unit id="0ed204e094dc9752d186724902c15a617f19dc27" translate="yes" xml:space="preserve">
          <source>Using diagnostics to get stack traces from a misbehaving script:</source>
          <target state="translated">진단을 사용하여 오작동 스크립트에서 스택 추적 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="6d1350125897c58fd7a177587a74cb5b6d024e7d" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt; ), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt; ). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="translated">while 안에 이중 꺾쇠 괄호를 사용하면 open에서 세 개의 인수 형식 (두 번째 인수가 &lt;code&gt;&amp;lt;&lt;/code&gt; )을 사용하므로 &lt;code&gt;ARGV&lt;/code&gt; 의 모든 인수는 리터럴 파일 이름 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; 포함)으로 처리됩니다 . 편의상 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 사용 하고 &lt;code&gt;@ARGV&lt;/code&gt; 가 비어 있으면 여전히 표준 입력에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="046e496e81943994e689bc356bf07a0e8b6601e5" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt;), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt;). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87082cc66c652c8a0a8c6cf8ba8fff9479b0be7a" translate="yes" xml:space="preserve">
          <source>Using either $MM-&amp;gt;{uc $var} || $Config{lc $var}, it will attempt to replace it's $prefix with a $new_prefix.</source>
          <target state="translated">$ MM-&amp;gt; {uc $ var} || $ Config {lc $ var}, $ prefix를 $ new_prefix로 교체하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="215bd29754319db34f811a8f9488126e67fb90a8" translate="yes" xml:space="preserve">
          <source>Using embedded Perl with POSIX locales</source>
          <target state="translated">POSIX 로케일과 함께 임베디드 Perl 사용</target>
        </trans-unit>
        <trans-unit id="b18845c29a07642058d0aa5ccceaac4ae90f9d59" translate="yes" xml:space="preserve">
          <source>Using gcc statement expressions</source>
          <target state="translated">gcc 문 표현식 사용</target>
        </trans-unit>
        <trans-unit id="2fe92cd4a689f7ce76bfa5b984e6c38acace0732" translate="yes" xml:space="preserve">
          <source>Using gcc-3.x (tested with 3.0.4, 3.1, and 3.2) now works out of the box, as do recent gcc-2.9 builds available directly from IBM as part of their Linux compatibility packages, available here:</source>
          <target state="translated">gcc-3.x (3.0.4, 3.1 및 3.2로 테스트)를 사용하면 Linux 호환성 패키지의 일부로 IBM에서 직접 사용할 수있는 최신 gcc-2.9 빌드와 마찬가지로 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb0c9c540b125781f1757da970ccae106c403a1" translate="yes" xml:space="preserve">
          <source>Using gdb to look at specific parts of a program</source>
          <target state="translated">gdb를 사용하여 프로그램의 특정 부분보기</target>
        </trans-unit>
        <trans-unit id="57bf0c1d6a34f5d8784552210b62d448a2b10410" translate="yes" xml:space="preserve">
          <source>Using gdb to look at what the parser/lexer are doing</source>
          <target state="translated">gdb를 사용하여 파서 / 렉서가 수행하는 작업 확인</target>
        </trans-unit>
        <trans-unit id="d623a07c7dcea608be086ca8cc859423db79fbd9" translate="yes" xml:space="preserve">
          <source>Using iPkg has been deprecated on DSM 6, but an alternative is available for DSM 6: entware/opkg. For instructions on how to use that, please read &lt;a href=&quot;https://github.com/Entware-ng/Entware-ng/wiki/Install-on-Synology-NAS&quot;&gt;Install Entware-ng on Synology NAS&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fde3627eec5ec683270fb27481ef8c0d1c38c6" translate="yes" xml:space="preserve">
          <source>Using independent subexpressions to prevent backtracking</source>
          <target state="translated">역 추적을 방지하기 위해 독립적 하위 표현식 사용</target>
        </trans-unit>
        <trans-unit id="e8b9dd4bb8ed97ffb07430ec6d35d6ea3ee41a4b" translate="yes" xml:space="preserve">
          <source>Using just the first character returned by \N{} in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f92a353c503ae2d38c23e8090282fadec8f34c" translate="yes" xml:space="preserve">
          <source>Using just the single character results returned by \p{} in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ab5d33d67aac1b9f2ccad1cbfd447894360c2b" translate="yes" xml:space="preserve">
          <source>Using logically paired delimiters can be even more readable:</source>
          <target state="translated">논리적으로 구분 된 구분 기호를 사용하면 훨씬 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3a44a3d396fc486b4ee2331bfc52809b0dad44df" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test that the contents works:</source>
          <target state="translated">수정하지 않고 내용이 작동하는지 테스트하는 방법 사용 :</target>
        </trans-unit>
        <trans-unit id="b0d1b97f67a06429913567862e9a662a62326468" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test the contents works:</source>
          <target state="translated">수정하지 않고 내용을 테스트하는 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a5aebc39485edc859f77fc91f87d35c5af691252" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but testthe contents works:</source>
          <target state="translated">수정하지 않고 내용을 테스트하는 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3ceb297fd417e76a638eea2b51f025be00a47ad" translate="yes" xml:space="preserve">
          <source>Using minimum thread stack size of #</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5bf5cc7e02027fc347fd5821a540e8a6ddd5c65" translate="yes" xml:space="preserve">
          <source>Using modules that use version.pm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7108a91963b8344d52acb6aff4bb6481258231a" translate="yes" xml:space="preserve">
          <source>Using my() in false conditional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d80ea05e0ed4a3e5f034eecf41875e66394f03f" translate="yes" xml:space="preserve">
          <source>Using negation on a single letter option when bundling is in effect is pointless and will result in a warning.</source>
          <target state="translated">번들링이 적용될 때 단일 문자 옵션에 부정을 사용하면 의미가 없으며 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="67ef0619a31b7410b25402183523bb6bbe8910fd" translate="yes" xml:space="preserve">
          <source>Using non-thread-safe modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d592d89e9701f8203326be192c2ab0972d996bc" translate="yes" xml:space="preserve">
          <source>Using open() for IPC</source>
          <target state="translated">IPC에 open () 사용</target>
        </trans-unit>
        <trans-unit id="f8c56b194bd4e8beff577cc65b3f025dea6a56fa" translate="yes" xml:space="preserve">
          <source>Using perl as shipped with HP-UX</source>
          <target state="translated">HP-UX와 함께 제공되는 perl 사용</target>
        </trans-unit>
        <trans-unit id="543f3ae6c47ff0945f0303be3eebde44d6d34ce3" translate="yes" xml:space="preserve">
          <source>Using perl from HP's porting centre</source>
          <target state="translated">HP 포팅 센터에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="f25d65fa681aba1a3e380720334ce4fec43f73bf" translate="yes" xml:space="preserve">
          <source>Using perl from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b05c58f51293f54962b4c8b3d752fd39e7ea984" translate="yes" xml:space="preserve">
          <source>Using perl to connect to Oracle databases through DBI and DBD::Oracle has caused a lot of people many headaches. Read README.hpux in the DBD::Oracle for much more information. The reason to mention it here is that Oracle requires a perl built with libcl and libpthread, the latter even when perl is build without threads. Building perl using all defaults, but still enabling to build DBD::Oracle later on can be achieved using</source>
          <target state="translated">DBI 및 DBD :: Oracle을 통해 Oracle 데이터베이스에 연결하기 위해 perl을 사용하면 많은 사람들이 많은 두통을 일으켰습니다. 자세한 내용은 DBD :: Oracle에서 README.hpux를 읽으십시오. 여기에 언급 한 이유는 Oracle이 libcl 및 libpthread로 빌드 된 perl을 필요로하기 때문이며, 후자는 perl이 스레드없이 빌드되는 경우에도 마찬가지입니다. 모든 기본값을 사용하여 perl을 빌드하지만 나중에 DBD :: Oracle을 계속 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2126efc34d2ceda4c425a482fb9bb2ca847f69" translate="yes" xml:space="preserve">
          <source>Using perl's built in conversion of &lt;code&gt;0x&lt;/code&gt; notation:</source>
          <target state="translated">펄의 내장 &lt;code&gt;0x&lt;/code&gt; 표기법 변환 사용 :</target>
        </trans-unit>
        <trans-unit id="1d2a5a50232b147e3a169652436928c470a9aa77" translate="yes" xml:space="preserve">
          <source>Using printf formats for non-basic C types</source>
          <target state="translated">비 기본 C 유형에 printf 형식 사용</target>
        </trans-unit>
        <trans-unit id="df5384f5e1467c8d0cf10444a33f9f98d9662cee" translate="yes" xml:space="preserve">
          <source>Using qq(), q(), and qx(), instead of &quot;double quotes&quot;, 'single quotes', and `backticks`, may make one-liners easier to write.</source>
          <target state="translated">&quot;큰 따옴표&quot;, '단일 따옴표'및 '백틱'대신 qq (), q () 및 qx ()를 사용하면 한 줄짜리 문자를 더 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322a6e9972f7fb8edd8295fc130224c62501d62e" translate="yes" xml:space="preserve">
          <source>Using regular expressions in Perl</source>
          <target state="translated">Perl에서 정규 표현식 사용</target>
        </trans-unit>
        <trans-unit id="6fac332e29fd0c799ec1618a5cc40f7221532230" translate="yes" xml:space="preserve">
          <source>Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:</source>
          <target state="translated">작은 따옴표를 구분 기호로 사용하면 펄의 큰 따옴표 보간으로부터 명령을 보호하고 대신 셸로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="17533bb23c45c392541dce8e0a6b13e74ebcae12" translate="yes" xml:space="preserve">
          <source>Using t/harness for testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc76a9390c03f1e1c8d53d3031773d984401877" translate="yes" xml:space="preserve">
          <source>Using the -a switch to &lt;code&gt;branch&lt;/code&gt; will also show the remote tracking branches in the repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29499bfd5b0fcb0c4c62782a738237d398c2bb02" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt; module. This module hides the complexity of the API defined below and comes with a number of &quot;canned&quot; filters that cover some of the common use-cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e361630850aae34ab890ed75be3d3681ddf2f2b5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">라이브러리 에서 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 양식을 예외 트랩으로 사용하면 몇 가지 문제가 있습니다. 현재 논쟁의 여지가있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 상태로 인해 사용자 코드가 설치했을 수 있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 를 트리거하지 않을 수 있습니다. 이 예제에서는 다음과 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 목적으로 &lt;a href=&quot;local&quot;&gt;로컬&lt;/a&gt; $ SIG {__ DIE__} 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1af4f95da6bd74e39669d85ff89a3cba96099269" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">라이브러리 에서 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 양식을 예외 트랩으로 사용하면 몇 가지 문제가 있습니다. 현재 논쟁의 여지가있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 상태로 인해 사용자 코드가 설치했을 수 있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 를 트리거하지 않을 수 있습니다. 이 예제에서는 다음과 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 목적으로 &lt;a href=&quot;functions/local&quot;&gt;로컬&lt;/a&gt; $ SIG {__ DIE__} 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de2169c7a04ae8dba7470fca93fa527b85798dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="1108296e898fc2261dd95f4aa7570d85ddac276e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt; ).</source>
          <target state="translated">Perl 디버거 의 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 명령 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 )을 사용하면 어떤 작업이 오버로드되고 어떤 조상이이 오버로드를 트리거하는지 추론 할 수 있습니다. 만약 말, &lt;code&gt;eq&lt;/code&gt; , 방법을 오버로드 &lt;code&gt;(eq&lt;/code&gt; 디버거에 의해 도시된다. 방법 &lt;code&gt;()&lt;/code&gt; 에 해당합니다 &lt;code&gt;fallback&lt;/code&gt; 이 방법 방송의 존재가이 패키지가 활성화 과부하되었음을 실제로 키 (그리고 그것이 의해 사용되는지 모듈 &lt;code&gt;overload&lt;/code&gt; 의 &lt;code&gt;Overloaded&lt;/code&gt; 기능 ).</target>
        </trans-unit>
        <trans-unit id="aa67b5d2a4e3907ddf928ce915424a8bf19328d4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 기능 사용하기 :</target>
        </trans-unit>
        <trans-unit id="53251a51732562d07b79a04a55bb9b101d155369" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 모든 변수가 올바르게 선언 펄이 특징으로 기존의 다른 오용을 방지하는 것을 프라 그마 보장하지만합니다.</target>
        </trans-unit>
        <trans-unit id="1bda480993361a430b2548cdcd3f02a2d61e7bb5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;In&lt;/code&gt; prefix avoids this ambiguity, so far. But new versions of Unicode continue to add new properties whose names begin with &lt;code&gt;In&lt;/code&gt; . There is a possibility that one of them someday will conflict with your usage. Since this is just a Perl extension, Unicode's name will take precedence and your code will become broken. Also, Unicode is free to add a script whose name begins with &lt;code&gt;In&lt;/code&gt; ; that would cause problems.</source>
          <target state="translated">&lt;code&gt;In&lt;/code&gt; 접두사를 사용하면 지금까지 이러한 모호성을 피할 수 있습니다. 그러나 새로운 버전의 유니 코드는 이름이 &lt;code&gt;In&lt;/code&gt; 로 시작하는 새로운 속성을 계속 추가합니다 . 언젠가 그들 중 하나가 사용과 충돌 할 가능성이 있습니다. 이것은 Perl 확장 일 뿐이므로 유니 코드 이름이 우선하며 코드가 손상됩니다. 또한 유니 코드는 이름이 &lt;code&gt;In&lt;/code&gt; 으로 시작하는 스크립트를 자유롭게 추가 할 수 있습니다 . 문제를 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="26fd47284e729cedc59da500b68930f9ee3e861b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;diagnostics&lt;/code&gt; pragma:</source>
          <target state="translated">은 Using &lt;code&gt;diagnostics&lt;/code&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="6a48fe8770e4bc6343e8f7cc623c071dba07db7d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;eval {}&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;local $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7366bf6040d08d4b8373a9577c95b17583042824" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;hex&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062e9840191a74dbcab03b46006e8ae73c24f2a7" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;m&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c4a3f647e2f5d82357ab39ea92ae98228cc2e0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;nntpstat&lt;/code&gt; command to select by message-id is valid but of questionable value, since a selection by message-id does &lt;b&gt;not&lt;/b&gt; alter the &quot;current article pointer&quot;.</source>
          <target state="translated">message-id로 선택 하면 &quot;현재 기사 포인터&quot;가 변경 되지 &lt;b&gt;않으므로 &lt;/b&gt; &lt;code&gt;nntpstat&lt;/code&gt; 명령을 사용하여 message-id로 선택하는 것은 유효하지만 의심스러운 값 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4aae14539f5087a9705a605bf5b6819cdd4aff20" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;oct&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d6e3a9e702d5a08e56927cb7a997c29fc49a7b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;splain&lt;/code&gt; standalone filter program:</source>
          <target state="translated">은 Using &lt;code&gt;splain&lt;/code&gt; 의 독립형 필터 프로그램을 :</target>
        </trans-unit>
        <trans-unit id="ac36b350bc5c7bff77a8c82b391ccc496e9c5d92" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea33d1eaae8e24543688decd019ec0f69a1f79d" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt; :</source>
          <target state="translated">CPAN 모듈 사용 &lt;code&gt;Bit::Vector&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="802b0f74ea43ba6c90816233a7cb9e542d5ff3eb" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910c0c6f5c0907edc9665e4e606f548cf3f4c360" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt; : clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="translated">위에서 설명한 G_EVAL 플래그를 사용하면 항상 &lt;code&gt;$@&lt;/code&gt; 가 설정됩니다. 오류가 없으면 지우고 호출 된 코드에 오류가 있으면 오류를 설명하도록 설정합니다. 이것은 가능한 오류를 처리하려는 경우 원하는 것이지만 때로는 오류를 잡아서 프로그램의 나머지 부분을 방해하는 것을 막고 싶을 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf237d121731c138e436d867fb340448be7bbc3" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt;: clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece795b73c229ddff7119e1c0d2301ee76d727fb" translate="yes" xml:space="preserve">
          <source>Using the GitHub Pull Request workflow, your patch will automatically be available in a suitable format. If you wish to submit a patch to the p5p list for review, make sure to create it appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c0cbb80720ba82333e9cac242b49c7344290c8" translate="yes" xml:space="preserve">
          <source>Using the O_WRONLY flag.</source>
          <target state="translated">O_WRONLY 플래그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="318651aa0afd4166b844c0395b31d38b0b5bb275" translate="yes" xml:space="preserve">
          <source>Using the copy or the original with overloaded math is okay, e.g. the following work:</source>
          <target state="translated">수학 또는 수학이 오버로드 된 원본을 사용하는 것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="0de692f809342e61f897ad9464158e162341eb3b" translate="yes" xml:space="preserve">
          <source>Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.</source>
          <target state="translated">$ x + = $ y 형식 사용; $ x = $ x + $ y 이상은 두 번째 경우 $ x의 복사본을 만들어야하므로 더 빠릅니다. 숫자가 길면 사본이 최대 20 %의 작품을 먹을 수 있습니다 (더하기 / 빼기의 경우 곱셈 / 나눗셈의 경우). $ y가 $ x에 비해 매우 작 으면 $ x의 복사본을 만드는 데 실제 시간보다 더 많은 시간이 걸리기 때문에 $ x + = $ y 형식은 $ x = $ x + $ y보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5f9ff7254d2f81af60c47b564085e4f9339d27bc" translate="yes" xml:space="preserve">
          <source>Using the low-level API defined below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce214a03a88942751d1032191930fa065fa65dbe" translate="yes" xml:space="preserve">
          <source>Using the same symbol to &lt;code&gt;open()&lt;/code&gt; a filehandle and a dirhandle throws a fatal error as of Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398007f06ed5c26b6393d21585510169a401935b" translate="yes" xml:space="preserve">
          <source>Using the same symbol to open a filehandle and a dirhandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ccaa0444078f2a1b0edccce245e0b394be801a" translate="yes" xml:space="preserve">
          <source>Using the supplied template, create the temporary directory in a standard location for temporary files. Equivalent to doing</source>
          <target state="translated">제공된 템플리트를 사용하여 임시 파일의 표준 위치에 임시 디렉토리를 작성하십시오. 하는 것과 동등</target>
        </trans-unit>
        <trans-unit id="9e2035734d6024304e489d6917a2e574dba468c1" translate="yes" xml:space="preserve">
          <source>Using the syntax &lt;code&gt;MyParser::new()&lt;/code&gt; to invoke the constructor is</source>
          <target state="translated">&lt;code&gt;MyParser::new()&lt;/code&gt; 구문을 사용하여 생성자를 호출하면</target>
        </trans-unit>
        <trans-unit id="38da1db00a7b99c0a13533d364129dc73f4d104a" translate="yes" xml:space="preserve">
          <source>Using the template &lt;code&gt;pat..patend&lt;/code&gt;, this function unpacks the string &lt;code&gt;s..strend&lt;/code&gt; into a number of mortal SVs, which it pushes onto the perl argument (&lt;code&gt;@_&lt;/code&gt;) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb6f03c46c097330bc723d0ffaf6e2dff2e6744" translate="yes" xml:space="preserve">
          <source>Using the template pat..patend, this function unpacks the string s..strend into a number of mortal SVs, which it pushes onto the perl argument (@_) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="translated">템플릿 pat..patend를 사용하여,이 기능은 펄 인수에 밀어 인간의 SV 숫자로 문자열 s..strend 압축을 풉니 다 (@_) 스택 (당신은 실행해야합니다, 그래서 &lt;code&gt;PUTBACK&lt;/code&gt; 전 &lt;code&gt;SPAGAIN&lt;/code&gt; 애프터을 이 함수를 호출하십시오). 푸시 된 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a18622b9f73cf084e1c40515e63402b15a29333" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::bitwise&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::bitwise&lt;/code&gt; 범주의 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="c41fbff9d3dc71a6f8badab26c0a06f0e18953ee" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::const_attr&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::const_attr&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="cc856eaeef355d43fa8953f9faffa4c073431f05" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_subs&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="857c7cbd2ca8ba6b31bcdbf6dd9c2b32441faf23" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_topic&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::lexical_topic&lt;/code&gt; 카테고리에서 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="de44610062c3b08fbff0aea3fd8f765facd544b6" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::postderef&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::postderef&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="e5af3cfd78b8e6f9d0563b3f4cf549f389ec7ba5" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::re_strict&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::re_strict&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="65fcb853c1a517ad8d77449f7c0018250e14485b" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::refaliasing&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::refaliasing&lt;/code&gt; 범주에서 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="37bffd5a63be98cf17b1b1c985d57c2adb638271" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::regex_sets&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::regex_sets&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c0a382b10a1d9a073eb205f7f2bb7818eb3bbf75" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::signatures&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::signatures&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="482e06051ee37583e9eea4d7cca4c50c1fbeaf4e" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::smartmatch&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::smartmatch&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="074c6a2ab43d29315af279e0bad192b2e6bd6e77" translate="yes" xml:space="preserve">
          <source>Using this inside your test tool takes care of a lot of boilerplate for you. It will ensure a context is acquired. It will capture and rethrow any exception. It will insure the context is released when you are done. It preserves the subroutine call context (array, scalar, void).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4359e0b1138dffdeb53a1d3017037757b78671" translate="yes" xml:space="preserve">
          <source>Using this operator can lead to programs that are difficult to port, because the shell commands called vary between systems, and may in fact not be present at all. As one example, the &lt;code&gt;type&lt;/code&gt; command under the POSIX shell is very different from the &lt;code&gt;type&lt;/code&gt; command under DOS. That doesn't mean you should go out of your way to avoid backticks when they're the right way to get something done. Perl was made to be a glue language, and one of the things it glues together is commands. Just understand what you're getting yourself into.</source>
          <target state="translated">이 연산자를 사용하면 호출되는 쉘 명령이 시스템마다 다르고 실제로 존재하지 않을 수 있기 때문에 이식하기 어려운 프로그램으로 이어질 수 있습니다. 하나의 예를 들어, &lt;code&gt;type&lt;/code&gt; 는 POSIX 쉘에서 명령은 매우 다른 &lt;code&gt;type&lt;/code&gt; DOS에서 명령. 그렇다고해서 배신자가 올바른 일을 할 때 올바른 방법으로 배제하지 않도록해야한다는 의미는 아닙니다. 펄은 접착제 언어로 만들어졌으며, 서로 붙어있는 것 중 하나는 명령입니다. 자신이 무엇을하고 있는지 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="b6c986b23b08d817ef2b3ef3edf4922835b01e64" translate="yes" xml:space="preserve">
          <source>Using this pragma to 'enable an experimental feature' is another way of saying that this pragma will disable the warnings which would result from using that feature. Therefore, the order in which pragmas are applied is important. In particular, you probably want to enable experimental features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a37b5dbd299333aab3745e6a99e1cd7583086d" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to &lt;code&gt;gv_fetchsv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d70574aacd1d1847898b08d95988a332169072" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to gv_fetchsv.</source>
          <target state="translated">다양한 bit 빗을 사용하여 SV에서 CV를 얻으십시오. 또한 가능하면 &lt;code&gt;*st&lt;/code&gt; 및 &lt;code&gt;*gvp&lt;/code&gt; 를 스 태쉬 및 GV에 설정하십시오. &lt;code&gt;lref&lt;/code&gt; 의 플래그는 gv_fetchsv 로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="27cc9ed80851550eb53eda865f75d2e008f1dc72" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get an IO from an SV: the IO slot if its a GV; or the recursive result if we're an RV; or the IO slot of the symbol named after the PV if we're a string.</source>
          <target state="translated">다양한 bit 비트를 사용하여 SV에서 IO를 가져 오십시오. GV 인 경우 IO 슬롯; 우리가 RV라면 재귀 적 결과; 또는 문자열 인 경우 PV 이름을 따서 명명 된 심볼의 IO 슬롯.</target>
        </trans-unit>
        <trans-unit id="40c4ad482806895c6f8713969b3ecb705fa44118" translate="yes" xml:space="preserve">
          <source>Using various methods &lt;b&gt;attempt&lt;/b&gt; to find the Fully Qualified Domain Name (FQDN) of the current host. From this determine the host-name and the host-domain.</source>
          <target state="translated">사용하여 다양한 방법 &lt;b&gt;을 시도&lt;/b&gt; 현재 호스트의 정규화 된 도메인 이름 (FQDN)을 찾을 수 있습니다. 여기에서 호스트 이름과 호스트 도메인을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="e11cccd40e08f4d8829656864189eefc5a2d6492" translate="yes" xml:space="preserve">
          <source>Using wildcards on these is resource intensive, given the hundreds of thousands of legal names that must be checked against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984440cafd7acbcbdf562eb5fc6d6acd83d7c5d3" translate="yes" xml:space="preserve">
          <source>Using your favourite browser open the DSM management page and start the Package Center.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892738b2747cec8282f76dab54e62a0b79491609" translate="yes" xml:space="preserve">
          <source>Usual perl lib path (semi-list).</source>
          <target state="translated">일반적인 perl lib 경로 (반 목록).</target>
        </trans-unit>
        <trans-unit id="b7cde133a5ff79130fd30cde6b361d0ab467bd51" translate="yes" xml:space="preserve">
          <source>Usually a hash ref, perhaps like this:</source>
          <target state="translated">일반적으로 다음과 같은 해시 참조 :</target>
        </trans-unit>
        <trans-unit id="ad35f25dce96f5712243ad327f82cc56b137d4d7" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVbyte&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="e38187632a58d32566d4fbc0b71dc22c87d815e2" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="a0ca6cd076c679630ac44632c012203ed79a11ad" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVutf8&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="b020d8f1cda36b9415a539e77cdc15cb72cc9530" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="7c024fdbe2028ca7a62024863c10f1c75039e578" translate="yes" xml:space="preserve">
          <source>Usually called from the object destructor when using the OO interface.</source>
          <target state="translated">일반적으로 OO 인터페이스를 사용할 때 객체 소멸자에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4285fe9b5258e25bc264f1b1a13271726e80e089" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in executing code context.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 코드 컨텍스트 실행시 STRING을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하도록 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b767b699ca666ca195f318b11bb903c3a22cd75" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;eval&lt;/code&gt;-ed in executing code context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026b900ced2773356641f583fde7b62143e57def" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the poststop action string.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 인수가 전달되지 않으면 poststop 조치 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d9b8edd49b4cf562a81e5b8decb5de77fa1afd9" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the prestop action string.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 인수가 전달되지 않으면 사전 중지 조치 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c460ecc82dad59a8d6a90636305608877d8c532" translate="yes" xml:space="preserve">
          <source>Usually programs take command line options as well as other arguments, for example, file names. It is good practice to always specify the options first, and the other arguments last. Getopt::Long will, however, allow the options and arguments to be mixed and 'filter out' all the options before passing the rest of the arguments to the program. To stop Getopt::Long from processing further arguments, insert a double dash &lt;code&gt;--&lt;/code&gt; on the command line:</source>
          <target state="translated">일반적으로 프로그램은 명령 행 옵션과 다른 인수 (예 : 파일 이름)를 사용합니다. 항상 옵션을 먼저 지정하고 다른 인수는 마지막에 지정하는 것이 좋습니다. 그러나 Getopt :: Long은 옵션과 인수를 혼합하고 나머지 인수를 프로그램에 전달하기 전에 모든 옵션을 '필터링'할 수 있습니다. 추가 인수를 처리에서 것은, Getopt :: 롱을 중지하려면, 이중 대시 삽입 &lt;code&gt;--&lt;/code&gt; 명령 줄을 :</target>
        </trans-unit>
        <trans-unit id="2691970d8d342de7ae3956a2783fcd64867158b2" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_catpvf&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="77ebade53997d221a462c627fabe395463a20200" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221ae26d5a59ab131e1ef8287fa9b5a715378994" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5a96fc714b34f71556d82b6c790fd037deaf405" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f47e17c3d0a65f1e24ab46a970720597c10ef39" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt; .</source>
          <target state="translated">보통 프론트 엔드 &lt;code&gt;sv_setpvf&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b4e1489808f355127c321ef07168c767ea9ffc9" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3548cea6e28d55dc32a5bfd0e3189ea93c77d357" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b469233ee2df2f568c9601474bc5743c17d8760" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bb4c004a0f7c4b905c963d10b31ef391b5c334" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 및 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 중 하나를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4c3aa12e3e6daf3bf3f8b843c4e309f3a2e4a62" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f08502c181dd16b4bbf68ae24c29b059d5a1bce" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 및 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 중 하나를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="54fe455ec6ccaaba60c8865419721a15c0826228" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fff94b5e5d0e7b2c191398749185343c2f32a65" translate="yes" xml:space="preserve">
          <source>Usually when a variable is localized you want to make sure that this change affects the shortest scope possible. So unless you are already inside some short &lt;code&gt;{}&lt;/code&gt; block, you should create one yourself. For example:</source>
          <target state="translated">일반적으로 변수가 지역화 된 경우이 변경이 가능한 가장 짧은 범위에 영향을 미치도록하려고합니다. 따라서 짧은 &lt;code&gt;{}&lt;/code&gt; 블록 안에 이미 있지 않은 경우 직접 작성해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="599351f57ec025dcf8b7e2139660d070855a8727" translate="yes" xml:space="preserve">
          <source>Usually you'll want to pack or unpack UTF-8 strings:</source>
          <target state="translated">일반적으로 UTF-8 문자열을 포장하거나 포장을 풀고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf8c2092d45b2a1234c61351a627eb75997a3b4f" translate="yes" xml:space="preserve">
          <source>Usually, the feature can be entirely ignored. Calling</source>
          <target state="translated">일반적으로이 기능은 완전히 무시할 수 있습니다. 부름</target>
        </trans-unit>
        <trans-unit id="3747a1556b1698c5e4df73c06a70d49b29b190d1" translate="yes" xml:space="preserve">
          <source>Usually, these single-character options can be bundled:</source>
          <target state="translated">일반적으로 이러한 단일 문자 옵션은 번들로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff606f5bbdaacc091df7cb49a15e201040dcd56" translate="yes" xml:space="preserve">
          <source>Utah</source>
          <target state="translated">Utah</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="29f83b729f46062c9dd1b32c5a75ee83eb4a8e12" translate="yes" xml:space="preserve">
          <source>Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">C / C ++ 애플리케이션에 Perl을 임베드하기위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="c5c36f1963730a8868662732388dc0c0703a634a" translate="yes" xml:space="preserve">
          <source>Utilities for managing %^H scopes</source>
          <target state="translated">% ^ H 범위 관리를위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="35acf3ef6343308f92e84a6c665aa85cecd79c2b" translate="yes" xml:space="preserve">
          <source>Utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">Makefile 등에서 일반적인 UNIX 명령을 대체하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="1637dc7299266babf67a48df4d48af858929b4bd" translate="yes" xml:space="preserve">
          <source>Utilities to write and check a MANIFEST file</source>
          <target state="translated">MANIFEST 파일을 작성하고 확인하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="8bf056ede57539fe7ab422f88b516c58223a0adf" translate="yes" xml:space="preserve">
          <source>Utility Functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">유틸리티 방법</target>
        </trans-unit>
        <trans-unit id="2ffeb2e1de80e186589b30d3572aa3cf779263b5" translate="yes" xml:space="preserve">
          <source>Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN :: Config 파일 초기화 유틸리티</target>
        </trans-unit>
        <trans-unit id="bc41614ee1aee6d115725273058a3f6ba77aebc5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of capturing buffers in it's current configuration.</source>
          <target state="translated">&lt;code&gt;IPC::Cmd&lt;/code&gt; 가 현재 구성에서 버퍼를 캡처 할 수 있는지 알려주는 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="f378c15ae2f401b4423675b36af5d2e3c5f0b6d5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of providing &lt;code&gt;run_forked&lt;/code&gt; on the current platform.</source>
          <target state="translated">&lt;code&gt;IPC::Cmd&lt;/code&gt; 가 현재 플랫폼에서 &lt;code&gt;run_forked&lt;/code&gt; 를 제공 할 수 있는지 알려주는 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="4bd9fd9b54869479fd1b5ab93786828f7dca29ba" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Open3&lt;/code&gt; is available. If the verbose flag is passed, it will print diagnostic messages if &lt;code&gt;IPC::Open3&lt;/code&gt; can not be found or loaded.</source>
          <target state="translated">&lt;code&gt;IPC::Open3&lt;/code&gt; 을 사용할 수 있는지 알려주는 유틸리티 기능 . verbose 플래그가 전달되면 &lt;code&gt;IPC::Open3&lt;/code&gt; 을 찾거나로드 할 수없는 경우 진단 메시지가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e2f17ef240aba3f9b165b95741ed6655472196e" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451db65a6c9d4e76bfbbd6735fbbae7748464a49" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; 을 사용할 수 있는지 알려주는 유틸리티 기능 . 경우 &lt;code&gt;verbose&lt;/code&gt; 플래그가 전달되는 경우,이 진단 메시지를 출력한다 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: 실행을&lt;/a&gt; 찾거나로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="1f8287a26f238372802990f191fcd97ce4ce1919" translate="yes" xml:space="preserve">
          <source>Utility functions to compare CPAN versions</source>
          <target state="translated">CPAN 버전을 비교하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="5361245b089bc8d03d289e970efd7e683d4ec19f" translate="yes" xml:space="preserve">
          <source>Utility method that performs the reverse of &lt;code&gt;split_addr&lt;/code&gt;, returning a string formed by joining the specified host address and port number. The host address will be wrapped in &lt;code&gt;[]&lt;/code&gt; brackets if required (because it is a raw IPv6 numeric address).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed6d1a25db20e0f87bc8b51d704291bd4012594" translate="yes" xml:space="preserve">
          <source>Utility method that provides the parsing functionality described above. Returns a 2-element list, containing either the split hostname and port description if it could be parsed, or the given address and &lt;code&gt;undef&lt;/code&gt; if it was not recognised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04d18faf6a6212c265fa3f8b28cccfae0335158" translate="yes" xml:space="preserve">
          <source>Utility method that returns Makefile snippet to call &lt;code&gt;Mksymlists&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e944fa11ecc3fc10a3b409bcd5f6df4ebd3f4487" translate="yes" xml:space="preserve">
          <source>Uuencoding</source>
          <target state="translated">Uuencoding</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="b2b5b0afa386d0f6d03efebcc7e6436dddd260b0" translate="yes" xml:space="preserve">
          <source>V [pkg [vars]]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcac8d0d355bfc2539bc51c5b27c73eb9148c07d" translate="yes" xml:space="preserve">
          <source>V6Only =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="41fdf9c71f9b0e67f5d577b57ffb59065472ee6e" translate="yes" xml:space="preserve">
          <source>VAR</source>
          <target state="translated">VAR</target>
        </trans-unit>
        <trans-unit id="b58c19038082c2364b9c1548d2e1a4ec413831d4" translate="yes" xml:space="preserve">
          <source>VARIABLE</source>
          <target state="translated">VARIABLE</target>
        </trans-unit>
        <trans-unit id="b5fcb61029823124da78ad195388293fa0fe55ea" translate="yes" xml:space="preserve">
          <source>VARIABLES</source>
          <target state="translated">VARIABLES</target>
        </trans-unit>
        <trans-unit id="65e8a60ae2734c94b1bca677070b6ce22543b21a" translate="yes" xml:space="preserve">
          <source>VENDORPREFIX</source>
          <target state="translated">VENDORPREFIX</target>
        </trans-unit>
        <trans-unit id="34cfc4300012f78dcac00f29aa2134528b1522e9" translate="yes" xml:space="preserve">
          <source>VERBINST</source>
          <target state="translated">VERBINST</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="1a0e7c6395aa749eb79993b77fe40299cee85e5a" translate="yes" xml:space="preserve">
          <source>VERSION NUMBERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a66beacd54baefba431f2c1d69f2741b3909cfb" translate="yes" xml:space="preserve">
          <source>VERSION SPECIFICATIONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c88937cef0ebe636b7d4a7ab527077c5d199964a" translate="yes" xml:space="preserve">
          <source>VERSION may be either a literal such as v5.24.1, which will be compared to &lt;a href=&quot;perlvar#%24%5EV&quot;&gt;&lt;code&gt;$^V&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$PERL_VERSION&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;), or a numeric argument of the form 5.024001, which will be compared to &lt;a href=&quot;perlvar#%24%5D&quot;&gt;&lt;code&gt;$]&lt;/code&gt;&lt;/a&gt;. An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f189e0805d92e6bfdd489073d1a01e43b46335be" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION은 5.0]과 같은 숫자 인수 ( &lt;code&gt;$]&lt;/code&gt; 와 비교 되거나 v5.6.1 형식의 리터럴 일 수 있으며 &lt;code&gt;$^V&lt;/code&gt; (일명 $ PERL_VERSION)와 비교됩니다 . VERSION이 현재 Perl 인터프리터의 버전보다 큰 경우 예외가 발생합니다. 컴파일시 비슷한 검사를 수행 할 수있는 &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f48ba5d24abaab8495945658838888561f00637" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION은 5.0]과 같은 숫자 인수 ( &lt;code&gt;$]&lt;/code&gt; 와 비교 되거나 v5.6.1 형식의 리터럴 일 수 있으며 &lt;code&gt;$^V&lt;/code&gt; (일명 $ PERL_VERSION)와 비교됩니다 . VERSION이 현재 Perl 인터프리터의 버전보다 큰 경우 예외가 발생합니다. 컴파일시 비슷한 검사를 수행 할 수있는 &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d731ce07b6ab147e73f68aa93bae0038e5c91ec" translate="yes" xml:space="preserve">
          <source>VERSION($need)</source>
          <target state="translated">VERSION($need)</target>
        </trans-unit>
        <trans-unit id="8aab271152b932f50d15f749cb2ad3f6aa388e98" translate="yes" xml:space="preserve">
          <source>VERSION: version of your module</source>
          <target state="translated">버전 : 모듈 버전</target>
        </trans-unit>
        <trans-unit id="cfc1761eb1b4fa057b0d19009a1cacfedb0165ec" translate="yes" xml:space="preserve">
          <source>VERSION_FROM</source>
          <target state="translated">VERSION_FROM</target>
        </trans-unit>
        <trans-unit id="439c8f3808541b8d38659912158a7dbb6e0d7837" translate="yes" xml:space="preserve">
          <source>VERSION_MACRO: which macro represents the version (usually 'VERSION')</source>
          <target state="translated">VERSION_MACRO : 버전을 나타내는 매크로 (일반적으로 'VERSION')</target>
        </trans-unit>
        <trans-unit id="8fb8fe6db13804d93644ada9aadf9577aa7276da" translate="yes" xml:space="preserve">
          <source>VERSION_SYM</source>
          <target state="translated">VERSION_SYM</target>
        </trans-unit>
        <trans-unit id="d46d79d5b527245ae65e82f18ddd3ba603c16976" translate="yes" xml:space="preserve">
          <source>VERSION_SYM: like version but safe for use as an RCS revision number</source>
          <target state="translated">VERSION_SYM : 버전과 유사하지만 RCS 개정 번호로 사용하기에 안전</target>
        </trans-unit>
        <trans-unit id="a850272b9ab78b2a9e2f07713cef8bc188b3ede9" translate="yes" xml:space="preserve">
          <source>VERY ALPHA AND LIKELY TO CHANGE</source>
          <target state="translated">매우 알파 및 변경 가능성</target>
        </trans-unit>
        <trans-unit id="cce163acefa51c5f80357419607cd2acfc9bcda6" translate="yes" xml:space="preserve">
          <source>VIEW.EXE</source>
          <target state="translated">VIEW.EXE</target>
        </trans-unit>
        <trans-unit id="8e5207fffbfb609ac37a389e363f0db0120b9dae" translate="yes" xml:space="preserve">
          <source>VMS</source>
          <target state="translated">VMS</target>
        </trans-unit>
        <trans-unit id="6ad64d23074ae7d322786e62e572397b29888496" translate="yes" xml:space="preserve">
          <source>VMS Software Inc. web site, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</source>
          <target state="translated">VMS Software Inc. 웹 사이트, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2719ba4075d542c93bfa0cdfa52b9abcdd8bf1e2" translate="yes" xml:space="preserve">
          <source>VMS file specification syntax is case-tolerant.</source>
          <target state="translated">VMS 파일 사양 구문은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="731e9eea656f3a7b49847d98fa31bc8bf39060b9" translate="yes" xml:space="preserve">
          <source>VMS has $(MMSQUALIFIERS) which is a listing of all the original command line options. This is used in every invocation of make in the VMS Makefile so PASTHRU should not be necessary. Using PASTHRU tends to blow commands past the 256 character limit.</source>
          <target state="translated">VMS에는 $ (MMSQUALIFIERS)가 있으며 이는 모든 원래 명령 행 옵션의 목록입니다. VMS Makefile에서 make를 호출 할 때마다 사용되므로 PASTHRU가 필요하지 않습니다. PASTHRU를 사용하면 명령이 256 자 제한을 초과하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ff54e8c5dec349cf161af5221feaf07190cd81" translate="yes" xml:space="preserve">
          <source>VMS implementation</source>
          <target state="translated">VMS 구현</target>
        </trans-unit>
        <trans-unit id="044140c726f05d1f569402b05b60683ee5f27ac8" translate="yes" xml:space="preserve">
          <source>VMS is VMS.</source>
          <target state="translated">VMS는 VMS입니다.</target>
        </trans-unit>
        <trans-unit id="19cc64067b9d9a483d87606a5fc200285da5a247" translate="yes" xml:space="preserve">
          <source>VMS support for this process in the current release of Perl is sufficient to handle most extensions. (See the MakeMaker documentation for more details on installation options for extensions.)</source>
          <target state="translated">현재 Perl 릴리스에서이 프로세스에 대한 VMS 지원은 대부분의 확장을 처리하기에 충분합니다. 확장 기능의 설치 옵션에 대한 자세한 내용은 MakeMaker 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b48a2078e8546f59c353d4437730af0e465606" translate="yes" xml:space="preserve">
          <source>VMS systems have a permissions structure that cannot be completely represented in a stat buffer, and unlike on other systems the builtin filetest operators respect this. The &lt;code&gt;File::stat&lt;/code&gt; overloads, however, do not, since the information required is not available.</source>
          <target state="translated">VMS 시스템은 stat 버퍼에 완전히 표현할 수없는 권한 구조를 가지고 있으며 다른 시스템과 달리 내장 파일 테스트 연산자는이를 존중합니다. &lt;code&gt;File::stat&lt;/code&gt; 필요한 정보를 사용할 수없는 때문에 오버로드하지만,하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d55cb5dcb20d55a8b83dc657590161b870f2b37b" translate="yes" xml:space="preserve">
          <source>VMS wants a dot in every file so we can't have one called 'pm_to_blib', it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.</source>
          <target state="translated">VMS는 모든 파일에 점을 원하므로 'pm_to_blib'라는 이름을 가질 수 없으며 'pm_to_blib'가됩니다. MMS / K는 'pm_to_blib'라는 대상이있을 때 'pm_to_blib'를 찾아야한다는 것을 알기에 충분히 똑똑하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e24f5c7bee0e19f011bf4c3aca4390cc4355307" translate="yes" xml:space="preserve">
          <source>VMS::DCLsym</source>
          <target state="translated">VMS::DCLsym</target>
        </trans-unit>
        <trans-unit id="b336ca312fb6b5012bc0f980018b96b39cc5d97a" translate="yes" xml:space="preserve">
          <source>VMS::DCLsym - Perl extension to manipulate DCL symbols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a668d8a9e7c5b2e6ed9bd16636649f0694d2e0" translate="yes" xml:space="preserve">
          <source>VMS::Filespec</source>
          <target state="translated">VMS::Filespec</target>
        </trans-unit>
        <trans-unit id="ce371c18629eb5a2332472099dc4be0f24631603" translate="yes" xml:space="preserve">
          <source>VMS::Filespec - convert between VMS and Unix file specification syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e48439cb0a08d8d733a8d5837af8969bf46574" translate="yes" xml:space="preserve">
          <source>VMS::Stdio</source>
          <target state="translated">VMS::Stdio</target>
        </trans-unit>
        <trans-unit id="8c21bd1897d8287afaceb2b3d0158fb032b5f81b" translate="yes" xml:space="preserve">
          <source>VMS::Stdio - standard I/O functions via VMS extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c0fca2c674b5e61f569c9a2276cbaa83043ca7" translate="yes" xml:space="preserve">
          <source>VMSish defaults for some values.</source>
          <target state="translated">일부 값의 VMSish 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b34e6b4bc196605f4ec9f36bd956bf4d5349e341" translate="yes" xml:space="preserve">
          <source>VOS</source>
          <target state="translated">VOS</target>
        </trans-unit>
        <trans-unit id="3ed32c224bfdeaef83075fa116b0ec438527a823" translate="yes" xml:space="preserve">
          <source>VOS Open-Source Software on the web at &lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt; 웹의 VOS 오픈 소스 소프트웨어</target>
        </trans-unit>
        <trans-unit id="957b3df553f7dff11b930fd1fbc2f8551388c83f" translate="yes" xml:space="preserve">
          <source>VOS perl can emulate Unix filenames with &lt;code&gt;/&lt;/code&gt; as path separator. The native pathname characters greater-than, less-than, number-sign, and percent-sign are always accepted.</source>
          <target state="translated">VOS perl은 경로 구분 기호 로 &lt;code&gt;/&lt;/code&gt; 를 사용 하여 Unix 파일 이름을 에뮬레이션 할 수 있습니다 . 보다 큼,보다 작음, 숫자 기호 및 백분율 기호는 기본 경로 이름 문자가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="228203bd56ca8f33c2e2cf1d51934741f92afc9c" translate="yes" xml:space="preserve">
          <source>VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 VOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="0565b8691c25d546ce54285d2b39e0a691ab1159" translate="yes" xml:space="preserve">
          <source>Valgrind also provides a cachegrind tool, invoked on perl as:</source>
          <target state="translated">Valgrind는 또한 다음과 같이 perl에서 호출되는 cachegrind 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c78c948aba2c03abbf33d21db8439afd4716f2fd" translate="yes" xml:space="preserve">
          <source>Valid $types are &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot; (also &quot;MSDOS&quot; for backwards bug compatibility), &quot;Epoc&quot; and &quot;Unix&quot; (all case-insensitive). If an unrecognized $type is given &quot;Unix&quot; will be assumed.</source>
          <target state="translated">유효한 $ 유형은 &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot;(뒤로 버그 호환성을위한 &quot;MSDOS&quot;), &quot;Epoc&quot;및 &quot;Unix&quot;( 대소 문자를 구분하지 않음). 인식 할 수없는 $ type이 주어지면 &quot;Unix&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d87824790e95edd528ec77ce1248bb255db934ac" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;family&lt;/code&gt; values for IPv4:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7b7334e746218435b347345ba3a54288017b88" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;family&lt;/code&gt; values for IPv6:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1f0874166d8489998a2dabaec65b65aacdc83c" translate="yes" xml:space="preserve">
          <source>Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and R_SETCURSOR.</source>
          <target state="translated">유효한 플래그는 R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE 및 R_SETCURSOR입니다.</target>
        </trans-unit>
        <trans-unit id="123ee2fdc2efc6c40bcd8dcd85325f7aa9fb54a9" translate="yes" xml:space="preserve">
          <source>Valid options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a290db91a18e145de3fd22cf0908d5ffbead566" translate="yes" xml:space="preserve">
          <source>Valid parameters include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544a40b2945362d5c270868a97b7c7b3dac0af34" translate="yes" xml:space="preserve">
          <source>Valid subkeys are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6574cf50e04ff3d08a215fe36df9b5f9360f4ab" translate="yes" xml:space="preserve">
          <source>Valid subkeys include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372003ef32f4fb85add82bd740d0d6f53c484da5" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; .</source>
          <target state="translated">유효한 값은 0-9입니다. &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01ad1474a233203dc1a0399d395439f1248f6024" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fc9756075f953dec67702b67d732830de319ae" translate="yes" xml:space="preserve">
          <source>Valid values are from 1 to 9, where 9 is best compression.</source>
          <target state="translated">유효한 값은 1에서 9까지이며 9는 최상의 압축입니다.</target>
        </trans-unit>
        <trans-unit id="61c0f0c254e06b47f44e05f0b16b8e15856c3b3c" translate="yes" xml:space="preserve">
          <source>Valid values for the file type are the following constants defined by Archive::Tar::Constant:</source>
          <target state="translated">파일 유형에 유효한 값은 Archive :: Tar :: Constant에 의해 정의 된 다음 상수입니다.</target>
        </trans-unit>
        <trans-unit id="e2d14a7d576fe1f87f5d9e8e9cd3b19b9f3883ab" translate="yes" xml:space="preserve">
          <source>Valid values range from 0 to 250, where 0 means use the default value 30.</source>
          <target state="translated">유효한 값의 범위는 0-250입니다. 여기서 0은 기본값 30을 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c5fff5f0da802e753b92748a90cbb8fb80c8fcd" translate="yes" xml:space="preserve">
          <source>Validate CPAN distribution metadata structures</source>
          <target state="translated">CPAN 배포 메타 데이터 구조 검증</target>
        </trans-unit>
        <trans-unit id="180bc31ac1ef2e429fcabdb69a6fabf90167ae43" translate="yes" xml:space="preserve">
          <source>Validate prototype string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ca1a4cda43fbba8ac585879a08c0309c1d20bf" translate="yes" xml:space="preserve">
          <source>Validate that a given string can be parsed as a version object, but doesn't actually perform the parsing. Can use either strict or lax validation rules. Can optionally set a number of hint variables to save the parsing code some time when tokenizing.</source>
          <target state="translated">지정된 문자열을 버전 객체로 구문 분석 할 수 있지만 실제로 구문 분석을 수행하지는 않는지 확인하십시오. 엄격한 또는 느슨한 유효성 검사 규칙을 사용할 수 있습니다. 토큰화할 때 구문 분석 코드를 저장하기 위해 여러 힌트 변수를 선택적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a3f32fae979c719788dc5214614a1ca3e7e4ee" translate="yes" xml:space="preserve">
          <source>Validate the arguments given by the user based on strings, regexes, lists or even subroutines</source>
          <target state="translated">문자열, 정규식, 목록 또는 서브 루틴을 기반으로 사용자가 제공 한 인수의 유효성을 검사합니다</target>
        </trans-unit>
        <trans-unit id="df34a04c181ba88b10ee206f3171d24fb01034c4" translate="yes" xml:space="preserve">
          <source>Validates that the SV contains valid internal structure for a version object. It may be passed either the version object (RV) or the hash itself (HV). If the structure is valid, it returns the HV. If the structure is invalid, it returns NULL.</source>
          <target state="translated">SV에 버전 객체의 유효한 내부 구조가 포함되어 있는지 확인합니다. 버전 오브젝트 (RV) 또는 해시 자체 (HV)로 전달 될 수 있습니다. 구조가 유효하면 HV를 반환합니다. 구조가 유효하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff4094183301726c60c811c9d974ce575c34af6b" translate="yes" xml:space="preserve">
          <source>Validation Tests</source>
          <target state="translated">검증 테스트</target>
        </trans-unit>
        <trans-unit id="4d900f1d051c288e24f709c981e03ccd37adfbbd" translate="yes" xml:space="preserve">
          <source>Value Stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa414ab19e33bf9bd3aaeda3e54cacdb51c904fe" translate="yes" xml:space="preserve">
          <source>Value must be greater than zero. Pass an undef value to disable it:</source>
          <target state="translated">값은 0보다 커야합니다. undef 값을 전달하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="8e360f8bf206de689bb55f1c4b0bd7cddaf9168d" translate="yes" xml:space="preserve">
          <source>Value of %s can be &quot;0&quot;; test with defined()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d46691b36a4cfd8073ccea65b9af59d3d9a938" translate="yes" xml:space="preserve">
          <source>Value of CLI symbol &quot;%s&quot; too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5329eac11375c274bf2934a43944e0d3c65118bd" translate="yes" xml:space="preserve">
          <source>Value slices of arrays and hashes may also be taken with postfix dereferencing notation, with the following equivalencies:</source>
          <target state="translated">배열과 해시의 값 조각은 다음과 같은 동등성으로 접미사 역 참조 표기법으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64d4ce7263370a1b49deef410915f500cf0475d" translate="yes" xml:space="preserve">
          <source>Values are pushed to the scope stack using the &lt;code&gt;ENTER&lt;/code&gt; macro, which begins a new nested scope. Any items pushed to the save stack are then restored at the next nested invocation of the &lt;code&gt;LEAVE&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d49e40c3d7ac176f056540076e808cf6346a547" translate="yes" xml:space="preserve">
          <source>Values are usually referred to by name, or through a named reference. The first character of the name tells you to what sort of data structure it refers. The rest of the name tells you the particular value to which it refers. Usually this name is a single</source>
          <target state="translated">값은 일반적으로 이름으로 또는 명명 된 참조를 통해 참조됩니다. 이름의 첫 문자는 어떤 종류의 데이터 구조를 나타내는 지 알려줍니다. 나머지 이름은 해당 이름이 나타내는 특정 값을 알려줍니다. 보통이 이름은 하나입니다</target>
        </trans-unit>
        <trans-unit id="b95834354d188d1c446139257f83c336e08b30f1" translate="yes" xml:space="preserve">
          <source>Values in this array are magical in numeric context: they compare equal to zero only if the line is not breakable.</source>
          <target state="translated">이 배열의 값은 숫자 컨텍스트에서 마술입니다. 줄을 끊을 수없는 경우에만 0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6e707c7542fd8d8b012efb4bcba22c20e79cddd" translate="yes" xml:space="preserve">
          <source>Values must be either strings with possible glob-style matching, or arrayrefs of strings or hashrefs which follow this pattern recursively.</source>
          <target state="translated">값은 glob 스타일 일치가 가능한 문자열이거나이 패턴을 반복적으로 따르는 문자열 또는 해시 참조의 배열 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9d7f43d25cf7a3a7519ab8b3625879499f1cffcc" translate="yes" xml:space="preserve">
          <source>Values of %meta_add will overwrite any existing metadata in those keys. %meta_merge will be merged with them.</source>
          <target state="translated">% meta_add 값은 해당 키의 기존 메타 데이터를 덮어 씁니다. % meta_merge가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c124848c793b84e7134c4f5b9435a446fc14e9" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="translated">'undef'로 config.sh에 저장된 값은 정의되지 않은 값으로 리턴됩니다. 펄 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명명 된 변수가 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc94d1a671b89ad57f1aa0156b15177125de31bb" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;exists&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cea87cf757286518e1e5c257fb70591a7aa6af7" translate="yes" xml:space="preserve">
          <source>Var</source>
          <target state="translated">Var</target>
        </trans-unit>
        <trans-unit id="a8cc4d7cf8e75840c513ed884704f9fb054bc7c2" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c72503df1f71c887b239158a8be4a2aa4b36a21" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; is not imported%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea9cac689300f159148e8f0a8f2616ca1bb44d6" translate="yes" xml:space="preserve">
          <source>Variable &quot;%s&quot; will not stay shared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7702d043cf3784b9e2c18ba2872555b4d1466f37" translate="yes" xml:space="preserve">
          <source>Variable length lookbehind not implemented in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9adc561121b10d3163cfe0f3b6e1049a68105bd5" translate="yes" xml:space="preserve">
          <source>Variable names</source>
          <target state="translated">변수 이름</target>
        </trans-unit>
        <trans-unit id="5b24debec3e800c2a01f6fe873b50e5c2cfac784" translate="yes" xml:space="preserve">
          <source>Variable names in Perl can have several formats. Usually, they must begin with a letter or underscore, in which case they can be arbitrarily long (up to an internal limit of 251 characters) and may contain letters, digits, underscores, or the special sequence &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. In this case, the part before the last &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; is taken to be a</source>
          <target state="translated">Perl의 변수 이름은 여러 형식을 가질 수 있습니다. 일반적으로 문자 또는 밑줄로 시작해야하며,이 경우 임의로 길 수 있으며 (내부 최대 251 자) 문자, 숫자, 밑줄 또는 특수 시퀀스 &lt;code&gt;::&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 를 포함 할 수 있습니다 . 이 경우 마지막 부분 앞의 &lt;code&gt;::&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="41f1e305cd399af1bab308129c47ec5731d3275e" translate="yes" xml:space="preserve">
          <source>Variable scoping</source>
          <target state="translated">변수 범위</target>
        </trans-unit>
        <trans-unit id="ef32d1f98150e537dbad0f8aeb79c36da9b27e19" translate="yes" xml:space="preserve">
          <source>Variable suicide is when you (temporarily or permanently) lose the value of a variable. It is caused by scoping through my() and local() interacting with either closures or aliased foreach() iterator variables and subroutine arguments. It used to be easy to inadvertently lose a variable's value this way, but now it's much harder. Take this code:</source>
          <target state="translated">변수 자살은 변수의 가치를 (일시적으로 또는 영구적으로) 잃을 때입니다. 클로저 또는 별명 된 foreach () 반복자 변수 및 서브 루틴 인수와 상호 작용하는 my () 및 local ()을 통해 범위를 지정하면 발생합니다. 이런 식으로 실수로 변수의 값을 잃기 쉬웠지만 지금은 훨씬 더 어려워졌습니다. 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="47b3e8f70ad6355e89423e5426ec8864d96b0945" translate="yes" xml:space="preserve">
          <source>Variable syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9595ccfdc2cb14668d7371a6550c9db23eb820fc" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;&lt;a href=&quot;#CLASS&quot;&gt;&quot;CLASS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2B%2B&quot;&gt;&quot;Using XS With C++&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250f3f77348f1daf074babbf51813ae9c5cec2e2" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;CLASS&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;Using XS With C++ in perlxs&lt;/a&gt;.</source>
          <target state="translated">C ++ XSUB에서 오브젝트를 지정하기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 C ++ 객체에 적합한 유형입니다. &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;perlxs에서 &lt;/a&gt; &lt;code&gt;CLASS&lt;/code&gt; 및 C ++와 함께 XS 사용 참조 .</target>
        </trans-unit>
        <trans-unit id="bdd7354af00e561ecb80e253a23ed6bba8978906" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f93b135985c0d3733c8f2cb9adad25487bb3de" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;The RETVAL Variable in perlxs&lt;/a&gt;.</source>
          <target state="translated">XSUB의 리턴 값을 보유하기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 XSUB에 적합한 유형입니다. &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;perlxs의 RETVAL 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca0fab0f8678649996d70b3f1641bab2dc619d79" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt; . See &lt;code&gt;THIS&lt;/code&gt; .</source>
          <target state="translated">C ++ XS 생성자의 클래스 이름을 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 &lt;code&gt;char*&lt;/code&gt; 입니다. 참조 &lt;code&gt;THIS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2610f01c18618f6b4e61ef5579954542f95443b5" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#THIS&quot;&gt;&quot;THIS&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9bc67084c6b4e0d289da64dc494006e6e91346" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;&quot;Variable-length Parameter Lists&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047db5765fb37d513256abe7c3bb231a7730d231" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists in perlxs&lt;/a&gt;.</source>
          <target state="translated">스택의 항목 수를 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;perlxs의 가변 길이 매개 변수 목록&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="f9f90eb2fc40e8b2bdb8fd7693973daf5289f55d" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; 및 &lt;code&gt;XSRETURN&lt;/code&gt; 매크로 에서 사용되는 스택 기본 오프셋을 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . &lt;code&gt;dMARK&lt;/code&gt; 의 매크로 설정 전에 호출 할 필요가 &lt;code&gt;MARK&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="4c4206525b1955922faa9570698fd54c202117dd" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c3d0dfeba1248a5e8fb4920323ae89e710ee04" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3A-Keyword&quot;&gt;&quot;The ALIAS: Keyword&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ae1592070f983485afeb1f94bb9f14e5751687" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되어 변수 를 호출하는 데 사용 된 XSUB의 별명을 표시하는 변수입니다 . &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;별명 : perlxs의 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="262d6897e3f4e2ab273d197b04708a28aa8bbe0f" translate="yes" xml:space="preserve">
          <source>Variable-length Parameter Lists</source>
          <target state="translated">가변 길이 파라미터 목록</target>
        </trans-unit>
        <trans-unit id="09f21e0b72a890b7452c0c80006a5d0fc60da109" translate="yes" xml:space="preserve">
          <source>Variable-length record format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fb38e548a7d57e9341b9693eae82c2cb8b3f6a" translate="yes" xml:space="preserve">
          <source>Variable-length record with fixed control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="ab9c1a29fb6d3de8ef612773205828e2a92ce7d5" translate="yes" xml:space="preserve">
          <source>Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.</source>
          <target state="translated">변수는 Perl에서 &quot;$&quot;, &quot;@&quot;또는 &quot;%&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5694c664526ad480f20d39864f7f31a2f29da553" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt; , such as $_ and &lt;code&gt;sub _&lt;/code&gt; , are still forced into the package &lt;code&gt;main&lt;/code&gt; . See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;The Syntax of Variable Names in perlvar&lt;/a&gt;.</source>
          <target state="translated">밑줄로 시작하는 변수는 패키지 메인에 강제로 사용되었지만 패키지 작성자가 밑줄을 사용하여 개인 변수 및 메소드 이름을 표시하는 것이 더 유용하다고 결정했습니다. 그러나 $ _ 및 &lt;code&gt;sub _&lt;/code&gt; 와 같이 단일 &lt;code&gt;_&lt;/code&gt; 로 이름 지정된 변수 및 함수 는 여전히 패키지 &lt;code&gt;main&lt;/code&gt; 에 강제 적용됩니다 . &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;perlvar의 변수 이름 구문&lt;/a&gt; 도 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="26168dd82bf7b2dc23bdaef3f18e5c1fff057d97" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt;, such as $_ and &lt;code&gt;sub _&lt;/code&gt;, are still forced into the package &lt;code&gt;main&lt;/code&gt;. See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;&quot;The Syntax of Variable Names&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9f29c9ec062e45676786fba6e4ad3c40d0d306" translate="yes" xml:space="preserve">
          <source>Variables can also be marked as shared at compile time by using the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;:shared&lt;/code&gt; 속성 을 사용하여 컴파일 타임에 변수를 공유로 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0033a0c4e8e90fcf27d95fe18f7eaf535322599e" translate="yes" xml:space="preserve">
          <source>Variables created by &lt;code&gt;xsubpp&lt;/code&gt; and &lt;code&gt;xsubpp&lt;/code&gt; internal functions</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 및 &lt;code&gt;xsubpp&lt;/code&gt; 내부 함수로 작성된 변수</target>
        </trans-unit>
        <trans-unit id="2071c5e3d5c20b9e635746474f5973d9034dd205" translate="yes" xml:space="preserve">
          <source>Variables created by xsubpp and xsubpp internal functions</source>
          <target state="translated">xsubpp 및 xsubpp 내부 함수로 작성된 변수</target>
        </trans-unit>
        <trans-unit id="ca450e789c925910d0144b598324f623b886a902" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수 로 패키지의 일부가 아니므로 패키지 이름으로 정규화되지 않습니다. 특히 패키지 변수 (또는 다른 전역)를 어휘로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="56cf64dcca72d1ecb702e55ecfffca62a98a5220" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; only affect code</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 유일한 코드로 선언 된 변수</target>
        </trans-unit>
        <trans-unit id="d3d56dc9a78f42fb7499789e6d98d88210aa03d0" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;my&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f70fed22449adf43a6e36b2bbd2180af0d6323b" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;my&lt;/code&gt; only affect code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ce46af0f21b3569cc5560ba28db507a1c93dca" translate="yes" xml:space="preserve">
          <source>Variables defined outside the &lt;code&gt;eval&lt;/code&gt; and used inside it retain their original UTF-8ness. Everything inside the string follows the normal rules for a Perl program with the given state of &lt;code&gt;use utf8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca248e3be58f6491cbca3baeca1c24e3a843c96" translate="yes" xml:space="preserve">
          <source>Variables related to filehandles</source>
          <target state="translated">파일 핸들 관련 변수</target>
        </trans-unit>
        <trans-unit id="558d3788e0608ddd59e54bc45d3414f4ed7b1e43" translate="yes" xml:space="preserve">
          <source>Variables related to formats</source>
          <target state="translated">형식과 관련된 변수</target>
        </trans-unit>
        <trans-unit id="f14620676ede46dcf2f3ea6fa3c3858d660e5480" translate="yes" xml:space="preserve">
          <source>Variables related to regular expressions</source>
          <target state="translated">정규식 관련 변수</target>
        </trans-unit>
        <trans-unit id="68141fa59316c5490c4a375661890da2077e4814" translate="yes" xml:space="preserve">
          <source>Variables related to the interpreter state</source>
          <target state="translated">인터프리터 상태와 관련된 변수</target>
        </trans-unit>
        <trans-unit id="45bdaa2e59ea64f1b1a54370586faae6f0ef4051" translate="yes" xml:space="preserve">
          <source>Variables set up from &lt;code&gt;$other_hashref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c673dd907946ee700d211969e18c41800f161cd" translate="yes" xml:space="preserve">
          <source>Variables that depend on the currently selected filehandle may be set by calling an appropriate object method on the &lt;code&gt;IO::Handle&lt;/code&gt; object, although this is less efficient than using the regular built-in variables. (Summary lines below for this contain the word HANDLE.) First you must say</source>
          <target state="translated">현재 선택된 파일 핸들에 의존하는 변수는 &lt;code&gt;IO::Handle&lt;/code&gt; 오브젝트 에 대해 적절한 오브젝트 메소드를 호출하여 설정할 수 있지만, 일반 내장 변수를 사용하는 것보다 덜 효율적입니다. (여기에 대한 요약은 HANDLE이라는 단어를 포함합니다.) 먼저 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c75a819ab1d89b1b9557b70b74cda014bda1555" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt;) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt;. This variant is used to emphasize by its name that only ASCII-range characters can return TRUE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438e58bd036b53d85e207095a62e0d34f8fb5fa9" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each). If the input is a number that doesn't fit in an octet, FALSE is returned. (Perl's documentation uses a colloquial definition of Latin-1, to include all code points below 256.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecd9778e510c6c92f9f4175aedb118b27dfcb52" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; is like the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_A&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt;. FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a373bcc3385df5e80bc17d512e29824facb6df" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt; acts exactly like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC&lt;/code&gt; for inputs less than 256, but for larger ones it returns the Unicode classification of the code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874df5512e3694c07df72eff5a9eb4e83beaba23" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt; is exactly like the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_L1&lt;/code&gt; variant, for inputs below 256, but if the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uvchr(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e157f974af404a93fff305d4d8e7f7a16c700432" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt; ) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt; .</source>
          <target state="translated">변형 &lt;code&gt;isFOO_A&lt;/code&gt; (예 : &lt;code&gt;isALPHA_A()&lt;/code&gt; )는 접미사 &lt;code&gt;&quot;_A&quot;&lt;/code&gt; 가없는 기본 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ee9c1e7b92e7d90953ad4f56c51f36c66e7040f2" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivlalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each).</source>
          <target state="translated">변형 &lt;code&gt;isFOO_L1&lt;/code&gt; 은 플랫폼에 Latin-1 (또는 EBCDIC 등가) 문자 집합을 부과합니다. 즉, ASCII는 Latin-1의 하위 집합이므로 ASCII 인 코드 포인트는 영향을받지 않습니다. 그러나 비 ASCII 코드 포인트는 마치 라틴 -1 문자 인 것처럼 처리됩니다. 예를 들어 &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; 은 ASCII 및 EBCDIC의 단어 문자 인 코드 포인트 0xDF와 함께 호출 될 때 true를 반환합니다 (각각 다른 문자를 나타냄).</target>
        </trans-unit>
        <trans-unit id="2ba58c7880e89de07e18f6663de6bf67a770fa3f" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC&lt;/code&gt; is like the &lt;code&gt;isFOO_A&lt;/code&gt; and &lt;code&gt;isFOO_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt; . FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC&lt;/code&gt; 는 &lt;code&gt;isFOO_A&lt;/code&gt; 및 &lt;code&gt;isFOO_L1&lt;/code&gt; 변형 과 유사 하지만 결과는 현재 로케일을 기반으로하며, 이는 이름의 &lt;code&gt;LC&lt;/code&gt; 가 의미하는 것입니다. Perl이 현재 로케일이 UTF-8 로케일임을 판별 할 수 있으면 공개 된 유니 코드 규칙을 사용합니다. 그렇지 않으면 명명 된 분류를 제공하는 C 라이브러리 함수를 사용합니다. 예를 들어 &lt;code&gt;isDIGIT_LC()&lt;/code&gt; UTF-8 로케일이 아닌 경우 는 &lt;code&gt;isdigit()&lt;/code&gt; 호출 결과를 리턴합니다 . 입력이 옥텟에 맞지 않으면 항상 FALSE가 반환됩니다. C 라이브러리 기능에 결함이있는 것으로 알려진 일부 플랫폼에서 Perl은 POSIX 표준의 규칙에 따라 결과를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0cd770db8027add93d163f3958fbe5e0a03fc884" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; 은 isFOO_LC_uvchr 과 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 하지만 입력은 (잘 구성된) UTF-8 인코딩 문자열 ( &lt;code&gt;U8*&lt;/code&gt; 또는 &lt;code&gt;char*&lt;/code&gt; )에 입니다. 문자열에서 첫 번째 (아마 멀티 바이트) 문자의 분류가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="2e2baae040164a854cd256e8bb0078a6be7e0556" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; is like &lt;code&gt;isFOO_LC&lt;/code&gt; , but is defined on any UV. It returns the same as &lt;code&gt;isFOO_LC&lt;/code&gt; for input code points less than 256, and returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 은 isFOO_LC 와 &lt;code&gt;isFOO_LC&lt;/code&gt; 하지만 모든 UV에서 정의됩니다. 256 미만의 입력 코드 포인트에 대해서는 &lt;code&gt;isFOO_LC&lt;/code&gt; 와 동일을 리턴하고, 로케일별로 영향을받지 않는 하드 코딩 된 큰 유니 코드 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ad298897b2ed0cfe491083076d3380e15f29221" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_uni&lt;/code&gt; is like the &lt;code&gt;isFOO_L1&lt;/code&gt; variant, but accepts any UV code point as input. If the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_uni&lt;/code&gt; 는 &lt;code&gt;isFOO_L1&lt;/code&gt; 변형 과 유사 하지만 UV 코드 포인트를 입력으로 허용합니다. 코드 포인트가 255보다 큰 경우 유니 코드 규칙을 사용하여 코드 포인트가 문자 클래스에 있는지 확인합니다. 예를 들어 &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; 은 0x100이 유니 코드로 된 대문자 대문자를 가진 라틴 문자이고 단어 문자이므로 TRUE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a2fc63255fac34edd7ea0e57902967c8c3777dd" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_uni&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_utf8&lt;/code&gt; 은 isFOO_uni 와 &lt;code&gt;isFOO_uni&lt;/code&gt; 하지만 입력은 (잘 구성된) UTF-8 인코딩 문자열 ( &lt;code&gt;U8*&lt;/code&gt; 또는 &lt;code&gt;char*&lt;/code&gt; )에 대한 포인터 입니다. 문자열에서 첫 번째 (아마 멀티 바이트) 문자의 분류가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="786f5e70748cc3ce6d3a4d95eb203e5790a45b20" translate="yes" xml:space="preserve">
          <source>Variant of make you intend to run the generated Makefile with. This parameter lets Makefile.PL know what make quirks to account for when generating the Makefile.</source>
          <target state="translated">생성 된 Makefile을 실행하려는 변형입니다. 이 매개 변수는 Makefile.PL이 Makefile을 생성 할 때 고려해야 할 사항을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="e4e1f2b8b132fbf4e7660ea9944ebd7d3a32964e" translate="yes" xml:space="preserve">
          <source>Variants &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_utf8_safe&lt;/code&gt; are like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_LC_uvchr&lt;/code&gt;, but are used for UTF-8 encoded strings. The two forms are different names for the same thing. Each call to one of these classifies the first character of the string starting at &lt;code&gt;p&lt;/code&gt;. The second parameter, &lt;code&gt;e&lt;/code&gt;, points to anywhere in the string beyond the first character, up to one byte past the end of the entire string. Although both variants are identical, the suffix &lt;code&gt;_safe&lt;/code&gt; in one name emphasizes that it will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return FALSE, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295db905c184e8133af3f2c19a8cc4a4448692b0" translate="yes" xml:space="preserve">
          <source>Variants &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8&lt;/code&gt; and &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_utf8_safe&lt;/code&gt; are like &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;_uvchr&lt;/code&gt;, but are used for UTF-8 encoded strings. The two forms are different names for the same thing. Each call to one of these classifies the first character of the string starting at &lt;code&gt;p&lt;/code&gt;. The second parameter, &lt;code&gt;e&lt;/code&gt;, points to anywhere in the string beyond the first character, up to one byte past the end of the entire string. Although both variants are identical, the suffix &lt;code&gt;_safe&lt;/code&gt; in one name emphasizes that it will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return FALSE, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075be6a60b145b1ce1b874ce5a76b369cdd0b469" translate="yes" xml:space="preserve">
          <source>Various</source>
          <target state="translated">Various</target>
        </trans-unit>
        <trans-unit id="8c77b7455bfd7adea569c5a3c57a2f0f3eeee8c3" translate="yes" xml:space="preserve">
          <source>Various ALLOW flags can be set in &lt;code&gt;flags&lt;/code&gt; to allow (and not warn on) individual types of malformations, such as the sequence being overlong (that is, when there is a shorter sequence that can express the same code point; overlong sequences are expressly forbidden in the UTF-8 standard due to potential security issues). Another malformation example is the first byte of a character not being a legal first byte. See</source>
          <target state="translated">다양는 플래그가 설정 될 수있는 허용 &lt;code&gt;flags&lt;/code&gt; 등의 시퀀스 (동일한 코드 포인트를 나타낼 수 짧은 시퀀스가있을 때 즉, 너무 긴 인 것으로 기형 개별 유형 (및에 경고하지 않음) 할 수 있도록, 너무 긴 시퀀스가 명백히 금지 잠재적 보안 문제로 인해 UTF-8 표준에서). 다른 기형의 예는 유효한 첫 바이트가 아닌 문자의 첫 번째 바이트입니다. 보다</target>
        </trans-unit>
        <trans-unit id="68c0704bdf0a70945d4fb86036dd49b70f248c62" translate="yes" xml:space="preserve">
          <source>Various HP-UX encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07be7bc36dbf55adefbb7fd81ec90050f12f5c8" translate="yes" xml:space="preserve">
          <source>Various Mac encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afddad8d7b065f14bf0be2c971fc90accba56a72" translate="yes" xml:space="preserve">
          <source>Various Unicode Transformation Formats</source>
          <target state="translated">다양한 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="404e3a3ac470d95d1670f966be1334f65704910a" translate="yes" xml:space="preserve">
          <source>Various control characters can be written in C language style: &lt;code&gt;&quot;\n&quot;&lt;/code&gt; matches a newline, &lt;code&gt;&quot;\t&quot;&lt;/code&gt; a tab, &lt;code&gt;&quot;\r&quot;&lt;/code&gt; a carriage return, &lt;code&gt;&quot;\f&quot;&lt;/code&gt; a form feed,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46ffb799e9facca7cf6a41e226c75214fbc1de5" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl%27s-pprivate-structure&quot;&gt;&quot;Perl's pprivate structure&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07521b5f641f36eca327ef3a95aecd1a3cb86300" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl's pprivate structure&lt;/a&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;ANYOF_&lt;/code&gt; 로 시작하는 다양한 플래그가 특수 상황에 사용됩니다. 위의 Latin1 경기와 런타임까지 알려지지 않은 것은 &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl의 개인 구조에&lt;/a&gt; 저장됩니다. .</target>
        </trans-unit>
        <trans-unit id="44c78407657471f7c495761722bd853edd5018b1" translate="yes" xml:space="preserve">
          <source>Various people have made helpful suggestions and contributions, in particular:</source>
          <target state="translated">다양한 사람들이 특히 유용한 제안과 기여를했습니다.</target>
        </trans-unit>
        <trans-unit id="69b7658a42848958a79ee8bd9419cad0dccd5541" translate="yes" xml:space="preserve">
          <source>Various spelling corrections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18054f599f969e2a7425c026d09df10072d24d7" translate="yes" xml:space="preserve">
          <source>Various tools exist for analysing C source code &lt;b&gt;statically&lt;/b&gt;, as opposed to &lt;b&gt;dynamically&lt;/b&gt;, that is, without executing the code. It is possible to detect resource leaks, undefined behaviour, type mismatches, portability problems, code paths that would cause illegal memory accesses, and other similar problems by just parsing the C code and looking at the resulting graph, what does it tell about the execution and data flows. As a matter of fact, this is exactly how C compilers know to give warnings about dubious code.</source>
          <target state="translated">다양한 도구는 C의 소스 코드 분석을 위해 존재 &lt;b&gt;정적&lt;/b&gt; 달리, &lt;b&gt;동적&lt;/b&gt; 코드를 실행하지 않고, 즉,. C 코드를 구문 분석하고 결과 그래프를 보면 리소스 누수, 정의되지 않은 동작, 유형 불일치, 이식성 문제, 잘못된 메모리 액세스를 유발하는 코드 경로 및 기타 유사한 문제를 감지 할 수 있습니다. 그리고 데이터 흐름. 사실, 이것은 C 컴파일러가 모호한 코드에 대해 경고하는 방법을 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cab00905b3a6637e1ac427d0bd8b9c7ea4bd82" translate="yes" xml:space="preserve">
          <source>Various useful techniques for the redirection of STDOUT and STDERR filehandles are explained in &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;.</source>
          <target state="translated">STDOUT 및 STDERR 파일 핸들의 재 지정에 대한 다양한 유용한 기술이 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 및 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="348afb03d84f05d16f7adbc3eb8e693f676f5018" translate="yes" xml:space="preserve">
          <source>Varying slowly compared to something else. (Unfortunately, everything is relatively stable compared to something else, except for certain elementary particles, and we&amp;rsquo;re not so sure about them.) In computers, where things are supposed to vary rapidly, &amp;ldquo;static&amp;rdquo; has a derogatory connotation, indicating a slightly dysfunctional &lt;b&gt;variable&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt;. In Perl culture, the word is politely avoided.</source>
          <target state="translated">다른 것에 비해 천천히 변화. (불행히도, 일부 기본 입자를 제외하고는 모든 것이 다른 것에 비해 상대적으로 안정적이며, 확실하지 않습니다.) 컴퓨터가 빠르게 변해야하는 컴퓨터에서 &quot;정적&quot;은 경멸 적 의미를 나타냅니다. 약간 기능 장애가있는 &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;방법&lt;/b&gt; . 펄 문화에서 단어는 정중하게 피합니다.</target>
        </trans-unit>
        <trans-unit id="e79da3e6021f3a596a78ff3c162722022d2bdea5" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;&quot;Freely available locale definitions&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ffef503f476138b4fff0b28711a4307dd0273e" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;Freely available locale definitions&lt;/a&gt;.)</source>
          <target state="translated">공급 업체 로캘은 악명 높으며 Perl이 제어 할 수없는 코드와 상호 작용하기 때문에 로캘 처리 코드를 테스트하기가 어렵습니다. 따라서 Perl의 로케일 처리 코드도 버그가있을 수 있습니다. 그러나 유니 코드 제공 로케일이 더 우수해야하며 문제점을 정정하는 피드백 메커니즘이 있습니다. &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;자유롭게 사용 가능한 로케일 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae16e585cede929dd5c0d05f2d8d93b4e3c5e1a2" translate="yes" xml:space="preserve">
          <source>Verb pattern '%s' has a mandatory argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c870d3cea184fbea0d2392c9e9ff75220ee8535" translate="yes" xml:space="preserve">
          <source>Verb pattern '%s' may not have an argument in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d32a0f82e0ef391607d7fd073f792ba0310faa2" translate="yes" xml:space="preserve">
          <source>Verbatim Paragraph</source>
          <target state="translated">축 어적 단락</target>
        </trans-unit>
        <trans-unit id="44cdb59b24111362d70f4a8382e75c47d1cd7dc4" translate="yes" xml:space="preserve">
          <source>Verbatim paragraph in NAME section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3c8bdee8d70621828a9acf42235be7b9af6f25" translate="yes" xml:space="preserve">
          <source>Verbatim paragraphs are usually used for presenting a codeblock or other text which does not require any special parsing or formatting, and which shouldn't be wrapped.</source>
          <target state="translated">축약어 단락은 일반적으로 특수 구문 분석이나 형식화가 필요하지 않으며 랩핑되어서는 안되는 코드 블록 또는 기타 텍스트를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="090b72cddab5818af5764dad1f1a558d3f63ccc1" translate="yes" xml:space="preserve">
          <source>Verbose</source>
          <target state="translated">Verbose</target>
        </trans-unit>
        <trans-unit id="d2ed762aa9e6f4a70c69d05cecc69ec96c79f712" translate="yes" xml:space="preserve">
          <source>Verbosity level for PERL5LIB changes (none or v)?</source>
          <target state="translated">PERL5LIB 변경에 대한 상세 레벨 (없음 또는 v)?</target>
        </trans-unit>
        <trans-unit id="b16f50ef11893ee8a56a924cf21f29d6d3384b2d" translate="yes" xml:space="preserve">
          <source>Verbosity level for loading modules (none or v)?</source>
          <target state="translated">모듈 로딩에 대한 상세 레벨 (없음 또는 v)?</target>
        </trans-unit>
        <trans-unit id="7802ad32f0ce92df70c7ae50d17c25d1ff11aa8c" translate="yes" xml:space="preserve">
          <source>Verbs</source>
          <target state="translated">Verbs</target>
        </trans-unit>
        <trans-unit id="ebb91b58aca2ebdb100650ca61a4b135081b8fae" translate="yes" xml:space="preserve">
          <source>Verification of server identity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c786adc4be052262918fbf867ae699f3967bdb1" translate="yes" xml:space="preserve">
          <source>Verifies your POD's correctness</source>
          <target state="translated">POD의 정확성을 확인</target>
        </trans-unit>
        <trans-unit id="d4e18ac1b3adf04f8a64f79e732d6cb231328446" translate="yes" xml:space="preserve">
          <source>Verify that</source>
          <target state="translated">확인</target>
        </trans-unit>
        <trans-unit id="c6d2ae8d70f95ac35eb4f17f52487e3fbb74bfe8" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;ADDRESS&lt;/code&gt; is a legitimate mailing address.</source>
          <target state="translated">&lt;code&gt;ADDRESS&lt;/code&gt; 가 합법적 인 우편 주소인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb149dcdc57c60283abbabea9a1ffc5a9199c209" translate="yes" xml:space="preserve">
          <source>Verify that a device's media is accessible. &lt;code&gt;$pInBuf&lt;/code&gt; and &lt;code&gt;$opOutBuf&lt;/code&gt; should both be &lt;code&gt;[]&lt;/code&gt;. If &lt;code&gt;DeviceIoControl&lt;/code&gt; returns a true value, then the media is currently accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa131b92248ccc3e18a5da63bd932dabad63bce2" translate="yes" xml:space="preserve">
          <source>Verify that the element at index</source>
          <target state="translated">색인의 요소가</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="9ed6f2dc280e11e593f15a2c84216188036d49d7" translate="yes" xml:space="preserve">
          <source>Version 0.14 relied on &lt;code&gt;Test::Builder-&amp;gt;history&lt;/code&gt; which was available in Test::Builder 1.5. Versions 0.12 and 0.13 relied on other Test::Builder internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994d1b0dafb2a784fe9a62de996298af3c56fa67" translate="yes" xml:space="preserve">
          <source>Version 0.17</source>
          <target state="translated">버전 0.17</target>
        </trans-unit>
        <trans-unit id="51506756d2eaaaf5ff900dffa8447ff28ca6442b" translate="yes" xml:space="preserve">
          <source>Version 0.30</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084e67410714ed45209c2fc1829d3b5161821488" translate="yes" xml:space="preserve">
          <source>Version 1.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9296ff9faf64bcbf7077fc94b20c36180a2b81" translate="yes" xml:space="preserve">
          <source>Version 1.0 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.0 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="aebe0ed007174f53947b5cc077294c6b536f56d0" translate="yes" xml:space="preserve">
          <source>Version 1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f58248b430683f1248cf64cbe1e704fe1b1c2aa" translate="yes" xml:space="preserve">
          <source>Version 1.1 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.1 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="b7238b18233914a27637a58322ad1e229a7760ee" translate="yes" xml:space="preserve">
          <source>Version 1.2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b502e3047cfe1751d1d1b7edc28b46bfd3a8d92" translate="yes" xml:space="preserve">
          <source>Version 1.2 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.2 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="f0a22b7c2bfa86efce44888eba679b333a85f9d7" translate="yes" xml:space="preserve">
          <source>Version 1.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0707932557d9b8e2fa8ebb9e9863bf7fee11d96" translate="yes" xml:space="preserve">
          <source>Version 1.3 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.3 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="6bb856fd2cb7a8a4749ea08a96d81eed38d2bee4" translate="yes" xml:space="preserve">
          <source>Version 1.3, 14th Apr 1997</source>
          <target state="translated">버전 1.3, 1997 년 4 월 14 일</target>
        </trans-unit>
        <trans-unit id="ab7ec275a46fb4c5722bac07a75f0a956f8d05bd" translate="yes" xml:space="preserve">
          <source>Version 1.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cdda2fafe15d6a81c70eb22bbe3a4d4d6f2154" translate="yes" xml:space="preserve">
          <source>Version 1.4 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.4 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="e595432938de926793decdb5491565f726cb5632" translate="yes" xml:space="preserve">
          <source>Version 1.x of Devel::PPPort was written by Kenneth Albanowski.</source>
          <target state="translated">Kenneth Albanowski가 Devel :: PPPort 버전 1.x를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="a64e96de79863ac878adbe6d99f0ef3004f7ada2" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (C) 1999, Kenneth Albanowski.</source>
          <target state="translated">버전 1.x, Copyright (C) 1999, Kenneth Albanowski.</target>
        </trans-unit>
        <trans-unit id="a5a2dcb962ed837bde5bb2d230fbf541ca8dd67b" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (c) 1997, Graham Barr.</source>
          <target state="translated">버전 1.x, Copyright (c) 1997, Graham Barr.</target>
        </trans-unit>
        <trans-unit id="57ce28f628abe360a4bb4a57891d0472e82ed0fe" translate="yes" xml:space="preserve">
          <source>Version 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45647cd5610f6e1c8ad80ff8302e3680ebe69bd4" translate="yes" xml:space="preserve">
          <source>Version 2.07 included 2 functions for modifying the internal data: rename_country and alias_code. Both of these could be used only to modify the internal data for country codes.</source>
          <target state="translated">버전 2.07에는 내부 데이터를 수정하기위한 rename_country 및 alias_code의 두 가지 기능이 포함되어 있습니다. 둘 다 국가 코드의 내부 데이터를 수정하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a1c91419a81cd1268ac19dce637a320313655e" translate="yes" xml:space="preserve">
          <source>Version 2.158 (March 13 2015)</source>
          <target state="translated">버전 2.158 (2015 년 3 월 13 일)</target>
        </trans-unit>
        <trans-unit id="0b55da2137d093534a6831714068f7257347e71c" translate="yes" xml:space="preserve">
          <source>Version 2.174</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b76e68914b5b481fce750a4808d6a01e4e0d7a5" translate="yes" xml:space="preserve">
          <source>Version 2.x was ported to the Perl core by Paul Marquess.</source>
          <target state="translated">버전 2.x는 Paul Marquess에 의해 Perl 코어로 이식되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4dfa929b5ee3edcabc4bb1ff1f2299b2ba1ffbf" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2001, Paul Marquess.</source>
          <target state="translated">버전 2.x, Copyright (C) 2001, Paul Marquess.</target>
        </trans-unit>
        <trans-unit id="afb9e5ddc0f066d6e4fe7219b73a7a8e7aeed9fa" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</source>
          <target state="translated">버전 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="2b92364fcb707c868641f18b85e8bb1624050d73" translate="yes" xml:space="preserve">
          <source>Version 3.35</source>
          <target state="translated">버전 3.35</target>
        </trans-unit>
        <trans-unit id="3d13369b73c7cc81fbe5ade842653a9ef9b6978a" translate="yes" xml:space="preserve">
          <source>Version 3.42</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0303ef100e7bd0b627ac0ed92f17d79836c82a" translate="yes" xml:space="preserve">
          <source>Version 3.x was ported back to CPAN by Marcus Holland-Moritz.</source>
          <target state="translated">버전 3.x는 Marcus Holland-Moritz가 CPAN으로 다시 포팅했습니다.</target>
        </trans-unit>
        <trans-unit id="87ba3aa39294d7bd5f976dfda6425a25c0769a48" translate="yes" xml:space="preserve">
          <source>Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</source>
          <target state="translated">버전 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="70ac02d65beabeafc66ef77aabf5e475e6710dac" translate="yes" xml:space="preserve">
          <source>Version 8 Regular Expressions</source>
          <target state="translated">버전 8 정규식</target>
        </trans-unit>
        <trans-unit id="48cef9bff2f0656a9bc016c70489a7f115e54a95" translate="yes" xml:space="preserve">
          <source>Version Formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7aa4af9923c4ea2df786e516b1d91ed097781a" translate="yes" xml:space="preserve">
          <source>Version Object Internals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612fee8b1bdb5ec96c3b958d20d963af408a8ba2" translate="yes" xml:space="preserve">
          <source>Version Range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2d06b1e653eddf67a51c5cfa2fa97d0daba218" translate="yes" xml:space="preserve">
          <source>Version Ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5148ac4d9167ac054bd9f1a1a44dfedd508ff1b8" translate="yes" xml:space="preserve">
          <source>Version Strings</source>
          <target state="translated">버전 문자열</target>
        </trans-unit>
        <trans-unit id="68c98714c821df335863c348a8dc241ec68a74da" translate="yes" xml:space="preserve">
          <source>Version caveat</source>
          <target state="translated">버전주의</target>
        </trans-unit>
        <trans-unit id="434cb8dbdd9890a0a33fe9a437168ab4d0039bc5" translate="yes" xml:space="preserve">
          <source>Version control conflict marker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48de413380b443b457a34140a67e47a478a91517" translate="yes" xml:space="preserve">
          <source>Version number must be a constant number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="7a4b23d2aee6859898d9d8a68bcc2c3cf6b34466" translate="yes" xml:space="preserve">
          <source>Version numbers can be checked like so:</source>
          <target state="translated">버전 번호는 다음과 같이 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5696765a5732e40cf7b383ab040149ef89dddcaa" translate="yes" xml:space="preserve">
          <source>Version numbers must be treated as strings, not numbers. For example, &lt;code&gt;1.200&lt;/code&gt;&lt;b&gt;must not&lt;/b&gt; be serialized as &lt;code&gt;1.2&lt;/code&gt;. Version comparison should be delegated to the Perl &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module, version 0.80 or newer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea6fb41a1f5c2adb11175166f62cfde32e3e36d" translate="yes" xml:space="preserve">
          <source>Version numbers should indicate at least major and minor releases, and possibly sub-minor releases. A major release is one in which most of the functionality has changed, or in which major new functionality is added. A minor release is one in which a small amount of functionality has been added or changed. Sub-minor version numbers are usually used for changes which do not affect functionality, such as documentation patches.</source>
          <target state="translated">버전 번호는 최소한 메이저 릴리스 및 마이너 릴리스를 표시해야합니다. 주 릴리스는 대부분의 기능이 변경되었거나 새로운 주요 기능이 추가 된 릴리스입니다. 부 릴리스는 소량의 기능이 추가되거나 변경된 릴리스입니다. 하위 부 버전 번호는 일반적으로 설명서 패치와 같이 기능에 영향을 미치지 않는 변경에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d33038b68a6d275b70080c4ca40f495c404258ac" translate="yes" xml:space="preserve">
          <source>Version object aware cmp. Both operands must already have been converted into version objects.</source>
          <target state="translated">버전 객체 인식 cmp. 두 피연산자가 이미 버전 객체로 변환되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c1648993be0b2c87b25909c3ffed3198e2670b9" translate="yes" xml:space="preserve">
          <source>Version objects overload the &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators. Perl automatically generates all of the other comparison operators based on those two so all the normal logical comparisons will work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393f932dd60dfc189f6aa33e5b9f83c8dab7f2ef" translate="yes" xml:space="preserve">
          <source>Version objects were added to Perl in 5.10. This module implements version objects for older version of Perl and provides the version object API for all versions of Perl. All previous releases before 0.74 are deprecated and should not be used due to incompatible API changes. Version 0.77 introduces the new 'parse' and 'declare' methods to standardize usage. You are strongly urged to set 0.77 as a minimum in your code, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baa0f9b0929b837aa74bf940a43803481da3864" translate="yes" xml:space="preserve">
          <source>Version string '%s' contains invalid data; ignoring: '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163f83af7c59c73d6987bf0e8d27cefb4ea749cd" translate="yes" xml:space="preserve">
          <source>VersionMessage</source>
          <target state="translated">VersionMessage</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="201083490b52b671353fc4a66b87fa4286ce8a12" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained by perl5 porters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe8bcdb81f192c675970c262f42ae11e468a493" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained with support from Matthew Horsfall (alh).</source>
          <target state="translated">&amp;gt; = 3.22 버전은 Matthew Horsfall (alh)의 지원을 받아 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0e4cacd3bf4b53f4105e538a9024d7fb5c49ec" translate="yes" xml:space="preserve">
          <source>Versions of Perl from 5.002 to 5.003 did use the &lt;code&gt;LC_CTYPE&lt;/code&gt; information if available; that is, &lt;code&gt;\w&lt;/code&gt; did understand what were the letters according to the locale environment variables. The problem was that the user had no control over the feature: if the C library supported locales, Perl used them.</source>
          <target state="translated">5.002에서 5.003까지의 Perl 버전은 사용 가능한 경우 &lt;code&gt;LC_CTYPE&lt;/code&gt; 정보를 사용했습니다. 즉, &lt;code&gt;\w&lt;/code&gt; 는 로캘 환경 변수에 따라 문자가 무엇인지 이해했습니다. 문제는 사용자가 기능을 제어 할 수 없다는 것입니다. C 라이브러리가 로케일을 지원하면 Perl에서이 기능을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="cb93dacee4b958854867faa8071d3b66c095d816" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;use locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot;&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;&quot;Character set modifiers&quot; in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19f78e14eb21b19646ec53e2aa5cba777aaa99b" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="translated">5.004 이전의 Perl 버전은 로케일 정보를 &lt;b&gt;대부분&lt;/b&gt; 무시했습니다. 일반적으로 프로그램 환경에서 다르게 제안하더라도 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로케일 과 유사한 것이 항상 적용되는 것처럼 작동합니다 ( &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale 함수&lt;/a&gt; 참조 ). 기본적으로 Perl은 이전 버전과의 호환성을 위해 여전히이 방식으로 작동합니다. 당신이 로케일 정보에주의로 펄 응용 프로그램을 원하는 경우에, 당신은 &lt;b&gt;해야한다&lt;/b&gt; 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 프라그를 (참조 &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;사용 로케일 프라그를&lt;/a&gt; , 당신은 단지 패턴 매칭을 위해 그렇게하도록 드문 경우에,) 또는 &lt;code&gt;/l&lt;/code&gt; 정규 표현식 수정 그렇게하도록 지시하려면 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 문자 세트 수정 자&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cd42417aaf403d8a849b95358e372d8ab627e926" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.6 would recompile the regular expression for each iteration, even if &lt;code&gt;$pattern&lt;/code&gt; had not changed. The &lt;code&gt;/o&lt;/code&gt; would prevent this by telling Perl to compile the pattern the first time, then reuse that for subsequent iterations:</source>
          <target state="translated">5.6 이전의 Perl 버전은 &lt;code&gt;$pattern&lt;/code&gt; 이 변경되지 않은 경우에도 각 반복에 대한 정규식을 다시 컴파일합니다 . 는 &lt;code&gt;/o&lt;/code&gt; 패턴을 처음 컴파일 펄을 이야기하여이를 방지 할 수, 후속 반복에 대한 것을 다시 :</target>
        </trans-unit>
        <trans-unit id="f19a403596404a81dbbf33862dbf8eb957047276" translate="yes" xml:space="preserve">
          <source>Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder and encoder. The MIME encoder infamously inserted additional spaces or discarded white spaces between consecutive MIME encoded-words, which led to invalid MIME headers produced by this module. The MIME decoder had a tendency to discard white spaces, incorrectly interpret data or attempt to decode Base64 MIME encoded-words as Quoted-Printable. These problems were fixed in version 2.22. It is highly recommended not to use any version prior 2.22!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9f13bce2e40c7034fc84684990b2f382929942" translate="yes" xml:space="preserve">
          <source>Versions prior to 2.24 (part of Encode 2.87) ignored &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt;. The MIME encoder used &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;not strict utf8&lt;/a&gt; encoder for input Unicode strings which could lead to invalid UTF-8 sequences. MIME decoder used also &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;not strict utf8&lt;/a&gt; decoder and additionally called the decode method with a &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; flag (thus user-specified &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; were ignored). Moreover, it automatically croaked when a MIME encoded-word contained unknown encoding. Since version 2.24, this module uses &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;strict UTF-8&lt;/a&gt; encoder and decoder. And &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; are correctly propagated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3862168f946314ea765703eeec887a87938d1f6e" translate="yes" xml:space="preserve">
          <source>Versions prior to perl5.004 had serious security problems with buffer overflows, and in some cases have CERT advisories (for instance, &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</source>
          <target state="translated">perl5.004 이전의 버전은 버퍼 오버 플로우와 관련하여 심각한 보안 문제가 있었으며 경우에 따라 CERT 권고가 있습니다 (예 : &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af88a51473f729bd7efb750c66c484d3ad88aa17" translate="yes" xml:space="preserve">
          <source>Versions up to 2.11 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.11 버전 Copyright (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.11 이후의 변경 사항 Copyright (C) 2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="645570264e1c9b5d4c69c1487a566c0753776ad2" translate="yes" xml:space="preserve">
          <source>Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.13 버전 Copyright (c) 1995-1998 Graham Barr. 판권 소유. 버전 2.13_01 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="df128b7f68ed19de182414be1bd4f1f2d9c6a0b4" translate="yes" xml:space="preserve">
          <source>Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.21 버전 Copyright (c) 1995-1998 Graham Barr. 판권 소유. 버전 2.22 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="230af24ce1338603fae4bdb469b6688c0e4037a9" translate="yes" xml:space="preserve">
          <source>Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr. All rights reserved. Changes in Version 2.25 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.24_1 버전 저작권 (c) 1995-1997 Graham Barr. 판권 소유. 버전 2.25 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="5670a2aa1f7771d1194bac3e8af5f2d1835dd801" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.29_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.29 버전 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.29_01 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="f23d5e96a8b776d3b4630eccbbe42aa010b76c05" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr. All rights reserved. Changes in Version 2.29_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.29_1 버전 저작권 (c) 1995-2006 Graham Barr. 판권 소유. 버전 2.29_2 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="84d20de3782c28252a3c6f7756f86f07da1b04bb" translate="yes" xml:space="preserve">
          <source>Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.31_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.31_1 버전 저작권 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.31_2 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="e46c1089fa8e642aaf026e639393be6e2f9a3f93" translate="yes" xml:space="preserve">
          <source>Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.77_3 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.77_2 버전 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.77_3 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="3e953c4e403299818cc2d2c327160433abe8b2b9" translate="yes" xml:space="preserve">
          <source>Very large code points (above 0x7FFF_FFFF) are considered more problematic than the others that are above the Unicode legal maximum. There are several reasons: they requre at least 32 bits to represent them on ASCII platforms, are not representable at all on EBCDIC platforms, and the original UTF-8 specification never went above this number (the current 0x10FFFF limit was imposed later). (The smaller ones, those that fit into 32 bits, are representable by a UV on ASCII platforms, but not by an IV, which means that the number of operations that can be performed on them is quite restricted.) The UTF-8 encoding on ASCII platforms for these large code points begins with a byte containing 0xFE or 0xFF. The UTF8_DISALLOW_FE_FF flag will cause them to be treated as malformations, while allowing smaller above-Unicode code points. (Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code points, including these, as malformations.) Similarly, UTF8_WARN_FE_FF acts just like the other WARN flags, but applies just to these code points.</source>
          <target state="translated">매우 큰 코드 포인트 (0x7FFF_FFFF 이상)는 유니 코드 법적 최대 값을 초과하는 다른 코드 포인트보다 더 문제가있는 것으로 간주됩니다. 몇 가지 이유가 있습니다. ASCII 플랫폼에서는 32 비트 이상을 나타내야하며 EBCDIC 플랫폼에서는 전혀 표현할 수 없으며 원래 UTF-8 사양은이 수를 초과하지 않았습니다 (현재 0x10FFFF 제한은 나중에 부과됨). (32 비트에 맞는 작은 것들은 ASCII 플랫폼에서는 UV로 표현할 수 있지만 IV로는 표현할 수 없습니다. 즉, 그들에 대해 수행 될 수있는 작업의 수가 상당히 제한되어 있습니다.) UTF-8 인코딩 이러한 큰 코드 포인트에 대한 ASCII 플랫폼에서 0xFE 또는 0xFF를 포함하는 바이트로 시작합니다. UTF8_DISALLOW_FE_FF 플래그는 유니 코드보다 작은 코드 포인트를 허용하면서 기형으로 취급합니다.(물론 UTF8_DISALLOW_SUPER는이를 포함하여 모든 유니 코드 위의 코드 포인트를 기형으로 취급합니다.) 마찬가지로 UTF8_WARN_FE_FF는 다른 WARN 플래그와 동일하게 작동하지만 이러한 코드 포인트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0d5201ccd05c9ec8ec53b6a69352780556eae41" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="translated">유니 코드 데이터를 생성 할 때까지 아무런 변화가 없으므로 작업이 거의 필요하지 않습니다. 가장 중요한 것은 입력을 유니 코드로 얻는 것입니다. 이에 대해서는 이전 I / O 토론을 참조하십시오. 완벽한 유니 코드 지원을 받으려면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )를 스크립트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="08ea2581324def416cf5169b872c3c2b6741d81c" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;use 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb22342c76c7e665931efb33364b8148d2bfea0a" translate="yes" xml:space="preserve">
          <source>Very nearly all Unicode character properties are accessible through regular expressions by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; &quot;doesn't match property&quot; for its negation.</source>
          <target state="translated">거의 모든 유니 코드 문자 속성은 &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot;구문과 &lt;code&gt;\P{}&lt;/code&gt; &quot;properties와 일치하지 않음&quot; 을 사용하여 정규식을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c9d6c4d037708bb7601d0c4b194d48f70b48661" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt;, for example, was equal to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="translated">아마 아닐 것입니다. 어떻게 든 유니 코드 문자를 생성하지 않는 한 이전 동작을 유지해야합니다. 유일한 문제에 대한 그 변경 및 유니 코드의 이전 동작이다 생성 시작할 수있는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 문자 모듈 255 제조 255의 인수 공급 여기서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt; , 예를 들면, 동등했다 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; 또는 &quot;-&quot;(ASCII), 이제 라틴 대문자 L을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ea422331279af5333effb9487f09e40531606795" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;chr()&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;chr(300)&lt;/code&gt;, for example, was equal to &lt;code&gt;chr(45)&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df57364769892c03471ecd89738053fe81083da" translate="yes" xml:space="preserve">
          <source>Very similar to HTML/XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; &quot;entity references&quot;:</source>
          <target state="translated">HTML / XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; 와 매우 유사합니다 . &quot;엔티티 참조&quot;:</target>
        </trans-unit>
        <trans-unit id="88a7cc964078758d646c21f587f22b62e9a2dd56" translate="yes" xml:space="preserve">
          <source>Very useful online reference material:</source>
          <target state="translated">매우 유용한 온라인 참조 자료 :</target>
        </trans-unit>
        <trans-unit id="53cd19bd85b05f2ff6addcc980a9f32c53ce3398" translate="yes" xml:space="preserve">
          <source>Viet Nam</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="955578c91c571b85e0395e0299d31bb8777ee3e2" translate="yes" xml:space="preserve">
          <source>Vietnamese encodings VPS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b34b94e5e74c2375523a735ce4a25a6536b5a0" translate="yes" xml:space="preserve">
          <source>View a few lines of code around the current line.</source>
          <target state="translated">현재 줄 주변의 몇 줄의 코드를 봅니다.</target>
        </trans-unit>
        <trans-unit id="ee53ceb3384ce0d69b124dce7f13e6c99981e32e" translate="yes" xml:space="preserve">
          <source>View existing bug reports at, and submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&lt;/a&gt; 에서 기존 버그 보고서를보고 새 버그, 문제, 패치 등을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="8d75c4c4e8ba2437b93176cc4dca513c1b1a52a8" translate="yes" xml:space="preserve">
          <source>View mailing list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedb02ffcfe21f8ad14403434b6387c1a2701d09" translate="yes" xml:space="preserve">
          <source>Vile</source>
          <target state="translated">Vile</target>
        </trans-unit>
        <trans-unit id="daa603bc60750ae7f5cf9defaca0f136f2e1197a" translate="yes" xml:space="preserve">
          <source>Ville Skytt&amp;auml;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="b6c758d8b473540f59e349acc9e443ca1e9333bd" translate="yes" xml:space="preserve">
          <source>Vincent Pit &amp;lt;perl@profvince.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee82a6b555759727c4e5933e475a065e10be5a6" translate="yes" xml:space="preserve">
          <source>Vipul Ved Prakash &amp;lt;mail AT vipul DOT net&amp;gt; - Helping with debugging</source>
          <target state="translated">Vipul Ved Prakash &amp;lt;mail at vipul DOT net&amp;gt;-디버깅 지원</target>
        </trans-unit>
        <trans-unit id="027fb4bdb28984d493fe1f36eee6d83fe2cd8afe" translate="yes" xml:space="preserve">
          <source>Virginia</source>
          <target state="translated">Virginia</target>
        </trans-unit>
        <trans-unit id="36318ca45973e47d767fba0f44ca703effba7017" translate="yes" xml:space="preserve">
          <source>Virtual parent class for Math::BigInt libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1807aa2e2ce520d4cd7270ad67acbbd88fb6197" translate="yes" xml:space="preserve">
          <source>Visual Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028988d7a45fe46ec8fd41d271d201dc35932db0" translate="yes" xml:space="preserve">
          <source>Visual Perl is a Visual Studio.NET plug-in from ActiveState.</source>
          <target state="translated">Visual Perl은 ActiveState의 Visual Studio.NET 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="386d827cc4ba6b5f42c38cef2abc770e9c36de72" translate="yes" xml:space="preserve">
          <source>Volumes can be drive letters or UNC sharenames (\\server\share).</source>
          <target state="translated">볼륨은 드라이브 문자 또는 UNC 공유 이름 (\\ server \ share) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd2e41fa14b367f9d76d5ff80e04135e1e22ee4" translate="yes" xml:space="preserve">
          <source>Vstrings are not implemented in the version of perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="fedc3a89289968e45dac8fb3352091ab861bbbec" translate="yes" xml:space="preserve">
          <source>W *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb850012f486d3a4b2c62a2ac8a7530c9d93702" translate="yes" xml:space="preserve">
          <source>W expr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26d74df8890b7f659e90425275e4ff437fc0eeb" translate="yes" xml:space="preserve">
          <source>WAIT</source>
          <target state="translated">WAIT</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="97689d5d0ad473b9dbadc8ef4f3007ef3d307a97" translate="yes" xml:space="preserve">
          <source>WARNING! Prior to Perl 5.28 or on a system that does not support thread-safe locale operations, do NOT use this function in a &lt;a href=&quot;threads&quot;&gt;thread&lt;/a&gt;. The locale will change in all other threads at the same time, and should your thread get paused by the operating system, and another started, that thread will not have the locale it is expecting. On some platforms, there can be a race leading to segfaults if two threads call this function nearly simultaneously. This warning does not apply on unthreaded builds, or on perls where &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; exists and is non-zero; namely Perl 5.28 and later compiled to be locale-thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e1ca04b7c3f5c99c009d6c09f17b1dc3b90bfb" translate="yes" xml:space="preserve">
          <source>WARNING! Prior to Perl 5.28 or on a system that does not support thread-safe locale operations, do NOT use this function in a &lt;a href=&quot;threads&quot;&gt;thread&lt;/a&gt;. The locale will change in all other threads at the same time, and should your thread get paused by the operating system, and another started, that thread will not have the locale it is expecting. On some platforms, there can be a race leading to segfaults if two threads call this function nearly simultaneously. This warning does not apply on unthreaded builds, or on perls where &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; exists and is non-zero; namely Perl 5.28 and later unthreaded or compiled to be locale-thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c94abff24468ec74283806394c7e1079287562a" translate="yes" xml:space="preserve">
          <source>WARNING: A variable used as a buffer by &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt;&lt;b&gt;must not be modified&lt;/b&gt; in any way until the IO::Handle is closed or &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt; is called again, or memory corruption may result! Remember that the order of global destruction is undefined, so even if your buffer variable remains in scope until program termination, it may be undefined before the file IO::Handle is closed. Note that you need to import the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; explicitly. Like C, setbuf returns nothing. setvbuf returns &quot;0 but true&quot;, on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">경고 : &lt;code&gt;setbuf&lt;/code&gt; 또는 &lt;code&gt;setvbuf&lt;/code&gt; 에 의해 버퍼로 사용 된 변수 는 IO :: Handle이 닫히거나 &lt;code&gt;setbuf&lt;/code&gt; 또는 &lt;code&gt;setvbuf&lt;/code&gt; 가 다시 호출 될 때까지 어떤 식 으로든 &lt;b&gt;수정해서는 안됩니다. 그렇지 않으면&lt;/b&gt; 메모리 손상이 발생할 수 있습니다! 전역 삭제 순서는 정의되어 있지 않으므로 버퍼 변수가 프로그램 종료까지 범위 내에 있어도 파일 IO :: Handle이 닫히기 전에 정의되지 않을 수 있습니다. 상수 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 명시 적으로 가져와야 합니다. C와 마찬가지로 setbuf는 아무것도 반환하지 않습니다. setvbuf는 성공하면 &quot;0이지만 true&quot;를 반환 하고 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fd94aaa9ebb92abff359a6bbe25198f13a80d2a2" translate="yes" xml:space="preserve">
          <source>WARNING: A variable used as a buffer by &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt;&lt;b&gt;must not be modified&lt;/b&gt; in any way until the IO::Handle is closed or &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt; is called again, or memory corruption may result! Remember that the order of global destruction is undefined, so even if your buffer variable remains in scope until program termination, it may be undefined before the file IO::Handle is closed. Note that you need to import the constants &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt; explicitly. Like C, setbuf returns nothing. setvbuf returns &quot;0 but true&quot;, on success, &lt;code&gt;undef&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c2915b48a50feabe204322fda8dc2bbdf52e7d" translate="yes" xml:space="preserve">
          <source>WARNING: As of the 5.004 release, proper usage of the array and hash access functions requires understanding a few caveats. Some of these caveats are actually considered bugs in the API, to be fixed in later releases, and are bracketed with [MAYCHANGE] below. If you find yourself actually applying such information in this section, be aware that the behavior may change in the future, umm, without warning.</source>
          <target state="translated">경고 : 5.004 릴리스부터 배열 및 해시 액세스 기능을 올바르게 사용하려면 몇 가지주의 사항을 이해해야합니다. 이러한 경고 중 일부는 실제로 API의 버그로 간주되며 이후 릴리스에서 수정되며 아래의 [MAYCHANGE]로 묶습니다. 이 섹션에서 실제로 이러한 정보를 적용하는 것을 발견하면 나중에 경고없이 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="209683d518f52549e286671c6de56b159d3f5040" translate="yes" xml:space="preserve">
          <source>WARNING: Comparing version with unequal numbers of decimal points (whether explicitly or implicitly initialized), may yield unexpected results at first glance. For example, the following inequalities hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cb5952c2334da8ce71a5e3b08759b3487fe96b" translate="yes" xml:space="preserve">
          <source>WARNING: Don't use references as hash keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05aab9ee07d74b03226bac90b4501275a8030a8f" translate="yes" xml:space="preserve">
          <source>WARNING: The IO::Handle::setvbuf() is not available by default on Perls 5.8.0 and later because setvbuf() is rather specific to using the stdio library, while Perl prefers the new perlio subsystem instead.</source>
          <target state="translated">경고 : setvbuf ()는 stdio 라이브러리 사용에 따라 다르고 Perl은 새로운 perlio 하위 시스템을 선호하므로 Perls 5.8.0 이상에서는 IO :: Handle :: setvbuf ()를 기본적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19985e22537400319dbf86c71031d6722bd3ab22" translate="yes" xml:space="preserve">
          <source>WARNING: This variable is strictly for internal use only. Its availability, behavior, and contents are subject to change without notice.</source>
          <target state="translated">경고 :이 변수는 내부 용으로 만 사용됩니다. 가용성, 동작 및 내용은 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d49d38da52bda88d24ca74222cd75784e961a51" translate="yes" xml:space="preserve">
          <source>WARNING: Unicode discourages the use of this function or any of the alternative mechanisms listed in this section (the documentation of &lt;code&gt;compexcl()&lt;/code&gt;), except internally in implementations of the Unicode Normalization Algorithm. You should be using &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; directly instead of these. Using these will likely lead to half-baked results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbfa986b2fb43598295e70fb2ca9f7ae7e83632" translate="yes" xml:space="preserve">
          <source>WARNING: do not use the following unless you *know* &lt;code&gt;off&lt;/code&gt; is within the UTF-8 data pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; *and* that on entry &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is aligned on the first byte of character or just after the last byte of a character.</source>
          <target state="translated">경고 : * know * &lt;code&gt;off&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; * 에 의해 지정된 UTF-8 데이터 내에 있고 * 입력시 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 문자의 첫 번째 바이트에 정렬되거나 문자의 마지막 바이트 바로 뒤에 정렬 되지 않는 한 다음을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8f3ae0bd39963e80fa9556609a8341dd002dea" translate="yes" xml:space="preserve">
          <source>WARNING: do not use the following unless you *know* &lt;code&gt;off&lt;/code&gt; is within the UTF-8 data pointed to by &lt;code&gt;s&lt;/code&gt; *and* that on entry &lt;code&gt;s&lt;/code&gt; is aligned on the first byte of character or just after the last byte of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabc0c60a46a204266038744d94511089efbda7b" translate="yes" xml:space="preserve">
          <source>WARNING: this is new code, use at your own risk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678aa148e87e729dd3e10fce0605ee0538d043a2" translate="yes" xml:space="preserve">
          <source>WARNING: use only if you *know* that the pointers point inside the same UTF-8 buffer.</source>
          <target state="translated">경고 : 포인터가 동일한 UTF-8 버퍼 내부를 가리키는 지 * 알아두면 * 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="163b0dd1ef8e487db793ddc755bf68fdfda1ccf3" translate="yes" xml:space="preserve">
          <source>WARNINGS</source>
          <target state="translated">WARNINGS</target>
        </trans-unit>
        <trans-unit id="991fe4b3587f5bc3956dbdf64cab7946d865d2e1" translate="yes" xml:space="preserve">
          <source>WARRANTY</source>
          <target state="translated">WARRANTY</target>
        </trans-unit>
        <trans-unit id="899abc782023a16c90d026f7662b081d0e5603bf" translate="yes" xml:space="preserve">
          <source>WELCOME to Plan 9 Perl, brave soul!</source>
          <target state="translated">9 펄, 용감한 영혼을 계획하는 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="943f25cc8d7abfb9400129c428f47471a4e77ccc" translate="yes" xml:space="preserve">
          <source>WHAT</source>
          <target state="translated">WHAT</target>
        </trans-unit>
        <trans-unit id="d8c634435f258992c7dbf89bc42a5c10afe89f43" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT &lt;code&gt;DB_File&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;DB_File&lt;/code&gt; 은 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="12d31ef8ed1e17871bcd8516b33cf37c388df2a0" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT &lt;code&gt;DB_File&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e4fe4880a26ca7ed67d03d21e6c8855e324c1e" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT DB_File?</source>
          <target state="translated">DB_File은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bb2cbc236529ba6c03e19171332631741f3a45b7" translate="yes" xml:space="preserve">
          <source>WHAT ARE FACETS?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69dc14e97abf1c2f032d0ecddf4083e210815600" translate="yes" xml:space="preserve">
          <source>WHAT IS A LOCALE</source>
          <target state="translated">로칼은 무엇인가</target>
        </trans-unit>
        <trans-unit id="eb5802049a17176195e43722e4ced1b8fb09cdaf" translate="yes" xml:space="preserve">
          <source>WHAT IS A VERSION?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee62ea74b2ed280ab8d8c51fcc0626b34eaaa438" translate="yes" xml:space="preserve">
          <source>WHAT IS NEW?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7eec36d2c3cf583d0c776054ef24d9f2ed0ea" translate="yes" xml:space="preserve">
          <source>WHAT NEXT?</source>
          <target state="translated">다음은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f60e480d83f28578fb3dbf8c978d35dfcb42e486" translate="yes" xml:space="preserve">
          <source>WHENCE=0 (SEEK_SET)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0fe6299ae8442d783daf2df69a8280af3c212a" translate="yes" xml:space="preserve">
          <source>WHENCE=1 (SEEK_CUR)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f29ab5ac9903a080d3f378d4a8806da7247a04b" translate="yes" xml:space="preserve">
          <source>WHENCE=2 (SEEK_END)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f400a201f25780fb9e0a0caa8053f3dac800fbe" translate="yes" xml:space="preserve">
          <source>WHERE IS THE DATA STORED?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31a09e4a44017984cab9426a275543f91816385" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt;</source>
          <target state="translated">항상 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야하는&lt;/a&gt; 이유</target>
        </trans-unit>
        <trans-unit id="761a1531e62fa364bf292e45dfe0cf1d0ec041d6" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS &lt;code&gt;use strict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf4ad6d76037668ee7377a5088288d629d80a03" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS use strict</source>
          <target state="translated">항상 엄격하게 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="7836d14ed49f7f915caabfbf55f88d40c3534ae0" translate="yes" xml:space="preserve">
          <source>WIDEST_UTYPE</source>
          <target state="translated">WIDEST_UTYPE</target>
        </trans-unit>
        <trans-unit id="dea5d6976f7c54b48ff5d6c539121232f52092ef" translate="yes" xml:space="preserve">
          <source>WILDCARD</source>
          <target state="translated">WILDCARD</target>
        </trans-unit>
        <trans-unit id="0c43129d9d0d186b4b0f362b87e153eb3ddb2224" translate="yes" xml:space="preserve">
          <source>WINSOCK</source>
          <target state="translated">WINSOCK</target>
        </trans-unit>
        <trans-unit id="f522c7304362d47837e7d7d72df20f33bb5c3578" translate="yes" xml:space="preserve">
          <source>WITH_LC_NUMERIC_SET_TO_NEEDED</source>
          <target state="translated">WITH_LC_NUMERIC_SET_TO_NEEDED</target>
        </trans-unit>
        <trans-unit id="2e8799ba5f44ad5295f36b8a4e9fd2c7bd21d464" translate="yes" xml:space="preserve">
          <source>WITH_LC_NUMERIC_SET_TO_NEEDED_IN</source>
          <target state="translated">WITH_LC_NUMERIC_SET_TO_NEEDED_IN</target>
        </trans-unit>
        <trans-unit id="89237cfda70e873f323e7dd25612ea5b444530a5" translate="yes" xml:space="preserve">
          <source>WIZARDS ONLY</source>
          <target state="translated">마법사 만</target>
        </trans-unit>
        <trans-unit id="612951b55eb7373e18b643aac58cf8c1af06a81c" translate="yes" xml:space="preserve">
          <source>WORKING WITH CPAN.pm BEHIND FIREWALLS</source>
          <target state="translated">방화벽 뒤에서 CPAN.pm을 사용한 작업</target>
        </trans-unit>
        <trans-unit id="c44674d622af74bf01f71c0df330675b8fc538a5" translate="yes" xml:space="preserve">
          <source>WORKING WITH THE REPOSITORY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d256f0190bf5f3f616a8b6b96bb25f26aee3704" translate="yes" xml:space="preserve">
          <source>WORKS BUT TESTS WILL FAIL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa72ff97b7ec5cf699db7cbbd19331d50b9d05b4" translate="yes" xml:space="preserve">
          <source>WRAP EXISTING TOOLS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999a14026114357b2720836f701f7f83d4e769ea" translate="yes" xml:space="preserve">
          <source>WRAP YOUR OWN</source>
          <target state="translated">자신의 랩</target>
        </trans-unit>
        <trans-unit id="0e5f01bd0e09cde662071352f1c22bdfa112d527" translate="yes" xml:space="preserve">
          <source>WRITE ACCESS TO THE GIT REPOSITORY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb69a08877950ac2cabf9586223967dbe69ff05" translate="yes" xml:space="preserve">
          <source>WRITE this, LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823cf783387b0921711ea7224e7f8f9852646895" translate="yes" xml:space="preserve">
          <source>WRITE this, scalar, length, offset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66af5a28971a4c6868ba337400ea0c92dd22295d" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER</source>
          <target state="translated">소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="0d91186f3fc1a27893403674a7abb0832febe2cf" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN C</source>
          <target state="translated">C에서 소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="1cd7808a59ef1fb929041296bd5ead5a0b08527e" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN PERL</source>
          <target state="translated">PERL로 소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="7cf837e27caaabc83bda33a0709b22a63a97d222" translate="yes" xml:space="preserve">
          <source>WRITING A TOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ed72ea4948106f20d22be7d4795a45bc81908a" translate="yes" xml:space="preserve">
          <source>WRITING DRIVERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f33f4557886e9a55139159f018449074d30de1b" translate="yes" xml:space="preserve">
          <source>WRITING PLUGINS</source>
          <target state="translated">쓰기 플러그인</target>
        </trans-unit>
        <trans-unit id="f05feec7da7a332163ae2b9ada28efac30939640" translate="yes" xml:space="preserve">
          <source>WTF is going on here?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a3f436dd9eb993df939861bd779d6edde94632" translate="yes" xml:space="preserve">
          <source>WYSIWYG</source>
          <target state="translated">WYSIWYG</target>
        </trans-unit>
        <trans-unit id="34dbd5c4c8a64801891d960b57133767c3104fe7" translate="yes" xml:space="preserve">
          <source>Wait</source>
          <target state="translated">Wait</target>
        </trans-unit>
        <trans-unit id="975f1891ff79af7de3d437f83af46051523ae8be" translate="yes" xml:space="preserve">
          <source>Wait a bit. The PAUSE admins don't want to act too quickly in case the current maintainer is on holiday. If there's no response to private communication or the public post, a PAUSE admin can transfer it to you.</source>
          <target state="translated">조금만 기다려 PAUSE 관리자는 현재 관리자가 휴일 인 경우 너무 빨리 행동하기를 원하지 않습니다. 비공개 커뮤니케이션 또는 공개 게시물에 응답이 없으면 PAUSE 관리자가이를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15314082ca8a524c0f28646da09da9a7b2b19503" translate="yes" xml:space="preserve">
          <source>Wait for a child process to change state. This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스가 상태를 변경할 때까지 기다리십시오. 이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cdfff8c0c2da9db775855d389b5ae3a04a93b78" translate="yes" xml:space="preserve">
          <source>Wait for a child process to change state. This is identical to Perl's builtin &lt;code&gt;waitpid()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#waitpid&quot;&gt;&quot;waitpid&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f8c391ec2d3f6164371190f831fbafeb81843a" translate="yes" xml:space="preserve">
          <source>Wait for a message to arive at the port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35026d04db5ceaa6a2182c2ffc6eee263aafcff" translate="yes" xml:space="preserve">
          <source>Wait on a signal set with optional timeout. The result ($signals) should be checked to determine which signal was raised. It will be 0 for timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc282e6beae9c158a75481f83c57c80668be2a" translate="yes" xml:space="preserve">
          <source>Wait until record is available, if currently locked by another stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cf131695c42ff802839eee6d284c2ac7d67182" translate="yes" xml:space="preserve">
          <source>Waiting For A Thread To Exit</source>
          <target state="translated">스레드가 종료되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="e3ebec26983a17c27a53a6ef7e86c4cba507cfab" translate="yes" xml:space="preserve">
          <source>Waiting for a Condition</source>
          <target state="translated">조건을 기다리는 중</target>
        </trans-unit>
        <trans-unit id="4fad8a3271d8da06df3b86b2c5fe59d52ab9c3c9" translate="yes" xml:space="preserve">
          <source>Waiting is turned on by default. Waiting will cause the parent process/thread to wait until all child processes and threads are finished before exiting. You will almost never want to turn this off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbebb4e5fbea810a41b79edfc44a1469a56aab0e" translate="yes" xml:space="preserve">
          <source>Waits for a particular child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there is no such child process. A non-blocking wait (with &lt;a href=&quot;posix#WNOHANG&quot;&gt;WNOHANG&lt;/a&gt; in FLAGS) can return 0 if there are child processes matching PID but none have terminated yet. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a039b2b9c5bcec1c837f18b2a777a3cf1a5c101d" translate="yes" xml:space="preserve">
          <source>Waits for a particular child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there is no such child process. On some systems, a value of 0 indicates that there are processes still running. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . If you say</source>
          <target state="translated">특정 자식 프로세스가 종료되기를 기다렸다가 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. 일부 시스템에서 값이 0이면 프로세스가 여전히 실행 중임을 나타냅니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . 당신이 말하는 경우</target>
        </trans-unit>
        <trans-unit id="9d2d2ea3d50db6c0193c946021247ef1ef74c98a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">Perl 구문 트리를 둘러보고 op에 대한 간결한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="98ac99324db8fed0af8f3ac36eac780a0f3b01c7" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">Ops에 대한 디버그 정보를 인쇄하여 Perl 구문 트리를 걷습니다.</target>
        </trans-unit>
        <trans-unit id="7431af4c5a7328a3a156e7686791a7345dc2386a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">Perl 구문 트리를 살펴보고 op에 대한 간결한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a864d880f623d2740f245bfcfe987603dc895c7a" translate="yes" xml:space="preserve">
          <source>Walk the symbol table starting at SYMREF and call METHOD on each symbol (a B::GV object) visited. When the walk reaches package symbols (such as &quot;Foo::&quot;) it invokes RECURSE, passing in the symbol name, and only recurses into the package if that sub returns true.</source>
          <target state="translated">SYMREF에서 시작하는 심볼 테이블을 걷고 방문한 각 심볼 (B :: GV 객체)에 대해 METHOD를 호출하십시오. Walk가 패키지 기호 (예 : &quot;Foo ::&quot;)에 도달하면 RECURSE를 호출하고 기호 이름을 전달하고 해당 하위가 true를 반환하는 경우에만 패키지로 재귀합니다.</target>
        </trans-unit>
        <trans-unit id="8c7c87239fc66d9d343f9260489e69fb8f9d3386" translate="yes" xml:space="preserve">
          <source>Walking through a zip file</source>
          <target state="translated">zip 파일을 통해 걷기</target>
        </trans-unit>
        <trans-unit id="4e8d79fb203d74f77c4bb0a86a3b744deaaf0e27" translate="yes" xml:space="preserve">
          <source>Wanting to explore this thoroughly, we want to use the stdio &lt;code&gt;fputs()&lt;/code&gt; on a PerlIO *. This means we have to ask the perlio system for a stdio &lt;code&gt;FILE *&lt;/code&gt; :</source>
          <target state="translated">이것을 철저히 탐구하기 위해 PerlIO *에서 stdio &lt;code&gt;fputs()&lt;/code&gt; 를 사용하고 싶습니다 . 이것은 perlio 시스템에 stdio &lt;code&gt;FILE *&lt;/code&gt; : 을 요청해야한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ddb9d78c7601cd47bef87e3a8d1703d450fc174a" translate="yes" xml:space="preserve">
          <source>Wanting to explore this thoroughly, we want to use the stdio &lt;code&gt;fputs()&lt;/code&gt; on a PerlIO *. This means we have to ask the perlio system for a stdio &lt;code&gt;FILE *&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65120e633a3335709be4eae387234d4db4add102" translate="yes" xml:space="preserve">
          <source>Warn on exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ff4de53d3fe3ffe55031beb5fa9d320e5a35d7" translate="yes" xml:space="preserve">
          <source>Warn on implicit encoding conversions</source>
          <target state="translated">암시 적 인코딩 변환에 대한 경고</target>
        </trans-unit>
        <trans-unit id="418df7742f5ac900627eefeef667634c85cc08a0" translate="yes" xml:space="preserve">
          <source>Warn()</source>
          <target state="translated">Warn()</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="5e95a54cc5d29c0bcc82593871bdfa68f79221af" translate="yes" xml:space="preserve">
          <source>Warning about Output Arguments</source>
          <target state="translated">출력 인수에 대한 경고</target>
        </trans-unit>
        <trans-unit id="78a452b501be745d32ffe67fa7b1df3549ee0e88" translate="yes" xml:space="preserve">
          <source>Warning and Dieing</source>
          <target state="translated">경고 및 사망</target>
        </trans-unit>
        <trans-unit id="3986e72de01daed13d3e70510168ee3fa7188cc1" translate="yes" xml:space="preserve">
          <source>Warning messages are not collected in this variable. You can, however, set up a routine to process warnings by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; as described in &lt;a href=&quot;#%25SIG&quot;&gt;&quot;%SIG&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62cd761838ae197b4220edd9e3bd0f69c6d3c92" translate="yes" xml:space="preserve">
          <source>Warning messages are not collected in this variable. You can, however, set up a routine to process warnings by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; as described in &lt;a href=&quot;#%25SIG&quot;&gt;%SIG&lt;/a&gt;.</source>
          <target state="translated">이 변수에는 경고 메시지가 수집되지 않습니다. 그러나 &lt;a href=&quot;#%25SIG&quot;&gt;% SIG에&lt;/a&gt; 설명 된대로 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 을 설정하여 경고를 처리하는 루틴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="177f43f40d5a0d1c0d1cade54f6a793d7b628bd1" translate="yes" xml:space="preserve">
          <source>Warning on &lt;code&gt;\1&lt;/code&gt; Instead of &lt;code&gt;$1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fb45b9b8c6b7b341ac8191e822e0bd743414ee" translate="yes" xml:space="preserve">
          <source>Warning on \1 Instead of $1</source>
          <target state="translated">$ 1 대신 \ 1에 대한 경고</target>
        </trans-unit>
        <trans-unit id="151e71b95baa6e558c89aa6c4dcb9635e2009b86" translate="yes" xml:space="preserve">
          <source>Warning! The accuracy</source>
          <target state="translated">경고! 정확성</target>
        </trans-unit>
        <trans-unit id="dab0c499dcd06e930b9b78c9e213ee3924e2052e" translate="yes" xml:space="preserve">
          <source>Warning: If &lt;code&gt;SvCUR&lt;/code&gt; is equal to &lt;code&gt;SvLEN&lt;/code&gt; , then &lt;code&gt;SvEND&lt;/code&gt; points to unallocated memory.</source>
          <target state="translated">경고 : 경우 &lt;code&gt;SvCUR&lt;/code&gt; 이 동일 &lt;code&gt;SvLEN&lt;/code&gt; , 다음 &lt;code&gt;SvEND&lt;/code&gt; 할당되지 않은 메모리를 가리키는.</target>
        </trans-unit>
        <trans-unit id="0974493779dafc7e57ac71d562dfab60f76d71ea" translate="yes" xml:space="preserve">
          <source>Warning: If &lt;code&gt;SvCUR&lt;/code&gt; is equal to &lt;code&gt;SvLEN&lt;/code&gt;, then &lt;code&gt;SvEND&lt;/code&gt; points to unallocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdc8cc6818456815e1d0494f24351d811145d85" translate="yes" xml:space="preserve">
          <source>Warning: Use of &quot;%s&quot; without parentheses is ambiguous</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897e60f42bffb44a74b7eeefd8312eec6b6adc82" translate="yes" xml:space="preserve">
          <source>Warning: What follows is an experimental feature.</source>
          <target state="translated">경고 : 다음은 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="3d90a55578395474fdb067a0642c6c8de7badf12" translate="yes" xml:space="preserve">
          <source>Warning: something's wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8de18035aca70c8dfa181a9a2f5d6af3e09a08" translate="yes" xml:space="preserve">
          <source>Warning: syntactical care is required when sorting the list returned from a function. If you want to sort the list returned by the function call &lt;code&gt;find_records(@key)&lt;/code&gt; , you can use:</source>
          <target state="translated">경고 : 함수에서 반환 된 목록을 정렬 할 때는 구문 관리가 필요합니다. 함수 호출 &lt;code&gt;find_records(@key)&lt;/code&gt; 에서 리턴 한 목록을 정렬하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae34924595ac7e52988d28d8e637ae6b35f169b" translate="yes" xml:space="preserve">
          <source>Warning: syntactical care is required when sorting the list returned from a function. If you want to sort the list returned by the function call &lt;code&gt;find_records(@key)&lt;/code&gt;, you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5108285f53caf36c4da1bf90b62aacb88666b29e" translate="yes" xml:space="preserve">
          <source>Warning: the inst_perl: target will most probably overwrite your existing perl binary. Use with care!</source>
          <target state="translated">경고 : inst_perl : 대상은 대부분 기존 perl 바이너리를 덮어 씁니다. 조심해서 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="dcb788686e262ffd0dbd7ce4c0f8b286c9bc209c" translate="yes" xml:space="preserve">
          <source>Warning: unable to close filehandle %s properly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c623d9da250d1d3baf0fc1865c1c269866707421" translate="yes" xml:space="preserve">
          <source>Warning: unable to close filehandle %s properly: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b8a6152044437878fd32b30b892373be87bfc0" translate="yes" xml:space="preserve">
          <source>Warning: unable to close filehandle properly: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="cd781cfd6561f1847315b32c68e5aa6443ed0ce1" translate="yes" xml:space="preserve">
          <source>Warnings about floating-point overflow when compiling Perl on Tru64</source>
          <target state="translated">Tru64에서 Perl을 컴파일 할 때 부동 소수점 오버플로에 대한 경고</target>
        </trans-unit>
        <trans-unit id="f781ae9f2ff2acd0ab91c312289ece490360983a" translate="yes" xml:space="preserve">
          <source>Warnings are issued and the file skipped if &lt;code&gt;AutoSplit&lt;/code&gt; cannot locate either the</source>
          <target state="translated">&lt;code&gt;AutoSplit&lt;/code&gt; 이 다음 중 하나를 찾을 수 없으면 경고가 표시되고 파일을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="931a49d01050aa1b2755e3ac6bcc484cb7da972d" translate="yes" xml:space="preserve">
          <source>Warnings dispatched from perl itself (or more accurately, those that match descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;) are only displayed once (no duplicate descriptions). User code generated warnings a la warn() are unaffected, allowing duplicate user messages to be displayed.</source>
          <target state="translated">perl 자체 (또는보다 정확하게는 &lt;a href=&quot;perldiag&quot;&gt;perldiag의&lt;/a&gt; 설명과 일치하는 경고)에서 전달 된 경고는 한 번만 표시됩니다 (중복 설명 없음). 사용자 코드 생성 경고 la warn ()은 영향을받지 않으므로 중복 된 사용자 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a6430c53bc65107aa5413603aa9d5ae883fbaa" translate="yes" xml:space="preserve">
          <source>Warnings import function</source>
          <target state="translated">경고 가져 오기 기능</target>
        </trans-unit>
        <trans-unit id="c2ae6895b901f6f499e198f2b33c31bd733ed306" translate="yes" xml:space="preserve">
          <source>Warnings of other C compilers</source>
          <target state="translated">다른 C 컴파일러의 경고</target>
        </trans-unit>
        <trans-unit id="b7138d6fa7c0b17bdce29490d5c36d00f35c9b8a" translate="yes" xml:space="preserve">
          <source>Warns the contents of &lt;code&gt;$@&lt;/code&gt; if any.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
