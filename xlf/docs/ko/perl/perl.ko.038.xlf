<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2a754fbd5a5705920e61152dd8c6911b9ca9d965" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script without &quot;magic&quot; line, and &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; is set to shell;</source>
          <target state="translated">system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; 에 의해 호출 된 실행 파일 이 &quot;magic&quot;줄이없는 스크립트이고 &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; 이 shell로 설정되어있는 경우;</target>
        </trans-unit>
        <trans-unit id="6143c4a0521be912f40be9869aedf7b75cf3c5aa" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is not found (is not this remark obsolete?);</source>
          <target state="translated">system () / exec () / pipe-open () / &lt;code&gt;``&lt;/code&gt; 에 의해 호출 된 실행 파일을 찾을 수없는 경우 (이 설명은 더 이상 사용되지 않습니까?);</target>
        </trans-unit>
        <trans-unit id="50b9d8b532d25e89b151dc2833716077761d9468" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt; . Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">사용 된 종료 상태가 2보다 작 으면 출력이 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄됩니다 . 그렇지 않으면 출력이 &lt;code&gt;STDERR&lt;/code&gt; 에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6254e53f84fb9e366ade9a7d71888f7244075a2" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt;. Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">사용 된 종료 상태가 2 미만이면 출력이 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄됩니다 . 그렇지 않으면 &lt;code&gt;STDERR&lt;/code&gt; 에 출력이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="48f5e0e5ea6330c7048648eb2edf1ad4ccc05a55" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; . This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt; ) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;.</source>
          <target state="translated">실험적인 &quot;비트 단위&quot;기능이 활성화 된 경우 ( &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조 ), 다섯 번째 TRUE 인수는 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이것은 발신자가 숫자 동작을 기대하고 있음을 나타냅니다. 위치 ( &lt;code&gt;$_[3]&lt;/code&gt; )가 &lt;a href=&quot;#nomethod&quot;&gt;nomethod에&lt;/a&gt; 의해 예약되어 있으므로 네 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d70ab84f3a316c00496bd0dced7b93acc9fa6af" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then this operator always treats its operand as numbers. This feature produces a warning unless you also use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">실험 &quot;비트&quot;기능을 통해 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; ,이 연산자는 항상 숫자로 피연산자를 처리합니다. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 않으면이 기능은 경고를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="429f3423b67c7b1e2fda19e3e61bde6079c26d75" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . This feature produces a warning unless you use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">실험 &quot;비트 단위&quot;기능이 &quot;bitwise&quot; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 통해 활성화 된 경우 단항 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 는 항상 인수를 숫자로 대체 연산자 인 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; 항상 인수를 문자열로 취급합니다. 따라서 &lt;code&gt;~0&lt;/code&gt; 및 &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 은 32 비트 플랫폼에서 2 ** 32-1을 제공하는 반면 &lt;code&gt;~.0&lt;/code&gt; 및 &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 합니다. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; 를 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 않으면이 기능은 경고를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="bc923038f738e51827c6486386f676bb16b7db9f" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">식이 레이블 이름으로 평가되면 해당 범위가 동적으로 확인됩니다. 이렇게하면 FORTRAN 당 계산 된 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; 가&lt;/a&gt; 허용 되지만 유지 관리를 위해 최적화하는 경우 반드시 권장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="44c964489535901a948a3b23073f9b9bb3c0a3e6" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">표현식이 레이블 이름으로 평가되면 해당 범위는 동적으로 해석됩니다. 이렇게하면 FORTRAN 당 계산 된 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 가능하지만 유지 관리 성을 최적화하는 경우 반드시 권장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c0c3c70b730f0e2950f8179af548175b3c6ef32a" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">표현식이 레이블 이름으로 평가되면 해당 범위는 동적으로 해석됩니다. 이렇게하면 FORTRAN 당 계산 된 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 가능하지만 유지 관리 성을 최적화하는 경우 반드시 권장되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3a5f344d7e209018f81b3bb395e41710ea76000e" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt; , then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">확장자에 &lt;code&gt;*&lt;/code&gt; 가 포함되어 있지 않으면 현재 파일 이름 끝에 접미사로 추가됩니다. 확장자에 하나 이상의 &lt;code&gt;*&lt;/code&gt; 문자 가 포함되어 있으면 각 &lt;code&gt;*&lt;/code&gt; 가 현재 파일 이름으로 바뀝니다. Perl 용어로 이것을 다음과 같이 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de01c14a7209a45c44123f6710c3fc14dda93261" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt;, then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">확장자에 &lt;code&gt;*&lt;/code&gt; 가 없으면 현재 파일 이름 끝에 접미사로 추가됩니다. 확장자에 &lt;code&gt;*&lt;/code&gt; 문자 가 하나 이상 포함되어 있으면 각 &lt;code&gt;*&lt;/code&gt; 가 현재 파일 이름으로 바뀝니다. Perl 용어로 다음과 같이 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912122ed04813ef6afa69c21de9ff5d7b9578a1b" translate="yes" xml:space="preserve">
          <source>If the extension links to a library that it builds, set this to the name of the library (see SDBM_File)</source>
          <target state="translated">확장이 빌드 한 라이브러리에 링크 된 경우이를 라이브러리 이름으로 설정하십시오 (SDBM_File 참조).</target>
        </trans-unit>
        <trans-unit id="d3a643174ddd0d9876c30f4ff9ae6dc788ca282c" translate="yes" xml:space="preserve">
          <source>If the extension might need extra libraries, they should be included here. The extension Makefile.PL will take care of checking whether the libraries actually exist and how they should be loaded. The extra libraries should be specified in the form -lm -lposix, etc, just as on the cc command line. By default, the Makefile.PL will search through the library path determined by Configure. That path can be augmented by including arguments of the form &lt;b&gt;-L/another/library/path&lt;/b&gt; in the extra-libraries argument.</source>
          <target state="translated">확장에 추가 라이브러리가 필요할 경우 여기에 포함시켜야합니다. 확장명 Makefile.PL은 라이브러리가 실제로 존재하는지 그리고 어떻게로드되어야하는지 점검합니다. 추가 라이브러리는 cc 명령 행에서와 같이 -lm -lposix 등의 형식으로 지정해야합니다. 기본적으로 Makefile.PL은 Configure에 의해 결정된 라이브러리 경로를 검색합니다. 추가 경로 인수에 &lt;b&gt;-L / another / library / path&lt;/b&gt; 형식의 인수를 포함시켜 해당 경로를 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="effa256cfcef0cdd6582a1503da6bdf1fb1d1f9e" translate="yes" xml:space="preserve">
          <source>If the external</source>
          <target state="translated">외부의 경우</target>
        </trans-unit>
        <trans-unit id="2e204c469081d0ce7742a3d71bcaeedaf9240cda" translate="yes" xml:space="preserve">
          <source>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is assumed to have failed to extract. If none of the extractor subroutines succeeds, then one character is extracted from the start of the text and the extraction subroutines reapplied. Characters which are thus removed are accumulated and eventually become the next field (unless the fourth argument is true, in which case they are discarded).</source>
          <target state="translated">추출기가 일치하지 않거나 (정규 추출기의 경우) 빈 목록 또는 정의되지 않은 값 (서브 루틴 추출기의 경우)을 반환하면 추출에 실패한 것으로 간주됩니다. 추출기 서브 루틴이 성공하지 못하면 텍스트의 시작 부분에서 하나의 문자가 추출되고 추출 서브 루틴이 다시 적용됩니다. 따라서 제거 된 문자는 누적되고 결국 다음 필드가됩니다 (4 번째 인수가 참이 아닌 경우에는 버림).</target>
        </trans-unit>
        <trans-unit id="17d2c98a680d0b983c00126ba7fbf7037583b89d" translate="yes" xml:space="preserve">
          <source>If the extractor is a hash reference, it must contain exactly one element. The value of that element is one of the above extractor types (subroutine reference, regular expression, or string). The key of that element is the name of a class into which the successful return value of the extractor will be blessed.</source>
          <target state="translated">추출기가 해시 참조 인 경우 정확히 하나의 요소를 포함해야합니다. 해당 요소의 값은 위의 추출기 유형 (서브 루틴 참조, 정규식 또는 문자열) 중 하나입니다. 그 요소의 열쇠는 추출기의 성공적인 반환 가치가 축복 될 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a2187e610c6c9ce986c9ab2bc434fe210c96d6c7" translate="yes" xml:space="preserve">
          <source>If the extractor is a precompiled regular expression or a string, it is matched against the text in a scalar context with a leading '\G' and the gc modifiers enabled. The extracted value is either $1 if that variable is defined after the match, or else the complete match (i.e. $&amp;amp;).</source>
          <target state="translated">추출기가 사전 컴파일 된 정규식 또는 문자열 인 경우 선행 '\ G'및 gc 수정자가 활성화 된 스칼라 컨텍스트의 텍스트와 일치합니다. 해당 변수가 일치 후에 정의 된 경우 추출 된 값은 $ 1이거나 완전 일치 (예 : $ &amp;amp;)입니다.</target>
        </trans-unit>
        <trans-unit id="8efec72894ea829331e728164da92723ccc10f46" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt; . Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">추출기가 서브 루틴 인 경우 목록 컨텍스트에서 호출되며 단일 요소의 목록, 즉 추출 된 텍스트를 리턴해야합니다. 또한 선택적으로 추출 후 남은 텍스트를 나타내는 문자열 (패턴 일치의 경우 $ ')과 추출 전에 건너 뛴 접두어 (패턴 일치의 $`)를 나타내는 문자열을 추가로 리턴 할 수도 있습니다. 이것은 &lt;code&gt;extract_multiple&lt;/code&gt; 과 함께 다른 Text :: Balanced 서브 루틴을 쉽게 사용할 수 있도록 설계되었습니다 . 추출기 서브 루틴이 리턴 한 값은 원본 텍스트의 해당 서브 스트링과 관계가 없어도됩니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="91257d19dbe73c3f0115d0e82b54c986793ce4ee" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt;. Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">추출기가 서브 루틴 인 경우 목록 컨텍스트에서 호출되고 단일 요소, ​​즉 추출 된 텍스트의 목록을 리턴 할 것으로 예상됩니다. 또한 선택적으로 두 개의 추가 인수를 반환 할 수 있습니다. 하나는 추출 후 남은 텍스트를 나타내는 문자열 (예 : 패턴 일치의 경우 $ ')과 추출 전에 건너 뛴 접두사를 나타내는 문자열 (예 : 패턴 일치의 경우 $`)입니다. 이것은 &lt;code&gt;extract_multiple&lt;/code&gt; 과 함께 다른 Text :: Balanced 서브 루틴을 쉽게 사용할 수 있도록 설계되었습니다 . 추출기 서브 루틴에서 반환 된 값은 원본 텍스트의 해당 하위 문자열과 어떤 관계도 가질 필요가 없습니다 (아래 예제 참조).</target>
        </trans-unit>
        <trans-unit id="a385fcb5d8ca5cfa07426e73b4f41df3b2f355d3" translate="yes" xml:space="preserve">
          <source>If the field contains a numeric value it will be displayed in hex. Zip stored most numbers in little-endian format - the value displayed will have the little-endian encoding removed.</source>
          <target state="translated">필드에 숫자 값이 포함되어 있으면 16 진수로 표시됩니다. Zip은 대부분의 숫자를 little-endian 형식으로 저장합니다. 표시된 값에는 little-endian 인코딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="12045367f64a99179f5690e61487afbfd5fe1436" translate="yes" xml:space="preserve">
          <source>If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">파일이 UTF-8, UTF-16BE 또는 UTF-16LE 바이트 순서 표시로 시작하면 처리하기 전에 건너 뛰고 파일 내용도 perl 5.8부터 적절하게 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0b45c8a0563151ba3b588e7383417bdd5f8a3d" translate="yes" xml:space="preserve">
          <source>If the file does not exist, &lt;code&gt;cpan&lt;/code&gt; dies.</source>
          <target state="translated">파일이 없으면 &lt;code&gt;cpan&lt;/code&gt; 이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4293d2972da49b7deee5cbac8e57e93be999a13" translate="yes" xml:space="preserve">
          <source>If the file is a symlink, the file it's pointing to</source>
          <target state="translated">파일이 심볼릭 링크 인 경우 파일이 가리키는 파일</target>
        </trans-unit>
        <trans-unit id="1260f14708b5c4f0e969b3d9b19ac87d75cb1573" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt; , compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">파일에 의해 당겨 경우 &lt;code&gt;perl_parse()&lt;/code&gt; , 새로 지어진 인터프리터로 컴파일하고, 그 후 함께 청소 &lt;code&gt;perl_destruct()&lt;/code&gt; 이후에, 당신은 대부분의 네임 스페이스 문제로부터 보호하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e4d1ea92f7af34b6047df7fcc8abb443c9f062" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt;, compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">파일이 &lt;code&gt;perl_parse()&lt;/code&gt; 에 의해 당겨지고 새로 구성된 인터프리터로 컴파일 된 다음 나중에 &lt;code&gt;perl_destruct()&lt;/code&gt; 정리되면 대부분의 네임 스페이스 문제로부터 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="0047e959707fe337b2aa331e4b4d29cbdd3ddf49" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt;. These permission values need to be in octal, and are modified by your process's current &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">FILENAME로 명명 된 파일이 존재하지 않고 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 호출이 파일을 생성하는 경우 (일반적으로 MODE에 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그가 포함되어 있기 때문에 ) PERMS 값은 새로 생성 된 파일의 권한을 지정합니다. &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; 에&lt;/a&gt; 대한 PERMS 인수를 생략하면 Perl은 8 진수 값 &lt;code&gt;0666&lt;/code&gt; 을 사용합니다 . 이러한 권한 값은 8 진수 여야하며 프로세스의 현재 &lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; 에&lt;/a&gt; 의해 수정됩니다 .</target>
        </trans-unit>
        <trans-unit id="972b095c8cf0635710238db90318d20a5a12c4b1" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FILENAME으로 이름 지정된 파일이 존재하지 않고 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 호출이 파일을 작성하는 경우 (일반적으로 MODE에 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그가 포함되어 있기 때문에 ) PERMS 값은 새로 작성된 파일의 권한을 지정합니다. PERMS 인수를 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 생략하면 Perl은 8 진 값 &lt;code&gt;0666&lt;/code&gt; 을 사용합니다 . 이 권한 값은 8 진수 여야하며 프로세스의 현재 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8aa66e9311c9629d0b8c20e950c88829b4d37f7e" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FILENAME으로 이름 지정된 파일이 존재하지 않고 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 호출이 파일을 작성하는 경우 (일반적으로 MODE에 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그가 포함되어 있기 때문에 ) PERMS 값은 새로 작성된 파일의 권한을 지정합니다. PERMS 인수를 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 생략하면 Perl은 8 진 값 &lt;code&gt;0666&lt;/code&gt; 을 사용합니다 . 이 권한 값은 8 진수 여야하며 프로세스의 현재 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 에 의해 수정됩니다 .</target>
        </trans-unit>
        <trans-unit id="afca59eeb0296a7f173f43e8587c0ce7c2de1f87" translate="yes" xml:space="preserve">
          <source>If the file specification is already in a valid VMS syntax, it will be passed through unchanged, except that the UTF-8 flag will be cleared since VMS format file specifications are never in UTF-8.</source>
          <target state="translated">파일 사양이 이미 유효한 VMS 구문에있는 경우 VMS 형식 파일 사양이 UTF-8이 아니므로 UTF-8 플래그가 지워진다는 점을 제외하고는 변경되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f20f26d4d2cfe896fd9be41e5561303708778051" translate="yes" xml:space="preserve">
          <source>If the file that contains the module begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">모듈을 포함하는 파일이 UTF-8, UTF-16BE 또는 UTF-16LE 바이트 순서 표시로 시작하면 처리하기 전에 건너 뛰고 파일 내용도 perl 5.8부터 적절하게 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9b9e946eeefcb8ca3ed866d0a22b192157304573" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">열려는 파일에 텍스트 문자 대신 이진 데이터가 들어 있으면 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;MODE&lt;/code&gt; 인수 가 약간 다릅니다. 인코딩을 지정하는 대신 데이터가 원시 바이트임을 Perl에 알립니다.</target>
        </trans-unit>
        <trans-unit id="b62027d4bfba52954180b6ef864f354108e4a798" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;open&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">열려는 파일이 이진 데이터 대신 텍스트 문자가 포함 된 경우, &lt;code&gt;MODE&lt;/code&gt; 에 인수 &lt;code&gt;open&lt;/code&gt; 조금 다르다. 인코딩을 지정하는 대신 데이터가 원시 바이트에 있음을 Perl에 알립니다.</target>
        </trans-unit>
        <trans-unit id="ed7727f14d3896e4199132a911f1277a6913be80" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">파일이 후크를 통해로드 된 경우 (예를 들어 서브 루틴 참조 참조 &lt;a href=&quot;functions/require&quot;&gt;필요한&lt;/a&gt; 이들 고리에 대한 설명)이 후크 삽입 디폴트로 &lt;code&gt;%INC&lt;/code&gt; 파일명 대신. 그러나 후크는 &lt;code&gt;%INC&lt;/code&gt; 항목을 자체적으로 설정하여 보다 구체적인 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf52c06965f9e5fc28f2b729df47caf3473ff123" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">파일이 후크를 통해로드 된 경우 (예 : 서브 루틴 참조, 이러한 후크에 대한 설명은 &lt;a href=&quot;perlfunc#require&quot;&gt;perlfunc의 &quot;require&quot;를&lt;/a&gt; 참조하십시오 )이 후크는 기본적 으로 파일 이름 대신 &lt;code&gt;%INC&lt;/code&gt; 에 삽입됩니다 . 그러나 후크는 보다 구체적인 정보를 제공하기 위해 자체적으로 &lt;code&gt;%INC&lt;/code&gt; 항목을 설정했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbada7e6f993214c7ee778a69597cde7ab2c7bef" translate="yes" xml:space="preserve">
          <source>If the file was modified and the server response includes a properly formatted &lt;code&gt;Last-Modified&lt;/code&gt; header, the file modification time will be updated accordingly.</source>
          <target state="translated">파일이 수정되고 서버 응답에 올바른 형식의 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더가 포함 된 경우 그에 따라 파일 수정 시간이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1055d8f3bf09e356a8ac90a312ee4c58ffecab8f" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;0&lt;/code&gt;. Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 핸들이 파이프 열기에서 나온 경우 관련된 다른 syscall 중 하나가 실패하거나 해당 프로그램이 0이 아닌 상태로 종료되면 &lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 가 false를 반환합니다. 유일한 문제가 프로그램이 0이 아닌 상태로 종료되었다는 것이라면 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 파이프를 닫으면 파이프에서 실행중인 프로세스가 종료 될 때까지 기다립니다 (나중에 파이프의 출력을 확인하려는 경우). 암시 적으로 해당 명령의 종료 상태 값을 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;및 &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e74503c754d78c3ba0f9051478f8b0d722c72c1" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">파일 핸들이 파이프 된 열기에서 온 경우, 관련된 다른 시스템 호출 중 하나가 실패하거나 프로그램이 0이 아닌 상태로 종료되면 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 는 false를 리턴합니다. 유일한 문제는 프로그램이 0이 아닌 것으로 종료했다면 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 파이프를 닫으면 파이프에서 실행중인 프로세스가 종료 될 때까지 기다립니다 (나중에 파이프의 출력을 보려는 경우).이 명령의 종료 상태 값을 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a275dda5ca271e5742fe50c27b80a1dea7fadc2a" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">파일 핸들이 파이프 된 열기에서 온 경우, 관련된 다른 시스템 호출 중 하나가 실패하거나 프로그램이 0이 아닌 상태로 종료되면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 는 false를 리턴합니다. 유일한 문제는 프로그램이 0이 아닌 것으로 종료했다면 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 파이프를 닫으면 파이프에서 실행중인 프로세스가 종료 될 때까지 기다립니다 (나중에 파이프의 출력을 보려는 경우).이 명령의 종료 상태 값을 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc5e1415bd14e8d1ec6ad1e512653e073ea2d16" translate="yes" xml:space="preserve">
          <source>If the filename supplied contains directory separators (and so is an absolute or relative pathname), and if that file is not found, platforms that append file extensions will do so and try to look for the file with those extensions added, one by one.</source>
          <target state="translated">제공된 파일 이름에 디렉토리 구분 기호 (절대 또는 상대 경로 이름도 포함)가 포함되어 있고 해당 파일을 찾을 수없는 경우 파일 확장자를 추가하는 플랫폼이 파일 확장자를 추가 한 파일을 하나씩 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8b638dc989817125971a607e8fa00529b2b307c1" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.</source>
          <target state="translated">지정된 최종 값이 마법 증분이 생성하는 순서에없는 경우 다음 값이 지정된 최종 값보다 길 때까지 시퀀스가 ​​진행됩니다.</target>
        </trans-unit>
        <trans-unit id="a33c6e16dc7645806ca8dcd82f881fedaded9d02" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified. If the length of the final string is shorter than the first, the empty list is returned.</source>
          <target state="translated">지정된 최종 값이 마법 증분으로 생성되는 시퀀스에 없으면 다음 값이 지정된 최종 값보다 길 때까지 시퀀스가 ​​진행됩니다. 최종 문자열의 길이가 첫 번째 문자열보다 짧으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5f8e1e30b780f6553cc08550f9370ae0ed9b97a" translate="yes" xml:space="preserve">
          <source>If the first argument is a reference to an array, the pseudo-hash will be created with keys from that array. If a second argument is supplied, it must also be a reference to an array whose elements will be used as the values. If the second array contains less elements than the first, the trailing elements of the pseudo-hash will not be initialized. This makes it particularly useful for creating a pseudo-hash from subroutine arguments:</source>
          <target state="translated">첫 번째 인수가 배열에 대한 참조 인 경우 해당 배열의 키를 사용하여 의사 해시가 작성됩니다. 두 번째 인수가 제공되면 요소가 값으로 사용될 배열에 대한 참조이기도합니다. 두 번째 배열에 첫 번째 배열보다 적은 수의 요소가 포함되어 있으면 의사 해시의 후행 요소가 초기화되지 않습니다. 이는 서브 루틴 인수에서 의사 해시를 작성하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9f235f80bacbd6f2376896bcd2071e6b6ed89634" translate="yes" xml:space="preserve">
          <source>If the first argument is an empty string &quot;&quot; or is a volume name, i.e. matches the pattern /^[^:]+:/, the resulting path is &lt;b&gt;absolute&lt;/b&gt;.</source>
          <target state="translated">첫 번째 인수가 빈 문자열 &quot;&quot;이거나 볼륨 이름 인 경우, 즉 / ^ [^ :] + : / 패턴과 일치하면 결과 경로는 &lt;b&gt;absolute&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89aa8ef2f6a6df7b419aa16ffe18ced8031ac672" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt; 또는 &lt;b&gt;-m&lt;/b&gt; 뒤의 첫 문자 가 대시 ( &lt;b&gt;-&lt;/b&gt; )이면 'use'가 'no'로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="d6369cd957319ca2b8d2442c19d6fcbc6b24183a" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'. This makes no difference for &lt;b&gt;-m&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt; 또는 &lt;b&gt;-m&lt;/b&gt; 뒤의 첫 번째 문자 가 대시 ( &lt;b&gt;-&lt;/b&gt; )이면 'use'가 'no'로 대체됩니다. 이것은 &lt;b&gt;-m&lt;/b&gt; 에는 차이가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="781d0d29a2affd4018c32ec572f1b116a7081027" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , this line is treated as &lt;code&gt;#!&lt;/code&gt; -line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;.</source>
          <target state="translated">Perl 스크립트의 첫 문자가 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; 인 경우이 행은 &lt;code&gt;#!&lt;/code&gt; -line과 같이이 줄의 모든 스위치가 처리됩니다 (cmd가 cmd.exe를 통해 시작된 경우 두 번). &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun의 DESCRIPTION을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="581c684b617d92750c5f38a91fda2e5d76163206" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt;, this line is treated as &lt;code&gt;#!&lt;/code&gt;-line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">Perl 스크립트의 첫 번째 문자가 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; 이면이 줄은 &lt;code&gt;#!&lt;/code&gt; -line, 따라서이 행의 모든 ​​스위치가 처리됩니다 (스크립트가 cmd.exe를 통해 시작된 경우 두 번). &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrun의 &quot;DESCRIPTION&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f46518f452342a5c022fec8e53026c8608f2e02a" translate="yes" xml:space="preserve">
          <source>If the first digit following the backslash is a 0, it's an octal escape.</source>
          <target state="translated">백 슬래시 다음의 첫 번째 숫자가 0이면 8 진수 이스케이프입니다.</target>
        </trans-unit>
        <trans-unit id="5675bafb3dc48482ba4a4f320234c0b4d704c9a0" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt; ) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt; . See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , the timeout class.</source>
          <target state="translated">리턴 값 ( &lt;code&gt;success&lt;/code&gt; ) 의 첫 번째 요소 가 0 인 경우 일부 오류가 발생했습니다. 이 두 번째 요소는 요청한 명령이 사용 가능한 경우 종료 한 오류 메시지입니다. 이것은 일반적으로 &lt;code&gt;$?&lt;/code&gt; 의 꽤 인쇄 된 값 입니까? 또는 &lt;code&gt;$@&lt;/code&gt; . 포함 할 수있는 내용에 대한 자세한 내용 은 &lt;code&gt;perldoc perlvar&lt;/code&gt; 를 참조하십시오 . 오류가 시간 초과 인 경우 시간 초과 클래스 인 문자열 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; 이 &lt;code&gt;error message&lt;/code&gt; 앞에 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="638a2f7fa728eb482819629ddfdf65e5299a089f" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt;) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt;. See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt;, the timeout class.</source>
          <target state="translated">반환 값의 첫 번째 요소 ( &lt;code&gt;success&lt;/code&gt; )가 0이면 오류가 발생한 것입니다. 이 두 번째 요소는 사용 가능한 경우 요청한 명령이 종료 된 오류 메시지입니다. 이것은 일반적으로 &lt;code&gt;$?&lt;/code&gt; 또는 &lt;code&gt;$@&lt;/code&gt; . 포함 할 수있는 항목에 대한 자세한 내용 은 &lt;code&gt;perldoc perlvar&lt;/code&gt; 를 참조하세요. 오류가 시간 초과 인 경우 &lt;code&gt;error message&lt;/code&gt; 앞에 시간 초과 클래스 인 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; 문자열이 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="6a57fb9b1830952d24356efef9c0744590e7e139" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is &quot;*&quot;, it's taken as shorthand for the so commonly called &quot;quant&quot; method. Similarly, if the first item in a bracket group is &quot;#&quot;, it's taken to be shorthand for &quot;numf&quot;.</source>
          <target state="translated">대괄호 그룹의 첫 번째 항목이 &quot;*&quot;인 경우 소위 &quot;quant&quot;방법의 약어로 간주됩니다. 마찬가지로, 괄호 그룹의 첫 번째 항목이 &quot;#&quot;이면 &quot;numf&quot;의 약어로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1953104edb77654c33631a60ba8219310b08e426" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is the empty-string, or &quot;_*&quot; or &quot;_</source>
          <target state="translated">대괄호 그룹의 첫 번째 항목이 빈 문자열이거나 &quot;_ *&quot;또는 &quot;_</target>
        </trans-unit>
        <trans-unit id="bf6e94a3fad4e68b50306c3295f243e0a73b5811" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group looks like a method name, then that group is interpreted like this:</source>
          <target state="translated">대괄호 그룹의 첫 번째 항목이 메소드 이름처럼 보이는 경우 해당 그룹은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ccf14e3215a8aeb1aa87eb4f44052cead882fc98" translate="yes" xml:space="preserve">
          <source>If the first operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">첫 번째 피연산자에 &quot;nomethod&quot;메소드가 있으면이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0dadbb13895f7c7975effc9602b93ea5e861379" translate="yes" xml:space="preserve">
          <source>If the first operand has declared a subroutine to overload the operator then use that implementation.</source>
          <target state="translated">첫 번째 피연산자가 연산자를 오버로드하기 위해 서브 루틴을 선언 한 경우 해당 구현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7ca747166805083d1be553c7e78c86f97bd5b0c" translate="yes" xml:space="preserve">
          <source>If the flag &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is passed, no warnings are generated, and hence no AV is created.</source>
          <target state="translated">&lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 플래그 가 전달되면 경고가 생성되지 않으므로 AV가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63722d831a3c09d59c00e59b75ba5f74f6230f38" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">플래그가 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 에 있으면 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 작동하기 전에 대상 문자열의 시작 부분에서 공백을 삭제합니다. 공백으로 간주되는 것은 주제가 UTF-8 문자열인지와 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; 플래그가 설정되어 있는지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="69393e8c9a9ff1f7ad6c1d1075c45161dd52ff73" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;split&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">플래그가 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 에있는 경우 &lt;code&gt;split&lt;/code&gt; 은 작동하기 전에 제목 문자열의 시작 부분에서 공백을 삭제합니다. 공백으로 간주되는 것은 제목이 UTF-8 문자열인지 및 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; 플래그가 설정 되었는지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="dbc08ae29def75bcb01866771948171d3f78fd50" translate="yes" xml:space="preserve">
          <source>If the function is used across several files, but intended only for Perl's internal use (and this should be the common case), do not export it to the public API. See the discussion about</source>
          <target state="translated">함수가 여러 파일에서 사용되지만 Perl의 내부 용도로만 사용되는 경우 (일반적인 경우) 공용 API로 내 보내지 마십시오. 에 대한 토론을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="0cd096b932efa03a9f98d53e47997c47f5475a48" translate="yes" xml:space="preserve">
          <source>If the function is used only inside one source code file, make it static. See the discussion about</source>
          <target state="translated">함수가 하나의 소스 코드 파일 내에서만 사용되는 경우 정적으로 만듭니다. 에 대한 토론을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="56833441b11ff81d3798d0015a0f9476e6600637" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;&quot;Lexer interface&quot;&lt;/a&gt; for details.</source>
          <target state="translated">함수가 키워드를 처리하려면 먼저 키워드에 의해 도입 된 구문의 일부인 키워드 다음의 모든 항목을 구문 분석해야합니다. 자세한 내용은 &lt;a href=&quot;#Lexer-interface&quot;&gt;&quot;Lexer 인터페이스&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d809f75a0fec341370456ffe5542097322b23570" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer interface&lt;/a&gt; for details.</source>
          <target state="translated">함수가 키워드를 처리하려면 먼저 키워드가 도입 한 구문의 일부인 키워드 다음에있는 것을 구문 분석해야합니다. 자세한 내용은 &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer 인터페이스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4257aa9162577acd082afc2803cd5eba4d35b6a8" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">함수 이름이 &lt;b&gt;DESTROY&lt;/b&gt; 이면 C ++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 함수가 호출되고 &lt;code&gt;THIS&lt;/code&gt; 가 매개 변수로 제공됩니다. 에 대한 생성 된 C ++ 코드</target>
        </trans-unit>
        <trans-unit id="2d5573b215565d0881940be9d2690435373f68b6" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;delete&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">함수 이름이 &lt;b&gt;DESTROY&lt;/b&gt; 이면 C ++ &lt;code&gt;delete&lt;/code&gt; 함수가 호출되고 &lt;code&gt;THIS&lt;/code&gt; 가 매개 변수로 제공됩니다. 생성 된 C ++ 코드</target>
        </trans-unit>
        <trans-unit id="7a9d5afefb1f72725e3effbcde85fc42f858949b" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt; , to be given as the first argument.</source>
          <target state="translated">함수 이름이 &lt;b&gt;new&lt;/b&gt; 이면 동적 C ++ 객체를 만들기 위해 C ++ &lt;code&gt;new&lt;/code&gt; 함수가 호출됩니다. XSUB는 클래스 이름이 &lt;code&gt;CLASS&lt;/code&gt; 라는 변수에 유지 될 것으로 첫 번째 인수로 제공 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="55694f31aaf01067ff0315ab3ecdf0ed7ab87a27" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt;, to be given as the first argument.</source>
          <target state="translated">함수의 이름이 &lt;b&gt;new&lt;/b&gt; 이면 C ++ &lt;code&gt;new&lt;/code&gt; 함수가 호출되어 동적 C ++ 객체를 생성합니다. XSUB는 &lt;code&gt;CLASS&lt;/code&gt; 라는 변수에 보관 될 클래스 이름 이 첫 번째 인수로 제공 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="6b71bbee27e0cc31a2af0019a27b599b4619d0d9" translate="yes" xml:space="preserve">
          <source>If the generated module were architecture-specific, you could replace &lt;code&gt;$(INST_LIB)&lt;/code&gt; above with &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt;, although if you locate modules under</source>
          <target state="translated">생성 된 모듈은 특정 아키텍처 인 경우에, 당신은 대체 할 수 &lt;code&gt;$(INST_LIB)&lt;/code&gt; 와 위를 &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt; 당신이 아래에 모듈을 찾을 경우 있지만,</target>
        </trans-unit>
        <trans-unit id="cf92d6194fe17b6faa691c083e3aa66b73fd41bc" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">주어진 파일이 Storable 이미지 인 경우이를 설명하는 해시를 반환합니다. 파일을 읽을 수 있지만 저장 가능 이미지가 아닌 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴하십시오 . 파일이 존재하지 않거나 읽을 수없는 경우에는 숨어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8a49ab1a01520f2d7d29b472d08d17beed998e" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;undef&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">주어진 파일이 저장 가능한 이미지이면 그것을 설명하는 해시를 반환합니다. 파일을 읽을 수 있지만 저장 가능한 이미지가 아닌 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. 파일이 존재하지 않거나 읽을 수없는 경우 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="6f5f5dfa299a465aa9a0110ad7326e956c843743" translate="yes" xml:space="preserve">
          <source>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.</source>
          <target state="translated">주어진 문자열이 FCD ( &quot;Fast C 또는 D&quot;형식, UTN # 5 참조) 인 경우 수정없이 문자열을 반환합니다. 그렇지 않으면 FCD 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12d092a8012a2b0bc17122d5b49e40f14ceca06d" translate="yes" xml:space="preserve">
          <source>If the global variable $KEEP_ALL is true, the file or directory will not be removed.</source>
          <target state="translated">글로벌 변수 $ KEEP_ALL이 true 인 경우 파일 또는 디렉토리가 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc1c6dee6d24dc894200423540415887a91afb83" translate="yes" xml:space="preserve">
          <source>If the groupings in a regex are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</source>
          <target state="translated">정규식의 그룹화가 중첩 된 경우 &lt;code&gt;$1&lt;/code&gt; 은 가장 왼쪽의 여는 괄호, &lt;code&gt;$2&lt;/code&gt; 는 다음 여는 괄호 등으로 그룹을 가져옵니다 . 예를 들어, 복잡한 정규식과 그 아래에 일치하는 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d3242285e88212205a68d263609b12616c56fc8" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis,</source>
          <target state="translated">정규 표현식의 그룹이 중첩 된 경우 &lt;code&gt;$1&lt;/code&gt; 은 가장 왼쪽 여는 괄호가있는 그룹을 가져오고 &lt;code&gt;$2&lt;/code&gt; 는 다음 여는 괄호를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="83b41f5fdfcf62fc4686ef889212a3544a4d2078" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. Here is a regexp with nested groups:</source>
          <target state="translated">정규 표현식의 그룹이 중첩되면 &lt;code&gt;$1&lt;/code&gt; 은 가장 왼쪽에 여는 괄호가있는 그룹을 가져오고 다음에 여는 첫 번째 괄호는 &lt;code&gt;$2&lt;/code&gt; 입니다. 중첩 된 그룹이있는 정규 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccea903e5c5ba097dd604b81034d2fccf458d781" translate="yes" xml:space="preserve">
          <source>If the gunzip program encounters a file containing multiple gzip files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="translated">gunzip 프로그램이 함께 연결된 여러 gzip 파일을 포함하는 파일을 발견하면 자동으로 모든 파일의 압축을 해제합니다. 아래 예는이 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7672fac594e6a7dd98d2bae0c51d24e5065e39e4" translate="yes" xml:space="preserve">
          <source>If the gzip FEXTRA header field is present it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">gzip FEXTRA 헤더 필드가 있으면 RFC 1952에 정의 된대로 서브 필드 구조를 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="948511a86fa3a757ed333c1057a05dc236b1ed7b" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a comment field (FCOMMENT) it consists solely of ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">gzip 헤더에 주석 필드 (FCOMMENT)가 포함 된 경우 ISO 8859-1 문자와 줄 바꿈만으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="309f2d92f5e86ee4880748347a713d797525d1c3" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a name field (FNAME) it consists solely of ISO 8859-1 characters.</source>
          <target state="translated">gzip 헤더에 이름 필드 (FNAME)가 포함 된 경우 ISO 8859-1 문자로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae4fed28b97ca4227cf5c00d60d4d6f2110ce60" translate="yes" xml:space="preserve">
          <source>If the hash is tied dispatches through to the SCALAR tied method, otherwise if the hash contains no keys returns 0, otherwise returns a mortal sv containing a string specifying the number of used buckets, followed by a slash, followed by the number of available buckets.</source>
          <target state="translated">해시가 연결되어 있으면 SCALAR 연결 메서드로 디스패치하고, 그렇지 않으면 해시에 키가 포함되어 있지 않으면 0을 반환하고, 그렇지 않으면 사용 된 버킷 수를 지정하는 문자열을 포함하는 mortal sv를 반환하고 그 뒤에 슬래시와 사용 가능한 버킷 수를 차례로 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="76da98a8a76e4650e3f026f7c68c78b99cc6936b" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">해시가 매우 큰 경우 긴 키 목록을 작성하지 않을 수 있습니다. 메모리를 절약하기 위해 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 사용하여 한 번에 하나의 키-값 쌍을 가져와 아직 보지 못한 쌍을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cd0158384418c000a070c2edb04e7bd8c177a8" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;each()&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">해시가 매우 큰 경우 긴 키 목록을 생성하지 않을 수 있습니다. 메모리를 절약하기 위해 &lt;code&gt;each()&lt;/code&gt; 사용하여 한 번에 하나의 키-값 쌍을 가져올 수 있습니다 . 그러면 아직 보지 못한 쌍이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb896d2cffead7d5fc78c0ddc9c3c52939333bc" translate="yes" xml:space="preserve">
          <source>If the hint provided is a subroutine, then &lt;code&gt;autodie&lt;/code&gt; will pass the complete return value to that subroutine. If the hint is any other value, then &lt;code&gt;autodie&lt;/code&gt; will smart-match against the value provided. In Perl 5.8.x there is no smart-match operator, and as such only subroutine hints are supported in these versions.</source>
          <target state="translated">제공된 힌트가 서브 루틴이면 &lt;code&gt;autodie&lt;/code&gt; 는 전체 반환 값을 해당 서브 루틴에 전달합니다. 힌트가 다른 값이면 &lt;code&gt;autodie&lt;/code&gt; 는 제공된 값과 스마트 매치됩니다. Perl 5.8.x에는 스마트 매치 연산자가 없으며 이러한 버전에서는 서브 루틴 힌트 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7d353d642decb66a3abbcefcf79e58c99b0ba1e9" translate="yes" xml:space="preserve">
          <source>If the hook is an array reference, its first element must be a subroutine reference. This subroutine is called as above, but the first parameter is the array reference. This lets you indirectly pass arguments to the subroutine.</source>
          <target state="translated">후크가 배열 참조 인 경우 첫 번째 요소는 서브 루틴 참조 여야합니다. 이 서브 루틴은 위와 같이 호출되지만 첫 번째 매개 변수는 배열 참조입니다. 이를 통해 서브 루틴에 인수를 간접적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75efff7a12e92261036612262090b64712859893" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an &lt;code&gt;INC&lt;/code&gt; method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt;.) Here is a typical code layout:</source>
          <target state="translated">후크가 객체 인 경우 위와 같이 호출 될 &lt;code&gt;INC&lt;/code&gt; 메서드를 제공해야합니다 . 첫 번째 매개 변수는 객체 자체입니다. (정규화되지 않은 &lt;code&gt;INC&lt;/code&gt; 는 항상 &lt;code&gt;main&lt;/code&gt; 패키지로 강제 되므로 서브의 이름을 완전하게 규정 해야합니다 .) 다음은 일반적인 코드 레이아웃입니다.</target>
        </trans-unit>
        <trans-unit id="089781c4ed94b59afd45ade73f63dd3ae0adcf17" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an INC method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt; .) Here is a typical code layout:</source>
          <target state="translated">후크가 객체 인 경우 위와 같이 호출 될 INC 메소드를 제공해야합니다. 첫 번째 매개 변수는 객체 자체입니다. 정규화되지 않은 &lt;code&gt;INC&lt;/code&gt; 는 항상 &lt;code&gt;main&lt;/code&gt; 패키지로 강제 적용 되므로 하위 이름을 완전히 규정 해야합니다 . 다음은 일반적인 코드 레이아웃입니다.</target>
        </trans-unit>
        <trans-unit id="dc5ac6730609a596bd949c3bb5ec01a23d4ffce0" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), only the initial value will be returned. So the following will only return an alpha:</source>
          <target state="translated">지정된 초기 값이 마법 증가 시퀀스의 일부가 아닌 경우 (즉, &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 일치하는 비어 있지 않은 문자열 ), 초기 값 만 반환됩니다. 따라서 다음은 알파 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f20e6769b4c4dc9b5fc71b6e41306b51022683e2" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;), only the initial value will be returned.</source>
          <target state="translated">지정된 초기 값이 마법 증분 시퀀스의 일부가 아닌 경우 (즉, &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 일치하는 비어 있지 않은 문자열 ) 초기 값 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce1ecd771a78ded6bdca0c84c4a8624d300c4df7" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt; , then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt; , is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">초기화가 &lt;code&gt;=&lt;/code&gt; 로 시작 하면 입력 변수에 대한 선언으로 출력되어 형식 맵에서 제공 한 초기화를 대체합니다. 초기화가 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 이면 모든 입력 변수가 선언 된 후에 수행됩니다. 에서 &lt;code&gt;;&lt;/code&gt; typemap에 의해 정상적으로 제공되는 초기화가 수행되지 않는 경우. 들어 &lt;code&gt;+&lt;/code&gt; 의 경우, 변수의 선언 타입 맵의 초기화를 포함 할 것이다. 전역 변수 &lt;code&gt;%v&lt;/code&gt; 는 한 초기화의 정보가 다른 초기화에 필요한 경우가 거의없는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef3d32f84fa869f08148860d3a1b874f45f05bbf" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt;, then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt;, is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">초기화가 &lt;code&gt;=&lt;/code&gt; 로 시작 하면 입력 변수에 대한 선언에 출력되어 typemap에서 제공하는 초기화를 대체합니다. 초기화가로 시작하는 경우 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 이면 모든 입력 변수가 선언 된 후에 수행됩니다. 에서 &lt;code&gt;;&lt;/code&gt; 일반적으로 typemap에 의해 제공되는 초기화가 수행되지 않는 경우. 들어 &lt;code&gt;+&lt;/code&gt; 의 경우, 변수의 선언 타입 맵의 초기화를 포함 할 것이다. 전역 변수 &lt;code&gt;%v&lt;/code&gt; 는 한 초기화의 정보가 다른 초기화에 필요한 매우 드문 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a641a3d375c74024ce1445924cf66af681f41ebd" translate="yes" xml:space="preserve">
          <source>If the input code point's name has more than one synonym, they are returned joined into a single comma-separated string.</source>
          <target state="translated">입력 코드 포인트 이름에 둘 이상의 동의어가있는 경우 단일 쉼표로 구분 된 문자열로 결합되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9e071ed158601437a7fd928632778e71dc9740aa" translate="yes" xml:space="preserve">
          <source>If the input file/buffer contains multiple compressed data streams, this option will uncompress the whole lot as a single data stream.</source>
          <target state="translated">입력 파일 / 버퍼에 여러 개의 압축 된 데이터 스트림이 포함 된 경우이 옵션은 전체 로트를 단일 데이터 스트림으로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3c582e01c3ed1134227361002db4abc5ef87f0a6" translate="yes" xml:space="preserve">
          <source>If the input is a buffer, &lt;code&gt;trailingData&lt;/code&gt; will return everything from the end of the compressed data stream to the end of the buffer.</source>
          <target state="translated">입력이 버퍼 인 경우 &lt;code&gt;trailingData&lt;/code&gt; 는 압축 된 데이터 스트림의 끝에서 버퍼의 끝까지 모든 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="646ddea5cc7fe42fca7b5f673b48b7968e951a94" translate="yes" xml:space="preserve">
          <source>If the input is a filehandle, &lt;code&gt;trailingData&lt;/code&gt; will return the data that is left in the filehandle input buffer once the end of the compressed data stream has been reached. You can then use the filehandle to read the rest of the input file.</source>
          <target state="translated">입력이 파일 핸들 인 경우, &lt;code&gt;trailingData&lt;/code&gt; 는 압축 된 데이터 스트림의 끝에 도달하면 파일 핸들 입력 버퍼에 남아있는 데이터를 리턴합니다. 그런 다음 파일 핸들을 사용하여 나머지 입력 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68ffb2242fbe49d90e0f353510f536b7c97b26ff" translate="yes" xml:space="preserve">
          <source>If the input is a gzip (RFC 1952) data stream, the following will be checked:</source>
          <target state="translated">입력이 gzip (RFC 1952) 데이터 스트림 인 경우 다음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fbb62e9bad07668939b33bd6b3f35cbd2a29221c" translate="yes" xml:space="preserve">
          <source>If the input is an RFC 1950 data stream, the following will be checked:</source>
          <target state="translated">입력이 RFC 1950 데이터 스트림 인 경우 다음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="681895bf526e306295ee60c6f4d01df1e2e0e233" translate="yes" xml:space="preserve">
          <source>If the input is being interpreted as UTF-8 and a UTF-8 encoding error is encountered, an exception is generated.</source>
          <target state="translated">입력이 UTF-8로 해석되고 UTF-8 인코딩 오류가 발생하면 예외가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3ba700c41877fa613cc375e9afc8a49773890d" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">입력을 알 수없는 경우 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다. 리스트 문맥 내의 비어있는리스트 입력이 알려진 경우 스칼라 컨텍스트에서 호출되면 목록의 요소 수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a3761d436a5408df215f967b2c72bd018ebcc47f" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;undef&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">입력을 알 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 스칼라 컨텍스트로 반환됩니다. 목록 컨텍스트의 빈 목록. 입력이 알려진 경우 스칼라 컨텍스트에서 호출되면 목록의 요소 수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a45a90c97d69c88324a18a4a975329202a110a46" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, extra characters are ignored.</source>
          <target state="translated">입력 문자열이 필요 이상으로 길면 추가 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="daec947152f5e00d64f719376318858935b663a6" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, remaining characters are ignored.</source>
          <target state="translated">입력 문자열이 필요 이상으로 길면 나머지 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a191161ccbd661c7961516bab02ad1f7aadb16a" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt; , and call it like this:</source>
          <target state="translated">&lt;code&gt;BOOT:&lt;/code&gt; 섹션과 Perl 코드 의 상호 의존성 이 이보다 더 복잡한 경우 (예 &lt;code&gt;BOOT:&lt;/code&gt; 섹션은 프로토 타입을 사용하여 XSUB를 호출하는 Perl 함수를 호출 함) &lt;code&gt;BOOT:&lt;/code&gt; 섹션을 모두 제거 하십시오. &lt;code&gt;onBOOT()&lt;/code&gt; 함수로 바꾸고 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="baa35ea6f799cdc2c58744681c4a0f8490276128" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt;, and call it like this:</source>
          <target state="translated">&lt;code&gt;BOOT:&lt;/code&gt; 섹션과 Perl 코드 의 상호 의존성 이 이것보다 더 복잡한 경우 (예 &lt;code&gt;BOOT:&lt;/code&gt; 섹션은 프로토 타입을 사용하여 XSUB를 호출하는 Perl 함수를 호출합니다) &lt;code&gt;BOOT:&lt;/code&gt; 섹션을 모두 제거 합니다. &lt;code&gt;onBOOT()&lt;/code&gt; 함수로 바꾸고 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="2909f2e071daf0b882a5795cb2264aafaf8e4b0b" translate="yes" xml:space="preserve">
          <source>If the interpreter's &lt;code&gt;PL_exit_flags&lt;/code&gt; word has the &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; flag set, then this function will execute code in &lt;code&gt;END&lt;/code&gt; blocks before performing the rest of destruction. If it is desired to make any use of the interpreter between &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; other than just calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;, then this flag should be set early on. This matters if &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; will not be called, or if anything else will be done in addition to calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;.</source>
          <target state="translated">인터프리터의 &lt;code&gt;PL_exit_flags&lt;/code&gt; 단어에 &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; 플래그가 설정 되어 있으면 이 함수는 나머지 파괴를 수행하기 전에 &lt;code&gt;END&lt;/code&gt; 블록 에서 코드를 실행합니다 . 이 사이에 인터프리터의 사용을하고자하는 경우 &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; 및 &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; 단지 호출하는 것보다 다른 &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;는&lt;/a&gt; ,이 플래그는 초기에 설정해야합니다. 이것은 &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; 이 호출되지 않거나 &quot;perl_run&quot; 을 호출하는 것 외에 다른 작업이 수행되는 경우 &lt;a href=&quot;#perl_run&quot;&gt;중요&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fd4475a90b24f7b1ba4a7b6ea113603191eff994" translate="yes" xml:space="preserve">
          <source>If the kernel set-id script feature isn't disabled, then any set-id script provides an exploitable vulnerability. Perl can't avoid being exploitable, but will point out vulnerable scripts where it can. If Perl detects that it is being applied to a set-id script then it will complain loudly that your set-id script is insecure, and won't run it. When Perl complains, you need to remove the set-id bit from the script to eliminate the vulnerability. Refusing to run the script doesn't in itself close the vulnerability; it is just Perl's way of encouraging you to do this.</source>
          <target state="translated">커널 set-id 스크립트 기능이 비활성화되지 않은 경우 모든 set-id 스크립트는 악용 가능한 취약점을 제공합니다. Perl은 악용되는 것을 피할 수는 없지만 가능한 경우 취약한 스크립트를 지적합니다. Perl이 set-id 스크립트에 적용되고 있음을 감지하면 set-id 스크립트가 안전하지 않다고 큰 소리로 불평하고 실행하지 않을 것입니다. Perl이 불만을 제기하면 취약점을 제거하기 위해 스크립트에서 set-id 비트를 제거해야합니다. 스크립트 실행을 거부한다고해서 취약점이 닫히는 것은 아닙니다. 이것은 단지 Perl이 이것을하도록 격려하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3e4a966e522ce068cba366c74c39330ba735c481" translate="yes" xml:space="preserve">
          <source>If the key does not exist the method returns 1.</source>
          <target state="translated">키가 존재하지 않으면 메소드는 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f85edef10f25d12c44c4dedc4c6946807ec9d900" translate="yes" xml:space="preserve">
          <source>If the label equals '-', then Concise will treat the bit as a raw bit and not try to display it symbolically.</source>
          <target state="translated">레이블이 '-'이면 Concise는 비트를 원시 비트로 취급하고 기호로 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f74ad7c032adb69e8741c3ce089dbedf2af387c8" translate="yes" xml:space="preserve">
          <source>If the language handle has a &quot;fail&quot; attribute whose value is a coderef, then $lh-&amp;gt;maketext(</source>
          <target state="translated">언어 핸들에 값이 coderef 인 &quot;fail&quot;속성이 있으면 $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="74b0a2c233bae54a5a0a22d4c6904ecf217ffcc9" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, mentioning the</source>
          <target state="translated">언어 핸들이 더는 &quot;실패&quot;가없는 경우 속성, maketext 단순히 예외가 발생합니다 (즉,이 호출 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 을 언급,</target>
        </trans-unit>
        <trans-unit id="ed178838d46c1e8b7a50a0bfb02973479dc8e58f" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;die&lt;/code&gt;, mentioning the</source>
          <target state="translated">언어 핸들에 &quot;fail&quot;속성이없는 경우 maketext는 단순히 예외를 throw합니다 (즉, &lt;code&gt;die&lt;/code&gt; 를 호출 하여</target>
        </trans-unit>
        <trans-unit id="f4c30b1f2ee79d6c9f16717998b6ca5cb7a43494" translate="yes" xml:space="preserve">
          <source>If the last definition is removed, then the DOS device name is also deleted.</source>
          <target state="translated">마지막 정의가 제거되면 DOS 장치 이름도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="11f576169bf47c87f2f0af12c0e2e1a4146c280c" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">LIST의 마지막 요소가 줄 바꿈으로 끝나지 않으면 현재 스크립트 줄 번호와 입력 줄 번호 (있는 경우)도 인쇄되고 줄 바꿈이 제공됩니다. &quot;입력 라인 번호&quot;( &quot;청크&quot;라고도 함)는 현재 유효한 &quot;라인&quot;개념에 따라 달라지며 특수 변수 &lt;code&gt;$.&lt;/code&gt; 로도 제공됩니다 . . &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;../perlvar#%24.&quot;&gt;$ &lt;/a&gt;에서 $ /를 참조하십시오 . perlvar에서 .</target>
        </trans-unit>
        <trans-unit id="2ddf8780e7e7d9b3df1dc954871c1e6b0c532c31" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">LIST의 마지막 요소가 줄 바꿈으로 끝나지 않으면 현재 스크립트 줄 번호와 입력 줄 번호 (있는 경우)도 인쇄되고 줄 바꿈이 제공됩니다. &quot;입력 라인 번호&quot;( &quot;청크&quot;라고도 함)는 현재 유효한 &quot;라인&quot;개념에 따라 달라지며 특수 변수 &lt;code&gt;$.&lt;/code&gt; 로도 제공됩니다 . . &lt;a href=&quot;perlvar#%24%2f&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;perlvar#%24.&quot;&gt;$ &lt;/a&gt;에서 $ /를 참조하십시오 . perlvar에서 .</target>
        </trans-unit>
        <trans-unit id="65ccdf7ae6afe2d083d0de8afca0765301ad5a3c" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;&quot;Method Call Variations&quot;&lt;/a&gt; for more nuances.</source>
          <target state="translated">왼쪽이 패키지 이름도 객체도 아닌 경우 메서드 호출로 인해 오류가 발생하지만 자세한 내용은 &lt;a href=&quot;#Method-Call-Variations&quot;&gt;&quot;메소드 호출 변형&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e90835049bf9dceb2b3128f6e0da3805c87bc497" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Method Call Variations&lt;/a&gt; for more nuances.</source>
          <target state="translated">왼쪽이 패키지 이름이나 객체가 아닌 경우 메소드 호출로 오류가 발생하지만 더 많은 뉘앙스에 대해서는 &lt;a href=&quot;#Method-Call-Variations&quot;&gt;메소드 호출 변형&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37bacecd2332508665ec81733fbdffa749ac5bfa" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not even, it behaves as if padded by a null character at the end. Similarly, &quot;extra&quot; nybbles are ignored during unpacking.</source>
          <target state="translated">입력 문자열의 길이가 고르지 않으면 끝에 널 문자로 채워진 것처럼 작동합니다. 마찬가지로, 포장을 풀 때 &quot;추가&quot;Nybbles가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="88b7864a27a0577ffff54b7d555aea0617e9d505" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not evenly divisible by 8, the remainder is packed as if the input string were padded by null characters at the end. Similarly during unpacking, &quot;extra&quot; bits are ignored.</source>
          <target state="translated">입력 문자열의 길이를 8로 균등하게 나눌 수없는 경우 나머지는 입력 문자열이 끝에 널 문자로 채워진 것처럼 압축됩니다. 압축을 풀 때와 마찬가지로 &quot;추가&quot;비트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e67d3ea522ed96fe7a9c8431714f7f3d0ba5c5" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt; , you need:</source>
          <target state="translated">라이브러리가 &lt;code&gt;$Config{libpth}&lt;/code&gt; 아닌 위치에있는 경우 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c256d5d027a4accdcc167669a7812e5bf777ccbe" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt;, you need:</source>
          <target state="translated">라이브러리가 &lt;code&gt;$Config{libpth}&lt;/code&gt; 아닌 위치에있는 경우 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="96118a855a2f1b2515701521249ef16334052e1f" translate="yes" xml:space="preserve">
          <source>If the line number is &lt;code&gt;.&lt;/code&gt;, sets a breakpoint on the current line:</source>
          <target state="translated">줄 번호가 &lt;code&gt;.&lt;/code&gt; 현재 줄에 중단 점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="94650250941df693d5a68b4ac245a935f3b9c2e5" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. Were they kind? You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable. Repeatedly protesting about the moderators' decisions regarding a third party is also unacceptable, as is continuing to initiate off-list contact with the moderators about their decisions.</source>
          <target state="translated">목록 중재자가 당신이 예의 바르지 않다고 말하면 어떤 식 으로든 응답하기 전에 당신의 말이 어떻게 나타 났는지 신중하게 고려하십시오. 친절 했나요? 귀하는 항의 할 수 있지만 반복적으로 재확인 된 결정에 대해 반복적으로 항의하는 것은 용납되지 않습니다. 제 3 자에 대한 중재자의 결정에 대해 반복적으로 항의하는 것도 용납 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f93c03970a56584f9fb61994432bc17cb7db5f12" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable.</source>
          <target state="translated">목록 중재자가 당신이 시민이 아니라고 말하면 어떤 식 으로든 반응하기 전에 단어가 어떻게 나타나는지 신중하게 고려하십시오. 귀하는 항의 할 수 있지만 반복적으로 재확인 된 결정에 대한 반복 된 항의는 용납되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0a9f58b026642b9c9e8e7bb8deab3007d5236f6" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt; , as perl has already set it up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread safe. However, some alien libraries that may be called do set it, such as &lt;code&gt;Gtk&lt;/code&gt; . This can cause problems for the perl core and other modules. Starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">사용자 환경의 로케일이 필요한 경우 perl이 이미 설정 했으므로 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이외의 로케일을 설정하기 위해 XS 코드가 필요하지 않습니다 . XS 코드는 로케일 변경을 피해야합니다. 로케일을 변경하면 관련이없는 다른 코드에 악영향을 줄 수 있으며 스레드로부터 안전하지 않을 수 있습니다. 그러나 &lt;code&gt;Gtk&lt;/code&gt; 와 같은 일부 외계인 라이브러리가 설정합니다 . 이로 인해 펄 코어 및 기타 모듈에 문제가 발생할 수 있습니다. v5.20.1부터는 XS에서 &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale ()&lt;/a&gt; 함수를 호출하면 이러한 문제를 대부분 피할 수 있습니다. 이 작업을 수행하기 전에이를 수행하는 순수한 Perl 명령문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29cc247eadfeb453e1955bad0bbc5ed23022a753" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt;, as perl has already set the others up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread-safe. To minimize problems, the macros &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; in perlapi&lt;/a&gt;, &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; in perlapi&lt;/a&gt;, and &lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot; in perlapi&lt;/a&gt; should be used to affect any needed change.</source>
          <target state="translated">사용자 환경의 로케일이 필요한 경우, perl이 이미 다른 것을 설정 했으므로 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 를 제외하고 XS 코드가 로케일을 설정할 필요가 없습니다 . XS 코드는 관련없는 다른 코드에 악영향을 미칠 수 있고 스레드로부터 안전하지 않을 수 있으므로 로케일 변경을 피해야합니다. 문제를 최소화하려면 &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;perlapi의 &quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; 매크로, perlapi 의 &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt; 및 perlapi의 &lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;매크로&lt;/a&gt; 를 사용하여 필요한 변경 사항을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4664ee573739492d5623b9369f8faea69d271aa1" translate="yes" xml:space="preserve">
          <source>If the main thread exits while there are detached threads which are still running, then Perl's global destruction phase is not executed because otherwise certain global structures that control the operation of threads and that are allocated in the main thread's memory may get destroyed before the detached thread is destroyed.</source>
          <target state="translated">여전히 실행중인 분리 된 스레드가있는 동안 주 스레드가 종료되면 Perl의 전역 파괴 단계가 실행되지 않습니다. 그렇지 않으면 스레드의 작업을 제어하고 주 스레드의 메모리에 할당 된 특정 전역 구조가 분리 된 스레드보다 먼저 파괴 될 수 있기 때문입니다. 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="823e97e3e713d61f96695c0b7d66500ba0535b81" translate="yes" xml:space="preserve">
          <source>If the make process encounters trouble with either compilation or linking then try setting the _C89_CCMODE to 1. Assuming sh is your login shell then run:</source>
          <target state="translated">make 프로세스에서 컴파일 또는 링크에 문제가 발생하면 _C89_CCMODE를 1로 설정하십시오. sh가 로그인 쉘이라고 가정하면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="fa7d8db26880e3b2b83f69006312ed2e5013aabf" translate="yes" xml:space="preserve">
          <source>If the member name in the zip archive is not valid UTF-8 when this optionn is true, the script will die with an error message.</source>
          <target state="translated">이 옵션이 true 일 때 zip 아카이브의 멤버 이름이 유효한 UTF-8이 아닌 경우 스크립트가 오류 메시지와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0119f182d57e85f55c259aad67e5507f5a71d506" translate="yes" xml:space="preserve">
          <source>If the method is called in scalar context, then it will try to extract exactly</source>
          <target state="translated">메서드가 스칼라 컨텍스트에서 호출되면 정확하게 추출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2ae0fed8c834da6c72af01b4cce727e6b5ec751e" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is already loaded, then the declaration</source>
          <target state="translated">모듈 &lt;code&gt;Module&lt;/code&gt; 이 이미로드 된 경우 선언</target>
        </trans-unit>
        <trans-unit id="1b3cd9a44d834ecaba373518cdced67ef6882e1c" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is not loaded yet, then the above declaration declares functions func1() and func2() in the current package. When these functions are called, they load the package &lt;code&gt;Module&lt;/code&gt; if needed, and substitute themselves with the correct definitions.</source>
          <target state="translated">모듈 &lt;code&gt;Module&lt;/code&gt; 이 아직로드되지 않은 경우, 위 선언은 현재 패키지에서 func1 () 및 func2 () 함수를 선언합니다. 이러한 함수가 호출 되면 필요한 경우 패키지 &lt;code&gt;Module&lt;/code&gt; 을로드 하고 올바른 정의로 ​​대체합니다.</target>
        </trans-unit>
        <trans-unit id="aa83e5ba98e2e00acddd7117050d321e4e9d54d9" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, &lt;code&gt;mark_as_loaded&lt;/code&gt; will carp about this and tell you from where the &lt;code&gt;PACKAGE&lt;/code&gt; has been loaded already.</source>
          <target state="translated">모듈이 이미로드 된 경우 &lt;code&gt;mark_as_loaded&lt;/code&gt; 는이 문제를 해결하고 &lt;code&gt;PACKAGE&lt;/code&gt; 가 이미로드 된 위치를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="e1cec740a866f3242f2245723f611d8e6a35a17e" translate="yes" xml:space="preserve">
          <source>If the module is already unloaded, &lt;code&gt;mark_as_unloaded&lt;/code&gt; will carp about this and tell you the &lt;code&gt;PACKAGE&lt;/code&gt; has been unloaded already.</source>
          <target state="translated">모듈이 이미 언로드 된 경우 &lt;code&gt;mark_as_unloaded&lt;/code&gt; 는이 문제를 해결하고 &lt;code&gt;PACKAGE&lt;/code&gt; 가 이미 언로드되었음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="55dd2ee6ad71be855cc8cea6dc45014e0de598b9" translate="yes" xml:space="preserve">
          <source>If the module is needed inside the</source>
          <target state="translated">내부에 모듈이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="fab3a0f11307492451a39d88e9be980974dcb4d2" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; if needed):</source>
          <target state="translated">모듈이 스레드 내부에서만 사용되는 경우 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드 진입 점 함수 내부에서 모듈을로드 해보십시오 ( 필요한 경우 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3aa735bc422b148dd84e6d085642a87f49e47ba" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;require&lt;/code&gt; (and &lt;code&gt;import&lt;/code&gt; if needed):</source>
          <target state="translated">모듈이 스레드 내에서만 사용되는 경우 &lt;code&gt;require&lt;/code&gt; ( 필요한 경우 &lt;code&gt;import&lt;/code&gt; 사용하여 스레드 진입 점 함수 내부에서 모듈을로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3b3934908dc77b79dcbb0b789e5b838d36463c" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt; . The value is passed direct as the parameter</source>
          <target state="translated">이름이 UTF-8로 제공되면 &lt;code&gt;HVhek_UTF8&lt;/code&gt; 로 설정하십시오 . 값은 매개 변수로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="873d55d8a257eaf7386c02b0cf4a9016781f6d23" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt;. The value is passed direct as the parameter</source>
          <target state="translated">이름이 UTF-8로 제공되는 경우이를 &lt;code&gt;HVhek_UTF8&lt;/code&gt; 로 설정하십시오 . 값은 매개 변수로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="31ddfa3306f944720376a989f9d5fd87c400eb47" translate="yes" xml:space="preserve">
          <source>If the name is omitted, format &quot;STDOUT&quot; is defined. A single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST consists of a sequence of lines, each of which may be one of three types:</source>
          <target state="translated">이름을 생략하면 &quot;STDOUT&quot;형식이 정의됩니다. 싱글 &quot;.&quot; 1 열의 형식은 형식을 종료하는 데 사용됩니다. FORMLIST는 일련의 행으로 구성되며 각 행은 세 가지 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0def4cf3757d0553a2341afef733c2c0849f1052" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the input, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">이름을 알 수 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다 (또는 목록 컨텍스트의 빈 목록). Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄이 있거나없는)를 사용하여 정규식에서 특성 이름을 인식합니다 . 이 함수는 입력에있는 것을 인식하지 않고 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. 그것들은 가능한 동의어로서 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88548ac66c76967c7a6bd845c8445fe8da2c6437" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the input, returning &lt;code&gt;undef&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">이름을 알 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다 (또는 목록 컨텍스트의 빈 목록). Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄 포함 또는 제외)가 있는 정규식의 속성 이름을 인식합니다 . 이 함수는 입력에있는 것을 인식하지 않고 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. 또한 가능한 동의어로 출력에 포함되지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="a79bb3cadb8f975e939ef18071a526a4b5d3363e" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt; . For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">명명 된 매개 변수 &lt;code&gt;config_override&lt;/code&gt; 가 지정되면 일반적으로 &lt;code&gt;%Config::Config&lt;/code&gt; 있는 모든 정보가 포함 된 해시에 대한 참조 여야합니다 . 예를 들어, 별도의 perl 설치에 대한 구성 정보를 확보하여 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455e39c93d939d0a811460c9e6eb8b61291c4896" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt;. For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">명명 된 매개 변수 &lt;code&gt;config_override&lt;/code&gt; 가 지정된 경우 일반적으로 &lt;code&gt;%Config::Config&lt;/code&gt; 에서 발견되는 모든 정보를 포함하는 해시에 대한 참조 여야합니다 . 예를 들어 별도의 perl 설치에 대한 구성 정보를 가져 와서 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db3ef5746e8cd5bab310439aa50dba89f545a584" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;skip_cwd&lt;/code&gt; is true, the current directory &lt;code&gt;.&lt;/code&gt; will be stripped from &lt;code&gt;@INC&lt;/code&gt; before searching for .packlists. This keeps ExtUtils::Installed from finding modules installed in other perls that happen to be located below the current directory.</source>
          <target state="translated">명명 된 매개 변수 &lt;code&gt;skip_cwd&lt;/code&gt; 가 true이면 현재 디렉토리 &lt;code&gt;.&lt;/code&gt; .packlists를 검색하기 전에 &lt;code&gt;@INC&lt;/code&gt; 에서 제거됩니다 . 이렇게하면 ExtUtils :: Installed가 현재 디렉토리 아래에있는 다른 perls에 설치된 모듈을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f6facbdb87684a56df7a20a0d54e6b8073b8eb9" translate="yes" xml:space="preserve">
          <source>If the new version of the C library is ABI-compatible (that's Application Binary Interface compatible) with the version you're upgrading from, and if the shared library version didn't change, no re-compilation should be necessary.</source>
          <target state="translated">C 라이브러리의 새 버전이 업그레이드하려는 버전과 ABI 호환 (응용 프로그램 이진 인터페이스 호환)이고 공유 라이브러리 버전이 변경되지 않은 경우 다시 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f6451aaf2bf86188eece8b63b5bab6c7257462f" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">다음 문자가 입력 텍스트의 다음 청크에 있거나 확장되면 다음 청크를 읽습니다. 일반적으로 현재 청크는 동시에 버려지지만</target>
        </trans-unit>
        <trans-unit id="1f73682ad19692885d11822d4f6d7cb69031b04a" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="translated">다음 문자가 입력 텍스트의 다음 청크에 있거나 확장되면 다음 청크를 읽습니다. 일반적으로 현재 청크는 동시에 삭제되지만 &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; 비트가 설정되어 있으면 현재 청크가 삭제됩니다. 청크는 폐기되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a6672795e23362230912b4b8b4e28fb661f0a19" translate="yes" xml:space="preserve">
          <source>If the number consists of digits only, JSON::PP will try to represent it as an integer value. If that fails, it will try to represent it as a numeric (floating point) value if that is possible without loss of precision. Otherwise it will preserve the number as a string value (in which case you lose roundtripping ability, as the JSON number will be re-encoded to a JSON string).</source>
          <target state="translated">숫자가 숫자로만 구성된 경우 JSON :: PP는 숫자를 정수 값으로 나타내려고합니다. 이것이 실패하면 정밀도 손실없이 가능하면 숫자 (부동 소수점) 값으로 표현하려고 시도합니다. 그렇지 않으면 숫자를 문자열 값으로 유지합니다 (이 경우 JSON 숫자가 JSON 문자열로 다시 인코딩되므로 라운드 트립 기능이 손실 됨).</target>
        </trans-unit>
        <trans-unit id="bf7862ebb65f1805f38240d9ec3614885b02e6ad" translate="yes" xml:space="preserve">
          <source>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</source>
          <target state="translated">백 슬래시 다음의 숫자가 N (10 진수)이고 Perl이 이미 N 개의 캡처 그룹을 본 경우, Perl은이를 역 참조로 간주합니다. 그렇지 않으면 8 진 탈출로 간주됩니다. N에 3 자리가 넘는 숫자가 있으면 Perl은 8 진수 이스케이프에 처음 3 개만 사용합니다. 나머지는 그대로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fad0df49da49393094ec039045da70fce50b5429" translate="yes" xml:space="preserve">
          <source>If the number of data bytes ($bytes) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 1024.</source>
          <target state="translated">데이터 바이트 수 ($ bytes)가 제공되면 원격 호스트로 전송되는 핑 패킷에 많은 데이터 바이트가 포함됩니다. 프로토콜이 &quot;tcp&quot;인 경우 데이터 바이트 수는 무시됩니다. 프로토콜이 &quot;udp&quot;이면 데이터 바이트의 최소 (및 기본) 수는 1이고 그렇지 않으면 0입니다. 지정할 수있는 최대 데이터 바이트 수는 1024입니다.</target>
        </trans-unit>
        <trans-unit id="173b84764a7ba838f6e1039dc98cb544515aa621" translate="yes" xml:space="preserve">
          <source>If the number of data bytes (&lt;code&gt;bytes&lt;/code&gt;) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 65535, but staying below the MTU (1472 bytes for ICMP) is recommended. Many small devices cannot deal with fragmented ICMP packets.</source>
          <target state="translated">데이터 바이트 수 ( &lt;code&gt;bytes&lt;/code&gt; )가 제공되면 해당 많은 데이터 바이트가 원격 호스트로 전송되는 ping 패킷에 포함됩니다. 프로토콜이 &quot;tcp&quot;인 경우 데이터 바이트 수는 무시됩니다. 프로토콜이 &quot;udp&quot;이면 최소 (및 기본) 데이터 바이트 수는 1이고 그렇지 않으면 0입니다. 지정할 수있는 최대 데이터 바이트 수는 65535이지만 MTU (ICMP의 경우 1472 바이트) 미만으로 유지하는 것이 좋습니다. 많은 소형 장치는 조각난 ICMP 패킷을 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="6ea88b95c30f8557b60611e6fa0d52e56ecf8669" translate="yes" xml:space="preserve">
          <source>If the number of partitions on the disk.</source>
          <target state="translated">디스크의 파티션 수.</target>
        </trans-unit>
        <trans-unit id="a34b4bc1598422e778b8ed9662906c7efb975344" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is greater than that in the left-hand list, the &quot;missing&quot; scalars will become undefined.</source>
          <target state="translated">왼쪽 목록의 스칼라 수가 왼쪽 목록의 스칼라 개수보다 많으면 &quot;누락 된&quot;스칼라가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73c7831330bbfcd31669c32d53f7a76b28d963cd" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is less than that in the right-hand list, the &quot;extra&quot; scalars in the right-hand list will simply not be assigned.</source>
          <target state="translated">왼쪽 목록의 스칼라 수가 오른쪽 목록의 개수보다 적 으면 오른쪽 목록의 &quot;추가&quot;스칼라가 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf726231b3d599cdbe46b108046dbf7815381c4c" translate="yes" xml:space="preserve">
          <source>If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.</source>
          <target state="translated">포크 동안 오브젝트가 하위 프로세스로 전달 된 경우 오브젝트가 상위에서 범위를 벗어나면 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="39e52d92c6b313ed3349d0401be82f80d273536a" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , etc., but will contain only locale keys.</source>
          <target state="translated">코드 포인트의 유일한 케이싱이 로케일에 의존하는 경우, 리턴 된 해시에는 &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; 등과 같은 기본 키가 없지만 로케일 키만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4285420e25852376bd4b42fe10dbce58fa32d6ad" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, etc., but will contain only locale keys.</source>
          <target state="translated">코드 포인트의 유일한 대 / 소문자가 로케일에 종속적이면 반환 된 해시에는 &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; 등과 같은 기본 키가 없지만 로케일 키만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="17fa159e601e547a6489ad99ba45fba36084dad4" translate="yes" xml:space="preserve">
          <source>If the only comparison needed is whether an installed module is of a sufficiently high version, a direct test may be done using the string form of &lt;code&gt;eval&lt;/code&gt; and the &lt;code&gt;use&lt;/code&gt; function. For example, for module &lt;code&gt;$mod&lt;/code&gt; and version prerequisite &lt;code&gt;$prereq&lt;/code&gt;:</source>
          <target state="translated">필요한 유일한 비교가 설치된 모듈이 충분히 높은 버전인지 여부 인 경우 &lt;code&gt;eval&lt;/code&gt; 의 문자열 형식 과 &lt;code&gt;use&lt;/code&gt; 함수를 사용하여 직접 테스트를 수행 할 수 있습니다 . 예를 들어 &lt;code&gt;$mod&lt;/code&gt; 모듈 및 버전 전제 조건 &lt;code&gt;$prereq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e51d5a9ae61f6c29388fc414c6297a691764547b" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to a blessed object, then the name of the class into which the referent is blessed will be returned. &lt;code&gt;ref&lt;/code&gt; doesn't care what the physical type of the referent is; blessing takes precedence over such concerns. Beware that exact comparison of &lt;code&gt;ref&lt;/code&gt; results against a class name doesn't perform a class membership test: a class's members also include objects blessed into subclasses, for which &lt;code&gt;ref&lt;/code&gt; will return the name of the subclass. Also beware that class names can clash with the built-in type names (described below).</source>
          <target state="translated">피연산자가 blessed 객체에 대한 참조이면 참조 대상이 blessed되는 클래스의 이름이 반환됩니다. &lt;code&gt;ref&lt;/code&gt; 는 리퍼 런트의 물리적 유형이 무엇인지 상관하지 않습니다. 축복이 그러한 염려보다 우선합니다. 클래스 이름에 대한 &lt;code&gt;ref&lt;/code&gt; 결과 의 정확한 비교는 클래스 멤버십 테스트를 수행하지 않습니다. 클래스의 멤버에는 하위 클래스로 축복 된 객체도 포함되며, 이에 대한 &lt;code&gt;ref&lt;/code&gt; 는 하위 클래스의 이름을 반환합니다. 또한 클래스 이름이 기본 제공 유형 이름 (아래에 설명 됨)과 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7623f1bb883be3a3b5a21de5d5644725c26daefe" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to an unblessed object, then the return value indicates the type of object. If the unblessed referent is not a scalar, then the return value will be one of the strings &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;FORMAT&lt;/code&gt;, or &lt;code&gt;IO&lt;/code&gt;, indicating only which kind of object it is. If the unblessed referent is a scalar, then the return value will be one of the strings &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;VSTRING&lt;/code&gt;, &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;GLOB&lt;/code&gt;, &lt;code&gt;LVALUE&lt;/code&gt;, or &lt;code&gt;REGEXP&lt;/code&gt;, depending on the kind of value the scalar currently has. But note that &lt;code&gt;qr//&lt;/code&gt; scalars are created already blessed, so &lt;code&gt;ref qr/.../&lt;/code&gt; will likely return &lt;code&gt;Regexp&lt;/code&gt;. Beware that these built-in type names can also be used as class names, so &lt;code&gt;ref&lt;/code&gt; returning one of these names doesn't unambiguously indicate that the referent is of the kind to which the name refers.</source>
          <target state="translated">피연산자가 비 축복 된 개체에 대한 참조 인 경우 반환 값은 개체의 유형을 나타냅니다. 비 축제 참조 대상이 스칼라가 아닌 경우 반환 값은 &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , &lt;code&gt;FORMAT&lt;/code&gt; 또는 &lt;code&gt;IO&lt;/code&gt; 문자열 중 하나가 되며 어떤 종류의 객체인지 만 나타냅니다. 비 축제 참조 대상이 스칼라 인 경우 반환 값은 스칼라가 현재 가지고있는 값의 종류에 따라 &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;VSTRING&lt;/code&gt; , &lt;code&gt;REF&lt;/code&gt; , &lt;code&gt;GLOB&lt;/code&gt; , &lt;code&gt;LVALUE&lt;/code&gt; 또는 &lt;code&gt;REGEXP&lt;/code&gt; 문자열 중 하나 가됩니다. 그러나 &lt;code&gt;qr//&lt;/code&gt; 스칼라는 이미 축복받은 상태로 생성되었으므로 &lt;code&gt;ref qr/.../&lt;/code&gt; 은 &lt;code&gt;Regexp&lt;/code&gt; 를 반환 할 가능성이 높습니다 . 이러한 내장 유형 이름은 클래스 이름으로도 사용할 수 있으므로 이러한 이름 중 하나를 반환하는 &lt;code&gt;ref&lt;/code&gt; 는 참조 대상이 이름이 참조하는 종류임을 명확하게 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa1ec170d0d4fcfcfbbdd9dd518a1d70b552ce0" translate="yes" xml:space="preserve">
          <source>If the operand is not a reference, then the empty string will be returned. An empty string will only be returned in this situation. &lt;code&gt;ref&lt;/code&gt; is often useful to just test whether a value is a reference, which can be done by comparing the result to the empty string. It is a common mistake to use the result of &lt;code&gt;ref&lt;/code&gt; directly as a truth value: this goes wrong because &lt;code&gt;0&lt;/code&gt; (which is false) can be returned for a reference.</source>
          <target state="translated">피연산자가 참조가 아니면 빈 문자열이 반환됩니다. 이 상황에서만 빈 문자열이 반환됩니다. &lt;code&gt;ref&lt;/code&gt; 는 값이 참조인지 여부를 테스트하는 데 유용하며 결과를 빈 문자열과 비교하여 수행 할 수 있습니다. &lt;code&gt;ref&lt;/code&gt; 의 결과를 진리 값으로 직접 사용하는 것은 일반적인 실수입니다. 참조 를 위해 &lt;code&gt;0&lt;/code&gt; (거짓)을 반환 할 수 있기 때문에 이것은 잘못된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="addcad10a864d1cffc4846608d394fea1feac09a" translate="yes" xml:space="preserve">
          <source>If the operands to a binary bitwise op are strings of different sizes, &lt;b&gt;|&lt;/b&gt; and &lt;b&gt;^&lt;/b&gt; ops act as though the shorter operand had additional zero bits on the right, while the &lt;b&gt;&amp;amp;&lt;/b&gt; op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.</source>
          <target state="translated">이진 비트 단위 연산에 대한 피연산자가 다른 크기의 문자열 인 경우 &lt;b&gt;|&lt;/b&gt; 및 &lt;b&gt;^&lt;/b&gt; 그동안 짧은 피연산자는 우측 부가 제로 비트를 가지고있는 것처럼 행동 OPS &lt;b&gt;및&lt;/b&gt; 긴 피연산자 짧은 길이로 절단 한 것처럼 연산이 작용한다. 이러한 확장 또는 잘림의 세분성은 하나 이상의 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="c7870bd3c024159f240305b7047279e21ad1fe56" translate="yes" xml:space="preserve">
          <source>If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).</source>
          <target state="translated">운영 체제가 지원하는 경우 (예 : BSD 파생 시스템) 파일 핸들은 O_EXLOCK (독점 파일 잠금으로 열림)으로 열립니다. 임시 파일이 재사용되지 않도록 배타적 잠금 (예 : DBD :: SQLite)을 취하는 다른 시스템으로 파일 이름을 전달하려는 경우 때때로 문제가 발생할 수 있습니다. 이 상황에서 &quot;EXLOCK&quot;옵션을 임시 파일로 전달할 수 있습니다. 기본적으로 EXLOCK은 true입니다 (이전 릴리스와의 호환성 유지).</target>
        </trans-unit>
        <trans-unit id="e19b7bb4d69a3c985ce8931960025916d3561c3a" translate="yes" xml:space="preserve">
          <source>If the operation being timed out is system() or qx(), this technique is liable to generate zombies. If this matters to you, you'll need to do your own fork() and exec(), and kill the errant child process.</source>
          <target state="translated">시간 종료 된 조작이 system () 또는 qx () 인 경우이 기술은 좀비를 생성 할 수 있습니다. 이것이 당신에게 중요하다면, 당신은 당신 자신의 fork ()와 exec ()를하고 잘못된 자식 프로세스를 죽여야합니다.</target>
        </trans-unit>
        <trans-unit id="05f4a71ea34fe9d7ddbd210db5290a2dfa223838" translate="yes" xml:space="preserve">
          <source>If the operation shown is &quot;ToFold&quot;, it means that case-insensitive matching in a regular expression was done on the code point.</source>
          <target state="translated">표시된 작업이 &quot;ToFold&quot;이면 정규식에서 대소 문자를 구분하지 않는 일치가 코드 포인트에서 수행되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3ba42937f598291497eafce66d29e91aabe688c5" translate="yes" xml:space="preserve">
          <source>If the optimization can not be applied, this returns undef. If it can be applied, this method returns a hash reference containing the following information:</source>
          <target state="translated">최적화를 적용 할 수없는 경우 undef를 반환합니다. 적용 할 수있는 경우이 메서드는 다음 정보가 포함 된 해시 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a982ec5add551174c87d54c0c75cad924249147a" translate="yes" xml:space="preserve">
          <source>If the option destination is a reference to a hash, the option will take, as value, strings of the form</source>
          <target state="translated">옵션 대상이 해시에 대한 참조 인 경우 옵션은 형식의 문자열을 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab8a370e734c2b7f25ad3475fabaef52fd095ddb" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</source>
          <target state="translated">옵션이 제공되고 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; 가 설정되지 않은 경우 '0'값은 &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; 을 의미 하고 다른 값은 &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="2d707532b21b034988218d78dc5dd2089b91f3ef" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt;.</source>
          <target state="translated">옵션이 제공되고 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; 가 설정되지 않은 경우 '0'값은 &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; 을 의미 하고 다른 값은 &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="bb774833de734f7b65efa56e3c7c5f53234542f8" translate="yes" xml:space="preserve">
          <source>If the option is set to false, the output buffer in the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method will be truncated before uncompressed data is written to it.</source>
          <target state="translated">옵션이 false로 설정되면 압축되지 않은 데이터가 기록되기 전에 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 메소드 의 출력 버퍼 가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="a7e5a140437039036cbeabf084c8f96c887a93f7" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">옵션이 true로 설정되면 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 메소드에 의해 압축되지 않은 데이터가 출력 버퍼에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c22c2720bbc793b56d2bdb2031cd852762e79aba" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">옵션이 true로 설정되면 압축되지 않은 데이터가 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 및 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 메소드 의 출력 버퍼에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="943c28148863687139f9e45e03407da89d7e13fa" translate="yes" xml:space="preserve">
          <source>If the option value is required, Getopt::Long will take the command line argument that follows the option and assign this to the option variable. If, however, the option value is specified as optional, this will only be done if that value does not look like a valid command line option itself.</source>
          <target state="translated">옵션 값이 필요한 경우 Getopt :: Long은 옵션 뒤에 오는 명령 행 인수를 사용하여 옵션 변수에 지정합니다. 그러나 옵션 값이 선택적으로 지정된 경우 해당 값이 유효한 명령 행 옵션 자체가 아닌 경우에만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b25fc0c82dd37f9c4b9d7996e6e001cd8c1c22e" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt; .</source>
          <target state="translated">의 순서 경우 &lt;code&gt;sv_setiv&lt;/code&gt; 및 &lt;code&gt;sv_setpv&lt;/code&gt; 이 반전했다, 다음 매크로 &lt;code&gt;SvPOK_on&lt;/code&gt; 는 대신 호출 할 필요가 &lt;code&gt;SvIOK_on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2507fa462b26287b008669ac5e4307de24ce4d06" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt;.</source>
          <target state="translated">의 순서 경우 &lt;code&gt;sv_setiv&lt;/code&gt; 및 &lt;code&gt;sv_setpv&lt;/code&gt; 이 반전했다, 다음 매크로 &lt;code&gt;SvPOK_on&lt;/code&gt; 는 대신 호출 할 필요가 &lt;code&gt;SvIOK_on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b0f391156a0e1896106ec41b93d3c42cc8fd48b" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . This is useful for propagating exceptions:</source>
          <target state="translated">출력이 비어 있고 &lt;code&gt;$@&lt;/code&gt; 에 값이 이미있는 경우 (일반적으로 이전 평가판의 값) &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 추가 한 후 해당 값이 재사용 됩니다. 이는 예외를 전파하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="25d81dad12165191ac2a4d2f3e667fda9ababd8e" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">출력이 비어 있고 &lt;code&gt;$@&lt;/code&gt; 에 값이 이미있는 경우 (일반적으로 이전 평가판의 값) &lt;code&gt;$@&lt;/code&gt; &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 를 추가 한 후 해당 값이 사용됩니다 . 이것은 거의 머물지 만, &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 완전히 유사한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="65e420bc5858eb45a1dddd4a10cb455bd1ce4cc1" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">출력이 비어 있고 &lt;code&gt;$@&lt;/code&gt; 에 값이 이미있는 경우 (일반적으로 이전 평가판의 값) &lt;code&gt;$@&lt;/code&gt; &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; 를 추가 한 후 해당 값이 사용됩니다 . 이것은 거의 머물지 만, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 완전히 유사한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2cfa46357b1516decacabae244126181d8b80b21" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">출력이 비어 있고 &lt;code&gt;$@&lt;/code&gt; 에 &lt;code&gt;PROPAGATE&lt;/code&gt; 메소드 가있는 오브젝트 참조가 포함 된 경우 해당 파일은 추가 파일 및 행 번호 매개 변수와 함께 호출됩니다. 리턴 값은 &lt;code&gt;$@&lt;/code&gt; 의 값을 대체합니다 . 즉, &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 호출되었다.</target>
        </trans-unit>
        <trans-unit id="a97492155e7589378bb301645dfa7c34b680ef04" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">출력이 비어 있고 &lt;code&gt;$@&lt;/code&gt; 에 &lt;code&gt;PROPAGATE&lt;/code&gt; 메소드 가있는 오브젝트 참조가 포함 된 경우 해당 파일은 추가 파일 및 행 번호 매개 변수와 함께 호출됩니다. 리턴 값은 &lt;code&gt;$@&lt;/code&gt; 의 값을 대체합니다 . 즉, &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 호출되었다.</target>
        </trans-unit>
        <trans-unit id="4e71a254b15b38644afabad82376b2bb1e4f7fab" translate="yes" xml:space="preserve">
          <source>If the output of the &lt;code&gt;h h&lt;/code&gt; command (or any command, for that matter) scrolls past your screen, precede the command with a leading pipe symbol so that it's run through your pager, as in</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; 명령 (또는 해당 문제에 대한 명령) 의 출력이 화면을지나 스크롤되면 명령 앞에 선행 파이프 기호가 표시되어 다음과 같이 페이저를 통해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f7911c6fed712fb085afb893540153d04c3ba2b2" translate="yes" xml:space="preserve">
          <source>If the package has a mailing list, include a URL or subscription instructions here.</source>
          <target state="translated">패키지에 메일 목록이있는 경우 여기에 URL 또는 구독 지침을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="2bd5efd382acc87571dd747451ad45f157dd85d7" translate="yes" xml:space="preserve">
          <source>If the package has a web site, include a URL here.</source>
          <target state="translated">패키지에 웹 사이트가있는 경우 여기에 URL을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="128d72462f8fdf7586cd07b73dc9169d6e753911" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFE&lt;/code&gt; has a minimal primary weight. The comparison between &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; and &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; first compares &lt;code&gt;$a1&lt;/code&gt; and &lt;code&gt;$b1&lt;/code&gt; at level 1, and then &lt;code&gt;$a2&lt;/code&gt; and &lt;code&gt;$b2&lt;/code&gt; at level 1, as followed.</source>
          <target state="translated">매개 변수가 true이면 &lt;code&gt;U+FFFE&lt;/code&gt; 의 최소 ​​기본 가중치가 있습니다. 간의 비교 &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; 제 비교 &lt;code&gt;$a1&lt;/code&gt; 과 &lt;code&gt;$b1&lt;/code&gt; 등급 1, 그리고 &lt;code&gt;$a2&lt;/code&gt; 및 &lt;code&gt;$b2&lt;/code&gt; 등급 1은 다음과 같이, .</target>
        </trans-unit>
        <trans-unit id="c1bc1d540aa212d81d3c27835031fe5adbb0eee1" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</source>
          <target state="translated">매개 변수가 true이면 &lt;code&gt;U+FFFF&lt;/code&gt; 의 기본 중량이 가장 높습니다. 시의 부울 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; 와 &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; 에 해당하는 것으로,이를 것으로 예상된다 &lt;code&gt;$str&lt;/code&gt; 시작 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 또는 이와 동등한 다른 기본 항목입니다. &lt;code&gt;$str&lt;/code&gt; 은 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; 일 수 있지만 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; 와 같은 &lt;code&gt;U+FFFF&lt;/code&gt; 를 포함하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="bd592631134dd93dfb6509b2405e1e6bdddd05d2" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;, &lt;code&gt;&quot;abc012&quot;&lt;/code&gt;, but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt;.</source>
          <target state="translated">매개 변수가 참이면 &lt;code&gt;U+FFFF&lt;/code&gt; 는 가장 높은 1 차 가중치를 갖습니다. 시의 부울 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; 와 &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; 에 해당하는 것으로,이를 것으로 예상된다 &lt;code&gt;$str&lt;/code&gt; 시작 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , 또는 다른 1 차 동등 물. &lt;code&gt;$str&lt;/code&gt; 은 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; 일 수 있지만 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; 와 같은 &lt;code&gt;U+FFFF&lt;/code&gt; 는 포함하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="2379a678967ce11b206cce9256eec402c626744e" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt; , the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">매개 변수가 true이면 최종 타이 브레이킹 레벨이 사용됩니다. 무게의 차이에 의해 지정된 모든 수준을 통해 비교 한 후 발견되지 않는 경우 &lt;code&gt;level&lt;/code&gt; , 코드 포인트와 비교가 수행됩니다. 동점 비교를 위해 정렬 키에는 원래 문자열의 코드 포인트가 추가됩니다. 완전히 무시할 수있는 문자는 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf3801fdcc987b0c168aed25eff11116ed2d9d13" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt;, the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">매개 변수가 참이면 최종 순위 결정 레벨이 사용됩니다. 무게의 차이에 의해 지정된 모든 수준을 통해 비교 한 후 발견되지 않는 경우 &lt;code&gt;level&lt;/code&gt; , 코드 포인트와 비교가 수행됩니다. 타이 브레이킹 비교를 위해 정렬 키에는 원래 문자열의 코드 포인트가 추가됩니다. 완전히 무시할 수있는 문자는 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6d70ed0cf4279c5cf91d7d6890341737c51d4df" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, accents (and other primary ignorable characters) are ignored, even though cases are taken into account.</source>
          <target state="translated">이 매개 변수가 true이면 대소 문자를 고려하더라도 악센트 (및 기타 무시할 수없는 문자)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ffce08d047eaee75c853cd8ab3be63e13efe5a7" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, for a contraction with three or more characters (here nicknamed &quot;long contraction&quot;), initial substrings will be handled. For example, a contraction ABC, where A is a starter, and B and C are non-starters (character with non-zero combining character class), will be detected even if there is not AB as a contraction.</source>
          <target state="translated">매개 변수가 true 인 경우 3 자 이상의 수축 (여기서 &quot;긴 수축&quot;이라는 별명)이있는 수축의 경우 초기 하위 문자열이 처리됩니다. 예를 들어, 수축 ABC는 A가 시작이고 B와 C가 시작이 아닌 (0이 아닌 결합 문자 클래스를 갖는 문자) 수축이 AB가 아니더라도 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="6196ed90d85a5642d1f2bff307d9850731d3ee76" translate="yes" xml:space="preserve">
          <source>If the parameters to the INCLUDE: keyword are followed by a pipe (&lt;code&gt;|&lt;/code&gt;) then the compiler will interpret the parameters as a command. This feature is mildly deprecated in favour of the &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; directive, as documented below.</source>
          <target state="translated">INCLUDE : 키워드에 대한 매개 변수 뒤에 파이프 ( &lt;code&gt;|&lt;/code&gt; ) 가 오는 경우 컴파일러는 매개 변수를 명령으로 해석합니다. 이 기능은 아래에 설명 된 것처럼 &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; 지시문 을 위해 약간 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60984150a4a273c37051fdd1024089806a686df1" translate="yes" xml:space="preserve">
          <source>If the parent process is killed (either using Perl's kill() builtin, or using some external means) all the pseudo-processes are killed as well, and the whole process exits.</source>
          <target state="translated">상위 프로세스가 종료되면 (Perl의 kill () 내장 또는 일부 외부 수단 사용) 모든 의사 프로세스도 종료되고 전체 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="aa64f5b5dc3063c1ec88bf3714d6a78f8885563e" translate="yes" xml:space="preserve">
          <source>If the pattern contains embedded code, such as</source>
          <target state="translated">패턴에 다음과 같은 내장 코드가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="c8e637c05d0476b3ff64dcc72c39f7a79e3a588a" translate="yes" xml:space="preserve">
          <source>If the pattern contains its delimiter within it, that delimiter must be escaped. Prefixing it with a backslash (</source>
          <target state="translated">패턴에 구분 기호가 포함 된 경우 해당 구분 기호를 이스케이프해야합니다. 백 슬래시 (</target>
        </trans-unit>
        <trans-unit id="400ab285c2500104132be9cd3fcc1a752df8a4f5" translate="yes" xml:space="preserve">
          <source>If the pattern does not match any pathname, then bsd_glob() returns a list consisting of only the pattern. If &lt;code&gt;GLOB_QUOTE&lt;/code&gt; is set, its effect is present in the pattern returned.</source>
          <target state="translated">패턴이 경로 이름과 일치하지 않으면 bsd_glob ()는 패턴으로 만 구성된 목록을 반환합니다. 경우 &lt;code&gt;GLOB_QUOTE&lt;/code&gt; 가 설정되어, 그 효과가 반환 패턴으로 존재한다.</target>
        </trans-unit>
        <trans-unit id="6adde583f90fd2399e3928b4e6217841c09c97fb" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; , or &lt;code&gt;GPOS&lt;/code&gt; . See the table below.</source>
          <target state="translated">패턴이 소수의 위치에서만 일치 할 수있는 경우 &lt;code&gt;TYPE&lt;/code&gt; 은 &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; 또는 &lt;code&gt;GPOS&lt;/code&gt; 입니다. 아래 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40469f0b5b6e999f3b3f0091f7983d3535304a67" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt;, &lt;code&gt;MBOL&lt;/code&gt;, or &lt;code&gt;GPOS&lt;/code&gt;. See the table below.</source>
          <target state="translated">패턴이 &lt;code&gt;TYPE&lt;/code&gt; 이 &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; 또는 &lt;code&gt;GPOS&lt;/code&gt; 인 소수의 위치에서만 일치 할 수있는 경우 . 아래 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0ce5cbb841f39a51912df72d9768f6a6a5fae33" translate="yes" xml:space="preserve">
          <source>If the pattern was used as follows</source>
          <target state="translated">패턴이 다음과 같이 사용 된 경우</target>
        </trans-unit>
        <trans-unit id="2dd05fadef47c4bd45462fdfaa94e04afc77ad22" translate="yes" xml:space="preserve">
          <source>If the performance in such cases is unacceptable, you may defer the actual writing, and then have it done all at once. The following loop will perform much better for large files:</source>
          <target state="translated">그러한 경우 성능이 만족스럽지 않으면 실제 작문을 연기 한 다음 한 번에 수행하도록 할 수 있습니다. 다음 루프는 큰 파일의 경우 훨씬 더 잘 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="956656b1b2d0c77e2fbe4d0d92677dc48070a8ed" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :</source>
          <target state="translated">플랫폼이 MS-DOS와 같고 일반적으로 CRLF에서 텍스트 파일을 &quot;\ n&quot;로 변환하는 경우 기본 레이어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f1c5a6b0ba8f7ba98047b8fb60cfdcca7e45034" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are:</source>
          <target state="translated">플랫폼이 MS-DOS와 같고 일반적으로 텍스트 파일에 대해 CRLF를 &quot;\ n&quot;으로 변환하는 경우 기본 계층은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fee788dad0c5b1cd15e2fa5ddb122d4f9bd910af" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;code&gt;langinfo(CODESET)&lt;/code&gt; interface, the codeset returned is used as the default encoding for the open pragma.</source>
          <target state="translated">플랫폼이 &lt;code&gt;langinfo(CODESET)&lt;/code&gt; 인터페이스를 지원하는 경우, 반환 된 코드 세트가 열린 pragma의 기본 인코딩으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e029b7bfe44b40ce79cdafd38dd9f57646af8f39" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then a warning will be issued.</source>
          <target state="translated">모든 스레드가 결합 또는 분리되지 않고 프로그램이 종료되면 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="68122aab68b9511758161a833aab14bd7cf8f3f4" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then this warning will be issued.</source>
          <target state="translated">모든 스레드가 결합 또는 분리되지 않고 프로그램이 종료되면이 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="3f05e0c9adcc7343a41a8d24201ee4c19ce64a54" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</source>
          <target state="translated">스위치를 통해 프로그램이 펄에 부여 된 경우 &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; 문자열을 포함하는 것 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b296afa5e8ade3ba3ac78a9d465e171ac5067f8" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt;.</source>
          <target state="translated">스위치를 통해 프로그램이 펄에 부여 된 경우 &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; 문자열을 포함하는 것 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="187d3c3b9917db708f6b4997f1f577493d56ad38" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">프로그램이 구문 상 올바른 경우 실행됩니다. exit () 또는 die () 연산자를 누르지 않고 프로그램이 끝까지 실행되는 경우 내재적 인 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 이 제공되어 성공적인 완료를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7da837d3689d8811d08d5a2ade1a1a152e04568" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;exit(0)&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">프로그램이 구문 상 올 바르면 실행됩니다. 프로그램이 exit () 또는 die () 연산자를 누르지 않고 끝까지 실행 되면 성공적인 완료를 나타 내기 위해 암시 적 &lt;code&gt;exit(0)&lt;/code&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf82d5604429bbfe1cb41298b645fa1f014e9ae" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">속성에 이러한 제한된 집합이 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f561839327dfb379f3ced83b14775ceeeefed09a" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">속성에 이러한 제한된 집합이 없으면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f736ee647a4d5e1589838b72f5b05af7545714ad" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">등록 정보 이름을 알 수 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다. Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄이 있거나없는)를 사용하여 정규식에서 특성 이름을 인식합니다 . 이 함수는 property 매개 변수의 것을 인식하지 않고 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="c8e6c1687e04cb1c576cc3de9ba670b370bee76a" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">속성 이름을 알 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. Perl은 일반적 으로 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 와 같이 접두사가 붙은 선택적 &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;(밑줄 포함 또는 제외)가 있는 정규식의 속성 이름을 인식합니다 . 이 함수는 속성 매개 변수의 항목을 인식하지 않고 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="afaf0816b79f3c9b4d1b468e6b1d9a01691cd781" translate="yes" xml:space="preserve">
          <source>If the protocol is set to &quot;tcp&quot;, this method may be called any number of times, and each call to the ping() method (below) will use the most recent $local_addr. If the protocol is &quot;icmp&quot; or &quot;udp&quot;, then bind() must be called at most once per object, and (if it is called at all) must be called before the first call to ping() for that object.</source>
          <target state="translated">프로토콜이 &quot;tcp&quot;로 설정된 경우이 메소드는 여러 번 호출 될 수 있으며 ping () 메소드 (아래)를 호출 할 때마다 가장 최근의 $ local_addr이 사용됩니다. 프로토콜이 &quot;icmp&quot;또는 &quot;udp&quot;인 경우, 오브젝트 당 최대 한 번 bind ()를 호출해야하며, 해당 오브젝트에 대한 ping ()을 처음 호출하기 전에 (전혀 호출되는 경우) 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd278d79ed04376a1ab23bc38f3813d0d8a95858" translate="yes" xml:space="preserve">
          <source>If the prototypes are enabled, you can disable it locally for a given XSUB as in the following example:</source>
          <target state="translated">프로토 타입이 활성화 된 경우 다음 예제와 같이 지정된 XSUB에 대해 로컬로 프로토 타입을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22222d2992db775cc93f4e6df7a745c81e01a6be" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">참조 된 객체가 패키지에 들어간 경우 해당 패키지 이름이 대신 반환됩니다. 그러나 이제는 &quot;나쁜 습관&quot;으로 간주되므로 사용하지 마십시오. 한 가지 이유 때문에 객체는 &lt;code&gt;Regexp&lt;/code&gt; 또는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;code&gt;HASH&lt;/code&gt; 클래스를 사용할 수 있습니다 . 또한 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;isa&lt;/code&gt; 와 같은 하위 클래스를 고려 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf268542a8929b7e398cc1536659093d140d5216" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">참조 된 객체가 패키지에 들어간 경우 해당 패키지 이름이 대신 반환됩니다. 그러나 이제는 &quot;나쁜 습관&quot;으로 간주되므로 사용하지 마십시오. 한 가지 이유 때문에 객체는 &lt;code&gt;Regexp&lt;/code&gt; 또는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;code&gt;HASH&lt;/code&gt; 클래스를 사용할 수 있습니다 . 또한 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;isa&lt;/code&gt; 와 같은 하위 클래스를 고려 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e68bc71ae659a158de263698e821903752a759" translate="yes" xml:space="preserve">
          <source>If the referred library is an archive library, then it is treated as a simple collection of .o modules (all of which must contain PIC). These modules are then linked into the shared library.</source>
          <target state="translated">참조 된 라이브러리가 아카이브 라이브러리 인 경우, 간단한 .o 모듈 콜렉션 (모두 PIC를 포함해야 함)으로 취급됩니다. 그런 다음이 모듈은 공유 라이브러리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="487c69f3c32cf6208263be856047bd1120b5cb11" translate="yes" xml:space="preserve">
          <source>If the regex engine was entered, the output may look like this:</source>
          <target state="translated">정규식 엔진을 입력 한 경우 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4071da6362bfae97335d6ccd04527e0675ca1ecf" translate="yes" xml:space="preserve">
          <source>If the remote server sends data a byte at time, and you need that data immediately without waiting for a newline (which might not happen), you may wish to replace the &lt;code&gt;while&lt;/code&gt; loop in the parent with the following:</source>
          <target state="translated">원격 서버가 한 번에 한 바이트 씩 데이터를 보내고 개행을 기다리지 않고 즉시 해당 데이터가 필요한 경우 (발생하지 않을 수도 있음) 부모 의 &lt;code&gt;while&lt;/code&gt; 루프를 다음과 같이 바꾸려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78e886a06c0d6c64ae06980c39f4979b0d06c657" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt; , the offset is relative to the start of the packed string.</source>
          <target state="translated">반복 횟수가 &lt;code&gt;*&lt;/code&gt; 이면 오프셋은 묶음 문자열의 시작을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="0c6d8ab738d17a47ddcc7210024698f2d723ba66" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt;, the offset is relative to the start of the packed string.</source>
          <target state="translated">반복 횟수가 &lt;code&gt;*&lt;/code&gt; 이면 오프셋은 압축 된 문자열의 시작을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="71535d2706781140ebf79d95c5c1eb0328f89697" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt; , it's relative to the current position.</source>
          <target state="translated">반복 횟수가 &lt;code&gt;0&lt;/code&gt; 이면 현재 위치를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="8bb595e18165255d40d28696ced7cb987361acca" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt;, it's relative to the current position.</source>
          <target state="translated">반복 횟수가 &lt;code&gt;0&lt;/code&gt; 이면 현재 위치를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="adddd684b7b4b320c5c6cd3d4e144f8d42b00be2" translate="yes" xml:space="preserve">
          <source>If the requested class doesn't yet exist, this function will still succeed, and return &lt;code&gt;[ $classname ]&lt;/code&gt;</source>
          <target state="translated">요청 된 클래스가 존재하지 않으면이 함수는 계속 성공하고 &lt;code&gt;[ $classname ]&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c8df40676c5ef413c4d428cc8bce1edd4a74be" translate="yes" xml:space="preserve">
          <source>If the required version is older than Perl 5.10, the &quot;:default&quot; feature bundle is automatically loaded instead.</source>
          <target state="translated">필요한 버전이 Perl 5.10보다 오래된 경우 &quot;: default&quot;기능 번들이 대신 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="d407bfa98e92001cef51aaea080c36419318c881" translate="yes" xml:space="preserve">
          <source>If the result is a fraction, it is converted into a floating point number to the accuracy of your platform.</source>
          <target state="translated">결과가 분수 인 경우 플랫폼 정확도에 따라 부동 소수점 숫자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0f32bf4dd5015a300ddb6707d47fae5eba9e46c" translate="yes" xml:space="preserve">
          <source>If the result is multiple script names, they are returned joined into a single comma-separated string.</source>
          <target state="translated">결과가 여러 스크립트 이름 인 경우 단일 쉼표로 구분 된 문자열로 결합되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45ec7fbff805996e6714524f94283d541160e6c3" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt; , the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">XSUB의 리턴 유형에 &lt;code&gt;static&lt;/code&gt; 이 포함 된 경우 메소드는 정적 메소드로 간주됩니다. class :: method () 구문을 사용하여 C ++ 함수를 호출합니다. 메소드가 정적이 아닌 경우 THIS-&amp;gt; method () 구문을 사용하여 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b467c0c1883d9fa2c1ada74a10e9d69505846ac1" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt;, the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">XSUB의 반환 유형에 &lt;code&gt;static&lt;/code&gt; 이 포함 된 경우 메서드는 정적 메서드로 간주됩니다. class :: method () 구문을 사용하여 C ++ 함수를 호출합니다. 메서드가 정적이 아닌 경우 함수는 THIS-&amp;gt; method () 구문을 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0b11488412f3e860557eb1891af20655d0de0fe4" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&quot;wrap_code_refs_within&quot;&lt;/a&gt;.</source>
          <target state="translated">reval ()의 반환 값이 코드 참조이거나 포함 된 경우 해당 코드 참조는 항상 구획에서 실행되도록 래핑됩니다. &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&quot;wrap_code_refs_within&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95ff7ce638cb043eea1113e455241d4090a0ba15" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;.</source>
          <target state="translated">reval ()의 반환 값이 코드 참조이거나 포함 된 경우 해당 코드 참조는 항상 구획에서 실행되도록 랩핑됩니다. &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b5b2e1517f57a24f52793e2d523bf3e3916b624" translate="yes" xml:space="preserve">
          <source>If the revision (previously &quot;tracking version&quot;) number of UCA is given, behavior of that revision is emulated on collating. If omitted, the return value of &lt;code&gt;UCA_Version()&lt;/code&gt; is used.</source>
          <target state="translated">UCA 개정판 (이전의 &quot;추적 버전&quot;) 수가 제공되면 해당 개정판의 동작이 조합시 에뮬레이트됩니다. 생략하면 &lt;code&gt;UCA_Version()&lt;/code&gt; 의 반환 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a7a3bfd506eaa3a5969fb39449cbd90048c5cd5" translate="yes" xml:space="preserve">
          <source>If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so</source>
          <target state="translated">올바른 인수가 검색 패턴, 대체 또는 음역이 아닌 표현식 인 경우 런타임시 검색 패턴으로 해석됩니다. 이는 내용이 두 번 보간됨을 의미하므로</target>
        </trans-unit>
        <trans-unit id="397d47eee4fc1ac1405170a336868a5dec199f77" translate="yes" xml:space="preserve">
          <source>If the same C type is used in several different contexts which require different translations, &lt;code&gt;typedef&lt;/code&gt; several new types mapped to this C type, and create separate</source>
          <target state="translated">다른 번역이 필요한 여러 컨텍스트에서 동일한 C 유형을 사용 하는 경우이 C 유형에 맵핑 된 몇 가지 새 유형을 &lt;code&gt;typedef&lt;/code&gt; 로 작성하고 개별적으로 작성하십시오</target>
        </trans-unit>
        <trans-unit id="456756c29fcce7da570891f767727aa9e1c8ea70" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt; , mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">같은 문자 (또는 문자 시퀀스)를 통해 조합 요소 테이블에있는 경우 &lt;code&gt;table&lt;/code&gt; , 정렬 요소에 매핑이 무시됩니다. 존재하지 않는 경우 매핑이 추가로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e4dde7b413bfb31794120513bb19ebe90728fd10" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt;, mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">같은 문자 (또는 문자 시퀀스)를 통해 조합 요소 테이블에있는 경우 &lt;code&gt;table&lt;/code&gt; , 정렬 요소에 매핑이 무시됩니다. 존재하지 않는 경우 매핑이 추가로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="250b229660b09d1a93cecb0077c43fdb021bc44f" translate="yes" xml:space="preserve">
          <source>If the scalar contains a number the raw SV will be leaner.</source>
          <target state="translated">스칼라에 숫자가 포함되어 있으면 원시 SV가 더 적습니다.</target>
        </trans-unit>
        <trans-unit id="129cba7aa8d1059953f619ec45963493064daafb" translate="yes" xml:space="preserve">
          <source>If the scalar from the previous example had an extra reference:</source>
          <target state="translated">이전 예제의 스칼라에 추가 참조가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="942a6cfe1787a0e79c2fbf6e9025269b48593e53" translate="yes" xml:space="preserve">
          <source>If the script says that your package is incomplete, and asks whether to continue, just answer with Y (this can only happen if you don't use long filenames or forget to issue &quot;set FNCASE=y&quot; first).</source>
          <target state="translated">스크립트가 패키지가 불완전하다고 말하고 계속할지 묻는다면 Y로 답하십시오 (긴 파일 이름을 사용하지 않거나 &quot;set FNCASE = y&quot;를 먼저 발행하는 것을 잊은 경우에만 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1ebc636a0a5f78fe0991b4d30678c7a47413c67b" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;s, then &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;How can I capture STDERR from an external command?&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">A와 두 번째 인수가 파이프 경우 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 쉘 메타 문자를 포함 펄 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 이야, 다음 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 메타 문자를 디코딩하고 결국 원하는 프로그램을 실행하는 쉘 SA. 프로그램을 실행할 수 없으면 펄이 아니라 메시지를받는 것이 쉘입니다. 펄 프로그램에서 찾을 수있는 것은 쉘 자체가 성공적으로 시작될 수 있는지 여부입니다. 여전히 쉘의 STDERR을 캡처하여 오류 메시지를 확인할 수 있습니다. &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;외부 명령에서 STDERR을 캡처하는 방법을&lt;/a&gt; 참조하십시오 . 이 문서의 다른 곳에 있거나 &lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c86f791ed05e6400ffb0303d6157f674dcf38a9" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;open()&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;fork()&lt;/code&gt;s, then &lt;code&gt;exec()&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&quot;How can I capture STDERR from an external command?&quot;&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">파이프 된 &lt;code&gt;open()&lt;/code&gt; 대한 두 번째 인수에 쉘 메타 문자, perl &lt;code&gt;fork()&lt;/code&gt; , &lt;code&gt;exec()&lt;/code&gt; sa 쉘이 포함되어 메타 문자를 디코딩하고 원하는 프로그램을 실행합니다. 프로그램을 실행할 수없는 경우 메시지를받는 것은 Perl이 아니라 셸입니다. Perl 프로그램이 알아낼 수있는 모든 것은 쉘 자체가 성공적으로 시작될 수 있는지 여부입니다. 여전히 셸의 STDERR을 캡처하고 오류 메시지를 확인할 수 있습니다. 를 참조하십시오 &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&quot;나는 외부 명령에서 STDERR을 캡처 할 수 있습니까?&quot;&lt;/a&gt; 이 문서의 다른 곳에서 또는 &lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a485d6980d01df96f56ec659ef159a6f3e30c7c" translate="yes" xml:space="preserve">
          <source>If the second operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">두 번째 피연산자에 &quot;nomethod&quot;메소드가 있으면이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d89fc930c903cfb2489602dfe78fa395aab16a02" translate="yes" xml:space="preserve">
          <source>If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.</source>
          <target state="translated">두 번째 매개 변수 (부울)가 생략되거나 거짓이면 분해는 정식 분해입니다. 두 번째 매개 변수 (부울)가 true 인 경우 분해는 호환성 분해입니다.</target>
        </trans-unit>
        <trans-unit id="cdc3a4f8b493e77f4b46b059968dc0b38f7409ec" translate="yes" xml:space="preserve">
          <source>If the selected element is outside the string, the value 0 is returned. If an element off the end of the string is written to, Perl will first extend the string with sufficiently many zero bytes. It is an error to try to write off the beginning of the string (i.e., negative OFFSET).</source>
          <target state="translated">선택된 요소가 문자열 외부에 있으면 값 0이 리턴됩니다. 문자열 끝의 요소가 쓰여지면 Perl은 먼저 0 바이트로 문자열을 확장합니다. 문자열의 시작 부분 (예 : 음수 OFFSET)을 쓰려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0efffe8f3cec0c66bc0076cfbf0d0f016059fa0" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until either the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by, or until the timeout is reached.</source>
          <target state="translated">세마포어의 개수가 0 아래로 떨어지면이 메서드는 세마포어의 개수가 세마포어의 개수를 &lt;code&gt;down&lt;/code&gt; 양보다 크거나 같을 때까지 또는 시간 초과에 도달 할 때까지 차단됩니다 .</target>
        </trans-unit>
        <trans-unit id="08309d3b072967d3ab275a7c77649be9b9f2f474" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt; ing the semaphore's count by.</source>
          <target state="translated">세마포어 카운트가 0 아래로 떨어지면이 방법은 세마포어 카운트가 세마포어 카운트를 &lt;code&gt;down&lt;/code&gt; 양보다 크거나 같은 시간까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="083a8e90721e210cc119c4e7060a13485c79131e" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by.</source>
          <target state="translated">세마포어의 카운트가 0 아래로 떨어지면이 메서드는 세마포어의 카운트가 세마포어의 카운트를 &lt;code&gt;down&lt;/code&gt; 양보다 크거나 같을 때까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="49cf6efaba2d8b062462556a6172122cd62a7391" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will return</source>
          <target state="translated">세마포어 수가 0 아래로 떨어지면이 메소드는</target>
        </trans-unit>
        <trans-unit id="43da8fe1e0dfe354dcb09a89c8401b1d0438aefd" translate="yes" xml:space="preserve">
          <source>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be &lt;code&gt;SCX_Unknown&lt;/code&gt;. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</source>
          <target state="translated">시퀀스에 사용중인 유니 코드 버전의 문자에 할당되지 않은 단일 코드 포인트가 포함 된 경우 함수는 TRUE를 반환하고 스크립트는 &lt;code&gt;SCX_Unknown&lt;/code&gt; 입니다. 입력 시퀀스에서 할당되지 않은 코드 포인트의 다른 조합은 입력을 스크립트 실행이 아닌 것으로 처리하는 함수가됩니다.</target>
        </trans-unit>
        <trans-unit id="ecadb78dff58886929648354bb050576d1075181" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, TRUE is returned, but &lt;code&gt;*ret_script&lt;/code&gt; (if asked for) will be &lt;code&gt;SCX_INVALID&lt;/code&gt;.</source>
          <target state="translated">시퀀스가 비어 있으면 TRUE가 반환되지만 &lt;code&gt;*ret_script&lt;/code&gt; (요청 된 경우)는 &lt;code&gt;SCX_INVALID&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="feaf413a0792a40fde39688dd7794f1b79d23f9d" translate="yes" xml:space="preserve">
          <source>If the shareable image isn't in any of these places, you'll need to define a logical name</source>
          <target state="translated">공유 가능한 이미지가이 위치에 없으면 논리적 이름을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="34b3b705ebfb832784afae8421a8cf44e644e9c0" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">소켓이 연결된 상태이면 피어 주소가 반환됩니다. 소켓이 연결된 상태가 아니면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d77daa474d5b520bbe270f2db415132f8e51945" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, undef is returned.</source>
          <target state="translated">소켓이 연결 상태에 있으면 피어 주소가 반환됩니다. 소켓이 연결 상태가 아닌 경우 undef가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bc839afaf75ab77ac378c573dd37cfe67fada222" translate="yes" xml:space="preserve">
          <source>If the source number can be represented in the target form, that representation is used.</source>
          <target state="translated">소스 번호를 대상 형식으로 표현할 수 있으면 해당 표현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad2456e62439e41ca828e4d7a559faef86d9a12f" translate="yes" xml:space="preserve">
          <source>If the source number is between two numbers representable in the target form, a representation of one of these numbers is used. (</source>
          <target state="translated">소스 번호가 대상 형식으로 표현할 수있는 두 숫자 사이 인 경우이 숫자 중 하나의 표현이 사용됩니다. (</target>
        </trans-unit>
        <trans-unit id="5807a3edb0534ce60ac2857df2fbffa4467c6e15" translate="yes" xml:space="preserve">
          <source>If the source number is outside of the limits representable in the target form, a representation of the closest limit is used. (</source>
          <target state="translated">소스 번호가 목표 형식으로 표현할 수있는 한계를 벗어난 경우 가장 가까운 한계의 ​​표현이 사용됩니다. (</target>
        </trans-unit>
        <trans-unit id="a2b6fc7f507aeb4c29a8733766d6c6136c45fda9" translate="yes" xml:space="preserve">
          <source>If the special input filename &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; is given then the STDIN filehandle is used for input (and no open or close is performed). If no input filename is specified then &quot;-&quot; is implied. Filehandle references, or objects that support the regular IO operations (like &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; or &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt;getline&amp;gt;) are also accepted; the handles must already be opened.</source>
          <target state="translated">특수 입력 파일 이름 &quot;&quot;, &quot;-&quot;또는 &quot;&amp;lt;&amp;amp; STDIN&quot;이 제공되면 STDIN 파일 핸들이 입력에 사용되며 열기 또는 닫기가 수행되지 않습니다. 입력 파일 이름을 지정하지 않으면 &quot;-&quot;가 암시됩니다. 파일 핸들 참조 또는 일반 IO 작업을 지원하는 객체 (예 : &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt; getline&amp;gt;)도 허용됩니다. 핸들이 이미 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3247f1e5568a45232c218d52498138f8657c71b9" translate="yes" xml:space="preserve">
          <source>If the specification of the class was not completely valid, the message indicates that.</source>
          <target state="translated">클래스 사양이 완전히 유효하지 않은 경우 메시지가이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ec8f0307ac0cd29be9e31e20412d0003c85f12a" translate="yes" xml:space="preserve">
          <source>If the standard options aren't enough, you may want to subclass Pod::Simple::XHMTL. These are the most likely candidates for methods you'll want to override when subclassing.</source>
          <target state="translated">표준 옵션이 충분하지 않으면 Pod :: Simple :: XHMTL을 서브 클래스화할 수 있습니다. 서브 클래 싱 할 때 재정의하려는 메소드에 가장 적합한 후보입니다.</target>
        </trans-unit>
        <trans-unit id="c57481fa08ceb2f9368092d11351ebd6c6865947" translate="yes" xml:space="preserve">
          <source>If the string can not be interpreted, NaN is returned.</source>
          <target state="translated">문자열을 해석 할 수 없으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc03084e4b347434da04ee646a45ae6dc9795b98" translate="yes" xml:space="preserve">
          <source>If the string exception does not end in a newline, the current script line number and input line number (if any) and a newline are appended to it. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&quot;$/&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;&quot;$.&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">문자열 예외가 개행으로 끝나지 않으면 현재 스크립트 행 번호와 입력 행 번호 (있는 경우) 및 개행이 추가됩니다. &quot;input line number&quot;( &quot;chunk&quot;라고도 함)는 현재 유효한 &quot;line&quot;개념에 따라 달라지며 특수 변수 &lt;a href=&quot;perlvar#%24.&quot;&gt; &lt;code&gt;$.&lt;/code&gt; &lt;/a&gt; 로도 사용할 수 있습니다 . . &lt;a href=&quot;perlvar#%24%2F&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;perlvar#%24.&quot;&gt;&quot;$ &lt;/a&gt;&quot;의 &quot;$ /&quot;를 참조하십시오 . perlvar .</target>
        </trans-unit>
        <trans-unit id="61afcdbf0b63afa329f8dddf52dc441cb7c93f4b" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; tries to convert it to use a one-byte-per-character internal representation. However, if the string contains characters with values of 256 or higher, a fatal error will occur.</source>
          <target state="translated">문자열이 내부적으로 UTF-8로 인코딩되어 UTF8 플래그가 설정된 경우 &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt; &lt;code&gt;vec&lt;/code&gt; &lt;/a&gt; 은 문자 당 1 바이트 내부 표현을 사용하도록 변환하려고합니다. 그러나 문자열에 256 이상의 값을 가진 문자가 포함되어 있으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95c4f5fed91805150d0fb1f5cc265445f3719afe" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">문자열이 내부적으로 UTF-8로 인코딩되어 UTF8 플래그 세트가있는 경우 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 에 의해 무시되며 , 문자열이있는 문자 만있는 경우에도 개념적 문자열이 아닌 내부 바이트 문자열에서 작동합니다. 256보다 작은 값.</target>
        </trans-unit>
        <trans-unit id="e46f7dff46b6e909ca2a4c0f1cd989e3474f6367" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">문자열이 내부적으로 UTF-8로 인코딩되어 UTF8 플래그 세트가있는 경우 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 에 의해 무시되며 , 문자열이있는 문자 만있는 경우에도 개념적 문자열이 아닌 내부 바이트 문자열에서 작동합니다. 256보다 작은 값.</target>
        </trans-unit>
        <trans-unit id="7652f3d26c3d783ee2b0cdbd7edb6550d6506acc" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary number.</source>
          <target state="translated">문자열에 &quot;0b&quot;접두사가 있으면 이진수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="88ff0fdfcd38431066beb5169d3e97b3f28b4513" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0x&quot; prefix, it is interpreted as a hexadecimal number.</source>
          <target state="translated">문자열에 &quot;0x&quot;접두사가 있으면 16 진수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="556906a3727707516e15ba62fe70b3006b4bd52d" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. Note that this need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , for example returns -0.5.</source>
          <target state="translated">문자열의 길이가 한 문자이면 유니 코드 숫자 값이 있으면 반환되고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다. 이것은 정수일 필요는 없습니다. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 예를 들어 -0.5를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fce93c48f5e7099a349c6ef5a41848fb5f748c7" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;undef&lt;/code&gt; otherwise. If the optional scalar ref is passed, it would be set to 1 if the return is valid; or 0 if the return is &lt;code&gt;undef&lt;/code&gt;. Note that the numeric value returned need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt;, for example returns -0.5.</source>
          <target state="translated">문자열의 길이가 한 문자이면 유니 코드 숫자 값이 반환되고 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. 선택적 스칼라 참조가 전달되면 반환이 유효하면 1로 설정됩니다. 또는 반환이 &lt;code&gt;undef&lt;/code&gt; 인 경우 0 입니다. 반환 된 숫자 값은 정수일 필요는 없습니다. 예를 들어 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 는 -0.5를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c98175c6574b582a8455429e44a48ac7e74d895" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt; ), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless all the digits in the string come from the same set.</source>
          <target state="translated">문자열이 둘 이상의 문자 인 경우 , 동일한 스크립트에서 모든 문자가 10 진수 (즉, &lt;code&gt;\d+&lt;/code&gt; 와 일치)가 아니면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴 됩니다. 예를 들어 ASCII '0'과 Bengali '3'이 함께 혼합되어 있으면 유효한 숫자로 간주되지 않으며 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다. 추가 제한 사항은 숫자가 모두 같은 형식이어야한다는 것입니다. 반각 자릿수와 전각 자릿수를 혼합하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환 됩니다. 아랍어 스크립트에는 두 자리 숫자가 있습니다. 문자열의 모든 숫자가 동일한 세트에서 나오지 않으면 &lt;code&gt;num&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="38c89008b47ecbaadc076b7aa2f24f0e7c6c9985" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;undef&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt;), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;undef&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;undef&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; unless all the digits in the string come from the same set. In all cases, the optional scalar ref parameter is set to how long any valid initial substring of digits is; hence it will be set to the entire string length if the main return value is not &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">문자열이 둘 이상의 문자 인 경우 동일한 스크립트에서 모든 문자가 10 진수 (즉, &lt;code&gt;\d+&lt;/code&gt; 와 일치)가 아니면 &lt;code&gt;undef&lt;/code&gt; 가 반환 됩니다. 예를 들어 ASCII '0'과 벵골어 '3'이 혼합 된 경우 유효한 숫자로 간주되지 않고 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. 추가 제한은 숫자가 모두 같은 형식이어야한다는 것입니다. 반자 숫자와 전각 숫자가 혼합되면 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. 아랍어 스크립트에는 두 세트의 숫자가 있습니다. &lt;code&gt;num&lt;/code&gt; 은 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.문자열의 모든 숫자가 동일한 세트에서 나오지 않는 한. 모든 경우에 선택적 스칼라 ref 매개 변수는 숫자의 유효한 초기 하위 문자열의 길이로 설정됩니다. 따라서 주 반환 값이 &lt;code&gt;undef&lt;/code&gt; 가 아니면 전체 문자열 길이로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fc51a016846748fdbc037c08fcea8e548c16fe0" translate="yes" xml:space="preserve">
          <source>If the string used for the filename and/or comment is not valid UTF-8 when this option is true, the script will die with a &quot;wide character&quot; error.</source>
          <target state="translated">이 옵션이 true 일 때 파일 이름 및 / 또는 주석에 사용 된 문자열이 유효한 UTF-8이 아닌 경우 스크립트는 &quot;와이드 문자&quot;오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="bc54c0830b9373d2798de2bf5260229a62e838a3" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. Execution of the subroutine will likely be a no-op, unless &lt;code&gt;sv&lt;/code&gt; was a tied array or the caller modified the subroutine in some interesting way before it was executed. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the treatment is buggy: the sub will be executed when only half built, and may be deleted prematurely, possibly causing a crash.</source>
          <target state="translated">서브 루틴에 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 와 같은 몇 가지 특수 이름 중 하나가 있으면 단계 관련 서브 루틴의 자동 실행을 위해 적절한 큐에서 요청합니다. 이 경우 관련 glob은 이전에 서브 루틴을 포함 했더라도 서브 루틴을 포함하지 않는 상태로 남습니다. &lt;code&gt;sv&lt;/code&gt; 가 묶인 배열이거나 호출자가 실행되기 전에 흥미로운 방식으로 서브 루틴을 수정 하지 않는 한, 서브 루틴의 실행은 작동하지 않을 것입니다. &lt;code&gt;BEGIN&lt;/code&gt; 의 경우 처리는 버그가 있습니다. 서브는 절반 만 빌드되었을 때 실행되며 조기에 삭제되어 충돌을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1db3945f60801d9fe74fe01151fa3c625ba2ad" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a &lt;code&gt;BEGIN&lt;/code&gt; subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</source>
          <target state="translated">서브 루틴에 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 와 같은 몇 가지 특수 이름 중 하나가 있으면 단계 관련 서브 루틴의 자동 실행을 위해 적절한 큐에서 요청합니다. 이 경우 관련 glob은 이전에 서브 루틴을 포함 했더라도 서브 루틴을 포함하지 않는 상태로 남습니다. &lt;code&gt;BEGIN&lt;/code&gt; 의 경우 서브 루틴이 실행 되고이 함수가 반환되기 전과 프로토 타입이 설정되기 전에 서브 루틴에 대한 참조가 삭제됩니다. A는 경우 &lt;code&gt;BEGIN&lt;/code&gt; 실행을위한 준비를 서브 루틴이 충분히이 기능에 의해 구성되지 않을 것이다 다음 호출자는 서브 루틴에 다른 이름을 지정하여이 일어나는 것을 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb58246d15f13a6f8775c588f89be7261648c55a" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns.</source>
          <target state="translated">서브 루틴에 &lt;code&gt;BEGIN&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 와 같은 몇 가지 특수 이름 중 하나가 있으면 단계 관련 서브 루틴의 자동 실행을 위해 적절한 큐에서 요청합니다. 이 경우 관련 glob은 이전에 서브 루틴을 포함 했더라도 서브 루틴을 포함하지 않는 상태로 남습니다. &lt;code&gt;BEGIN&lt;/code&gt; 의 경우 서브 루틴이 실행 되고이 함수가 반환되기 전에 서브 루틴에 대한 참조가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c4922eb5c062cef768c57176fb78d4965487a5" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. $a and $b are not set.</source>
          <target state="translated">서브 루틴이 XSUB 인 경우 비교할 요소가 스택으로 푸시되고 인수가 일반적으로 XSUB에 전달되는 방식으로 푸시됩니다. $ a 및 $ b가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1afca0c8662d7dc27c024fcc727c62d11480ea99" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are not set.</source>
          <target state="translated">서브 루틴이 XSUB이면 비교할 요소가 스택에 푸시됩니다. 인수가 일반적으로 XSUB에 전달되는 방식입니다. &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="976151f66fa723fd3131374feb62ee8e2fa9f3b7" translate="yes" xml:space="preserve">
          <source>If the subroutine needs to signal an error, it should call die() with the desired error message as its argument. GetOptions() will catch the die(), issue the error message, and record that an error result must be returned upon completion.</source>
          <target state="translated">서브 루틴이 오류를 신호해야하는 경우 원하는 오류 메시지를 인수로 사용하여 die ()를 호출해야합니다. GetOptions ()는 die ()를 포착하고 오류 메시지를 발행하며 완료시 오류 결과를 리턴해야한다는 것을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="40540ec0b48601a220c70ec78c454bb0e1f51c33" translate="yes" xml:space="preserve">
          <source>If the subroutine returns a scalar with a newline or a filehandle, it will be interpreted as raw TAP or as a TAP stream, respectively.</source>
          <target state="translated">서브 루틴이 개행 또는 파일 핸들이있는 스칼라를 리턴하면 각각 원시 TAP 또는 TAP 스트림으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ca613cca9ddf94b18fd3a6da5979f02e2a0a3fcf" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt; , the elements to be compared are passed by reference in &lt;code&gt;@_&lt;/code&gt; , as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables $a and $b (see example below). Note that in the latter case, it is usually highly counter-productive to declare $a and $b as lexicals.</source>
          <target state="translated">서브 루틴의 프로토 타입이 &lt;code&gt;($$)&lt;/code&gt; 인 경우, 비교할 요소 는 일반 서브 루틴과 마찬가지로 &lt;code&gt;@_&lt;/code&gt; 에 참조로 전달됩니다 . 이것은 프로토 타입이없는 서브 루틴보다 느립니다. 여기서 비교할 요소는 패키지 전역 변수 $ a 및 $ b (아래 예 참조)로 서브 루틴에 전달됩니다. 후자의 경우, 일반적으로 $ a와 $ b를 어휘로 선언하는 것은 비생산적입니다.</target>
        </trans-unit>
        <trans-unit id="84b98f5d60037882d103faaf29e539e20c444828" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt;, the elements to be compared are passed by reference in &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; (see example below).</source>
          <target state="translated">서브 루틴의 프로토 타입이 &lt;code&gt;($$)&lt;/code&gt; 이면 비교할 요소 는 일반 서브 루틴과 마찬가지로 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 에서 참조로 전달됩니다 . 이것은 비교 될 요소가 패키지 전역 변수 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 로 서브 루틴에 전달되는 프로토 타입 화되지 않은 서브 루틴보다 느립니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="1b8a697c5090fd8ce94c13b5cefb41955f99b010" translate="yes" xml:space="preserve">
          <source>If the sv already is UTF-8 (or if it is not POK), or if the encoding is not a reference, nothing is done to the sv. If the encoding is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">sv가 이미 UTF-8이거나 (또는 ​​POK가 아닌 경우) 인코딩이 참조가 아닌 경우 sv에 대해서는 수행되지 않습니다. 인코딩이 &lt;code&gt;Encode::XS&lt;/code&gt; 인코딩 개체 가 아닌 경우 나쁜 일이 발생합니다. (보다</target>
        </trans-unit>
        <trans-unit id="25e6d11786b2dfdb0f52678b6850a3dff8731c46" translate="yes" xml:space="preserve">
          <source>If the sv is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return NULL.</source>
          <target state="translated">sv가 약한 참조의 대상이면 sv와 연관된 역 참조 구조를 반환합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82b0821b14cc4cbb805ab8ac00aa5900da22e409" translate="yes" xml:space="preserve">
          <source>If the symbol &lt;code&gt;:void&lt;/code&gt; appears in the import list, then functions named later in that import list raise an exception only when these are called in void context--that is, when their return values are ignored. For example</source>
          <target state="translated">가져 오기 목록에 &lt;code&gt;:void&lt;/code&gt; 기호 가 표시되면 해당 가져 오기 목록에서 나중에 명명 된 함수가 void 컨텍스트에서 호출 된 경우, 즉 반환 값이 무시되는 경우에만 예외가 발생합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="50cf7df5061941de64a11ddf12781ae7a8f3290f" translate="yes" xml:space="preserve">
          <source>If the system Perl is compiled in has thread-safe variants of such calls, they will be used. Beyond that, Perl is at the mercy of the thread-safety or -unsafety of the calls. Please consult your C library call documentation.</source>
          <target state="translated">시스템 Perl이 그러한 호출의 스레드 안전 변형을 가지고 있으면 컴파일됩니다. 그 외에도 Perl은 스레드 안전성 또는 호출의 안전하지 않은 자비에 있습니다. C 라이브러리 호출 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5b1234bec481f7f0fb540471e8867994b10762a" translate="yes" xml:space="preserve">
          <source>If the target machine is little-endian, we could write:</source>
          <target state="translated">대상 머신이 리틀 엔디안이라면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4756e731e627a9969d09a902907c109ca92f4013" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (&lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">템플릿을 지정하지 않으면 템플릿이 항상 자동으로 생성됩니다. 이 임시 파일은 디렉토리가 DIR 옵션으로 명시 적으로 지정되지 않는 한 tmpdir () ( &lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt; )에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff635540edd5aea28a885e06a80c5c6844ba7c11" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (L&amp;lt;:spec&amp;gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">템플릿을 지정하지 않으면 템플릿이 항상 자동으로 생성됩니다. 이 임시 파일은 디렉토리가 DIR 옵션으로 명시 적으로 지정되지 않는 한 tmpdir () (L &amp;lt;: spec&amp;gt;)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="593ec0746d963b28de5ba2cf0799b3f4777c63c7" translate="yes" xml:space="preserve">
          <source>If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.</source>
          <target state="translated">임시 파일을 만들 수 없으면 undef가 반환됩니다. 현재이 명령은 임시 디렉토리가 NFS 파일 시스템에있을 때 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326e7cf804954bda3811121b38cb7c631e7575fe" translate="yes" xml:space="preserve">
          <source>If the terminating string is quoted, the type of quotes used determine the treatment of the text.</source>
          <target state="translated">종료 문자열이 인용되면 사용 된 인용 유형에 따라 텍스트 처리가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="957eb5ae659823f7ba1c0183ec0ac873de8b4109" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt; .</source>
          <target state="translated">테스트가 계획되지 않은 경우이 메소드는 항상 false를 리턴합니다. &lt;code&gt;is_unplanned&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20d3ba6a3f24850f51b5f59f10528892b52a140e" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt;.</source>
          <target state="translated">테스트가 계획되지 않은 경우이 메서드는 항상 false를 반환합니다. &lt;code&gt;is_unplanned&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfabe273698ccd033cf292d0d277e005ca02c57" translate="yes" xml:space="preserve">
          <source>If the tests fail &lt;code&gt;prove&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">테스트에 실패하면 &lt;code&gt;prove&lt;/code&gt; 은 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="269c79628ff3b9a7faad565d0d36f6d320d9b282" translate="yes" xml:space="preserve">
          <source>If the text of the L&amp;lt;&amp;gt; escape is entirely enclosed in double quotes, it's interpreted as a link to a section for backward compatibility.</source>
          <target state="translated">L &amp;lt;&amp;gt; 이스케이프 텍스트가 큰 따옴표로 묶인 경우 이전 버전과의 호환성을위한 섹션에 대한 링크로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="f92e03b607dab58b8f2f2e3c224ccb0a3fc3ca6c" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">오류 메시지의 텍스트가 느낌표로 시작하면 &lt;code&gt;!&lt;/code&gt; GetOptions ()에 의해 특별히 해석됩니다. 현재 하나의 특수 명령이 구현되어 있습니다. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; 는 GetOptions ()가 이중 대시 &lt;code&gt;--&lt;/code&gt; 와 같이 옵션 처리를 중지하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="3d332109bf38a18b83347b1abe4af5018dfcf4a0" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">오류 메시지의 텍스트가 느낌표로 시작하는 경우 &lt;code&gt;!&lt;/code&gt; 특별히 GetOptions ()에 의해 해석됩니다. 현재 하나의 특수 명령이 구현되어 있습니다. &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; 는 GetOptions ()가 마치 이중 대시 &lt;code&gt;--&lt;/code&gt; 발견 한 것처럼 옵션 처리를 중지하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="54a21a0dcb36b1ce3d43912ccebce5a460b97864" translate="yes" xml:space="preserve">
          <source>If the third argument is</source>
          <target state="translated">세 번째 인수가</target>
        </trans-unit>
        <trans-unit id="b232866b6ad063c73d4ad37ea476edb565d6de63" translate="yes" xml:space="preserve">
          <source>If the third argument,</source>
          <target state="translated">세 번째 주장이</target>
        </trans-unit>
        <trans-unit id="66bf0740d3ced4e3ce4166e93bb8bdf81549240a" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;ed &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or use the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread method instead of &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드가 존재하는 경우 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 에드 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (D)를, 그것과 사망 오류 이때 리턴한다. 당신이이 수행하는 스레드하지 않으려면 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 뿐만 아니라 죽을를, 당신이 중 하나는 포장해야 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 사용 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 스레드 방식을 대신 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a5af2f1be44751c2177059f4e6af4dd499466cc" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;join&lt;/code&gt;ed &lt;code&gt;die&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;join&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;join&lt;/code&gt; in an &lt;code&gt;eval&lt;/code&gt; or use the &lt;code&gt;eval&lt;/code&gt; thread method instead of &lt;code&gt;join&lt;/code&gt;.</source>
          <target state="translated">스레드가 존재하는 경우 &lt;code&gt;join&lt;/code&gt; 에드 &lt;code&gt;die&lt;/code&gt; (D)를, 그것과 사망 오류 이때 리턴한다. 당신이이 수행하는 스레드하지 않으려면 &lt;code&gt;join&lt;/code&gt; 뿐만 아니라 죽을를, 당신이 중 하나는 포장해야 &lt;code&gt;join&lt;/code&gt; 에 &lt;code&gt;eval&lt;/code&gt; 또는 사용 &lt;code&gt;eval&lt;/code&gt; 스레드 방식을 대신 &lt;code&gt;join&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2279b2f8b74fd7d772a6ba18eb3177b3a248c49d" translate="yes" xml:space="preserve">
          <source>If the timeout is reached, this method will return</source>
          <target state="translated">시간 초과에 도달하면이 메서드는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cd970acc5e28ee89d2e82334dde273c65bae5b7" translate="yes" xml:space="preserve">
          <source>If the title can't be found, then get_short_title returns empty-string (&quot;&quot;).</source>
          <target state="translated">제목을 찾을 수 없으면 get_short_title은 빈 문자열 ( &quot;&quot;)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="697a489e14d5b870ec5510bd4b458c67ab45bad8" translate="yes" xml:space="preserve">
          <source>If the typeglob &lt;code&gt;gv&lt;/code&gt; can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that &lt;code&gt;gv&lt;/code&gt; is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</source>
          <target state="translated">타입 글로브 &lt;code&gt;gv&lt;/code&gt; 를 더 간결하게 표현할 수있는 경우, 숨김에 실제 GV 이외의 것을 배치하여 최적화 된 형태로 바꾸십시오. 이것에 대한 기본 요구 사항은 &lt;code&gt;gv&lt;/code&gt; 가 실제 타입 글롭이고 충분히 평범하며 패키지에서만 참조 해야한다는 것 입니다. 이 기능은 GV가 부분적으로 조회되어 업그레이드 된 원인이 무엇인지 확인하는 데 사용되지만 실제 GV가 필요하지 않은 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="7e317e256420ab2a48b2f7e7b312c3d9f416e521" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">기본 &lt;code&gt;IO::Handle&lt;/code&gt; 이 닫히거나 읽기 또는 쓰기 실패가 발생하면 파일 핸들이 강제로 닫히고 &lt;code&gt;code()&lt;/code&gt; 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 반환 하고 message () 는 &quot;[ $ pkg] Connection closed &quot;(여기서 $ pkg는 &lt;code&gt;Net::Cmd&lt;/code&gt; 를 서브 클래 싱 한 클래스의 이름입니다 ). _set_status_closed () 메소드를 재정 의하여 다른 메시지를 설정하거나 (set_status () 호출)이 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e77ce40e4dd7efc2c043a17aee5d821a48fe672" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">기본 &lt;code&gt;IO::Handle&lt;/code&gt; 이 닫히거나 읽기 또는 쓰기 실패가있는 경우 파일 핸들이 강제로 닫히고 &lt;code&gt;code()&lt;/code&gt; 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 반환 하고 message () 는 &quot;[를 반환합니다. $ pkg] Connection closed &quot;(여기서 $ pkg는 &lt;code&gt;Net::Cmd&lt;/code&gt; 를 서브 클래 싱 한 클래스의 이름입니다 ). _set_status_closed () 메서드를 재정 의하여 다른 메시지를 설정하거나 (set_status ()를 호출하여) 그렇지 않으면이 오류를 트랩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc3b2cf894256f273b0349af8d5d688d0cdcb39" translate="yes" xml:space="preserve">
          <source>If the user builds a shared</source>
          <target state="translated">사용자가 공유를 구축하는 경우</target>
        </trans-unit>
        <trans-unit id="32324af5745fb70c85007da7a27faa556a189cfd" translate="yes" xml:space="preserve">
          <source>If the user didn't specify anything, it's interpreted as having used the &lt;code&gt;please&lt;/code&gt; tag. It's up to you to make this useful.</source>
          <target state="translated">사용자가 아무것도 지정하지 않은 경우 &lt;code&gt;please&lt;/code&gt; 태그 를 사용한 것으로 해석됩니다 . 이것을 유용하게 만드는 것은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd074d1ec9315994a5770ffd227be188d8ea3674" translate="yes" xml:space="preserve">
          <source>If the user does not have HTML::Lint installed, the whole block of code</source>
          <target state="translated">사용자에게 HTML :: Lint가 설치되어 있지 않은 경우 전체 코드 블록</target>
        </trans-unit>
        <trans-unit id="b39c8811f479889c6eabed43038bf7a333557852" translate="yes" xml:space="preserve">
          <source>If the user has superuser privileges, and is not working on AFS or relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT, etc. will be appropriate, and this incantation will be the best:</source>
          <target state="translated">사용자에게 수퍼 유저 권한이 있고 AFS 또는 친척에 대해 작업하지 않는 경우 INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT 등의 기본값이 적절하며이 제안이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d9745c4616cab220c27715466f7a222d8b72268" translate="yes" xml:space="preserve">
          <source>If the value</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="1676523b419ae746e43ad6553d2687aea42c504e" translate="yes" xml:space="preserve">
          <source>If the value doesn't match the 'make' program you want to use, edit Config.pm to fix it.</source>
          <target state="translated">값이 사용하려는 'make'프로그램과 일치하지 않으면 Config.pm을 편집하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="9aa86f4743abc7079a416abc9073771271ff4394" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">값이 &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; 인 경우 UV로 반환되고 출력 플래그가 지워 지며 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69db17f26df78ff9935057c8c72522c8171dedc4" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_bin&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">값이 &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; 이면 UV로 반환되고 출력 플래그가 지워지고 &lt;code&gt;*result&lt;/code&gt; 에 아무것도 기록되지 않습니다 . 값&amp;gt;이면 &lt;code&gt;UV_MAX&lt;/code&gt; , &lt;code&gt;grok_bin&lt;/code&gt; 복귀 &lt;code&gt;UV_MAX&lt;/code&gt; , 세트 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 출력 플래그에, 그리고 내로 정확한 값의 근사치 기록 &lt;code&gt;*result&lt;/code&gt; (AN NV이다 경우 또는 근사가 삭제되고 &lt;code&gt;result&lt;/code&gt; NULL이다).</target>
        </trans-unit>
        <trans-unit id="b33edf1191e45f2f7c173468860c56b9c68eec7c" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">값이 &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; 이면 UV로 반환되고 출력 플래그가 지워지고 &lt;code&gt;*result&lt;/code&gt; 에 아무것도 기록되지 않습니다 . 값이면&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; 는 반환 &lt;code&gt;UV_MAX&lt;/code&gt; , 세트 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에 내로 정확한 값의 근사치 기록 &lt;code&gt;*result&lt;/code&gt; (또는 경우 근사치는 폐기되는 NV 인 &lt;code&gt;result&lt;/code&gt; NULL이다).</target>
        </trans-unit>
        <trans-unit id="11949fed265c94f0f9f0cc1d3c0a3164a55a86d5" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_oct&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">값이 &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; 이면 UV로 반환되고 출력 플래그가 지워지고 &lt;code&gt;*result&lt;/code&gt; 에 아무것도 기록되지 않습니다 . 값이면&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; , &lt;code&gt;grok_oct&lt;/code&gt; 의 복귀 &lt;code&gt;UV_MAX&lt;/code&gt; , 세트 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 출력 플래그, 그리고는에 올바른 값의 근사치 기록 &lt;code&gt;*result&lt;/code&gt; (또는 경우 근사치는 폐기되는 NV 인 &lt;code&gt;result&lt;/code&gt; NULL이다).</target>
        </trans-unit>
        <trans-unit id="bd15952acdcd265d4f18a816b3be548c37a82d83" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= UV_MAX it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">값이 &amp;lt;= UV_MAX 인 경우 UV로 반환되고 출력 플래그가 지워지며 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c10d8690679793d91d603d7249997075229bffed" translate="yes" xml:space="preserve">
          <source>If the value is a coderef, we return &amp;amp;$value($lh, ...parameters...).</source>
          <target state="translated">값이 코드 참조 인 경우 &amp;amp; $ value ($ lh, ... parameters ...)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef50a320b2209faad43a3f8213d92ea4b618e424" translate="yes" xml:space="preserve">
          <source>If the value is a scalarref, the scalar is dereferenced and returned (and any parameters are ignored).</source>
          <target state="translated">값이 스칼라 참조 인 경우 스칼라는 역 참조되어 리턴됩니다 (그리고 모든 매개 변수는 무시됩니다).</target>
        </trans-unit>
        <trans-unit id="6f950a468109b8d39520112d3f58effdc56407fc" translate="yes" xml:space="preserve">
          <source>If the value is a string that</source>
          <target state="translated">값이 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="034aa5dfb1d3fc388ace8815e3c3af316b7fe0f0" translate="yes" xml:space="preserve">
          <source>If the value is true, then the appropriate pragma is assumed to be in the ambient scope, otherwise not.</source>
          <target state="translated">값이 true이면 해당 pragma가 주변 범위에있는 것으로 가정하고 그렇지 않으면 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="3679a65190bd3883b712c84ff2c3ed51da02c8c9" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in &lt;code&gt;*valuep&lt;/code&gt;. &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set to indicate that &lt;code&gt;*valuep&lt;/code&gt; is valid, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will never be set unless &lt;code&gt;*valuep&lt;/code&gt; is valid, but &lt;code&gt;*valuep&lt;/code&gt; may have been assigned to during processing even though &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; is not set on return. If &lt;code&gt;valuep&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set for the same cases as when &lt;code&gt;valuep&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">숫자 값이 UV에 맞을 수 있으면 &lt;code&gt;*valuep&lt;/code&gt; 로 반환됩니다 . &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 는 것을 나타 내기 위해 설정됩니다 &lt;code&gt;*valuep&lt;/code&gt; 는 , 유효 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 가 되지 않는 설정되지 않습니다 &lt;code&gt;*valuep&lt;/code&gt; 이 유효하지만 &lt;code&gt;*valuep&lt;/code&gt; 은 비록 처리시에 할당 된 수 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 이 반환에 설정되어 있지 않습니다. 경우 &lt;code&gt;valuep&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; 은 때와 같은 경우에 설정됩니다 &lt;code&gt;valuep&lt;/code&gt; 이 비입니다 &lt;code&gt;NULL&lt;/code&gt; 하지만, 실제 할당 (또는 SEGV)가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3799e4ea2da2d340ca2beed8a5872250c216eb41" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but *valuep may have been assigned to during processing even though IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when valuep is non-NULL, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">숫자 값이 UV에 맞으면 * valuep에 반환됩니다. IS_NUMBER_IN_UV는 * valuep가 유효 함을 나타내도록 설정되며 * valuep가 유효하지 않으면 IS_NUMBER_IN_UV가 설정되지 않지만 * valuep가 IS_NUMBER_IN_UV가 반환시 설정되지 않은 경우에도 처리 중 valuep가 NULL 인 경우 valuep가 NULL이 아닌 경우와 동일한 경우 IS_NUMBER_IN_UV가 설정되지만 실제 할당 (또는 SEGV)은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d417792987cefdc8fbbad820c7047930346b40c5" translate="yes" xml:space="preserve">
          <source>If the value to pack is too long, the result is truncated. If it's too long and an explicit count is provided, &lt;code&gt;Z&lt;/code&gt; packs only &lt;code&gt;$count-1&lt;/code&gt; bytes, followed by a null byte. Thus &lt;code&gt;Z&lt;/code&gt; always packs a trailing null, except when the count is 0.</source>
          <target state="translated">압축 할 값이 너무 길면 결과가 잘립니다. 너무 길고 명시적인 카운트가 제공되면 &lt;code&gt;Z&lt;/code&gt; 는 &lt;code&gt;$count-1&lt;/code&gt; 바이트 만 압축 한 다음 null 바이트를 씁니다. 따라서 &lt;code&gt;Z&lt;/code&gt; 는 개수가 0 인 경우를 제외하고 항상 후행 null을 압축합니다.</target>
        </trans-unit>
        <trans-unit id="2b18faee7915986e7efaa1de04f931c2b8c71f1c" translate="yes" xml:space="preserve">
          <source>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</source>
          <target state="translated">값이 모두 작은 정수이면 간단한 인덱스 배열을 사용할 수 있습니다. 이런 종류의 배열은 공간을 덜 차지합니다.</target>
        </trans-unit>
        <trans-unit id="5cc9e16e91b4a8896cd9faaa5f9549cbc7085c8f" translate="yes" xml:space="preserve">
          <source>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</source>
          <target state="translated">문제의 값이 문자열이 아닌 정수이면 비트 문자열을 대신 사용하여 많은 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82319500e10e873dfa0526d703945d89b55231f8" translate="yes" xml:space="preserve">
          <source>If the values of &lt;code&gt;$mod&lt;/code&gt; and &lt;code&gt;$prereq&lt;/code&gt; have not been scrubbed, however, this presents security implications.</source>
          <target state="translated">그러나 &lt;code&gt;$mod&lt;/code&gt; 및 &lt;code&gt;$prereq&lt;/code&gt; 의 값 이 제거되지 않은 경우 보안에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="73e7da39372f108fea1077e432f6f8a5490ef1c9" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">변수가 다른 스레드에 의해 잠겨 있으면 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 호출은 사용 가능할 때까지 차단됩니다. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 여러 번 호출하므로 재귀 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 안전 - 변수의 바깥 쪽 잠금 범위를 벗어날 때까지 변수이 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="d43da14411193cb05153c9413f27d1e7c410d9b1" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. &lt;code&gt;lock&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;lock&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">변수가 다른 스레드에 의해 잠긴 경우 &lt;code&gt;lock&lt;/code&gt; 호출은 사용할 수있을 때까지 차단됩니다. &lt;code&gt;lock&lt;/code&gt; 여러 번 호출하므로 재귀 &lt;code&gt;lock&lt;/code&gt; 안전 - 변수의 바깥 쪽 잠금 범위를 벗어날 때까지 변수이 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="82a274850c71686d34e3baa803737f0dedda24d3" translate="yes" xml:space="preserve">
          <source>If the variable is not set, or if the head of space-separated list is empty, the best available package is loaded.</source>
          <target state="translated">변수가 설정되어 있지 않거나 공백으로 구분 된 목록의 헤드가 비어 있으면 사용 가능한 최상의 패키지가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="332df1267de6f0a87c793832b4c5597a101a667d" translate="yes" xml:space="preserve">
          <source>If the warning comes from other than I/O, this diagnostic probably indicates that incorrect results are being obtained. You should examine your code to determine how a wide character is getting to an operation that doesn't handle them.</source>
          <target state="translated">경고가 I / O가 아닌 다른 곳에서 발생하는 경우이 진단은 잘못된 결과를 얻고 있음을 나타낼 수 있습니다. 코드를 검사하여 와이드 문자가 처리하지 않는 작업에 어떻게 적용되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="80b83d018cb7a8db8be65fb54c56d8b5b7e8cb24" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt; , has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">호출 모듈에서 경고 범주 &lt;code&gt;$category&lt;/code&gt; 가 &quot;FATAL&quot;로 설정되어 있으면 죽습니다. 그렇지 않으면 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="834ab1c45a3f45ffae4b5d0f33ce4babb0604bab" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt;, has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">경고 범주 &lt;code&gt;$category&lt;/code&gt; 가 호출 모듈에서 &quot;FATAL&quot;로 설정되어 있으면 죽습니다. 그렇지 않으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5e41570d4b0ba06d69d1ed0ddaa70c09dffea4d" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all literal strings within it must be Unicode.</source>
          <target state="translated">전체 프로그램이 유니 코드 인 경우 (8 비트 사용하여 의미했다 &lt;b&gt;U&lt;/b&gt; nicode &lt;b&gt;T&lt;/b&gt; ransformation &lt;b&gt;F의&lt;/b&gt; ORMAT을), 다음 내의 모든 리터럴 문자열은 유니 코드해야합니다.</target>
        </trans-unit>
        <trans-unit id="9de09cf9a89a26f0cb448619847689ec2527d3db" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all strings within it must be Unicode.</source>
          <target state="translated">전체 프로그램이 유니 코드 인 경우 (8 비트 사용하여 의미했다 &lt;b&gt;U&lt;/b&gt; nicode &lt;b&gt;T&lt;/b&gt; ransformation &lt;b&gt;F의&lt;/b&gt; ORMAT을), 다음 내의 모든 문자열은 유니 코드해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf7f58b72ea89ccbb496e2eb6b9b4bc7fadaa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt; , the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">단어의 경우 &lt;code&gt;while&lt;/code&gt; 단어로 대체 &lt;code&gt;until&lt;/code&gt; 테스트의 의미는 반대하지만, 조건은 여전히 첫 번째 반복 전에 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="bb24c8d0dff7253263fabb1012737a1c5185daa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt;, the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">단어의 경우 &lt;code&gt;while&lt;/code&gt; 단어로 대체 &lt;code&gt;until&lt;/code&gt; 테스트의 의미는 반대하지만, 조건은 여전히 첫 번째 반복 전에 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="10166029e96e7fe67231308fbe3c16515584c847" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;../locale/country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;../locale/language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt; .)</source>
          <target state="translated">특정 로케일에만 적용되는 추가 케이싱 규칙이있는 경우 각각의 추가 키가 반환 된 해시에 정의됩니다. 이러한 각 키는 2 문자 ISO 3166 국가 코드로 정의 된 로케일 이름이며 &quot;_&quot;및 2 문자 ISO 언어 코드 ( &quot;_&quot;및 변형 코드가 뒤에옵니다)가 뒤에있을 수 있습니다. 가능한 모든 로캘 목록을 찾을 수 있습니다 ( &lt;a href=&quot;../locale/country&quot;&gt;Locale :: Country&lt;/a&gt; 및 &lt;a href=&quot;../locale/language&quot;&gt;Locale :: Language 참조)&lt;/a&gt; . (유니 코드 6.0에서이 함수가 리턴하는 유일한 로케일은 &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;az&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="c9b92a1c0c95f09069f2ada78514b6761e600855" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;Locale::Country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;Locale::Language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt;.)</source>
          <target state="translated">특정 로케일에만 적용되는 추가 대 / 소문자 규칙이있는 경우 각각에 대한 추가 키가 반환 된 해시에 정의됩니다. 이러한 각 키는 2 글자 ISO 3166 국가 코드로 정의 된 로케일 이름이며, &quot;_&quot;및 2 글자 ISO 언어 코드 ( &quot;_&quot;및 변형 코드가 이어질 수 있음)가 뒤따를 수 있습니다. 가능한 모든 로케일 목록을 찾을 수 있습니다. &lt;a href=&quot;Locale::Country&quot;&gt;Locale :: Country&lt;/a&gt; 및 &lt;a href=&quot;Locale::Language&quot;&gt;Locale :: Language를&lt;/a&gt; 참조하십시오 . (유니 코드 6.0에서이 함수가 반환하는 유일한 로케일은 &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;tr&lt;/code&gt; 및 &lt;code&gt;az&lt;/code&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="10187abc55d0802b4b3951872dffe3ad9dfa823c" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;$count&lt;/code&gt; items in the list then the function will return once all of them have been randomly selected; effectively the function behaves similarly to &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt;.</source>
          <target state="translated">목록에 &lt;code&gt;$count&lt;/code&gt; 미만의 항목이있는 경우 모든 항목이 무작위로 선택되면 함수가 반환됩니다. 효과적으로이 함수는 &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt; 과 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c91a8fd751937bd233ccdf982bb8140e1a1456b2" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">팩 코드가 더 많거나 필드 또는 그룹의 반복 횟수가 입력 문자열의 나머지가 허용하는 것보다 크면 결과가 제대로 정의되지 않습니다. 반복 횟수가 감소하거나 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 빈 문자열이 생성 될 수 있습니다. 0 또는 예외가 발생할 수 있습니다. 입력 문자열이 TEMPLATE에 설명 된 것보다 길면 해당 입력 문자열의 나머지는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c264a98231858c182cc8e558543c798b7c30e957" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">더 많은 팩 코드가 있거나 필드 또는 그룹의 반복 횟수가 입력 문자열의 나머지가 허용하는 것보다 큰 경우 결과가 제대로 정의되지 않습니다. 반복 횟수가 줄어들거나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 이 비어있을 수 있습니다 문자열 또는 0이거나 예외가 발생할 수 있습니다. 입력 문자열이 TEMPLATE에서 설명 된 것보다 긴 경우 해당 입력 문자열의 나머지는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b76f7ceb246d4c2d7fabcbfce30f4b0cda04fc65" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">더 많은 팩 코드가 있거나 필드 또는 그룹의 반복 횟수가 입력 문자열의 나머지가 허용하는 것보다 큰 경우 결과가 제대로 정의되지 않습니다. 반복 횟수가 줄어들거나 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 이 비어있을 수 있습니다 문자열 또는 0이거나 예외가 발생할 수 있습니다. 입력 문자열이 TEMPLATE에서 설명 된 것보다 긴 경우 해당 입력 문자열의 나머지는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="68b83d3193021444c248ae823551b36481a4afcb" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">실행중인 여러 스레드 가있는 경우 파일 핸들이 다른 스레드에서 여전히 열려있는 경우 파이프 된 열기에서 파일 핸들을 &lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 자식 프로세스가 종료 될 때까지 기다리지 않고 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf8ae3d8fd9e42e9aba417d2727a1cef25f1654d" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">여러 스레드가 실행중인 경우 파일 핸들이 다른 스레드에서 여전히 열려 있으면 파이프 프로세스 열기에서 파일 핸들을 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 하위 프로세스가 종료 될 때까지 기다리지 않고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2d703ea78c6bd312ccc4d4536374984caf742a2c" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">여러 스레드가 실행중인 경우 파일 핸들이 다른 스레드에서 여전히 열려 있으면 파이프 프로세스 열기에서 파일 핸들을 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 하위 프로세스가 종료 될 때까지 기다리지 않고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b367c7608072c7b2e27d64beb7fdc3ebcfc5757e" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;에&lt;/a&gt; 대한 대소 문자 매핑이 없거나 세 가지 가능한 매핑 (</target>
        </trans-unit>
        <trans-unit id="c3ca3b8e4b7d3fd6327a3431ba332cb4654544b7" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수에&lt;/a&gt; 대한 대소 문자 맵핑이 없거나 가능한 세 가지 맵핑 (</target>
        </trans-unit>
        <trans-unit id="4d288bab40c0346d55a3c0eb77940eab7a6641ad" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 인수에 쉘 메타 문자가 없으면 Perl은 쉘을 사용하지 않고 명령을 직접 실행하며 명령이 시작되었는지 여부를 올바르게보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b923cdb7f2db79984c43279c6e1908fa7560e3" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;open()&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 인수에 쉘 메타 문자가 없으면 Perl은 쉘을 사용하지 않고 명령을 직접 실행하며 명령이 시작되었는지 여부를 올바르게보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b3c9dc933e2482f8eba281e591135e3899389e" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded.</source>
          <target state="translated">변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 차단 된 스레드가 없으면 신호가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dcf5c5ee7e0424ea7ada5c7826f4b90fdb2a116c" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded. By always locking before signaling, you can (with care), avoid signaling before another thread has entered cond_wait().</source>
          <target state="translated">변수 의 &lt;code&gt;cond_wait&lt;/code&gt; 에서 차단 된 스레드가 없으면 신호가 삭제됩니다. 신호를 보내기 전에 항상 잠금을 설정하면 다른 스레드가 cond_wait ()에 들어가기 전에 신호를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5de19948908467a5a983001d47b7d9a0689b746" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt; ). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt; ) will not cause a warning (currently).</source>
          <target state="translated">중괄호 사이에 유효한 숫자가 없으면 생성 된 문자는 NULL 문자 ( &lt;code&gt;\x{00}&lt;/code&gt; )입니다. 그러나 명시적인 빈 괄호 ( &lt;code&gt;\x{}&lt;/code&gt; )는 경고를 발생시키지 않습니다 (현재).</target>
        </trans-unit>
        <trans-unit id="954b2d334088acf7ff9ea75b92d63622f7bf51c0" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt;). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt;) will not cause a warning (currently).</source>
          <target state="translated">중괄호 사이에 유효한 숫자가 없으면 생성 된 문자는 NULL 문자 ( &lt;code&gt;\x{00}&lt;/code&gt; )입니다. 그러나 명시적인 빈 중괄호 ( &lt;code&gt;\x{}&lt;/code&gt; )는 경고를 발생시키지 않습니다 (현재).</target>
        </trans-unit>
        <trans-unit id="b342c6d59112da790e47e12118a22cde8dbcaf22" translate="yes" xml:space="preserve">
          <source>If there are only a few field hashes to declare, it is simplest to</source>
          <target state="translated">선언 할 필드 해시가 거의없는 경우 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="ae8e9a2c571cd018342d9c2118caec048fd77da4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">세 개의 인수 만 있고 세 번째 인수가 해시 참조 인 경우 해당 해시의 키는 &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; 및 &lt;code&gt;comp&lt;/code&gt; 또는 &lt;code&gt;xfrm&lt;/code&gt; 값을 가질 수 있으며 (아래 참조) 해당 값이 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e81956a0441efe3f26746423f2c17c9cee5f29f4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">세 개의 인수 만 있고 세 번째 인수가 해시 참조 인 경우 해당 해시의 키는 &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , &lt;code&gt;comp&lt;/code&gt; 또는 &lt;code&gt;xfrm&lt;/code&gt; 값을 가질 수 있으며 (아래 참조) 해당 값이 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e86b013905dd12651149e8ec83c3ae6cf6c6b73" translate="yes" xml:space="preserve">
          <source>If there are two modules using &lt;code&gt;FindBin&lt;/code&gt; from different directories under the same interpreter, this won't work. Since &lt;code&gt;FindBin&lt;/code&gt; uses a &lt;code&gt;BEGIN&lt;/code&gt; block, it'll be executed only once, and only the first caller will get it right. This is a problem under mod_perl and other persistent Perl environments, where you shouldn't use this module. Which also means that you should avoid using &lt;code&gt;FindBin&lt;/code&gt; in modules that you plan to put on CPAN. To make sure that &lt;code&gt;FindBin&lt;/code&gt; will work is to call the &lt;code&gt;again&lt;/code&gt; function:</source>
          <target state="translated">동일한 인터프리터 아래의 다른 디렉토리에서 &lt;code&gt;FindBin&lt;/code&gt; 을 사용하는 두 개의 모듈이 있으면 작동하지 않습니다. &lt;code&gt;FindBin&lt;/code&gt; 은 &lt;code&gt;BEGIN&lt;/code&gt; 블록을 사용 하므로 한 번만 실행되며 첫 번째 발신자 만 올바르게 처리합니다. 이것은 mod_perl 및 다른 영구 Perl 환경에서이 모듈을 사용해서는 안되는 문제입니다. 또한 &lt;code&gt;FindBin&lt;/code&gt; 에 장착하려는 모듈에서 FindBin 을 사용하지 않아야합니다 . &lt;code&gt;FindBin&lt;/code&gt; 이 작동 하는지 확인하려면 &lt;code&gt;again&lt;/code&gt; 함수 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcc3c3e2760c5e396f33222005be848fc9fe18e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK 이 있으면 조건부 조건을 다시 평가하기 직전에 항상 실행됩니다. 따라서 루프가 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문을 통해 계속 된 경우에도 루프 변수를 증가시키는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47225f2cbf093a41e464bfd235d898451ab3fec3" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;continue&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;next&lt;/code&gt; statement.</source>
          <target state="translated">A가있을 경우 &lt;code&gt;continue&lt;/code&gt; BLOCK을, 항상 조건을 다시 평가하는 것입니다 직전에 실행됩니다. 따라서 루프가 &lt;code&gt;next&lt;/code&gt; 문을 통해 계속되는 경우에도 루프 변수를 증가시키는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b36be5061281671022cf399b379651681b1d4d0" translate="yes" xml:space="preserve">
          <source>If there is a case folding for that code point, a reference to a hash with the following fields is returned:</source>
          <target state="translated">해당 코드 포인트에 대해 접는 사례가있는 경우 다음 필드가있는 해시에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="791dad5bf77a3c7753599734b55d1d951806d6b3" translate="yes" xml:space="preserve">
          <source>If there is a possibility of malformed input, use instead:</source>
          <target state="translated">잘못된 입력 가능성이있는 경우 다음을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6424bf8b1f44f30e366f5038ca9bafadec447990" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">읽기 또는 쓰기 시간 종료 &lt;code&gt;code()&lt;/code&gt; 가있는 경우 () 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 리턴 하고 message () 는 &quot;[$ pkg] 시간 종료&quot;를 리턴합니다 (여기서 $ pkg는 &lt;code&gt;Net::Cmd&lt;/code&gt; 를 서브 클래 싱 한 클래스의 이름입니다) ). _set_status_timeout () 메소드를 재정 의하여 다른 메시지를 설정하거나 (set_status () 호출)이 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5ddbe053c3383dcb2da814550e984622b561fa" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">읽기 또는 쓰기 제한 시간이있는 경우 &lt;code&gt;code()&lt;/code&gt; 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 반환 하고 message () 는 &quot;[$ pkg] Timeout&quot;을 반환합니다 (여기서 $ pkg는 &lt;code&gt;Net::Cmd&lt;/code&gt; 를 서브 클래 싱 한 클래스의 이름입니다. ). _set_status_timeout () 메서드를 재정 의하여 다른 메시지를 설정하거나 (set_status ()를 호출하여) 그렇지 않으면이 오류를 트랩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a08eec9ef05dccf9a00729a1af45acee83fa1a4" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; statement is executed, &lt;code&gt;eval&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context, or an empty list in list context, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the empty string. A control flow operator like &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; can bypass the setting of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Beware that using &lt;code&gt;eval&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. To do either of those, you have to use the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__WARN__}&lt;/code&gt;&lt;/a&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;no warnings 'all'&lt;/code&gt;. See &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">구문 오류 또는 런타임 오류가 있거나 &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt; 문이 실행되면 &lt;code&gt;eval&lt;/code&gt; 은 스칼라 컨텍스트에서 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 반환 하거나 목록 컨텍스트에서 빈 목록을 반환 하고 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 가 오류 메시지로 설정됩니다. (5.16 이전에는 버그로 인해 구문 오류에 대해서는 목록 컨텍스트 에 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 가 반환되지만 런타임 오류에 대해서는 반환되지 않습니다.) 오류가 없으면 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 가 빈 문자열로 설정됩니다. &lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; 와 같은 제어 흐름 연산자 는 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 설정을 무시할 수 있습니다 . &lt;code&gt;eval&lt;/code&gt; 을 사용하면 Perl이 STDERR에 경고를 인쇄하지 못하도록하거나 경고 메시지 텍스트를 &lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt; 넣지 않습니다.. 둘 중 하나를 수행하려면 &lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; &lt;/a&gt; 기능을 사용하거나 &lt;code&gt;no warnings 'all'&lt;/code&gt; 사용 하지 않고 BLOCK 또는 EXPR 내부의 경고를 해제 해야 합니다. &lt;a href=&quot;#warn-LIST&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;warnings를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11aba41a92baa1006f7ccfb764892fd564d365da" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">구문 오류 또는 런타임 오류가 있거나 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 문이 실행되면 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하거나 목록 컨텍스트에서 빈 목록을 반환 하고 &lt;code&gt;$@&lt;/code&gt; 는 오류 메시지로 설정됩니다. (5.16 이전에는 버그로 인해 구문 오류에 대해서는 목록 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환되었지만 런타임 오류는 발생하지 않았습니다.) 오류가 없으면 &lt;code&gt;$@&lt;/code&gt; 가 빈 문자열로 설정됩니다. &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 와 같은 제어 흐름 연산자 는 &lt;code&gt;$@&lt;/code&gt; 설정을 무시할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 Perl이 경고를 STDERR로 인쇄하지 못하게하거나 경고 메시지의 텍스트를 &lt;code&gt;$@&lt;/code&gt; 넣지 않습니다.. 이 중 하나를 수행하려면 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 기능을 사용하거나 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 사용 &lt;a href=&quot;no&quot;&gt;하지 않고&lt;/a&gt; BLOCK 또는 EXPR 내에서 경고를 해제 해야 합니다. &lt;a href=&quot;warn&quot;&gt;경고&lt;/a&gt; , &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;../warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebacccba519ce29c0edb6165a1d7c06041545422" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">구문 오류 또는 런타임 오류가 있거나 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 문이 실행되면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하거나 목록 컨텍스트에서 빈 목록을 반환 하고 &lt;code&gt;$@&lt;/code&gt; 는 오류 메시지로 설정됩니다. (5.16 이전에는 버그로 인해 구문 오류에 대해서는 목록 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환되었지만 런타임 오류는 발생하지 않았습니다.) 오류가 없으면 &lt;code&gt;$@&lt;/code&gt; 가 빈 문자열로 설정됩니다. &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 와 같은 제어 흐름 연산자 는 &lt;code&gt;$@&lt;/code&gt; 설정을 무시할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 Perl이 경고를 STDERR로 인쇄하지 못하게하거나 경고 메시지의 텍스트를 채우지 않습니다. &lt;code&gt;$@&lt;/code&gt; . 이 중 하나를 수행하려면 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 기능을 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않고&lt;/a&gt; BLOCK 또는 EXPR 내에서 경고를 해제 해야 합니다. &lt;a href=&quot;#warn&quot;&gt;경고&lt;/a&gt; , &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0363f8d22dbc9b336b291dea3342e0d06c042240" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</source>
          <target state="translated">지정된 이름의 서브 루틴이 이미있는 경우 새 서브는 glob의 기존 서브 루틴을 대체하거나 기존 서브 루틴과 병합됩니다. 재정의에 대한 경고가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f502d2c87f9e6854805c11486fbe0df87ab65e99" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition.</source>
          <target state="translated">지정된 이름의 서브 루틴이 이미있는 경우 새 서브가 glob의 기존 서브 루틴을 대체합니다. 재정의에 대한 경고가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b62d67db30c0ed8a724a981f3cdb26a57d7bac9" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was &lt;code&gt;CvCONST&lt;/code&gt; then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by &lt;code&gt;const_svp&lt;/code&gt;. (Note that the call to this function doesn't make the new subroutine &lt;code&gt;CvCONST&lt;/code&gt; in any case; that is left to the caller.) If &lt;code&gt;const_svp&lt;/code&gt; is null then it indicates that the new subroutine will not become a constant. If &lt;code&gt;const_svp&lt;/code&gt; is non-null then it indicates that the new subroutine will become a constant, and it points to an &lt;code&gt;SV*&lt;/code&gt; that provides the constant value that the subroutine will have.</source>
          <target state="translated">지정된 이름의 서브 루틴이 이미있는 경우 새 서브가 glob의 기존 서브 루틴을 대체합니다. 재정의에 대한 경고가 생성 될 수 있습니다. 이전 서브 루틴이 &lt;code&gt;CvCONST&lt;/code&gt; 이면 경고 여부에 대한 결정은 새 서브 루틴이 비슷한 값의 상수가 될지 여부에 대한 기대에 영향을받습니다. 그 기대는 &lt;code&gt;const_svp&lt;/code&gt; 에 의해 결정됩니다 . (이 함수에 대한 호출 은 어떤 경우에도 새 서브 루틴 &lt;code&gt;CvCONST&lt;/code&gt; 를 만들지 않습니다 . 이는 호출자에게 맡겨집니다.) &lt;code&gt;const_svp&lt;/code&gt; 가 null이면 새 서브 루틴이 상수가되지 않음을 나타냅니다. 경우 &lt;code&gt;const_svp&lt;/code&gt; 가 null 이외는 그것은 새로운 서브 루틴이 일정하게 나타냅니다, 그리고 그것은 가리키는 &lt;code&gt;SV*&lt;/code&gt; 서브 루틴이 가질 상수 값을 제공하는 SV * .</target>
        </trans-unit>
        <trans-unit id="5466934b0ce09952bbdf7a873d8e98baf5e63870" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">오류가 있으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b85ca592364b34a60190d51f6450258a4cd0c81b" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">오류가 있으면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="467d2ed550f37bc1b9fda912fd43e11ff12b4118" translate="yes" xml:space="preserve">
          <source>If there is any question about whether a given patch might merit inclusion in a maint release, then it almost certainly should not be included.</source>
          <target state="translated">주어진 패치가 maint 릴리스에 포함될 가치가 있는지에 대한 의문이 있다면, 거의 포함시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ca419a7d4011e71c524719322dfff4afd6d50991" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls &lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp(3)&lt;/a&gt; with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt;, which is more efficient. Examples:</source>
          <target state="translated">LIST에 둘 이상의 인수가있는 경우 LIST 의 인수를 사용하여 &lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp (3)&lt;/a&gt; 를 호출합니다 . LIST에 요소가 하나만있는 경우 인수에서 쉘 메타 문자를 확인하고,있는 경우 전체 인수가 구문 분석을 위해 시스템의 명령 쉘로 전달됩니다 ( 유닉스 플랫폼에서는 &lt;code&gt;/bin/sh -c&lt;/code&gt; 이지만 다양합니다. 다른 플랫폼에서). 인수에 쉘 메타 문자가 없으면 단어로 분할되어 &lt;code&gt;execvp&lt;/code&gt; 로 직접 전달되므로 더 효율적입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="0f8376c45472eeb9e97a43b3d977d663509a5686" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls execvp(3) with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. Examples:</source>
          <target state="translated">LIST에 둘 이상의 인수가 있으면 LIST의 인수와 함께 execvp (3)을 호출합니다. LIST에 하나의 요소 만있는 경우, 인수는 쉘 메타 문자를 검사하고, 존재하는 경우 전체 인수는 구문 분석을 위해 시스템의 명령 쉘로 전달됩니다 (이는 Unix 플랫폼에서 &lt;code&gt;/bin/sh -c&lt;/code&gt; 이지만 다양합니다) 다른 플랫폼에서). 인수에 쉘 메타 문자가 없으면 단어로 분리되어 &lt;code&gt;execvp&lt;/code&gt; 로 직접 전달되므로 보다 효율적입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2594b97a91aa3fa79863d35058be1a8172ac679a" translate="yes" xml:space="preserve">
          <source>If there is no</source>
          <target state="translated">없는 경우</target>
        </trans-unit>
        <trans-unit id="836d7eec1f71c6b6f4181b3811b03cbac0e80430" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt; , case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">&lt;code&gt;\E&lt;/code&gt; 가 없으면 문자열이 끝날 때까지 대소 문자가 변환됩니다. regexps '에 &lt;code&gt;\L\u$word&lt;/code&gt; 또는 &lt;code&gt;\u\L$word&lt;/code&gt; 변환의 첫 번째 문자 &lt;code&gt;$word&lt;/code&gt; 대문자와 소문자로 문자의 나머지.</target>
        </trans-unit>
        <trans-unit id="f1b2b91591fb1955a250148f5d6f9f32438d8436" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt;, case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">&lt;code&gt;\E&lt;/code&gt; 가 없으면 문자열 끝까지 대소 문자가 변환됩니다. regexps '에 &lt;code&gt;\L\u$word&lt;/code&gt; 또는 &lt;code&gt;\u\L$word&lt;/code&gt; 변환의 첫 번째 문자 &lt;code&gt;$word&lt;/code&gt; 대문자와 소문자로 문자의 나머지.</target>
        </trans-unit>
        <trans-unit id="c73d7b3af9d178254858949bc270c269c6e2e60d" translate="yes" xml:space="preserve">
          <source>If there is no INSTALL.SKIP file in the make directory then this value can be used to provide a default.</source>
          <target state="translated">make 디렉토리에 INSTALL.SKIP 파일이 없으면이 값을 사용하여 기본값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3610af61096f12f4c9e6f52b35a24b772a2c16bd" translate="yes" xml:space="preserve">
          <source>If there is no Pod in the given document, then the event structure will be this:</source>
          <target state="translated">주어진 문서에 포드가없는 경우 이벤트 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="349639462c1781c6c7203933948097f1b032dbf1" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">입력 코드 포인트에 대소 문자가 접히지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb296c4463c79fc259188fecb37636b958c8768" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">입력 코드 포인트에 대한 대소 문자 접기가 없으면 &lt;code&gt;undef&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20a8d9cc6cec6caebf969b32884584509dabbda2" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">해당 캡처 그룹이 정의되어 있지 않으면 치명적인 오류입니다. 입력 문자열을 사용하지 않고 50 회 이상 반복하면 치명적인 오류가 발생합니다. 최대 깊이는 perl로 컴파일되므로이를 변경하려면 사용자 정의 빌드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9a6e24a6b319d54eae6772ce7d4930464be16411" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeply without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="translated">정의 된 해당 캡처 그룹이 없으면 치명적인 오류입니다. 입력 문자열을 사용하지 않고 깊이 반복하면 치명적인 오류가 발생합니다. 발생하는 깊이는 perl로 컴파일되므로 사용자 지정 빌드로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28265c4ced5473656451fd65ecb5d6a73bdd1b4e" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">설명이없는 경우 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker에&lt;/a&gt; 문서화 된 WriteMakefile ()에 대한 매개 변수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c7947682ddf8ce5897cbba5d096660017802ec" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in ExtUtils::MakeMaker.</source>
          <target state="translated">설명이 없으면 ExtUtils :: MakeMaker에 설명 된 WriteMakefile ()의 매개 변수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9a08244ff3de5da70abd74d4f48bc9a98bd5fd63" translate="yes" xml:space="preserve">
          <source>If there is no error, then the method returns the value of the last expression evaluated, or a return statement may be used, just as with subroutines and &lt;b&gt;eval()&lt;/b&gt;. The context (list or scalar) is determined by the caller as usual.</source>
          <target state="translated">오류가 없으면 메소드는 마지막으로 평가 된 표현식의 값을 리턴하거나 서브 루틴 및 &lt;b&gt;eval ()에서&lt;/b&gt; 와 같이 리턴 명령문을 사용할 수 있습니다 . 컨텍스트 (목록 또는 스칼라)는 일반적인 방법으로 호출자가 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9fcf9881e5055fcb38df136c867429f9722c1a7e" translate="yes" xml:space="preserve">
          <source>If there is no global precision or accuracy set, &lt;b&gt;and&lt;/b&gt; the operation in question was not called with a requested precision or accuracy, &lt;b&gt;and&lt;/b&gt; the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &lt;code&gt;div_scale&lt;/code&gt; and can be accessed via:</source>
          <target state="translated">이 전역 정밀도 또는 정확성 세트 없으며, 경우 &lt;b&gt;및&lt;/b&gt; 해당 작업이 요청 된 정밀도 또는 정확도로 호출되지 않은, &lt;b&gt;그리고&lt;/b&gt; 입력 $ x가 더 정확성과 정밀도가 설정되지, 다음 대체 매개 변수가 사용됩니다. 역사적 이유로 &lt;code&gt;div_scale&lt;/code&gt; 이라고 하며 다음을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd1fd130f18a572d29a93b5834a0fdb0347ebb7" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">상호 작용이없는 경우에도 여전히 &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;템플릿 툴킷&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit&lt;/a&gt; 과 같은 것을 사용 하여 HTML 파일 (및 기타 자산)을보다 쉽게 ​​관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a299e842222c6ed90a64aa41cd2a789a3c361e2f" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">상호 작용이없는 경우에도 &lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt; 또는 &lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkit&lt;/a&gt; 과 같은 것을 사용 하여 HTML 파일 (및 기타 자산)을 더 쉽게 유지 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd8956e9b63cae584008cf6c1bbe7cd26c8c5c5" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">일치하는 항목이없고 기본값이 정의되어 있지 않거나 .netrc 파일이 없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e6537a61412be05c76bbd6dbb9043f0a60ac95b9" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">일치하는 항목이없고 정의 된 기본값이 없거나 .netrc 파일이없는 경우 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6dfba39c8f615f2c8441ca5b61296e07f9cf19" translate="yes" xml:space="preserve">
          <source>If there is no top hub, and you do not ask to leave IPC and formatter undef, then a new formatter will be created, and the IPC instance from &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; will be used.</source>
          <target state="translated">최상위 허브가없고 IPC 및 포맷터를 undef 상태로 두도록 요청하지 않으면 새 포맷터가 생성되고 &lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt; 의 IPC 인스턴스 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40165726268e187e7ad5a226c93cb70fb5e7ae2c" translate="yes" xml:space="preserve">
          <source>If there is only one argument and it is a reference to an array then the array is assumed to contain a list of key-value pairs specifying the options. In this case the option &quot;from_to&quot; is mandatory. This style means that you do not have to supply a cryptic list of arguments and can use a self documenting argument list that is easier to understand.</source>
          <target state="translated">인수가 하나만 있고 배열에 대한 참조 인 경우 배열은 옵션을 지정하는 키-값 쌍 목록을 포함하는 것으로 가정합니다. 이 경우 &quot;from_to&quot;옵션은 필수입니다. 이 스타일은 인수의 암호 목록을 제공 할 필요가없고 이해하기 쉬운 자체 문서화 인수 목록을 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="663e6f7ad7626839945e055f61dd00fa139292d7" translate="yes" xml:space="preserve">
          <source>If there was an error authenticating the user then</source>
          <target state="translated">사용자 인증 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="c4805e4afe7a0ccfe45caa54514a077972082082" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt; , then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt; , which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt; , that is not yet in &lt;code&gt;%table&lt;/code&gt; ?</source>
          <target state="translated">현재 &lt;code&gt;$country&lt;/code&gt; 대한 &lt;code&gt;%table&lt;/code&gt; 에 이미 항목이 있으면 아무것도 다릅니다. 6 행 은 배열에 대한 참조 인 &lt;code&gt;$table{$country}&lt;/code&gt; 의 값을 찾아 &lt;code&gt;$city&lt;/code&gt; 를 배열로 푸시 합니다. 그러나이 때 무엇을 않는 &lt;code&gt;$country&lt;/code&gt; 말할 키를 보유하고 &lt;code&gt;Greece&lt;/code&gt; 에 아직, &lt;code&gt;%table&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="9e3670f66abc27b9c0c1a9a3a64b0edd5b7f7779" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt;, then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt;, which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt;, that is not yet in &lt;code&gt;%table&lt;/code&gt;?</source>
          <target state="translated">현재 &lt;code&gt;$country&lt;/code&gt; 대한 항목이 &lt;code&gt;%table&lt;/code&gt; 에 이미있는 경우 다른 것은 없습니다. 6 행 은 배열에 대한 참조 인 &lt;code&gt;$table{$country}&lt;/code&gt; 의 값을 찾고 &lt;code&gt;$city&lt;/code&gt; 를 배열로 푸시 합니다. 그러나이 때 무엇을 않는 &lt;code&gt;$country&lt;/code&gt; 말할 키를 보유하고 &lt;code&gt;Greece&lt;/code&gt; 에 아직, &lt;code&gt;%table&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="b79b95fc8b6f0bdad9a42663607fbb6bbfce24c2" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt; , why does their concatenation have one?</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 또는 &lt;code&gt;s2&lt;/code&gt; 에 &lt;code&gt;\w&lt;/code&gt; 가 없으면 왜 연결에 하나가 있습니까?</target>
        </trans-unit>
        <trans-unit id="f998e73c18ed98eef0579d8f9950627eae9eb668" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt;, why does their concatenation have one?</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 또는 &lt;code&gt;s2&lt;/code&gt; 에 &lt;code&gt;\w&lt;/code&gt; 가 없으면 왜 연결에 하나가 있습니까?</target>
        </trans-unit>
        <trans-unit id="e887683b17f434ea92edf8b372be7bfa0a590185" translate="yes" xml:space="preserve">
          <source>If there's no handle_unknown_option, then we just warn, and then increment the error counter</source>
          <target state="translated">handle_unknown_option이 없으면 경고하고 오류 카운터를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="4d867e0a4fd4a8ea827c16a08b87197c9c461d55" translate="yes" xml:space="preserve">
          <source>If these dependent libraries are not listed at shared library creation time, you will get fatal &quot;Unresolved symbol&quot; errors at run time when the library is loaded.</source>
          <target state="translated">이러한 종속 라이브러리가 공유 라이브러리 작성 시간에 나열되지 않으면 라이브러리가로드 될 때 런타임시 치명적인 &quot;해결되지 않은 기호&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66c4d2d6f3874b5b92940f178682f9bbdd8c1db5" translate="yes" xml:space="preserve">
          <source>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn't match it). Defining a catch-all &lt;code&gt;'nomethod'&lt;/code&gt; (see &lt;a href=&quot;#nomethod&quot;&gt;below&lt;/a&gt;) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</source>
          <target state="translated">이러한 연산자가 명시 적으로 오버로드되지 않으면 정상적인 방식으로 작동하여 기본 스칼라, 배열 또는 객체 데이터를 저장하는 모든 항목 (역 참조 연산자가 일치하지 않는 경우 적절한 오류 메시지)을 생성합니다. catch-all &lt;code&gt;'nomethod'&lt;/code&gt; ( &lt;a href=&quot;#nomethod&quot;&gt;아래 참조&lt;/a&gt; )를 정의하면 누락 된 역 참조 연산자를 구현하기 위해 catch-all 함수가 호출되지 않으므로 이에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7e81ed1aafee87e39f3bf4df7400134171b1b47" translate="yes" xml:space="preserve">
          <source>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&amp;lt;/em&amp;gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&amp;lt;lt&amp;gt;&quot; or &quot;E&amp;lt;eacute&amp;gt;&quot;. But since this is in a &quot;=begin</source>
          <target state="translated">이것들이 일반적인 문단이라면 포드 파서는 &quot;E &amp;lt;em&amp;gt;&quot;또는 &quot;E &amp;lt;eacute&amp;gt;&quot;와 같이 &quot;E &amp;lt;/ em&amp;gt;&quot;(첫 번째 문단)를 서식 코드로 확장하려고합니다. 그러나 이것은 &quot;= 시작하기 때문에</target>
        </trans-unit>
        <trans-unit id="fc6b5f11ab146ad9637defe5808c195788361c30" translate="yes" xml:space="preserve">
          <source>If these weren't meant to be POSIX classes, this warning message is spurious, and can be suppressed by reordering things, such as</source>
          <target state="translated">이것이 POSIX 클래스가 아닌 경우이 경고 메시지는 허위이며 다음과 같은 항목을 재정렬하여 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4135dfc8a9407c20cefc1359ee43028a8d9e9a77" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a6c7139e709a41aafbcb832650d6f1102386857" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">구성 할 수없는 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7928853cb29cf0ed7b6549f627a68e66710a9993" translate="yes" xml:space="preserve">
          <source>If they wanted to clobber something, they might say:</source>
          <target state="translated">그들이 무언가를 방해하고 싶다면,</target>
        </trans-unit>
        <trans-unit id="005637a170229ceb4ce45f18dce99b88396f9f92" translate="yes" xml:space="preserve">
          <source>If things aren't broken, upgrading perl may break them (or at least issue new warnings).</source>
          <target state="translated">문제가 해결되지 않으면 perl을 업그레이드하면 문제가 발생하거나 최소한 새로운 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f401b770207b3e95d6e44d96ff6ad2d9bf229b05" translate="yes" xml:space="preserve">
          <source>If this attribute is set to true, the parser will not ignore empty &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; blocks. The type of &lt;code&gt;=over&lt;/code&gt; will be</source>
          <target state="translated">이 속성이 true로 설정되면 구문 분석기는 빈 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록을 무시하지 않습니다 . &lt;code&gt;=over&lt;/code&gt; 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af3184843a959ec8cbcadf6df48b4b495b6b3f78" translate="yes" xml:space="preserve">
          <source>If this behaviour is not desirable, the &lt;code&gt;error&lt;/code&gt; attribute may be used to hold a reference to a variable, which will be used to store the diagnostics. The variable is made a reference to an array of hash references. Each hash contain a single key/value pair where the key is the name of the file, and the value is the error message (including the contents of &lt;code&gt;$!&lt;/code&gt; when appropriate). If a general error is encountered the diagnostic key will be empty.</source>
          <target state="translated">이 동작이 바람직하지 않은 경우 &lt;code&gt;error&lt;/code&gt; 속성을 사용하여 변수에 대한 참조를 보유 할 수 있으며 이는 진단을 저장하는 데 사용됩니다. 변수는 해시 참조 배열을 참조합니다. 각 해시는 단일 키 / 값 쌍을 포함합니다. 여기서 키는 파일 이름이고 값은 오류 메시지입니다 ( 적절한 경우 &lt;code&gt;$!&lt;/code&gt; 의 내용 포함 ). 일반적인 오류가 발생하면 진단 키가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9e80a2a00d7763bcb33166ac12286d96be2d204" translate="yes" xml:space="preserve">
          <source>If this bit is set and a file [but not a directory] named &lt;code&gt;$sNewName&lt;/code&gt; already exists, then it will be replaced by &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail rather than replace an existing &lt;code&gt;$sNewName&lt;/code&gt;.</source>
          <target state="translated">이 비트가 설정되고 &lt;code&gt;$sNewName&lt;/code&gt; 이라는 파일 [디렉토리가 아님]이 이미 존재하는 경우 &lt;code&gt;$sOldName&lt;/code&gt; 으로 대체됩니다 . 이 비트가 설정되지 않은 경우 기존 &lt;code&gt;$sNewName&lt;/code&gt; 대체하는 대신 &lt;code&gt;MoveFileEx&lt;/code&gt; 가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="fa9fb1ea3eae474e9c243073b7277960fe7cd8b7" translate="yes" xml:space="preserve">
          <source>If this bit is set, then calls to &lt;code&gt;CloseHandle&lt;/code&gt; against this handle will be ignored, leaving the handle open and usable.</source>
          <target state="translated">이 비트가 설정되면 이 핸들에 대한 &lt;code&gt;CloseHandle&lt;/code&gt; 호출 이 무시되고 핸들이 열려 있고 사용 가능한 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0ba2e4466abc8ea8b16e3596960ca402d75037" translate="yes" xml:space="preserve">
          <source>If this bit is set, then children of this process who inherit handles [that is, processes created by calls to the Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API with the &lt;code&gt;bInheritHandles&lt;/code&gt; parameter specified as &lt;code&gt;TRUE&lt;/code&gt;], will inherit this particular object handle.</source>
          <target state="translated">이 비트가 설정되면 핸들 (즉, &lt;code&gt;TRUE&lt;/code&gt; 로 지정된 &lt;code&gt;bInheritHandles&lt;/code&gt; 매개 변수 를 사용하여 Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API를 호출하여 생성 된 프로세스)을 상속하는이 프로세스의 자식은 이 특정 개체 핸들을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="cfffc413c869bcf00848584ef88629d0cba8d4b7" translate="yes" xml:space="preserve">
          <source>If this command lists any paths that don't exist on your system, then you may need to move the appropriate libraries to these locations, or create symbolic links, aliases, or shortcuts appropriately. &lt;code&gt;@INC&lt;/code&gt; is also printed as part of the output of</source>
          <target state="translated">이 명령이 시스템에 존재하지 않는 경로를 나열하는 경우 적절한 라이브러리를이 위치로 이동하거나 기호 링크, 별명 또는 단축키를 적절하게 작성해야합니다. &lt;code&gt;@INC&lt;/code&gt; 는 출력의 일부로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4975023e8ced451b521e66f7c64344d22c9935aa" translate="yes" xml:space="preserve">
          <source>If this directory is exactly the same as the prefix which was compiled into</source>
          <target state="translated">이 디렉토리가 컴파일 된 접두사와 정확히 동일한 경우</target>
        </trans-unit>
        <trans-unit id="285c8028480f1bd9da414482302791b2b2e5917d" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; ), you have non-const data. The symbols the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">이것이 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;d&lt;/code&gt; 기호 (또는 가능하면 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; )를 표시하면 비 정확한 데이터가있는 것입니다. 기호 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 다음과 같이 제거는 다음과 같습니다 &lt;code&gt;Tt&lt;/code&gt; 있습니다</target>
        </trans-unit>
        <trans-unit id="e00722416b7c55f26c8b791511437fbf3bd5fa48" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt;), you have non-const data. The symbols the &lt;code&gt;grep&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">이 표시가있는 경우 &lt;code&gt;D&lt;/code&gt; 또는 &lt;code&gt;d&lt;/code&gt; 심볼 (또는 가능한 &lt;code&gt;C&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; )는 비 데이터 CONST있다. 기호 &lt;code&gt;grep&lt;/code&gt; 다음과 같이 제거는 다음과 같습니다 &lt;code&gt;Tt&lt;/code&gt; 있습니다</target>
        </trans-unit>
        <trans-unit id="4abdac7aa391382bc2754c2374cb867d27e05580" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">이 환경 변수가 true 값으로 설정되면이 모듈에 의해 정의 된 모든 함수 (color (), colored () 및 프로그램에서 이전에 사용되지 않은 모든 상수)가 이스케이프 시퀀스를 출력하지 않고 대신 빈 문자열을 반환하거나 적절하게 원본 텍스트를 전달하십시오. 이는 ANSI 이스케이프 시퀀스를 지원하지 않는 플랫폼에서이 모듈을 사용하여 스크립트를 쉽게 사용할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="38f035ce9a9a2458333cab9abdbe9a0ca164bacc" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">이 환경 변수가 true 값으로 설정되면이 모듈에 의해 정의 된 모든 함수 (color (), colors () 및 모든 상수)는 이스케이프 시퀀스를 출력하지 않고 대신 빈 문자열을 반환하거나 전달합니다. 적절하게 원본 텍스트를 통해. 이는 ANSI 이스케이프 시퀀스를 지원하지 않는 플랫폼에서이 모듈을 사용하여 스크립트를 쉽게 사용할 수 있도록 지원하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f18c65b6596250b7fc84f994b0860dfb64443933" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to any value, it suppresses generation of escape sequences the same as if ANSI_COLORS_DISABLED is set to a true value. This implements the &lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt; informal standard. Programs that want to enable color despite NO_COLOR being set will need to unset that environment variable before any constant or function provided by this module is used.</source>
          <target state="translated">이 환경 변수가 임의의 값으로 설정되면 ANSI_COLORS_DISABLED가 true 값으로 설정된 것과 동일한 이스케이프 시퀀스 생성을 억제합니다. 이것은 &lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt; 비공식 표준을 구현합니다 . NO_COLOR가 설정되어 있음에도 불구하고 색상을 활성화하려는 프로그램은이 모듈에서 제공하는 상수 또는 함수를 사용하기 전에 해당 환경 변수를 설정 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="876cbaf8d98a55944949f12e34d25c434a20bad7" translate="yes" xml:space="preserve">
          <source>If this environment variable is true then normal install processes will always overwrite older identical files during the install process.</source>
          <target state="translated">이 환경 변수가 true이면 일반 설치 프로세스는 설치 프로세스 중에 항상 동일한 동일한 파일을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="e053edd732d7c1c9c9166271bdb64b8b374b5d23" translate="yes" xml:space="preserve">
          <source>If this event is nested inside of other events, this should be the depth of nesting. (This is mainly for subtests)</source>
          <target state="translated">이 이벤트가 다른 이벤트 내부에 중첩 된 경우 중첩 깊이 여야합니다. (주로 하위 테스트 용입니다.)</target>
        </trans-unit>
        <trans-unit id="30b941d4f353a594151f4f0a38deaca7c7d4a4d4" translate="yes" xml:space="preserve">
          <source>If this feature is enabled (which is the default under a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration), EXPR is considered to be in the same encoding as the surrounding program. Thus if &lt;a href=&quot;utf8&quot;&gt;&lt;code&gt;use utf8&lt;/code&gt;&lt;/a&gt; is in effect, the string will be treated as being UTF-8 encoded. Otherwise, the string is considered to be a sequence of independent bytes. Bytes that correspond to ASCII-range code points will have their normal meanings for operators in the string. The treatment of the other bytes depends on if the &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;'unicode_strings&quot;&lt;/code&gt; feature&lt;/a&gt; is in effect.</source>
          <target state="translated">이 기능이 활성화 된 경우 ( &lt;code&gt;use 5.16&lt;/code&gt; 이상 선언 의 기본값 ) EXPR은 주변 프로그램과 동일한 인코딩으로 간주됩니다. 따라서 &lt;a href=&quot;utf8&quot;&gt; &lt;code&gt;use utf8&lt;/code&gt; &lt;/a&gt; 이 유효한 경우 문자열은 UTF-8로 인코딩 된 것으로 처리됩니다. 그렇지 않으면 문자열은 독립적 인 바이트 시퀀스로 간주됩니다. ASCII 범위 코드 포인트에 해당하는 바이트는 문자열의 연산자에 대한 일반적인 의미를 갖습니다. 다른 바이트의 처리는 &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;'unicode_strings&quot;&lt;/code&gt; 기능&lt;/a&gt; 이 유효 한지 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f7eb5123560aed4a2756b83ae3d2c52a26a17f8b" translate="yes" xml:space="preserve">
          <source>If this field is omitted, it defaults to 1 (true).</source>
          <target state="translated">이 필드를 생략하면 기본값은 1 (true)입니다.</target>
        </trans-unit>
        <trans-unit id="07fe5d03fc19f605909f122565e563658cd995e6" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">이 필드가 0이면 &lt;code&gt;PerlIO_pushed&lt;/code&gt; 는 아무 것도 말코 하지 않으며 레이어의 푸시 기능은 필요한 레이어 스택 조작을 수행한다고 가정합니다. 더미 레이어에 대한 말코 / 무료 오버 헤드를 피하는 데 사용됩니다. 필드가 0이 아닌 경우, 최소한 &lt;code&gt;PerlIOl&lt;/code&gt; 크기 여야합니다 . &lt;code&gt;PerlIO_pushed&lt;/code&gt; 는 계층의 데이터 구조에 메모리를 할당하고 새 계층을 스트림 스택에 링크합니다. 레이어의 Pushed 메서드가 오류 표시를 반환하면 레이어가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a5a45df8d66f9a394f3a4c96ed9c17f127fd5118" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt;, &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">이 필드가 0이면 &lt;code&gt;PerlIO_pushed&lt;/code&gt; 는 아무 것도 malloc하지 않으며, 레이어의 Pushed 함수가 더미 레이어에 대한 malloc / free 오버 헤드를 피하기 위해 필요한 레이어 스택 조작을 수행한다고 가정합니다. 필드가 0이 아닌 경우 &lt;code&gt;PerlIOl&lt;/code&gt; 의 크기 이상이어야합니다 . &lt;code&gt;PerlIO_pushed&lt;/code&gt; 는 계층의 데이터 구조에 메모리를 할당하고 새 계층을 스트림의 스택에 연결합니다. (레이어의 Pushed 메서드가 오류를 반환하면 레이어가 다시 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="6eff879286b0f884c3e6b0dc473e05a91d80d4a8" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">이 함수가 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 를 통해 별도의 파일에서 제공되는 경우에는 문제가되지 않습니다 . 메인 프로그램에 모두 포함되어 있다면 메인 블록 위에 전체 블록을 배치하거나 &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록 만 배치 하여 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 을 조기에 실행 하도록하십시오. 프로그램이 실행되기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3b08fb8fb677146606e9cfcd0ad7806affc639d2" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;my&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">이 함수가 &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 를 통해 별도의 파일에서 제공되는 경우 아마도 괜찮을 것입니다. 모든 것이 메인 프로그램에있는 경우 , 전체 블록을 메인 프로그램 위에 놓거나 더 가능성이 높으면 그 주변에 &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록을 배치 하여 &lt;code&gt;my&lt;/code&gt; 프로그램이 조기에 실행 되도록해야합니다. 프로그램이 실행되기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e5121e7b7256f6d0ab378dc9bff9a8c6dad43577" translate="yes" xml:space="preserve">
          <source>If this happens to you, there's not much you can do except switch to use a different locale or use &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; to translate from the locale into UTF-8; if that's impracticable, you have been warned that some things may break.</source>
          <target state="translated">이런 일이 발생하면 다른 로케일을 사용하거나 로케일을 UTF-8로 변환 하기 위해 &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 를 사용하는 스위치를 제외하고는 할 수있는 일이 많지 않습니다 . 그것이 불가능한 경우, 당신은 어떤 것들이 깨질 수 있다는 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="faa64c33180aaefa8582782daf214d7a2f4780a7" translate="yes" xml:space="preserve">
          <source>If this interior sequence is nested inside of another interior sequence, then the outer/parent sequence that contains it is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">이 내부 시퀀스가 ​​다른 내부 시퀀스 안에 중첩 된 경우이 시퀀스가 ​​포함 된 외부 / 부모 시퀀스가 ​​반환됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf7d995797b0338af1d03b9d03a8511323aeb269" translate="yes" xml:space="preserve">
          <source>If this is a TODO test and an 'ok' line, this method returns true. Otherwise, it will always return false (regardless of passing status on non-todo tests).</source>
          <target state="translated">이것이 TODO 테스트이고 'ok'라인 인 경우이 메소드는 true를 리턴합니다. 그렇지 않으면, 할 일이 아닌 테스트에서 상태를 전달하지 않더라도 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="604eb865cff5427575c78b447eb628e9c645992c" translate="yes" xml:space="preserve">
          <source>If this is a simple scalar then it will be treated as a boolean for the 'buffered' setting. If this is a hash reference then it will be used as a parameters hash. The param hash will be used for hub construction (with the specified keys removed).</source>
          <target state="translated">이것이 단순한 스칼라 인 경우 '버퍼링 된'설정에 대한 부울로 처리됩니다. 이것이 해시 참조 인 경우 매개 변수 해시로 사용됩니다. 매개 변수 해시는 허브 구성에 사용됩니다 (지정된 키가 제거됨).</target>
        </trans-unit>
        <trans-unit id="f7666722db0ac2cfa26e5cabc574e02e68556877" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt; , if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt; .</source>
          <target state="translated">이것이 &lt;code&gt;re::regname&lt;/code&gt; 으로 호출 되면 &lt;code&gt;re::regnames&lt;/code&gt; 또는 &lt;code&gt;re::regnames_count&lt;/code&gt; (있는 경우). 처음 두 개는 &lt;code&gt;RXapif_ONE&lt;/code&gt; 또는 &lt;code&gt;RXapif_ALL&lt;/code&gt; 과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="79a068f47ba129d0ff77349a01057b9518f8fbed" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt;, &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt;, if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; 또는 &lt;code&gt;re::regnames_count&lt;/code&gt; 로 호출되는 경우 (있는 경우). 처음 두 개는 &lt;code&gt;RXapif_ONE&lt;/code&gt; 또는 &lt;code&gt;RXapif_ALL&lt;/code&gt; 과 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="9edbce2664bb4f91955d900ea95b27deaa6b5a4b" translate="yes" xml:space="preserve">
          <source>If this is in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; it will be passed to &lt;code&gt;Perl_fbm_instr&lt;/code&gt; by &lt;code&gt;pp_split&lt;/code&gt; which will treat the subject string as a multi-line string.</source>
          <target state="translated">이것이 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 에 있으면 &lt;code&gt;Perl_fbm_instr&lt;/code&gt; 의해 &lt;code&gt;pp_split&lt;/code&gt; 전달되어 제목 문자열을 여러 줄 문자열로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="3e0c042153cf9f6ff54247584b15672ab611a4af" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt; , it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">음수이고 &lt;code&gt;HEf_SVKEY&lt;/code&gt; 에 해당하면 항목에 &lt;code&gt;SV*&lt;/code&gt; 키 가 있음을 나타냅니다 . 그렇지 않으면 실제 키 길이를 유지합니다. 할당 할 수 있습니다. &lt;code&gt;HePV()&lt;/code&gt; 매크로 키 길이를 찾는 일반적으로 바람직하다.</target>
        </trans-unit>
        <trans-unit id="f90d0f4d493e8df7c15bcc83bca70a42ffcdb6df" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt;, it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">이것이 음수이고 &lt;code&gt;HEf_SVKEY&lt;/code&gt; 에 해당하는 경우 항목에 &lt;code&gt;SV*&lt;/code&gt; 키 가 있음을 나타냅니다 . 그렇지 않으면 키의 실제 길이를 보유합니다. 할당 할 수 있습니다. &lt;code&gt;HePV()&lt;/code&gt; 매크로 키 길이를 찾는 일반적으로 바람직하다.</target>
        </trans-unit>
        <trans-unit id="ddda819aeefa94d361f2fc0677ccc065e6c33f4f" translate="yes" xml:space="preserve">
          <source>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</source>
          <target state="translated">이것이 가치보다 무섭게 들리기 시작하면 긴장을 푸십시오. Perl에는 가장 일반적인 함정을 피하는 데 도움이되는 몇 가지 기능이 있습니다. 혼동을 피하는 가장 좋은 방법은 다음과 같이 모든 프로그램을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2cd7396387cdb373b2dd32a6d21ffa39a9fbdd0" translate="yes" xml:space="preserve">
          <source>If this is true, none of that will be done.</source>
          <target state="translated">이것이 사실이라면, 그 중 어느 것도 수행되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="998c59b2484753d1482d0ff9ba7497a84e80fcd4" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이것이 의도 한 것이라면 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; 를 사용하여 경고를 끄십시오 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="44c23df76d34643bd06f7fcbfd01951d86e6affe" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;m/${\}/&lt;/code&gt; (for example: &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt;).</source>
          <target state="translated">이것이 의도 한 것이라면 &lt;code&gt;m/${\}/&lt;/code&gt; (예 : &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt; ) 를 사용하여 경고를 음소거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2f4b7328771b0d9e19ff0a7ce5f9c13e4b36300" translate="yes" xml:space="preserve">
          <source>If this is your first use of Sys::Syslog, you must read the doc.</source>
          <target state="translated">이것이 Sys :: Syslog를 처음 사용하는 경우 문서를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="51d2478f45a9802ed436c7d6c5c2a5bb72aeb395" translate="yes" xml:space="preserve">
          <source>If this optimization is applicable, &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; will emit a &lt;code&gt;dXSTARG;&lt;/code&gt; definition at the start of the generated XSUB code, and type (see below) dependent code to set &lt;code&gt;TARG&lt;/code&gt; and push it on the stack at the end of the generated XSUB code.</source>
          <target state="translated">이 최적화를 적용 할 수있는 경우 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 는 dXSTARG 를 내 &lt;code&gt;dXSTARG;&lt;/code&gt; 생성 된 XSUB 코드의 시작 부분에 정의를 입력하고 종속 코드를 입력 (아래 참조)하여 &lt;code&gt;TARG&lt;/code&gt; 를 설정 하고 생성 된 XSUB 코드의 끝에서 스택에 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="51861420a23f19227e776c6bc3a38fdcea309df1" translate="yes" xml:space="preserve">
          <source>If this option is not present, the value stored in XFL field will be determined by the setting of the &lt;code&gt;Level&lt;/code&gt; option.</source>
          <target state="translated">이 옵션이 없으면 XFL 필드에 저장된 값은 &lt;code&gt;Level&lt;/code&gt; 옵션 의 설정에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="415323d14a6e182890345d78f7ae3f3149cdff1f" translate="yes" xml:space="preserve">
          <source>If this option is set and the input file/buffer is not compressed data, the module will allow reading of it anyway.</source>
          <target state="translated">이 옵션이 설정되고 입력 파일 / 버퍼가 압축 된 데이터가 아닌 경우 모듈은 어쨌든 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="805aae725ba9def01f764562edc887adcbc46d85" translate="yes" xml:space="preserve">
          <source>If this option is set, Pod::Man will instead output UTF-8. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">이 옵션을 설정하면 Pod :: Man이 대신 UTF-8을 출력합니다. * roff 구현이이를 처리 할 수있는 경우 이것이 사용하기에 가장 적합한 출력 형식이며 ASCII가 아닌 문자가 포함 된 문서의 손상을 피합니다. 그러나 리터럴 UTF-8 문자가있는 * roff 소스는 많은 구현에서 지원되지 않으며 segfaults 및 기타 나쁜 동작을 초래할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9276827e0a43ce0cd98e803156d215d94a1cfced" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the name of the command (</source>
          <target state="translated">이 단락이 명령 단락이면이 메소드는 명령의 이름을 리턴합니다 (</target>
        </trans-unit>
        <trans-unit id="bcc44b3b4b66c03b7a2464f3e737f50efd9dbf21" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the prefix used to denote the command (which should be the string &quot;=&quot; or &quot;==&quot;).</source>
          <target state="translated">이 단락이 명령 단락 인 경우이 메소드는 명령을 나타내는 데 사용되는 접두사 (문자열 &quot;=&quot;또는 &quot;==&quot;여야 함)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97d5af9792754821d43f791eb7a3e99d0e1078a4" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the text used to separate the command name from the rest of the paragraph (if any).</source>
          <target state="translated">이 단락이 명령 단락 인 경우이 메소드는 명령 이름을 나머지 단락과 분리하는 데 사용 된 텍스트를 반환합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="b75f187e2f383fe73ad62fc9d325ab173aba9b5e" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program to halt, unless trapped in an &lt;code&gt;eval&lt;/code&gt; block.</source>
          <target state="translated">이 매개 변수를 사용하지 않으면 특정 오류 조건에서 &lt;code&gt;eval&lt;/code&gt; 블록에 갇히지 않는 한 프로그램이 중지되는 치명적인 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1f4b76081f3628eb70be0fbee8dbf0d6e9f3ca4" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program will halt, unless trapped in an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">이 매개 변수를 사용하지 않으면 특정 오류 조건으로 인해 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록에 갇히지 않으면 치명적인 오류가 발생하여 프로그램이 중지 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d2fb08e29fba6225fdf1f445f37f2366e459721" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt; , and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt; , just like &lt;code&gt;$3&lt;/code&gt; , or it remains undefined.</source>
          <target state="translated">이 정규 표현식에 일치하는 경우, &lt;code&gt;$1&lt;/code&gt; 로 시작하는 문자열이 들어 &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 에 두 세트입니다 &lt;code&gt;'cd'&lt;/code&gt; 또는 &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등호 중 &lt;code&gt;'gi'&lt;/code&gt; 또는 &lt;code&gt;'j'&lt;/code&gt; , 및 &lt;code&gt;$4&lt;/code&gt; 에 두 세트입니다 &lt;code&gt;'gi'&lt;/code&gt; 단지를, 같은 &lt;code&gt;$3&lt;/code&gt; , 또는 그것은 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5fa9692a7ddbf5956b5114988e2959b2c5e493" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt;, and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt;, just like &lt;code&gt;$3&lt;/code&gt;, or it remains undefined.</source>
          <target state="translated">이 정규 표현식에 일치하는 경우, &lt;code&gt;$1&lt;/code&gt; 로 시작하는 문자열이 들어 &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 에 두 세트입니다 &lt;code&gt;'cd'&lt;/code&gt; 또는 &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; 등호 중 &lt;code&gt;'gi'&lt;/code&gt; 또는 &lt;code&gt;'j'&lt;/code&gt; , 및 &lt;code&gt;$4&lt;/code&gt; 에 두 세트입니다 &lt;code&gt;'gi'&lt;/code&gt; 단지를, 같은 &lt;code&gt;$3&lt;/code&gt; , 또는 그것은 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf2f5a008449abe516d485f423f30c756bf9374" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">이것이 많이 보인다면 대부분의 메소드에 대해 표준 Tie :: StdHash 모듈에서 상속하여 흥미로운 것만 재정의하십시오. 자세한 내용은 &lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f92dc123bfc535dc7925652fedf35a2b5f0876" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">이것이 많은 것처럼 보이면 대부분의 메소드에 대해 표준 Tie :: StdHash 모듈을 상속하고 흥미로운 메소드 만 재정의하십시오. 자세한 내용은 &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c67ef6ff224aaeb335a4c34ee8f8573b58ab3fc4" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">그래도 작동하지 않으면 &lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt; 에서 &lt;code&gt;clearerr&lt;/code&gt; 메서드를 살펴보면 핸들 의 오류 및 파일 끝 상태를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="d3f60efe640d39524c6e11c22deb74b1e7bd6e48" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">그래도 문제가 해결되지 않으면 &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; 에서 &lt;code&gt;clearerr&lt;/code&gt; 메소드를 살펴보십시오 . 그러면 핸들 의 오류 및 파일 끝 상태가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5f660c829995c0ccf8574939955dcb34cbb1fbc2" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">이 템플릿 키가 true 인 경우이 키가 사용자 입력으로 제공되면 해당 값이 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; . 이는 사용자 가이 키의 값으로 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 전달할 수 없으며 다음과 같습니다. allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="e156c85e449c1c19860e80cb4d0bda5ed5967f61" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;defined&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;undef&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">이 템플릿 키가 true이면이 키가 사용자 입력에 의해 제공되면 해당 값이 &lt;code&gt;defined&lt;/code&gt; 합니다. 이는 사용자 가이 키의 값으로 &lt;code&gt;undef&lt;/code&gt; 를 전달할 수 없음을 의미하며 다음 과 동일합니다. allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="76bbabb48932b2f041b390c777de07be84c85182" translate="yes" xml:space="preserve">
          <source>If this value is defined but false then such an operation has ocurred, but should not impact later operations.</source>
          <target state="translated">이 값이 정의되었지만 false 인 경우 해당 작업이 발생했지만 이후 작업에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc6a20a1fa0fe02624d3822b74f6ca89396c5ee4" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">이 변수를 true로 설정하면 Windows의 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 가 파일을 열려고하지 않습니다. 이는 파일에 대한 추가 하드 링크가 존재하는 경우 링크 수를 판별 할 수없고 파일 속성이 오래되었을 수 있음을 의미합니다. 반면, 특히 네트워크 드라이브에있는 파일의 경우 파일을 열지 않는 것이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="bea7dc99d361b98967fbf94336d0529e85ea5d0f" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;stat()&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">이 변수가 true 값으로 설정되면 Windows의 &lt;code&gt;stat()&lt;/code&gt; 는 파일 열기를 시도하지 않습니다. 즉, 파일에 대한 추가 하드 링크가있는 경우 링크 수를 확인할 수 없으며 파일 속성이 만료 될 수 있습니다. 반면에 파일을 열지 않는 것은 특히 네트워크 드라이브에있는 파일의 경우 상당히 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="65e9d7214894094637d48b5893992a1d4deebf1e" translate="yes" xml:space="preserve">
          <source>If this variable is true then such an operation has occurred and anything depending on this module cannot proceed until a reboot has occurred.</source>
          <target state="translated">이 변수가 true이면 해당 작업이 발생한 것이므로이 모듈에 따라 재부팅이 발생할 때까지 진행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0523b9c70c7c9e8111746aca12afc08517491534" translate="yes" xml:space="preserve">
          <source>If this warning does come from I/O, the easiest way to quiet it is simply to add the &lt;code&gt;:utf8&lt;/code&gt; layer,</source>
          <target state="translated">이 경고가 I / O에서 발생하는 경우 가장 쉬운 방법은 간단히 &lt;code&gt;:utf8&lt;/code&gt; 레이어 를 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="41c3e520fc9953b8c23b0cb154effeffba4245f7" translate="yes" xml:space="preserve">
          <source>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt; or nothing, the file is opened for input. If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , the file is opened for appending, again being created if necessary.</source>
          <target state="translated">세 개 이상의 인수가 지정된 경우 두 번째 인수의 열린 모드 (선택적 인코딩 포함)는 세 번째의 파일 이름과 다릅니다. MODE가 &lt;code&gt;&amp;lt;&lt;/code&gt; 이거나 아니면 파일이 입력을 위해 열립니다. MODE가 &lt;code&gt;&amp;gt;&lt;/code&gt; 이면 기존 파일이 먼저 잘리고 ( &quot;clobbered&quot;) 존재하지 않는 파일이 새로 작성된 상태로 파일이 출력을 위해 열립니다. MODE가 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 이면 파일을 추가하기 위해 열어 필요한 경우 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="977c9556940f8be99675602713d0721d1fa68782" translate="yes" xml:space="preserve">
          <source>If trailing data is present immediately after the zip archive and the &lt;code&gt;Transparent&lt;/code&gt; option is enabled, this method will consider that trailing data to be another member of the zip archive.</source>
          <target state="translated">후행 데이터가 zip 아카이브 바로 뒤에 있고 &lt;code&gt;Transparent&lt;/code&gt; 옵션이 활성화 된 경우이 방법은 해당 후행 데이터를 zip 아카이브의 다른 구성원으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="2e10a47d1100af2f4e741fa10c714b1d6eb83c05" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate a JavaScript in the output directory, and set our HTML files to use it. Currently, the JavaScript is used only to get the browser to remember what stylesheet it prefers. TODO: continue</source>
          <target state="translated">true 인 경우 (기본값) 출력 디렉토리에서 JavaScript를 자동 생성하고 HTML 파일을 사용하도록 설정합니다. 현재 JavaScript는 브라우저가 선호하는 스타일 시트를 기억하도록하기 위해 사용됩니다. TODO : 계속</target>
        </trans-unit>
        <trans-unit id="634c500cd04e5d0b913158c1c6e9ccddc0f9bc06" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate some CSS files in the output directory, and set our HTML files to use those. TODO: continue</source>
          <target state="translated">true 인 경우 (기본값) 출력 디렉토리에서 일부 CSS 파일을 자동 생성하고 HTML 파일을 사용하도록 설정합니다. TODO : 계속</target>
        </trans-unit>
        <trans-unit id="ed672b2b381b7d94345040cc4eb4667fc3d97c8b" translate="yes" xml:space="preserve">
          <source>If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, warning &quot;symbolic_link_name is a dangling symbolic link\n&quot; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="translated">true이고 코드 참조 인 경우 기호 링크 이름 및 디렉토리가 인수로있는 디렉토리와 함께 호출됩니다. 그렇지 않으면 true이고 경고가 설정된 경우 &quot;symbolic_link_name이 매달려있는 심볼릭 링크 \ n&quot;이라는 경고가 표시됩니다. False이면 매달려있는 심볼릭 링크가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="93e6a2b3c3a0187d609e46522f3b6f893e49aa02" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with &lt;code&gt;quadmath_snprintf()&lt;/code&gt;, but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_valid&quot;&gt;&quot;quadmath_format_valid&quot;&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because &lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">true가 반환되면 이론적으로 이러한 인수 &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;quadmath_snprintf()&lt;/code&gt; 로 처리 &lt;b&gt;되어야합니다&lt;/b&gt; . 그러나 그러한 형식 지정자가 둘 이상인 경우 ( &lt;a href=&quot;#quadmath_format_valid&quot;&gt;&quot;quadmath_format_valid&quot;&lt;/a&gt; 참조 ), 그 외에 다른 것이있는 경우 (단지 1 바이트라도 ), &lt;code&gt;quadmath_snprintf()&lt;/code&gt; 는 매우 엄격하고 하나의 형식 사양 만 허용하고 다른 것은 허용 &lt;b&gt;하지&lt;/b&gt; 않기 때문에 처리 할 &lt;b&gt;수 없습니다&lt;/b&gt; . 이 경우 코드가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f3fdfd0a40c103a2211bdac354013485a8b6be3" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with quadmath_snprintf(), but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because quadmath_snprintf() is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">true가 반환되면 이러한 인수 &lt;b&gt;는&lt;/b&gt; 이론적으로 quadmath_snprintf ()를 사용하여 처리 &lt;b&gt;해야&lt;/b&gt; 하지만 이러한 형식 지정자가 두 개 이상인 경우 ( &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt; 참조 ) 그 이외의 항목이있는 경우 (단일 바이트) quadmath_snprintf ()는 매우 엄격하여 하나의 형식 사양 만 허용하고 다른 형식은 허용 &lt;b&gt;하지 않으므로&lt;/b&gt; 처리 할 &lt;b&gt;수 없습니다&lt;/b&gt; . 이 경우 코드가 실패해야합니다.</target>
        </trans-unit>
        <trans-unit id="0653af7b3995880e12e86c1b6df46b2abdc8adcd" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;Configure&lt;/code&gt; will check each hostname given that it exists</source>
          <target state="translated">true 인 경우 &lt;code&gt;Configure&lt;/code&gt; 는 각 호스트 이름이 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5e192827bd7624c2eefa078600e9250f2fd8d099" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;make test&lt;/code&gt; may attempt to connect to hosts given in the configuration.</source>
          <target state="translated">true 인 경우 &lt;code&gt;make test&lt;/code&gt; 에서 구성에 지정된 호스트에 연결을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dfb0e1e33130859f2e7e4109870d6a5dff7d085" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TAP::Harness&lt;/code&gt; will output the verbose results of running its tests.</source>
          <target state="translated">true 인 경우 &lt;code&gt;TAP::Harness&lt;/code&gt; 는 테스트 실행의 자세한 결과를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1bd986bfa48b8d9de9607995da53c20f474abed0" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;Test::Harness&lt;/code&gt; will output the verbose results of running its tests. Setting &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; will override this, or you can use the &lt;code&gt;-v&lt;/code&gt; switch in the</source>
          <target state="translated">true 인 경우 &lt;code&gt;Test::Harness&lt;/code&gt; 는 테스트 실행의 자세한 결과를 출력합니다. &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; 설정하면 이를 무시하거나 &lt;code&gt;-v&lt;/code&gt; 스위치를 사용하여</target>
        </trans-unit>
        <trans-unit id="44529fee5d3eb44416500710e8dc9bea67c57ded" translate="yes" xml:space="preserve">
          <source>If true, STDERR and STDOUT are the same filehandle. This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.</source>
          <target state="translated">true 인 경우 STDERR 및 STDOUT은 동일한 파일 핸들입니다. STDERR에 TAP 형식과 유사한 것이 포함되어 있지만 정확한 동기화를 허용하는 경우 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1c5580c4e77a7f54f6b42fc274494bf3ad60b5" translate="yes" xml:space="preserve">
          <source>If true, make install will be verbose</source>
          <target state="translated">true 인 경우 자세한 설치를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a169cfeed98e3c1eafec522650538e080de52944" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt</source>
          <target state="translated">true이면 &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2e14d9f9dc273a75bb28fef309ebf7b650f85381" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt</source>
          <target state="translated">true이면 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e89fb240c4dc14ea640fd2d16ea6df8791107ad3" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt (not all OSes implement this sockopt)</source>
          <target state="translated">true 인 경우 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt를 설정합니다 (모든 OS가이 sockopt를 구현하는 것은 아님).</target>
        </trans-unit>
        <trans-unit id="dab1cddffad75299c410b1e954057e9efb6fb3e2" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">참이면 프록시 서브를 사용합니다. &lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb2c5a318ef60df6e780dd24e4ef173dd23b6b3c" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">true 인 경우 프록시 하위를 사용합니다. &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33b670decc24a56dd9e5e0101143f31051cabe4b" translate="yes" xml:space="preserve">
          <source>If two arrays smartmatch each other, then they are deep copies of each others' values, as this example reports:</source>
          <target state="translated">두 배열이 서로 스마트하게 일치하는 경우,이 예에서보고하는 것처럼 서로의 값에 대한 깊은 사본입니다.</target>
        </trans-unit>
        <trans-unit id="acee3e1d7871c445b42f87ba144a405a067cf53f" translate="yes" xml:space="preserve">
          <source>If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.</source>
          <target state="translated">여기 및 다음 두 문자 (코드 포인트)가 컴포저 블 가능하면 (한글 자모 / 음절 및 컴포지션 제외 포함) 컴포지트의 코드 포인트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5cba0eaa180ef04fc5494ba487a038ca330cd204" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&quot;fileparse_set_fstype&quot;&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">type이 Unix가 아닌 경우 ( &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&quot;fileparse_set_fstype&quot;&lt;/a&gt; 참조 ) 접미사 제거를위한 패턴 일치는 기존 파일을 열 때 해당 시스템이 대소 문자를 구분하지 않기 때문에 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42360b0ce037c1aa50c01166917adec5fecc2590" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">type이 Unix가 아닌 경우 ( &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt; 참조 ) 접미사 제거를위한 패턴 일치는 기존 파일을 열 때 대소 문자를 구분하지 않으므로 대소 문자를 구분하지 않고 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd48f2e17e1f717f9f154bd3292076827285d01" translate="yes" xml:space="preserve">
          <source>If umask(2) is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">시스템에 umask (2)가 구현되어 있지 않고 액세스를 제한하려는 경우</target>
        </trans-unit>
        <trans-unit id="67a1f447b6ee3db12f569b14d8d5a13cc81a620d" translate="yes" xml:space="preserve">
          <source>If unsafe signals is in effect, then signal handling is not thread-safe, and the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; signalling method cannot be used.</source>
          <target state="translated">안전하지 않은 신호가 유효하면 신호 처리가 스레드로부터 안전하지 않으며 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 신호 방식을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70663a96a9c0a32a9a2fde13b31bf56729b3885e" translate="yes" xml:space="preserve">
          <source>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</source>
          <target state="translated">업그레이드가 유효하면 현재 반올림 모드에서 N 자리로 반올림 된 PI를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6635daa00264b763872dbf741802de705f31e8f0" translate="yes" xml:space="preserve">
          <source>If used with -v &amp;lt;version&amp;gt; then all utilities released with that version of perl are listed, and any utility programs named on the command line are ignored.</source>
          <target state="translated">-v &amp;lt;version&amp;gt;과 함께 사용하면 해당 버전의 perl과 함께 릴리스 된 모든 유틸리티가 나열되고 명령 줄에 이름이 지정된 모든 유틸리티 프로그램은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d763c9ab9f9ca920e89e5e82fe0a4c19ddec98c7" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">스칼라 컨텍스트에서 단일 인수와 함께 사용되는 경우 명명 된 시퀀스의 코드 포인트로 구성된 문자열을 반환하거나 해당 이름의 명명 된 시퀀스가 ​​없으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. 목록 컨텍스트에서 단일 인수와 함께 사용하면 코드 포인트의 서수 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da57dfd2566c5bbbb36939e6a816eb57d92a5102" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;undef&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">스칼라 컨텍스트에서 단일 인수와 함께 사용되는 경우 명명 된 시퀀스의 코드 포인트로 구성된 문자열을 반환하거나 해당 이름의 명명 된 시퀀스가없는 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다. 목록 컨텍스트에서 단일 인수와 함께 사용되는 경우 코드 포인트의 서수 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="beaceddc3b74ab2a5e89e9e5517463a3fd4ed9e1" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">리스트 컨텍스트에서 인수없이 사용하면 이름이 지정된 모든 시퀀스의 이름을 키로 사용하고 해당 시퀀스를 문자열을 값으로 사용하여 해시를 리턴합니다. 그렇지 않으면 컨텍스트에 따라 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 빈 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0407b6cc8a060a9f5a98513aa0ab0a70e400908b" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;undef&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">목록 컨텍스트에서 인수없이 사용되는 경우 모든 명명 된 시퀀스의 이름을 키로, 시퀀스의 시퀀스를 값으로 문자열로 포함하는 해시를 반환합니다. 그렇지 않으면 컨텍스트에 따라 &lt;code&gt;undef&lt;/code&gt; 또는 빈 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="20ccd67205017380c2547c8a9567b9cb20e04c0c" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; on a Unicode string (which</source>
          <target state="translated">유니 코드 문자열에서 &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 (</target>
        </trans-unit>
        <trans-unit id="bcae58a7d75cf50d08d76e85d4556f2e6099dd18" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;버클리이&lt;/a&gt; 옵션을 선택하지 않습니다, 잠금을 구현하는 데 사용할 수 있습니다 CPAN에서 사용 가능한 모듈을 제공하고 있습니다. 각각은 잠금을 다르게 구현하고 다른 목표를 염두에두고 있습니다. 따라서 응용 프로그램에 적합한 것을 선택할 수 있도록 차이점을 아는 것이 좋습니다. 다음은 세 가지 잠금 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="6b1f504c6467cdb5b94820cfba3df9e446f6d20a" translate="yes" xml:space="preserve">
          <source>If using &lt;b&gt;BerkeleyDB&lt;/b&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">&lt;b&gt;BerkeleyDB&lt;/b&gt; 사용 이 옵션이 아닌 경우 CPAN에서 잠금을 구현하는 데 사용할 수있는 많은 모듈이 있습니다. 각각은 잠금을 다르게 구현하고 다른 목표를 염두에두고 있습니다. 따라서 차이점을 아는 것이 가치가 있으므로 응용 프로그램에 적합한 것을 선택할 수 있습니다. 다음은 세 가지 잠금 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="b0d8dee3f60efc11f28b77ac32acb4a0d6da837c" translate="yes" xml:space="preserve">
          <source>If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.</source>
          <target state="translated">Perl 파일을 소스로 사용하는 경우 perl 실행 파일을 호출 할 때 사용되는 선택적 스위치가 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a612abcdba4adc1d68486aebb4d51b768494dc19" translate="yes" xml:space="preserve">
          <source>If using adb, a &quot;basic&quot; Configure line will look like this:</source>
          <target state="translated">adb를 사용하는 경우 &quot;기본&quot;구성 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2c2e41b4856cbf4192df9fdfdae8eb4debbc3b0" translate="yes" xml:space="preserve">
          <source>If using crypt() on a Unicode string (which</source>
          <target state="translated">유니 코드 문자열에서 crypt ()를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="45cfcf2e0c855940dc64008801ae135f972cfd74" translate="yes" xml:space="preserve">
          <source>If using ftp remember to transfer the distribution in binary format.</source>
          <target state="translated">ftp를 사용하는 경우 이진 형식으로 배포를 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6fa09de90b513e62acb77e553ed8a67bf3a34b1" translate="yes" xml:space="preserve">
          <source>If using gcc, you can add the &lt;code&gt;-std=c89&lt;/code&gt; option which will hopefully catch most of these unportabilities. (However it might also catch incompatibilities in your system's header files.)</source>
          <target state="translated">gcc를 사용한다면, &lt;code&gt;-std=c89&lt;/code&gt; 옵션을 추가 할 수 있습니다 . 그러나 시스템 헤더 파일에서 비 호환성 문제가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae0365130c2e3d1490dd7527e14992a1ddb3fda" translate="yes" xml:space="preserve">
          <source>If using ssh, it's not too different -- we just change targetrun to ssh, and pass in targetuser and targetport. It ends up looking like this:</source>
          <target state="translated">ssh를 사용하는 경우도 다르지 않습니다. targetrun을 ssh로 변경하고 targetuser와 targetport를 전달하기 만하면됩니다. 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="664754e120bf0080d8c4c2636edd9c4d43e0b86a" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">명시 적 인코딩 이름없이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma &lt;a href=&quot;functions/use&quot;&gt;사용을 사용&lt;/a&gt; 하는 경우 PERL_ENCODING 환경 변수가 인코딩 이름을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="47d8d46dc66c1660b89d6816f6548597b112a1d7" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wuninitialized&lt;/code&gt;) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gcc -Wall&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;-O&lt;/code&gt; 로 컴파일하지 않는 한 모든 가능한 경고 (예 : &lt;code&gt;-Wuninitialized&lt;/code&gt; )가 제공되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cfca052b74a8f394827d7f4faa9fd4f5bf5109bf" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wunitialized&lt;/code&gt; ) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gcc -Wall&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;-O&lt;/code&gt; 로 컴파일하지 않으면 가능한 모든 경고 (예 : &lt;code&gt;-Wunitialized&lt;/code&gt; )가 제공되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fa9480a44177272fde2828188fac358cc2184e4c" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;use encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">명시 적 인코딩 이름없이 &lt;code&gt;use encoding&lt;/code&gt; pragma를 사용하는 경우 인코딩 이름에 대해 PERL_ENCODING 환경 변수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="49dda8790f1c37a11e446613192c2ff1c5642e05" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, to build use for example the File-&amp;gt;Open Workspace-&amp;gt; C:\Symbian\8.0a\S60_2nd_FP2\epoc32\build\symbian\perl\perl\wins\perl.dsw The emulator binaries will appear in the same directory.</source>
          <target state="translated">VC IDE를 사용하는 경우 빌드를 위해 파일-&amp;gt; 작업 공간 열기-&amp;gt; C : \ Symbian \ 8.0a \ S60_2nd_FP2 \ epoc32 \ build \ symbian \ perl \ perl \ wins \ perl.dsw 에뮬레이터 바이너리가 나타납니다. 동일한 디렉토리.</target>
        </trans-unit>
        <trans-unit id="87f25526e76efefdb9a4ff18e831107d545ddc34" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, you will a lot of warnings in the beginning of the build because a lot of headers mentioned by the source cannot be found, but this is not serious since those headers are not used.</source>
          <target state="translated">VC IDE를 사용하는 경우 소스에서 언급 한 많은 헤더를 찾을 수 없기 때문에 빌드 시작시 많은 경고가 표시되지만 해당 헤더가 사용되지 않으므로 심각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95f6a03b7ab2b25638142acde2118920ba4f7593" translate="yes" xml:space="preserve">
          <source>If we add a &lt;code&gt;(*PRUNE)&lt;/code&gt; before the count like the following</source>
          <target state="translated">다음과 같이 카운트 앞에 &lt;code&gt;(*PRUNE)&lt;/code&gt; 을 추가하면</target>
        </trans-unit>
        <trans-unit id="f49196da102bf295b3091d7157018af8c9071a57" translate="yes" xml:space="preserve">
          <source>If we call a method on a &lt;code&gt;Child&lt;/code&gt; object and that method is not defined in the &lt;code&gt;Child&lt;/code&gt; class, Perl will look for that method in the &lt;code&gt;Parent&lt;/code&gt; class and then, if necessary, in the &lt;code&gt;Grandparent&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;Child&lt;/code&gt; 객체 에서 메소드를 호출 하고 해당 메소드가 &lt;code&gt;Child&lt;/code&gt; 클래스에 정의되어 있지 않으면 Perl은 &lt;code&gt;Parent&lt;/code&gt; 클래스 에서 해당 메소드를 찾은 다음 필요한 경우 &lt;code&gt;Grandparent&lt;/code&gt; 클래스 에서 해당 메소드를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="ef968fd799fd1b1033f77f3853f27266c25aff48" translate="yes" xml:space="preserve">
          <source>If we can tell that there is no valid start point then we don't bother running the interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</source>
          <target state="translated">유효한 시작점이 없다는 것을 알 수 있다면 인터프리터를 전혀 실행하지 않아도됩니다. 마찬가지로, 분석 단계에서 시작 위치로의 지름길을 감지 할 수 없다는 것을 알면 통역사로 바로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ee8cb3b419bcafdec86df4116638973be94d94a5" translate="yes" xml:space="preserve">
          <source>If we could reliably use `goto &amp;amp;` on core builtins, we wouldn't need this subroutine.</source>
          <target state="translated">코어 내장에서`goto &amp;amp;`를 안정적으로 사용할 수 있다면이 서브 루틴이 필요하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2cd027f23ebc9bafdd0ef83ac988a2e8f6205abb" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;mkrot13&lt;/code&gt; 으로 이것을 암호화하면 :</target>
        </trans-unit>
        <trans-unit id="b2db7414804acef79a0ead64758e1284fbf24a9c" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt;:</source>
          <target state="translated">이것을 &lt;code&gt;mkrot13&lt;/code&gt; 으로 암호화하면 :</target>
        </trans-unit>
        <trans-unit id="b742d69e435d1dc4ae57558eae468b9e3038bfd1" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">우리가 수정해야 할 문자열이 있다면 정규 표현식은 거의 항상 훨씬 더 융통성이 있지만 , 자주 사용되지 않는 도구 인 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 은 여전히 ​​유용 할 수 있습니다. 하나의 시나리오는 모든 모음을 다른 문자로 대체 할 수 있습니다. 정규식 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8dec03047abaaa8042a15b74ce655789698f5d5" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;tr&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">수정해야 할 문자열이있는 경우 정규식은 거의 항상 훨씬 더 유연하지만 자주 사용되지 않는 도구 인 &lt;code&gt;tr&lt;/code&gt; 은 여전히 ​​유용 할 수 있습니다. 한 시나리오는 모든 모음을 다른 문자로 대체 할 수 있습니다. 정규식 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9e855f5e5eecc49e2e1826c2e605b2358ee8b64" translate="yes" xml:space="preserve">
          <source>If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0. &quot;ST&quot; is actually a macro that points to the n'th argument on the argument stack. ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on.</source>
          <target state="translated">예제 1을 제외한 모든 예제에서 생성 된 C 코드를 살펴보면 ST (n)에 대한 수많은 참조를 볼 수 있습니다. 여기서 n은 일반적으로 0입니다. &quot;ST&quot;는 실제로 n을 가리키는 매크로입니다. 인수 스택의 인수 따라서 ST (0)은 스택의 첫 번째 인수이므로 XSUB에 전달 된 첫 번째 인수이고 ST (1)은 두 번째 인수입니다.</target>
        </trans-unit>
        <trans-unit id="b4b727c2115d816f7a5edf98b373babd311821be" translate="yes" xml:space="preserve">
          <source>If we replace the &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; with &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt;, the variable changes are</source>
          <target state="translated">우리가 교체되면 &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; 과 &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt; , 변수의 변화는</target>
        </trans-unit>
        <trans-unit id="6b22701c7de1c1b18f83a3da253320877e6db57e" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">스칼라 컨텍스트에서 함수를 호출하려면 조금 더 많은 작업을 수행해야합니다. 우리는 실제로 중괄호 안에 좋아하는 코드를 가질 수 있으므로 스칼라 참조로 끝나기 만하면됩니다. 비록 그렇게하는 방법은 여러분에게 달려 있으며, 중괄호 안에 코드를 사용할 수 있습니다. 우리가 필요하므로 참고 괄호의 사용은리스트 문맥을 생성하는 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 함수에 대한 스칼라 문맥을 강제로 :</target>
        </trans-unit>
        <trans-unit id="b2ecb0d182e5a6aa3494d3aa82a88c04143a9745" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;scalar&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">스칼라 컨텍스트에서 함수를 호출하려면 좀 더 많은 작업을 수행해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 우리는 중괄호 안에 우리가 좋아하는 어떤 코드라도 가질 수 있습니다. 그래서 스칼라 참조로 끝내기 만하면됩니다.하지만 어떻게하는지는 여러분에게 달려 있습니다. 그리고 중괄호 안에 코드를 사용할 수 있습니다. 우리가 필요하므로 참고 괄호의 사용은리스트 문맥을 생성하는 &lt;code&gt;scalar&lt;/code&gt; 함수에 대한 스칼라 문맥을 강제로 :</target>
        </trans-unit>
        <trans-unit id="2aa4af82f261a5bfccad859728bbc5e698f2ad5a" translate="yes" xml:space="preserve">
          <source>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</source>
          <target state="translated">해시 값을 기준으로 정렬하려면 해시 키를 사용하여 찾아보십시오. 우리는 여전히 키 목록을 얻지 만 이번에는 키 값으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0a23be20e0afdc53dc3805694c934e04c1d63f" translate="yes" xml:space="preserve">
          <source>If we wanted to include the mp3's title in the greeting, we could override the method:</source>
          <target state="translated">인사말에 mp3의 제목을 포함하려면 다음 방법을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="215abf71d62aea6c4bacd7ab63842ca42cbc8d09" translate="yes" xml:space="preserve">
          <source>If we were interested in performance, not in code compactness, in the success branch we would not use &lt;code&gt;XPUSHs&lt;/code&gt; macros, but &lt;code&gt;PUSHs&lt;/code&gt; macros, and would pre-extend the stack before pushing the return values:</source>
          <target state="translated">우리가하지 코드 소형화에, 성능에 관심이 있다면, 성공 지점에서 우리는 사용하지 것이다 &lt;code&gt;XPUSHs&lt;/code&gt; 의 매크로하지만 &lt;code&gt;PUSHs&lt;/code&gt; 의 매크로 및 반환 값을 밀어 전에 스택을 미리 확장 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="65993e20767895a57d8f797f997352ddbf9ddad7" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">우리가 일을 제대로했다면, 이것을 서브 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;클래 싱&lt;/a&gt; 하는 것보다 새로운 소스를 작성하고 싶을 것입니다 ( 그에 대해서는 TAP :: Parser :: SourceHandler 참조 ).</target>
        </trans-unit>
        <trans-unit id="ed55ede23a733b9689b8f241805b425f9dc0c341" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">작업을 올바르게 수행했다면 하위 클래스를 작성하는 대신 새 소스를 작성하는 것이 좋습니다 ( &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="433a6e7876c97a91d0108a2079322b6917a252c6" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt; ), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">꺾쇠 괄호에 포함 된 내용이 간단한 스칼라 변수 (예 : &lt;code&gt;$foo&lt;/code&gt; ) 인 경우 해당 변수에는 입력 할 파일 핸들의 이름 또는 typeglob 또는 이에 대한 참조가 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6838a6ca305b32b023903f5887f6858a0601c74f" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt;), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">꺾쇠 괄호에 포함 된 것이 단순 스칼라 변수 (예 : &lt;code&gt;$foo&lt;/code&gt; ) 인 경우 해당 변수에는 입력 할 파일 핸들의 이름, 해당 typeglob 또는 동일한 참조가 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b51d046d4f4e47130f90dab13b7fc186caff6e3" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; , not &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">꺾쇠 괄호 안에있는 파일이 파일 핸들 이름, typeglob 또는 typeglob 참조를 포함하는 간단한 스칼라 변수가 아닌 경우, glob 할 파일 이름 패턴과 파일 이름 목록 또는 목록의 다음 파일 이름으로 해석됩니다. 상황에 따라 반환됩니다. 이 구별은 구문상의 근거에서만 결정됩니다. 즉, &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; 는 항상 간접 핸들 의 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; 이지만 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; 는 항상 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 입니다. 의 그 때문에 &lt;code&gt;$x&lt;/code&gt; 간단한 스칼라 변수이지만, &lt;code&gt;$hash{key}&lt;/code&gt; 아니다 - 그것은 해시 요소입니다. &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (추가 공간에 주목) 조차도 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; 로 취급됩니다 .아니 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6919e586a25966a42d5d004843760749c92f077" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;readline()&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;glob()&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt;, not &lt;code&gt;readline($x)&lt;/code&gt;.</source>
          <target state="translated">꺾쇠 괄호 안에있는 것이 파일 핸들이나 파일 핸들 이름, typeglob 또는 typeglob 참조를 포함하는 간단한 스칼라 변수가 아닌 경우, glob 될 파일 이름 패턴으로 해석되고 파일 이름 목록 또는 목록의 다음 파일 이름으로 해석됩니다. 컨텍스트에 따라 반환됩니다. 이 구별은 구문 적 근거만으로 결정됩니다. 즉, &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; 는 항상 간접 핸들 의 &lt;code&gt;readline()&lt;/code&gt; 이지만 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; 는 항상 &lt;code&gt;glob()&lt;/code&gt; 입니다. 의 그 때문에 &lt;code&gt;$x&lt;/code&gt; 간단한 스칼라 변수이지만, &lt;code&gt;$hash{key}&lt;/code&gt; 아니다 - 그것은 해시 요소입니다. 심지어 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (여분의 공간을 유의)로 처리됩니다 &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt; ,하지 &lt;code&gt;readline($x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b842d8a427447b55d56f0f86ffb1407d7bbf70b" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt; . The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">공백이 대부분 관련이없는 경우 확장 정규 표현식에 공백 문자가 어떻게 포함됩니까? 대답은 &lt;code&gt;'\ '&lt;/code&gt; 를 백 슬래시 하거나 문자 클래스 &lt;code&gt;[ ]&lt;/code&gt; 에 넣는 것입니다 . 파운드 기호도 마찬가지입니다 : use &lt;code&gt;\#&lt;/code&gt; 또는 &lt;code&gt;[#]&lt;/code&gt; . 예를 들어 Perl은 부호와 가수 또는 정수 사이에 공백을 허용하며 다음과 같이 정규 표현식에이를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea95fa4866be380e5de6f53e01cf2830a2660fd" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt;. The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">공백이 대부분 무관 한 경우 확장 정규식에 공백 문자를 어떻게 포함합니까? 대답은 &lt;code&gt;'\ '&lt;/code&gt; 를 백 슬래시 하거나 문자 클래스 &lt;code&gt;[ ]&lt;/code&gt; 에 넣는 것입니다 . 파운드 기호도 마찬가지입니다. &lt;code&gt;\#&lt;/code&gt; 또는 &lt;code&gt;[#]&lt;/code&gt; 을 사용하십시오 . 예를 들어 Perl은 부호와 가수 또는 정수 사이에 공백을 허용하며 다음과 같이 정규 표현식에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6171e2e12a8c60c3485d29916f7ac5529de6161" translate="yes" xml:space="preserve">
          <source>If writing a plugin is not enough, you can write your own test harness; one of the motives for the 3.00 rewrite of Test::Harness was to make it easier to subclass and extend.</source>
          <target state="translated">플러그인을 작성하는 것으로 충분하지 않은 경우 자체 테스트 하네스를 작성할 수 있습니다. Test :: Harness의 3.00 재 작성 동기 중 하나는 하위 클래스 및 확장을 더 쉽게 만드는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="0ac523288e8907db49cd44aeec42c46983d54f41" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="translated">만약 너라면</target>
        </trans-unit>
        <trans-unit id="a97a499d1638eac60812016983597e71f2e68467" translate="yes" xml:space="preserve">
          <source>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</source>
          <target state="translated">CPAN의 File :: Map 모듈을 사용하여 파일을 &quot;mmap&quot;하면 실제로 파일을 메모리에 저장하지 않고 전체 파일을 사실상 문자열로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc7d708aba8a01827e46990051f630f335a2e71" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt; 이제까지 당신의 아이들을 기다리지 않고, 당신은 좀비를 축적합니다. 일부 시스템에서는 &lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 로 설정하여이를 방지 할 수 있습니다 . &lt;a href=&quot;perlipc&quot;&gt;몹시 괴로운 아이들&lt;/a&gt; 을 갈고리 거두는 더 많은 예를 보려면 perlipc 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9fdf3b9fc81571db27bb02cd29a8e0b53b10cc5" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">당신이 경우 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 이제까지 당신의 아이들을 기다리지 않고, 당신은 좀비를 축적합니다. 일부 시스템에서는 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 를 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 로 설정하여이를 피할 수 있습니다 . 사나운 아이들을 포크하고 수확하는 더 많은 예 는 &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3342529f369584d116691354aca02d8a637cdc3f" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">당신이 경우 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 이제까지 당신의 아이들을 기다리지 않고, 당신은 좀비를 축적합니다. 일부 시스템에서는 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 를 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 로 설정하여이를 피할 수 있습니다 . 사나운 아이들을 포크하고 수확하는 더 많은 예 는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb90d14b290d4320ac5634dcbc5bece03b18182e" translate="yes" xml:space="preserve">
          <source>If you actually need to be able to get a real reference back from each hash entry, you can use the Tie::RefHash module, which does the required work for you.</source>
          <target state="translated">실제로 각 해시 항목에서 실제 참조를 다시 얻을 수 있어야하는 경우 필요한 작업을 수행하는 Tie :: RefHash 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0863c378529bcaaf05a08fbe7b9d62fcdd40f533" translate="yes" xml:space="preserve">
          <source>If you actually want to bless into the stringified version of the reference supplied, you need to stringify it yourself, for example by:</source>
          <target state="translated">제공된 참조의 문자열 버전을 실제로 축복하려면 다음과 같이 직접 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="7632fd79ddaeaed4fd83611844af65a8558ccb38" translate="yes" xml:space="preserve">
          <source>If you actually want to pack Unicode codepoints, use the &lt;code&gt;&quot;U&quot;&lt;/code&gt; format instead.</source>
          <target state="translated">실제로 유니 코드 코드 포인트를 압축하려면 대신 &lt;code&gt;&quot;U&quot;&lt;/code&gt; 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="30a06cdba55cf94e2b0d8887615268f65da700c2" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 스레드 선언에 &lt;code&gt;stringify&lt;/code&gt; 가져 오기 옵션을 추가하면 문자열 또는 문자열 컨텍스트 (예 : 해시 키)의 스레드 객체를 사용하면 해당 ID가 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="30adb136bf842fc19188bd6258e57dee7ddb8e9f" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;use threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">&lt;code&gt;use threads&lt;/code&gt; 선언에 &lt;code&gt;stringify&lt;/code&gt; 가져 오기 옵션을 추가하면 문자열 또는 문자열 컨텍스트 (예 : 해시 키)에서 스레드 객체를 사용하면 해당 ID가 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24defde4aa2bffa14e170e2d3b5990c2b9ad5b66" translate="yes" xml:space="preserve">
          <source>If you already have a Perl repository, you should ensure that you're on the</source>
          <target state="translated">이미 Perl 저장소가있는 경우</target>
        </trans-unit>
        <trans-unit id="77f0b688e7f7db776b8a41a0294b1be395b96046" translate="yes" xml:space="preserve">
          <source>If you already have the data in memory or if you want to keep your code simple, you can use one of the sv_cat*() variants, such as sv_catpvn(). If you want to insert anywhere in the string you can use sv_insert() or sv_insert_flags().</source>
          <target state="translated">메모리에 이미 데이터가 있거나 코드를 단순하게 유지하려는 경우 sv_catpvn ()과 같은 sv_cat * () 변형 중 하나를 사용할 수 있습니다. 문자열의 아무 곳에 나 삽입하려면 sv_insert () 또는 sv_insert_flags ()를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e6e027d69f3e21d5d8d4eaafdf5a18b7a271a0" translate="yes" xml:space="preserve">
          <source>If you also specify the &lt;code&gt;save&lt;/code&gt; option newly passing tests will be excluded from subsequent runs.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 옵션 도 지정하면 새로 통과 한 테스트는 후속 실행에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f2315b4f443374dc91536026901e2322007448a6" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">서브 루틴 (예 : &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ) 에서 @_ 인수를 변경 하면 스택 역 추적에 원래 값이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87b7e2c0f9e7bf47de8a9bd321c66e6de23241e4" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">서브 루틴에서 @_ 인수를 변경하면 (예 : &lt;code&gt;shift&lt;/code&gt; 또는 &lt;code&gt;pop&lt;/code&gt; 사용 ) 스택 역 추적에 원래 값이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5bf3485b53b1f2fcb4fdcf6bb2cccc1e74cefad" translate="yes" xml:space="preserve">
          <source>If you are a committer to Perl and you think the patch is good, you can then merge it into blead then push it out to the main repository:</source>
          <target state="translated">Perl의 커미터이고 패치가 좋다고 생각한다면 blead에 병합 한 다음 메인 저장소로 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcce70763746b8ab89abce0fda8214efc82356bb" translate="yes" xml:space="preserve">
          <source>If you are accustomed to using perl from various command-line shells found in UNIX environments, you will be less than pleased with what Windows offers by way of a command shell.</source>
          <target state="translated">UNIX 환경에있는 다양한 명령 줄 셸에서 perl을 사용하는 데 익숙하다면 Windows가 명령 셸을 통해 제공하는 것에 만족하지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="75851b1a6055f8c9601d27bb8e4f2638f62e5f5e" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt; . Try to keep your PATH enviromental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">C 코드 작성으로 충분히 발전했다면 다음과 같이 perl 작성 속도를 높이고 나중에 &lt;code&gt;make test&lt;/code&gt; . 가능한 최소한의 폴더로 PATH 환경 변수를 유지하십시오 (C 컴파일러의 폴더를 거기에 보관하십시오). OS 버전에 따라 &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; 또는 &lt;code&gt;C:\WINNT\system32&lt;/code&gt; 는 PATH의 첫 번째 폴더 여야합니다. &quot;cmd.exe&quot;는 빌드 및 이후 테스트 중에 가장 일반적으로 실행되는 프로그램이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="04da8dab27ca1a90f04cb94a9ccc32581630ed82" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt;. Try to keep your PATH environmental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">C 코드 빌드에 능숙하다면 여기에 perl 빌드 속도를 높이기위한 제안이 있고 나중에 &lt;code&gt;make test&lt;/code&gt; 합니다. 가능한 최소한의 폴더로 PATH 환경 변수를 유지하십시오 (C 컴파일러의 폴더를 거기에 유지하는 것을 기억하십시오). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; 또는 &lt;code&gt;C:\WINNT\system32&lt;/code&gt; 는 OS 버전에 따라 PATH의 첫 번째 폴더 여야합니다. &quot;cmd.exe&quot;는 빌드 및 이후 테스트 중에 가장 일반적으로 실행되는 프로그램이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9e6e47c6af55350e3bd275924a9467fa5be92cb6" translate="yes" xml:space="preserve">
          <source>If you are author of a package and wonder if your $VERSION can be parsed, please try the above method.</source>
          <target state="translated">패키지를 작성하고 $ VERSION을 파싱 할 수 있는지 궁금하다면 위의 방법을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="e9341f5fe0aca50dc1a438efa6a2a0829ec331a7" translate="yes" xml:space="preserve">
          <source>If you are building Perl from source, the Perl test suite file</source>
          <target state="translated">소스에서 Perl을 빌드하는 경우 Perl 테스트 스위트 파일</target>
        </trans-unit>
        <trans-unit id="fd709122178ec9749d3b052901d53a7e7c059f96" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;b&gt;pod2usage()&lt;/b&gt; from a module and want to display that module's POD, you can use this:</source>
          <target state="translated">모듈에서 &lt;b&gt;pod2usage ()&lt;/b&gt; 를 호출 하고 해당 모듈의 POD를 표시하려는 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b3eed9ee23b3eafd899b21c185d1c6a6521682" translate="yes" xml:space="preserve">
          <source>If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:</source>
          <target state="translated">주의를 기울이면 동일한 코드에서 API 호출을 연결된 해시 / 배열 인터페이스와 혼합 할 수 있습니다. 연결된 인터페이스를 구현하는 데 사용되는 몇 가지 메서드 만 현재 커서를 사용하지만 연결된 해시 / 배열 인터페이스를 사용할 때마다 커서가 변경되었다고 가정해야합니다. 예를 들어,이 코드는 예상 한대로 수행하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f310b0eef5419b5aba99dec1af26f1763cc1c050" translate="yes" xml:space="preserve">
          <source>If you are certain that you want a different tool to use the same context you may pass it a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">다른 도구가 동일한 컨텍스트를 사용하도록하려면 스냅 샷을 전달할 수 있습니다. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; 은 전달하거나 저장하기에 안전한 컨텍스트의 얕은 복제본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e316a557a29cf6095279d19d99c5e2d5b583af0" translate="yes" xml:space="preserve">
          <source>If you are certain that you want to save the context for later, you can use a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">나중에 사용할 수 있도록 컨텍스트를 저장하려는 경우 스냅 샷을 사용할 수 있습니다. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; 은 전달하거나 저장하기에 안전한 컨텍스트의 얕은 복제본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46443ee64846124969f99d9a251a1b5c33defa28" translate="yes" xml:space="preserve">
          <source>If you are coming here because code of yours is being adversely affected by someone's use of this variable, you can usually work around it by doing this:</source>
          <target state="translated">귀하의 코드가 누군가 가이 변수를 사용하여 악영향을 받아 여기에 오는 경우 일반적으로 다음을 수행하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580a992ac4c85198002e3da1ab0af0114ef2843d" translate="yes" xml:space="preserve">
          <source>If you are compiling Perl on a remotely-mounted NFS filesystem, the test io/fs.t may fail on test #18. This appears to be a bug in HP-UX and no fix is currently available.</source>
          <target state="translated">원격으로 마운트 된 NFS 파일 시스템에서 Perl을 컴파일하는 경우 테스트 # 18에서 테스트 io / fs.t가 실패 할 수 있습니다. HP-UX의 버그로 보이며 현재 사용할 수있는 수정 프로그램이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b33c19354a1a90e2387b434d12153c90f20f627" translate="yes" xml:space="preserve">
          <source>If you are compiling in PASE, then &quot;make install&quot; is the only thing you will need to do.</source>
          <target state="translated">PASE로 컴파일하는 경우 &quot;make install&quot;만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="81413ae9ed04e602e1a5e2aa34f9a9228c164afc" translate="yes" xml:space="preserve">
          <source>If you are compiling on AIX, simply do a &quot;make install&quot; on the AIX box. Once the install finishes, tar up the /QOpenSys/perl directory. Transfer the tarball to the OS/400 using FTP with the following commands:</source>
          <target state="translated">AIX에서 컴파일하는 경우 AIX 상자에서 &quot;make install&quot;을 수행하십시오. 설치가 완료되면 / QOpenSys / perl 디렉토리를 압축 해제하십시오. 다음 명령으로 FTP를 사용하여 tarball을 OS / 400으로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="633f40501c71cc3d9b9dd021b947e0958a8636a6" translate="yes" xml:space="preserve">
          <source>If you are confident that all byte-strings will be in a specific encoding like UTF-8,</source>
          <target state="translated">모든 바이트 문자열이 UTF-8과 같은 특정 인코딩으로되어 있다고 확신한다면,</target>
        </trans-unit>
        <trans-unit id="24c32dcfc58ac17c09099d20bc9bc3a8e41bba8b" translate="yes" xml:space="preserve">
          <source>If you are content with the test result, just &quot;make install&quot;</source>
          <target state="translated">테스트 결과에 만족하는 경우 &quot;make install&quot;</target>
        </trans-unit>
        <trans-unit id="aa6a61423fd16b04dc17486be56b73db7a8c3506" translate="yes" xml:space="preserve">
          <source>If you are creating a PerlIO layer, you may want to be lazy, in other words, implement only the methods that interest you. The other methods you can either replace with the &quot;blank&quot; methods</source>
          <target state="translated">PerlIO 계층을 작성하는 경우 게으 르기를 원할 수 있습니다. 즉, 관심있는 메소드 만 구현하십시오. &quot;빈&quot;방법으로 대체 할 수있는 다른 방법</target>
        </trans-unit>
        <trans-unit id="602ef84230a9a9bbabefd6f60652a28db56ddfcd" translate="yes" xml:space="preserve">
          <source>If you are creating a Zip file using the one-shot interface, and any of the input files is greater than 4Gig, a zip64 complaint zip file will be created.</source>
          <target state="translated">원샷 인터페이스를 사용하여 Zip 파일을 생성하고 입력 파일이 4Gig보다 큰 경우 zip64 불만 zip 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2de75d9b2a463fc1f9325a0ae503a9f6861718" translate="yes" xml:space="preserve">
          <source>If you are developing a suite of related modules/classes it's good practice to use nested classes with a common prefix as this will avoid namespace clashes. For example: Xyz::Control, Xyz::View, Xyz::Model etc. Use the modules in this list as a naming guide.</source>
          <target state="translated">관련 모듈 / 클래스 제품군을 개발하는 경우 네임 스페이스 충돌을 피하기 위해 공통 접두사가있는 중첩 클래스를 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다. Xyz :: Control, Xyz :: View, Xyz :: Model 등이 목록의 모듈을 이름 지정 안내서로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cf3f54058ec5c3861eafa70f589fb5c16feca4d3" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">당신은 차단하고 있다면 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; , 당신은 알람 핸들러 (참조 제한 시간을 제공하기 위해 준비해야 &lt;a href=&quot;functions/alarm&quot;&gt;알람&lt;/a&gt; ). 비 차단 열기가있는 경우 비 차단 읽기가있을 수 있습니다. 즉, 4 개의 인수 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 장치에서 I / O가 준비되어 있는지 확인해야합니다 ( &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="a3262a8838df2cab768e5f0aeb8b39d02c8c5bb9" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;sysread()&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;perlfunc#alarm&quot;&gt;&quot;alarm&quot; in perlfunc&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;select()&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">블로킹 &lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;sysread()&lt;/code&gt; 를 수행하는 경우 시간 제한을 제공하도록 알람 핸들러를 조정해야합니다 ( &lt;a href=&quot;perlfunc#alarm&quot;&gt;perlfunc의 &quot;alarm&quot;&lt;/a&gt; 참조 ). non-blocking open이있는 경우 non-blocking 읽기 가 가능합니다. 즉, 해당 장치에서 I / O가 준비되었는지 확인 &lt;code&gt;select()&lt;/code&gt; 4-arg select () 를 사용해야 할 수 있습니다 ( &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot;&lt;/a&gt; 참조). perlfunc에서 .</target>
        </trans-unit>
        <trans-unit id="ec0d9c19ee9bcc3793bd395f6bcc7da295d90db4" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">여러 페이지와 양식 또는 웹 사이트를 이동하는 것과 같이 복잡한 작업을 수행하는 경우 &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW :: Mechanize를&lt;/a&gt; 사용할 수 있습니다 . 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27eb5f2751e7b3c976fa3693eb1b047c9ea468b5" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">많은 페이지와 양식 또는 웹 사이트를 이동하는 등 복잡한 작업을 수행하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize를&lt;/a&gt; 사용할 수 있습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1a9b4d7923308acf7ee68c13a2cd11f90f3c70ce" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt; . The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">당신이 변수 자살이 발생하는 경우, 것을 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; 서브 루틴은의 새 복사본 선택하지 않는 &lt;code&gt;$f&lt;/code&gt; 값 &lt;code&gt;'foo'&lt;/code&gt; . 출력은 서브 루틴 내부에서 &lt;code&gt;$f&lt;/code&gt; 값 이이 출력에서와 같이해서는 안될 때 누출되는 것을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="90ffffc1c986cd8a0326c90c4ba333b4ce6ffe43" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;my $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt;. The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">당신이 변수 자살이 발생하는 경우, 것을 &lt;code&gt;my $f&lt;/code&gt; 서브 루틴은의 새 복사본 선택하지 않는 &lt;code&gt;$f&lt;/code&gt; 값 &lt;code&gt;'foo'&lt;/code&gt; . 출력은 다음 출력에서와 같이 서브 루틴 내부에서 &lt;code&gt;$f&lt;/code&gt; 값이 누출되지 않아야 할 때 누출 됨을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bbeae6d94c0568a9909c55582ce46133df1b3000" translate="yes" xml:space="preserve">
          <source>If you are familiar with the</source>
          <target state="translated">당신이 익숙한 경우</target>
        </trans-unit>
        <trans-unit id="09b5540260d1429f031cae6d4fea34d1c0219ed0" translate="yes" xml:space="preserve">
          <source>If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</source>
          <target state="translated">모든 임시 파일을 생성하는 많은 프로세스를 병렬로 포크하는 경우 각 자식에서 srand (EXPR)를 사용하여 난수 시드를 재설정해야합니다. 그렇지 않으면 모든 자식이 동일한 임의의 파일 이름 세트를 탐색하려고 시도 할 수 있습니다. 재시도 횟수를 초과하면 포기할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79eaecd3ef824520bc14f0a6f551bc580fb007f0" translate="yes" xml:space="preserve">
          <source>If you are going to convert the script to a module you can use the opportunity to redesign the interface. The guidelines for module creation above include many of the issues you should consider.</source>
          <target state="translated">스크립트를 모듈로 변환하려는 경우 기회를 사용하여 인터페이스를 다시 디자인 할 수 있습니다. 위의 모듈 생성 지침에는 고려해야 할 많은 문제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c8864889db08a398c2a1fd61fb5557dd86b1b1" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt; --it declares and initializes a</source>
          <target state="translated">Perl 스택에 무언가를 넣으려면 어디에 놓아야하는지 알아야합니다. 이것은 매크로 &lt;code&gt;dSP&lt;/code&gt; 의 목적입니다. 선언하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="537495a37e599c942d74bd5d8aca0155b4da8202" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt;--it declares and initializes a</source>
          <target state="translated">Perl 스택에 무언가를 놓으려면 어디에 놓을 지 알아야합니다. 이것이 매크로 &lt;code&gt;dSP&lt;/code&gt; 의 목적입니다 .</target>
        </trans-unit>
        <trans-unit id="0cf3f133791811ca9201975358ebf1e226d3c50a" translate="yes" xml:space="preserve">
          <source>If you are going to use the HP DCE package, the library used for threading is /usr/lib/libcma.sl, but there have been multiple updates of that library over time. Perl will build with the first version, but it will not pass the test suite. Older Oracle versions might be a compelling reason not to update that library, otherwise please find a newer version in one of the following patches: PHSS_19739, PHSS_20608, or PHSS_23672</source>
          <target state="translated">HP DCE 패키지를 사용하려는 경우 스레딩에 사용되는 라이브러리는 /usr/lib/libcma.sl이지만 시간이 지남에 따라 해당 라이브러리가 여러 번 업데이트되었습니다. Perl은 첫 번째 버전으로 빌드되지만 테스트 스위트를 통과하지는 않습니다. 이전 Oracle 버전은 해당 라이브러리를 업데이트하지 않는 강력한 이유 일 수 있습니다. 그렇지 않으면 PHSS_19739, PHSS_20608 또는 PHSS_23672 패치 중 하나에서 최신 버전을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="330882464199f1a0851acc4b79e3a966cdc91c15" translate="yes" xml:space="preserve">
          <source>If you are going to use this method you have to be aware of a possible memory leak which can arise under very specific circumstances. To explain these circumstances you need to know a bit about the flow of control between Perl and the callback routine.</source>
          <target state="translated">이 방법을 사용하려면 매우 특정한 상황에서 발생할 수있는 메모리 누수를 알고 있어야합니다. 이러한 상황을 설명하려면 Perl과 콜백 루틴 사이의 제어 흐름에 대해 약간 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="91073f8278c247bf05c5742a59e2d0906bf12cbd" translate="yes" xml:space="preserve">
          <source>If you are going to write a platform specific MM package, please try to limit the necessary overrides to primitive methods, and if it is not possible to do so, let's work out how to achieve that gain.</source>
          <target state="translated">플랫폼 별 MM 패키지를 작성하려는 경우 필요한 재정의를 기본 방법으로 제한하고 그렇게 할 수없는 경우 해당 이익을 달성하는 방법을 알아 봅시다.</target>
        </trans-unit>
        <trans-unit id="3470649433d76902fec9be392ea404a581213006" translate="yes" xml:space="preserve">
          <source>If you are having trouble with square brackets then consider switching your rlogin or telnet client. Try to avoid older 3270 emulators and ISHELL for working with Perl on USS.</source>
          <target state="translated">대괄호에 문제가있는 경우 rlogin 또는 telnet 클라이언트 전환을 고려하십시오. USS에서 Perl과 함께 작업 할 때 구형 3270 에뮬레이터와 ISHELL을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="fb193e3267912e83638916e973e0dcc8b120aead" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt; for details.</source>
          <target state="translated">라이센스 상황에 대해 의문이있는 경우 Berkeley DB 작성자 또는 DB_File 작성자에게 문의하십시오. 자세한 내용은 &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be777d0c50e7b77da7283f3ff8a7e540b7f7344c" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details.</source>
          <target state="translated">라이센스 상황이 확실하지 않은 경우 Berkeley DB 작성자 또는 DB_File 작성자에게 문의하십시오. 자세한 내용은 &lt;a href=&quot;#AUTHOR&quot;&gt;저자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99320978b9537887ebc85e1dfd4bdf0910cbc812" translate="yes" xml:space="preserve">
          <source>If you are in doubt which package contains a file you are missing, try to find an installation that has that file. Then do a</source>
          <target state="translated">누락 된 파일이 들어있는 패키지가 확실하지 않은 경우 해당 파일이있는 설치를 찾으십시오. 그런 다음</target>
        </trans-unit>
        <trans-unit id="92276bc0e44e1b658a5288e18f73cfbd284b63bb" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt; , as in the examples below.</source>
          <target state="translated">비트 스트링을 조작하려는 경우 비트 스트링을 제공하고 있는지 확인하십시오. 피연산자가 &lt;b&gt;숫자 인&lt;/b&gt; 경우 &lt;b&gt;숫자&lt;/b&gt; 비트 연산을 의미 합니다. 아래 예와 같이 &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;0+&lt;/code&gt; 를 사용하여 원하는 작업 유형을 명시 적으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2877e8cae4b72c189b80caef94210456b80f06da" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt;, as in the examples below.</source>
          <target state="translated">비트 문자열을 조작하려는 경우 비트 문자열을 제공하고 있는지 확인하십시오. 피연산자가 숫자이면 &lt;b&gt;숫자&lt;/b&gt; 비트 연산을 의미 합니다. 아래 예에서와 같이 &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;0+&lt;/code&gt; 를 사용하여 의도 한 작업 유형을 명시 적으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0e74d8ccd8d67f221dc38d69397982438ef8887" translate="yes" xml:space="preserve">
          <source>If you are interested in the guts underlying these systems, check out &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">이 시스템의 기본 내장에 관심이 있으시면 &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f81bce975381ffe867c89af365021d38913e30eb" translate="yes" xml:space="preserve">
          <source>If you are interested in the z/OS (formerly known as OS/390) and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list. To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</source>
          <target state="translated">Perl의 z / OS (이전의 OS / 390) 및 POSIX-BC (BS2000) 포트에 관심이 있으면 perl-mvs 메일 링리스트를 참조하십시오. 가입하려면 빈 메시지를 perl-mvs-subscribe@perl.org로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="81e9b341887276c07ed78e971fe73fb2fe685324" translate="yes" xml:space="preserve">
          <source>If you are interested in writing new tools you should take a look at &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; first.</source>
          <target state="translated">새로운 도구를 작성하는 데 관심이 있다면 먼저 &lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API를&lt;/a&gt; 살펴 봐야 합니다.</target>
        </trans-unit>
        <trans-unit id="18b06deb07c89c9dfd8a2b96ce84d618599bef3b" translate="yes" xml:space="preserve">
          <source>If you are interested in writing tests using new tools then you should look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; is a separate cpan distribution that contains many tools implemented on Test2.</source>
          <target state="translated">새로운 도구를 사용하여 테스트를 작성하는 데 관심이 있다면 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite를&lt;/a&gt; 살펴 봐야 합니다. &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt; 는 Test2에서 구현 된 많은 도구를 포함하는 별도의 cpan 배포판입니다.</target>
        </trans-unit>
        <trans-unit id="38d9bbb97bd39f15f79a0ad6f3bd53d77bb54ef1" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use look-behind instead (see below).</source>
          <target state="translated">앞에 &quot;foo&quot;가없는 &quot;bar&quot;를 찾는 경우 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; 는 원하는 작업을 수행하지 않습니다. 그 이유는 &lt;code&gt;(?!foo)&lt;/code&gt; 는 다음 것은 &quot;foo&quot;가 될 수 없다고 말하고 있기 때문입니다. 그렇지 않은 경우 &quot;bar&quot;이므로 &quot;foobar&quot;가 일치합니다. 대신 look-behind를 사용하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="f7b2a50928124f0618a8144a8e1baa9cc8e568eb" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use lookbehind instead (see below).</source>
          <target state="translated">앞에 &quot;foo&quot;가없는 &quot;bar&quot;를 찾고 있다면 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; 는 원하는 작업을 수행하지 않습니다. 그 이유는 &lt;code&gt;(?!foo)&lt;/code&gt; 가 다음 항목이 &quot;foo&quot;가 될 수 없다고 말하고 있기 때문입니다. 그렇지 않고 &quot;bar&quot;이므로 &quot;foobar&quot;가 일치합니다. 대신 lookbehind를 사용하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="dc60d35f80efdd879c9aa94cc9f2ee7ad195384c" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you that you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">자신이 정의하지 않은 모든 것을 수행하는 클래스를 찾고 있다면 &lt;code&gt;Tie::Scalar&lt;/code&gt; 클래스가 아닌 &lt;code&gt;Tie::StdScalar&lt;/code&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f20427718038bfba8c53137f8646eb9abfc2ff46" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">스스로 정의하지 않은 모든 것을 수행하는 클래스를 찾고 있다면 &lt;code&gt;Tie::Scalar&lt;/code&gt; 클래스가 아닌 &lt;code&gt;Tie::StdScalar&lt;/code&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7787fb3feb00a627232c8ef4ce3954c9d7deed73" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">Perl 라이브러리 모듈 문서의 목차를 찾으 &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;려면 perltoc&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40f5e81161933568c426f178117fbe0b2c9f0084" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">Perl 라이브러리 모듈 문서의 목차를 찾고 있다면 &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fac826063cfc00ef4ae02f7626b0848d723ad5d" translate="yes" xml:space="preserve">
          <source>If you are looking for an example, I recommend that you look at the simple example in the Memoize::Expire documentation, or at the code for Memoize::Expire itself.</source>
          <target state="translated">예제를 찾고 있다면 Memoize :: Expire 문서 또는 Memoize :: Expire 자체의 코드에서 간단한 예제를 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01bb70148d15624f6da074182f77ad2f0eee86c6" translate="yes" xml:space="preserve">
          <source>If you are looking for helpers with &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;like&lt;/code&gt;, and others, see &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; , &lt;code&gt;like&lt;/code&gt; 및 기타 를 사용하는 도우미를 찾고 있다면 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b33652a525614ae7d89321a43fb11331d7e5b6fa" translate="yes" xml:space="preserve">
          <source>If you are making use of the Perl stack pointer in your code you must always refresh the local copy using SPAGAIN whenever you make use of the</source>
          <target state="translated">코드에서 Perl 스택 포인터를 사용하는 경우 SPAGAIN을 사용하여 로컬 복사본을 새로 고쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="31bb9506f4ff23e6db70b0b08455755a7de18605" translate="yes" xml:space="preserve">
          <source>If you are not using threads, forking, or IPC then the only difference between a &lt;code&gt;filter&lt;/code&gt; and a &lt;code&gt;pre_filter&lt;/code&gt; is that &lt;code&gt;pre_filter&lt;/code&gt; subs run first. When you are using threads, forking, or IPC, pre_filters happen to events before they are sent to their destination proc/thread, ordinary filters happen only in the destination hub/thread.</source>
          <target state="translated">스레드, 분기 또는 IPC를 사용하지 않는 경우 &lt;code&gt;filter&lt;/code&gt; 와 &lt;code&gt;pre_filter&lt;/code&gt; 의 유일한 차이점은 &lt;code&gt;pre_filter&lt;/code&gt; subs가 먼저 실행 된다는 것 입니다. 스레드, 분기 또는 IPC를 사용하는 경우 pre_filters는 이벤트가 대상 proc / thread로 전송되기 전에 발생하고 일반 필터는 대상 허브 / 스레드에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0468c5bae6319f4655b5720508b9d190b598ea2a" translate="yes" xml:space="preserve">
          <source>If you are on a Unix-like system, you might be able to get away with a system call where you put an &lt;code&gt;&amp;amp;&lt;/code&gt; on the end of the command:</source>
          <target state="translated">유닉스 계열 시스템을 사용하는 경우 명령 끝에 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 입력하면 시스템 호출을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74fb92ccab7935bd1e0cc2c8300a7bef29eb75de" translate="yes" xml:space="preserve">
          <source>If you are on a non-UNIX platform &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, as some features may be unimplemented or work differently.</source>
          <target state="translated">비 UNIX 플랫폼 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 에있는 경우 일부 기능이 구현되지 않거나 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f59ff52a71652ecb89231c85ecae2ce17688eb9" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 을 올바르게 구현하는 시스템에 있고 &quot;perldoc -f flock&quot;의 코드를 추가하는 예제를 사용하는 경우 사용중인 OS가 추가 모드를 올바르게 구현하지 않아도 (모든 시스템이있는 경우) 모든 것이 정상입니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 를 구현하는 OS로 자신을 제한하고 싶다면 (그다지 제한되지는 않습니다) 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="775ac36d1065d528736d6584503c5960de9afca8" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;flock&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;flock&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; 을 올바르게 구현하는 시스템에 있고 &quot;perldoc -f flock&quot;의 코드를 추가하는 예제를 사용하는 경우 사용중인 OS가 추가 모드를 올바르게 구현하지 않더라도 (해당 시스템이있는 경우) 모든 것이 정상입니다. 따라서 &lt;code&gt;flock&lt;/code&gt; 를 구현하는 OS로 자신을 제한하는 것이 기쁘다면 (그것이 실제로 제한이 아닙니다) 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="54d7fa3e38420fc843370b116c9be081ea5603e0" translate="yes" xml:space="preserve">
          <source>If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</source>
          <target state="translated">함수 이름 만 내보내는 경우 구현 속도가 빠르므로 앰퍼샌드를 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2de91fd61e5dabce87e62b432c1af2d2e0384486" translate="yes" xml:space="preserve">
          <source>If you are overriding any of these methods in your Makefile.PL (in the MY class), please report that to the makemaker mailing list. We are trying to minimize the necessary method overrides and switch to data driven Makefile.PLs wherever possible. In the long run less methods will be overridable via the MY class.</source>
          <target state="translated">MY 클래스의 Makefile.PL에서 이러한 메소드를 재정의하는 경우 해당 메소드를 makemaker 메일 링리스트에보고하십시오. 필요한 메소드 재정의를 최소화하고 가능한 경우 데이터 구동 Makefile.PL로 전환하려고합니다. 장기적으로는 MY 클래스를 통해 더 적은 메서드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25095e5b9b6ab11015f95ba50809b8be1a58758d" translate="yes" xml:space="preserve">
          <source>If you are particularly interested in customizing this module's output even more, see the source and/or write to me.</source>
          <target state="translated">특히이 모듈의 출력을 사용자 정의하는 데 관심이 있으시면 소스를 참조하거나 저에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="d40865e3f4f814dc75edbc20fbc8762037c6c824" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , you should use the following macros for portability</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; 와 같은 stdio (3) 스타일 형식화 코드 대신 IV, UV 또는 NVS를 인쇄하는 경우 이식성을 위해 다음 매크로를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="367b87e5b6a685cdb2627b032e60c907e2607076" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%ld&lt;/code&gt;, &lt;code&gt;%f&lt;/code&gt;, you should use the following macros for portability</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; 와 같은 stdio (3) 스타일 형식화 코드 대신 IV, UV 또는 NVS를 인쇄하는 경우 이식성을 위해 다음 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6da5a3aba0348fe8e8ae52d62d3e9bfb01a53b73" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use %p or UVxf combined with PTR2UV().</source>
          <target state="translated">포인터의 주소를 인쇄하는 경우 PTR2UV ()와 결합 된 % p 또는 UVxf를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b082a380f246d61dd682cd511f2ea77809e32735" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use UVxf combined with PTR2UV(), do not use %lx or %p.</source>
          <target state="translated">포인터의 주소를 인쇄하는 경우 PTR2UV ()와 함께 UVxf를 사용하고 % lx 또는 % p를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b6f4ed221243b9dde4f0f2cc29b067e485bbf822" translate="yes" xml:space="preserve">
          <source>If you are reading this documentation, looking for a replacement for the &lt;code&gt;FileHandle&lt;/code&gt; package, then I suggest you read the documentation for &lt;code&gt;IO::File&lt;/code&gt; too.</source>
          <target state="translated">이 문서를 읽고 &lt;code&gt;FileHandle&lt;/code&gt; 패키지 의 대체물을 찾고 있다면 &lt;code&gt;IO::File&lt;/code&gt; 대한 문서도 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8c40246fed4e0a31f96c46a72d0a85e56bbe29c3" translate="yes" xml:space="preserve">
          <source>If you are reading this in the future then it's possible that the state of the art has changed. We recommend you start by reading the perlootut document in the latest stable release of Perl, rather than this version.</source>
          <target state="translated">미래에 이것을 읽으면 최신 기술이 변경되었을 수 있습니다. 이 버전이 아닌 Perl의 최신 안정 릴리스에서 perlootut 문서를 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0add6c557074aa94dbce442362b0e5da76c5396" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Compress :: Bzip2에서 리턴 된 오브젝트 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어 압축 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e4df4e4f27db0bf9a46e2a1941e85758d61068" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Compress :: Deflate에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어 압축 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e65ffc69fed189ecd525fba0988f92db4e7035" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Compress :: Gzip에서 리턴 된 오브젝트 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어 압축 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b6ef257ae9881b6bd3fd8eaa22b1a4c05c99ca" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Compress :: RawDeflate에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어 압축 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c423a94c7fc5cb61812044d70c6c094354f683a" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Compress :: Zip에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어 압축 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fea5722273a1695c99b2d6f3f73bb1257cd24c3" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: AnyInflate에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b2972d5cdbb1eb98b989631b3ded397e40e59e75" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: AnyUncompress에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="18aa1921698d337e93a7e4edaa2b66e95de457bf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: Bunzip2에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f86eb994b5def7f39f87b382b570ded31372309e" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: Gunzip에서 리턴 된 오브젝트 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="05ab40d4db9fa577fb79380b48870abe52f5c6be" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: Inflate에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d70a4ecbd7bb1c964123dba102fe8a49b561cb00" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: RawInflate에서 리턴 된 오브젝트 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3608890b582bffd465c544ac9e831ad2b06501a0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행중인 경우 IO :: Uncompress :: Unzip에서 리턴 된 &lt;code&gt;$z&lt;/code&gt; 오브젝트 는 &lt;a href=&quot;../file&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 동일하게 사용할 수 있습니다 . 이는 모든 일반 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 파일 / 버퍼에서 행을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c3f55f8a5aa9143947c1b03103f8fcb1230f8026" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Compress :: Bzip2에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c943ecc09f7906641ce0c8c9195f36b53b0da84" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Compress :: Deflate에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0d2de3cb6af8e02dfa388bc8385e1f9fef63232" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Compress :: Gzip에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f19394fb5dae0da1468d85a7077d6de961381d1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Compress :: RawDeflate에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8705529210f30abadfa2690a88a8e55709062caf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Compress :: Zip에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 출력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에 쓰려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8dcbb9c89b754c497d19b04a16a87cbcd0b450" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: AnyInflate에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc295bba8742677124dc7e9dbafd6bdce18ea43" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: AnyUncompress에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04020399fea242c9c0dc69403e3ea87fc90e780" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: Bunzip2에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8386c862fdf7a36268d1e2d11759b36cc61a052" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: Gunzip에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e228b2a0d2a2705757b5a03c01b16b81052402f0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: Inflate에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="250328bb572e14771a91f743881702e8168f7ce1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: RawInflate에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac7ddace8a1bf7c76549d07abf22fa8e8e550364" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005 이상을 실행하는 경우 IO :: Uncompress :: Unzip에서 반환 된 개체 &lt;code&gt;$z&lt;/code&gt; 는 &lt;a href=&quot;IO::File&quot;&gt;IO :: File 파일&lt;/a&gt; 핸들 과 똑같이 사용할 수 있습니다 . 이는 모든 정상적인 입력 파일 작업이 &lt;code&gt;$z&lt;/code&gt; 로 수행 될 수 있음을 의미합니다 . 예를 들어, 압축 된 파일 / 버퍼에서 한 줄을 읽으려면 다음 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f53b731da5c3618fcf6d87c9434da7f9ed2f65" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.6.0 이상을 실행중인 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma를 통해 생성되는 경고를 세부적으로 제어 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3a447e1361d79aaa9ee74688b52a31d693ae7e5" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;use warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.6.0 이상을 실행중인 경우 &lt;code&gt;use warnings&lt;/code&gt; pragma를 사용하면 생성되는 경고를 세부적으로 제어 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af8514c8e63d77882efdff2789324ce75a2c20f4" translate="yes" xml:space="preserve">
          <source>If you are running VOS Release 14.4.1 or later, you can obtain a pre-compiled, supported copy of perl by purchasing the GNU Tools product from Stratus Technologies.</source>
          <target state="translated">VOS 릴리스 14.4.1 이상을 실행중인 경우 Stratus Technologies에서 GNU Tools 제품을 구입하여 사전 컴파일되고 지원되는 perl 사본을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90113b08f2e5803b4f4fa9119cc6038c86b7bb42" translate="yes" xml:space="preserve">
          <source>If you are running a Unix derivative this value defaults to</source>
          <target state="translated">Unix 파생 상품을 실행중인 경우이 값의 기본값은</target>
        </trans-unit>
        <trans-unit id="9cc43bdd9e8f39cf93edce0474ecd12686e0c219" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at &lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils::Embed&lt;/a&gt; which is a collection of utilities for embedding.</source>
          <target state="translated">perl을 다른 응용 프로그램에 라이브러리로 포함하는 실험을 실행하는 경우 MakeMaker가 충분하지 않을 수 있습니다. 임베딩을위한 유틸리티 모음 인 &lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils :: Embed&lt;/a&gt; 를 살펴 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ae421a254aed7ffd059cb6be52110578a85cd308" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at ExtUtils::Embed which is a collection of utilities for embedding.</source>
          <target state="translated">Perl을 라이브러리로 다른 응용 프로그램에 포함하여 실험을 실행하는 경우 MakeMaker가 충분하지 않을 수 있습니다. 임베드를위한 ​​유틸리티 모음 인 ExtUtils :: Embed를 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="743cbf656ee357233b7747fd85635a26f54ae749" translate="yes" xml:space="preserve">
          <source>If you are running the tests from a emacs shell window, you may see failures in op/stat.t. Run &quot;dmake test-notty&quot; in that case.</source>
          <target state="translated">emacs 쉘 ​​창에서 테스트를 실행중인 경우 op / stat.t에 실패가 표시 될 수 있습니다. 이 경우 &quot;dmake test-notty&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="eb661707e45d0fa6207ff65030fca0e35ac953eb" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">당신이에서 실행중인 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (? 당신이하지 않은 경우, 왜 세상에서 당신이 아닌), 당신은 행복하게하는 몇 가지 선언을 추가해야합니다 :</target>
        </trans-unit>
        <trans-unit id="0cc4f2e6ac843fbaf8224a05183a7220196cd15a" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;use strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; 하에서 실행중인 경우 (그렇지 않은 경우 왜 세상에 있지 않습니까?) 행복하게 만들기 위해 몇 가지 선언을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="767de91007776d2ff4bd67fc3c5e04ab7cebdfa3" translate="yes" xml:space="preserve">
          <source>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</source>
          <target state="translated">배열을 인쇄 할 때 배열의 요소 사이에 공백이 있으면 배열을 큰 따옴표로 보간하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="094ee1dd3418e11cdcfc777d87840149f066679d" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">이전 Perls를 사용하는 경우 &lt;a href=&quot;Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt; 모듈로 &lt;a href=&quot;Unicode::Map8&quot;&gt;유니 코드&lt;/a&gt; 를 수행하고 Unicode :: Map8 및 &lt;a href=&quot;Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt; 모듈을 사용하여 문자 변환을 수행 할 수 있습니다 . 일본어 인코딩을 사용하는 경우 jperl 5.005_03을 사용해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16bb00dc57c212c5f89aeced92e2138d70407e36" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">이전 Perls를 사용하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt; 모듈로 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;유니 코드&lt;/a&gt; 를 수행하고 Unicode :: Map8 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt; 모듈을 사용하여 문자를 변환 할 수 있습니다 . 일본어 인코딩을 사용하는 경우 jperl 5.005_03을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="a4539f5703f218245f234df49c0b9e75bd10857f" translate="yes" xml:space="preserve">
          <source>If you are submitting a code patch there are several things that you can do to help the Perl 5 Porters accept your patch.</source>
          <target state="translated">코드 패치를 제출하는 경우 Perl 5 Porter가 패치를 승인하는 데 도움이되는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2ae6978c448ceee8a44a91cddc4545fb9e5c5e" translate="yes" xml:space="preserve">
          <source>If you are targetting an ARM device -- which currently includes the vast majority of phones and tablets -- you'll want to pass -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc to Configure. Alternatively, if you are targetting an x86 device, or using the simulator provided with the NDK, you should specify -Dcc=ntox86-gcc instead.</source>
          <target state="translated">현재 대다수의 휴대 전화와 태블릿을 포함하는 ARM 장치를 대상으로하는 경우 -Dcc = arm-unknown-nto-qnx8.0.0eabi-gcc를 구성에 전달하려고합니다. 또는 x86 장치를 대상으로하거나 NDK와 함께 제공된 시뮬레이터를 사용하는 경우 대신 -Dcc = ntox86-gcc를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="562b5f2e0c42aed49d34015bad0780eaae56e849" translate="yes" xml:space="preserve">
          <source>If you are targetting x86 Android, you will have to change &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; to &lt;code&gt;i686-linux-android-gcc&lt;/code&gt;.</source>
          <target state="translated">x86 Android를 대상으로하는 경우 &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; 를 &lt;code&gt;i686-linux-android-gcc&lt;/code&gt; 로 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c81847f52511bd6e6f2d950ba6b028d46d7fda4c" translate="yes" xml:space="preserve">
          <source>If you are testing locales (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), there are helper functions in</source>
          <target state="translated">로케일을 테스트하는 경우 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="638d5e69c0134925bf444f9f37d95ff5346d9353" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;any&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">한 번만 테스트하는 경우 표준 모듈 &lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt; 은이 목적을 위해 &lt;code&gt;any&lt;/code&gt; 함수를 내 보냅니다 . 요소를 찾으면 중지하여 작동합니다. 속도를 위해 C로 작성되었으며 해당 Perl은 다음 서브 루틴과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1005d40b52c8fba9456ef2a3b1ec6cff90f7233f" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;first&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">한 번만 테스트하는 경우 표준 모듈 &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; 은이 목적으로 함수를 &lt;code&gt;first&lt;/code&gt; 내 보냅니다 . 요소를 찾으면 중지하여 작동합니다. 속도를 위해 C로 작성되었으며 Perl에 해당하는 것은 다음 서브 루틴과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee2ce6dbafcb9d4d548485293c0456fbed2a8877" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt;) and write to that instead.</source>
          <target state="translated">출력을 캡처하기 위해 &lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 대신 이것을 사용하려는 경우 스칼라에 대한 파일 핸들을 &lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ( open my $ fh, &quot;&amp;gt;&quot;, \ $ output ) 대신 쓰는 것이 더 쉬울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="faf3c25ab12fb420d9fdf6ea0144e15dc43f0fe2" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 대신 이것을 사용 하여 출력을 캡처하려는 경우, 파일 핸들을 스칼라에 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) 보다 쉽게 ​​파일 핸들을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87f126d580b9d17eb9520e5adc6ebcd7b64cbce8" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 대신 이것을 사용 하여 출력을 캡처하려는 경우, 파일 핸들을 스칼라에 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) 보다 쉽게 ​​파일 핸들을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0601abe3b8fe05fc06de5499fb9941a40db6bc0" translate="yes" xml:space="preserve">
          <source>If you are unable to send your report using &lt;b&gt;perlbug&lt;/b&gt; (most likely because your system doesn't have a way to send mail that perlbug recognizes), you may be able to use this tool to compose your report and save it to a file which you can then send to &lt;b&gt;perlbug@perl.org&lt;/b&gt; using your regular mail client.</source>
          <target state="translated">&lt;b&gt;perlbug를&lt;/b&gt; 사용하여 보고서를 보낼 수없는 경우 (대부분 시스템에 perlbug가 인식하는 메일을 보낼 수있는 방법이 없기 때문에)이 도구를 사용하여 보고서를 작성하고 파일을 저장할 수 있습니다. 그런 다음 일반 메일 클라이언트를 사용하여 &lt;b&gt;perlbug@perl.org&lt;/b&gt; 로 &lt;b&gt;보낼&lt;/b&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd788f693f0912cff62f6c5004a3304201e94790" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt; , this section will describe how they interact.</source>
          <target state="translated">어휘 범위 경고를 도입하기 전에 Perl 버전 작업에 익숙하거나 어휘 경고와 &lt;code&gt;$^W&lt;/code&gt; 모두 사용하는 코드가있는 경우이 섹션에서는 이들이 상호 작용하는 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d4b0bb469edf0650ec3f65bb5c7e77e909873d27" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt;, this section will describe how they interact.</source>
          <target state="translated">어휘 범위 경고를 도입하기 전에 Perl 버전으로 작업하는 데 익숙하거나 어휘 경고와 &lt;code&gt;$^W&lt;/code&gt; 모두 사용하는 코드가있는 경우이 섹션에서는 이들이 상호 작용하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="08e74829ea9d71b80a5466e72595b5d826dd1692" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;IO::Handle&quot;&gt;IO :: 핸들&lt;/a&gt; 또는 그 서브 클래스 중 하나를, 당신은 호출 할 수 &lt;code&gt;autoflush&lt;/code&gt; 파일 핸들의 설정을 변경하는 방법 :</target>
        </trans-unit>
        <trans-unit id="19c883172a7bd8c24338f9dd7a287c030969e4c2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;io/handle&quot;&gt;IO :: 핸들&lt;/a&gt; 또는 그 서브 클래스 중 하나를, 당신은 호출 할 수 &lt;code&gt;autoflush&lt;/code&gt; 파일 핸들의 설정을 변경하는 방법 :</target>
        </trans-unit>
        <trans-unit id="66ca3a901cfd38d2b33b77415f58b3c173825a91" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;HePV&lt;/code&gt; to get values to pass to &lt;code&gt;newSVpvn()&lt;/code&gt; to create a new SV, you should consider using &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; as it is more efficient.</source>
          <target state="translated">새 SV를 작성 하기 위해 &lt;code&gt;HePV&lt;/code&gt; 를 사용하여 newSVpvn &lt;code&gt;newSVpvn()&lt;/code&gt; 에 전달할 값을 얻는 경우 &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; 를 사용하는 것이 더 효율적이므로 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="987d668924ef21e965c8815374cd5ece61317689" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;nanosleep&lt;/code&gt; for something else than mixing sleeping with signals, give some thought to whether Perl is the tool you should be using for work requiring nanosecond accuracies.</source>
          <target state="translated">수면과 신호를 혼합하는 것 이외의 용도로 &lt;code&gt;nanosleep&lt;/code&gt; 을 사용하는 경우 Perl이 나노초 정확도를 요구하는 작업에 사용해야하는 도구인지 여부를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ef7387a4fe9a4611da9e256c7be19f5e356ca6ea" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; that may produce more accurate results than the bare &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode bits. When under &lt;code&gt;use filetest 'access'&lt;/code&gt;, the above-mentioned filetests test whether the permission can(not) be granted using the &lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access(2)&lt;/a&gt; family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; tests may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;use filetest 'access'&lt;/code&gt;, the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; pragma for more information.</source>
          <target state="translated">ACL을 사용하는 경우 베어 &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모드 비트 보다 더 정확한 결과를 생성 할 수있는 &lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt; 라는 pragma 가 있습니다 . &lt;code&gt;use filetest 'access'&lt;/code&gt; 때 위에서 언급 한 filetests는 &lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access (2)&lt;/a&gt; 계열의 시스템 호출을 사용하여 권한을 부여 할 수 있는지 여부를 테스트합니다 . 또한 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;-X&lt;/code&gt; 테스트는 실행 권한 비트가 설정되지 않은 경우에도이 pragma에서 true를 반환 할 수 있습니다 (추가 실행 권한 ACL도 없음). 이 이상 함은 기본 시스템 호출의 정의 때문입니다. 때문에의 구현에, 또한 주 &lt;code&gt;use filetest 'access'&lt;/code&gt; 1, &lt;code&gt;_&lt;/code&gt; 이 pragma가 적용될 때 특수 파일 핸들은 파일 테스트 결과를 캐시하지 않습니다. 자세한 정보 는 &lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt; pragma에 대한 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f9a45f762f42b66675541c22b88f50402f53057c" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">ACL을 사용하는 경우, 베어 stat () 모드 비트보다 정확한 결과를 생성 할 수있는 &lt;code&gt;filetest&lt;/code&gt; 라는 pragma 가 있습니다. 경우에 따라 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 권한이 액세스 시스템 콜 (2) 제품군을 사용하여 부여 (안) 할 수 있는지 여부를 상기 filetests 테스트. 또한 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 는이 pragma에서 실행 권한 비트가 설정되어 있지 않거나 추가 실행 권한 ACL이없는 경우에도 true를 반환 할 수 있습니다. 이 이상한 점은 기본 시스템 호출의 정의 때문입니다. 때문에의 구현에, 또한 주 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 1, &lt;code&gt;_&lt;/code&gt; 이 pragma가 적용될 때 특수 파일 핸들은 파일 테스트 결과를 캐시하지 않습니다. 자세한 내용 은 &lt;code&gt;filetest&lt;/code&gt; pragma 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="536f259afd4833a386595561631d799b0872387d" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">ACL을 사용하는 경우, 베어 stat () 모드 비트보다 정확한 결과를 생성 할 수있는 &lt;code&gt;filetest&lt;/code&gt; 라는 pragma 가 있습니다. 경우에 따라 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 권한이 액세스 시스템 콜 (2) 제품군을 사용하여 부여 (안) 할 수 있는지 여부를 상기 filetests 테스트. 또한 &lt;code&gt;-x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 는이 pragma에서 실행 권한 비트가 설정되어 있지 않거나 추가 실행 권한 ACL이없는 경우에도 true를 반환 할 수 있습니다. 이 이상한 점은 기본 시스템 호출의 정의 때문입니다. 때문에의 구현에, 또한 주 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 1, &lt;code&gt;_&lt;/code&gt; 이 pragma가 적용될 때 특수 파일 핸들은 파일 테스트 결과를 캐시하지 않습니다. 자세한 내용 은 &lt;code&gt;filetest&lt;/code&gt; pragma 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4cb0cc5912b1065f25576985628bc261176328a3" translate="yes" xml:space="preserve">
          <source>If you are using MacOS, the same concerns apply. MacPerl (for Classic environments) comes with a simple editor. Popular external editors are BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) or Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). MacOS X users can use Unix editors as well.</source>
          <target state="translated">MacOS를 사용하는 경우 동일한 문제가 적용됩니다. MacPerl (클래식 환경 용)에는 간단한 편집기가 제공됩니다. 많이 사용되는 외부 편집기는 BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) 또는 Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; )입니다. MacOS X 사용자는 Unix 편집기도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6089a0839b7337d6b244906202548f79ff85a178" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">Plack (대부분의 프레임 워크에서 사용)을 사용하는 경우 &lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt; 는 Apache에서 마이그레이션하거나 항상 리디렉션하려는 URL이 있는지 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4548a312b12b5507979ee1df1e5c700b717005" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">Plack (대부분의 프레임 워크에서 사용)을 사용하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt; 는 Apache에서 마이그레이션하거나 URL을 항상 리디렉션하려는 경우 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="88dc2855988852eaabc5467d99d4705c5f78e44c" translate="yes" xml:space="preserve">
          <source>If you are using Term::ANSIColor in a console command, consider supporting the CLICOLOR standard. See &lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&quot;Supporting CLICOLOR&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">콘솔 명령에서 Term :: ANSIColor를 사용하는 경우 CLICOLOR 표준 지원을 고려하십시오. 자세한 내용은 &lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&quot;CLICOLOR 지원&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b08c775dc3592188f9dd4afa0190ccbb806664" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">Windows를 사용하는 경우 메모장이나 워드 패드와 같은 일반 텍스트로 작업 할 수있는 편집기를 사용할 수 있습니다. Microsoft Word 또는 WordPerfect와 같은 워드 프로세서는 일반적으로 모든 종류의 비하인드 정보를 삽입하기 때문에 작동하지 않지만 일부는 파일을 &quot;텍스트 만&quot;으로 저장할 수 있습니다. Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) 및 UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ) 와 같이 프로그래밍을 위해 특별히 설계된 텍스트 편집기를 다운로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b14c31c340803d7d1a8907e87c3b623cebca0d" translate="yes" xml:space="preserve">
          <source>If you are using a SOCKS firewall, you will need to compile perl and link it with the SOCKS library. This is what is normally called a 'socksified' perl. With this executable you will be able to connect to servers outside the firewall as if it were not there.</source>
          <target state="translated">SOCKS 방화벽을 사용하는 경우 perl을 컴파일하고 SOCKS 라이브러리와 링크해야합니다. 이것을 일반적으로 '양말'펄이라고합니다. 이 실행 파일을 사용하면 마치 방화벽이없는 것처럼 방화벽 외부의 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52dddb8880620f072f3a58161e2e257e19923fa6" translate="yes" xml:space="preserve">
          <source>If you are using a module which returns something special on failure, then you can manually create hints for each of the desired subroutines. Once the hints are specified, they are available for all files and modules loaded thereafter, thus you can move this work into a module and it will still work.</source>
          <target state="translated">실패시 특별한 것을 반환하는 모듈을 사용하는 경우 원하는 각 서브 루틴에 대한 힌트를 수동으로 만들 수 있습니다. 힌트가 지정되면 이후에로드 된 모든 파일과 모듈에서 사용할 수 있으므로이 작업을 모듈로 이동할 수 있으며 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="29c561106308348f3755c72923d0a263a80ca5d3" translate="yes" xml:space="preserve">
          <source>If you are using a regex here, you have to use the quotes as shown or it won't work. Also note that regex handling is tricky even for the experienced. Use this feature with caution.</source>
          <target state="translated">여기에 정규 표현식을 사용하는 경우 표시된대로 따옴표를 사용해야합니다. 그렇지 않으면 작동하지 않습니다. 또한 정규 표현식 처리는 경험이 많은 사람들에게 까다 롭습니다. 이 기능은주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5a12a925a69a2c6041232d382cd6683ae36d2da6" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">5.004_57 이전의 Perl 버전을 사용하는 경우 연결 배열 인터페이스가 상당히 제한됩니다. 위의 예제 스크립트에서 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 또는 array length 결정은 연결된 배열에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e370f11050262a4d86dce72f35bfab79335c669" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">5.004_57 이전의 Perl 버전을 사용하는 경우 연결된 배열 인터페이스가 상당히 제한됩니다. 위의 예제 스크립트에서 &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;shift&lt;/code&gt; , &lt;code&gt;unshift&lt;/code&gt; 또는 배열 길이 결정은 연결된 배열에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02abd4a44d56e10cd1bbe5fedc62225b1b539860" translate="yes" xml:space="preserve">
          <source>If you are using any code that requires the execution of the global destruction phase for clean up (e.g., removing temp files), then do not use detached threads, but rather join all threads before exiting the program.</source>
          <target state="translated">정리 (예 : 임시 파일 제거)를 위해 전역 파괴 단계를 실행해야하는 코드를 사용하는 경우 분리 된 스레드를 사용하지 말고 프로그램을 종료하기 전에 모든 스레드를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="360a39abe6795afd63327f3e470a092ad595cbfe" translate="yes" xml:space="preserve">
          <source>If you are using cpan-mac, just drop the folder on the &lt;b&gt;installme&lt;/b&gt; droplet, and use the module.</source>
          <target state="translated">cpan-mac을 사용하는 경우, &lt;b&gt;installme&lt;/b&gt; 드롭 릿 에 폴더를 놓고 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fc1c37b5a3d2067860bd9ba4aa2038972693c34" translate="yes" xml:space="preserve">
          <source>If you are using gcc, just</source>
          <target state="translated">gcc를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="8fd5d7695f8aa3649f7196f528604d5d3ae20e06" translate="yes" xml:space="preserve">
          <source>If you are using gcc, you would need to use -mcpu=v9 -m64 instead. This option is not yet supported as of gcc 2.95.2; from install/SPECIFIC in that release:</source>
          <target state="translated">gcc를 사용하는 경우 대신 -mcpu = v9 -m64를 사용해야합니다. 이 옵션은 gcc 2.95.2부터 아직 지원되지 않습니다. 해당 릴리스의 설치 / 특정에서 :</target>
        </trans-unit>
        <trans-unit id="43b374ff761647040bfef238a2f344855f86b957" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt; ), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 이 아닌 숫자 및 시간 형식과 관련된 특성에 로케일을 순수하게 사용하는 &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;경우&lt;/a&gt; &quot; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; 와 같이 제한된 형식의 로케일 pragma 사용 ( perllocale에 로케일 pragma 사용 참조)을 고려하십시오 . &quot;.</target>
        </trans-unit>
        <trans-unit id="3f4713ad5807b5f7826ec2dd53e64e4312c481e4" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt;), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot; in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;use locale ':not_characters'&lt;/code&gt;&quot;.</source>
          <target state="translated">당신은 로케일 순수 (그리고 포맷의 숫자와 시간 같은 것들에 관한 특성에 사용하는 경우 &lt;code&gt;LC_CTYPE&lt;/code&gt; 를 (참조 로케일 프라그의 제한된 양식을 사용)을 고려 &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;perllocale에서 &quot;&quot;사용 로케일 &quot;프라 그마&quot;&lt;/a&gt; &quot;와 같은) &lt;code&gt;use locale ':not_characters'&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="bf7e18738b21f2b01d05483723778a511f7e8e06" translate="yes" xml:space="preserve">
          <source>If you are using the 'make' directly, it is the GNU make from the SDKs, and it will invoke the right make commands for the Windows emulator build and the Arm target builds ('thumb' by default) as necessary.</source>
          <target state="translated">'make'를 직접 사용하는 경우 SDK의 GNU make이며 필요에 따라 Windows 에뮬레이터 빌드 및 Arm 대상 빌드 (기본적으로 'thumb')에 대한 올바른 make 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="63c7cadf9ebf06d221687f1101781684817f90c8" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt; , you should check out &lt;a href=&quot;#The-'bval'-Option&quot;&gt;The 'bval' Option&lt;/a&gt;.</source>
          <target state="translated">DB_RECNO 인터페이스를 사용 &lt;code&gt;bval&lt;/code&gt; 을 사용하려는 경우 &lt;a href=&quot;#The-'bval'-Option&quot;&gt;'bval'옵션을&lt;/a&gt; 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f6185500a12d4aa7861d0d23b58da2516585e5a" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt;, you should check out &lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&quot;The 'bval' Option&quot;&lt;/a&gt;.</source>
          <target state="translated">DB_RECNO 인터페이스를 사용 &lt;code&gt;bval&lt;/code&gt; 을 사용하려는 경우 &lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&quot;The 'bval'Option&quot;을&lt;/a&gt; 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e34b95c988ef9ff5f011e4473a6842bbc8f305e" translate="yes" xml:space="preserve">
          <source>If you are using the Visual C compiler, you can get the C runtime's command line wildcard expansion built into perl binary. The resulting binary will always expand unquoted command lines, which may not be what you want if you use a shell that does that for you. The expansion done is also somewhat less powerful than the approach suggested above.</source>
          <target state="translated">Visual C 컴파일러를 사용하는 경우 perl 바이너리에 내장 된 C 런타임 명령 줄 와일드 카드 확장을 얻을 수 있습니다. 결과 바이너리는 항상 인용되지 않은 명령 행을 확장하며,이를 위해 쉘을 사용하는 경우 원치 않을 수도 있습니다. 확장은 위에서 제안한 접근 방식보다 다소 강력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d685e73a12ad96dde7946d5ecb4aacf9b0497e1" translate="yes" xml:space="preserve">
          <source>If you are using the constant interface, be sure to include this code before you use any color constants (such as at the very top of your script), since this environment variable is only honored the first time a color constant is seen.</source>
          <target state="translated">상수 인터페이스를 사용하는 경우 색상 상수 (예 : 스크립트 맨 위)를 사용하기 전에이 코드를 포함해야합니다.이 환경 변수는 색상 상수가 처음 표시 될 때만 적용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b64d320b887e6639115cc4ac113f85e3f1804107" translate="yes" xml:space="preserve">
          <source>If you are using this in non-legacy code you may need to reconsider the course of your life, maybe a hermitage would suite you?</source>
          <target state="translated">레거시가 아닌 코드에서 이것을 사용하는 경우 인생의 과정을 재고해야 할 수도 있습니다. 암자가 당신에게 적합할까요?</target>
        </trans-unit>
        <trans-unit id="a368c00c8ef926e64658830003081d5eb361bb8d" translate="yes" xml:space="preserve">
          <source>If you are using zlib 1.2.0 or older, &lt;code&gt;zlibCompileFlags&lt;/code&gt; will return 0.</source>
          <target state="translated">zlib 1.2.0 이상을 사용하는 경우 &lt;code&gt;zlibCompileFlags&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d19a794a39cad7420e5c34d0bb89a7b77ddba40" translate="yes" xml:space="preserve">
          <source>If you are willing to accept all the defaults run Configure with &lt;b&gt;-de&lt;/b&gt;. However, several useful customizations are available.</source>
          <target state="translated">모든 기본값을 그대로 사용하려면 Configure with &lt;b&gt;-de를&lt;/b&gt; 실행하십시오 . 그러나 몇 가지 유용한 사용자 정의가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fd5b1c2924a349d7291d8ad147e3c28043609419" translate="yes" xml:space="preserve">
          <source>If you are working with a git clone of the Perl repository, you will want to create a branch for your changes. This will make creating a proper patch much simpler. See the &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Perl 저장소의 git 복제본으로 작업중인 경우 변경 사항에 대한 분기를 작성하려고합니다. 이렇게하면 적절한 패치를 만드는 것이 훨씬 간단 해집니다. 이 작업을 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3a5c5d66921962ee5d2f131da55a853da5b0930" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt; . These variants must be explicitly imported.</source>
          <target state="translated">유효한 것으로 알고있는 데이터로 작업하는 경우 &quot;nocheck&quot;변형 인 &lt;code&gt;timelocal_nocheck()&lt;/code&gt; 및 &lt;code&gt;timegm_nocheck()&lt;/code&gt; 를 사용하여 코드 속도를 높일 수 있습니다 . 이러한 변형은 명시 적으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="44340ebb8cf0e2382c2ca3711523d41bd143a85f" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;. These variants must be explicitly imported.</source>
          <target state="translated">유효한 것으로 알고있는 데이터로 작업하는 경우 &quot;nocheck&quot;변형, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; 및 &lt;code&gt;timegm_nocheck()&lt;/code&gt; 를 사용하여 코드 속도를 높일 수 있습니다 . 이러한 변형은 명시 적으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a9fdba02c2ad23e42f49d14ef3350c451024e80f" translate="yes" xml:space="preserve">
          <source>If you are writing a module to expand an already existing set of modules, please coordinate with the author of the package. It helps if you follow the same naming scheme and module interaction scheme as the original author.</source>
          <target state="translated">기존 모듈 세트를 확장하기 위해 모듈을 작성하는 경우 패키지 작성자와상의하십시오. 원래 작성자와 동일한 이름 지정 체계 및 모듈 상호 작용 체계를 따르는 경우 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd2c8d5447831e253b224430edc3070841bc27c" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt; s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">해당 패키지를 작성하는 경우 &lt;code&gt;AUTOLOAD&lt;/code&gt; 들, 강제 고려 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 패키지 인 경우 일반적으로 사용되는 명시 적으로 다른 패키지 나있는 수입 된 모든 상수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 라.</target>
        </trans-unit>
        <trans-unit id="008854f6c49a92df108a1a38fd8f1f0c1b757eb6" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt;s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;use&lt;/code&gt;d.</source>
          <target state="translated">해당 패키지를 작성하는 경우 &lt;code&gt;AUTOLOAD&lt;/code&gt; 들, 강제 고려 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 패키지 인 경우 일반적으로 사용되는 명시 적으로 다른 패키지 나있는 수입 된 모든 상수 &lt;code&gt;use&lt;/code&gt; 라.</target>
        </trans-unit>
        <trans-unit id="f5966f6f48bbef92de0797373659162ca479de0d" translate="yes" xml:space="preserve">
          <source>If you are writing new code, your first port of call should be one of the new &lt;code&gt;IO::Compress&lt;/code&gt; or &lt;code&gt;IO::Uncompress&lt;/code&gt; modules.</source>
          <target state="translated">새 코드를 작성하는 경우 첫 번째 호출 포트는 새로운 &lt;code&gt;IO::Compress&lt;/code&gt; 또는 &lt;code&gt;IO::Uncompress&lt;/code&gt; 모듈 중 하나 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="0d5955743a0fa060d529640f937e917d974a0fd9" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less
'please'&lt;/code&gt; .</source>
          <target state="translated">특별히 아무 것도 요구하지 않으면 &lt;code&gt;less 'please'&lt;/code&gt; 을 적게 요구할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8027e6b734038f8b5eea431be412179b0c1aa993" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less 'please'&lt;/code&gt;.</source>
          <target state="translated">특별히 아무것도 요구하지 않는다면 &lt;code&gt;less 'please'&lt;/code&gt; 요구하게 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d232183f686226b9e4d9f0a9749bb4ab75350724" translate="yes" xml:space="preserve">
          <source>If you ask it to unmemoize a function that was never memoized, it croaks.</source>
          <target state="translated">절대로 메모되지 않은 기능의 메모리를 해제하도록 요청하면 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="5ac398bf0535c0d2bb95ebfd6fd6655ce0bd6b20" translate="yes" xml:space="preserve">
          <source>If you ask to override your chdir() built-in function,</source>
          <target state="translated">chdir () 내장 함수를 대체하도록 요청하면</target>
        </trans-unit>
        <trans-unit id="aae82346550e5f30641b00cfb651b5e652048f2e" translate="yes" xml:space="preserve">
          <source>If you attempt to compile Perl with (POSIX) threads on an 11.X system and also link in the GDBM library, then Perl will immediately core dump when it starts up. The only workaround at this point is to relink the GDBM library under 11.X, then relink it into Perl.</source>
          <target state="translated">11.X 시스템에서 (POSIX) 스레드로 Perl을 컴파일하려고 시도하고 GDBM 라이브러리에서도 링크를 시도하면 Perl은 시작할 때 즉시 코어 덤프를 수행합니다. 이 시점의 유일한 해결 방법은 GDBM 라이브러리를 11.X에서 다시 연결 한 다음 Perl에 다시 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="372756b443de4017a28427029bf0d506d7081a2a" translate="yes" xml:space="preserve">
          <source>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</source>
          <target state="translated">스칼라가 UTF-8로 돌아 왔다고 생각되면 UTF8 플래그를 복원하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1489e0cb25a613554ca1fb1509eb4766e09aaf06" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email perl5-security-report@perl.org with details. This points to a closed subscription, unarchived mailing list. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">Perl에서 보안 취약점을 발견했다고 생각되면 perl5-security-report@perl.org로 이메일을 보내주십시오. 이것은 비공개 구독, 보관되지 않은 메일 링리스트를 가리 킵니다. CPAN에 독립적으로 배포 된 모듈이 아닌 Perl 코어의 보안 문제에만이 주소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74dfa21f751ce3fabe2deb1f0f641c590253ad7e" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email the details to perl5-security-report@perl.org. This creates a new Request Tracker ticket in a special queue which isn't initially publicly accessible. The email will also be copied to a closed subscription unarchived mailing list which includes all the core committers, who will be able to help assess the impact of issues, figure out a resolution, and help co-ordinate the release of patches to mitigate or fix the problem across all platforms on which Perl is supported. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">Perl에서 보안 취약점을 발견했다고 생각되면 자세한 내용을 perl5-security-report@perl.org로 이메일을 보내주십시오. 이렇게하면 처음에 공개적으로 액세스 할 수없는 특수 대기열에 새 요청 추적기 티켓이 생성됩니다. 이메일은 또한 문제의 영향을 평가하고 해결 방법을 파악하고 완화 또는 수정을 위해 패치 릴리스를 조정하는 데 도움을 줄 수있는 모든 핵심 커미터를 포함하는 폐쇄 된 구독 보관되지 않은 메일 링 목록에 복사됩니다. Perl이 지원되는 모든 플랫폼의 문제. 이 주소는 CPAN에 독립적으로 배포 된 모듈이 아닌 Perl 코어의 보안 문제에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2508e4352c00aad2e5cda3b21b798f7f8735a139" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2013 then three tests currently may fail with Daylight Saving Time related problems:</source>
          <target state="translated">Visual C ++ 2013으로 빌드하면 일광 절약 시간 관련 문제로 현재 세 가지 테스트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29ad197e59c85308f30e04c723a79c6188595db" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2015 or later then</source>
          <target state="translated">Visual C ++ 2015 이상으로 빌드하는 경우</target>
        </trans-unit>
        <trans-unit id="fc747a2308602b12226c600429d56710358ba8a4" translate="yes" xml:space="preserve">
          <source>If you build with certain versions (e.g. 4.8.1) of gcc from www.mingw.org then</source>
          <target state="translated">www.mingw.org에서 gcc의 특정 버전 (예 : 4.8.1)으로 빌드하는 경우</target>
        </trans-unit>
        <trans-unit id="5d082c0ec07ad4429dea09b4d3b6034a0edf4cf9" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build XS based extensions. However, if you built perl with the default static linking you can still build XS based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + XS extension boils down to:</source>
          <target state="translated">동적 로딩 기능으로 perl을 빌드했다면 XS 기반 확장을 빌드하는 방법이기도합니다. 그러나 기본 정적 링크로 perl을 빌드 한 경우 OS / 390 용 XS 기반 확장을 빌드 할 수 있지만 정적으로 링크 된 perl 바이너리를 빌드하려면 ExtUtils :: MakeMaker의 지침을 따라야합니다. 가장 간단한 구성에서 정적 펄 + XS 확장을 빌드하는 것은 다음과 같이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="fccb9cfffea038156e1e9bf29f1e74a06b7c692d" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build xs based extensions. However, if you built perl with the default static linking you can still build xs based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + xs extension boils down to:</source>
          <target state="translated">동적 로딩 기능으로 perl을 빌드하면 xs 기반 확장을 빌드하는 방법이기도합니다. 그러나 기본 정적 링크로 perl을 빌드 한 경우에도 OS / 390 용 xs 기반 확장을 빌드 할 수 있지만 정적으로 링크 된 perl 바이너리를 빌드하려면 ExtUtils :: MakeMaker의 지시 사항을 따라야합니다. 가장 간단한 구성에서 정적 perl + xs 확장을 빌드하면 다음과 같이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bbe3ec8c3dbb9079b54edeba88cab20e6c6b9a" translate="yes" xml:space="preserve">
          <source>If you call $lh-&amp;gt;maketext(</source>
          <target state="translated">$ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="b2b245ecec2ba731bc1217986ab8fe3ce3832fb6" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt; , don't call any of the other methods below.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; 을 호출하는 경우 아래의 다른 방법을 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1fcdeca5cd1457b673de047212c964254182c124" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt;, don't call any of the other methods below.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; 을 호출하는 경우 아래의 다른 메서드를 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f29b01f558f5cc8e37b47ab816256a32df3eb207" translate="yes" xml:space="preserve">
          <source>If you call a method that doesn't exist in a class, Perl will throw an error. However, if that class or any of its parent classes defines an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, that &lt;code&gt;AUTOLOAD&lt;/code&gt; method is called instead.</source>
          <target state="translated">클래스에 존재하지 않는 메소드를 호출하면 Perl에서 오류가 발생합니다. 그러나 해당 클래스 또는 상위 클래스 중 하나가 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드를 정의하면 해당 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="945646515b442a128e465225a1d325a7ca2f3625" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">정의되지 않은 서브 루틴을 호출하면 일반적으로 서브 루틴이 존재하지 않는다는 불만을 즉시 치명적인 오류가 발생합니다. (메소드가 클래스 패키지의 기본 클래스에 존재하지 않는 경우 메소드로 사용되는 서브 루틴의 경우와 유사합니다.) 그러나 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴이 패키지에 원래 서브 루틴을 찾는 데 사용 된 패키지에 정의되어 있으면 해당 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴 원래 서브 루틴으로 전달 된 인수와 함께 호출됩니다. 원래 서브 루틴의 완전한 이름은 마술과 같은 패키지의 글로벌 $의 AUTOLOAD 변수에 나타납니다 &lt;code&gt;AUTOLOAD&lt;/code&gt; 일상. 그 이름은 일반적인 주장으로 전달되지 않습니다. 왜냐하면 그 이유 때문입니다. (예외, 존재하지 않는에 메소드 호출로 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;unimport&lt;/code&gt; 자동로드 서브 루틴이 XSUB 경우 대신 건너 그냥 방법. 또한, 서브 루틴의 이름을 검색 할 수있는 다른 방법이 있습니다. 참조 &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;자동 로딩은 perlguts에있는 XSUB에&lt;/a&gt; 대한 자세한 내용은.)</target>
        </trans-unit>
        <trans-unit id="ae93390d7689eae59da77f05524628edc8a8e772" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">정의되지 않은 서브 루틴을 호출하면 일반적으로 서브 루틴이 존재하지 않는다는 즉각적이고 치명적인 오류가 발생합니다. (마찬가지로 메서드로 사용되는 서브 루틴의 경우 메서드가 클래스 패키지의 기본 클래스에 존재하지 않는 경우) 그러나 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴이 원래 서브 루틴을 찾는 데 사용 된 패키지 또는 패키지에 정의 된 경우 해당 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴 원래 서브 루틴에 전달되었을 인수로 호출됩니다. 원래 서브 루틴의 완전한 이름은 마술과 같은 패키지의 글로벌 $의 AUTOLOAD 변수에 나타납니다 &lt;code&gt;AUTOLOAD&lt;/code&gt; 일상. 그 이름은 평범한 주장으로 전달되지 않습니다. 왜냐하면 어, 음, 그 이유 때문입니다. (예외로, 존재하지 않는 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;unimport&lt;/code&gt; 메소드에 대한 메소드 호출 은 대신 그냥 건너 뜁니다. 또한 AUTOLOAD 서브 루틴이 XSUB 인 경우 서브 루틴 이름을 검색하는 다른 방법이 있습니다. 자세한 내용 &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;은 perlguts의 &quot;Autoloading with XSUBs&quot;&lt;/a&gt; 를 참조하십시오. .)</target>
        </trans-unit>
        <trans-unit id="a71cdebace5c6abb01b81af0b4383d9f3787c035" translate="yes" xml:space="preserve">
          <source>If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</source>
          <target state="translated">모든 사람이 참조를 통해이 문제를 처리하도록 할 수 있다면보기에는 좋지 않지만 코드는 더 깨끗합니다. 다음은 두 개의 배열 참조를 인수로 사용하여 두 개의 배열 요소를 순서대로 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3cb0b0acb5a45f37eacb24751a1ec1aefb74d989" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">피할 수 있거나 피할 수 없거나 &lt;a href=&quot;Text::Template&quot;&gt;Text :: Template&lt;/a&gt; 또는 &lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit 과 같은 템플릿 시스템을 사용할 수있는 경우 대신 그렇게하십시오. &lt;code&gt;sprintf&lt;/code&gt; 또는 &lt;code&gt;printf&lt;/code&gt; 로 작업을 완료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23b6ce07b51bd0ae187fbd5346ee2bf854f2bb10" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이를 피할 수 있거나하지 말거나 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit 과 같은 템플릿 시스템을 사용할 수있는 경우 대신 수행하십시오. &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 로 작업을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9556f6832194ce02eb38bf13ea3951955c6d164" translate="yes" xml:space="preserve">
          <source>If you can do these things, you've started on the long road to Perl porting. Thanks for wanting to help make Perl better - and happy hacking!</source>
          <target state="translated">이런 일을 할 수 있다면 펄 포팅으로가는 길을 시작한 것입니다. Perl을 개선하고 행복한 해킹을 도와 주셔서 감사합니다!</target>
        </trans-unit>
        <trans-unit id="4e5e8e457d8aab789523193251b0cae471debcb4" translate="yes" xml:space="preserve">
          <source>If you can go through your firewall with e.g. lynx, presumably with a command such as</source>
          <target state="translated">lynx와 같은 방화벽을 통과 할 수 있다면 아마도 다음과 같은 명령으로</target>
        </trans-unit>
        <trans-unit id="22d913b1c7a6af16ecff397b87485204b5a8ebbc" translate="yes" xml:space="preserve">
          <source>If you can not reach the author for some reason contact the PAUSE admins at modules@perl.org who may be able to help, but each case is treated separately.</source>
          <target state="translated">어떤 이유로 저자에게 연락 할 수없는 경우 PAUSE 관리자 (module@perl.org)에게 도움을 줄 수 있지만 각 사례는 별도로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e0ff87acae1d2fe61dfcf4190a982955e52a9134" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do exactly what you want, and writing a plugin isn't an option, consider extending it. It is designed to be (mostly) easy to subclass, though the cases when sub-classing is necessary should be few and far between.</source>
          <target state="translated">원하는 것을 정확하게 수행 하도록 &lt;code&gt;TAP::Harness&lt;/code&gt; 를 구성 할 수없고 플러그인 작성이 옵션이 아닌 경우 확장을 고려하십시오. 서브 클래 싱이 필요한 경우는 거의없고 서브 클래 싱이 필요한 경우가 많지만 (주로) 서브 클래스하기 쉽도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">원하는 것을 수행 하도록 &lt;code&gt;TAP::Harness&lt;/code&gt; 를 구성 할 수없고 기존 플러그인을 찾을 수없는 경우 작성해보십시오.</target>
        </trans-unit>
        <trans-unit id="aab6be6829c9bde3ac67ace0b1b8f3a83861108b" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">&lt;a href=&quot;File::Copy&quot;&gt;File :: Copy를&lt;/a&gt; 사용할 수없는 경우 에는 직접 작업해야합니다. 원본 파일을 열고 대상 파일을 연 다음 원본을 읽으면서 대상 파일로 인쇄합니다. 또한 권한, 소유자 및 그룹을 새 파일에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy를&lt;/a&gt; 사용할 수없는 경우 직접 작업해야합니다. 원본 파일을 열고 대상 파일을 연 다음 원본을 읽을 때 대상 파일로 인쇄하십시오. 또한 권한, 소유자 및 그룹을 새 파일로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">속성을 지정하여 원하는 Makefile 동작을 수행 할 수없는 경우 Makefile.PL에 개인 서브 루틴을 정의 할 수 있습니다. 각 서브 루틴은 Makefile에 쓰려고하는 텍스트를 반환합니다. Makefile의 섹션을 재정의하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Perl을 5.8.0 이상으로 업그레이드 할 수없는 경우 CPAN에서 사용 가능한 &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; 및 &lt;code&gt;Unicode::Map&lt;/code&gt; 모듈을 사용하여 일부 유니 코드 처리를 계속할 수 있습니다. GNU 레코딩이 설치되어 있으면 문자 변환에 Perl 프론트 엔드 &lt;code&gt;Convert::Recode&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="675032f69b34d194dcc7017e3c4c3044e3fbd01f" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt;, &lt;code&gt;Unicode::Map8&lt;/code&gt;, and &lt;code&gt;Unicode::Map&lt;/code&gt;, available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Perl을 5.8.0 이상으로 업그레이드 할 수없는 경우에도 CPAN에서 사용할 수있는 &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; 및 &lt;code&gt;Unicode::Map&lt;/code&gt; 모듈을 사용하여 일부 유니 코드 처리를 수행 할 수 있습니다 . GNU 레코드가 설치되어있는 경우 문자 변환을 위해 Perl 프런트 엔드 &lt;code&gt;Convert::Recode&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d66bfc35fac26ccfc5a2fc8cf1cd9923cd9f43b" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">&lt;a href=&quot;List::Util&quot;&gt;List :: Util을&lt;/a&gt; 사용할 수없는 경우 동일한 작업을 수행하는 자체 루프를 만들 수 있습니다. 요소를 찾으면 last로 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">&lt;a href=&quot;list/util&quot;&gt;List :: Util을&lt;/a&gt; 사용할 수없는 경우 동일한 작업을 수행하도록 자체 루프를 만들 수 있습니다. 요소를 찾으면 마지막으로 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">방화벽 이유로 git 프로토콜을 사용할 수없는 경우 http를 통해 복제 할 수도 있지만 속도는 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="b117af02a8ee1b3faa8a2a2959074d94964f1bce" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http:</source>
          <target state="translated">방화벽으로 인해 git 프로토콜을 사용할 수없는 경우 http :를 통해 복제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">첫 번째 대체가 발생한 후 &lt;code&gt;$pattern&lt;/code&gt; 을 변경하면 Perl은이를 무시합니다. 당신이 전혀 대체를 원하지 않는 경우, 특별한 구분 기호 사용 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a64e176836406787422c8fb3c6947be0def6d35" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;m''&lt;/code&gt;:</source>
          <target state="translated">첫 번째 대체가 발생한 후 &lt;code&gt;$pattern&lt;/code&gt; 을 변경하면 Perl은이를 무시합니다. 대체를 전혀 원하지 않으면 특수 구분 기호 &lt;code&gt;m''&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 을 확인 하면 open ()을 호출하는 몇 가지 방법이 트릭을 수행해야 함을 알 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65c2b7d80f9113d02d83f4af5a6da477cccfeb58" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc에서 &quot;open&quot;&lt;/a&gt; 을 확인 하면 open ()을 호출하는 여러 가지 방법이 트릭을 수행해야한다는 것을 알 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">목록을 숨기면 각 요소가 잘리고 제거 된 총 문자 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">XL C / C ++ V11을 선택하면 2010 년 4 월 PTF (또는 그 이상)가 설치되어 있어야합니다. 그렇지 않으면 작동하는 Perl 버전이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">XL C / C ++ V9를 선택하면 APAR IZ35785를 설치해야합니다. 그렇지 않으면 최적화 버그로 인해 통합 SDBM_File이 올바르게 컴파일되지 않습니다. 최적화 플래그에 -qipa를 추가하여이 문제를 피할 수 있습니다 (-Doptimize = '-O -qipa'). 이 문제점을 해결하는 APAR IZ35785의 PTF는 IBM에서 사용할 수 있습니다 (AIX, V9.0 용 XL C / C ++ Enterprise Edition의 2009 년 4 월 PTF).</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">PTH 패키지를 선택한 경우 swinstall을 사용하여 기본 위치 (/ opt / pth)에 pth를 설치 한 다음 / usr / lib에서 라이브러리에 대한 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">64 비트 Perl을 컴파일하기 위해 gcc를 선택하면 다음 옵션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="043ebe155c68a02fa99782ad455e116e9535a4e8" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">목록을 자르면 각 요소가 잘립니다. 마지막 &lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt; 의 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">목록을 자르면 각 요소가 잘립니다. 마지막 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">목록을 자르면 각 요소가 잘립니다. 마지막 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">컴파일하고 실행하면</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">짧은 형식의 Perl 공용 API를 완전히 숨기면 컴파일 플래그에 -DPERL_NO_SHORT_NAMES를 추가하십시오. 이것은 예를 들어 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="2026c5f1b05bc468fd9f9b21ddfe279181855850" translate="yes" xml:space="preserve">
          <source>If you constrain the portion of &lt;code&gt;pv&lt;/code&gt; that is looked at by this function (by passing a non-NULL &lt;code&gt;endptr&lt;/code&gt;), and if the intial bytes of that portion form a valid value, it will return TRUE, setting &lt;code&gt;*endptr&lt;/code&gt; to the byte following the final digit of the value. But if there is no constraint at what's looked at, all of &lt;code&gt;pv&lt;/code&gt; must be valid in order for TRUE to be returned. &lt;code&gt;*endptr&lt;/code&gt; is unchanged from its value on input if FALSE is returned;</source>
          <target state="translated">이 함수에서 보는 &lt;code&gt;pv&lt;/code&gt; 부분을 ​​제한하고 ( NULL이 아닌 &lt;code&gt;endptr&lt;/code&gt; 을 전달하여 ) 해당 부분의 초기 바이트가 유효한 값을 형성하면 TRUE를 반환하고 &lt;code&gt;*endptr&lt;/code&gt; 을 다음 바이트로 설정 합니다. 값의 마지막 자리. 그러나 보는 것에 제약이 없다면 TRUE가 반환 되려면 모든 &lt;code&gt;pv&lt;/code&gt; 가 유효해야합니다. &lt;code&gt;*endptr&lt;/code&gt; 은 FALSE가 반환되면 입력 값에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">당신이 상담하는 경우 &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신이 볼 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; bareword는 나 문자열을 투여했을 때 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="675f3fe6a1b5c4eacc7781347f628b31f87a96c1" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f require&lt;/code&gt; you will see that &lt;code&gt;require&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">당신이 상담하는 경우 &lt;code&gt;perldoc -f require&lt;/code&gt; 당신이 볼 &lt;code&gt;require&lt;/code&gt; bareword는 나 문자열을 투여했을 때 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">한 스레드에서 인터프리터를 작성하고 다른 스레드에서 인터프리터를 호출하는 경우 perl의 자체 스레드 로컬 스토리지 (TLS) 슬롯이 각 스레드에서 올바르게 초기화되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">이 조언을 무시하고 어쨌든 GNU 버전을 사용하기로 결정했다면 비교적 최신 버전인지 확인하십시오. 2.7보다 새로운 버전은 충분히 새로운 버전입니다. 이전 버전은 동적 로딩에 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">다른 버전의 zlib 라이브러리를 사용하기로 결정한 경우 다음 문제를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">gcc를 사용하기로 결정한 경우, 설치가 최신이고 완전한지 확인하고 더 자세한 gcc 특정 세부 사항은 Perl INSTALL 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">gcc를 사용하기로 결정한 경우, 설치가 최신이고 완전한지 확인하고 더 자세한 gcc 특정 세부 사항은 Perl INSTALL 파일을 읽으십시오. 개발 팀에 뛰어 넘어야 할 농구대를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">클래스에서 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 정의하면 Perl은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 호출하여 &lt;code&gt;DESTROY&lt;/code&gt; 메소드 를 처리합니다 . 자동로드 예제에서와 같이 빈 &lt;code&gt;DESTROY&lt;/code&gt; 를 정의하여이를 방지 할 수 있습니다 . &lt;code&gt;DESTROY&lt;/code&gt; 처리를 위해 호출 될 때 아무 작업도하지 않고 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 값을 확인 하고 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="498a8ce676b34793704f21213180e13370975cc0" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt;, like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt;.</source>
          <target state="translated">클래스에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 정의하면 Perl은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 호출하여 &lt;code&gt;DESTROY&lt;/code&gt; 메서드 를 처리합니다 . 자동 로딩 예제에서했던 것처럼 빈 &lt;code&gt;DESTROY&lt;/code&gt; 를 정의하여이를 방지 할 수 있습니다 . &lt;code&gt;$AUTOLOAD&lt;/code&gt; 의 값을 확인하고 &lt;code&gt;DESTROY&lt;/code&gt; 를 처리하기 위해 호출 될 때 아무것도하지 않고 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">코드 포인트에 대해 둘 이상의 이름을 정의하면 어떤 이름이 리턴 될지 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49322aadfdd4f7ccdbc478f7d31a6ef35c74c780" translate="yes" xml:space="preserve">
          <source>If you desire complete control over SSL connections, the &lt;code&gt;SSL_options&lt;/code&gt; attribute lets you provide a hash reference that will be passed through to &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt;, overriding any options set by HTTP::Tiny. For example, to provide your own trusted CA file:</source>
          <target state="translated">SSL 연결을 완벽하게 제어하려면 &lt;code&gt;SSL_options&lt;/code&gt; 속성을 사용하여 &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt; 로 전달되는 해시 참조를 제공하고 HTTP :: Tiny에서 설정 한 모든 옵션을 재정의 할 수 있습니다. 예를 들어 자신의 신뢰할 수있는 CA 파일을 제공하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">Memoize와 함께 배포해야한다고 생각되는 유용한 만료 관리자를 개발하는 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="2101fa1f88298b0b195dfaac7732fd2635cea835" translate="yes" xml:space="preserve">
          <source>If you didn't mean to use a Unicode property, escape the &lt;code&gt;\p&lt;/code&gt;, either by &lt;code&gt;\\p&lt;/code&gt; (just the &lt;code&gt;\p&lt;/code&gt;) or by &lt;code&gt;\Q\p&lt;/code&gt; (the rest of the string, or until &lt;code&gt;\E&lt;/code&gt;).</source>
          <target state="translated">유니 코드 속성을 사용하려는 것이 아니라면 &lt;code&gt;\p&lt;/code&gt; 를 &lt;code&gt;\\p&lt;/code&gt; ( &lt;code&gt;\p&lt;/code&gt; ) 또는 &lt;code&gt;\Q\p&lt;/code&gt; (나머지 문자열 또는 &lt;code&gt;\E&lt;/code&gt; 까지)로 이스케이프하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;syslog()&lt;/code&gt; &lt;code&gt;openlog()&lt;/code&gt; 를 사용하기 전에 openlog () 를 사용 하지 않은 경우 , &lt;code&gt;syslog()&lt;/code&gt; 는 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 로 끝나는 &lt;code&gt;$format&lt;/code&gt; 의 가장 짧은 접두사를 추출하여 &lt;code&gt;$ident&lt;/code&gt; 를 추측하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="c2758eb43b68115ce83395ea254e99fa90136500" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt;, &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하지 않은 경우 &lt;code&gt;openlog()&lt;/code&gt; 사용하기 전에 &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; 추측하려고합니다 &lt;code&gt;$ident&lt;/code&gt; 가장 짧은 접두사를 추출하여 &lt;code&gt;$format&lt;/code&gt; 하는에 끝 &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">결함이 발견되면 문제가있는 모듈의 디렉토리를 다른 위치로 이동하십시오. 이러한 모듈이 비 XS 모듈 인 경우 무시해도됩니다. 이미 설치되어 있습니다. 나머지 XS 모듈은 하나씩 수동으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">당신이 할 경우</target>
        </trans-unit>
        <trans-unit id="cb8667358646593d3b3e540e94dd3bddc5a68445" translate="yes" xml:space="preserve">
          <source>If you do need to sort non-alphabetically for whatever reasons, you can give a code reference (or a subroutine name) to &lt;code&gt;sort_by&lt;/code&gt;, then the argument will be passed to Perl's &lt;code&gt;sort&lt;/code&gt; built-in function.</source>
          <target state="translated">어떤 이유로 든 알파벳이 아닌 순서로 정렬해야하는 경우 &lt;code&gt;sort_by&lt;/code&gt; 에 대한 코드 참조 (또는 서브 루틴 이름)를 제공 하면 인수가 Perl의 &lt;code&gt;sort&lt;/code&gt; 내장 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f303cdfeba4ec1c04b3ea76ad07c019d7ba1217e" translate="yes" xml:space="preserve">
          <source>If you do not do this, then tools you call that also check for a context will notice that the context they grabbed was created at the same stack depth, which will trigger protective measures that warn you and destroy the existing context.</source>
          <target state="translated">이 작업을 수행하지 않으면 컨텍스트를 확인하는 호출 도구도 해당 컨텍스트가 동일한 스택 깊이에서 생성되었음을 알아 차리고 기존 컨텍스트를 파괴하는 보호 조치를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">쉘을 입력하지 않으면 쉘 명령은 메소드 ( &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; )와 호출 패키지 ( &lt;code&gt;install(...)&lt;/code&gt; )의 함수로 사용할 수 있습니다. 저수준 명령을 호출하기 전에 필요한 CPAN의 구성 요소를 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">당신이없는 경우</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">GNU 일반 공중 사용 허가서 사본이없는 경우, 미국 MA 02139, 케임브리지 소재 675 Mass Ave, Free Software Foundation, Inc.에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ca85e836f91816edbc4e15e9107effedf45973f0" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">해당 모듈이없는 경우 표준 라이브러리의 일부인 &lt;a href=&quot;File::Find&quot;&gt;File :: Find로&lt;/a&gt; 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">해당 모듈이없는 경우 표준 라이브러리의 일부인 &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; 를 사용하여 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c2496743b48fe9b410f73d7328bfcdc228baa8" translate="yes" xml:space="preserve">
          <source>If you do not have the SDK installed you must at least have abc-shell installed or some other suitable sh port. This is required to run external commands and should be available as 'sh' in your path.</source>
          <target state="translated">SDK가 설치되어 있지 않은 경우 최소한 abc-shell 또는 기타 적절한 sh 포트가 설치되어 있어야합니다. 이는 외부 명령을 실행하는 데 필요하며 경로에서 'sh'로 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">어떤 쉘을 가지고 있는지 모르는 경우, 해당 지역의 헬프 데스크 또는 이와 동등한 것을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e4c6cc6957c31110bb18e19744ff8957469df93" translate="yes" xml:space="preserve">
          <source>If you do not override this then the default implementation will attempt to generate facets from the legacy API. This generation is limited only to what the legacy API can provide. It is recommended that you override this method and write out explicit facet data.</source>
          <target state="translated">이를 재정의하지 않으면 기본 구현이 기존 API에서 패싯을 생성하려고 시도합니다. 이 세대는 레거시 API가 제공 할 수있는 것만으로 제한됩니다. 이 메서드를 재정의하고 명시 적 패싯 데이터를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">이 플래그를 설정하지 않으면</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">패키지 이름을 지정하지 않으면 변수가 현재 패키지에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="eb887a9c7d54012c86e6e1c5e9df47c38a1fd9a7" translate="yes" xml:space="preserve">
          <source>If you do not want to actually create a full blown version object, but would still like to verify that a given string meets the criteria to be parsed as a version, there are two helper functions that can be employed directly:</source>
          <target state="translated">실제로 완전한 버전 객체를 만들고 싶지 않지만 주어진 문자열이 버전으로 구문 분석 할 기준을 충족하는지 확인하려면 직접 사용할 수있는 두 가지 도우미 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec84ed1a6f6d8da6377929662414a47b27976a2" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">패키지의 &lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하지 않으려면 (예 : 네임 스페이스 변경을 중지하기 위해) 빈 목록을 명시 적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">패키지의 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드 를 호출하지 않으려면 (예 : 네임 스페이스 변경을 중지하기 위해) 빈 목록을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">패키지의 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드 를 호출하지 않으려면 (예 : 네임 스페이스 변경을 중지하기 위해) 빈 목록을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">이러한 기본값을 사용하지 않으려면 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션 을 명시 적으로 설정 하거나 &lt;code&gt;Minimal&lt;/code&gt; 매개 변수 를 설정하여 이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">이러한 기본값을 사용하지 않으려면 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Time&lt;/code&gt; 옵션 을 명시 적으로 설정 하거나 &lt;code&gt;Minimal&lt;/code&gt; 매개 변수 를 설정하여 이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de7aec51016dff43e0ecf45d764d0cccf666e711" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">이러한 기본값을 사용하지 않으려면 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션 을 명시 적으로 설정 하거나 &lt;code&gt;Minimal&lt;/code&gt; 매개 변수 를 설정하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">이런 일이 일어나지 않게하려면 명령의 모든 부분이 이미 분리되어있는 배열 참조를 제공해야합니다. 그러나 이러한 부분에 추가 공백이나 허위 공백이 있으면 구문 분석기 또는 기본 코드가이를 올바르게 해석하지 못하여 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459db29c5c8a7302439a70851525c81616dcc865" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">CPAN에서 &lt;a href=&quot;Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; 패키지 를 설치하지 않으려면 ,</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">CPAN에서 &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; 패키지 를 설치하지 않으려면</target>
        </trans-unit>
        <trans-unit id="484cd976813c85d85881ff70f66c34600b720c15" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0, you may notice an improvement in speed at the risk of not recursing into subdirectories if a filesystem doesn't populate &lt;code&gt;nlink&lt;/code&gt; as expected.</source>
          <target state="translated">당신이 설정하는 경우 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 0으로, 당신은 파일 시스템이 채워지지 않는 경우 하위 디렉토리로 재귀하지의 위험 속도의 개선 알 수 있습니다 &lt;code&gt;nlink&lt;/code&gt; 예상대로입니다.</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">당신이 설정하는 경우 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 1로, 당신은 속도 저하를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">이진 연산자로이 작업을 수행하면 실제로 연산자에 들어온 문자열 중 하나를 변경하게되며 최종 사용자가 눈에 띄지 않아야하지만 코드 부족 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 서브 루틴이 닫히는 변수의 향후 변경 사항을 반영하는 클로저가되도록하려면 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="38c006c4445fbc760bcc20774ff0c404fc351e3b" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">이 서브 루틴이 닫히는 변수에 대한 향후 변경 사항을 반영하는 클로저가되도록하려면 명시 적 &lt;code&gt;return&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 와 같은 큰 정수로 작업 하려면 ; 시도 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b1975a786e24a8553b122ca84ecd2c75458bf60c" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;use integer;&lt;/code&gt;, try &lt;code&gt;use bigint;&lt;/code&gt;:</source>
          <target state="translated">under &lt;code&gt;use integer;&lt;/code&gt; 와 같은 큰 정수로 작업하고 싶다면 ; , &lt;code&gt;use bigint;&lt;/code&gt; 사용해보십시오 . :</target>
        </trans-unit>
        <trans-unit id="226407ccd685c51b95b1d8b7151f227bb1d0575c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to be included in the AUTHORS file, just let us know. Otherwise we will take your submission of a patch as permission to credit you in the AUTHORS file.</source>
          <target state="translated">AUTHORS 파일에 포함되지 않으려면 저희에게 알려주십시오. 그렇지 않으면 AUTHORS 파일에서 귀하를 크레딧으로 표시하기 위해 귀하의 패치 제출을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">기능을 요청하지 않으면 사용자가 친절하게 요청한 기능 목록이 표시됩니다. 이것은 당신이 특히 아무것도 존중하지 않으면 그것을 요구하고 그것을 부울처럼 사용할 수 있다는 좋은 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">요소의 순서에 신경 쓰지 않으면 해시를 만든 다음 키를 추출하면됩니다. 해시를 만드는 방법은 중요하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용 하여 고유 한 요소를 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ab466d2383fda10b330c50a2b963d3911043a02" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;keys&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">요소의 순서에 신경 쓰지 않는다면 해시를 생성 한 다음 키를 추출 할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 해시를 만드는 방법은 중요하지 않습니다. &lt;code&gt;keys&lt;/code&gt; 를 사용 하여 고유 한 요소를 가져 오는 것뿐입니다 .</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">숫자와 밑줄이 정렬되는 위치에 신경 쓰지 않으면 다음과 같이 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">한 해시가 다른 해시의 키와 값을 덮어 쓰는 것을 신경 쓰지 않으면 해시 슬라이스를 사용하여 하나의 해시를 다른 해시에 추가 할 수 있습니다. 이 경우 &lt;code&gt;%hash2&lt;/code&gt; 값은 공통 키가있을 때 &lt;code&gt;%hash1&lt;/code&gt; 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">확장 된 토론의 한두 단락을 얻지 못하면 펄의 메시지가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">File :: Stream이 없으면 조금 더 많은 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">위에서 설명한 perl의 특정 구성으로 작성된 데이터가 없으면 아무 것도 수행하지 않아야합니다. 플래그를 설정하지 마십시오-동일하게 구성된 펄의 Storable은로드를 거부 할뿐만 아니라, 다르게 구성된 펄은로드가 올바른 것으로 믿고로드 한 후 읽거나 실패 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="670ababa1b4eae15ad2ad8b23b062bc17283021f" translate="yes" xml:space="preserve">
          <source>If you don't have the safe version of set-id scripts, all is not lost. Sometimes this kernel &quot;feature&quot; can be disabled, so that the kernel either doesn't run set-id scripts with the set-id or doesn't run them at all. Either way avoids the exploitability of the race condition, but doesn't help in actually running scripts set-id.</source>
          <target state="translated">안전한 버전의 set-id 스크립트가 없다면 모든 것이 손실되지 않습니다. 때때로이 커널 &quot;기능&quot;을 비활성화하여 커널이 set-id로 set-id 스크립트를 실행하지 않거나 전혀 실행하지 않도록 할 수 있습니다. 어느 쪽이든 경쟁 조건의 악용 가능성을 피하지만 실제로 set-id 스크립트를 실행하는 데는 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f34e9607e58d64a63d5aabb3955bab5ec740de09" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to trap the error.</source>
          <target state="translated">DBM 파일에 대한 쓰기 권한이없는 경우 해시 변수를 읽을 수만 있고 설정할 수는 없습니다. 쓸 수 있는지 테스트하려면 파일 테스트를 사용하거나 &lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 내부에 더미 해시 항목을 설정 하여 오류를 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBM 파일에 대한 쓰기 액세스 권한이없는 경우 해시 변수 만 읽을 수 있으며 설정하지 않아도됩니다. 쓰기 가능 여부를 테스트하려면 파일 테스트를 사용하거나 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에 더미 해시 항목을 설정 하여 오류를 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBM 파일에 대한 쓰기 액세스 권한이없는 경우 해시 변수 만 읽을 수 있으며 설정하지 않아도됩니다. 쓰기 가능 여부를 테스트하려면 파일 테스트를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에 더미 해시 항목을 설정 하여 오류를 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">이러한 함수를 가져 오지 않으면 다음 예제에서 모든 함수 이름 앞에 &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; 를 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">실행할 테스트 수를 모를 경우 테스트 실행이 완료되면 계획을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="739739cb456280bdf258e73ad5d6021f89fcc54e" translate="yes" xml:space="preserve">
          <source>If you don't know if a string contains YAML or JSON, this method will use &lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse::CPAN::Meta&lt;/a&gt; to guess. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="translated">문자열에 YAML 또는 JSON이 포함되어 있는지 모르는 경우이 메서드는 &lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse :: CPAN :: Meta&lt;/a&gt; 를 사용하여 추측합니다. 다른 측면에서는 &lt;code&gt;load_file()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">어떤 라이센스를 사용해야하는지 모르는 경우 GPL 및 Artistic 라이센스 (Perl과 동일)에 따른 이중 라이센스를 사용하는 것이 좋습니다. &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; 및 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed23e5a70f4d9c445aa4d9a13f1bd7f582002fa9" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">어떤 라이선스를 사용해야할지 모르겠다면 GPL 및 Artistic 라이선스 (Perl 자체와 동일)에 따른 이중 라이선스를 사용하는 것이 좋습니다. &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; 및 &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">문자열에 YAML 또는 JSON 데이터가 포함되어 있는지 알 수없는 경우이 방법은 일부 추론 및 추측을 사용합니다. 말할 수 없으면 YAML이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">쉘링을 신경 쓰지 않으면 &lt;code&gt;wc&lt;/code&gt; 명령이 추가 프로세스 간 오버 헤드가 있어도 가장 빠릅니다. 그래도 감염되지 않은 파일 이름이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">SV의 기존 컨텐츠가 필요하지 않은 경우 다음을 사용하여 일부 복사를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">파일 이름을 알 필요가 없으면 파일 이름 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . Perl 5.8 이상에서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 함수는 익명 임시 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="22928fef3e84c8263a53f0cfc23f1b5d448491ff" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;open()&lt;/code&gt; with &lt;code&gt;undef&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;open()&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">파일 이름을 알 필요가 없으면 파일 이름 대신 &lt;code&gt;undef&lt;/code&gt; 와 함께 &lt;code&gt;open()&lt;/code&gt; 을 사용할 수 있습니다 . Perl 5.8 이상에서 &lt;code&gt;open()&lt;/code&gt; 함수는 익명의 임시 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">정확한 역변환을 제공하지 않으면 이와 같은 코드가 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">실제로 첫 번째 인수를 실행하고 싶지는 않지만 자신의 이름에 대해 실행중인 프로그램에 거짓말을하려면 실제로 &quot;간접 객체&quot;(쉼표없이)로 실행하려는 프로그램을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 에서와 같이 LIST 앞 . (목록에 단일 스칼라 만있는 경우에도 항상 LIST를 다중 값 목록으로 해석해야합니다.) 예 :</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">실제로 첫 번째 인수를 실행하고 싶지는 않지만 자신의 이름에 대해 실행중인 프로그램에 거짓말을하려면 실제로 &quot;간접 객체&quot;(쉼표없이)로 실행하려는 프로그램을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 에서와 같이 LIST 앞 . (목록에 단일 스칼라 만있는 경우에도 항상 LIST를 다중 값 목록으로 해석해야합니다.) 예 :</target>
        </trans-unit>
        <trans-unit id="418ff649fbe756afaa4bfbbd2264a36cfbe884b8" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;exec PROGRAM LIST&lt;/code&gt;. (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">첫 번째 인수를 실제로 실행하고 싶지 않지만 실행중인 프로그램에 자신의 이름에 대해 거짓말을하고 싶다면 실제로 실행할 프로그램을 &quot;간접 객체&quot;(쉼표없이)로 지정할 수 있습니다. &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; 에서와 같이 LIST 앞에 . (이렇게하면 목록에 스칼라가 하나만 있더라도 항상 LIST를 다중 값 목록으로 해석해야합니다.) 예 :</target>
        </trans-unit>
        <trans-unit id="24b9da8187ce4c2f915ec1ca4c659113a1fb93a3" translate="yes" xml:space="preserve">
          <source>If you don't run the full test suite, at least &lt;code&gt;make test_porting&lt;/code&gt;. This will run basic sanity checks. To see which sanity checks, have a look in</source>
          <target state="translated">전체 테스트 스위트를 실행하지 않으면 최소한 &lt;code&gt;make test_porting&lt;/code&gt; . 이것은 기본적인 온 전성 검사를 실행합니다. 어떤 온 전성 검사를 확인하려면</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">오류 메시지가 표시되지 않으면 모듈이있는 것입니다. (오류 메시지가 표시되면 여전히 모듈이있을 수 있지만 경로에없는 것입니다. &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 표시 할 수 있습니다 .이 문서의 나머지 부분에서, 우리는 당신에게 솔직히 설치된 모듈이 실제로 없다고 가정하지만 CPAN에서 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="eb0d75079c24e83da6fecb7132e9b60520bba455" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt;.) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">오류 메시지가 표시되지 않으면 모듈이있는 것입니다. (오류 메시지가 표시되는 경우에도 모듈이있을 수 있지만 경로에 있지 않을 수 있습니다. &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 를 사용하여 표시 할 수 있습니다 .)이 문서의 나머지 부분에 대해서는 정말 솔직히 설치된 모듈이 부족하지만 CPAN에서 찾은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">&lt;code&gt;dw_size&lt;/code&gt; 를 지정하지 않으면 기본적으로 전체 메모리 제한이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d09f5237198c8d539c87c541eb6e6b72285d75" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt;, it defaults to the entire memory limit.</source>
          <target state="translated">&lt;code&gt;dw_size&lt;/code&gt; 를 지정하지 않으면 기본적으로 전체 메모리 제한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="680f0cec0c96fdd6b5789593128bcc203ccf616d" translate="yes" xml:space="preserve">
          <source>If you don't specify a plan, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; expects to see &lt;code&gt;done_testing()&lt;/code&gt; before your program exits. It will warn you if you forget it. You can give &lt;code&gt;done_testing()&lt;/code&gt; an optional number of tests you expected to run, and if the number ran differs, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; will give you another kind of warning.</source>
          <target state="translated">계획을 지정하지 않으면 &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 는 프로그램이 종료되기 전에 &lt;code&gt;done_testing()&lt;/code&gt; 을 볼 것으로 예상합니다 . 잊어 버린 경우 경고합니다. &lt;code&gt;done_testing()&lt;/code&gt; 에 실행할 것으로 예상 한 테스트 수를 선택적으로 제공 할 수 있으며 실행 된 수가 다른 경우 &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 는 다른 종류의 경고를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">이 질문을 이해하지 못하면 ENTER를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 가 원래 변수를 변경 하지 않게 하려면 비파괴 대체 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 . 이는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 이 대체 수 대신 최종 대체 문자열을 반환 하도록 동작을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="b16ffc6d1bac1378ef5d03cf556d21c8b3e4f33f" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;s///&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;s///r&lt;/code&gt;. This changes the behavior so that &lt;code&gt;s///r&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 가 원래 변수를 변경 하지 않도록 하려면 비파괴 대체 수정 &lt;code&gt;s///r&lt;/code&gt; 사용할 수 있습니다 . 이렇게하면 &lt;code&gt;s///r&lt;/code&gt; (대체 횟수 대신) 최종 대체 문자열을 반환 하도록 동작이 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">모든 모듈을 최신 상태로 유지하려는 출력을 원하지 않으면 정규식 &lt;code&gt;/modules are up to date/&lt;/code&gt; 인지에 대한 위 명령의 출력을 구문 분석하고 출력이 일치하지 않는 경우에만 메일을 보내도록 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">새로운 해시를 생성하지 않으려면이 루핑 기법을 계속 사용할 수 있습니다. &lt;code&gt;%new_hash&lt;/code&gt; 를 &lt;code&gt;%hash1&lt;/code&gt; 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="611b9b2078bc455fea7df0c75d337a1c6b770290" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt;.</source>
          <target state="translated">새 해시를 생성하지 않으려는 경우에도이 루핑 기술을 사용할 수 있습니다. &lt;code&gt;%new_hash&lt;/code&gt; 를 &lt;code&gt;%hash1&lt;/code&gt; 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">AIX에서 컴파일 된 Perl을 / QOpenSys에 설치하지 않으려면 (PASE로 복사하기 전에 패키징하기 위해) Configure 매개 변수 -Dinstallprefix = / tmp / QOpenSys / perl을 사용할 수 있습니다. 이렇게하면 &quot;make install&quot;이 해당 디렉토리에 모든 것을 설치하지만 설치된 파일은 여전히 ​​/ QOpenSys / perl에 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">INSTALL * 매크로의 기본값을 유지하지 않으려면 MakeMaker를 사용하여 필요한 입력을 최소화 할 수 있습니다. INSTALLPRIVLIB와 INSTALLARCHLIB의 일반적인 관계는 perl 컴파일시 구성에 의해 결정됩니다. MakeMaker는 INSTALLPRIVLIB를 설정하는 사용자를 지원합니다. INSTALLPRIVLIB가 설정되었지만 INSTALLARCHLIB가 설정되지 않은 경우 MakeMaker는 후자가 기본적으로 % Config의 상대방에 대해 Configure가 결정한 것과 동일한 INSTALLPRIVLIB의 서브 디렉토리가되도록 기본 설정합니다. 그렇지 않으면 기본값은 INSTALLPRIVLIB입니다. INSTALLSITELIB 및 INSTALLSITEARCH에 대해 동일한 관계가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">소스 코드를 수정하지 않고 여전히 경고가있는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">객체를 사용하지 않으려면 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메소드를 &lt;code&gt;stat_cando&lt;/code&gt; 라는 일반 함수로 네임 스페이스에 가져올 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 의 반환 값을 첫 번째 인수로 포함하는 arrayref를 가져 와서 해석합니다.</target>
        </trans-unit>
        <trans-unit id="75651ef23090da325a0156abcf83a5415a24e8bd" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt;. This takes an arrayref containing the return values of &lt;code&gt;stat&lt;/code&gt; or &lt;code&gt;lstat&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">객체를 사용하지 않으려면 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메서드를 &lt;code&gt;stat_cando&lt;/code&gt; 라는 일반 함수로 네임 스페이스에 가져올 수 있습니다 . 이것은 &lt;code&gt;stat&lt;/code&gt; 또는 &lt;code&gt;lstat&lt;/code&gt; 의 반환 값을 첫 번째 인수로 포함하는 arrayref를 가져 와서 해석합니다.</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">이 작업을 원하지 않으면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그러면 버전 비교가 불가능하다는 것을 이해하고 Module :: Load :: Conditional은 설치 한 모듈 버전을 알려줄 수 없습니다. 이것은 보안 또는 성능 관점에서 바람직 할 수 있습니다. 참고 &lt;code&gt;$FIND_VERSION&lt;/code&gt; 코드에서 안전하게 실행 &lt;code&gt;taint mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de94190185ca2f3465ff49971ba654614381737e" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt;. Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt;.</source>
          <target state="translated">이렇게하지 않으려면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그러면 버전 비교가 불가능하며 Module :: Load :: Conditional은 설치 한 모듈 버전을 알려줄 수 없음을 이해하십시오. 이것은 보안 또는 성능 관점에서 바람직 할 수 있습니다. 참고 &lt;code&gt;$FIND_VERSION&lt;/code&gt; 코드에서 안전하게 실행 &lt;code&gt;taint mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">그렇지 않으면 이상한 빌드 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">편집하면</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">Perl 5.8.0 이상을 설치했거나 Scalar-List-Utils 1.03 이상을 설치 한 경우 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09872666932a845e43c465fbd124a59438a49096" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns a false value if the hash is empty. If there are any key/value pairs, it returns a true value. A more precise definition is version dependent.</source>
          <target state="translated">스칼라 컨텍스트에서 해시를 평가하는 경우 해시가 비어 있으면 false 값을 반환합니다. 키 / 값 쌍이 있으면 참 값을 반환합니다. 보다 정확한 정의는 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">스칼라 컨텍스트에서 해시를 평가하면 해시가 비어 있으면 false를 반환합니다. 키 / 값 쌍이 있으면 true를 반환합니다. 보다 정확하게 반환 된 값은 사용 된 버킷 수와 할당 된 버킷 수로 구성되는 문자열이며 슬래시로 구분됩니다. 이것은 Perl의 내부 해싱 알고리즘이 데이터 세트에서 제대로 수행되지 않는지 확인하는 데만 유용합니다. 예를 들어, 해시에 10,000 개의 항목을 집어 넣지 만 스칼라 컨텍스트에서 % HASH를 평가하면 &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; 이 표시됩니다 . 이는 16 개의 버킷 중 하나만 건드리고 10,000 개의 항목을 모두 포함하고 있음을 의미합니다. 이것은 일어나지 않아야합니다. 스칼라 컨텍스트에서 연결된 해시가 평가되면 &lt;code&gt;SCALAR&lt;/code&gt; 메소드가 호출됩니다 ( &lt;code&gt;FIRSTKEY&lt;/code&gt; 로 대체 됨 ).</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">스칼라 컨텍스트에서 배열을 평가하면 배열의 길이가 반환됩니다. C 쉼표 연산자와 같이 마지막 값을 반환하는 목록이나 반환하려는 느낌을 반환하는 내장 함수는 목록에 해당되지 않습니다. 다음은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">이와 같은 문자열이 표시되면 실수로 참조를 인쇄 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">활성 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 에서 &lt;code&gt;T&lt;/code&gt; 명령 을 실행하면 역 추적에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임과 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 프레임이 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="091b3761ddd88c9d0dd9f58cc16fae998cfc428e" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;use&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;require&lt;/code&gt; frame and an &lt;code&gt;eval&lt;/code&gt; frame.</source>
          <target state="translated">활성 &lt;code&gt;use&lt;/code&gt; 문 내 에서 &lt;code&gt;T&lt;/code&gt; 명령 을 실행하면 역 추적에 &lt;code&gt;require&lt;/code&gt; 프레임과 &lt;code&gt;eval&lt;/code&gt; 프레임이 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">문자를 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 할 때 장치에 문자가 표시 될 것으로 예상되는 경우 해당 파일 핸들을 자동 플러시하고 싶을 것입니다. &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;$|&lt;/code&gt; 사용할 수 있습니다 자동 세척을 제어하는 ​​변수 (참조</target>
        </trans-unit>
        <trans-unit id="13366f7fd030f27f570c375099dc54189f595b15" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;print()&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;select()&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&quot;$|&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="translated">문자를 &lt;code&gt;print()&lt;/code&gt; 할 때 장치에 문자가 전달 될 것으로 예상하는 경우 해당 파일 핸들을 자동 플러시하는 것이 좋습니다. 당신이 사용할 수있는 &lt;code&gt;select()&lt;/code&gt; 와 &lt;code&gt;$|&lt;/code&gt; 자동 플러시 를 제어하는 ​​변수 ( &lt;a href=&quot;perlvar#%24%7C&quot;&gt;perlvar의 &quot;$ |&quot;&lt;/a&gt; 및 &lt;a href=&quot;perlfunc#select&quot;&gt;perlfunc의 &quot;select&quot;&lt;/a&gt; 또는 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; , &quot;출력 파일 핸들을 플러시 / 언 버퍼하는 방법? 왜 이렇게해야합니까?&quot;) :</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">장치에서 읽기 및 쓰기 작업을 모두 사용하려면 업데이트를 위해 장치를 열어야합니다 (자세한 내용은 &lt;a href=&quot;functions/open&quot;&gt;열기&lt;/a&gt; 참조). &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈 (표준 perl 배포의 일부 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; 를 사용하여 차단 위험을 감수하지 않고 열 수 있습니다 . 이 방법에 대한 자세한 내용은 &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c9408c9e8ecf3bf3ccb1ff9f6037ecd31cab34f" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;sysopen()&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;perlfunc#sysopen&quot;&gt;&quot;sysopen&quot; in perlfunc&lt;/a&gt; for more on this approach.</source>
          <target state="translated">장치에서 읽기 및 쓰기 작업을 모두 사용하려면 업데이트를 위해 열어야합니다 ( 자세한 내용 &lt;a href=&quot;perlfunc#open&quot;&gt;은 perlfunc의 &quot;열기&quot;&lt;/a&gt; 참조). &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈 (표준 perl 배포의 일부 &lt;code&gt;sysopen()&lt;/code&gt; 및 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; 를 사용하여 차단 위험없이 열 수 있습니다 . 이 접근 방식에 대한 자세한 내용 &lt;a href=&quot;perlfunc#sysopen&quot;&gt;은 perlfunc의 &quot;sysopen&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">254 개가 넘는 테스트에 실패하면 254로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">비활성화 할 것을 강하게 느끼면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;IO::String&lt;/code&gt; 화 된 아카이브 작성을 지원 하려면 IO :: String이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">비활성화 할 것을 강하게 느끼면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;perlio&lt;/code&gt; 아카이브를 작성하려면 perl의 perlio 지원이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3a8a7ec77511b20c4509af066f4a3c986692847a" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">비활성화에 대해 강하게 생각하는 경우이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;IO::String&lt;/code&gt; 화 된 아카이브 쓰기를 지원 하려면 IO :: String을 설치 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdfe08a0cfcd839078102e8b91b9b69bb63aa64b" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">비활성화에 대해 강하게 생각하는 경우이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;perlio&lt;/code&gt; 화 된 아카이브를 작성할 수 있으려면 perl에서 perlio 지원이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">Perl 모듈을 작성하고 싶은 충동을 느끼면 &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 가 좋은 조언을 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e8118a36fba749a624194d24477115572a55b8e" translate="yes" xml:space="preserve">
          <source>If you feel you need to use one of these functions, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that there is a good reason for the function not being documented, and it should be removed from this list; or it may just be that no one has gotten around to documenting it. In the latter case, you will be asked to submit a patch to document the function. Once your patch is accepted, it will indicate that the interface is stable (unless it is explicitly marked otherwise) and usable by you.</source>
          <target state="translated">이러한 기능 중 하나를 사용해야한다고 생각되면 먼저 &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt; 로 이메일을 보내 십시오 . 문서화되지 않은 함수에 대한 합당한 이유가있을 수 있으므로이 목록에서 제거해야합니다. 아니면 아무도 그것을 문서화하지 않았을 수도 있습니다. 후자의 경우 기능을 문서화하기 위해 패치를 제출하라는 메시지가 표시됩니다. 패치가 승인되면 인터페이스가 안정적이며 (명시 적으로 달리 표시되지 않는 한) 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">당신이 편안하게 채우면</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">버그가 발견되면 &lt;code&gt;Devel::PPPort&lt;/code&gt; 가 시스템에서 빌드되지 않거나 테스트에 실패한 경우 여기에 문제를 제기하십시오. &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55c31040a6a87b03d0eac44bd1c63f05031e2f01" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please send a bug report to &lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues/new&lt;/a&gt;.</source>
          <target state="translated">버그를 발견하거나 &lt;code&gt;Devel::PPPort&lt;/code&gt; 가 시스템에 빌드되지 않은 것 같 거나 테스트가 실패하면 &lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues&lt;/a&gt; 로 버그 보고서를 보내주세요. / new .</target>
        </trans-unit>
        <trans-unit id="6f336ce8c57722e9cc0dd1c79931ced850c7378d" translate="yes" xml:space="preserve">
          <source>If you find any other limitations or bugs then let me know.</source>
          <target state="translated">다른 제한 사항이나 버그를 발견하면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="8d6e534aca61d370cf38f89adc29a8e3c3accf6a" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can report them to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">perl에서 버그를 발견하면 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; 에보고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">당신이 펄에서 버그를 발견하면, 당신은 실행할 수 있습니다 &lt;code&gt;perlbug&lt;/code&gt; 버그 리포트를 만들 수를 (당신이 경우 수동으로 전송 할 수 있습니다 &lt;code&gt;perlbug&lt;/code&gt; 이 시스템에 우편물을 찾을 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">버그가 있거나 장치에서 전혀 작동하지 않으면 아래 주소로 메일을 보내십시오. 장치의 세부 정보 (프로세서, ceversion, 장치 유형 (hpc / palm / pocket)) 및 다운로드 한 파일의 날짜를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">Perl 배포판에서이 인스턴스를 찾으면 알려 주시면 해결해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">시스템 Perl을 업데이트해야 할 경우 정적 라이브러리와 동적 라이브러리의 문제를 염두에 두어야합니다. 기본 정적 libperl을 사용하여 업그레이드하면 Apple에서 제공 한 동적 libperl이 삭제되지 않습니다. libperl과 링크되는 응용 프로그램이 빌드 될 때 두 라이브러리가 모두 존재하면 ld는 기본적으로 동적 라이브러리와 링크됩니다. 따라서 Apple의 동적 libperl을 정적 libperl로 교체해야하는 경우 업데이트를 설치 한 후 이전 동적 라이브러리를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">Perl 애플리케이션의 특정 부분 (자주 필요한 것은 아님)의 속도를 높여야하는 경우 C를 사용할 수 있지만 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 사용하여 Perl 코드에서이 부분에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">Calc 모듈이 느리게 작동하면 교체 모듈을 설치하고 도움이되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">구현 문서가 명확하지 않거나 충분하지 않은 경우 다음을 포함하여 기존 PerlIO 계층 구현을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">이 모듈이 유용하다고 생각되면 CPAN 등급 서비스 ( &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie)&lt;/a&gt; 에서 등급을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8307a7110288b02faca83e75adb216a84beaca75" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">사용자 지정 기능을 제공해야하는 경우 ( &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps를&lt;/a&gt; 사용하는 것처럼 ) 운이 좋을 것입니다 . &lt;code&gt;TAP::Parser&lt;/code&gt; 와 친구들은 쉽게 연결 및 / 또는 하위 클래스 화되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps를&lt;/a&gt; 사용하는 것처럼 사용자 정의 기능을 제공해야하는 경우 운이 좋을 것입니다 . &lt;code&gt;TAP::Parser&lt;/code&gt; 및 friends는 쉽게 플러그인 및 / 또는 서브 클래스되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="e0f3870d3b01febf6f7490ea91b0d476cdafaf0c" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt;.</source>
          <target state="translated">자체 반복기 팩토리를 사용해야하는 경우 &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; 를 설정하여 &lt;code&gt;TAP::Parser&lt;/code&gt; 를 하위 클래스 화하지 않고도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">당신이 찾아내는 경우에 당신은 정말 당신이 여전히 하위 클래스라는없이 그렇게 할 수 있습니다 자신의 반복자 공장을 사용할 필요가 &lt;code&gt;TAP::Parser&lt;/code&gt; 설정하여 &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">어떤 이유로 (이진 역 호환성과 같은) 실제로 perl의 malloc을 사용해야하는 경우 소스에서 perl을 다시 빌드하고 다음으로 빌드를 구성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 을 잊어 버린 경우 높은 바이트는 별도의 문자로 오해되며 아무것도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c95ef6991d8327e95ef74bf4e7dd1e20f49af62" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;use utf8&lt;/code&gt;, high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 을 잊어 버리면 높은 바이트가 별도의 문자로 오해되고 아무 것도 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 을 잊어 버린 경우 유용한 진단 메시지를 완전히 놓치게됩니다.</target>
        </trans-unit>
        <trans-unit id="f4036448bea62235f8e0ea98c0684157616bfe9e" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;use warnings&lt;/code&gt;, you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">&lt;code&gt;use warnings&lt;/code&gt; 을 잊은 경우 유용한 진단 메시지를 완전히 놓치게됩니다.</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">코어 덤프 (또는 이와 동등한)를 얻는 경우 디버거 ( &lt;b&gt;dbx&lt;/b&gt; , &lt;b&gt;gdb&lt;/b&gt; 등)를 사용하여 버그 보고서에 포함 할 스택 추적을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">&quot;perl : command not found&quot;와 같은 메시지가 표시되면 perl이 PATH에없는 것입니다. 이는 perl의 위치가 원하는 위치가 아니므로 shebang 라인을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">다음과 같은 오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">오류 메시지가 나타나면</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">so_locations에 대한 불만이 있으면 hints / irix_6.sh 파일에서 &quot;lddflags&quot;를 검색하고 제안 된 조정을 수행하십시오. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">양식에 많은 오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="39b025fcc6f0d1c529cf233b24ac57e017d8f611" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt;.</source>
          <target state="translated">SunOS 또는 Solaris에서이 메시지가 표시되고 gcc를 사용중인 경우 이전 항목 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt; 의 GNU as 또는 GNU ld 문제 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">SunOS 또는 Solaris에서이 메시지가 표시되고 gcc를 사용중인 경우 이전 항목 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as 및 GNU ld&lt;/a&gt; 의 GNU as 또는 GNU ld 문제 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">플랫폼의 고유 정수에 노출되는 데 지치면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 문제를 완전히 회피 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ba4fd6db8745c64a8a60725ff36af2b0505794" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;use bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">플랫폼의 기본 정수에 종속되는 것에 지쳤다면 &lt;code&gt;use bigint&lt;/code&gt; pragma를 사용 하면 문제를 깔끔하게 회피 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; 라고 지속적으로 말하기에 지치면 다음과 같이 기능적 래퍼를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f2e5f31a627306a3c5068e17e18a085ffc1169d9" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt;, consider making a functional wrapper for it, like so:</source>
          <target state="translated">계속해서 &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt; 라고 말하는 것에 지쳤다 면, 다음과 같이 기능적인 래퍼를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="572c0959177d510f33c38a6508a8f796163c8877" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;a href=&quot;File::stat&quot;&gt;&lt;code&gt;File::stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::hostent&quot;&gt;&lt;code&gt;Net::hostent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::netent&quot;&gt;&lt;code&gt;Net::netent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::protoent&quot;&gt;&lt;code&gt;Net::protoent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::servent&quot;&gt;&lt;code&gt;Net::servent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::gmtime&quot;&gt;&lt;code&gt;Time::gmtime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::localtime&quot;&gt;&lt;code&gt;Time::localtime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;User::grent&quot;&gt;&lt;code&gt;User::grent&lt;/code&gt;&lt;/a&gt;. These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">반환 목록의 어떤 요소에 어떤 반환 값이 포함되어 있는지 기억 나지 않는다면 표준 모듈에서 이름 별 인터페이스가 제공됩니다. &lt;a href=&quot;File::stat&quot;&gt; &lt;code&gt;File::stat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Net::hostent&quot;&gt; &lt;code&gt;Net::hostent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Net::netent&quot;&gt; &lt;code&gt;Net::netent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Net::protoent&quot;&gt; &lt;code&gt;Net::protoent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Net::servent&quot;&gt; &lt;code&gt;Net::servent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Time::gmtime&quot;&gt; &lt;code&gt;Time::gmtime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;Time::localtime&quot;&gt; &lt;code&gt;Time::localtime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;User::grent&quot;&gt; &lt;code&gt;User::grent&lt;/code&gt; &lt;/a&gt; . 이는 일반 내장 기능을 재정 의하여 각 필드에 적절한 이름을 가진 객체를 반환하는 버전을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">리턴리스트의 어떤 요소가 어떤 리턴 값을 포함하는지 기억하는 데 지치면 표준 모듈에 이름 별 인터페이스가 제공됩니다. &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; 및 &lt;code&gt;User::grent&lt;/code&gt; 입니다. 이들은 기본 제공되는 기본 제공을 대체하여 각 필드에 적절한 이름을 가진 오브젝트를 리턴하는 버전을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">다음과 같이 이상한 것을 쓰는 데 익숙하다면 :</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">그러한 패키지 변수가 존재하는지 여부를 확인하기 위해 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; 를 &lt;a href=&quot;functions/defined&quot;&gt;정의한&lt;/a&gt; 경우 실제로는 신뢰할 수 없으며 패키지의 기능 또는로드 여부 등을 문의하는 좋은 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3a8d785689c76bcc85c3a87585c7936ee4bbbc6c" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">이러한 패키지 변수가 있는지 확인하기 위해 &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; 를 정의한 경우에는 실제로 신뢰할 수 없으며 패키지의 기능이나로드 여부 등을 조회하는 좋은 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">변수를 가져와야한다면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">당신이 가지고 있다면</target>
        </trans-unit>
        <trans-unit id="5887bd3238a6e02f0034680e74b35124b3f3183f" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;File::Stream&quot;&gt;파일 :: 스트림&lt;/a&gt; 이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="aebe0c8d3505d2fdad4a2b644054c80705f47533" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;Term::ReadKey&quot;&gt;기간 :: ReadKey&lt;/a&gt; CPAN에서 설치 모듈을, 당신은 문자와 폭과 높이를 픽셀 단위로 가져 오는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;파일 :: 스트림&lt;/a&gt; 이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;기간 :: ReadKey&lt;/a&gt; CPAN에서 설치 모듈을, 당신은 문자와 폭과 높이를 픽셀 단위로 가져 오는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7230ece2e031d91cec5a13b629b5ff58c45c8753" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;IPC::Run&lt;/code&gt; 설치, 변수 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 합니다 (참조 true로 설정되어있는 &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;전역 변수&quot;&lt;/a&gt; 명령을 실행하는 것을 사용 절). 버퍼에서 전체 출력을 사용할 수 있으며, 대화 형 명령이 작동하고 자세한 정보 설정이 명확하게 적용되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;IPC::Run&lt;/code&gt; 설치, 변수 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 합니다 (참조 true로 설정되어있는 &lt;a href=&quot;#Global-Variables&quot;&gt;글로벌 변수&lt;/a&gt; 명령을 실행하는 것을 사용 절). 버퍼에서 전체 출력을 사용할 수 있으며 대화식 명령이 작동하며 자세한 설정을 깨끗하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;man&lt;/code&gt; 시스템에 설치되어, 당신은 펄 맨이 같이 사용 무언가를 설치 :</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">Perl 5.10 이상이 있고 나중에 조회를 위해 참조에 대한 값을 저장하려는 경우 핵심 Hash :: Util :: Fieldhash 모듈을 사용할 수 있습니다. 또한 여러 스레드를 사용하는 경우 (모든 주소가 새 주소에 재 할당되고 문자열이 변경됨) 참조 된 변수가 범위를 벗어날 때 항목을 가비지 수집하는 경우 키 이름 바꾸기를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">Perl 5.10 이상이 있으면 거의 사소합니다. 당신은 정규 표현식 객체의 배열과 똑똑하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f112acda35554c21f927d9597b0b2023538c4e09" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">Perl v5.16 또는 v5.18이 있고 업그레이드 할 수없는 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">Perl v5.16을 사용하는 경우 &lt;code&gt;:not_characters&lt;/code&gt; 매개 변수를 로케일 pragma에 사용하면 위에서 언급 한 문제점이 사라집니다 (문자 이외의 부분에서 벤더 버그 제외). v5.16이없고</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">당신이 YAML.pm (또는 구성 다른 YAML 모듈이있는 경우 &lt;code&gt;yaml_module&lt;/code&gt; ) 설치, CPAN.pm 최근 다운로드에 대한 몇 가지 통계 데이터를 수집합니다. &lt;code&gt;hosts&lt;/code&gt; 명령으로 통계를 보거나 &lt;code&gt;cpan_home&lt;/code&gt; 디렉토리 의 &lt;code&gt;FTPstats.yml&lt;/code&gt; 파일을 찾아서 직접 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">당신이의 readline 모듈이 설치되어있는 경우, 당신은 명령 줄의 어느 지점에서 TAB을 칠 수와 &lt;code&gt;o conf&lt;/code&gt; 당신에 대한 완료를 제공 할 것입니다 내장 하위 명령 및 / 또는 설정 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">Newx ()로 할당 된 버퍼가 있고이를 SV 값으로 설정하려면 sv_usepvn_flags ()를 사용할 수 있습니다. 펄이 후행 NUL에 맞게 버퍼를 다시 할당하는 것을 피하려면 몇 가지 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">발표에 대해 전 세계에 알리고 싶은 마음이 있다면 중재 된 &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; 뉴스 그룹에 공지 사항을 게시하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">작업을 수행하는 명령 줄 프로그램이있는 경우 출력을 캡처하기 위해 백틱으로 호출하여 나중에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">커밋 비트가있는 경우 git 사용에 대한 자세한 내용 은 &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">정렬하려는 부분을 꺼내기 위해 복잡한 기능이 필요한 경우 정렬 기능 내에서 수행하지 마십시오. 동일한 요소에 대해 정렬 BLOCK을 여러 번 호출 할 수 있으므로 먼저 빼냅니다. 다음은 각 항목에서 첫 번째 숫자 다음에 첫 번째 단어를 가져온 다음 대소 문자를 구분하지 않고 정렬하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">레거시 인코딩이있는 경우 &lt;code&gt;:encoding(...)&lt;/code&gt; 태그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">API를 제공하는 라이브러리가있는 경우 C 또는 C ++로 작성되고 기본 Perl 인터프리터에 동적으로 링크 된 Perl 확장을 사용하여 해당 컴포넌트의 컴포넌트를 다른 Perl 함수 또는 변수로 사용할 수 있습니다. 다른 방향으로 가고 C 또는 C ++로 기본 프로그램을 작성한 다음 즉시 Perl 코드로 링크하여 강력한 응용 프로그램을 만들 수 있습니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">파일에 테스트 목록 (또는 URL 또는 테스트하려는 다른 것)이있는 경우 '-'를 사용하여 테스트에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">CPAN의 로컬 미러가 있고 &quot;file :&quot;URL을 사용하여 모든 파일에 액세스 할 수있는 경우이 모듈을 실행하려면 perl5.003 이후의 perl 만 있으면됩니다. 그렇지 않으면 Net :: FTP를 적극 권장합니다. UNIX 이외의 시스템 또는 가장 가까운 CPAN 사이트가 &lt;code&gt;ftp:&lt;/code&gt; 가 아닌 URL과 연관된 경우 LWP가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc89a24f0e796df127e886da4fce9233949042a4" translate="yes" xml:space="preserve">
          <source>If you have a module that uses a decimal $VERSION (floating point), and you do not intend to ever change that, this module is not for you. There is nothing that version.pm gains you over a simple $VERSION assignment:</source>
          <target state="translated">십진수 $ VERSION (부동 소수점)을 사용하는 모듈이 있고이를 변경하지 않으려는 경우이 모듈은 적합하지 않습니다. version.pm이 간단한 $ VERSION 할당을 통해 얻을 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="44d0404e38c1a8f4fe7f4884e84970ffe1a562e8" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please either:</source>
          <target state="translated">FAQ에 추가 되었으면하는 질문이있는 경우 (답변 여부에 관계없이) 다음 중 하나를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">궁금한 사항이 있으시면 FAQ에 추가하고 싶을 경우 (답이 있는지 없는지) makemaker@perl.org로 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">특정 인코딩을 통해 해석해야하는 원시 바이트 시퀀스가있는 경우 &lt;code&gt;Encode&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b4a02619440b043ea55b1e3e613964a4f9957c4" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt;:</source>
          <target state="translated">특정 인코딩을 통해 해석되어야하는 원시 바이트 시퀀스가있는 경우 &lt;code&gt;Encode&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">정말 털이 많은 정규 표현식이있는 경우 &lt;code&gt;/x&lt;/code&gt; 수정자를 사용하고 공백을 넣어 줄 노이즈와 비슷하게 만듭니다. 정규 표현식에 슬래시 또는 백 슬래시가 있으면 슬래시를 구분 기호로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="df35f05fcbbff85a11dabd04bca96051a29d5068" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; or &lt;code&gt;/xx&lt;/code&gt; modifiers and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">정말 털이 많은 정규식이 있다면 &lt;code&gt;/x&lt;/code&gt; 또는 &lt;code&gt;/xx&lt;/code&gt; 수정자를 사용하고 약간의 공백을 넣어 라인 노이즈처럼 보이게 만듭니다. 정규 표현식에 슬래시 또는 백 슬래시가있는 경우 슬래시를 구분 기호로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">&lt;b&gt;알고&lt;/b&gt; 있는 바이트 시퀀스 가 유효한 UTF-8이지만 Perl이 아직 알지 못하는 경우 Perl도 신자로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">여러 문자열에 대해 &quot;equal in locale&quot;을 확인하려는 단일 문자열이있는 경우 &lt;code&gt;eq&lt;/code&gt; 와 함께 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 을 사용하면 약간의 효율성을 얻을 수 있다고 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f95d4b51e2c5877925e6bfc513dc2300a8f4721e" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">&quot;로케일에서 같음&quot;을 확인하려는 단일 문자열이있는 경우 &lt;code&gt;eq&lt;/code&gt; 와 함께 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 을 사용하여 약간의 효율성을 얻을 수 있다고 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">제출할 작은 패치가있는 경우 perlbug를 통해 제출하십시오. perlbug@perl.org로 직접 이메일을 보낼 수도 있습니다. perlbug로 전송 된 메시지는 중재 대기열에 보관 될 수 있으므로 즉시 응답을받지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5776918dce21a614ab7d2b6b104a983a49243a" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via the GitHub Pull Request workflow. You may also send patches to the p5p list.</source>
          <target state="translated">제출할 작은 패치가있는 경우 GitHub Pull Request 워크 플로를 통해 제출하세요. 패치를 p5p 목록으로 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">특정 로마자 표기법을 염두에두고 있으면 특정 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">작동하는 &lt;code&gt;DynaLoader&lt;/code&gt; 가있는 경우 다른 확장에서 정적으로 링크 할 필요가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">여러 멤버를 포함하는 zip 파일이 있고 파일에서 특정 멤버를 읽으려면 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 과 같이 &lt;code&gt;Name&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6052cdbbf6fcaf2baac87ba7e1b86897c2e18ac9" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">여러 구성원을 포함하는 zip 파일이 있고 파일에서 특정 구성원을 읽으려면 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 이라고 말하고 &lt;code&gt;Name&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">당신은 FTP 프록시 방화벽 (있는 경우 &lt;b&gt;NOT&lt;/b&gt; HTTP 또는 SOCKS 방화벽)이 값은 방화벽 호스트 이름으로 설정해야합니다. 방화벽이 포트 21을 수신하지 않으면이 값을 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; 로 설정해야합니다 (예 : &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3ebb071202346598d9545555072b8cd9d0e64671" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt;)</source>
          <target state="translated">당신은 FTP 프록시 방화벽 (있는 경우 &lt;b&gt;NOT&lt;/b&gt; HTTP 또는 SOCKS 방화벽)이 값은 방화벽 호스트 이름으로 설정해야합니다. 방화벽이 포트 21을 수신하지 않는 경우이 값은 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; 로 설정해야합니다 (예 : &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">SV가 있고 Perl에 어떤 종류의 데이터가 저장되어 있다고 생각되는지 알고 싶다면 다음 매크로를 사용하여 SV 유형을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">연결하고 정규화 해야하는 &lt;code&gt;@string&lt;/code&gt; 배열이 있으면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">빈 디렉토리가 있으면 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . 디렉토리가 비어 있지 않은 경우 (파일 또는 하위 디렉토리가없는 경우) 직접 비우거나 (많은 작업) 모듈을 사용하여 도움을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="e617c76fa41bca088e2fe925791d55bef7f3208c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;rmdir&lt;/code&gt;. If the directory is not empty (so, with files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">빈 디렉토리가 있으면 Perl의 내장 &lt;code&gt;rmdir&lt;/code&gt; 을 사용할 수 있습니다 . 디렉토리가 비어 있지 않은 경우 (파일 또는 하위 디렉토리 포함) 직접 비우거나 (많은 작업) 모듈을 사용하여 도움을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">기존 인사이드 아웃 클래스가있는 경우 다른 변경없이 모든 해시 필드 해시를 만들면 아무런 차이가 없습니다. &lt;code&gt;refaddr&lt;/code&gt; 또는 동등한 항목에 대한 호출을 통해 필드 해시는 절대 참조를 보지 않고 일반 해시처럼 작동합니다. DESTROY (및 CLONE) 방법이 여전히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">이전 버전의 Perl이있는 경우 &lt;code&gt;$^W&lt;/code&gt; 변수 ( &lt;a href=&quot;perlvar&quot;&gt;perlvar에&lt;/a&gt; 문서화 됨 )는 블록에 대한 런타임 경고를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">이스케이프해야 할 다른 문자가 있으면 CPAN에서 &lt;code&gt;URI::Escape&lt;/code&gt; 모듈을 설치하고 URI 를 &lt;code&gt;File::Fetch&lt;/code&gt; 전달하기 전에 미리 인코딩하십시오 . URI 및 URI 인코딩에 대한 자세한 내용은 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3a311e2f3de5d8bd7b59c7e63cc0db7c3de9dbd" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt;. You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">이스케이프해야하는 다른 문자가있는 경우 CPAN에서 &lt;code&gt;URI::Escape&lt;/code&gt; 모듈을 설치하고 URI 를 &lt;code&gt;File::Fetch&lt;/code&gt; 전달하기 전에 미리 인코딩하십시오 . 여기에서 URI 및 URI 인코딩에 대한 세부 정보를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baafc393e6c194ed8ae0aabf8fee882236c21df9" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, ask someone familiar with Perl on your operating system, or if all else fails, file a ticket at &lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">이 페이지에 대해 제안 된 변경 사항이 있으면 알려주십시오. 모듈 설치 방법에 대한 도움을 요청하는 메일을 보내지 마십시오. 모듈이 너무 많고 Orwants가 너무 적어서 모든 질문에 답하거나 인정할 수 없습니다. 대신 모듈 작성자에게 문의하거나 운영 체제에서 Perl에 익숙한 사람에게 문의하거나, 다른 모든 방법이 실패하면 &lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt; 에서 티켓을 제출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">이 페이지에 대한 제안 된 변경 사항이 있으면 알려주십시오. 모듈 설치 방법에 대한 도움을 요청하는 메일을 보내지 마십시오. 모든 질문에 대답하거나 인정할 수있는 너무 많은 모듈과 너무 적은 Orwants가 있습니다. 대신 모듈 작성자에게 문의하거나 comp.lang.perl.modules에 게시하거나 운영 체제에서 Perl에 익숙한 사람에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">zlib&amp;gt; = 1.2.0으로이 모듈을 빌드 한 경우 &lt;code&gt;$eof&lt;/code&gt; 매개 변수는 무시됩니다. 원하는 경우 계속 설정할 수 있지만 장면 뒤에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd7c754383786ab750ba8d8b8b5b2710b62cfc9e" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</source>
          <target state="translated">zlib 1.2.3 이상으로이 모듈을 빌드 한 경우 두 개의 CRC 관련 기능을 더 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49d178439aabd6902535000d809a8c4d8c6c0d0" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statements), these will</source>
          <target state="translated">컴파일 타임 실행 문이있는 경우 (예 : BEGIN, UNITCHECK 및 CHECK 블록 내의 코드 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 명령문)</target>
        </trans-unit>
        <trans-unit id="23cdaab0976c373088c475389e1f28133a88c5c3" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;use&lt;/code&gt; statements), these will</source>
          <target state="translated">컴파일 타임 실행 가능 문 (예 : BEGIN, UNITCHECK 및 CHECK 블록 내의 코드 또는 &lt;code&gt;use&lt;/code&gt; 문)이있는 경우</target>
        </trans-unit>
        <trans-unit id="4a053828197d3de496e658e2f64e31f462c0e7ce" translate="yes" xml:space="preserve">
          <source>If you have experience with other thread implementations, you might find that things aren't quite what you expect. It's very important to remember when dealing with Perl threads that</source>
          <target state="translated">다른 스레드 구현 경험이 있다면 예상 한 것과 다른 것이 발견 될 수 있습니다. Perl 스레드를 다룰 때 기억하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0ffa35b58c4462159f2ea02872365ed984d54889" translate="yes" xml:space="preserve">
          <source>If you have found a bug with a non-standard port (one that was not part of the</source>
          <target state="translated">비표준 포트에 버그가 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="0e1af930aa8bf951949bff6fef33b900fd538735" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt; &quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot; is sufficient.</source>
          <target state="translated">&lt;code&gt;make test_static&lt;/code&gt; 으로 이러한 정적으로 링크 된 실행 파일을 생성 한 경우 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 라고 말하지 않고 &quot; make test_static &quot; 이라고 말해야 합니다. 동적으로로드 가능한 라이브러리를 전혀 구축 할 수없는 시스템에서는 단순히 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 라고 말하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="23bdd0e95f3443590926733fe84eb18d18c20c8a" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt;&quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt;&quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt;&quot; is sufficient.</source>
          <target state="translated">정적으로 링크 된 실행 파일을 &lt;code&gt;make test_static&lt;/code&gt; 으로 생성했다면 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 대신 &quot; make test_static &quot; 이라고 말해야 합니다. 동적으로로드 할 수있는 라이브러리를 전혀 빌드 할 수없는 시스템에서는 단순히 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 라고 말하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="ea57a23a75f969a9e5ed037d598a374a300583a4" translate="yes" xml:space="preserve">
          <source>If you have gotten this far into the tutorial, you can probably guess what the different parts of the debugging output tell you. The first part</source>
          <target state="translated">이 과정을 통해 튜토리얼을 살펴 보았다면 디버깅 출력의 다른 부분이 무엇을 말해 줄지 추측 할 수 있습니다. 첫 번째 부분</target>
        </trans-unit>
        <trans-unit id="9d264a66a026ef716495bcfe67d5b82c2fd75d79" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt; , the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">당신을위한 신호 처리기를 설치 한 경우 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 가치 &lt;code&gt;$?&lt;/code&gt; 일반적으로 해당 핸들러 외부에서 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c96322abc1990a9be6677edc2fb6d0c6fb9d00" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt;, the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">&lt;code&gt;SIGCHLD&lt;/code&gt; 에 대한 신호 처리기를 설치 한 경우 &lt;code&gt;$?&lt;/code&gt; 일반적으로 해당 핸들러 외부에서 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="d59e8efecc586326d2ab32c89e976a471be555e8" translate="yes" xml:space="preserve">
          <source>If you have installed extra libraries such as GDBM through Fink (in other words, you have libraries under</source>
          <target state="translated">Fink를 통해 GDBM과 같은 추가 라이브러리를 설치 한 경우 (즉,</target>
        </trans-unit>
        <trans-unit id="30e77bf1c945abc2f9365943feb77a853899df5c" translate="yes" xml:space="preserve">
          <source>If you have loaded the &lt;a href=&quot;posix&quot;&gt;&lt;code&gt;POSIX&lt;/code&gt;&lt;/a&gt; module you can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; to safely change or query the locale (on systems where it is safe to do so), or you can use the new 5.28 function &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&quot;Perl_setlocale&quot; in perlapi&lt;/a&gt; instead, which is a drop-in replacement for the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt;, and handles single-threaded and multi-threaded applications transparently.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt; &lt;code&gt;POSIX&lt;/code&gt; &lt;/a&gt; 모듈을 로드 한 경우에는 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 에 제공된 메소드를 사용하여 &lt;a href=&quot;posix#setlocale&quot;&gt; &lt;code&gt;POSIX::setlocale&lt;/code&gt; &lt;/a&gt; 을 호출 하여 로케일을 안전하게 변경하거나 쿼리하거나 (안전한 시스템에서) 새로운 5.28 함수 &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&quot;Perl_setlocale을&lt;/a&gt; 사용할 수 있습니다. &quot; 대신 perlapi 에서 시스템 &lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt; 대한 드롭 인 대체이며 단일 스레드 및 다중 스레드 응용 프로그램을 투명하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="adf0535478f796f8c19ba9c98c90186d9fd4978f" translate="yes" xml:space="preserve">
          <source>If you have more than two files, this is the place where you should boot extra XS files from.</source>
          <target state="translated">파일이 두 개 이상인 경우 여분의 XS 파일을 부팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="47f402ce95a3894708d131d4f57afb65a8408c3a" translate="yes" xml:space="preserve">
          <source>If you have neither Net::FTP nor LWP, there is a fallback mechanism implemented for an external ftp command or for an external lynx command.</source>
          <target state="translated">Net :: FTP 또는 LWP가없는 경우 외부 ftp 명령 또는 외부 lynx 명령에 대해 대체 메커니즘이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="24c715fba81da2278914f96579f9af2c125fe732" translate="yes" xml:space="preserve">
          <source>If you have never been to a hackathon, here are a few basic things you need to know before attending: have a working laptop and know how to use it; check out the involved projects beforehand; have the necessary version control client; and bring backup equipment (an extra LAN cable, additional power strips, etc.) because someone will forget.</source>
          <target state="translated">해커 톤에 가본 적이 없다면, 참석하기 전에 알아야 할 몇 가지 기본 사항은 다음과 같습니다. 랩탑이 작동하고 사용 방법을 알고 있어야합니다. 관련 프로젝트를 미리 확인하십시오. 필요한 버전 관리 클라이언트가 있어야합니다. 다른 사람이 잊어 버릴 수 있으므로 백업 장비 (추가 LAN 케이블, 추가 전원 스트립 등)를 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb2a3bd6bb2269e089bc5caced075f60ca01d0a" translate="yes" xml:space="preserve">
          <source>If you have never defined your own &lt;code&gt;urllist&lt;/code&gt; in your configuration then &lt;code&gt;CPAN.pm&lt;/code&gt; will be hesitant to use the built in default sites for downloading. It will ask you once per session if a connection to the internet is OK and only if you say yes, it will try to connect. But to avoid this question, you can choose your favorite download sites once and get away with it. Or, if you have no favorite download sites answer yes to the following question.</source>
          <target state="translated">구성에서 고유 한 &lt;code&gt;urllist&lt;/code&gt; 를 정의하지 않은 경우 &lt;code&gt;CPAN.pm&lt;/code&gt; 은 기본 제공 기본 사이트를 사용하여 다운로드하는 것을 주저합니다. 인터넷 연결이 정상인지 세션 당 한 번 묻고 예라고 대답하는 경우에만 연결을 시도합니다. 그러나이 질문을 피하기 위해 즐겨 찾는 다운로드 사이트를 한 번 선택하여 벗어날 수 있습니다. 또는 즐겨 찾는 다운로드 사이트가없는 경우 다음 질문에 예라고 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb5903dce5dded96414f72da47519a1cbbb4440" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">이전에 CPAN에 모듈을 업로드 한 적이 없다면 &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt; 에 대한 피드백을받는 것이 좋습니다 . PrePAN은 CPAN 모듈에 대한 아이디어를 다른 Perl 개발자와 논의하는 데 전념하는 사이트이며 신규 (및 숙련 된) Perl 개발자를위한 훌륭한 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="7a84d97dce110800ef0a7f4d11d992d7a0415274" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">CPAN에 모듈을 업로드 한 적이없는 경우 (있는 경우에도), &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt; 에 대한 피드백을받는 것이 좋습니다 . PrePAN은 다른 Perl 개발자와 CPAN 모듈에 대한 아이디어를 논의하기위한 사이트이며 새로운 Perl 개발자를위한 훌륭한 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="69b676873a6496894a8ce65e0d6abefddf731b2d" translate="yes" xml:space="preserve">
          <source>If you have not guessed it yet, the</source>
          <target state="translated">아직 추측하지 못했다면</target>
        </trans-unit>
        <trans-unit id="eb6ae544b0243a12b93b26e3f0b3956b5515717f" translate="yes" xml:space="preserve">
          <source>If you have one of the readline packages (Term::ReadLine::Perl, Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN shell will have history support. The next two questions deal with the filename of the history file and with its size. If you do not want to set this variable, please hit SPACE ENTER to the following question.</source>
          <target state="translated">readline 패키지 중 하나 (Term :: ReadLine :: Perl, Term :: ReadLine :: Gnu 등)가 설치되어 있으면 대화식 CPAN 쉘은 히스토리를 지원합니다. 다음 두 질문은 기록 파일의 파일 이름과 크기를 처리합니다. 이 변수를 설정하지 않으려면 다음 질문에 SPACE ENTER를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="bb7b55bdb52c9b6a39041d0271244a521cb3ff47" translate="yes" xml:space="preserve">
          <source>If you have perl documentation in the source form, perl utilities installed, and GNU groff installed, you may use</source>
          <target state="translated">소스 형식의 perl 문서, perl 유틸리티 및 GNU groff가 설치된 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841004095d25b3d59f531a821f770d0871403ca9" translate="yes" xml:space="preserve">
          <source>If you have previously used &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, the following enhancements/changes have been made to the &lt;code&gt;gzopen&lt;/code&gt; interface:</source>
          <target state="translated">이전에 &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x를 사용한 경우 &lt;code&gt;gzopen&lt;/code&gt; 인터페이스 가 다음과 같이 개선 / 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d0935b429ee79675810171542b17a2b721980e73" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt; above.</source>
          <target state="translated">SunOS 또는 Solaris에서 gcc를 사용한 동적로드에 문제가 있고 GNU를 및 GNU ld로 사용하는 경우 위의 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU 및 GNU ld&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2a37b8d2199c6cd81ec323e698311d35b1e6c13" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt; above.</source>
          <target state="translated">SunOS 또는 Solaris에서 gcc를 사용한 동적 로딩에 문제가 있고 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as 및 GNU ld를 사용하는 경우&lt;/a&gt; 위의 GNU as 및 GNU ld 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea5710225473b92c4d4337a393fa28ea045d7828" translate="yes" xml:space="preserve">
          <source>If you have questions about DJGPP, try posting to the DJGPP newsgroup: comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.</source>
          <target state="translated">DJGPP에 대한 질문이있는 경우 DJGPP 뉴스 그룹 (comp.os.msdos.djgpp)에 게시하거나 이메일 게이트웨이 djgpp@delorie.com을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0f8d11e3dbd4746ff7b4eeb245a0d52d534f6e" translate="yes" xml:space="preserve">
          <source>If you have questions, I will be happy to answer them if you send them to mjd-perl-memoize+@plover.com.</source>
          <target state="translated">질문이 있으시면 mjd-perl-memoize+@plover.com으로 보내 주시면 기꺼이 답변 해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="f26f03ce6e7bfe1cbb7f3ba37413ced07d1e0917" translate="yes" xml:space="preserve">
          <source>If you have read this far, congratulations! You now have all the basic tools needed to use regular expressions to solve a wide range of text processing problems. If this is your first time through the tutorial, why not stop here and play around with regexps a while.... Part 2 concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</source>
          <target state="translated">이 글을 읽었다면 축하합니다! 이제 광범위한 텍스트 처리 문제를 해결하기 위해 정규식을 사용하는 데 필요한 모든 기본 도구가 있습니다. 이 튜토리얼을 처음 접하는 분이라면 여기에서 멈추고 정규 표현식으로 잠시 놀아보십시오. 2 부에서는 정규 표현식의 좀 더 난해한 측면에 대해 다루고 있으며 이러한 개념은 시작시 바로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d2bd9a5983ab6b077a9576a5fb009ebd58ad9d0" translate="yes" xml:space="preserve">
          <source>If you have received a patch file generated using the above section, you should try out the patch.</source>
          <target state="translated">위 섹션을 사용하여 생성 된 패치 파일을 받으 셨다면 패치를 시험해 보셔야합니다.</target>
        </trans-unit>
        <trans-unit id="75f3eda9f9b422ec46068b583597695f9e1e075d" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, installed the Perl documentation in the source form, and Perl utilities, you can build HTML docs. Cd to directory with</source>
          <target state="translated">사용 가능한 WWW 브라우저가 있고 소스 양식으로 Perl 문서 및 Perl 유틸리티를 설치 한 경우 HTML 문서를 빌드 할 수 있습니다. 디렉토리에 CD</target>
        </trans-unit>
        <trans-unit id="15919d939102f998b0d1a3071b0bdc4ec9361810" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, you can build &lt;b&gt;HTML&lt;/b&gt; docs. Cd to directory with</source>
          <target state="translated">사용 가능한 WWW 브라우저가 있으면 &lt;b&gt;HTML&lt;/b&gt; 문서를 작성할 수 있습니다 . 디렉토리에 CD</target>
        </trans-unit>
        <trans-unit id="760a427c6aacab9e74e50c0e342e67f06ea0a89d" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt; , please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">&lt;code&gt;OS2::Cmd&lt;/code&gt; 대한 작업 코드가 있으면 나에게 보내주십시오. 배포에 포함시킬 것입니다. 그러한 모듈이 필요하지 않으므로 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92b80366e1063cc2e2041c74ed4ea55af2ea445a" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt;, please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">&lt;code&gt;OS2::Cmd&lt;/code&gt; 대한 작동 코드가있는 경우 저에게 보내 주시면 배포에 포함하겠습니다. 그런 모듈이 필요하지 않으므로 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c766c1d4e406f5a8fab49e64104f5bd544a7e67b" translate="yes" xml:space="preserve">
          <source>If you have test cases that fail, check for the existence of spool files. The test case may be trying to use a syscall that is not implemented in PASE. To avoid the SIGILL, try setting the PASE_SYSCALL_NOSIGILL environment variable or have a handler for the SIGILL. If you can compile programs for PASE, run the config script and edit config.sh when it gives you the option. If you want to remove fchdir(), which isn't implement in V5R1, simply change the line that says:</source>
          <target state="translated">실패한 테스트 케이스가있는 경우 스풀 파일이 있는지 확인하십시오. 테스트 케이스가 PASE에서 구현되지 않은 syscall을 사용하려고 시도했을 수 있습니다. SIGILL을 피하려면 PASE_SYSCALL_NOSIGILL 환경 변수를 설정하거나 SIGILL에 대한 핸들러를 사용하십시오. PASE 용 프로그램을 컴파일 할 수 있으면 config 스크립트를 실행하고 옵션이 제공 될 때 config.sh를 편집하십시오. V5R1에서 구현되지 않은 fchdir ()을 제거하려면 다음과 같은 행을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c895956df28d2a0d520a665ed39e5054b694f69f" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;Kwalify&lt;/code&gt; module installed (which is part of the Bundle::CPANxxl), then all your distroprefs files are checked for syntactic correctness.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;Kwalify&lt;/code&gt; 의 (번들 :: CPANxxl의 일부입니다) 모듈을 설치 한 후 모든 distroprefs 파일을 구문 정확성을 위해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="310e2cf6fe93a96344e5f48617c55b650052b357" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;uncompress&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;uncompress&lt;/code&gt; 프로그램을 사용할 수, 당신은 압축 된 파일을 읽을 이것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a48f13710ced892050924fc9519945fba0fac1d0" translate="yes" xml:space="preserve">
          <source>If you have the GNU's version of &lt;b&gt;emacs&lt;/b&gt; installed on your system, it can interact with the Perl debugger to provide an integrated software development environment reminiscent of its interactions with C debuggers.</source>
          <target state="translated">시스템에 GNU &lt;b&gt;emacs&lt;/b&gt; 버전이 설치되어 있으면 Perl 디버거와 상호 작용하여 C 디버거와의 상호 작용을 연상시키는 통합 소프트웨어 개발 환경을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="831bd1aa0f0b4a83cdb4f8d8c798aaee5e24ba5d" translate="yes" xml:space="preserve">
          <source>If you have the LD_LIBRARY_PATH environment variable set, be sure that it does NOT include /lib or /usr/lib. If you will be building extensions that call third-party shared libraries (e.g. Berkeley DB) then make sure that your LD_LIBRARY_PATH environment variable includes the directory with that library (e.g. /usr/local/lib).</source>
          <target state="translated">LD_LIBRARY_PATH 환경 변수가 설정되어 있으면 / lib 또는 / usr / lib를 포함하지 않아야합니다. 타사 공유 라이브러리 (예 : Berkeley DB)를 호출하는 확장을 빌드하는 경우 LD_LIBRARY_PATH 환경 변수에 해당 라이브러리가있는 디렉토리 (예 : / usr / local / lib)가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="483a6567552062a96a05353738254e25f5829f05" translate="yes" xml:space="preserve">
          <source>If you have the earlier ports perl 5.16 or 5.8 installed you may like to rename your perl executable to perl516 or perl58 or something similar before the installation of 5.22.1, this will allow you to use both versions at the same time.</source>
          <target state="translated">이전 포트 perl 5.16 또는 5.8이 설치되어있는 경우, 5.22.1을 설치하기 전에 perl 실행 파일의 이름을 perl516 또는 perl58 또는 이와 유사한 이름으로 바꾸고 싶을 수 있습니다. 이렇게하면 두 버전을 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b99419c67def721d2695cd48d34dc88cb8c781c" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">많은 C 구조를 처리하고 모든 템플릿 문자열을 수동으로 해킹하고 싶지 않은 경우 CPAN 모듈 &lt;code&gt;Convert::Binary::C&lt;/code&gt; 살펴보고 싶을 것입니다 . C 소스를 직접 구문 분석 할 수있을뿐만 아니라이 섹션에서 더 자세히 설명 된 모든 확률과 끝을 기본적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="20f202512374709bcbdf3d36e09a30c2730f3952" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt;. Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">많은 C 구조를 처리해야하고 모든 템플릿 문자열을 수동으로 해킹하고 싶지 않다면 CPAN 모듈 &lt;code&gt;Convert::Binary::C&lt;/code&gt; 살펴보고 싶을 것입니다 . C 소스를 직접 구문 분석 할 수있을뿐만 아니라이 섹션에서 자세히 설명하는 모든 승률과 결말에 대한 지원이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fedff50b6bdfc3eaf8ccc29c03df5c84e0ff6a06" translate="yes" xml:space="preserve">
          <source>If you have trouble compiling the scripts in this documentation, you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</source>
          <target state="translated">이 문서에서 스크립트를 컴파일하는 데 문제가 있다면 혼자가 아닙니다. 기본 규칙 : 정확한 PERL 프로그램과 동일한 방식으로 프로그램을 완료하십시오. (죄송합니다.)</target>
        </trans-unit>
        <trans-unit id="899489485e48eb6acab0142eabbf325712e8b44a" translate="yes" xml:space="preserve">
          <source>If you have updated your Solaris version, you may also have to update your gcc. For example, if you are running Solaris 2.6 and your gcc is installed under /usr/local, check in /usr/local/lib/gcc-lib and make sure you have the appropriate directory, sparc-sun-solaris2.6/ or i386-pc-solaris2.6/. If gcc's directory is for a different version of Solaris than you are running, then you will need to rebuild gcc for your new version of Solaris.</source>
          <target state="translated">Solaris 버전을 업데이트 한 경우 gcc를 업데이트해야 할 수도 있습니다. 예를 들어, Solaris 2.6을 실행 중이고 gcc가 / ​​usr / local에 설치된 경우 / usr / local / lib / gcc-lib를 확인하여 적절한 디렉토리 sparc-sun-solaris2.6 /이 있는지 확인하십시오. i386-pc-solaris2.6 /. gcc의 디렉토리가 실행중인 것과 다른 버전의 Solaris 용인 경우 새 버전의 Solaris 용으로 gcc를 재 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="61a8da0f8f7da9cf9cae8a262e98843a7815ba5c" translate="yes" xml:space="preserve">
          <source>If you have used a decimal $VERSION in the past and wish to switch to a dotted-decimal $VERSION, then you need to make a one-time conversion to the new format.</source>
          <target state="translated">과거에 십진수 $ VERSION을 사용했고 점으로 구분 된 십진수 $ VERSION으로 전환하려면 새 형식으로 한 번만 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5baa162c1dcd052bd0eee802b13bec96e916c96" translate="yes" xml:space="preserve">
          <source>If you have written a test module based on Test::Builder then Test::Tester allows you to test it with the minimum of effort.</source>
          <target state="translated">Test :: Builder를 기반으로 테스트 모듈을 작성한 경우 Test :: Tester를 사용하면 최소한의 노력으로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44abb6ca108f95533f7bd86193633f514940a80" translate="yes" xml:space="preserve">
          <source>If you have your perl compiled for debugging (usually done with &lt;code&gt;-DDEBUGGING&lt;/code&gt; on the &lt;code&gt;Configure&lt;/code&gt; command line), you may examine the compiled tree by specifying &lt;code&gt;-Dx&lt;/code&gt; on the Perl command line. The output takes several lines per node, and for &lt;code&gt;$b+$c&lt;/code&gt; it looks like this:</source>
          <target state="translated">디버깅을 위해 perl을 컴파일 한 경우 (일반적으로 &lt;code&gt;Configure&lt;/code&gt; 명령 행 에서 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 으로 수행됨 ) Perl 명령 행에서 &lt;code&gt;-Dx&lt;/code&gt; 를 지정하여 컴파일 된 트리를 검사 할 수 있습니다 . 출력은 노드 당 여러 줄을 취하며 &lt;code&gt;$b+$c&lt;/code&gt; 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4be3c9c74002e27258a38e4f113b05f31396c7de" translate="yes" xml:space="preserve">
          <source>If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.</source>
          <target state="translated">아직 추측하지 않은 경우 위치 문자열은 종료 NULL로 저장됩니다. 즉, 데이터베이스에 액세스 할 때주의해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
