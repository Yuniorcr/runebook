<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="198821065f8114e37c282b1dc5e2e1e562fb79c1" translate="yes" xml:space="preserve">
          <source>This option takes a parameter that must be a reference to a sub. On entry to the sub the &lt;code&gt;$_&lt;/code&gt; variable will contain the name to be filtered. If no filename is available &lt;code&gt;$_&lt;/code&gt; will contain an empty string.</source>
          <target state="translated">이 옵션은 하위에 대한 참조 여야하는 매개 변수를 사용합니다. 하위 항목을 입력하면 &lt;code&gt;$_&lt;/code&gt; 변수에 필터링 할 이름이 포함됩니다. 파일 이름이 없으면 &lt;code&gt;$_&lt;/code&gt; 에 빈 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3c97397612f397cc9803106ff617ed57fcd7bbdd" translate="yes" xml:space="preserve">
          <source>This option was introduced to let you easily customize which</source>
          <target state="translated">이 옵션은 쉽게 사용자 정의 할 수 있도록 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="478ef92f533a2a64ed38715adae3641923596540" translate="yes" xml:space="preserve">
          <source>This option will uncompress the contents of &lt;code&gt;$string&lt;/code&gt; before processing the input file/buffer.</source>
          <target state="translated">이 옵션은 입력 파일 / 버퍼를 처리하기 전에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 압축 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="94e79c8cc707f4d220ebc5676b2e7c094b43e26e" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 옵션을 true로 설정하면 앵커 텍스트가 제공 될 때 URL이 표시되지 않으므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 형식으로 표시됩니다 . 이것은 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c093990608ad560cd2156838664c1a41d4353f2" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt;. This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 옵션을 true 값으로 설정하면 앵커 텍스트가 제공 될 때 URL이 표시되지 않으므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 형식으로 지정됩니다 . 이렇게하면 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73e8a9fe84394bb733d349d80f809abc0c71549" translate="yes" xml:space="preserve">
          <source>This overload was introduced in Perl 5.12.</source>
          <target state="translated">이 과부하는 Perl 5.12에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="80f1948b993b572ddd0ded00367d4480f0e1a9dd" translate="yes" xml:space="preserve">
          <source>This overrides all the default install locations. Man pages, libraries, scripts, etc... MakeMaker will try to make an educated guess about where to place things under the new PREFIX based on your Config defaults. Failing that, it will fall back to a structure which should be sensible for your platform.</source>
          <target state="translated">이것은 모든 기본 설치 위치를 대체합니다. 매뉴얼 페이지, 라이브러리, 스크립트 등 ... MakeMaker는 구성 기본값을 기반으로 새 PREFIX 아래에 항목을 배치 할 위치에 대한 정확한 추측을 시도합니다. 실패하면 플랫폼에 적합한 구조로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="444e5337bdc60ac371985ae433717f80c0fb2273" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">이것은 새로 작성된 스레드 내에서만 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 의 기본 작동을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="24a3ff23ecaa6a599f398f1b05a599f96ef89aff" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;exit()&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">이것은 새로 생성 된 스레드에서만 &lt;code&gt;exit()&lt;/code&gt; 의 기본 동작을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="54817ecdea72dd0f8dad14e4e986821245f79bb0" translate="yes" xml:space="preserve">
          <source>This package &lt;code&gt;ISA&lt;/code&gt; IO::File, so that you can call IO::File methods on the handles returned by &lt;code&gt;vmsopen&lt;/code&gt; and &lt;code&gt;vmssysopen&lt;/code&gt;. The IO::File package is not initialized, however, until you actually call a method that VMS::Stdio doesn't provide. This is done to save startup time for users who don't wish to use the IO::File methods.</source>
          <target state="translated">이 패키지는 &lt;code&gt;ISA&lt;/code&gt; IO :: File을 사용하므로 &lt;code&gt;vmsopen&lt;/code&gt; 및 &lt;code&gt;vmssysopen&lt;/code&gt; 이 반환 한 핸들에서 IO :: File 메서드를 호출 할 수 있습니다 . 그러나 IO :: File 패키지는 VMS :: Stdio에서 제공하지 않는 메서드를 실제로 호출 할 때까지 초기화되지 않습니다. 이것은 IO :: File 메서드를 사용하지 않으려는 사용자의 시작 시간을 절약하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="519b8612e911f1f56d7cf335d416b8b3e0b034ae" translate="yes" xml:space="preserve">
          <source>This package allows a tied hash to autoload its values on the first access, and to use the cached value on the following accesses.</source>
          <target state="translated">이 패키지를 사용하면 연결 해시가 첫 번째 액세스에서 값을 자동로드하고 다음 액세스에서 캐시 된 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd12631c6783b870d8636d280593396cecef2aa" translate="yes" xml:space="preserve">
          <source>This package assumes your instances are blessed hashrefs, it will not work if that is not true. It will store all meta-data in the &lt;code&gt;_meta&lt;/code&gt; key on your objects hash. If your object makes use of the &lt;code&gt;_meta&lt;/code&gt; key in its underlying hash, then there is a conflict and you cannot use this package.</source>
          <target state="translated">이 패키지는 귀하의 인스턴스가 축복받은 해시 참조라고 가정합니다. 그렇지 않으면 작동하지 않습니다. 객체 해시 의 &lt;code&gt;_meta&lt;/code&gt; 키에 모든 메타 데이터를 저장합니다 . 개체가 기본 해시에서 &lt;code&gt;_meta&lt;/code&gt; 키를 사용 하는 경우 충돌이 발생하고이 패키지를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="27ef3cf0031676169d1650659bd8ca01863df483" translate="yes" xml:space="preserve">
          <source>This package exports all the functions necessary to write and/or verify testing tools. Using these building blocks you can begin writing test tools very quickly. You are also provided with tools that help you to test the tools you write.</source>
          <target state="translated">이 패키지는 테스트 도구를 작성 및 / 또는 확인하는 데 필요한 모든 기능을 내 보냅니다. 이러한 빌딩 블록을 사용하면 테스트 도구 작성을 매우 빠르게 시작할 수 있습니다. 작성하는 도구를 테스트하는 데 도움이되는 도구도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="24fee1df4d3c220048420e934bfa1571230d5dc6" translate="yes" xml:space="preserve">
          <source>This package gives Perl scripts access via VMS extensions to several C stdio operations not available through Perl's CORE I/O functions. The specific routines are described below. These functions are prototyped as unary operators, with the exception of &lt;code&gt;vmsopen&lt;/code&gt; and &lt;code&gt;vmssysopen&lt;/code&gt;, which can take any number of arguments, and &lt;code&gt;tmpnam&lt;/code&gt;, which takes none.</source>
          <target state="translated">이 패키지는 Perl의 CORE I / O 기능을 통해 사용할 수없는 여러 C stdio 작업에 대한 VMS 확장을 통해 Perl 스크립트에 액세스 할 수 있도록합니다. 구체적인 루틴은 아래에 설명되어 있습니다. 이러한 함수는 단항 연산자로 프로토 타입 화됩니다. 단항 연산자 는 임의의 수를 사용할 수있는 &lt;code&gt;vmsopen&lt;/code&gt; 및 &lt;code&gt;vmssysopen&lt;/code&gt; 및 인수가 없는 &lt;code&gt;tmpnam&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="117523179eb4686be1091dc68328b55978f9a6f5" translate="yes" xml:space="preserve">
          <source>This package has an END block. This END block is responsible for setting the exit code based on the test results. This end block also calls the callbacks that can be added to this package.</source>
          <target state="translated">이 패키지에는 END 블록이 있습니다. 이 END 블록은 테스트 결과에 따라 종료 코드를 설정합니다. 이 끝 블록은이 패키지에 추가 할 수있는 콜백도 호출합니다.</target>
        </trans-unit>
        <trans-unit id="52216942838934faafa12f993b9e33de2dc6a37f" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since perl 5.001. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">이 패키지는 perl 5.001 이후 펄 코어의 일부였습니다. CPAN에 별도로 릴리스되었으므로 이전 설치에서는 버그 수정의 혜택을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c6b0ed0d74189431901579ee94937bb8d4ce64" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since the first release of perl5. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">이 패키지는 perl5의 첫 번째 릴리스 이후 펄 코어의 일부였습니다. CPAN에 별도로 릴리스되었으므로 이전 설치에서는 버그 수정의 혜택을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8604a04f6b263dfa751e272224470b230a03d1e8" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core.</source>
          <target state="translated">이 패키지는 펄 코어와 동일한 저작권 및 라이센스를가집니다.</target>
        </trans-unit>
        <trans-unit id="5b6805fe29e54bd4efe3c6b5cfa333a68b6dd7e7" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core:</source>
          <target state="translated">이 패키지는 펄 코어와 동일한 저작권 및 라이센스를가집니다 :</target>
        </trans-unit>
        <trans-unit id="3dd0926d44817739b9d6d9f6b9c878553eedc873" translate="yes" xml:space="preserve">
          <source>This package has the same functionality as CPAN.pm, but tries to prevent the usage of compiled extensions during its own execution. Its primary purpose is a rescue in case you upgraded perl and broke binary compatibility somehow.</source>
          <target state="translated">이 패키지는 CPAN.pm과 기능은 동일하지만 자체 실행 중에 컴파일 된 확장이 사용되지 않도록합니다. 주요 목적은 펄을 업그레이드하고 어떻게 든 바이너리 호환성을 깨뜨린 경우를 대비 한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="5ec260b88b13584e3875f1a95d421c8de3085165" translate="yes" xml:space="preserve">
          <source>This package is free software and is provided &quot;as is&quot; without express or implied warranty. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">이 패키지는 무료 소프트웨어이며 명시 적 또는 묵시적 보증없이 &quot;있는 그대로&quot;제공됩니다. Perl 자체와 동일한 용어로 사용, 재배포 및 / 또는 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d169e6cde7a05a46328dee15bc92ea9fbd31c5a" translate="yes" xml:space="preserve">
          <source>This package is just a front end to some other packages. It's a stub to set up a common interface to the various ReadLine implementations found on CPAN (under the &lt;code&gt;Term::ReadLine::*&lt;/code&gt; namespace).</source>
          <target state="translated">이 패키지는 다른 패키지의 프론트 엔드입니다. CPAN ( &lt;code&gt;Term::ReadLine::*&lt;/code&gt; 네임 스페이스 아래)에있는 다양한 ReadLine 구현에 대한 공통 인터페이스를 설정하는 토막 입니다.</target>
        </trans-unit>
        <trans-unit id="b1ade6c9a8f018d0fad6780df5d177f32fbb0e0d" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;Pod::Perldoc::ToText&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;Pod::Perldoc::ToMan&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;Pod::Perldoc::ToText&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt; , &lt;a href=&quot;Pod::Perldoc::ToMan&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt; 등과 같은 Pod :: Perldoc 포매터의 기반입니다 .</target>
        </trans-unit>
        <trans-unit id="ce76c6c4371370495517baf3705b461101fff8c7" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;totext&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;toman&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;totext&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt; , &lt;a href=&quot;toman&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt; 등과 같은 Pod :: Perldoc 포맷터의 기본으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9180a230452e68871f0598e03ac17371f08687f4" translate="yes" xml:space="preserve">
          <source>This package is still a work in progress. ;-)</source>
          <target state="translated">이 패키지는 여전히 진행중인 작업입니다. ;-)</target>
        </trans-unit>
        <trans-unit id="e14216db6d6f543013d22d6e863cfe0d56fedf31" translate="yes" xml:space="preserve">
          <source>This package is used to generate classes based on hashrefs. Using this class will give you a &lt;code&gt;new()&lt;/code&gt; method, as well as generating accessors you request. Generated accessors will be getters, &lt;code&gt;set_ACCESSOR&lt;/code&gt; setters will also be generated for you. You also get constants for each accessor (all caps) which return the key into the hash for that accessor. Single inheritance is also supported.</source>
          <target state="translated">이 패키지는 해시 참조를 기반으로 클래스를 생성하는 데 사용됩니다. 이 클래스를 사용 하면 요청한 접근자를 생성 할뿐만 아니라 &lt;code&gt;new()&lt;/code&gt; 메서드 가 제공됩니다 . 생성 된 접근자는 getter가되고 &lt;code&gt;set_ACCESSOR&lt;/code&gt; setter도 생성됩니다. 또한 해당 접근 자의 해시로 키를 반환하는 각 접근 자 (모두 대문자)에 대한 상수를 얻습니다. 단일 상속도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5132ab88c97f356a0cb81785c11fd445555c2f78" translate="yes" xml:space="preserve">
          <source>This package lets you create and manipulate complex numbers. By default,</source>
          <target state="translated">이 패키지를 사용하면 복소수를 생성하고 조작 할 수 있습니다. 기본적으로,</target>
        </trans-unit>
        <trans-unit id="a170bd1eff2041ac0d0ac79f2c0ec18d1fc8c0b5" translate="yes" xml:space="preserve">
          <source>This package lets you define a clear, and consistent way to allow third party tools to attach meta-data to your instances. If your object consumes this package, and imports its methods, then third party meta-data has a safe place to live.</source>
          <target state="translated">이 패키지를 사용하면 타사 도구가 메타 데이터를 인스턴스에 연결할 수 있도록 명확하고 일관된 방법을 정의 할 수 있습니다. 개체가이 패키지를 사용하고 해당 메서드를 가져 오면 타사 메타 데이터가 안전하게 살 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c027490dcb5b2efb5529d5116c08443a95ca1c4a" translate="yes" xml:space="preserve">
          <source>This package provides routines to simplify conversion between VMS and Unix syntax when processing file specifications. This is useful when porting scripts designed to run under either OS, and also allows you to take advantage of conveniences provided by either syntax (</source>
          <target state="translated">이 패키지는 파일 사양을 처리 할 때 VMS와 Unix 구문 간의 변환을 단순화하는 루틴을 제공합니다. 이는 두 OS에서 실행되도록 설계된 스크립트를 이식 할 때 유용하며 두 구문 (</target>
        </trans-unit>
        <trans-unit id="11a96a3b10a148099f0b7f72edfecfa081ed012b" translate="yes" xml:space="preserve">
          <source>This package represents what is expected in units of amnesty.</source>
          <target state="translated">이 패키지는 사면 단위로 예상되는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="733cf8ccc54fc2caec2b129c7f9c3b8fe256f776" translate="yes" xml:space="preserve">
          <source>This package supplies the following functions, all of which should be called as methods.</source>
          <target state="translated">이 패키지는 다음과 같은 기능을 제공하며, 모두 메소드로 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3cfaecafb317f7a283c4d709b1fe33fabf00ba94" translate="yes" xml:space="preserve">
          <source>This package variable is used by code which needs to generate random numbers (such as the &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt; and &lt;a href=&quot;#sample&quot;&gt;&quot;sample&quot;&lt;/a&gt; functions). If set to a CODE reference it provides an alternative to perl's builtin &lt;code&gt;rand()&lt;/code&gt; function. When a new random number is needed this function will be invoked with no arguments and is expected to return a floating-point value, of which only the fractional part will be used.</source>
          <target state="translated">이 패키지 변수는 난수를 생성해야하는 코드 (예 : &lt;a href=&quot;#shuffle&quot;&gt;&quot;셔플&quot;&lt;/a&gt; 및 &lt;a href=&quot;#sample&quot;&gt;&quot;샘플&quot;&lt;/a&gt; 함수)에서 사용됩니다. CODE 참조로 설정되면 perl의 내장 &lt;code&gt;rand()&lt;/code&gt; 함수에 대한 대안을 제공 합니다. 새로운 난수가 필요할 때이 함수는 인수없이 호출되며 소수 부분 만 사용되는 부동 소수점 값을 반환 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="0502ae210c839a0d5612b4c49c9ee0a00914b58d" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt; ! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">이것은 &lt;code&gt;3*@buffer&lt;/code&gt; 바이트를 압축 하지만 &lt;code&gt;buffer_t&lt;/code&gt; 의 크기는 &lt;code&gt;BUFLEN&lt;/code&gt; 의 4 배 입니다 . 이야기의 도덕은 구조 또는 배열의 필요한 정렬이 패딩을 고려해야하는 다음 상위 레벨로 전파된다는 것입니다</target>
        </trans-unit>
        <trans-unit id="e53c590bd241b677c54acd7fcca9e80edc4d08e4" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt;! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">이것은 &lt;code&gt;3*@buffer&lt;/code&gt; 바이트를 포장 하지만 &lt;code&gt;buffer_t&lt;/code&gt; 의 크기는 &lt;code&gt;BUFLEN&lt;/code&gt; 의 4 배인 것으로 밝혀졌습니다 ! 이야기의 교훈은 구조 또는 배열의 필수 정렬이 패딩을 고려해야하는 다음 상위 레벨로 전파된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6a4741dfc9d84d06564831e13aad41055715be9" translate="yes" xml:space="preserve">
          <source>This page assumes you already know things, like what a &quot;pattern&quot; is, and the basic syntax of using them. If you don't, see &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 &quot;패턴&quot;이 무엇인지, 그리고 그것들을 사용하는 기본 구문과 같은 것을 이미 알고 있다고 가정합니다. 그렇지 않은 경우 &lt;a href=&quot;perlretut&quot;&gt;perlretut를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="946e326f892b4b8b1ddce244173724cf9a7d1bb8" translate="yes" xml:space="preserve">
          <source>This page covers the very basics of understanding, creating and using regular expressions ('regexes') in Perl.</source>
          <target state="translated">이 페이지는 Perl에서 정규식 ( 'regexes')을 이해하고 작성하고 사용하는 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="dce9886ab9b0a9a0def511caa51f7fe80e84aea2" translate="yes" xml:space="preserve">
          <source>This page describes the syntax of regular expressions in Perl.</source>
          <target state="translated">이 페이지에서는 Perl의 정규 표현식 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="317e90a756283c2e548a97a6d078f31d1baf3825" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 Perl에서 정규식 이해, 작성 및 사용에 대한 기본 학습서를 제공합니다. 정규 표현식 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 의 참조 페이지를 보완합니다 . 정규식은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 의 필수 부분 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;이므로이&lt;/a&gt; 튜토리얼 은 perlop 및 &lt;a href=&quot;functions/split&quot;&gt;split의 &lt;/a&gt;Regexp Quote-Like 연산자 와 겹칩니다 .</target>
        </trans-unit>
        <trans-unit id="7d5a131e3270619460abdb9845cd688fb5a50600" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt; and &lt;code&gt;split&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;perlfunc#split&quot;&gt;&quot;split&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 Perl에서 정규식을 이해, 생성 및 사용하는 방법에 대한 기본 자습서를 제공합니다. 정규식 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 의 참조 페이지를 보완하는 역할을합니다 . 정규식은 &lt;code&gt;m//&lt;/code&gt; , &lt;code&gt;s///&lt;/code&gt; , &lt;code&gt;qr//&lt;/code&gt; 및 &lt;code&gt;split&lt;/code&gt; 연산자 의 필수 부분 이므로이 자습서는 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 &quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; 및 &lt;a href=&quot;perlfunc#split&quot;&gt;perlfunc의 &quot;split&quot;&lt;/a&gt; 과 겹칩니다 .</target>
        </trans-unit>
        <trans-unit id="5dd11d6815b6bbd5757b2908c5f7f36d9fc65ef7" translate="yes" xml:space="preserve">
          <source>This parameter allows additional metadata to be stored in the ExtraField in the gzip header. An RFC 1952 compliant ExtraField consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">이 매개 변수를 사용하면 추가 메타 데이터를 gzip 헤더의 ExtraField에 저장할 수 있습니다. RFC 1952 호환 ExtraField는 0 개 이상의 서브 필드로 구성됩니다. 각 서브 필드는 2 바이트 헤더와 서브 필드 데이터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5f89c77abee951f08c51fc642a03fa6b870eac" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of a bit in the zip central header. It is used to signal that the data stored in the zip file/buffer is probably text.</source>
          <target state="translated">이 매개 변수는 Zip 중앙 헤더의 비트 설정을 제어합니다. zip 파일 / 버퍼에 저장된 데이터가 아마도 텍스트라는 신호를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7ab5c8a3bc9a88a9534a62193fcda4a2a345ca3" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of the FLG.FTEXT bit in the gzip header. It is used to signal that the data stored in the gzip file/buffer is probably text.</source>
          <target state="translated">이 매개 변수는 gzip 헤더에서 FLG.FTEXT 비트의 설정을 제어합니다. gzip 파일 / 버퍼에 저장된 데이터가 아마도 텍스트라는 신호를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d135fdd7e0c9609625dc055c076f0bab706088f" translate="yes" xml:space="preserve">
          <source>This parameter defaults to 0.</source>
          <target state="translated">이 매개 변수의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a954f8a244020c9f424e9822cfad5459a2f5fec4" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
          <target state="translated">이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3095070e85d1a1b0788b86dc1c47569b11d0ecb4" translate="yes" xml:space="preserve">
          <source>This parameter is used to specify the ambient pragmas which are stored in the special hash %^H.</source>
          <target state="translated">이 매개 변수는 특수 해시 % ^ H에 저장된 주변 pragma를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aaafa45d95b04bd8c01708fb5fdd297ddbefc3b4" translate="yes" xml:space="preserve">
          <source>This parameter takes precedence over the &lt;code&gt;Local*&lt;/code&gt;, &lt;code&gt;Family&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;Proto&lt;/code&gt; arguments.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;Local*&lt;/code&gt; , &lt;code&gt;Family&lt;/code&gt; , &lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;Proto&lt;/code&gt; 인수 보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="144cb2f166d202c7f6fa31b74b5f72c47f93cb09" translate="yes" xml:space="preserve">
          <source>This parameter takes precedence over the &lt;code&gt;Peer*&lt;/code&gt;, &lt;code&gt;Family&lt;/code&gt;, &lt;code&gt;Type&lt;/code&gt; and &lt;code&gt;Proto&lt;/code&gt; arguments.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;Peer*&lt;/code&gt; , &lt;code&gt;Family&lt;/code&gt; , &lt;code&gt;Type&lt;/code&gt; 및 &lt;code&gt;Proto&lt;/code&gt; 인수 보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="e57f8e4024e58b80873e8cbfaa23d47d4d596bfc" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;overrideCJK&lt;/code&gt; 와 같이 작동 하므로 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51565d89891bf2948d91c1cc64dabcc98c8f8a0a" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt;, so see there for examples.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;overrideCJK&lt;/code&gt; 처럼 작동 하므로 예제를 보려면 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac9494fe5df3170e77a2748f1c2b29eb01128b21" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally.</source>
          <target state="translated">이 패턴은 아무 것도 일치하지 않으며 항상 실패합니다. 엔진을 강제로 역 추적하는 데 사용할 수 있습니다. 그것은 동일합니다 &lt;code&gt;(?!)&lt;/code&gt; 하지만, 쉽게 읽을 수. 실제로 &lt;code&gt;(?!)&lt;/code&gt; 는 내부적 으로 &lt;code&gt;(*FAIL)&lt;/code&gt; 로 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fc6c7ad71aa7736bfa3c0da48319c974555eb05" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally. You can provide an argument so that if the match fails because of this &lt;code&gt;FAIL&lt;/code&gt; directive the argument can be obtained from &lt;code&gt;$REGERROR&lt;/code&gt;.</source>
          <target state="translated">이 패턴은 아무것도 일치하지 않으며 항상 실패합니다. 엔진을 강제로 역 추적하는 데 사용할 수 있습니다. 그것은 동일합니다 &lt;code&gt;(?!)&lt;/code&gt; 하지만, 쉽게 읽을 수. 실제로 &lt;code&gt;(?!)&lt;/code&gt; 는 내부적 으로 &lt;code&gt;(*FAIL)&lt;/code&gt; 에 최적화됩니다 . 이 &lt;code&gt;FAIL&lt;/code&gt; 지시문으로 인해 일치가 실패 할 경우 &lt;code&gt;$REGERROR&lt;/code&gt; 에서 인수를 얻을 수 있도록 인수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d7331a8c75f2ab7015003fc1a186b402d4f4b0f" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt; , only the innermost pattern is ended immediately.</source>
          <target state="translated">이 패턴은 아무것도 일치하지 않으며 실제로 문자열에 일치하는 항목이 더 있는지 여부에 관계없이 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 패턴이 발생한 지점에서 성공적인 일치를 종료 합니다. 재귀와 같은 중첩 패턴의 내부 또는 &lt;code&gt;(??{})&lt;/code&gt; 를 통해 동적으로 생성 된 하위 패턴의 경우 가장 안쪽의 패턴 만 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="67ca6793aa1baf492f23da59c43d48ed60e5c55a" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt;, only the innermost pattern is ended immediately.</source>
          <target state="translated">이 패턴은 아무것도 일치하지 않으며 문자열에 실제로 일치 할 항목이 더 있는지 여부에 관계없이 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 패턴이 발생한 지점에서 성공적인 일치가 종료 되도록합니다. 재귀와 같은 중첩 패턴 내부 또는 &lt;code&gt;(??{})&lt;/code&gt; 를 통해 동적으로 생성 된 하위 패턴 에서 가장 안쪽 패턴 만 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="19f045887dd160fbc7bf52fef1325dee9e3b92d8" translate="yes" xml:space="preserve">
          <source>This perl distribution comes with a tremendous amount of documentation. To add these to the built-in manuals that come with Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately) run:</source>
          <target state="translated">이 펄 배포판에는 엄청난 양의 문서가 제공됩니다. /sys/src/cmd/perl/5.00301에서 Plan 9와 함께 제공되는 내장 매뉴얼에 추가하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="faaee2dbff571e442cc459d64235bf7e75251410" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt; -blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; .</source>
          <target state="translated">이 단계는 최상위 프로그램뿐만 아니라 컴파일 단위의 컴파일 타임 동안 실행되므로 &lt;code&gt;BEGIN&lt;/code&gt; 블록 과 혼동을 피하기 위해 &quot;BEGIN&quot;이라고 하지 않습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; 이 전역 인터프리터 단계가 아니므 로 런타임에 입력 된 새로운 현지화 된 컴파일 타임은 구문에 의해 구성 되므로 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5c6076111df5ac2088f7c60ba538962c1ba1518f" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt;-blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;eval &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="translated">이 단계는 &lt;code&gt;BEGIN&lt;/code&gt; 블록 과의 혼동을 피하기 위해 &quot;BEGIN&quot;이라고 부르지 않습니다. 이는 최상위 프로그램뿐만 아니라 컴파일 단위의 컴파일 시간 동안 실행되기 때문입니다. 예를 들어 &lt;code&gt;eval &quot;use SomeModule&quot;&lt;/code&gt; 로 구성에 의해 런타임에 입력 된 새로운 지역화 된 컴파일 타임 은 전역 인터프리터 단계가 아니므로 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38d412691b698918f3fb521b6c5dd0a3a033324a" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the &quot;less&quot; pager and prints &quot;bar&quot; on the console:</source>
          <target state="translated">&quot;foo&quot;를 &quot;less&quot;호출기로 파이프하고 콘솔에 &quot;bar&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d6fbd955f7e5cef0d107f07af92fd7a485df2" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the pager and writes &quot;bar&quot; in the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;foo&quot;를 호출기로 파이프하고 &quot;blurch&quot;파일에 &quot;bar&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5e952eb46ee9ecbd24ef00bffe49334d2cc3dad" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo\nbar\n&quot; to the less pager:</source>
          <target state="translated">&quot;foo \ nbar \ n&quot;을 적은 호출기로 파이프합니다.</target>
        </trans-unit>
        <trans-unit id="9ef24b3495020011602b2e6eab8942a1d3d9b7c9" translate="yes" xml:space="preserve">
          <source>This port can also be built on IA64/AMD64 using:</source>
          <target state="translated">이 포트는 다음을 사용하여 IA64 / AMD64에 구축 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca794b2a97ff2f3e9f3ab8b1358dfca57eef50e2" translate="yes" xml:space="preserve">
          <source>This port currently supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites.</source>
          <target state="translated">이 포트는 현재 MakeMaker (Perl에 대한 확장을 빌드하는 데 사용되는 모듈 세트)를 지원합니다. 따라서 CPAN 사이트에있는 대부분의 확장을 빌드하고 설치할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="793aa06cc8a67a48ad4353d4f7baf40b5e8a8732" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;&quot;Usage Hints for Perl on Windows&quot;&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">이 포트는 MakeMaker (perl 확장을 빌드하는 데 사용되는 모듈 세트)를 완전히 지원합니다. 따라서 CPAN 사이트에있는 대부분의 확장을 빌드하고 설치할 수 있어야합니다. 이에 대한 일반적인 힌트는 아래의 &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;&quot;Windows의 Perl 사용 힌트&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da8d54e517da55f89f98bd5f4b007e4f6e30203a" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Usage Hints for Perl on Windows&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">이 포트는 MakeMaker (Perl에 대한 확장을 빌드하는 데 사용되는 모듈 세트)를 완벽하게 지원합니다. 따라서 CPAN 사이트에있는 대부분의 확장을 빌드하고 설치할 수 있어야합니다. 이에 대한 일반적인 힌트는 아래의 &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Windows에서 Perl의 사용법 힌트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca5da1d69d15505d5dfe7b2200728b9e2a69857" translate="yes" xml:space="preserve">
          <source>This port of Perl also uses Unix-epoch date values internally. As long as you are dealing with ASCII character string representations of dates, this should not be an issue. The supported epoch is January 1, 1980 to January 17, 2038.</source>
          <target state="translated">이 Perl 포트는 내부적으로 Unix-epoch 날짜 값을 사용합니다. 날짜의 ASCII 문자열 표현을 다루는 한, 이것은 문제가되지 않습니다. 지원되는시기는 1980 년 1 월 1 일부터 2038 년 1 월 17 일까지입니다.</target>
        </trans-unit>
        <trans-unit id="3b59478e1d9adc5bbc9ae74efe6d7c2a8e595477" translate="yes" xml:space="preserve">
          <source>This port of Perl version 5 prefers Unix-style, slash-separated pathnames over OpenVOS-style greater-than-separated pathnames. OpenVOS-style pathnames should work in most contexts, but if you have trouble, replace all greater-than characters by slash characters. Because the slash character is used as a pathname delimiter, Perl cannot process OpenVOS pathnames containing a slash character in a directory or file name; these must be renamed.</source>
          <target state="translated">이 Perl 버전 5 포트는 OpenVOS 스타일보다 큰 경로 이름보다 슬래시로 구분 된 Unix 스타일 경로 이름을 선호합니다. OpenVOS 스타일 경로 이름은 대부분의 컨텍스트에서 작동하지만 문제가 발생하면 큰 문자를 모두 슬래시 문자로 바꾸십시오. 슬래시 문자는 경로 이름 구분 기호로 사용되므로 Perl은 디렉토리 또는 파일 이름에 슬래시 문자가 포함 된 OpenVOS 경로 이름을 처리 할 수 ​​없습니다. 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="5661c31774bac29706eeedad5ca0b82e3ef23fed" translate="yes" xml:space="preserve">
          <source>This port was originally contributed by Gary Ng around 5.003_24, and borrowed from the Hip Communications port that was available at the time. Various people have made numerous and sundry hacks since then.</source>
          <target state="translated">이 포트는 원래 Gary Ng가 5.003_24 경에 기부했으며 당시 사용 가능한 Hip Communications 포트에서 빌 렸습니다. 그 이후로 다양한 사람들이 수많은 해킹 해킹을 해왔습니다.</target>
        </trans-unit>
        <trans-unit id="791faea88ef9fd32067c73f960fb805edbc087f6" translate="yes" xml:space="preserve">
          <source>This port will support dynamic loading, but it is not selected by default. If you would like to experiment with dynamic loading then be sure to specify -Dusedl in the arguments to the Configure script. See the comments in hints/os390.sh for more information on dynamic loading. If you build with dynamic loading then you will need to add the $archlibexp/CORE directory to your LIBPATH environment variable in order for perl to work. See the config.sh file for the value of $archlibexp. If in trying to use Perl you see an error message similar to:</source>
          <target state="translated">이 포트는 동적로드를 지원하지만 기본적으로 선택되어 있지 않습니다. 동적로드를 실험하려면 Configure 스크립트의 인수에 -Dusedl을 지정하십시오. 동적 로딩에 대한 자세한 내용은 hints / os390.sh의 주석을 참조하십시오. 동적 로딩으로 빌드하는 경우 perl이 작동하려면 $ archlibexp / CORE 디렉토리를 LIBPATH 환경 변수에 추가해야합니다. $ archlibexp의 값은 config.sh 파일을 참조하십시오. Perl을 사용하려고하면 다음과 유사한 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9ea06585be873f55abde4de83dd620970030f924" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;&quot;Overriding Built-in Functions&quot; in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">이 pragma는 클래스에 대한 Perl 연산자의 오버로딩을 허용합니다. 내장 함수를 오버로드하려면 대신 &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsub의 &quot;내장 함수 재정의&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66e0b9c8e30e0b67210d260345f05889e99ff243" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">이 pragma를 사용하면 클래스에 대한 Perl 연산자를 오버로드 할 수 있습니다. 내장 함수를 오버로드하려면 대신 &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsub에서 내장&lt;/a&gt; 함수 대체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca794d61d2dfe5a76e1bb77807f394d0b2d09964" translate="yes" xml:space="preserve">
          <source>This pragma allows you to declare constants at compile-time.</source>
          <target state="translated">이 pragma를 사용하면 컴파일 타임에 상수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c01b8b1ad50eec7e989d0f266d4a4fc89f5d88b" translate="yes" xml:space="preserve">
          <source>This pragma allows you to lexically disable or enable overloading.</source>
          <target state="translated">이 pragma를 사용하면 사전에 과부하를 비활성화하거나 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c428d7745a523c21e13cd202bfe44587bda59ff5" translate="yes" xml:space="preserve">
          <source>This pragma also affects encoding of the 0x80..0xFF code point range: normally characters in that range are left as eight-bit bytes (unless they are combined with characters with code points 0x100 or larger, in which case all characters need to become UTF-8 encoded), but if the &lt;code&gt;encoding&lt;/code&gt; pragma is present, even the 0x80..0xFF range always gets UTF-8 encoded.</source>
          <target state="translated">이 pragma는 0x80..0xFF 코드 포인트 범위의 인코딩에도 영향을줍니다. 일반적으로 해당 범위의 문자는 8 비트 바이트로 남습니다 (코드 포인트가 0x100 이상인 문자와 결합되지 않은 경우 모든 문자가 UTF 여야 함) -2) 부호화하지만, 만약 &lt;code&gt;encoding&lt;/code&gt; 래그가 존재조차 0x80..0xFF 범위는 항상 UTF-8 인코딩 얻는다.</target>
        </trans-unit>
        <trans-unit id="d924aa9de8af230a322065eb09c25f0d879f8eac" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;b&gt;-C&lt;/b&gt;&lt;/a&gt; command line switch.</source>
          <target state="translated">이 pragma는 환경에 지정된대로 현재 로케일에서 유니 코드로 변환 될 파일의 ​​모든 입력 ( &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; 참조 )과 로케일로 다시 변환 될 파일에 대한 모든 출력을 정렬합니다 . ( &lt;a href=&quot;open&quot;&gt;열기&lt;/a&gt; 참조 ). 파일 핸들별로 CPAN에서 사용할 수 있는 &lt;a href=&quot;PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt; 모듈 또는 &lt;a href=&quot;Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt; 모듈을 대신 사용할 수 있습니다 . 후자의 모듈에는 &lt;code&gt;ARGV&lt;/code&gt; 및 환경 변수 를 쉽게 처리 할 수있는 메서드가 있으며 개별 문자열에 사용할 수 있습니다. 요즘처럼 모든 로케일이 UTF-8이라는 것을 알고 있다면 &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;b&gt;-C&lt;/b&gt;&lt;/a&gt; 명령 줄 스위치를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd54481ef89d3dcd2f0d998cbd0de47400ae94c4" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; command line switch.</source>
          <target state="translated">이 pragma는 파일의 모든 입력을 환경에 지정된대로 현재 로케일에서 유니 코드로 변환하고 ( &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 참조 ) 파일로의 모든 출력을 로케일로 다시 변환하도록 정렬합니다 . ( &lt;a href=&quot;open&quot;&gt;열기&lt;/a&gt; 참조 ). 파일 핸들 단위로 대신 CPAN에서 사용 가능한 &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt; 모듈 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt; 모듈을 사용할 수 있습니다. 후자의 모듈에는 &lt;code&gt;ARGV&lt;/code&gt; 및 환경 변수 를 쉽게 처리 할 수있는 방법이 있으며 개별 문자열에서 사용할 수 있습니다. 요즘과 같이 모든 로케일이 UTF-8이된다는 것을 알고 있다면 &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; 명령 행 스위치를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37ed3079bf4bc6e6eae888371e167c272116e8dd" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;use utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">이 pragma는 UTF-8 지원 편집기가 드문 시절부터 시작되었습니다. 그러나 그것은 오래 전 일이며 그 필요성이 크게 줄어 들었습니다. 다른 문제와 함께 스레드와 함께 작동하지 않는다는 사실과 함께 ( &lt;a href=&quot;#BUGS&quot;&gt;&quot;버그&quot;&lt;/a&gt; 참조 ) 더 이상 사용되지 않습니다. 향후 Perl 버전에서이 pragma를 제거 할 계획입니다. 새 코드는 UTF-8로 작성해야하며 대신 &lt;code&gt;use utf8&lt;/code&gt; pragma를 사용해야합니다 (자세한 내용은 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 및 &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 참조). 이전 코드는 &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt; 의 레시피와 같은 방식으로 UTF-8로 변환되어야합니다 (이 간단한 접근 방식은 나중에 수동 조정이 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="34db7e44f64dc2e33987c7fbd44c07e44789bfa8" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">이 pragma는 UTF-8 지원 편집기가 흔하지 않은 시절부터 시작되었습니다. 그러나 그것은 오래 전에 이루어졌으며, 그 필요성은 크게 줄어 들었습니다. 그것은 다른 문제와 함께 스레드에서 작동하지 않는다는 사실과 함께 ( &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; 참조 ) 더 이상 사용되지 않습니다. 향후 Perl 버전에서이 pragma를 제거 할 계획입니다. 새로운 코드는 UTF-8로 작성되어야하며, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 대신 사용 pragma는 (참조 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 및 &lt;a href=&quot;utf8&quot;&gt;UTF8&lt;/a&gt; 자세한 내용을). &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 의 레시피와 같은 방법으로 이전 코드를 UTF-8로 변환해야합니다 (이 간단한 방법은 나중에 수동 조정이 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="4adb9dc70f3c9381053e6cf64fee4c07c531fe57" translate="yes" xml:space="preserve">
          <source>This pragma doesn't affect I/O. Nor does it change the internal representation of strings, only their interpretation. There are still several places where Unicode isn't fully supported, such as in filenames.</source>
          <target state="translated">이 pragma는 I / O에 영향을 미치지 않습니다. 또한 문자열의 내부 표현뿐만 아니라 해석 만 변경하지 않습니다. 파일 이름과 같이 유니 코드가 완전히 지원되지 않는 곳이 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a1053bcb46765bc08bab8c76c7daf170b6ab41" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">이 pragma는 PerlIO 와 잘 어울리지 않기 때문에 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 에 ASCII가 아닌 문자가 포함되어 있으면 재미있게 인쇄되거나 &quot;와이드 문자 경고&quot;가 표시됩니다. 이해하려면 아래 코드를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="63bc5c639e862260de54994e4a3fd753cd2d30e7" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;format&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;format&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">이 pragma는 PerlIO가 &lt;code&gt;format&lt;/code&gt; 과 잘 어울리지 않기 때문에 형식 과 잘 작동 하지 않습니다. &lt;code&gt;format&lt;/code&gt; 에 ASCII가 아닌 문자가 포함되어 있으면 재미있게 인쇄되거나 &quot;와이드 문자 경고&quot;가 표시됩니다. 그것을 이해하려면 아래 코드를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="842309da32a571cffd281160b3136685717f49db" translate="yes" xml:space="preserve">
          <source>This pragma first appeared in Perl v5.8.0. It has been enhanced in later releases as specified above.</source>
          <target state="translated">이 pragma는 Perl v5.8.0에서 처음 등장했습니다. 위에 지정된 이후 릴리스에서 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea296547782279e5c0e53a333818543fc8821038" translate="yes" xml:space="preserve">
          <source>This pragma is used to enable a Perl script to be written in encodings that aren't strictly ASCII nor UTF-8. It translates all or portions of the Perl program script from a given encoding into UTF-8, and changes the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; to the encoding specified.</source>
          <target state="translated">이 pragma는 Perl 스크립트를 ASCII 나 UTF-8이 아닌 인코딩으로 작성하는 데 사용됩니다. Perl 프로그램 스크립트의 일부 또는 전부를 주어진 인코딩에서 UTF-8로 변환하고 &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 의 PerlIO 계층을 지정된 인코딩으로 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="b2499dd223fe6da7fc3aa8e53b4286111a638895" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt; , and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; . Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">이 pragma를 사용하면 &quot;C3&quot;해상도 순서로 전환 할 수 있습니다. 간단히 말하면, &quot;C3&quot;순서는 공유 상위 클래스가 하위 클래스보다 먼저 검색되지 않도록하기 때문에 Perl은 이제 &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; 및 마지막으로 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 를 검색 합니다. 모든이가 &quot;폭 우선&quot;검색 아니라고하지만 참고 &lt;code&gt;Father&lt;/code&gt; 의 모든 먼저 검색된다 (공통 조상 제외) 조상 &lt;code&gt;Mother&lt;/code&gt; 조상으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6a561743b48f6917f3de6223e944d7c22b30aa" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt;, and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;. Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">이 pragma를 사용하면 &quot;C3&quot;확인 순서로 전환 할 수 있습니다. 간단히 말해서 &quot;C3&quot;순서는 공유 된 부모 클래스가 자식 클래스보다 먼저 검색되지 않도록 보장하므로 Perl은 이제 &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; , 마지막으로 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 를 검색 합니다. 그러나 이것은 &quot;폭 우선&quot;검색이 아닙니다. 모든 &lt;code&gt;Father&lt;/code&gt; 조상 (공통 조상 제외)은 &lt;code&gt;Mother&lt;/code&gt; 조상이 고려 되기 전에 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="7563cc6ded71ab7f47219e909773301db6c2d889" translate="yes" xml:space="preserve">
          <source>This pragma provides an easy and convenient way to enable or disable experimental features.</source>
          <target state="translated">이 pragma는 실험적 기능을 활성화 또는 비활성화하는 쉽고 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2063e0ed31e4ca83c59af99843b134e51c1d67ca" translate="yes" xml:space="preserve">
          <source>This pragma reflects early attempts to incorporate Unicode into perl and has since been superseded. It breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), and use of this module for anything other than debugging purposes is strongly discouraged. If you feel that the functions here within might be useful for your application, this possibly indicates a mismatch between your mental model of Perl Unicode and the current reality. In that case, you may wish to read some of the perl Unicode documentation: &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;, &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 유니 코드를 펄에 통합하려는 초기의 시도를 반영하며 이후 대체되었습니다. 캡슐화를 중단합니다 (즉, 현재 perl 실행 파일이 문자열을 저장하는 방식의 내부를 노출). 디버깅 이외의 용도로이 모듈을 사용하지 않는 것이 좋습니다. 여기에있는 함수가 응용 프로그램에 유용하다고 생각되면 Perl Unicode의 정신 모델과 현재 현실이 일치하지 않을 수 있습니다. 이 경우, &lt;a href=&quot;perluniintro&quot;&gt;perlniintro&lt;/a&gt; , &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; , &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 와 같은 perl Unicode 문서 중 일부를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17b8d23d839b79073aa5a07e1c3b5c9898bf0286" translate="yes" xml:space="preserve">
          <source>This pragma simplifies the maintenance of dual-life modules that will no longer be included in the Perl core in a future Perl release, but are still included currently.</source>
          <target state="translated">이 pragma는 향후 Perl 릴리스에서 더 이상 Perl 코어에 포함되지 않지만 현재 포함되어있는 이중 수명 모듈의 유지 관리를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="c260c6accbf395dcf89666ab18de9cc81ef025ab" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;-X&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">이 pragma는 컴파일러에게 filetest 권한 연산자 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;-X&lt;/code&gt; 의 동작을 변경하도록 지시합니다 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2ef074ee97cc67ce380e960a125c4b931d1340ce" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">이 pragma는 파일 테스트 권한 연산자 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 동작을 변경하도록 컴파일러에 지시합니다 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="221ed9ae1b0c79e2438890e0d6c973d357078c4b" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to enable (or disable) the use of POSIX locales for built-in operations (for example, LC_CTYPE for regular expressions, LC_COLLATE for string comparison, and LC_NUMERIC for number formatting). Each &quot;use locale&quot; or &quot;no locale&quot; affects statements to the end of the enclosing BLOCK.</source>
          <target state="translated">이 pragma는 내장 연산에 POSIX 로케일 사용을 활성화 (또는 비활성화)하도록 컴파일러에 지시합니다 (예 : 정규식의 경우 LC_CTYPE, 문자열 비교의 경우 LC_COLLATE, 숫자 형식의 경우 LC_NUMERIC). 각각의 &quot;사용 로케일&quot;또는 &quot;로케일 없음&quot;은 묶는 BLOCK의 끝에 대한 명령문에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="aeeaf592fadd170ef60bd36772264838afffed60" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 Perl에게 해당 범위 내에서 실행되는 작업이 유니 코드 규칙을 사용한다는 것을 명시 적으로 알릴 수 있도록 만들어졌습니다. 최신 펄로 인해 더 많은 작업이 영향을받습니다. &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;&quot;유니 코드 버그 &quot;&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e609830a837e5307b3fb39be2d58dc9501e3994d" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 해당 범위 내에서 실행되는 작업이 유니 코드 규칙을 사용한다는 것을 Perl에 명시 적으로 알릴 수 있도록 만들어졌습니다. 더 많은 작업이 새로운 perls의 영향을받습니다. &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c932803f2c5c4b2cf5c88433b729097c2569d39" translate="yes" xml:space="preserve">
          <source>This pragma will predeclare all the variables whose names are in the list, allowing you to use them under &lt;code&gt;use strict&lt;/code&gt;, and disabling any typo warnings for them.</source>
          <target state="translated">이 pragma는 이름이 목록에있는 모든 변수를 미리 선언하여 &lt;code&gt;use strict&lt;/code&gt; 하에서 사용할 수 있도록 하고 오타 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="700e6f2388b406cbe201cbb98323ed5f25c8d4b4" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">이 pragma는 &lt;code&gt;strict&lt;/code&gt; pragma 처럼 작동합니다 . 이는 경고 pragma의 범위가 둘러싸는 블록으로 제한됨을 의미합니다. 또한 pragma 설정이 파일 전체에서 누출되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 사용 ). 이를 통해 작성자는 모듈에 적용될 경고 확인 정도를 독립적으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd21a83903c74ae90d870a3df25547a1a2130d8" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">이 pragma는 &lt;code&gt;strict&lt;/code&gt; pragma 처럼 작동합니다 . 이는 경고 pragma의 범위가 둘러싸는 블록으로 제한됨을 의미합니다. 또한 pragma 설정이 &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 를 통해 파일간에 누출되지 않음을 의미합니다 . 이를 통해 작성자는 모듈에 적용될 경고 확인의 정도를 독립적으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">이것은 인쇄</target>
        </trans-unit>
        <trans-unit id="b6e212e7ef6ac1844cda369639e0440d069cad8b" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; into the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;bar&quot;를 인쇄하고 &quot;blurch&quot;파일에 &quot;foo&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d54bfbbae93113b4950fc2d869fb4754b9ce7e99" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; to the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;bar&quot;를 인쇄하고 &quot;blurch&quot;파일에 &quot;foo&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="efd4b33e8216cea60a6219dc7e5bd98ac5e87040" translate="yes" xml:space="preserve">
          <source>This prints &quot;foo&quot; (&quot;bar&quot; disappears into nowhereland):</source>
          <target state="translated">이것은 &quot;foo&quot;를 출력합니다 ( &quot;bar&quot;는 아무데도 사라집니다) :</target>
        </trans-unit>
        <trans-unit id="41ff0d603c865bec8366dedecbae0223cb1c3622" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;2.7&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="5884fb8d5912977dd4b38b66daf68b4ce0bb0d83" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;2.7&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="bb91200cd90a472a1ae9cb007ac03043f56be426" translate="yes" xml:space="preserve">
          <source>This prints out the name and version of all modules used and then exits.</source>
          <target state="translated">사용 된 모든 모듈의 이름과 버전이 인쇄되고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0f904b0830f014f8a9104235a42d06c972150632" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the &lt;a href=&quot;http://man.he.net/man1/printenv&quot;&gt;printenv(1)&lt;/a&gt; program, but in a different order:</source>
          <target state="translated">이것은 &lt;a href=&quot;http://man.he.net/man1/printenv&quot;&gt;printenv (1)&lt;/a&gt; 프로그램 과 같은 환경을 출력 하지만 순서는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f686232da2ac609974851dce432c4e1340ec7365" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the printenv(1) program, but in a different order:</source>
          <target state="translated">이것은 printenv (1) 프로그램과 같은 환경을 다른 순서로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="04d447d63dbf460d4723e288297a46d354df3e2a" translate="yes" xml:space="preserve">
          <source>This prints two doublequotes:</source>
          <target state="translated">이렇게하면 큰 따옴표 두 개가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="468d6d44762bf30d6816e393a8ba4eeeb6a7be16" translate="yes" xml:space="preserve">
          <source>This probably does nothing.</source>
          <target state="translated">이것은 아마도 아무 일도하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d21d1db17e4be9e2f5e50a54879f0a7c98d4455f" translate="yes" xml:space="preserve">
          <source>This probably isn't as useful as you might think. Normally, you shouldn't need to.</source>
          <target state="translated">이것은 아마도 생각만큼 유용하지 않습니다. 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341bfd19674c6dfeba3ffe584bfdf82c2776cb1e" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; , and add them together. Find &lt;code&gt;$a&lt;/code&gt; , and assign one to the other. Then leave.</source>
          <target state="translated">이것은 아마도 인간에게 더 의미가 있습니다. 블록을 입력하고 진술을 시작하십시오. &lt;code&gt;$b&lt;/code&gt; 및 &lt;code&gt;$c&lt;/code&gt; 의 값을 가져와 함께 더하십시오. &lt;code&gt;$a&lt;/code&gt; 찾아서 다른 것을 할당하십시오. 그런 다음 떠나십시오.</target>
        </trans-unit>
        <trans-unit id="a4586de2c445b95b021af0b04d69fb01ba89d45c" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt;, and add them together. Find &lt;code&gt;$a&lt;/code&gt;, and assign one to the other. Then leave.</source>
          <target state="translated">이것은 아마도 인간에게 더 합리적 일 것입니다. 블록을 입력하고 문장을 시작하십시오. &lt;code&gt;$b&lt;/code&gt; 및 &lt;code&gt;$c&lt;/code&gt; 값을 가져 와서 더합니다. &lt;code&gt;$a&lt;/code&gt; 찾아서 하나를 다른 것에 할당하십시오. 그럼 떠나요.</target>
        </trans-unit>
        <trans-unit id="d9d98988085b44026120bb435150bffabf68b9c3" translate="yes" xml:space="preserve">
          <source>This probably sounds a bit more confusing than it really is, so let's go through this program piece by piece and see what it does. (For those of you who might be trying to remember exactly what a prime number is, it's a number that's only evenly divisible by itself and 1.)</source>
          <target state="translated">이것은 아마도 실제보다 약간 더 혼란스럽게 들릴 것이므로이 프로그램을 하나씩 살펴보고 그것이 무엇을하는지 봅시다. (소수를 정확히 기억하려고하는 사람들에게는 그 자체로 1과 균등하게 나눌 수있는 숫자입니다.)</target>
        </trans-unit>
        <trans-unit id="8ac64410a0a0c80ce97774854ab9fa0ae7c24c64" translate="yes" xml:space="preserve">
          <source>This probing and the checks we performed have some limitations:</source>
          <target state="translated">이 프로빙과 우리가 수행 한 검사에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e016023303c59d801c6e740a285fec3afa4a6473" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들어 해결할 수 있습니다 . 외부 서브 루틴에서 어휘 서브 루틴을 참조하는 내부 익명 서브가 작성되면 자동으로 해당 어휘 서브의 현재 값으로 리바운드됩니다.</target>
        </trans-unit>
        <trans-unit id="b60e9bed0f73061b937a8fe5fecd9ad0d49454e0" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들어 해결할 수 있습니다 . 외부 서브 루틴에서 변수를 참조하는 내부 익명 서브가 작성되면 자동으로 해당 변수의 현재 값으로 리바운드됩니다.</target>
        </trans-unit>
        <trans-unit id="57123e780f962baab766839b9fcf02a5c2e726f1" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;sub {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;sub {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들면 해결할 수 있습니다 . 외부 서브 루틴의 어휘 서브 루틴을 참조하는 내부 익명 서브가 작성되면, 자동으로 해당 어휘 서브의 현재 값으로 리 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="8b0f22c9ea1e13dec6b01b469b5a53003b6ea76c" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;sub {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;sub {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들면 해결할 수 있습니다 . 외부 서브 루틴의 변수를 참조하는 내부 익명 서브가 생성되면 자동으로 해당 변수의 현재 값으로 리 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="30e5c26de90551718f152502391c103ab788e07b" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">이 문제는 일반적으로 명령 행에서 8 진 숫자를 인수로 사용하는 Unix 명령과 동일한 이름을 가진 Perl 내장 중 하나를 포함합니다. 이 예제 에서 명령 행의 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 는 첫 번째 인수가 8 진임을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d33a707f660fda2085139973d7ad824dc2ab179f" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;chmod&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">이 문제는 일반적으로 명령 줄에서 8 진수를 인수로 사용하는 Unix 명령과 동일한 이름을 가진 Perl 내장 기능 중 하나와 관련됩니다. 이 예 에서 명령 줄의 &lt;code&gt;chmod&lt;/code&gt; 는 첫 번째 인수가 8 진수라는 것을 알고 있습니다. 이것이 수행하는 작업이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="78b6c2ab73ee787f434ee0ce1c24dc74fd9f5055" translate="yes" xml:space="preserve">
          <source>This problem was fixed in perl 5.004_05, so preventing it means upgrading your version of perl. ;)</source>
          <target state="translated">이 문제는 perl 5.004_05에서 수정되었으므로이를 방지하는 것은 perl 버전을 업그레이드하는 것을 의미합니다. ;)</target>
        </trans-unit>
        <trans-unit id="149ef363e988711abf3a930d8381275df0baf405" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">이것은 &lt;code&gt;@lines&lt;/code&gt; 행을 처리합니다. 여기서 각 목록 항목은 정의 된 값이어야하며 정확히 한 줄의 내용을 포함해야합니다. 따라서 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 와 같은 항목 은 허용되지 않습니다. 최종 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 파싱되는 문서의 끝을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="688ef3f8e6f5eaf3a51865a695b77382ce66b228" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;undef&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">이것은 &lt;code&gt;@lines&lt;/code&gt; 의 행을 처리합니다 (여기서 각 목록 항목은 정의 된 값이어야하며 정확히 한 행의 내용을 포함해야합니다. 따라서 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 와 같은 항목 은 허용되지 않습니다). 최종 &lt;code&gt;undef&lt;/code&gt; 는 구문 분석중인 문서의 끝을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c20dce79362eb3c48b58c8e5bc86aad6133c323" translate="yes" xml:space="preserve">
          <source>This produces a patch based on the difference between blead and your current branch. It's important to make sure that blead is up to date before producing the diff, that's why we call &lt;code&gt;git pull&lt;/code&gt; first.</source>
          <target state="translated">이것은 블리드와 현재 브랜치의 차이를 기반으로 패치를 생성합니다. diff를 생성하기 전에 블리드가 최신 상태인지 확인하는 것이 중요 &lt;code&gt;git pull&lt;/code&gt; 먼저 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5a3bf030e7bf490188072c702d468c0925c814bb" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt; . Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">이것은 Perl docs 온라인 서적 &lt;code&gt;perl.INF&lt;/code&gt; 를 생성합니다 . &lt;code&gt;BOOKSHELF&lt;/code&gt; 경로 에 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1d23f3b834b32d7a55e6f86f555013820b4d006" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt;. Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">이것은 Perl 문서 온라인 서적 &lt;code&gt;perl.INF&lt;/code&gt; 를 생성합니다 . &lt;code&gt;BOOKSHELF&lt;/code&gt; 경로 에 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="7a75bb1a7c7847916a1dc3b67dbf0cb3e9f1aba1" translate="yes" xml:space="preserve">
          <source>This produces the default error string for the given exception,</source>
          <target state="translated">이것은 주어진 예외에 대한 기본 오류 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2c9c734dac073d3001ca1ea5f8fa8cfb8daa173b" translate="yes" xml:space="preserve">
          <source>This program is Copyright 1990,2015 by Johan Vromans. This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</source>
          <target state="translated">이 프로그램은 Johan Vromans의 저작권 1990,2015입니다. 이 프로그램은 무료 소프트웨어입니다. 자유 소프트웨어 재단이 출판 한 Perl Artistic License 또는 GNU General Public License의 조항에 따라 재배포 및 / 또는 수정할 수 있습니다. 라이센스 버전 2 또는 (선택에 따라) 이후 버전.</target>
        </trans-unit>
        <trans-unit id="26f7f8dba51ed564d4c376a299ad1ccb7d59f62d" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate and send bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">이 프로그램은 perl5와 함께 제공되는 모듈에 대한 버그 보고서 (및 감사 노트)를 생성하고 보내는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="95c0f8377730d3f4d0f475e508c5eeed353ea1d3" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">이 프로그램은 perl5 및 함께 제공되는 모듈에 대한 버그 보고서 (및 감사 노트)를 생성하는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="04d3efb8a4ca3ef394388570fac127108dc6a9fe" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See either the GNU General Public License or the Artistic License for more details.</source>
          <target state="translated">이 프로그램은 유용 할 것이라는 희망으로 배포되지만 어떠한 보증도 없습니다. 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증도 없습니다. 자세한 내용은 GNU General Public License 또는 Artistic License를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2cac2059d04ed459899445fb7d4adafed92ceb31" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">이 프로그램은 유용 할 것이라는 희망으로 배포되었지만 어떠한 보증도하지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증조차 포함하지 않습니다. 자세한 내용은 GNU General Public License를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8761e66f0aa0865d7b8a0fad53a385acc12de1d" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">이 프로그램은 유용하지만 보증없이 희망에 따라 배포됩니다. 상업성이나 특정 목적에의 적합성에 대한 묵시적 보증없이.</target>
        </trans-unit>
        <trans-unit id="2b736eab48b8800afefb519e32bdf619448f2254" translate="yes" xml:space="preserve">
          <source>This program is distributed under the Artistic License.</source>
          <target state="translated">이 프로그램은 예술 라이센스에 따라 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d0a6a12423ce6569360d8955fb54c14fc9d18b" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; or &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; for more info on that.</source>
          <target state="translated">이 프로그램은 perl 자체와 동일한 용어로 배포됩니다. 이에 대한 자세한 내용은 &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; 또는 &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f880f2d75284047b0b3ca19e5c220c8ba58fc91" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See http://perl.org/ or http://cpan.org/ for more info on that.</source>
          <target state="translated">이 프로그램은 perl 자체와 동일한 조건으로 배포됩니다. 이에 대한 자세한 내용은 http://perl.org/ 또는 http://cpan.org/를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c09da468beec666c3faa34069fc9e34aec608126" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">이 프로그램은 이해하기 쉽습니다. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 은 쉘에서 perl 프로그램을 호출하는 표준 방법입니다. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 첫 번째 명령 줄 인수를 사용할 정규 표현식으로 저장하고 나머지 명령 줄 인수는 파일로 처리합니다. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 는 모든 파일의 모든 줄을 반복합니다. 각 라인의 경우, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; 정규 표현식이 줄과 일치하면 줄을 인쇄합니다. 이 줄에서 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;/$regexp/&lt;/code&gt; 는 기본 변수 &lt;code&gt;$_&lt;/code&gt; 암시 적 으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1261f166c54df8049e546eae1262e6a9cada525" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = shift;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;print if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">이 프로그램은 이해하기 쉽습니다. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 은 쉘에서 perl 프로그램을 호출하는 표준 방법입니다. &lt;code&gt;$regexp = shift;&lt;/code&gt; 첫 번째 명령 줄 인수를 사용할 정규 표현식으로 저장하고 나머지 명령 줄 인수는 파일로 처리합니다. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 은 모든 파일의 모든 행을 반복합니다. 각 행에 대해 &lt;code&gt;print if /$regexp/;&lt;/code&gt; regexp가 행과 일치하면 행을 인쇄합니다. 이 줄에서 &lt;code&gt;print&lt;/code&gt; 와 &lt;code&gt;/$regexp/&lt;/code&gt; 는 모두 기본 변수 &lt;code&gt;$_&lt;/code&gt; 암시 적 으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b3f9820f4fcf840eefdc1fac524d68220274e583" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46aefc944a8368be1c5041bb6eeeeb6f411fe967" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7753908303851a8d71edec5d567bdf9359f255" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the terms of either:</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. 다음 조건 중 하나에 따라 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d232685400a50b411b31a9d8b5d5d46e7d1e5a7e" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the terms of either: the GNU General Public License as published by the Free Software Foundation; or the Artistic License.</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. 다음 조건 중 하나에 따라 재배포 및 / 또는 수정할 수 있습니다. Free Software Foundation에서 게시 한 GNU General Public License; 또는 예술적 라이센스.</target>
        </trans-unit>
        <trans-unit id="eda486acda27bdf9cd66949e1266b5a78cb661d8" translate="yes" xml:space="preserve">
          <source>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a9ebce432bc6f7a5abfa1673ae23d082772d50" translate="yes" xml:space="preserve">
          <source>This program is maintained by the Perl 5 Porters. The CPAN distribution is maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</source>
          <target state="translated">이 프로그램은 Perl 5 Porter가 관리합니다. CPAN 배포는 S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d98f469a4bef1492cbd51567cf72d3226f5fb0a1" translate="yes" xml:space="preserve">
          <source>This program provides an easy way to send a thank-you message back to the authors and maintainers of perl. It's just</source>
          <target state="translated">이 프로그램은 perl의 저자와 관리자에게 감사의 메시지를 쉽게 보낼 수있는 방법을 제공합니다. 그냥</target>
        </trans-unit>
        <trans-unit id="474e6c18a35ba4d4e6ef7db0a92aa1f2c8019fc7" translate="yes" xml:space="preserve">
          <source>This program uses the pipeline model to generate prime numbers. Each thread in the pipeline has an input queue that feeds numbers to be checked, a prime number that it's responsible for, and an output queue into which it funnels numbers that have failed the check. If the thread has a number that's failed its check and there's no child thread, then the thread must have found a new prime number. In that case, a new child thread is created for that prime and stuck on the end of the pipeline.</source>
          <target state="translated">이 프로그램은 파이프 라인 모델을 사용하여 소수를 생성합니다. 파이프 라인의 각 스레드에는 검사 할 숫자를 제공하는 입력 큐, 담당하는 소수 및 검사에 실패한 숫자를 퍼널 링하는 출력 큐가 있습니다. 스레드에 검사에 실패한 숫자가 있고 하위 스레드가없는 경우 스레드가 새로운 소수를 찾은 것입니다. 이 경우 해당 프라임에 대해 새 하위 스레드가 작성되고 파이프 라인 끝에 붙어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd07d758efadc42857a5a0bab51cd8a077edefd" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt; , it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">이 프로그램은 &quot;Bar&quot;가 포함 된 줄만 인쇄합니다. 범위 연산자가 &lt;code&gt;...&lt;/code&gt; 로 변경 되면 &quot;Baz&quot;줄도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="30db2380e071100cd380f37fbfe50881aec4a9f3" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt;, it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">이 프로그램은 &quot;Bar&quot;를 포함하는 행만 인쇄합니다. 범위 연산자가 &lt;code&gt;...&lt;/code&gt; 로 변경 되면 &quot;Baz&quot;행도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f91a32c34a450fa3aaeea5e09b4bf9753a0de2ef" translate="yes" xml:space="preserve">
          <source>This program will probably hang until you kill it. The only way it won't hang is if one of the two threads acquires both locks first. A guaranteed-to-hang version is more complicated, but the principle is the same.</source>
          <target state="translated">이 프로그램은 당신이 죽일 때까지 중단 될 것입니다. 중단되지 않는 유일한 방법은 두 스레드 중 하나가 두 잠금을 먼저 획득하는 것입니다. 매달린 버전은 더 복잡하지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5342717fe0bceba26cbcb8fb4ec4c851e52a537d" translate="yes" xml:space="preserve">
          <source>This project was originated by the late Nick Ing-Simmons and later maintained by Dan Kogai</source>
          <target state="translated">이 프로젝트는 Nick Ing-Simmons 말기에서 시작되었으며 나중에 Dan Kogai가 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9118e7dccf4093710a6ee14c8c47816f5d4b16b0" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;https://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">이 속성은 항상 복합 형식으로 작성됩니다. 예를 들어, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 은 일반적으로 오른쪽에서 왼쪽으로 쓰는 문자와 일치합니다. &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; 속성 과 달리이 속성은 향후 유니 코드 릴리스에서 더 많은 값을 추가 할 수 있습니다. 위에 나열된 것은 많은 유니 코드 릴리스에 대한 전체 세트를 구성했지만 나머지는 유니 코드 6.3에 추가되었습니다. &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; 에서 현재 항목이 무엇인지 항상 찾을 수 있습니다 . 그리고 &lt;a href=&quot;https://www.unicode.org/reports/tr9/&quot;&gt;https://www.unicode.org/reports/tr9/&lt;/a&gt; 는 사용 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d353efbbda92520a2429ad4f8535f649667e5952" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">이 속성은 항상 복합 형식으로 작성됩니다. 예를 들어, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 은 일반적으로 오른쪽에서 왼쪽으로 쓰는 문자와 일치합니다. &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 속성 과 달리이 속성은 향후 유니 코드 릴리스에서 더 많은 값을 추가 할 수 있습니다. 위에 나열된 것들은 많은 유니 코드 릴리스에 대한 완전한 세트로 구성되었지만 다른 것들은 유니 코드 6.3에 추가되었습니다. 당신은 항상 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; 에있는 것들을 찾을 수 있습니다 . 그리고 &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; 는 그것들을 사용하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9d34b69b565209c628e5e765cbc6639e949afb7e" translate="yes" xml:space="preserve">
          <source>This property is used when you need to know in what Unicode version(s) a character is.</source>
          <target state="translated">이 속성은 문자가 어떤 유니 코드 버전인지 알아야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba740c0026c45f2093377326c9e21d5c765b2b70" translate="yes" xml:space="preserve">
          <source>This provides access to most of the Win32 GUI widgets from Perl. Obviously, it only runs under Win32, and uses native widgets. The Perl interface doesn't really follow the C interface: it's been made more Perlish, and the documentation is pretty good. More advanced stuff may require familiarity with the C Win32 APIs, or reference to MSDN.</source>
          <target state="translated">이를 통해 Perl에서 대부분의 Win32 GUI 위젯에 액세스 할 수 있습니다. 분명히 Win32에서만 실행되며 기본 위젯을 사용합니다. Perl 인터페이스는 실제로 C 인터페이스를 따르지 않습니다. 더 Perlish로 만들어졌으며 문서는 꽤 좋습니다. 고급 기능을 사용하려면 C Win32 API에 익숙하거나 MSDN을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="05ed7360b5662052cf8df531a4821820675f5a90" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file.</source>
          <target state="translated">이는 확장에서 내보낼 함수 이름을 지정하는 대체 수단을 제공합니다. 이 값은 확장 프로그램에서 내보낼 함수 이름 배열에 대한 참조입니다. 이러한 이름은 변경되지 않은 상태로 링커 옵션 파일로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b6d4501c0d8df55386bc41a04cfb00e365ded86e" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file. Specifying a value for the FUNCLIST attribute suppresses automatic generation of the bootstrap function for the package. To still create the bootstrap name you have to specify the package name in the DL_FUNCS hash:</source>
          <target state="translated">이는 확장에서 내보낼 함수 이름을 지정하는 대체 수단을 제공합니다. 이 값은 확장 프로그램에서 내보낼 함수 이름 배열에 대한 참조입니다. 이러한 이름은 변경되지 않은 상태로 링커 옵션 파일로 전달됩니다. FUNCLIST 속성 값을 지정하면 패키지에 대한 부트 스트랩 기능의 자동 생성이 억제됩니다. 부트 스트랩 이름을 계속 작성하려면 DL_FUNCS 해시에서 패키지 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5949eb8258f363515432b75a3130bd3950de7ae" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;../../harness#jobs&quot;&gt;jobs in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness &lt;/a&gt;&lt;a href=&quot;../../harness#jobs&quot;&gt;에서&lt;/a&gt; 여러 작업으로 실행될 때 TAP :: Harness에 대한 콘솔 지향 출력 형식을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5c754e200bc077c2bf6996a1253c57ba0690ec6b" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;TAP::Harness#jobs&quot;&gt;&quot;jobs&quot; in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">이는 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt; 에서 여러 &lt;a href=&quot;TAP::Harness#jobs&quot;&gt;&quot;작업&quot;으로&lt;/a&gt; 실행될 때 TAP :: Harness에 대한 콘솔 지향 출력 형식을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9181d13c6755b2d2d5fcc68549a86008e0459f52" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for TAP::Harness.</source>
          <target state="translated">TAP :: Harness에 대한 콘솔 지향 출력 형식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cb848608e40dafbcfe04519def93d68a46db285b" translate="yes" xml:space="preserve">
          <source>This provides fairly low-level access to the Win32 System API calls dealing with files and directories.</source>
          <target state="translated">이는 파일 및 디렉터리를 처리하는 Win32 시스템 API 호출에 대해 상당히 낮은 수준의 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d034d371e8adbdcae6dcc8b5f1035f643b009166" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness에&lt;/a&gt; 대한 파일 지향 출력 형식을 제공합니다 . 병렬 테스트를 실행할 때는 특히 중요하지만 테스트 결과가 인터리브되지 않도록 보장하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="41a1e8e2958aae247fdb0f251950cd9259ec4e20" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness에&lt;/a&gt; 대한 파일 지향 출력 형식을 제공합니다 . 병렬 테스트로 실행할 때는 상세하게 실행하더라도 테스트 결과가 인터리브되지 않도록하기 때문에 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="be3613f62ba727bb8044f064f871c5a2ffe96d89" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for TAP::Harness.</source>
          <target state="translated">TAP :: Harness에 대한 파일 지향 출력 형식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e79f6eddf4d757dda9eee150d598652b5e165fe6" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">이것은 현재 서브 루틴에 대한 참조를 리턴하거나 서브 루틴 외부의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴하는 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 토큰을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3e44b62c4658b0866a101af4ad0e69174b50a666" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;__SUB__&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;undef&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">이것은 현재 서브 루틴 또는 서브 루틴 외부의 &lt;code&gt;undef&lt;/code&gt; 에 대한 참조를 반환하는 &lt;code&gt;__SUB__&lt;/code&gt; 토큰을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="224c6e548e4884dfbdfe2ac071bf15dda7c825fc" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt; , manually move the built</source>
          <target state="translated">실행 파일은 f : / perllib / bin에 저장됩니다. 수동으로 &lt;code&gt;PATH&lt;/code&gt; 로 옮기고 빌드 된 것을 수동으로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="0f078af34eb1808b4b8645c105ffb896a2e3287b" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt;, manually move the built</source>
          <target state="translated">그러면 실행 파일이 f : / perllib / bin에 저장됩니다. 수동으로 &lt;code&gt;PATH&lt;/code&gt; 로 이동하고 빌드 된</target>
        </trans-unit>
        <trans-unit id="d9a0cac7b723579ba6e539b4576a4997c5b49e8f" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">이 읽기 전용 변수에는 마지막으로 읽은 파일 핸들에 대한 참조가 포함됩니다. 이것은 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 로 설정 됩니다. 이것은 &lt;code&gt;$.&lt;/code&gt; 와 같은 핸들입니다 . 그리고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수를 사용하지 않고. 또한 Perl이 &quot;, &amp;lt;STDIN&amp;gt; line 1&quot;을 오류 또는 경고 메시지에 추가 할 때 사용되는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="be43d29d7cb60d0bb5d93c01c4c8424abbd333f2" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;tell&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt; and &lt;code&gt;seek&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;tell&lt;/code&gt; and &lt;code&gt;eof&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">이 읽기 전용 변수는 마지막으로 읽은 파일 핸들에 대한 참조를 포함합니다. 이것은 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;readline&lt;/code&gt; , &lt;code&gt;tell&lt;/code&gt; , &lt;code&gt;eof&lt;/code&gt; 및 &lt;code&gt;seek&lt;/code&gt; 에 의해 설정됩니다 . 이것은 &lt;code&gt;$.&lt;/code&gt; 와 동일한 핸들입니다 . 그리고 &lt;code&gt;tell&lt;/code&gt; 과 &lt;code&gt;eof&lt;/code&gt; 인수를 사용하지 않고. 또한 Perl이 &quot;, &amp;lt;STDIN&amp;gt; line 1&quot;을 오류 또는 경고 메시지에 추가 할 때 사용되는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="36a8564c99d9b70452198f29efc00c01b42f3989" translate="yes" xml:space="preserve">
          <source>This readonly SV has a zero numeric value and a &lt;code&gt;&quot;0&quot;&lt;/code&gt; string value. It's similar to &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt; except for its string value. Can be used as a cheap alternative to &lt;code&gt;mXPUSHi(0)&lt;/code&gt; for example. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_zero&lt;/code&gt;. Introduced in 5.28.</source>
          <target state="translated">이 읽기 전용 SV는 숫자 값이 0이고 문자열 값 이 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 입니다. 문자열 값을 제외하고 &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt; 와 유사 합니다. 예를 들어 &lt;code&gt;mXPUSHi(0)&lt;/code&gt; 의 저렴한 대안으로 사용할 수 있습니다 . 항상 &lt;code&gt;&amp;amp;PL_sv_zero&lt;/code&gt; 로 참조하십시오 . 5.28에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e9c374af25573cbb8a011c91df0b5de175403d9" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt; 's class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">이것은 사용자가 지정하는 파일 (또는 핸들)의 포드 내용을 읽고, 그와 함께 처리 &lt;code&gt;$parser&lt;/code&gt; 객체, 그러나에 따라 &lt;code&gt;$parser&lt;/code&gt; 클래스 작품의, 그리고 당신이에 설정 한 어떤 파서 옵션에 따라 &lt;code&gt;$parser&lt;/code&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="a26e710e2e27380d631c3ef937b2b0240e77b996" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt;'s class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">이것은 사용자가 지정하는 파일 (또는 핸들)의 포드 내용을 읽고, 그와 함께 처리 &lt;code&gt;$parser&lt;/code&gt; 객체, 그러나에 따라 &lt;code&gt;$parser&lt;/code&gt; 클래스 작품의, 그리고 당신이에 설정 한 어떤 파서 옵션에 따라 &lt;code&gt;$parser&lt;/code&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="49bb05c8de9876d308efc2608bb9d89029538d52" translate="yes" xml:space="preserve">
          <source>This refers to a namespace declared with the Perl &lt;code&gt;package&lt;/code&gt; statement. In Perl, packages often have a version number property given by the &lt;code&gt;$VERSION&lt;/code&gt; variable in the namespace.</source>
          <target state="translated">이것은 Perl &lt;code&gt;package&lt;/code&gt; 문으로 선언 된 네임 스페이스를 나타냅니다 . Perl에서 패키지는 종종 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수에서 제공하는 버전 번호 속성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b4ff270630232407257920d032001ef8966fbd15" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code contained in a single file. Modules usually contain one or more packages and are often referred to by the name of a primary package that can be mapped to the file name. For example, one might refer to &lt;code&gt;File::Spec&lt;/code&gt; instead of</source>
          <target state="translated">이것은 단일 파일에 포함 된 재사용 가능한 코드 라이브러리를 나타냅니다. 모듈은 일반적으로 하나 이상의 패키지를 포함하며 종종 파일 이름에 매핑 될 수있는 기본 패키지의 이름으로 참조됩니다. 예를 들어, &lt;code&gt;File::Spec&lt;/code&gt; 대신 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8d7cb3ad9af8785004d6aea2c58d998c7c43122" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code typically contained in a single file. Currently, we primarily talk of perl modules, but this specification should be open enough to apply to other languages as well (ex. python, ruby).</source>
          <target state="translated">일반적으로 단일 파일에 포함 된 재사용 가능한 코드 라이브러리를 나타냅니다. 현재 우리는 주로 펄 모듈에 대해 이야기하지만,이 사양은 다른 언어 (예 : python, ruby)에도 적용 할 수있을만큼 개방되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eced75506fbb27c39fc8e3e1e378940cf07d3648" translate="yes" xml:space="preserve">
          <source>This refers to a reusable library of code typically contained in a single file. Currently, we primarily talk of perl modules, but this specification should be open enough to apply to other languages as well (ex. python, ruby). Examples of modules are &lt;code&gt;Class::Container&lt;/code&gt;, &lt;code&gt;LWP::Simple&lt;/code&gt;, or &lt;code&gt;DBD::File&lt;/code&gt;.</source>
          <target state="translated">일반적으로 단일 파일에 포함 된 재사용 가능한 코드 라이브러리를 나타냅니다. 현재 우리는 주로 펄 모듈에 대해 이야기하지만,이 사양은 다른 언어 (예 : python, ruby)에도 적용 할 수있을만큼 개방되어 있어야합니다. 모듈의 예는 &lt;code&gt;Class::Container&lt;/code&gt; , &lt;code&gt;LWP::Simple&lt;/code&gt; 또는 &lt;code&gt;DBD::File&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="738d39668fa39fd446be00455410afcfca770f3c" translate="yes" xml:space="preserve">
          <source>This refers to code that constructs a metadata data structure, serializes into a bytestream and/or writes it to disk.</source>
          <target state="translated">이것은 메타 데이터 데이터 구조를 구성하고 바이트 스트림으로 직렬화하거나 디스크에 쓰는 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fdbb6deaa19e9a370f00c7ae0865d9d2054ba9d5" translate="yes" xml:space="preserve">
          <source>This refers to code that reads a metadata file, deserializes it into a data structure in memory, or interprets a data structure of metadata elements.</source>
          <target state="translated">이는 메타 데이터 파일을 읽고,이를 메모리의 데이터 구조로 역 직렬화하거나, 메타 데이터 요소의 데이터 구조를 해석하는 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c31dda74f7214f2c1e1f0e262ad534c6710776eb" translate="yes" xml:space="preserve">
          <source>This regex from Benjamin Goldberg will add commas to numbers:</source>
          <target state="translated">Benjamin Goldberg 의이 정규식은 숫자에 쉼표를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="056a5755811e26e84ba66501ddc6e8aa83e0239e" translate="yes" xml:space="preserve">
          <source>This regexp covers a much more limited set of formats and constitutes the best practices for initializing version objects. Whether you choose to employ decimal or dotted-decimal for is a personal preference however.</source>
          <target state="translated">이 정규식은 훨씬 더 제한된 형식 집합을 다루며 버전 개체를 초기화하는 모범 사례를 구성합니다. 그러나 십진수 또는 점 분리 십진수를 사용하도록 선택하는 것은 개인적인 선호 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d63b86d7679f940ac8c61114c80aac9d0dbe5e33" translate="yes" xml:space="preserve">
          <source>This regexp covers all of the legal forms allowed under the current version string parser. This is not to say that all of these forms are recommended, and some of them can only be used when quoted.</source>
          <target state="translated">이 정규식은 현재 버전 문자열 파서에서 허용되는 모든 법적 형식을 다룹니다. 이것은 이러한 모든 양식이 권장된다는 의미가 아니며 일부는 인용 된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5402a82ba706913f690e8b3975f67ccd9cac88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt; . The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">이 정규식은 일반적인 작업을 표시합니다. 대소 문자를 구분하지 않습니다. 펄은 경기의 끝에 &lt;code&gt;'i'&lt;/code&gt; 를 추가하여 모든 대괄호를 피하는 방법을 제공합니다 . 그런 다음 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; &lt;code&gt;/yes/i;&lt;/code&gt; 로 다시 쓸 수 있습니다 . . 는 &lt;code&gt;'i'&lt;/code&gt; 대소 문자 구별 약자와의 예</target>
        </trans-unit>
        <trans-unit id="3a214c88f7b6824fbb7ccf51b387a9a746e2ab88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt;. The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">이 정규식은 일반적인 작업을 표시합니다. 대소 문자를 구분하지 않는 일치를 수행합니다. Perl은 단순히 경기 끝에 &lt;code&gt;'i'&lt;/code&gt; 를 추가하여 이러한 모든 대괄호를 피하는 방법을 제공합니다 . 그런 다음 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; &lt;code&gt;/yes/i;&lt;/code&gt; 로 다시 작성할 수 있습니다 . . 는 &lt;code&gt;'i'&lt;/code&gt; 대소 문자 구별 약자와의 예</target>
        </trans-unit>
        <trans-unit id="f039b2c10f0c743bc7161531bc5bb4ee7cf32e0f" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt; . One might think that &lt;code&gt;e&lt;/code&gt; , being leftmost in the alternation, would be matched, but &lt;code&gt;r&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">이 정규 표현식은 가장 빠른 문자열 위치 &lt;code&gt;'T'&lt;/code&gt; 에서 일치합니다 . 교대에서 가장 왼쪽에있는 &lt;code&gt;e&lt;/code&gt; 가 일치 한다고 생각할 수도 있지만 &lt;code&gt;r&lt;/code&gt; 은 첫 번째 수량 자에서 가장 긴 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="18bc3044ad1a70322cf6bfca75dfe2f27fadde89" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt;. One might think that &lt;code&gt;'e'&lt;/code&gt;, being leftmost in the alternation, would be matched, but &lt;code&gt;'r'&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">이 정규 표현식은 가장 빠른 문자열 위치 &lt;code&gt;'T'&lt;/code&gt; 에서 일치합니다 . 하나는 생각할 수도 &lt;code&gt;'e'&lt;/code&gt; 는 교대에서 왼쪽 인이 일치 될 수 있지만, &lt;code&gt;'r'&lt;/code&gt; 최초의 정량에서 가장 긴 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b2afed8f05eefbd66a6b4b21a4dd6dc09f86be3d" translate="yes" xml:space="preserve">
          <source>This regexp without the &lt;code&gt;/x&lt;/code&gt; modifier is</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; 수정자가 없는이 정규식 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7d61ce1428d48124b4e47e558b037fdd3f04877" translate="yes" xml:space="preserve">
          <source>This registers warning categories for the given names and is primarily for use by the warnings::register pragma.</source>
          <target state="translated">지정된 이름에 대한 경고 범주를 등록하며 주로 warnings :: register pragma에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac7da667100d67a773306ce2d3526ac0aaefa222" translate="yes" xml:space="preserve">
          <source>This release (5.14) uses &lt;code&gt;unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;win32&lt;/code&gt; layer, which is expected to be enhanced and should eventually become the default under Win32.</source>
          <target state="translated">이 릴리스 (5.14)는 &lt;code&gt;unix&lt;/code&gt; 를 Win32의 최하위 계층으로 사용하므로 여전히 C 컴파일러의 숫자 파일 디스크립터 루틴을 사용합니다. 실험적인 기본 &lt;code&gt;win32&lt;/code&gt; 레이어가 있으며 이는 향상 될 것으로 예상되며 결국 Win32에서 기본값이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e97366cc6c8c908874e040814cdab3c3ba7152dc" translate="yes" xml:space="preserve">
          <source>This release (5.30) uses &lt;code&gt;:unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;:win32&lt;/code&gt; layer, which is expected to be enhanced and may eventually become the default under Win32.</source>
          <target state="translated">이 릴리스 (5.30)는 Win32의 맨 아래 계층으로 &lt;code&gt;:unix&lt;/code&gt; 를 사용하므로 C 컴파일러의 숫자 파일 설명자 루틴을 계속 사용합니다. 실험적인 네이티브 &lt;code&gt;:win32&lt;/code&gt; 레이어가 있는데, 이는 향상 될 것으로 예상되며 결국 Win32에서 기본값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e93ba339b839f549405138c86c3e7a085e38a6" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt; ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">이 Storable 릴리스는 최신 Perl 버전에서 사용되어 이전 Perls에서 지원하지 않는 데이터를 직렬화 할 수 있습니다. 기본적으로 Storable은 deserialize 할 수없는 데이터가 발견되면 &lt;code&gt;croak()&lt;/code&gt; 하여 올바른 작업을 시도합니다 . 그러나 기본값은 다음과 같이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ffdd0bf1fbd694aafba1b69b74908623d9b39e0" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt;ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">이 Storable 릴리스는 최신 버전의 Perl에서 이전 Perls에서 지원하지 않는 데이터를 직렬화하는 데 사용할 수 있습니다. 기본적으로 Storable은 deserialize 할 수없는 데이터를 발견하면 &lt;code&gt;croak()&lt;/code&gt; ing 하여 올바른 작업을 시도합니다 . 그러나 기본값은 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224448a00c11022eb7a054d96b5b7887fe965764" translate="yes" xml:space="preserve">
          <source>This relied on &lt;code&gt;Test::Builder-&amp;gt;_try()&lt;/code&gt; which was a private method, documented as something nobody should use. This was fixed by using a different tool.</source>
          <target state="translated">이것은 아무도 사용해서는 안되는 것으로 문서화 된 개인 메서드 인 &lt;code&gt;Test::Builder-&amp;gt;_try()&lt;/code&gt; 에 의존했습니다 . 이것은 다른 도구를 사용하여 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1df9abd6e13cb17537a033c0a98a21365649ee63" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">이것은 초기화되지 않은 배열 요소가 &lt;code&gt;NULL&lt;/code&gt; 로 설정되어 있다는 사실에 의존 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d1b77b3467fa5b58df05f447b8e32028382b1ea" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to NULL.</source>
          <target state="translated">이것은 초기화되지 않은 배열 요소가 NULL로 설정되어 있다는 사실에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="44ecfba29c712b60c9051df87b6cdce165f041c1" translate="yes" xml:space="preserve">
          <source>This removes the requirement for a given module from the object.</source>
          <target state="translated">이렇게하면 개체에서 주어진 모듈에 대한 요구 사항이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9d7d55aad79de70107f3e8211b62fbf8c98570e5" translate="yes" xml:space="preserve">
          <source>This renders a print statement, which includes a call to the function. It's identical to rendering a file with a use call and that single statement, except for the filename which appears in the nextstate ops.</source>
          <target state="translated">함수에 대한 호출을 포함하는 print 문을 렌더링합니다. nextstate ops에 나타나는 파일 이름을 제외하고 use 호출과 단일 명령문으로 파일을 렌더링하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea6f5b9409b135d9fd2914f5e9712bb211e3d415" translate="yes" xml:space="preserve">
          <source>This renders all functions in the B::Concise package with the source lines. It eschews the O framework so that the stashref can be passed directly to B::Concise::compile(). See -stash option for a more convenient way to render a package.</source>
          <target state="translated">이렇게하면 B :: Concise 패키지의 모든 기능이 소스 행과 함께 렌더링됩니다. stashref가 B :: Concise :: compile ()에 직접 전달 될 수 있도록 O 프레임 워크를 생략합니다. 보다 편리한 패키지 렌더링 방법은 -stash 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32554955438229712c4cac893fa9122a188f77ea" translate="yes" xml:space="preserve">
          <source>This replaces any read-only SV with a fresh SV and removes any magic.</source>
          <target state="translated">이것은 모든 읽기 전용 SV를 새로운 SV로 대체하고 모든 마법을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e348cbe59c03a2464d04a9305501c3c5773cd34e" translate="yes" xml:space="preserve">
          <source>This replaces any read-only SV with a fresh writable copy and removes any magic.</source>
          <target state="translated">이것은 모든 읽기 전용 SV를 새로운 쓰기 가능한 복사본으로 대체하고 모든 마법을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4e89c15d6e7988885e07ca54d3050b10693c573d" translate="yes" xml:space="preserve">
          <source>This reports whether the VMS process has been set to a case tolerant state, and returns true when the process is in the traditional case tolerant mode and false when case sensitivity has been enabled for the process. It is intended for use by the File::Spec::VMS-&amp;gt;case_tolerant method only, and it is recommended that you only use File::Spec-&amp;gt;case_tolerant.</source>
          <target state="translated">이는 VMS 프로세스가 대소 문자 허용 상태로 설정되었는지 여부를보고하고 프로세스가 기존 대소 문자 허용 모드에있는 경우 true를 반환하고 프로세스에 대해 대소 문자 구분이 활성화 된 경우 false를 반환합니다. 이는 File :: Spec :: VMS-&amp;gt; case_tolerant 메소드에서만 사용하기위한 것이며 File :: Spec-&amp;gt; case_tolerant 만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="65869e50f6892b08c4cf7dcb78cc5963bf748c6b" translate="yes" xml:space="preserve">
          <source>This requires &lt;code&gt;perl-5.8&lt;/code&gt; or higher, compiled with &lt;code&gt;perlio&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;perlio&lt;/code&gt; 로 컴파일 된 &lt;code&gt;perl-5.8&lt;/code&gt; 이상 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf4909d18f4323c37d07bae96a1d0080562f63f5" translate="yes" xml:space="preserve">
          <source>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</source>
          <target state="translated">이를 위해서는 64 비트 MIPS CPU (R8000, R10000, ...)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f7da7513031db644267fa4b13fabe99ed2a030c7" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; , into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">그러면 표준 선 스타일 중 하나 인 &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; 가복원 됩니다. 또한 add_style ()로 이전에 정의 된 스타일 이름도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="36fc0f09fd582998b2f90539bd1668c94507a44b" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt;, &lt;code&gt;concise&lt;/code&gt;, &lt;code&gt;linenoise&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt;, into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">이렇게하면 표준 라인 스타일 중 하나 인 &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; 가 적용됩니다. 또한 이전에 add_style ()로 정의 된 스타일 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f0559182bda8492a3ca4dae9b14b73dc55291956" translate="yes" xml:space="preserve">
          <source>This restores the default behavior after you've changed it with '-main' (it's not normally needed). If no subroutine name/ref is given, main is rendered, regardless of this flag.</source>
          <target state="translated">'-main'으로 변경 한 후 기본 동작이 복원됩니다 (일반적으로 필요하지 않음). 서브 루틴 이름 / 참조가 제공되지 않으면이 플래그에 관계없이 main이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f49545d47b4c2e67130feb223d7916803e2151e7" translate="yes" xml:space="preserve">
          <source>This restores the token object(s) to the front of the parser stream.</source>
          <target state="translated">토큰 객체를 파서 스트림의 전면으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="bc16a591c72f30b96574184a49591c3cb8b3396e" translate="yes" xml:space="preserve">
          <source>This results in checking out the median commit between &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;perl-5.10.0&lt;/code&gt;. You can then run the bisecting process with:</source>
          <target state="translated">결과적으로 &lt;code&gt;HEAD&lt;/code&gt; 와 &lt;code&gt;perl-5.10.0&lt;/code&gt; 사이의 중앙 커밋을 확인합니다 . 그런 다음 다음을 사용하여 이등분 프로세스를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc61a1506f4a52166fcca29cd0724a61c00502b" translate="yes" xml:space="preserve">
          <source>This returns -1 if it is not possible to know.</source>
          <target state="translated">알 수없는 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c7a366a88c90193129d1a95d7e39c2f2c494051" translate="yes" xml:space="preserve">
          <source>This returns -1 if there is no way to check (assume yes)</source>
          <target state="translated">확인할 방법이 없으면 -1을 반환합니다 (예라고 가정).</target>
        </trans-unit>
        <trans-unit id="cc21f44beb4322ca69654d9019b9237853614328" translate="yes" xml:space="preserve">
          <source>This returns 0 if there are (most likely) no pending events.</source>
          <target state="translated">보류중인 이벤트가 없을 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8bd0398abb2c08261b0415684f65513126559e63" translate="yes" xml:space="preserve">
          <source>This returns 0 if there are no pending events.</source>
          <target state="translated">보류중인 이벤트가 없으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e5a3b4ddffecb8501f761fb971c3b2d6c7162bb" translate="yes" xml:space="preserve">
          <source>This returns 1 if there are (likely) pending events. Upon return it will reset, nothing else will be able to see that there were pending events.</source>
          <target state="translated">보류중인 이벤트가있는 경우 1을 반환합니다. 반환되면 재설정되며 보류중인 이벤트가 있다는 것을 다른 사람이 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa266181f0344e330298c3c78c5770ba393e0756" translate="yes" xml:space="preserve">
          <source>This returns 1 if there are pending events.</source>
          <target state="translated">보류중인 이벤트가있는 경우 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="438306ebd9d1acbe91b86dc11907f9e6dab643b7" translate="yes" xml:space="preserve">
          <source>This returns NULL if the variable does not exist.</source>
          <target state="translated">변수가 존재하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a696a06774c6f3002eeb51ec2f2001513d53029" translate="yes" xml:space="preserve">
          <source>This returns a data structure containing the version requirements for a given module or undef if the given module has no requirements. This should not be used for version checks (see &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; instead).</source>
          <target state="translated">이것은 주어진 모듈에 대한 버전 요구 사항을 포함하는 데이터 구조를 반환하거나 주어진 모듈에 요구 사항이없는 경우 undef를 반환합니다. 버전 확인에 사용해서는 안됩니다 ( 대신 &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c37bfa051bc09e91f6aa8c8e068658f22a9b05b4" translate="yes" xml:space="preserve">
          <source>This returns a glob reference for the symbol table entry of VARNAME in the package of the compartment. VARNAME must be the &lt;b&gt;name&lt;/b&gt; of a variable without any leading type marker. For example:</source>
          <target state="translated">구획 패키지에서 VARNAME의 기호 테이블 항목에 대한 glob 참조를 리턴합니다. VARNAME은 선행 유형 표시자가없는 변수 의 &lt;b&gt;이름&lt;/b&gt; 이어야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4846a06785f0daaeee2213d80f23082c8fa4965c" translate="yes" xml:space="preserve">
          <source>This returns a handy stringified value of this object. This is useful for debugging, as in:</source>
          <target state="translated">이것은이 객체의 편리한 문자열 값을 반환합니다. 다음과 같이 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ed3e8770a5f12bfd2e6e0013e9c81234e1f2fd4f" translate="yes" xml:space="preserve">
          <source>This returns a list of all facets that have been loaded using the &lt;code&gt;load_facet()&lt;/code&gt; method. This will not return any classes that have not been loaded, or have been loaded directly without a call to &lt;code&gt;load_facet()&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;load_facet()&lt;/code&gt; 메서드를 사용하여로드 된 모든 패싯 목록이 반환 됩니다. 로드되지 않았거나 &lt;code&gt;load_facet()&lt;/code&gt; 호출하지 않고 직접로드 된 클래스는 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b1ea704d04f7c3ec75b7f4e64aa2fc6d627bedce" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; , etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">op의 aux 데이터 구조 요소 목록을 표시하거나 aux가 없으면 null 목록을 반환합니다. 반환되는 것은 객체의 유형에 따라 다르지만 일반적으로 &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; 등의 객체 컬렉션입니다 . &lt;code&gt;cv&lt;/code&gt; 는 op가 포함 된 하위를 나타내는 &lt;code&gt;B::CV&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="18b3e284330afc61e3a6c84779d9500461f4397e" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt;, &lt;code&gt;B::GV&lt;/code&gt;, etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">이것은 op의 aux 데이터 구조의 요소 목록을 반환하거나 aux가없는 경우 null 목록을 반환합니다. 반환되는 것은 객체의 유형에 따라 다르지만 일반적으로 &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; 등의 객체 모음입니다 . &lt;code&gt;cv&lt;/code&gt; 는 작업 이 포함 된 하위를 나타내는 &lt;code&gt;B::CV&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="78c4d2eacb966527e478f0083cb85da673514051" translate="yes" xml:space="preserve">
          <source>This returns a list of the names of all the installed modules. The perl 'core' is given the special name 'Perl'.</source>
          <target state="translated">설치된 모든 모듈의 이름 목록이 반환됩니다. 펄 '코어'에는 특수 이름 'Perl'이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="14379e40e50bf7d9283b3df7b37c3928bd424f74" translate="yes" xml:space="preserve">
          <source>This returns a new CPAN::Meta::Requirements object. It takes an optional hash reference argument. Currently, only one key is supported:</source>
          <target state="translated">이것은 새로운 CPAN :: Meta :: Requirements 객체를 반환합니다. 선택적 해시 참조 인수를 사용합니다. 현재는 하나의 키만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="531b8c5d5e45b476d43548e396af61e47ca0e014" translate="yes" xml:space="preserve">
          <source>This returns a new Feature object. The &lt;code&gt;%spec&lt;/code&gt; argument to the constructor should be the same as the value of the &lt;code&gt;optional_feature&lt;/code&gt; entry in the distmeta. It must contain entries for &lt;code&gt;description&lt;/code&gt; and &lt;code&gt;prereqs&lt;/code&gt;.</source>
          <target state="translated">새 기능 개체를 반환합니다. 생성자에 대한 &lt;code&gt;%spec&lt;/code&gt; 인수 는 distmeta 의 &lt;code&gt;optional_feature&lt;/code&gt; 항목 값과 동일해야합니다 . &lt;code&gt;description&lt;/code&gt; 및 &lt;code&gt;prereqs&lt;/code&gt; 에 대한 항목을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a39fe91e6096e4528d2eface949d54878f13adb3" translate="yes" xml:space="preserve">
          <source>This returns a new parser object, where</source>
          <target state="translated">새로운 파서 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0e359e0a6bfe07d5ae556f45550772e1dc21138" translate="yes" xml:space="preserve">
          <source>This returns a normal Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.</source>
          <target state="translated">$ x에서 일반 Perl 스칼라를 반환합니다. 예를 들어 배열 인덱스 작업에서 스칼라가 필요할 때마다 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="39af602c2add0567b4eacfb622fe97070c79fecd" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash describing the requirements using the strings in the &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; specification.</source>
          <target state="translated">&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt; 사양 의 문자열을 사용하여 요구 사항을 설명하는 해시에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4bedda000844c8f0e165c8e9491e25dc6f787dac" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt; , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">이는 키로 일반 카테고리 이름 (예 : &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; )이 있고 값 으로 &lt;code&gt;UppercaseLetter&lt;/code&gt; (예 : UppercaseLetter , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) 가있는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시를 되돌릴 수 있습니다. 일반 카테고리는 &lt;code&gt;category&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 에서 리턴 된 카테고리 입니다.</target>
        </trans-unit>
        <trans-unit id="039f30ebcd1468ad00dd473984fb486ddd84fa51" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt;, &lt;code&gt;Nd&lt;/code&gt;, &lt;code&gt;Zs&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt;, &lt;code&gt;DecimalNumber&lt;/code&gt;, &lt;code&gt;SpaceSeparator&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">이는 짧은 일반 카테고리 이름 (예 : &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; )을 키로, 긴 이름 (예 : &lt;code&gt;UppercaseLetter&lt;/code&gt; , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; )을 값 으로 갖는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시는 되돌릴 수 있습니다. 일반 범주는 &lt;code&gt;category&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;&lt;/a&gt; 에서 반환 된 범주 입니다.</target>
        </trans-unit>
        <trans-unit id="88c58feecc3765e5c4080f925afe0ce2010395de" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">이는 짧은 bidi (양방향) 유형 이름 (예 : &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; )을 키로, 긴 이름 (예 : &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; )을 값 으로 갖는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시를 되돌릴 수 있습니다. bidi 유형은 &lt;code&gt;bidi&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 에서 반환 된 유형입니다 . 다양한 bidi 클래스의 정확한 의미를 위해 유니 코드 TR9를 읽는 것이 좋습니다. &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (유니 코드 5.0.0부터)</target>
        </trans-unit>
        <trans-unit id="48267796da0925cc66914e24ff7b670270826077" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt;, &lt;code&gt;Right-to-Left&lt;/code&gt;) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">이는 짧은 bidi (양방향) 유형 이름 (예 : &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; )을 키로, 긴 이름 (예 : &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; )을 값 으로 갖는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시는 되돌릴 수 있습니다. bidi 유형은 &lt;code&gt;bidi&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;&lt;/a&gt; 에서 반환 된 유형입니다 . 다양한 비디 클래스의 정확한 의미에 대해서는 유니 코드 TR9를 읽을 것을 권장합니다 : &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (유니 코드 5.0.0 기준)</target>
        </trans-unit>
        <trans-unit id="1e684e737bcd2717e8bbc64c2a24292cf8407953" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;.</source>
          <target state="translated">이는 키가 모두 고유 한 유니 코드 (Perl 확장 없음) 속성이고 해당 값이 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;에&lt;/a&gt; 대한 해당 속성의 값인 해시에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9b6e4381af622706d0b561391364ef549fe16051" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;.</source>
          <target state="translated">키가 모두 고유 한 유니 코드 (확장자 없음) 특성이고 값이 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 의 해당 특성 값인 해시에 대한 참조를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="92aa49cb1c3f622edac6a155f13e38f83b6dfb08" translate="yes" xml:space="preserve">
          <source>This returns a scalar reference to the string that this token holds. This can be useful if you don't want to memory-copy the potentially large text value (well, as large as a paragraph or a verbatim block) as calling $token-&amp;gt;text would do.</source>
          <target state="translated">이 토큰이 보유한 문자열에 대한 스칼라 참조를 리턴합니다. 이것은 $ token-&amp;gt; text를 호출하는 것처럼 잠재적으로 큰 텍스트 값 (문단 또는 축약 블록만큼 큰)을 메모리 복사하지 않으려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34145279dcfb22813c0a829b74bb6750ab581547" translate="yes" xml:space="preserve">
          <source>This returns a string containing the version requirements for a given module in the format described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; or undef if the given module has no requirements. This should only be used for informational purposes such as error messages and should not be interpreted or used for comparison (see &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; instead).</source>
          <target state="translated">&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec에&lt;/a&gt; 설명 된 형식으로 주어진 모듈에 대한 버전 요구 사항을 포함하는 문자열을 반환 하거나 주어진 모듈에 요구 사항이없는 경우 undef를 반환합니다. 이것은 오류 메시지와 같은 정보 제공 목적으로 만 사용해야하며 해석하거나 비교를 위해 사용해서는 안됩니다 ( 대신 &lt;a href=&quot;#accepts_module&quot;&gt;&quot;accepts_module&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2ab22c2c85c0520c74858caf823a5761f4144c2f" translate="yes" xml:space="preserve">
          <source>This returns a string of the form &quot;AUTHORID/TARBALL&quot;. If you want the full path and filename to this distribution on a CPAN mirror, then it is &lt;code&gt;.../authors/id/A/AU/AUTHORID/TARBALL&lt;/code&gt;.</source>
          <target state="translated">&quot;AUTHORID / TARBALL&quot;형식의 문자열을 반환합니다. CPAN 미러에서이 배포에 대한 전체 경로와 파일 이름을 원한다면 &lt;code&gt;.../authors/id/A/AU/AUTHORID/TARBALL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ddd7e0058fbe245746ba269fcc6ddbdc3f189037" translate="yes" xml:space="preserve">
          <source>This returns a string reporting the $VERSION value from your module (and its classname) as well as the $VERSION value of Pod::Simple. Note that &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; requires output formats (wherever possible) to note this detail in a comment in the output format. For example, for some kind of SGML output format:</source>
          <target state="translated">그러면 모듈 (및 해당 클래스 이름)의 $ VERSION 값과 Pod :: Simple의 $ VERSION 값을보고하는 문자열이 반환됩니다. 참고 &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec이&lt;/a&gt; 출력 형식을 필요는 (가능한 한) 출력 형식의 주석에서이 세부 사항에 유의합니다. 예를 들어, 어떤 종류의 SGML 출력 형식의 경우 :</target>
        </trans-unit>
        <trans-unit id="78d7fbfdd37ad836b426c426d9f57674d28b607c" translate="yes" xml:space="preserve">
          <source>This returns a textual representation of the object (likely to b useful for deparsing and debugging), or an empty string if the op type doesn't support this. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">이것은 객체의 텍스트 표현 (파싱 및 디버깅에 유용 할 것 같음) 또는 op 유형이이를 지원하지 않는 경우 빈 문자열을 반환합니다. &lt;code&gt;cv&lt;/code&gt; 는 op가 포함 된 하위를 나타내는 &lt;code&gt;B::CV&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="589c10ddf68513d199db67a67a86aebabd06473d" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{ord(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(ord(&quot;A&quot;))&lt;/code&gt;;</source>
          <target state="translated">이것은 해시에 대한 참조 형식으로 현재 유니 코드 버전의 모든 대소 문자 접기를 반환합니다. 해시의 각 키는 자체 이외의 케이스 폴드가있는 유니 코드 문자의 십진수 표현입니다. 세미콜론의 케이스 폴드는 그 자체이므로 해시에 없습니다. 소문자 &quot;a&quot;와 마찬가지로 대문자 &quot;A&quot;에 대한 항목이 있습니다. 각 키의 해시 값은 해당 코드 포인트를 인수로 사용하여 호출 된 경우 &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold ()&quot;&lt;/a&gt; 가 반환하는 것과 동일한 또 다른 해시 입니다. 따라서 &lt;code&gt;all_casefolds()-&amp;gt;{ord(&quot;A&quot;)}'&lt;/code&gt; 은 &lt;code&gt;casefold(ord(&quot;A&quot;))&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5163e24143304da0c24ab6f05ddab5463a924808" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</source>
          <target state="translated">이렇게하면 현재 버전의 유니 코드에서 모든 대소 문자를 해시에 대한 참조 형식으로 반환합니다. 해시의 각 키는 자신 이외의 다른 사례가있는 유니 코드 문자의 10 진수 표현입니다. 세미콜론의 사례는 자체이므로 해시에는 없습니다. 마찬가지로 소문자 &quot;a&quot;에 대해서도 대문자 &quot;A&quot;에 대한 항목이 있습니다. 각 키의 해시 값은 다른 해시이며, 해당 코드 포인트를 인수로 사용하여 호출 한 경우 &lt;a href=&quot;#casefold()&quot;&gt;casefold ()에서&lt;/a&gt; 반환되는 것과 동일합니다 . 따라서 &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; 은 &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b91ef374b2d4fc8d006452914a0d544355b3b1bb" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt;) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">이것은 유니 코드 표준에 정의 된대로 필드의 해시에 대한 참조로 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;&lt;/a&gt; 에 대한 정보를 리턴합니다 . 는 IF &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수가&quot;&lt;/a&gt; 표준에 할당되지 않은 (즉, 일반 카테고리가 &lt;code&gt;Cn&lt;/code&gt; 의미 &lt;code&gt;Unassigned&lt;/code&gt; ) 또는 (이 표준에 배정하지 않는다는 보장을 의미)가 아닌 문자, &lt;code&gt;undef&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc96752d9a4198cd2cf54c44f2b3b5b10b6e33c5" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt; ) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">이것은 유니 코드 표준에 의해 정의 된대로 필드의 해시에 대한 참조로 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 에 대한 정보를 리턴합니다 . 경우 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수가&lt;/a&gt; 표준에 할당되지 않은 (즉, 일반 카테고리가 &lt;code&gt;Cn&lt;/code&gt; 의미 &lt;code&gt;Unassigned&lt;/code&gt; ) 또는 (이 표준에 배정하지 않는다는 보장을 의미)가 아닌 문자, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="720b1f4304617aafa21c73583795df1e0c36847e" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then an upgrade is required for the module to work properly.</source>
          <target state="translated">키 / 값 쌍을 반환합니다. 키는 모듈 이름이고 값은 버전 번호입니다. 설치된 모듈 버전이 지정된 버전 이하인 경우 모듈이 제대로 작동하려면 업그레이드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d4b8690d330c57f118fa7767021e234753523c18" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then an upgrade would be a good idea, but not strictly necessary.</source>
          <target state="translated">키 / 값 쌍을 반환합니다. 키는 모듈 이름이고 값은 버전 번호입니다. 설치된 모듈 버전이 지정된 버전 이하이면 업그레이드하는 것이 좋지만 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c8f9c7b3513420a38f5822d9d3cf20a8ca38b03e" translate="yes" xml:space="preserve">
          <source>This returns key/value pairs. The key is the module name, the value is the version number. If the installed version of the module is at or below the specified one then the module will not work. A newer version may work, but is not tested or verified.</source>
          <target state="translated">키 / 값 쌍을 반환합니다. 키는 모듈 이름이고 값은 버전 번호입니다. 설치된 모듈 버전이 지정된 버전 이하이면 모듈이 작동하지 않습니다. 최신 버전이 작동 할 수 있지만 테스트 또는 확인되지는 않았습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="69bdf5cea17e905e3d66cdc8ddc0f9c868e3cf58" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;fc()&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">이것은 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;로&lt;/a&gt; 지정된 문자의 (거의) 로케일 독립적 인 대소 문자 접기를 리턴합니다 . (Perl v5.16부터 핵심 함수 &lt;code&gt;fc()&lt;/code&gt; 는 이보다 빠르게 전체 문자열에 대해 &lt;code&gt;full&lt;/code&gt; 매핑 (아래 설명 )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eb91ab331ab9de210b4db7e921e9ff160732003a" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">이것은 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 argument로&lt;/a&gt; 지정된 문자의 (거의) 로케일 독립적 대소 문자를 리턴합니다 . (Perl v5.16부터 핵심 함수 &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; 는 전체 문자열에 대해 &lt;code&gt;full&lt;/code&gt; 매핑 (아래 설명 참조)을 더 빠르게 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="91677229ee695edb8db59966a9bf52f69db7141f" translate="yes" xml:space="preserve">
          <source>This returns the ExtUtils::Packlist object for the specified module.</source>
          <target state="translated">지정된 모듈에 대한 ExtUtils :: Packlist 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dffc96fcce0657afd70270ea32ed9cfdcbbe0c11" translate="yes" xml:space="preserve">
          <source>This returns the arguments that should be used to construct the proper &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; structure.</source>
          <target state="translated">적절한 &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info&lt;/a&gt; 구조 를 구성하는 데 사용해야하는 인수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc91311f7c5bdfc09fe1efb765e76b3d3c015ee2" translate="yes" xml:space="preserve">
          <source>This returns the count of Pod paragraphs seen so far.</source>
          <target state="translated">지금까지 본 Pod 단락의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ccaab350d04c0aa0ce59d8ea55f9203083f5944f" translate="yes" xml:space="preserve">
          <source>This returns the data structure used for tables by &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info&lt;/a&gt; 에서 테이블에 사용 된 데이터 구조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="91c8292002290e5d7ad79eff5f6aca62a17b0302" translate="yes" xml:space="preserve">
          <source>This returns the file format version as number. It is a string like &quot;2.007&quot;. This value is suitable for numeric comparisons.</source>
          <target state="translated">파일 형식 버전을 숫자로 반환합니다. &quot;2.007&quot;과 같은 문자열입니다. 이 값은 숫자 비교에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b28a3d3b844d30822d117ab98847259c42e20f28" translate="yes" xml:space="preserve">
          <source>This returns the file format version. It is a string like &quot;2.7&quot;.</source>
          <target state="translated">파일 형식 버전을 반환합니다. &quot;2.7&quot;과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="88abd5e16e9b3ba61f0f89ea977172fa6b064d17" translate="yes" xml:space="preserve">
          <source>This returns the filename that this parser object was set to read from.</source>
          <target state="translated">파서 객체를 읽도록 설정된 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bccff29a1ac784a814e5e53a8041bdec5c902b0f" translate="yes" xml:space="preserve">
          <source>This returns the full path of the first occurrence to the file. Package names (eg 'A::B') are automatically converted to directory names in the selected directory. Additionally, '.pm', '.pl' and '.pod' are automatically appended to the search as required. (So, for example, under Unix, &quot;A::B&quot; is converted to &quot;somedir/A/B.pm&quot;, &quot;somedir/A/B.pod&quot;, or &quot;somedir/A/B.pl&quot;, as appropriate.)</source>
          <target state="translated">이것은 첫 번째 발생의 전체 경로를 파일로 리턴합니다. 패키지 이름 (예 : 'A :: B')은 선택한 디렉토리의 디렉토리 이름으로 자동 변환됩니다. 또한 필요에 따라 '.pm', '.pl'및 '.pod'가 자동으로 검색에 추가됩니다. 따라서 예를 들어 Unix에서 &quot;A :: B&quot;는 다음과 같이 &quot;somedir / A / B.pm&quot;, &quot;somedir / A / B.pod&quot;또는 &quot;somedir / A / B.pl&quot;로 변환됩니다. 적당한.)</target>
        </trans-unit>
        <trans-unit id="2a501f04d237b4afdc751c24d97b1564c6c9be99" translate="yes" xml:space="preserve">
          <source>This returns the function name as a string (e.g. &quot;PL_ppaddr[OP_ADD]&quot;, &quot;PL_ppaddr[OP_RV2AV]&quot;).</source>
          <target state="translated">함수 이름을 문자열로 반환합니다 (예 : &quot;PL_ppaddr [OP_ADD]&quot;, &quot;PL_ppaddr [OP_RV2AV]&quot;).</target>
        </trans-unit>
        <trans-unit id="a6c7ba8cdf1911985e871524f867f03a73878f39" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt; 's implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">이것은 이 언어의 규칙에 따라 수량 &lt;code&gt;$number&lt;/code&gt; 에 적합한 주어진 명사 양식을 리턴합니다 . &lt;code&gt;numerate&lt;/code&gt; 는 명사를 정량화하기 위해 &lt;code&gt;quant&lt;/code&gt; 에 의해 내부적으로 사용됩니다 . &lt;code&gt;quant&lt;/code&gt; 의 &lt;code&gt;numf&lt;/code&gt; 에 대한 암시 적 호출 및 숫자 수량의 출력 을 피하려면 직접 대괄호 표기법으로 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3221ea44d138b99a98ddd26d5fa0b5a10d585e1" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt;'s implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">이 언어의 규칙에 따라 &lt;code&gt;$number&lt;/code&gt; 수량에 적합한 지정된 명사 형식을 반환합니다 . &lt;code&gt;numerate&lt;/code&gt; 는 명사를 수량화하기 위해 &lt;code&gt;quant&lt;/code&gt; 에 의해 내부적으로 사용됩니다 . &lt;code&gt;numf&lt;/code&gt; 에 대한 &lt;code&gt;quant&lt;/code&gt; 의 암시 적 호출 과 숫자 수량의 출력 을 피하기 위해 일반적으로 대괄호 표기법에서 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ecd76e9b7635df85484a01189e6a2f492cf6d79" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">이 언어의 규칙에 따라 형식이 지정된 주어진 숫자를 반환합니다. Maketext의 기본 방법은 대부분 숫자의 일반적인 문자열 형식 (매우 큰 숫자에만 sprintf &quot;% G&quot;적용)을 취한 다음 필요에 따라 쉼표를 추가하는 것입니다. ( $ language-&amp;gt; { 'numf_comma'}가 true 인 경우 &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; 적용한다는 점을 제외하고 는 &quot;백만이 아닌&quot;2.000.000 &quot;으로 표현되는 언어에는 유용한 해킹입니다. 2,000,000 &quot;).</target>
        </trans-unit>
        <trans-unit id="05a83ab19e6c9cde5d56340c6947ca203501a3b8" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;tr/,./.,/&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">이 언어의 규칙에 따라 멋지게 형식화 된 주어진 숫자를 반환합니다. Maketext의 기본 방법은 대개 숫자의 일반 문자열 형식 (매우 큰 숫자에만 sprintf &quot;% G&quot;적용)을 취한 다음 필요에 따라 쉼표를 추가하는 것입니다. ( $ language-&amp;gt; { 'numf_comma'}가 true 인 경우 &lt;code&gt;tr/,./.,/&lt;/code&gt; 을 적용하는 경우를 제외하고 , 이는 2 백만을 &quot;2.000.000&quot;으로 표현하고 &quot;로 표시하지 않는 언어에 유용한 약간의 해킹입니다. 2,000,000 &quot;).</target>
        </trans-unit>
        <trans-unit id="025fac90217d4ce617ea39a22bf3a99d01ca61a8" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">이 시작 토큰에 대해 설정된 속성 인 해시 참조를 리턴합니다. 이것은 (예를 들어) 모든 속성이 무엇인지 묻고 싶을 때 유용 &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c00d82623e18153d6a353f47395dae6583b5a22" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;keys %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">이것은이 시작 토큰에 대해 설정된 속성 인 해시 참조를 리턴합니다. 예를 들어 모든 속성이 무엇인지 묻고 싶을 때 유용 &lt;code&gt;keys %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a1d54ba9e2a0e72117dea2ff05555485f06342" translate="yes" xml:space="preserve">
          <source>This returns the name of the associated .packlist file</source>
          <target state="translated">연결된 .packlist 파일의 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e09dcd49b996b5c9c29c7bd188efbeaabae3afb" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">다음 토큰 객체 ( &lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 하위 클래스가 됨 )를 반환하거나 파서 스트림이 문서의 끝에 도달 한 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8714a4ea9c89be9e02bb0a484046217a2fdc2659" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">그러면 다음 토큰 객체 ( &lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 서브 클래스가 됨 )를 반환하거나 파서 스트림이 문서의 끝에 도달하면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db9439ac80b35bc802acd8f20ce2c7390e307d09" translate="yes" xml:space="preserve">
          <source>This returns the op description from the global C PL_op_desc array (e.g. &quot;addition&quot; &quot;array deref&quot;).</source>
          <target state="translated">전역 C PL_op_desc 배열 (예 : &quot;addition&quot; &quot;array deref&quot;)에서 op 설명을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5681c12774f7d1547e4176d6eccb3ccd12074a1f" translate="yes" xml:space="preserve">
          <source>This returns the op name as a string (e.g. &quot;add&quot;, &quot;rv2av&quot;).</source>
          <target state="translated">op 이름을 문자열로 반환합니다 (예 : &quot;add&quot;, &quot;rv2av&quot;).</target>
        </trans-unit>
        <trans-unit id="c03ab2186d312ee9f05759433ffaba12c8dd3636" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; never are).</source>
          <target state="translated">이것은 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; 의 잠재적 인 로케일 종속 대소 문자 매핑을 반환합니다 . 매핑은 단일 코드 포인트보다 길 수 있습니다 ( &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo ()&quot;에&lt;/a&gt; 의해 반환 된 기본 유니 코드 대 / 소문자 매핑은 절대 그렇지 않음).</target>
        </trans-unit>
        <trans-unit id="7c24d1c30b8541d36722cb533fdf5d0b9d4b051d" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; never are).</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 의 잠재적 인 로케일 종속 대소 문자 맵핑을 리턴합니다 . 매핑은 단일 코드 포인트보다 길 수 있습니다 ( &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()에&lt;/a&gt; 의해 반환되는 기본 유니 코드 대 / 소문자 매핑은 절대 안 됨).</target>
        </trans-unit>
        <trans-unit id="64bc8ef0666e73530b9a3f2cd195ef738c2d8851" translate="yes" xml:space="preserve">
          <source>This returns the string form of the table if it was set, otherwise it returns the string &lt;code&gt;&quot;&amp;lt;TABLE NOT DISPLAYED&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">설정된 경우 테이블의 문자열 형식을 반환하고, 그렇지 않으면 문자열 &lt;code&gt;&quot;&amp;lt;TABLE NOT DISPLAYED&amp;gt;&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e407d9572ab9c5f99771767ba652986d36609117" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this end-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">이 엔드 토큰 객체의 태그 이름을 반환합니다. 예를 들어, &quot;= head1 ...&quot;줄을 구문 분석하면 &quot;name1&quot;이라는 태그 이름을 가진 시작 토큰, 내용에 대한 토큰 및 &quot;head1&quot;이라는 태그 이름을 가진 종료 토큰이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1457f9cf582cb43f3b8ece06b77a4a774ea5edd5" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this start-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">시작 토큰 객체의 태그 이름을 반환합니다. 예를 들어, &quot;= head1 ...&quot;줄을 구문 분석하면 &quot;name1&quot;이라는 태그 이름을 가진 시작 토큰, 내용에 대한 토큰 및 &quot;head1&quot;이라는 태그 이름을 가진 종료 토큰이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a92df26815537e43f9c0925776fd61d439836096" translate="yes" xml:space="preserve">
          <source>This returns the text that this token holds. For example, parsing C&amp;lt;foo&amp;gt; will return a C start-token, a text-token, and a C end-token. And if you want to get the &quot;foo&quot; out of the text-token, call &lt;code&gt;$token-&amp;gt;text&lt;/code&gt;</source>
          <target state="translated">이 토큰이 보유한 텍스트를 반환합니다. 예를 들어 C &amp;lt;foo&amp;gt;를 구문 분석하면 C 시작 토큰, 텍스트 토큰 및 C 엔드 토큰이 반환됩니다. 그리고 텍스트 토큰에서 &quot;foo&quot;를 가져 오려면 &lt;code&gt;$token-&amp;gt;text&lt;/code&gt; 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="37adaa267b32499cf66804411e8414b1ad1805e1" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 와 같은 방식으로 스레드 컨텍스트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cadb33aaeb1401584260a466e314c67532c002d6" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray()&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray ()&lt;/a&gt; 와 같은 방식으로 스레드의 컨텍스트를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e65fe0dbb6e214f3cd7dbd02a6dc6c382b0c30da" translate="yes" xml:space="preserve">
          <source>This returns the type of the token. This will be either the string &quot;start&quot;, the string &quot;text&quot;, or the string &quot;end&quot;.</source>
          <target state="translated">토큰 유형을 반환합니다. 이것은 문자열 &quot;start&quot;, 문자열 &quot;text&quot;또는 문자열 &quot;end&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="11b6f6f063cb5805a948af38969c126392d218a6" translate="yes" xml:space="preserve">
          <source>This returns the value of the</source>
          <target state="translated">이것은 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="58c9aa25d44f77824a03159b1475adf1a9714a16" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; given by the first.</source>
          <target state="translated">이것은 첫 번째가 제공 하는 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;에&lt;/a&gt; 대해 두 번째 매개 변수가 제공하는 유니 코드 속성의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e7567ac847e3dd9703ee4f767f192a1f4433a0b" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; given by the first.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수에&lt;/a&gt; 대한 두 번째 매개 변수가 제공 한 Unicode 특성 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="00254886c0f76de134b6342f6c209f119eee2c52" translate="yes" xml:space="preserve">
          <source>This returns the version number for the specified module.</source>
          <target state="translated">지정된 모듈의 버전 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28cb21f0ce04fc34237dafa4d05afb66efd55c58" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt; ).</source>
          <target state="translated">이것은 유니 코드 문자 데이터베이스의 버전, 즉 데이터베이스가 구현하는 유니 코드 표준의 버전을 리턴합니다. 버전은 점 ( &lt;code&gt;'.'&lt;/code&gt; )으로 구분 된 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="a289cd11d045f8591acb29dd41933e8954d58596" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="translated">이것은 유니 코드 문자 데이터베이스의 버전, 즉 데이터베이스가 구현하는 유니 코드 표준의 버전을 반환합니다. 버전은 점 ( &lt;code&gt;'.'&lt;/code&gt; )으로 구분 된 숫자 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="0537cb9604bd46fdc53aedf1ef4d31156ea69d21" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and come to the end of that source.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 소스에서 읽고 해당 소스의 끝 부분에 도달 하면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d892085e64119e5b73847e052d7936e4ec27fd45" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and has seen Pod content in it.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 소스에서 읽고 Pod 컨텐츠를 본 경우 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0b811ea00850392c2bee3b4f40af1e1b677b7142" translate="yes" xml:space="preserve">
          <source>This returns true only if there has been any real content seen for this document. Returns false in cases where the document contains content, but does not make use of any Pod markup.</source>
          <target state="translated">이 문서에 실제 내용이있는 경우에만 true를 반환합니다. 문서에 내용이 포함되어 있지만 포드 마크 업을 사용하지 않는 경우 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e28605a00b749132376858f485353c17ca2a0f0d" translate="yes" xml:space="preserve">
          <source>This routine also returns a different number of arguments depending on the success or failure of the call to statfs. If there is an error, the error number is returned as a single-element array. If the call is successful, then a 7-element array is returned. Since only one argument is passed into this function, we need room on the stack to hold the 7 values which may be returned.</source>
          <target state="translated">이 루틴은 또한 statfs 호출의 성공 또는 실패에 따라 다른 수의 인수를 리턴합니다. 오류가 있으면 오류 번호가 단일 요소 배열로 반환됩니다. 호출이 성공하면 7 요소 배열이 리턴됩니다. 이 함수에는 하나의 인수 만 전달되므로 스택에 7 개의 값을 보유 할 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5b820e747b00eb7161f8b3a6555a694bd263c329" translate="yes" xml:space="preserve">
          <source>This routine behaves identically to the final two forms. That is, it does not return &lt;b&gt;true&lt;/b&gt; if the code point has a decomposition consisting of another single code point, nor if its decomposition starts with a code point whose combining class is non-zero. Code points that meet either of these conditions should also not be produced by composition normalization, which is probably why you should use the &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; property instead, as shown above.</source>
          <target state="translated">이 루틴은 마지막 두 양식과 동일하게 작동합니다. 즉, 코드 포인트에 다른 단일 코드 포인트로 구성된 분해가 있거나 분해 클래스가 0이 아닌 코드 포인트로 분해가 시작되는 경우에는 &lt;b&gt;true를&lt;/b&gt; 반환하지 않습니다 . 이러한 조건 중 하나를 충족하는 코드 포인트는 컴포지션 정규화로 생성되지 않아야하므로 위와 같이 &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; 속성을 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cbcd70e8dd9e2b5edee3c69038ed73e9a903ad" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt; , but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">이 루틴은 어떤 유형의 매직 &lt;code&gt;sv&lt;/code&gt; 이 있는지 확인합니다 . mg_type 필드가 대문자이면 mg_obj가 복사됩니다 &lt;code&gt;nsv&lt;/code&gt; 하지만 mg_type 필드는 소문자 편지로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ebc0f1624cad62f6320cad80e7fcee1daed490" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt;, but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">이 루틴은 어떤 유형의 매직 &lt;code&gt;sv&lt;/code&gt; 가 있는지 확인합니다 . mg_type 필드가 대문자이면 mg_obj가 복사됩니다 &lt;code&gt;nsv&lt;/code&gt; 하지만 mg_type 필드는 소문자 편지로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="1147ded4271f3785411e40a784f62228ae86794d" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">이 루틴은 단일 매개 변수 (서브 루틴 또는 변수에 대한 참조)를 예상합니다. 비어있을 수있는 속성 목록을 반환합니다. 유효하지 않은 인수를 전달하면 ( &lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt; 를 통해) die ()를 사용 하여 치명적인 예외를 발생시킵니다. 클래스 메서드 조회에 적합한 패키지 이름을 찾을 수있는 경우 아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;패키지 별 속성 처리&quot;에&lt;/a&gt; 설명 된대로 반환 목록에 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 호출 의 결과가 포함 됩니다. 그렇지 않으면 &lt;a href=&quot;#Built-in-Attributes&quot;&gt;내장 속성&lt;/a&gt; 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="156fe43e5f5152548ce6f33bee1b7f0723071b2f" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">이 루틴은 단일 매개 변수, 즉 서브 루틴 또는 변수에 대한 참조를 필요로합니다. 비어있을 수있는 속성 목록을 반환합니다. 유효하지 않은 인수를 전달하면 die () ( &lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt; 를 통해 )를 사용하여 치명적인 예외를 발생시킵니다. 클래스 메소드 검색에 적합한 패키지 이름을 찾을 수 있으면 아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리에&lt;/a&gt; 설명 된대로 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 호출 의 결과를 리턴 목록에 포함 시킵니다. 그렇지 않으면 &lt;a href=&quot;#Built-in-Attributes&quot;&gt;내장 속성&lt;/a&gt; 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1cbd8c6e15630953581b673b778fa0654a81555" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns the built-in type of the referenced variable, ignoring any package into which it might have been blessed. This can be useful for determining the</source>
          <target state="translated">이 루틴은 단일 매개 변수, 즉 서브 루틴 또는 변수에 대한 참조를 필요로합니다. 참조 된 변수의 내장 유형을 리턴하며, 축복 된 패키지는 무시합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="a441bbdb5a22183756c86532b0bd8538c60db634" translate="yes" xml:space="preserve">
          <source>This routine is automatically used whenever a scalar is required:</source>
          <target state="translated">이 루틴은 스칼라가 필요할 때마다 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d5c36985c03c1b5c7bc41a618c507ece2116559" translate="yes" xml:space="preserve">
          <source>This routine is just a simple interface into GetOSVersion(). More specific or demanding situations should use that instead. Another option would be to use POSIX::uname(), however the latter appears to report only the OS family name and not the specific OS. In scalar context it returns just the ID.</source>
          <target state="translated">이 루틴은 GetOSVersion ()에 대한 단순한 인터페이스입니다. 더 구체적이거나 까다로운 상황에서 대신 사용해야합니다. 또 다른 옵션은 POSIX :: uname ()을 사용하는 것이지만 후자는 특정 OS가 아닌 OS 계열 이름 만보고하는 것으로 보입니다. 스칼라 컨텍스트에서는 ID 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af05f40d5a349a9cf28386764e38317c02e23a0c" translate="yes" xml:space="preserve">
          <source>This routine provides word completion on the list of words in the array (or array ref).</source>
          <target state="translated">이 루틴은 배열 (또는 배열 참조)의 단어 목록에서 단어 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a12916af343198cbe644e34418361cddb6245ff7" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">이 루틴은 사용중인 유니 코드 버전이 너무 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이 특성이없는 경우 undef를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3f4e8ad32963f7898d4d526c86c643ef2d8a5ac8" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;undef&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">이 루틴은 사용중인 유니 코드 버전이 너무 일찍이 속성이없는 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="101ceccec63478c5c011c3caa8244abb6108d41c" translate="yes" xml:space="preserve">
          <source>This routine returns a pointer to a &lt;code&gt;MAGIC&lt;/code&gt; structure stored in the SV. If the SV does not have that magical feature, &lt;code&gt;NULL&lt;/code&gt; is returned. If the SV has multiple instances of that magical feature, the first one will be returned. &lt;code&gt;mg_findext&lt;/code&gt; can be used to find a &lt;code&gt;MAGIC&lt;/code&gt; structure of an SV based on both its magic type and its magic virtual table:</source>
          <target state="translated">이 루틴은 SV에 저장된 &lt;code&gt;MAGIC&lt;/code&gt; 구조에 대한 포인터를 반환합니다 . SV에 해당 마법 기능이 없으면 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다. SV에 해당 마법 기능의 인스턴스가 여러 개있는 경우 첫 번째 기능이 반환됩니다. &lt;code&gt;mg_findext&lt;/code&gt; 는 마법 유형과 마법 가상 테이블을 기반으로 SV 의 &lt;code&gt;MAGIC&lt;/code&gt; 구조 를 찾는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be064f7d7fc8c5c81c03e6f7693444f3da761d4d" translate="yes" xml:space="preserve">
          <source>This runs all the given</source>
          <target state="translated">이 모든 주어진 주어진</target>
        </trans-unit>
        <trans-unit id="5f9d330768a086b11c3fee8aaebb21d2fcbcb969" translate="yes" xml:space="preserve">
          <source>This runs some basic sanity tests on the source tree and helps catch basic errors before you submit a patch.</source>
          <target state="translated">이것은 소스 트리에서 몇 가지 기본 온 전성 테스트를 실행하며 패치를 제출하기 전에 기본 오류를 포착하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b456dbbb28104ac1fe79034d2719d013d951db2d" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">이보다 안전한 &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; 버전은 &lt;code&gt;$/&lt;/code&gt; 의 현재 값 ( &lt;code&gt;English&lt;/code&gt; 모듈 에서 $ INPUT_RECORD_SEPARATOR라고도 함)에 해당하는 후행 문자열을 제거합니다 . 모든 인수에서 제거 된 총 문자 수를 반환합니다. 최종 레코드에 줄 바꿈이 누락 될 염려가있는 경우 입력 레코드 끝에서 줄 바꿈을 제거하는 데 자주 사용됩니다. 단락 모드 ( &lt;code&gt;$/ = ''&lt;/code&gt; )에서는 문자열에서 모든 후행 줄 바꿈을 제거합니다. slurp 모드 ( &lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 또는 고정 길이 레코드 모드 ( &lt;code&gt;$/&lt;/code&gt; 는 정수 등을 참조합니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )에서 chomp ()는 아무것도 제거하지 않습니다. VARIABLE을 생략하면 mp &lt;code&gt;$_&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="f11cb2092730214fd2c5570df1288f5c170ff762" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; (also known as &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; in the &lt;a href=&quot;english&quot;&gt;&lt;code&gt;English&lt;/code&gt;&lt;/a&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt;), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = undef&lt;/code&gt;) or fixed-length record mode (&lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), &lt;a href=&quot;#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt; won't remove anything. If VARIABLE is omitted, it chomps &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">이 안전한 버전 &lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt; 의 현재 값에 해당하는 후행 문자열 제거 &lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt; (라고도 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 에서 &lt;a href=&quot;english&quot;&gt; &lt;code&gt;English&lt;/code&gt; &lt;/a&gt; 모듈). 모든 인수에서 제거 된 총 문자 수를 반환합니다. 최종 레코드에 줄 바꿈이 누락 될 수 있다고 걱정할 때 입력 레코드 끝에서 줄 바꿈을 제거하는 데 자주 사용됩니다. 단락 모드 ( &lt;code&gt;$/ = ''&lt;/code&gt; )에서는 문자열에서 모든 후행 줄 바꿈을 제거합니다. slurp 모드 ( &lt;code&gt;$/ = undef&lt;/code&gt; ) 또는 고정 길이 레코드 모드 ( &lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt; 는 정수 등에 대한 참조입니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 ), &lt;a href=&quot;#chomp-VARIABLE&quot;&gt; &lt;code&gt;chomp&lt;/code&gt; &lt;/a&gt;아무것도 제거하지 않습니다. VARIABLE이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 쪼개집니다 . 예:</target>
        </trans-unit>
        <trans-unit id="ade7671cda06ea60596db7de673c42e7e9809682" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">이보다 안전한 &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; 버전은 &lt;code&gt;$/&lt;/code&gt; 의 현재 값 ( &lt;code&gt;English&lt;/code&gt; 모듈 에서 $ INPUT_RECORD_SEPARATOR라고도 함)에 해당하는 후행 문자열을 제거합니다 . 모든 인수에서 제거 된 총 문자 수를 반환합니다. 최종 레코드에 줄 바꿈이 누락 될 염려가있는 경우 입력 레코드 끝에서 줄 바꿈을 제거하는 데 자주 사용됩니다. 단락 모드 ( &lt;code&gt;$/ = ''&lt;/code&gt; )에서는 문자열에서 모든 후행 줄 바꿈을 제거합니다. slurp 모드 ( &lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 또는 고정 길이 레코드 모드 ( &lt;code&gt;$/&lt;/code&gt; 는 정수 등을 참조합니다. &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )에서 chomp ()는 아무것도 제거하지 않습니다. VARIABLE을 생략하면 mp &lt;code&gt;$_&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="29322e1fae611c7a4ec6b18f01c0e5539c007dbe" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 통해 동일한 펄에서 동일한 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3881ba4a6ee9c9f7a39f8b6e30cf077c3df62fb1" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt;.</source>
          <target state="translated">이 동일한 방법은 &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 통해 순수 perl에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7a4db1ab47139698e5958a2175645481a1041ec" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 참조 (ROK)이며 PVAV 인 어레이 인 다른 SV를 가리 킵니다. 배열에는 하나의 요소 (요소 0)가 있으며 이는 다른 SV입니다. 위의 &lt;code&gt;FILL&lt;/code&gt; 필드 는 &lt;code&gt;$#$a&lt;/code&gt; 와 유사하게 배열의 마지막 요소를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9184d54b5dc37c9e6366802801d705be70172a95" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 참조 (ROK)이며 PVAV, 즉 어레이 인 다른 SV를 가리 킵니다. 배열에는 하나의 요소 (요소 0)가 있으며 이는 또 다른 SV입니다. 위의 &lt;code&gt;FILL&lt;/code&gt; 필드 는 &lt;code&gt;$#$a&lt;/code&gt; 와 유사한 배열의 마지막 요소를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="036ebde834d76ddc89809412a48e08bc1aad5dd1" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar is an IV, a number. Its reference count is 1. It has the &lt;code&gt;IOK&lt;/code&gt; flag set, meaning it is currently being evaluated as a number. Because IOK is set we look at the IV item to see what is in the scalar.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 스칼라 인 SV 라고 말합니다 . 스칼라는 숫자 IV입니다. 참조 횟수는 1입니다. &lt;code&gt;IOK&lt;/code&gt; 플래그가 설정되어 있으며 현재 숫자로 평가되고 있습니다. IOK가 설정되었으므로 IV 항목을보고 스칼라에있는 항목을 봅니다.</target>
        </trans-unit>
        <trans-unit id="2536195f9e270d7a0608ccd9b92c67b39acf3e86" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar type is a PVIV, which is capable of holding an integer (IV) and/or a string (PV) value. The scalar's head is allocated at address 0xbe9a8, while the body is at 0xbc288. Its reference count is 1. It has the &lt;code&gt;POK&lt;/code&gt; flag set, meaning its current PV field is valid. Because POK is set we look at the PV item to see what is in the scalar. The \0 at the end indicate that this PV is properly NUL-terminated. Note that the IV field still contains its old numeric value, but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR indicates the number of characters in the PV. LEN indicates the number of bytes allocated for the PV (at least one more than CUR, because LEN includes an extra byte for the end-of-string marker, then usually rounded up to some efficient allocation unit).</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 스칼라 인 SV 라고 말합니다 . 스칼라 유형은 PVIV이며 정수 (IV) 및 / 또는 문자열 (PV) 값을 보유 할 수 있습니다. 스칼라의 헤드는 주소 0xbe9a8에 할당되고 본문은 0xbc288에 할당됩니다. 참조 횟수는 1입니다. &lt;code&gt;POK&lt;/code&gt; 가 있습니다.현재 PV 필드가 유효 함을 의미하는 플래그 설정. POK가 설정되었으므로 PV 항목을보고 스칼라에 무엇이 있는지 확인합니다. 끝에있는 \ 0은이 PV가 제대로 NUL로 종료되었음을 나타냅니다. IV 필드에는 여전히 이전 숫자 값이 포함되지만 FLAGS에는 IOK가 설정되어 있지 않으므로 IV 항목을 무시해야합니다. CUR은 PV의 문자 수를 나타냅니다. LEN은 PV에 할당 된 바이트 수를 나타냅니다 (LEN은 문자열 끝 표시자를위한 추가 바이트를 포함하고 일반적으로 일부 효율적인 할당 단위로 반올림되므로).</target>
        </trans-unit>
        <trans-unit id="d4038eb2f65cf90ff5c5db0ff06612a08d942853" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt; . If the file contained the following data:</source>
          <target state="translated">이는 레코드가 문자열 &lt;code&gt;es&lt;/code&gt; 로 구분된다고 말합니다 . 파일에 다음 데이터가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="e7ff66ceeac2fbc00d45f5c00f7c3466cddbfb77" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt;. If the file contained the following data:</source>
          <target state="translated">이것은 레코드가 &lt;code&gt;es&lt;/code&gt; 문자열로 구분된다는 것을 의미합니다 . 파일에 다음 데이터가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="c3f732b3da7c2a158f6a684ddbc311ca908a5e5b" translate="yes" xml:space="preserve">
          <source>This says what packages are internal to Perl. &lt;code&gt;Carp&lt;/code&gt; will never report an error as being from a line in a package that is internal to Perl. For example:</source>
          <target state="translated">이것은 Perl의 내부에 어떤 패키지가 있는지를 나타냅니다. &lt;code&gt;Carp&lt;/code&gt; 는 Perl 내부의 패키지 라인에서 오류를보고하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94c9a814257648d20b0d4f2bf7acb2782a18b6ea" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; . There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">이것은 어떤 패키지가 Perl의 경고 시스템 내부에 있는지를 나타냅니다. 전체 스택 역 추적을 생성하는 경우 이는 Perl 내부와 동일하며 스택 역 추적은 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열된 패키지 내부에서 시작되지 않습니다 . 그러나 &lt;code&gt;carp&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 에 의해 생성 된 요약 메시지는 약간 다릅니다 . &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 에서 패키지를 호출하는 행에는 오류가보고되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="84798169adfcecd51c1ec3874bbf65c79b20278e" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;. But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;. There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;.</source>
          <target state="translated">이것은 Perl의 경고 시스템 내부에있는 패키지를 나타냅니다. 전체 스택 역 추적을 생성하는 경우 이는 Perl 내부에있는 것과 동일하며 스택 역 추적은 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열된 패키지 내에서 시작되지 않습니다 . 그러나 &lt;code&gt;carp&lt;/code&gt; 나 &lt;code&gt;croak&lt;/code&gt; 의해 생성 된 요약 메시지는 약간 다릅니다 . &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 에서 패키지를 호출하는 라인에는 오류가보고되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31106a1a20d4ea51da0f7d90c3fe4fb2b5ff8f01" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">이 시나리오는 소멸자, 비동기 콜백 및 신호 처리기 내에서 호출되는 코드에 주로 적용됩니다. 호출되는 코드가 주변 동적 컨텍스트와 거의 관련이없는 상황에서, 주 프로그램은 지능적으로 처리 할 수 ​​없더라도 호출 된 코드의 오류로부터 격리되어야합니다. &lt;code&gt;__DIE__&lt;/code&gt; 또는 &lt;code&gt;__WARN__&lt;/code&gt; 후크에 대한 코드를 사용하여이 작업을 수행 하고 함수를 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ac4667cace4096dfbe5b4c50d550b72cbd4224" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;tie&lt;/code&gt; functions.</source>
          <target state="translated">이 시나리오는 대부분 소멸자, 비동기 콜백 및 신호 처리기 내에서 호출되는 코드에 적용됩니다. 호출되는 코드가 주변 동적 컨텍스트와 거의 관련이없는 이러한 상황에서는 지능적으로 처리 할 수없는 경우에도 호출 된 코드의 오류로부터 주 프로그램을 격리해야합니다. &lt;code&gt;__DIE__&lt;/code&gt; 또는 &lt;code&gt;__WARN__&lt;/code&gt; 후크에 대한 코드로이를 수행 하고 함수를 &lt;code&gt;tie&lt;/code&gt; 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1df3253c4ccef59169cb5ac31f3ae1f9a3a9a53" translate="yes" xml:space="preserve">
          <source>This script provides a command interface (not a shell) to CPAN. At the moment it uses CPAN.pm to do the work, but it is not a one-shot command runner for CPAN.pm.</source>
          <target state="translated">이 스크립트는 CPAN에 대한 명령 인터페이스 (쉘이 아님)를 제공합니다. 현재 CPAN.pm을 사용하여 작업을 수행하지만 CPAN.pm에 대한 원샷 명령 실행기는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e17cbd723cbdc191dc4fdc562d2ff451e857ff96" translate="yes" xml:space="preserve">
          <source>This script shows how to override the default sorting algorithm that BTREE uses. Instead of using the normal lexical ordering, a case insensitive compare function will be used.</source>
          <target state="translated">이 스크립트는 BTREE가 사용하는 기본 정렬 알고리즘을 재정의하는 방법을 보여줍니다. 일반적인 어휘 순서를 사용하는 대신 대소 문자를 구분하지 않는 비교 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af317b7379a832e3b0678b6eea769f242beb3e07" translate="yes" xml:space="preserve">
          <source>This script,</source>
          <target state="translated">이 스크립트는</target>
        </trans-unit>
        <trans-unit id="86ea44fa36ed41d21548135cdfb2e7b1ad994fbc" translate="yes" xml:space="preserve">
          <source>This searches the directories given in</source>
          <target state="translated">이것은 주어진 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="cc448c949fa2502c3de5bd50cf25e079f49a973e" translate="yes" xml:space="preserve">
          <source>This section also applies to other overloaded math packages, like Math::String.</source>
          <target state="translated">이 섹션은 Math :: String과 같은 다른 오버로드 된 수학 패키지에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6d18fe35323b673cf86ded4be1699795588d00" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;&quot;Earlier releases caveats&quot;&lt;/a&gt; subsection below.</source>
          <target state="translated">이 섹션은 v5.22부터 Perls에 완전히 적용됩니다. 이전 릴리스에 대한 다양한주의 사항은 아래 &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;&quot;이전 릴리스주의 사항&quot;&lt;/a&gt; 하위 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="be390d54ea95c83e1fca1268a1911351d2f7df4c" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;Earlier releases caveats&lt;/a&gt; subsection below.</source>
          <target state="translated">이 섹션은 v5.22부터 Perls에 완전히 적용됩니다. 이전 릴리스에 대한 다양한 경고는 아래 의 &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;초기 릴리스 경고&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dd90ab92335c6f36e8ed1d4a60c84c97df21db" translate="yes" xml:space="preserve">
          <source>This section concerns the lookahead and lookbehind assertions. First, a little background.</source>
          <target state="translated">이 섹션에서는 미리보기 및 찾아보기 어설 션에 대해 설명합니다. 먼저 작은 배경.</target>
        </trans-unit>
        <trans-unit id="ab4a7c816ed65ffc082450cf0217f6cf1db2cf6e" translate="yes" xml:space="preserve">
          <source>This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing, formats, and footers.</source>
          <target state="translated">이 섹션에서는 I / O 및 &quot;f&quot;문제 (파일 처리, 플러시, 형식 및 바닥 글)를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c67dd2be244aa67b2c3982a2251efd0aba82da6e" translate="yes" xml:space="preserve">
          <source>This section deals with general Perl language issues that don't clearly fit into any of the other sections.</source>
          <target state="translated">이 섹션은 다른 섹션에는 명확하게 맞지 않는 일반적인 Perl 언어 문제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="4dacb0d5b8529783cda24f9a101a291fd790bb1b" translate="yes" xml:space="preserve">
          <source>This section deals with questions related to running web sites, sending and receiving email as well as general networking.</source>
          <target state="translated">이 섹션에서는 웹 사이트 실행, 전자 메일 송수신 및 일반 네트워킹과 관련된 질문을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8c7e75fcfcb79fa2aefcfcb9d7bd00c769af0ac" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory compression using the</source>
          <target state="translated">이 섹션은 다음을 사용하여 메모리 내 압축이 가능한 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="07d89dd508bd9a1955f604c65746a72fe10cd652" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory uncompression using the</source>
          <target state="translated">이 섹션은 다음을 사용하여 메모리 내 압축 해제를 허용하는 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="574b76a7c21f5d83dd373c1961cc34e2c0747c9f" translate="yes" xml:space="preserve">
          <source>This section defines the Version type, used by several fields in the CPAN Meta Spec.</source>
          <target state="translated">이 섹션은 CPAN 메타 사양의 여러 필드에서 사용되는 버전 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3243853ef1a289c9e89d976c5c5c21cc63e5a678" translate="yes" xml:space="preserve">
          <source>This section defines the interface available that allows in-memory uncompression using the</source>
          <target state="translated">이 섹션에서는 사용 가능한 메모리 압축 풀기를 허용하는 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8adf59417e2d7f3c501610b406a6fa8b838974b3" translate="yes" xml:space="preserve">
          <source>This section describes how JSON::PP maps Perl values to JSON values and vice versa. These mappings are designed to &quot;do the right thing&quot; in most circumstances automatically, preserving round-tripping characteristics (what you put in comes out as something equivalent).</source>
          <target state="translated">이 섹션에서는 JSON :: PP가 Perl 값을 JSON 값에 매핑하는 방법과 그 반대의 경우를 설명합니다. 이러한 매핑은 대부분의 상황에서 자동으로 &quot;올바른 일을 수행&quot;하도록 설계되어 라운드 트립 특성 (입력 한 내용이 동등한 것으로 표시됨)을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="95a0852ba843f17dcbe1940f17029f381d5d77f9" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::Big* as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">이 섹션에서는 Math :: Big *의 정확도 / 정밀도 처리에 대해 설명했으며 현재와 마찬가지로 모든 용어와 약어에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="06b4644a1d0abd71307ee2e3605d7fc2e4535b4d" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::BigInt and Math::BigFloat as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">이 섹션에서는 Math :: BigInt 및 Math :: BigFloat의 정확도 / 정밀도 처리에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ec789fa26c9d8dfd2479d175b7e934018d065eea" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; using the mkstemp() from this module.</source>
          <target state="translated">이 섹션에서는 이 모듈의 mkstemp ()를 사용하여 &lt;a href=&quot;posix&quot;&gt;POSIX에&lt;/a&gt; 설명 된 tmpnam () 및 tmpfile () 함수의 재 구현에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="39aef7a353c321f38285ab3f99461b24884c7fa4" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in L</source>
          <target state="translated">이 절에서는 L에 설명 된 tmpnam () 및 tmpfile () 함수의 재 구현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5b6ee285a0e0ef806b91b3b763a8498277e66885" translate="yes" xml:space="preserve">
          <source>This section describes the recommended interface for generating temporary files and directories.</source>
          <target state="translated">이 절에서는 임시 파일 및 디렉토리 생성을위한 권장 인터페이스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="69aa90134b4dce1d696ebb05a6dbb67cf8770a91" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build PerlCE. You may find additional information about building perl for WinCE at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; and some pre-built binaries.</source>
          <target state="translated">이 섹션에서는 PerlCE를 빌드하기 위해 수행 할 단계를 설명합니다. &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; 및 일부 사전 빌드 된 바이너리 에서 WinCE 용 perl 빌드에 대한 추가 정보를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f3d56c367a6b305dcc2c5edd92d44276e1ff5b" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build a Perl NLM and other associated NLMs.</source>
          <target state="translated">이 섹션에서는 Perl NLM 및 기타 관련 NLM을 빌드하기 위해 수행되는 단계에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1019c06c85688bbdf3af5c6e3b95950cdf59effc" translate="yes" xml:space="preserve">
          <source>This section describes ways to call &lt;code&gt;open&lt;/code&gt; outside of best practices; you may encounter these uses in older code. Perl does not consider their use deprecated, exactly, but neither is it recommended in new code, for the sake of clarity and readability.</source>
          <target state="translated">이 섹션에서는 모범 사례 외부에서 &lt;code&gt;open&lt;/code&gt; 을 호출하는 방법에 대해 설명합니다 . 이전 코드에서 이러한 사용이 발생할 수 있습니다. Perl은 정확하게 사용되지 않는 것으로 간주하지 않지만 명확성과 가독성을 위해 새 코드에서는 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73c6a4b67a7eaa7527571d5faec72b4bfebc75e4" translate="yes" xml:space="preserve">
          <source>This section documents functions to manipulate CVs which are code-values, or subroutines. For more information, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 절에서는 코드 값 또는 서브 루틴 인 CV를 조작하는 기능에 대해 설명합니다. 자세한 정보는 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ac896f6350aabd5af3622467a85a4b6b744251" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 복합 형식의 유니 코드 속성과 동의어가 아닌 모든 확장에 대한 세부 정보를 제공합니다 (해당 속성의 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;유니 코드 표준&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="9319fc0cf40bc57d3c32a473ab7229f4845e3419" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 복합 형식 유니 코드 속성의 동의어가 아닌 모든 확장에 대한 세부 정보를 제공합니다 (이러한 속성의 경우 &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;Unicode Standard&lt;/a&gt; 를 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="954cb379e9610eb88d0cd37b6e5358601612440b" translate="yes" xml:space="preserve">
          <source>This section hopes to clarify how Perl handles quoted constructs. Although the most common reason to learn this is to unravel labyrinthine regular expressions, because the initial steps of parsing are the same for all quoting operators, they are all discussed together.</source>
          <target state="translated">이 섹션에서는 Perl이 인용 된 구문을 처리하는 방법을 명확하게 설명하려고합니다. 이것을 배우는 가장 일반적인 이유는 미로 정규 표현식을 풀기위한 것이지만, 파싱의 초기 단계는 모든 인용 연산자에 대해 동일하기 때문에 모두 함께 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="536fa6406d989d8eb5028cec20788cbdc6568c11" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;use bytes&lt;/code&gt;, and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">이 섹션은 문자를 구두점 대 알파벳 등과 같은 유형으로 분류하는 함수 (정말 매크로)에 관한 것입니다. 이들 중 대부분은 정규식 문자 클래스와 유사합니다. ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .) 각 클래스에는 여러 변형이 있습니다. (모든 매크로에 모든 변형이있는 것은 아닙니다. 아래의 각 항목에는 유효한 항목이 나열되어 있습니다.) &lt;code&gt;use bytes&lt;/code&gt; 의 영향을받는 것은 없으며 이름에 &lt;code&gt;LC&lt;/code&gt; 가있는 매크로 만 현재 로케일의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="7547891b2c07526eb3624e622a75bf7d7cccf2c6" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">이 섹션은 문장 부호 대 알파벳 등의 문자를 유형으로 분류하는 함수 (실제 매크로)에 관한 것입니다. 대부분은 정규 표현식 문자 클래스와 유사합니다. ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스를&lt;/a&gt; 참조하십시오 .) 각 클래스마다 몇 가지 변형이 있습니다. 모든 매크로에 모든 변형이있는 것은 아니며 아래 각 항목에 유효한 매크로가 나열되어 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용의&lt;/a&gt; 영향은 없으며 이름에 &lt;code&gt;LC&lt;/code&gt; 가있는 것만 현재 로케일의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="e9ab2821650c93c09f64d44ff30564f17238787a" translate="yes" xml:space="preserve">
          <source>This section is also taken from JSON::XS.</source>
          <target state="translated">이 섹션은 JSON :: XS에서도 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="ddeda1d72fad19d0a6a9f82fe55d9f33ab10382a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;&quot;Command Paragraph&quot; in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">이 섹션은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod의 &quot;Command Paragraph&quot;에서&lt;/a&gt; 논의를 보완하고 명확하게하기위한 것 입니다. 다음은 현재 인식되는 Pod 명령입니다.</target>
        </trans-unit>
        <trans-unit id="d919f2203b8f136316a99d5a21a115c2a5759b1a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">이 섹션은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod의 Command Paragraph에&lt;/a&gt; 대한 논의를 보완하고 명확하게하기위한 것 입니다. 다음은 현재 인식되는 포드 명령입니다.</target>
        </trans-unit>
        <trans-unit id="12d39af9317de3b208731a0e9f6172ef3ca0985f" translate="yes" xml:space="preserve">
          <source>This section is just an outline of some of the things code in a compartment might do (intentionally or unintentionally) which can have an effect outside the compartment.</source>
          <target state="translated">이 섹션은 컴 파트먼트의 코드가 의도적이거나 의도하지 않은 방식으로 컴 파트먼트 외부에 영향을 줄 수있는 작업 중 일부에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="afce53c6f9505fd215e3565d5b9cbd7590482493" translate="yes" xml:space="preserve">
          <source>This section is only necessary for those who want to write a compiler backend module that can be used via this module.</source>
          <target state="translated">이 섹션은이 모듈을 통해 사용할 수있는 컴파일러 백엔드 모듈을 작성하려는 사람들에게만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d2dead1ebaa9a0daf17a7735104700bab6a62c1" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you want to use the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; together with the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">이 섹션은 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; &lt;b&gt;SelfLoader&lt;/b&gt; 와 함께 사용하려는 경우에만 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b8111cc382b6e222eab22ae8b7285382f21bba0" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;: &quot;How do I decode or create those %-encodings on the web&quot; and &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">이 섹션은 놀랍게도 작습니다. FAQ의 나머지 부분에는 정규 표현식과 관련된 답변이 포함되어 있기 때문입니다. 예를 들어, URL을 디코딩하고 숫자인지 확인하는 것은 정규 표현식으로 처리 할 수 ​​있지만이 답변은이 문서의 다른 부분에서 찾을 수 있습니다 ( &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; : &quot;웹에서 이러한 %-인코딩을 디코딩하거나 작성하는 방법&quot;및 &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4).&lt;/a&gt; : &quot;스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?&quot;)</target>
        </trans-unit>
        <trans-unit id="e488b03478a9d4c34a486aa35881d2d7c336d0b6" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : &quot;How do I decode or create those %-encodings on the web&quot; and perlfaq4 : &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">이 섹션은 놀랍게도 작습니다. FAQ의 나머지 부분에는 정규 표현식과 관련된 답변이 포함되어 있기 때문입니다. 예를 들어, URL을 디코딩하고 숫자인지 확인하는 것은 정규 표현식으로 처리 할 수 ​​있지만이 답변은이 문서의 다른 부분에서 찾을 수 있습니다 (perlfaq9 : &quot;웹에서 이러한 %-인코딩을 디코딩하거나 작성하는 방법&quot;및 perlfaq4). : &quot;스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?&quot;)</target>
        </trans-unit>
        <trans-unit id="732c1a0656cc78e70f97a666a29ecd78fe5a04dd" translate="yes" xml:space="preserve">
          <source>This section is taken from JSON::XS almost verbatim. &lt;code&gt;encode_json&lt;/code&gt; and &lt;code&gt;decode_json&lt;/code&gt; are exported by default.</source>
          <target state="translated">이 섹션은 거의 그대로 JSON :: XS에서 가져온 것입니다. &lt;code&gt;encode_json&lt;/code&gt; 및 &lt;code&gt;decode_json&lt;/code&gt; 은 기본적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="94d687991685902a3cbba9421e6e5a504f1cdd17" translate="yes" xml:space="preserve">
          <source>This section is taken from JSON::XS.</source>
          <target state="translated">이 섹션은 JSON :: XS에서 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="94757c3cee869d3cff315104b19f6299d40770f6" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions about where to find source and documentation for Perl, support, and related matters.</source>
          <target state="translated">이 FAQ 섹션에서는 Perl, 지원 및 관련 문제에 대한 소스 및 문서를 찾을 수있는 위치에 대한 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="dd108d0d127c5d70473c9d7274a370ea63329739" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.</source>
          <target state="translated">이 FAQ 섹션에서는 숫자, 날짜, 문자열, 배열, 해시 및 기타 데이터 문제 조작과 관련된 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="43d6c325f900a7d6a933d383734e7454f02fa808" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to programmer tools and programming support.</source>
          <target state="translated">이 FAQ 섹션은 프로그래머 도구 및 프로그래밍 지원과 관련된 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="8c63d2f74bc0df3e2938dcd3a6724a679f1d5b9f" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers very general, high-level questions about Perl.</source>
          <target state="translated">이 FAQ 섹션은 Perl에 대한 매우 일반적인 고급 질문에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="f91732cbb36111757913713f2dd27264f7f4075b" translate="yes" xml:space="preserve">
          <source>This section of the Perl FAQ covers questions involving operating system interaction. Topics include interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.</source>
          <target state="translated">Perl FAQ의이 섹션은 운영 체제 상호 작용과 관련된 질문을 다룹니다. 프로세스 간 통신 (IPC), 사용자 인터페이스 제어 (키보드, 화면 및 포인팅 장치) 및 데이터 조작과 관련이없는 대부분의 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d25ee711a891d2493e43b730a8ee5f38afba1662" translate="yes" xml:space="preserve">
          <source>This section only applies to you if you have existing data written out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which has been configured with 64 bit integer support (not the default) If you got a precompiled perl, rather than running Configure to build your own perl from source, then it almost certainly does not affect you, and you can stop reading now (unless you're curious). If you're using perl on Windows it does not affect you.</source>
          <target state="translated">이 섹션은 64 비트 정수 지원 (기본값 아님)으로 구성된 유닉스 또는 Linux에서 perl 5.6.0 또는 5.6.1에서 Storable 2.02 이전 버전으로 작성된 기존 데이터가있는 경우에만 적용됩니다 (사전 컴파일되지 않은 경우). perl, 소스를 사용하여 자신 만의 perl을 빌드하도록 구성을 실행하는 것보다는 거의 확실하게 영향을 미치지 않으며, 궁금한 경우가 아니라면 지금 읽기를 중단 할 수 있습니다. Windows에서 perl을 사용하는 경우 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ecf28b7a887ea07f287d9185e0392b617b15554" translate="yes" xml:space="preserve">
          <source>This section only considers the tagged value case: a tagged JSON object is encountered during decoding and &lt;code&gt;allow_tags&lt;/code&gt; is disabled, a parse error will result (as if tagged values were not part of the grammar).</source>
          <target state="translated">이 섹션에서는 태그가 지정된 값 사례 만 고려합니다. 태그가 지정된 JSON 개체가 디코딩 중에 발생하고 &lt;code&gt;allow_tags&lt;/code&gt; 가 비활성화되면 구문 분석 오류가 발생합니다 (태그 된 값이 문법의 일부가 아닌 것처럼).</target>
        </trans-unit>
        <trans-unit id="df773f3e4810bcca716d1f76438458e235350349" translate="yes" xml:space="preserve">
          <source>This section tries to classify the supported encodings by their applicability for information exchange over the Internet and to choose the most suitable aliases to name them in the context of such communication.</source>
          <target state="translated">이 섹션에서는 인터넷을 통한 정보 교환에 대한 적용 가능성에 따라 지원되는 인코딩을 분류하고 이러한 통신 컨텍스트에서 이름을 지정하는 데 가장 적합한 별칭을 선택하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9863e5d9d88cf88755191633db565f4fe6bf163c" translate="yes" xml:space="preserve">
          <source>This sends an &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event. This event will completely terminate all testing.</source>
          <target state="translated">이것은 &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2 :: Event :: Bail&lt;/a&gt; 이벤트를 보냅니다 . 이 이벤트는 모든 테스트를 완전히 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5b9a6489148fff3cc80ff958733f7f998b0b3cdf" translate="yes" xml:space="preserve">
          <source>This server accepts one of five different commands, sending output back to the client. Unlike most network servers, this one handles only one incoming client at a time. Multitasking servers are covered in Chapter 16 of the Camel.</source>
          <target state="translated">이 서버는 다섯 가지 명령 중 하나를 받아 들여 클라이언트로 출력을 보냅니다. 대부분의 네트워크 서버와 달리이 서버는 한 번에 하나의 수신 클라이언트 만 처리합니다. 멀티 태스킹 서버는 Camel의 16 장에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="ffb206fa8662fa49c173d5f9d350cc23a1d8b5c6" translate="yes" xml:space="preserve">
          <source>This server takes the trouble to clone off a child version via fork() for each incoming request. That way it can handle many requests at once, which you might not always want. Even if you don't fork(), the listen() will allow that many pending connections. Forking servers have to be particularly careful about cleaning up their dead children (called &quot;zombies&quot; in Unix parlance), because otherwise you'll quickly fill up your process table. The REAPER subroutine is used here to call waitpid() for any child processes that have finished, thereby ensuring that they terminate cleanly and don't join the ranks of the living dead.</source>
          <target state="translated">이 서버는 들어오는 각 요청에 대해 fork ()를 통해 하위 버전을 복제하는 데 어려움을 겪습니다. 그렇게하면 한 번에 많은 요청을 처리 할 수 ​​있으며 항상 원치 않을 수도 있습니다. fork ()를하지 않더라도 listen ()은 보류중인 많은 연결을 허용합니다. 포크 서버는 프로세스 테이블을 빠르게 채울 수 있기 때문에 죽은 자식 (유닉스 용어에서 &quot;좀비&quot;라고 함)을 정리하는 데 특히주의해야합니다. REAPER 서브 루틴은 여기에서 완료된 모든 하위 프로세스에 대해 waitpid ()를 호출하여 깨끗하게 종료되고 살아있는 사람의 순위에 합류하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="3c5ebe323e1cea15acbe8beafe841f6d123af5cf" translate="yes" xml:space="preserve">
          <source>This set of instructions is meant to describe a so-called &quot;native&quot; port of Perl to the Windows platform. This includes both 32-bit and 64-bit Windows operating systems. The resulting Perl requires no additional software to run (other than what came with your operating system). Currently, this port is capable of using one of the following compilers on the Intel x86 architecture:</source>
          <target state="translated">이 지시 사항 세트는 Windows 플랫폼에 대한 소위 &quot;기본&quot;포트 Perl을 설명하기위한 것입니다. 여기에는 32 비트 및 64 비트 Windows 운영 체제가 모두 포함됩니다. 결과 Perl은 운영 체제와 함께 제공된 소프트웨어 외에 추가 소프트웨어를 실행할 필요가 없습니다. 현재이 포트는 Intel x86 아키텍처에서 다음 컴파일러 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8777023fd72f0e0c5194df7056fed5f92ab1ed79" translate="yes" xml:space="preserve">
          <source>This sets &lt;code&gt;$\&lt;/code&gt; to newline and then sets &lt;code&gt;$/&lt;/code&gt; to the null character.</source>
          <target state="translated">이 세트 &lt;code&gt;$\&lt;/code&gt; 줄 바꿈과는 설정 &lt;code&gt;$/&lt;/code&gt; 널 문자로.</target>
        </trans-unit>
        <trans-unit id="4549dd71bcce8b09d1c070ffac130c9cb9eed0b2" translate="yes" xml:space="preserve">
          <source>This sets a variable in op/numconvert.t.</source>
          <target state="translated">op / numconvert.t에 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="df79d9971c873dd56e1affe3565f833f5f4ef4be" translate="yes" xml:space="preserve">
          <source>This sets the</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="cc422551baf5bd378e1441e1ffd937104c35c5d0" translate="yes" xml:space="preserve">
          <source>This sets the accuracy for all math operations. The argument must be greater than or equal to zero. See Math::BigInt's bround() function for details.</source>
          <target state="translated">모든 수학 연산의 정확도를 설정합니다. 인수는 0보다 크거나 같아야합니다. 자세한 내용은 Math :: BigInt의 bround () 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2057b585966ee5e34a71b1fcc4af8dffd8aef3" translate="yes" xml:space="preserve">
          <source>This sets the default per-thread stack size at the start of the application.</source>
          <target state="translated">응용 프로그램 시작시 스레드 별 기본 스택 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d80f3ae97beba02bd7de41d9d2bef09e8032704e" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt; 's output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt; , otherwise you should probably do something like this:</source>
          <target state="translated">이것은 &lt;code&gt;$parser&lt;/code&gt; 의 출력이 쓰여질 파일 핸들을 설정합니다 . &lt;code&gt;*STDOUT&lt;/code&gt; 또는 &lt;code&gt;*STDERR&lt;/code&gt; 을 전달할 수 있습니다 . 그렇지 않으면 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f62f85bc91a48745c4461c85cd5655d80de88af" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt;'s output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt;, otherwise you should probably do something like this:</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 의 출력이 기록 될 파일 핸들을 설정합니다 . &lt;code&gt;*STDOUT&lt;/code&gt; 또는 &lt;code&gt;*STDERR&lt;/code&gt; 을 전달할 수 있습니다 . 그렇지 않으면 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="af102c7f2132a623b34e9347ca5e8597fbe36895" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt; , or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">이 코드는이 문서에있는 언어 태그를 설정합니다. 기본적으로 현재 환경 변수 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 의 값 이거나 설정되지 않은 경우 값 1033 (미국 영어의 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="38b3389f1a148c762d20dbeefeec456038d65737" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt;, or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">이 문서에있는 것으로 태그를 지정하는 언어 코드를 설정합니다. 기본적으로 현재 환경 변수 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 의 값 이거나 설정되지 않은 경우 값 1033 (미국 영어의 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="529a10bfb87aaa836949c559d932aa868d0ea517" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, and are &amp;lt;B&amp;gt;ignored&amp;lt;/B&amp;gt; since all operations happen in integer space. A positive value rounds to this digit left from the dot. 0 or 1 mean round to integer and are ignore like negative values.</source>
          <target state="translated">모든 수학 연산의 정밀도를 설정합니다. 인수는 정수일 수 있습니다. 음수 값은 점 뒤에 고정 된 자릿수를 의미하며 모든 연산이 정수 공간에서 발생하므로 &amp;lt;B&amp;gt; 무시 &amp;lt;/ B&amp;gt;됩니다. 양수 값은 점에서 왼쪽으로이 숫자로 반올림합니다. 0 또는 1은 정수로 반올림하며 음수 값처럼 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="674e5733f608427771b5b90d6f64c3b452aa5b35" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, while a positive value rounds to this digit left from the dot. 0 or 1 mean round to integer. See Math::BigInt's bfround() function for details.</source>
          <target state="translated">모든 수학 연산의 정밀도를 설정합니다. 인수는 정수일 수 있습니다. 음수 값은 점 뒤에 고정 된 자릿수를 의미하고 양수 값은 점에서 왼쪽으로이 숫자로 반올림합니다. 0 또는 1은 정수로 반올림합니다. 자세한 내용은 Math :: BigInt의 bfround () 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b5668a047104c30653c0804d67e484bf29d90cb" translate="yes" xml:space="preserve">
          <source>This sets the soft and hard limits to 10 and 20 seconds, respectively. After 10 seconds of time spent running on the CPU (not &quot;wall&quot; time), the process will be sent a signal (XCPU on some systems) which, if not trapped, will cause the process to terminate. If that signal is trapped, then after 10 more seconds (20 seconds in total) the process will be killed with a non-trappable signal.</source>
          <target state="translated">소프트 및 하드 제한을 각각 10 초와 20 초로 설정합니다. &quot;벽&quot;시간이 아닌 CPU에서 10 초의 시간을 소비 한 후 프로세스는 트랩되지 않은 경우 프로세스를 종료시키는 신호 (일부 시스템의 XCPU)를 전송합니다. 해당 신호가 포착되면 10 초 이상 (총 20 초) 후에 트랩 할 수없는 신호로 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="130c125b35cf3d3da34044cd207b5628dc2ffac8" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt; 's output will be sent to, instead of any filehandle.</source>
          <target state="translated">이것은 파일 핸들 대신 &lt;code&gt;$parser&lt;/code&gt; 출력이 전송 될 문자열을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="11dc24aa23b6cf452f77c63ea5e698909de49109" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt;'s output will be sent to, instead of any filehandle.</source>
          <target state="translated">이것은 파일 핸들 대신 &lt;code&gt;$parser&lt;/code&gt; 의 출력이 전송 될 문자열을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6b4632ee2d247f3c071c82005711a1c83db25822" translate="yes" xml:space="preserve">
          <source>This sets the version required for the given module to</source>
          <target state="translated">이것은 주어진 모듈에 필요한 버전을 다음과 같이 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ce02c4df1fe3dcc67a7d36b7b1e441cff60cc978" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일 렌더링에 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: HTML&quot;입니다. 다른 것으로 설정하면 아마도 Pod :: Simple :: HTML의 서브 클래스 여야하고 Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5cfda4b2fca350828dd5a1ac91438eac5b206248" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일을 렌더링하는 데 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: HTML&quot;입니다. 다른 것으로 설정하면 Pod :: Simple :: HTML의 하위 클래스 여야 &lt;code&gt;require&lt;/code&gt; Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 요구 하거나 &lt;code&gt;use&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ec1e3d22ca8911a43038e77812f3f3938f114390" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일 검색에 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: Search&quot;입니다. 다른 것으로 설정하면 아마도 Pod :: Simple :: Search의 서브 클래스 여야하고 Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7237f6ff3ed8efb498d362dab04bc50228f211f0" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일 검색에 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: Search&quot;입니다. 다른 것으로 설정하면 Pod :: Simple :: Search의 하위 클래스 여야 &lt;code&gt;require&lt;/code&gt; Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 요구 하거나 &lt;code&gt;use&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c9cf2efded42d8cb56f73f264ab95aef6e9febaa" translate="yes" xml:space="preserve">
          <source>This setting has currently no effect on tied hashes.</source>
          <target state="translated">이 설정은 현재 연결된 해시에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52c8e9c991aed7d8a50a93d4bed0eb71bffb9b06" translate="yes" xml:space="preserve">
          <source>This setting has no effect on &lt;code&gt;decode&lt;/code&gt;.</source>
          <target state="translated">이 설정은 &lt;code&gt;decode&lt;/code&gt; 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c8d1b9e8622b5f2ff4cb6a55e0533419d19af149" translate="yes" xml:space="preserve">
          <source>This setting has no effect when decoding JSON texts.</source>
          <target state="translated">이 설정은 JSON 텍스트를 디코딩 할 때 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03e68aea7378a9d8770b734fa44395aeb3e883a4" translate="yes" xml:space="preserve">
          <source>This setting has no effect when decoding JSON texts. You will also most likely combine this setting with &lt;code&gt;space_after&lt;/code&gt;.</source>
          <target state="translated">이 설정은 JSON 텍스트를 디코딩 할 때 효과가 없습니다. 또한이 설정을 &lt;code&gt;space_after&lt;/code&gt; 와 결합 할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="40822cd1e25ae559171a5c38a63f3fa78270123b" translate="yes" xml:space="preserve">
          <source>This setting needs to be in effect while Perl is built, but also when the programs are run.</source>
          <target state="translated">이 설정은 Perl이 빌드되는 동안뿐만 아니라 프로그램이 실행될 때도 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ef0f761ac69580bceb47730cfb76aca36efdbeb" translate="yes" xml:space="preserve">
          <source>This shares the variable(s) in the argument list with the compartment. This is almost identical to exporting variables using the &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; module.</source>
          <target state="translated">인수 목록의 변수를 구획과 공유합니다. &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 모듈을 사용하여 변수를 내보내는 것과 거의 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d152c0ad7d6bcbd14fe51b7170fea53d971e63b6" translate="yes" xml:space="preserve">
          <source>This shifts the burden of complexity off to the quant method. That method's parameters are: the numeric value it's going to use to quantify something; the Russian word it's going to quantify; and the parameter &quot;accusative&quot;, which you're using to mean that this sentence's syntax wants a noun in the accusative case there, although that quantification method may have to overrule, for grammatical reasons you may recall from the beginning of this article.</source>
          <target state="translated">이것은 복잡성의 부담을 양자 방법으로 이동시킵니다. 이 메서드의 매개 변수는 다음과 같습니다. 어떤 것을 정량화하는 데 사용할 숫자 값; 수량화 할 러시아어 단어; 그리고 &quot;accusative&quot;라는 매개 변수는이 문장의 구문이이 글의 시작 부분에서 기억할 수있는 문법적 이유로 인해 그 정량화 방법이 우선해야 할 수도 있지만이 문장의 구문이 비난 적 경우에 명사를 원한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6847db733d896a734ef92c2af3a111d1b507ced6" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt; and friends.</source>
          <target state="translated">이것은 &lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt; 와 친구들을 사용하여 얻은 메모리 &lt;b&gt;에만&lt;/b&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d3464b620ba9f7ef03d81ee4683ae7ba242d757" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; and friends.</source>
          <target state="translated">이것은 &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; 와 친구들을 사용하여 얻은 메모리 &lt;b&gt;에서만&lt;/b&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d79a68f01e1702d7ec1c9976d188db9c7f2aece8" translate="yes" xml:space="preserve">
          <source>This should allow read/write access to any files that are extracted from the zip file/buffer`.</source>
          <target state="translated">이것은 zip 파일 / 버퍼에서 추출 된 모든 파일에 대한 읽기 / 쓰기 액세스를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="38a7ea1ad739ecad0857da6650e530f48bc66f62" translate="yes" xml:space="preserve">
          <source>This should be completely transparent to any applications written entirely in Perl (minus a few rarely encountered caveats given in the &lt;a href=&quot;#Multi-threaded&quot;&gt;&quot;Multi-threaded&quot;&lt;/a&gt; section). Information for XS module writers is given in &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">이것은 완전히 Perl로 작성된 모든 응용 프로그램에 대해 완전히 투명해야합니다 ( &lt;a href=&quot;#Multi-threaded&quot;&gt;&quot;다중 스레드&quot;&lt;/a&gt; 섹션 에서 제공하는 몇 가지 드물게 발생하는주의 사항 제외 ). XS 모듈 작성자에 대한 정보 &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;는 perlxs의 &quot;로케일 인식 XS 코드&quot;에 제공&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bc0e6df3ccf75b9d4b22bada1e150f1c0bf5e1" translate="yes" xml:space="preserve">
          <source>This should be fixed already.</source>
          <target state="translated">이것은 이미 수정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1709f85224b4fc47c42955a5583dcda72fcf36e" translate="yes" xml:space="preserve">
          <source>This should be fixed.</source>
          <target state="translated">이것은 수정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d375da43f6c63dd4302e9f62a049ebffa1351990" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt; ' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; , can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">이것은 ' &lt;code&gt;PVOP&lt;/code&gt; '로만 해석되어야합니다 . &lt;code&gt;_OR_SVOP&lt;/code&gt; 는 유일한 핵심 때문이다 &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; 이 , 때로는 될 수 &lt;code&gt;SVOP&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="55cb7fd92e54949da6a1f17f8e9cc521852ab737" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt;' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt;, &lt;code&gt;OP_TRANS&lt;/code&gt;, can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">이것은 ' &lt;code&gt;PVOP&lt;/code&gt; '로만 해석되어야합니다 . &lt;code&gt;_OR_SVOP&lt;/code&gt; 는 유일한 핵심 때문이다 &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; 이 , 때로는 될 수 &lt;code&gt;SVOP&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="13a5db63688f7fa372582799c1bd3dfdaa3ba0cd" translate="yes" xml:space="preserve">
          <source>This should be replaced by the full path to your clang executable if it is not in your path.</source>
          <target state="translated">경로에없는 경우 clang 실행 파일의 전체 경로로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="87cbf40ae5f30dda5d9df6e6dea667727ea90c08" translate="yes" xml:space="preserve">
          <source>This should be set for non debug messages that are still important enough to show when a formatter is in quiet mode. A formatter should send these to STDOUT not STDERR, but should show them even in non-verbose mode.</source>
          <target state="translated">이는 포맷터가 자동 모드에있을 때 표시하기에 충분히 중요한 비디 버그 메시지에 대해 설정해야합니다. 포맷터는 이것을 STDERR이 아닌 STDOUT으로 보내야하지만 상세하지 않은 모드에서도 보여 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="b5a95a55a5803d791f964bba2e2a1d75b4c88370" translate="yes" xml:space="preserve">
          <source>This should be the first thing you call in your test script. It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.</source>
          <target state="translated">테스트 스크립트에서 가장 먼저 호출해야합니다. 테스트 계획, 계획 수, 실패 여부 등을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="c0f01ea79ad3c782b34e1c39edb42ab144bd80b0" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl522.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">이것은 모든 것을 구축해야합니다. 특히 perl.exe, perl522.dll을 perl 최상위 수준에 만들고 다양한 기타 확장 dll을 lib \ auto 디렉토리에 만듭니다. 어떤 이유로 든 빌드가 실패하면 이전 단계를 올바르게 수행했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3a62d97effee732e54e0d1504511279a90715573" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl532.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">이것은 모든 것을 구축해야합니다. 특히 perl.exe, perl532.dll을 perl 최상위에 생성하고 기타 다양한 확장 dll을 lib \ auto 디렉토리에 생성합니다. 어떤 이유로 든 빌드가 실패하면 이전 단계를 올바르게 수행했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="30ba9060ffc1293bd461e0db035bb80a563a059f" translate="yes" xml:space="preserve">
          <source>This should build miniperl and then fail when it tries to run it.</source>
          <target state="translated">miniperl을 빌드 한 다음 실행하려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="db496c0536d24209950a452554a51ec2ca77e58c" translate="yes" xml:space="preserve">
          <source>This should contain a URI where the exact terms of the license may be found.</source>
          <target state="translated">여기에는 라이선스의 정확한 조건을 찾을 수있는 URI가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="678375f3c34a52f1c875afc4e9a5d9d1a7cc959a" translate="yes" xml:space="preserve">
          <source>This should create an executable</source>
          <target state="translated">이것은 실행 파일을 만들어야합니다</target>
        </trans-unit>
        <trans-unit id="0343ed053df7e2ae641054c461a6d9ef120ebfaa" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt; , but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; followed by another &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes&lt;/a&gt; above.)</source>
          <target state="translated">이는 &lt;code&gt;\xDF&lt;/code&gt; 가 아닌 문자 와 &lt;code&gt;/i&lt;/code&gt; 에서 &lt;code&gt;\xDF&lt;/code&gt; 일치 하는 문자 시퀀스와 일치해야합니다 . &lt;code&gt;&quot;s&quot;&lt;/code&gt; 는 &lt;code&gt;\xDF&lt;/code&gt; 가 아니지만, 유니 코드에 따르면 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 는 &lt;code&gt;\xDF&lt;/code&gt; 가 &lt;code&gt;/i&lt;/code&gt; 에서 일치하는 것 입니다. 어느 쪽이 &quot;승리&quot;합니까? 문자열에 &lt;code&gt;ss&lt;/code&gt; 가 있기 때문에 일치하지 않거나 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 있고 다른 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 있기 때문에 수락 합니까? 펄은 후자를 선택했다. ( 위의 &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;괄호로 묶은 문자 클래스의&lt;/a&gt; 참고 사항을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="eb02f2a8ec63111dfc588d8b17a8d6fb2096fcb5" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt;, but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;s&lt;/code&gt; followed by another &lt;code&gt;s&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot;&lt;/a&gt; above.)</source>
          <target state="translated">이것은 &lt;code&gt;\xDF&lt;/code&gt; 가 아닌 모든 문자 시퀀스 나 &lt;code&gt;/i&lt;/code&gt; 아래에서 &lt;code&gt;\xDF&lt;/code&gt; 일치 하는 문자와 일치해야합니다 . &lt;code&gt;&quot;s&quot;&lt;/code&gt; 는 &lt;code&gt;\xDF&lt;/code&gt; 가 아니지만 유니 코드는 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 가 &lt;code&gt;/i&lt;/code&gt; 아래에서 일치 하는 &lt;code&gt;\xDF&lt;/code&gt; 라고 말합니다 . 그럼 어느 쪽이 &quot;승리&quot;할까요? 당신은 문자열이 있기 때문에 경기를하지 마십시오 &lt;code&gt;ss&lt;/code&gt; 그가이 있기 때문에 그것을 또는 동의 &lt;code&gt;s&lt;/code&gt; 의 또 다른 다음 &lt;code&gt;s&lt;/code&gt; ? Perl은 후자를 선택했습니다. ( 위의 &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;&quot;브라켓 문자 클래스&quot;의&lt;/a&gt; 참고를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="050396cf8762718cb34435af8d06d17eb8dd7bc6" translate="yes" xml:space="preserve">
          <source>This should not be used to supply default values for parameters. One would normally use this when a function parameter must be processed by another library function before it can be used. Default parameters are covered in the next section.</source>
          <target state="translated">매개 변수의 기본값을 제공하는 데 사용해서는 안됩니다. 함수 매개 변수를 사용하기 전에 다른 라이브러리 함수에서 처리해야하는 경우 일반적으로이를 사용합니다. 기본 매개 변수는 다음 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="8b1ca7922101edcce2a492b3a6c129abd8a583e6" translate="yes" xml:space="preserve">
          <source>This should only be necessary if</source>
          <target state="translated">이 경우에만 필요합니다</target>
        </trans-unit>
        <trans-unit id="598f32a1125324d2a241a1c920bc050b40fac3d7" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 함수는 위의 &lt;code&gt;MHCONTEXT&lt;/code&gt; 에서와 같이 숫자 설명 자의 dup이더라도 Perl 자체에서 열린 것에 사용 되므로 거의 필요하지 않습니다 . 그러나 정말로해야 할 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e177911fc8ed26557ec26b5355ec1390d9f4d0" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;close()&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">Perl &lt;code&gt;close()&lt;/code&gt; 함수는 위의 &lt;code&gt;MHCONTEXT&lt;/code&gt; 에서와 같이 숫자 설명 자의 복제 인 경우에도 Perl이 자체적으로 열었던 것에 사용되기 때문에 거의 필요하지 않습니다 . 그러나 정말로 필요하다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d79cf36faa3af81e4bd5bbe5c4a98d13ad84be9" translate="yes" xml:space="preserve">
          <source>This should return true if the driver works in the current environment. This should return false if it does not. This is a CLASS method.</source>
          <target state="translated">드라이버가 현재 환경에서 작동하는 경우 true를 반환해야합니다. 그렇지 않은 경우 false를 반환해야합니다. 이것은 CLASS 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cf1ab6069990fc4ba153fc0e586880eb88157c07" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 SV를 가리키는 참조 임을 보여줍니다 . 그 SV는 해시 인 PVHV입니다.</target>
        </trans-unit>
        <trans-unit id="b7c7e9b83cb4841b6e6724c1f7e531bbbc2b68cb" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash. Fields RITER and EITER are used by &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 SV를 가리키는 참조 임을 나타냅니다 . 그 SV는 해시 인 PVHV입니다. RITER 및 EITER 필드는 &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4544b90fccd9dc8117d7d96fcbc15a1ca629dfae" translate="yes" xml:space="preserve">
          <source>This shows that</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="d012fb20c34f9ef1051349030cb25501698029ec" translate="yes" xml:space="preserve">
          <source>This shows that there were changes to this document staged for commit, and that there were further changes in the working directory not yet staged. It also shows that there was an untracked file in the working directory, and as you can see shows how to change all of this. It also shows that there is one commit on the working branch &lt;code&gt;blead&lt;/code&gt; which has not been pushed to the &lt;code&gt;origin&lt;/code&gt; remote yet. &lt;b&gt;NOTE&lt;/b&gt;: This output is also what you see as a template if you do not provide a message to &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이것은 커밋을 위해 준비된이 문서에 변경 사항이 있고 아직 준비되지 않은 작업 디렉토리에 추가 변경 사항이 있음을 보여줍니다. 또한 작업 디렉토리에 추적되지 않은 파일이 있음을 보여 주며 보시다시피이 모든 것을 변경하는 방법을 보여줍니다. 또한 아직 &lt;code&gt;origin&lt;/code&gt; 원격 으로 푸시되지 않은 작업 브랜치 &lt;code&gt;blead&lt;/code&gt; 에 하나의 커밋이 있음을 보여줍니다 . &lt;b&gt;참고&lt;/b&gt; :이 출력은 &lt;code&gt;git commit&lt;/code&gt; 에 메시지를 제공하지 않는 경우 템플릿으로도 표시됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b55aa05d72ea8d4828d039cb967e2a4c2c9f3f35" translate="yes" xml:space="preserve">
          <source>This shows that we have an SV which is a reference, which points at another SV. In this case that second SV is a PVMG, a blessed scalar. Because it is blessed it has the &lt;code&gt;OBJECT&lt;/code&gt; flag set. Note that an SV which holds a C pointer also has the &lt;code&gt;IOK&lt;/code&gt; flag set. The &lt;code&gt;STASH&lt;/code&gt; is set to the package name which this SV was blessed into.</source>
          <target state="translated">이것은 우리가 다른 SV를 가리키는 참조 인 SV를 가지고 있음을 보여줍니다. 이 경우 두 번째 SV는 축복 스칼라 인 PVMG입니다. 복이 있기 때문에 &lt;code&gt;OBJECT&lt;/code&gt; 플래그가 설정되어 있습니다. C 포인터를 보유한 SV에도 &lt;code&gt;IOK&lt;/code&gt; 플래그가 설정되어 있습니다. &lt;code&gt;STASH&lt;/code&gt; 이 SV가에 축복 된 패키지 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d6b36418bf4797a5df13199701553bd6ebeff202" translate="yes" xml:space="preserve">
          <source>This shows the sorts of output the &lt;code&gt;l&lt;/code&gt; command can produce:</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 명령이 생성 할 수있는 출력 종류를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="220ae5d1e65680423ed0fee8d1ae71265a4673d1" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt; . The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">서브 루틴 &lt;code&gt;clear_noremap&lt;/code&gt; 에 사용 된 변수를 보여줍니다 . 변수의 &lt;code&gt;$ready_to_print&lt;/code&gt; A가 내 () (어휘) 변수이며, &lt;b&gt;내가&lt;/b&gt; ntroduced 라인 1069에와 변수 라인 1079에 사용 (첫째 내 ()로 선언) &lt;code&gt;$&amp;amp;&lt;/code&gt; 메인 패키지 등 1086에 사용되며, .</target>
        </trans-unit>
        <trans-unit id="69445b30eafff7b7c0b6c3e36cb0b52aa8e5353f" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt;. The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">이것은 서브 루틴 &lt;code&gt;clear_noremap&lt;/code&gt; 에서 사용되는 변수를 보여줍니다 . 변수의 &lt;code&gt;$ready_to_print&lt;/code&gt; A가 내 () (어휘) 변수이며, &lt;b&gt;내가&lt;/b&gt; ntroduced 라인 1069에와 변수 라인 1079에 사용 (첫째 내 ()로 선언) &lt;code&gt;$&amp;amp;&lt;/code&gt; 메인 패키지 등 1086에 사용되며, .</target>
        </trans-unit>
        <trans-unit id="e3a1a612c118404300b4fc88e912d956be940f47" translate="yes" xml:space="preserve">
          <source>This shows us two libraries being updated and two being added, one of which has an undefined version in the right-hand side version.</source>
          <target state="translated">이것은 두 개의 라이브러리가 업데이트되고 두 개의 라이브러리가 추가되고 있음을 보여줍니다. 그 중 하나는 오른쪽 버전에 정의되지 않은 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9392876266258935c97915a0016be1ab3e077a8" translate="yes" xml:space="preserve">
          <source>This shows what a reference looks like when it references a simple scalar.</source>
          <target state="translated">간단한 스칼라를 참조 할 때 참조 모양을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="62c1dd6d2092bdafabfdd27d34aabe7eb07a45cc" translate="yes" xml:space="preserve">
          <source>This shows what a reference to an array looks like.</source>
          <target state="translated">배열에 대한 참조 모양을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5af0b0f40fa34ec87e6b5d92094f2a134fbd1781" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">이는 분해가 알고리즘 적으로 계산되는 모든 코드 포인트에 대한 분해로이 항목을 대체해야 함을 의미합니다. (현재 모두 하나의 범위에 있으며 범위 밖의 다른 것은 유니 코드에 추가되지 않을 가능성이 높습니다. &lt;code&gt;&quot;n&quot;&lt;/code&gt; 형식에는 동일한 항목이 있습니다.) 이러한 항목은 &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize :: NFD (&lt;/a&gt; 함수를 통해 생성 할 수 있습니다. ) .</target>
        </trans-unit>
        <trans-unit id="19b0c298e2bbc25317cee46892abecba84a7892d" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">이는 분해가 알고리즘 적으로 계산되는 모든 코드 포인트에 대해이 항목이 분해로 대체되어야 함을 나타냅니다. (이들 모두는 현재 한 범위에 있고 범위 밖의 다른 것은 유니 코드에 추가 될 가능성이 없습니다. &lt;code&gt;&quot;n&quot;&lt;/code&gt; 형식은 동일한 항목을 갖습니다.) &lt;a href=&quot;normalize&quot;&gt;유니 코드 :: Normalize :: NFD ( )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3ee18b62d8c4cf82c2682ec3f88357d163d3e8" translate="yes" xml:space="preserve">
          <source>This silent implicit decoding is known as &quot;upgrading&quot;. That may sound positive, but it's best to avoid it.</source>
          <target state="translated">이 자동 암시 적 디코딩을 &quot;업그레이드&quot;라고합니다. 긍정적 인 것처럼 들리지만 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="75ceec87638702fc9211fcbb47c663ad2b557d5f" translate="yes" xml:space="preserve">
          <source>This simplifies the reverse operation as the number of repetitions can be unpacked with the &lt;code&gt;/&lt;/code&gt; code:</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 코드를 사용하여 반복 횟수를 풀 수 있으므로 역 동작이 간단 해집니다 .</target>
        </trans-unit>
        <trans-unit id="c76a52e49b25fb93c5814da39f8a0ca4f090ec45" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt; .</source>
          <target state="translated">이것은 단순히 &lt;code&gt;sv_magic&lt;/code&gt; 을 호출 하고 &lt;code&gt;gv&lt;/code&gt; 인수를 &lt;code&gt;SV&lt;/code&gt; 로 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="37a8b66b66bc575f562e00ecf205b1032d87cf22" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt;.</source>
          <target state="translated">이것은 단순히 &lt;code&gt;sv_magic&lt;/code&gt; 을 호출 하고 &lt;code&gt;gv&lt;/code&gt; 인수를 &lt;code&gt;SV&lt;/code&gt; 로 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="15c5bc95dce18ddda2693ffc0b4a16e21790eea4" translate="yes" xml:space="preserve">
          <source>This simply evaluates any expression (&lt;code&gt;$got eq $expected&lt;/code&gt; is just a simple example) and uses that to determine if the test succeeded or failed. A true expression passes, a false one fails. Very simple.</source>
          <target state="translated">이것은 단순히 모든 표현식을 평가하고 ( &lt;code&gt;$got eq $expected&lt;/code&gt; 는 단순한 예일뿐)이를 사용하여 테스트의 성공 또는 실패 여부를 판별합니다. 진정한 표현은 통과하고, 거짓 표현은 실패합니다. 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="3d969d8fe90ed0cdf3881a37bda779e5984f6b64" translate="yes" xml:space="preserve">
          <source>This simply passes the C representation of the Perl variable (an SV*) in and out of the XS layer. This can be used if the C code wants to deal directly with the Perl variable.</source>
          <target state="translated">이는 XS 계층 안팎으로 Perl 변수 (SV *)의 C 표현을 전달합니다. C 코드가 Perl 변수를 직접 처리하려는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e6d63f50f6edf8d1ca7caa25f784dd03a42ad6f" translate="yes" xml:space="preserve">
          <source>This simultaneously affects all threads of the program, so it may be problematic to use locales in threaded applications except where there is a single locale applicable to all threads.</source>
          <target state="translated">이것은 동시에 프로그램의 모든 스레드에 영향을 미치므로 모든 스레드에 적용 가능한 단일 로캘이있는 경우를 제외하고 스레드 응용 프로그램에서 로캘을 사용하는 것이 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd936fff6e8f9ae7642c5c6dc94b4b5fc101a895" translate="yes" xml:space="preserve">
          <source>This situation can happen, for example, in</source>
          <target state="translated">이 상황은 예를 들어 다음과 같이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e7f436f0844c6bf989784164030c8f8ea5c91c" translate="yes" xml:space="preserve">
          <source>This software enables you to upgrade software on your computer and so is inherently dangerous because the newly installed software may contain bugs and may alter the way your computer works or even make it unusable. Please consider backing up your data before every upgrade.</source>
          <target state="translated">이 소프트웨어를 사용하면 컴퓨터에서 소프트웨어를 업그레이드 할 수 있으므로 새로 설치된 소프트웨어에 버그가 포함되어 컴퓨터 작동 방식을 변경하거나 사용하지 못하게 될 수 있으므로 본질적으로 위험합니다. 업그레이드 할 때마다 데이터 백업을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="95b86ac068430d7abe3629291f82ebff76fb040f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1996- by Andreas Koenig.</source>
          <target state="translated">이 소프트웨어는 Andreas Koenig에 의해 저작권이 있습니다 (c) 1996-.</target>
        </trans-unit>
        <trans-unit id="dfe6bc95971d9555fd4a070b4a33ad4fd59cb09c" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1997 - 2018 by Graham Barr &amp;amp; Dave Rolsky.</source>
          <target state="translated">이 소프트웨어의 저작권은 Graham Barr &amp;amp; Dave Rolsky가 (c) 1997-2018에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21371f38c12dbc9248a71f0465727bfaee148a3" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2002 by Ilya Zakharevich.</source>
          <target state="translated">이 소프트웨어의 저작권은 Ilya Zakharevich가 (c) 2002에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8d4de71ea698d046dd2d94f72a8a7fd4559231" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by Adam Kennedy.</source>
          <target state="translated">이 소프트웨어의 저작권은 Adam Kennedy가 (c) 2010에 있습니다.</target>
        </trans-unit>
        <trans-unit id="af578baff649ee012be86b76b46b21b70df94c94" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by David Golden and Ricardo Signes.</source>
          <target state="translated">이 소프트웨어의 저작권은 David Golden과 Ricardo Signes가 (c) 2010에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8bb5af5fa084e557d0f3cc7f0b45662d3a55d8f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2010 by David Golden, Ricardo Signes, Adam Kennedy and Contributors.</source>
          <target state="translated">이 소프트웨어는 David Golden, Ricardo Signes, Adam Kennedy 및 Contributors의 저작권 (c) 2010입니다.</target>
        </trans-unit>
        <trans-unit id="e377a624f20232cdb4cb749fe2907f2c5ef396be" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Leon Timmermans.</source>
          <target state="translated">이 소프트웨어는 Leon Timmermans의 저작권 (c) 2013입니다.</target>
        </trans-unit>
        <trans-unit id="67032da8813d4f4a0a08f93013ebb3760de4d75d" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">이 소프트웨어는 Tim Jenness와 UK Particle Physics and Astronomy Research Council에 의해 (c) 2013 저작권이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5cf6253d3c58ee0e8370fe0b1014e17ef0f493" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2014 by Adam Kennedy and Contributors.</source>
          <target state="translated">이 소프트웨어는 Adam Kennedy와 Contributors에 의해 2014 년 저작권이 있습니다 (c).</target>
        </trans-unit>
        <trans-unit id="66f85f97c6d8584288b7cc1e27089a6848dac19e" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2016 by David Golden.</source>
          <target state="translated">이 소프트웨어는 David Golden의 저작권 (c) 2016입니다.</target>
        </trans-unit>
        <trans-unit id="d3e0edd840c94a8b44ae9918823591f4112c67a4" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2018 by Christian Hansen.</source>
          <target state="translated">이 소프트웨어는 Christian Hansen의 저작권 (c) 2018입니다.</target>
        </trans-unit>
        <trans-unit id="9071214c3f60bf69bb79c3a0e0a801662f73777b" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2019 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">이 소프트웨어는 Tim Jenness와 UK Particle Physics and Astronomy Research Council의 저작권 (c) 2019입니다.</target>
        </trans-unit>
        <trans-unit id="5fb28093815e879710a9bb0a4ef5d290c79e5b95" translate="yes" xml:space="preserve">
          <source>This software is free software and can be modified and distributed under the same terms as Perl itself.</source>
          <target state="translated">이 소프트웨어는 무료 소프트웨어이며 Perl 자체와 동일한 조건으로 수정 및 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dbd632224b5aa617ba78b7d9260ccc05095f469" translate="yes" xml:space="preserve">
          <source>This software is released under the MIT license cited below. Additionally, when this software is distributed with &lt;b&gt;Perl Kit, Version 5&lt;/b&gt;, you may also redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 소프트웨어는 아래 인용 된 MIT 라이센스에 따라 배포됩니다. 또한이 소프트웨어가 &lt;b&gt;Perl Kit, Version 5&lt;/b&gt; 와 함께 배포되는 경우 &lt;b&gt;Perl&lt;/b&gt; 과 동일한 조건으로 소프트웨어 를 재배포 및 / 또는 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8cc7587a3592d000978422dcd1052715c6866c6" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">이 소프트웨어 패턴은 광범위하게 적용 가능하므로 Attribute :: Handlers는이를 자동화하는 방법을 제공합니다. &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; Attribute :: Handlers 문 에서 &lt;code&gt;'autotie'&lt;/code&gt; 를 지정 하십시오 . 따라서 사이클링 예제도 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91e373183a0a3faaf1f65e220cc6670b2950cfc" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;use Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">이 소프트웨어 패턴은 광범위하게 적용 가능하므로 Attribute :: Handlers는이를 자동화하는 방법을 제공합니다. &lt;code&gt;use Attribute::Handlers&lt;/code&gt; 문 에 &lt;code&gt;'autotie'&lt;/code&gt; 를 지정 합니다. 따라서 사이클링 예제도 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89832468782e8e99834462aa8eda8b90c2a987a8" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;. Before Perl 5.28, it used to emit a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category. Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt;) forces it to treat its operands as strings:</source>
          <target state="translated">이 다소 예측할 수없는 동작은 Perl 5.22의 새로운 &quot;비트&quot;기능으로 피할 수 있습니다. &lt;code&gt;use feature 'bitwise'&lt;/code&gt; 을 사용 하거나 &lt;code&gt;use v5.28&lt;/code&gt; 을 사용 하여 활성화 할 수 있습니다 . Perl 5.28 이전에는 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 범주 에서 경고를 내보냈습니다 . 이 기능에서 네 가지 표준 비트 연산자 ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; )는 항상 숫자입니다. 각 연산자 ( &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) 뒤에 점을 추가하면 피연산자가 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4e18e30d88ab31167f2d6596e06fcdc6dfcfae" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the experimental &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; . By default, it will warn unless the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; warnings category has been disabled. (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; will enable the feature and disable the warning.) Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) forces it to treat its operands as strings:</source>
          <target state="translated">Perl 5.22의 새로운 기능인 실험적인 &quot;비트 단위&quot;기능으로 이러한 예측할 수없는 동작을 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 기능을 통해 활성화 할 수 있습니다 . &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 경고 범주가 비활성화되어 있지 않으면 기본적으로 경고가 표시됩니다. ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; 경고 기능을 사용하거나 사용하지 않도록한다.)이 기능에서, 네 개의 표준 비트 연산자 ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ) 항상 숫자입니다. 각 연산자 뒤에 점을 추가하면 ( &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) 피연산자를 문자열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c23e7895c905e61a802fac11e961fcc5116c44d1" translate="yes" xml:space="preserve">
          <source>This sort of code can be a real eyesore to read, as well as being very sensitive to typos, and it's much clearer to dereference the variable explicitly. We're side-stepping the issue of working with object-oriented programming techniques to encapsulate variable access via methods, only accessible through an object. Here we're just discussing the technical implementation of choice, and whether this has an effect on performance. We can see whether this dereferencing operation, has any overhead by putting comparative code in a file and running a &lt;code&gt;Benchmark&lt;/code&gt; test.</source>
          <target state="translated">이런 종류의 코드는 읽기가 쉬울뿐만 아니라 오타에 매우 민감 할 수 있으며 변수를 명시 적으로 역 참조하는 것이 훨씬 더 명확합니다. 우리는 객체 지향 프로그래밍 기술을 사용하여 메소드를 통한 변수 액세스를 캡슐화하고 객체를 통해서만 액세스 할 수있는 문제를 회피하고 있습니다. 여기서 우리는 선택의 기술적 구현과 이것이 성능에 영향을 미치는지 여부를 논의하고 있습니다. 비교 코드를 파일에 넣고 &lt;code&gt;Benchmark&lt;/code&gt; 테스트를 실행하여이 역 참조 작업에 오버 헤드가 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f7b19aa0a9a6b3365d27ee63f89751c7ffa5a4" translate="yes" xml:space="preserve">
          <source>This special value becomes JSON null.</source>
          <target state="translated">이 특수 값은 JSON null이됩니다.</target>
        </trans-unit>
        <trans-unit id="a97c4e8f1d7ea6446c4098759acfa71805444e34" translate="yes" xml:space="preserve">
          <source>This special variable is correctly set to the pseudo-process ID. It can be used to identify pseudo-processes within a particular session. Note that this value is subject to recycling if any pseudo-processes are launched after others have been wait()-ed on.</source>
          <target state="translated">이 특수 변수는 의사 프로세스 ID로 올바르게 설정되어 있습니다. 특정 세션 내에서 의사 프로세스를 식별하는 데 사용할 수 있습니다. 다른 값을 대기 한 후 의사 프로세스가 시작된 경우이 값은 재활용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c4aceca7fa6325a5de35ebe0aa5f8ca9090348" translate="yes" xml:space="preserve">
          <source>This specifies a search for library &lt;code&gt;gl&lt;/code&gt; as before. If that search fails to find the library, it looks at the next item in the list. The &lt;code&gt;:nosearch&lt;/code&gt; flag will prevent searching for the libraries that follow, so it simply returns the value as &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt;, since GCC can use that value as is with its linker.</source>
          <target state="translated">이전과 같이 라이브러리 &lt;code&gt;gl&lt;/code&gt; 에 대한 검색을 지정합니다 . 해당 검색에서 라이브러리를 찾지 못하면 목록에서 다음 항목을 찾습니다. &lt;code&gt;:nosearch&lt;/code&gt; 단순히 같은 값을 반환 있도록 플래그는 다음과 라이브러리 검색을 방지 할 수 있습니다 &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt; 그 링커와 같이 GCC 그 값을 사용할 수 있기 때문에.</target>
        </trans-unit>
        <trans-unit id="15c61edb09c43955982bc45d6acb4f0c4af7b4ab" translate="yes" xml:space="preserve">
          <source>This specifies an option to call the formatter &lt;b&gt;w&lt;/b&gt;ith. For example, &lt;code&gt;-w textsize:15&lt;/code&gt; will call &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; on the formatter object before it is used to format the object. For this to be valid, the formatter class must provide such a method, and the value you pass should be valid. (So if &lt;code&gt;textsize&lt;/code&gt; expects an integer, and you do &lt;code&gt;-w textsize:big&lt;/code&gt;, expect trouble.)</source>
          <target state="translated">이 포맷터를 호출 할 수있는 옵션이 지정 &lt;b&gt;승&lt;/b&gt; i 번째입니다. 예를 들어, &lt;code&gt;-w textsize:15&lt;/code&gt; 는 오브젝트를 형식화하는 데 사용되기 전에 포맷터 오브젝트에서 &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; 를 호출 합니다. 이것이 유효하려면 포맷터 클래스가 그러한 메소드를 제공해야하며 전달하는 값이 유효해야합니다. 따라서 &lt;code&gt;textsize&lt;/code&gt; 에 정수가 필요하고 &lt;code&gt;-w textsize:big&lt;/code&gt; 을 수행하면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68a43776b3796bfc1e7b13ea689fcb5185c15c99" translate="yes" xml:space="preserve">
          <source>This specifies code that should be called when a code line is seen (i.e., a line outside of the Pod). Normally this is undef, meaning that no code should be called. If you provide a routine, it should start out like this:</source>
          <target state="translated">이것은 코드 라인이 보일 때 호출되어야하는 코드를 지정합니다 (즉, 포드 외부 라인). 일반적으로 이것은 undef이며 코드를 호출하지 않아야 함을 의미합니다. 루틴을 제공하면 다음과 같이 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="14a814b946e54a59ba68d016b5b039bbdb959679" translate="yes" xml:space="preserve">
          <source>This specifies that the director &quot;somedir&quot; is the input. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">이것은 &quot;somedir&quot;디렉터가 입력임을 지정합니다. (절대 또는 상대 경로 일 수 있지만 중요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="6e3a29e95276948f0b11420f703cc3aaddffd6ef" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt; .</source>
          <target state="translated">입력 디렉토리가 arrayref &lt;code&gt;\@dirs&lt;/code&gt; 의 항목임을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1655aff188e0c2a28c8b5f646e8ad62ec66c5897" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt;.</source>
          <target state="translated">이것은 입력 디렉토리가 arrayref &lt;code&gt;\@dirs&lt;/code&gt; 의 항목임을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="63679666659be8466fb9bd4dddfdca5063fd3f26" translate="yes" xml:space="preserve">
          <source>This specifies that the output is not to be sent to a pager, but is to be sent directly to STDOUT.</source>
          <target state="translated">출력이 호출기로 전송되지 않고 STDOUT으로 직접 전송되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b1a8fe6a04c1ca76ee22b76d1682c8136ef9711f" translate="yes" xml:space="preserve">
          <source>This specifies that the output is to be sent neither to a pager nor to STDOUT, but is to be saved to the specified filename. Example: &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</source>
          <target state="translated">출력이 호출기 나 STDOUT으로 보내지 않고 지정된 파일 이름으로 저장되도록 지정합니다. 예 : &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d4b28c13ac9c0ec2726a96f6188b8beab502af" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt; . This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">이는 Perldoc이 지정한 출력 형식에 대해 포드 형식화 클래스를 사용하도록 지정합니다. 예를 들면 다음과 같습니다. &lt;code&gt;-oman&lt;/code&gt; 입니다. 이것은 실제로 &lt;code&gt;-M&lt;/code&gt; 스위치 주위의 래퍼 일뿐입니다 . &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 사용 하면 다른 클래스 이름 접두사 끝에 해당 형식 이름을 다른 대문자로 추가하여로드 가능한 클래스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="010d97695be94f0fec9f8d59b9e5f92e8321d055" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt;. This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">이는 지정한 출력 형식에 대해 Perldoc이 Pod 형식 지정 클래스를 사용하도록 지정합니다. 예 : &lt;code&gt;-oman&lt;/code&gt; . 이것은 실제로 &lt;code&gt;-M&lt;/code&gt; 스위치를 둘러싼 래퍼 일뿐입니다 . &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 사용 하면 다른 클래스 이름 접두사 끝에 해당 형식 이름 (대소 문자 구분)을 추가하여로드 가능한 클래스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9e4b01265a71898dfb9f81df9b68ddce9ce51346" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the current directory.</source>
          <target state="translated">이것은 HTML 출력이 현재 디렉토리로 들어가도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ae7a3e343e7bbeb0dfb1ab04a69a9932581a88b" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the directory 'somedir'. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">이것은 HTML 출력이 'somedir'디렉토리로 들어가도록 지정합니다. (절대 또는 상대 경로 일 수 있지만 중요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e7729b553095fc163c271a3e43dbeb5e583f17f6" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; . Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">이것은 arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 전달한 것처럼 &quot;somedir&quot;, &quot;someother&quot;및 &quot;also&quot;디렉토리를 스캔하도록 지정합니다 . 유닉스에서는 &quot;:&quot;-separator가 일반적이지만 MSWin에서는 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; 의 pathsep가 &quot;;&quot;이므로 'somedir; someother; 또한' 가 필요합니다 . 대신에 &quot;:&quot;. (과</target>
        </trans-unit>
        <trans-unit id="4d5774ca5649a7d9fa31c36d1f9fa10a02babb34" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt;. Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">이것은 arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 전달한 것처럼 &quot;somedir&quot;, &quot;someother&quot;및 &quot;also&quot;디렉토리를 스캔하도록 지정합니다 . &quot;:&quot;구분 기호는 Unix에서는 정상이지만 MSWin에서는 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; 의 pathsep이 &quot;;&quot;이므로 대신 'somedir; someother; also' 가 필요합니다 . 대신에 &quot;:&quot;. (과</target>
        </trans-unit>
        <trans-unit id="b8852ab4d60e276583c1dd4292c015bb068208e6" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</source>
          <target state="translated">포드를 포맷하는 데 사용하려는 모듈을 지정합니다. 클래스는 최소한 &lt;code&gt;parse_from_file&lt;/code&gt; 메소드를 제공해야합니다 . 예를 들면 : &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9860d4fcf1674e2b5833d10a9182c9c5be14d26" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt;.</source>
          <target state="translated">포드 형식 지정에 사용하려는 모듈을 지정합니다. 클래스는 최소한 &lt;code&gt;parse_from_file&lt;/code&gt; 메소드를 제공해야합니다 . 예 : &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be95e643e0441d56be0f4bdb53c658cbf47d5fc4" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the beginning of the contents page. The default is a string more or less like this:</source>
          <target state="translated">내용 페이지의 시작 부분에 어떤 문자열을 넣어야하는지 지정합니다. 기본값은 다음과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9c8f94ea33d23c19ce77204a84bf9dc0e745ad73" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the end of the contents page. The default is a string more or less like this:</source>
          <target state="translated">내용 페이지의 끝에 어떤 문자열을 넣어야하는지 지정합니다. 기본값은 다음과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6917d9958e46c59dbadffa0d75ffc8ead9eeb027" translate="yes" xml:space="preserve">
          <source>This specifies where to find a YAML file of test scheduling rules. If not provided, it looks for a default file to use. It first checks for a file given in the &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; environment variable, then it checks for</source>
          <target state="translated">테스트 예약 규칙의 YAML 파일을 찾을 위치를 지정합니다. 제공되지 않으면 사용할 기본 파일을 찾습니다. 먼저 &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; 환경 변수에 지정된 파일을 확인한 다음 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ad18b67d60ebc32fa32a162a7cf995a9a7c75509" translate="yes" xml:space="preserve">
          <source>This stack stores the values that regular perl code is operating on, usually intermediate values of expressions within a statement. The stack itself is formed of an array of SV pointers.</source>
          <target state="translated">이 스택은 일반 펄 코드가 작동하는 값, 일반적으로 명령문 내 표현식의 중간 값을 저장합니다. 스택 자체는 SV 포인터의 배열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c702c584a5b241344dd398527ce50b4bfbe9b63e" translate="yes" xml:space="preserve">
          <source>This stage is controlled by the macro &lt;code&gt;SIZE_ONLY&lt;/code&gt; being set.</source>
          <target state="translated">이 단계는 매크로 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 가 설정되어 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="bad4c7bd6149d53fef7284ef08f67b09b3206bd8" translate="yes" xml:space="preserve">
          <source>This statement is not a legal contract. This statement is not a legal document in any way, shape, or form. Perl is distributed under the GNU Public License and under the Artistic License; those are the precise legal terms. This statement isn't about the law or licenses. It's about community, mutual respect, trust, and good-faith cooperation.</source>
          <target state="translated">이 진술은 법적 계약이 아닙니다. 이 진술은 어떤 식 으로든 형태 또는 형태에 대한 법적 문서가 아닙니다. Perl은 GNU Public License 및 Artistic License에 따라 배포됩니다. 그것들은 정확한 법적 용어입니다. 이 진술은 법률 또는 라이센스에 관한 것이 아닙니다. 공동체, 상호 존중, 신뢰 및 선의의 협력에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a98c55935426becf715b954b892501f79db080b" translate="yes" xml:space="preserve">
          <source>This statement should at least appear in the README file. You may also wish to include it in a Copying file and your source files. Remember to include the other words in addition to the Copyright.</source>
          <target state="translated">이 문장은 최소한 README 파일에 나타나야합니다. 복사 파일과 소스 파일에 포함시킬 수도 있습니다. 저작권 외에 다른 단어도 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="5584a0e56dfda5fbec4748cd6a50bc455909922d" translate="yes" xml:space="preserve">
          <source>This step is listed for completeness only. Since it does not change semantics, details of this step are not documented and are subject to change without notice. This step is performed over the finite automaton that was generated during the previous pass.</source>
          <target state="translated">이 단계는 완전성에 대해서만 나열됩니다. 시맨틱을 변경하지 않으므로이 단계의 세부 사항은 문서화되지 않으며 사전 통지없이 변경 될 수 있습니다. 이 단계는 이전 단계에서 생성 된 유한 오토 마톤에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="54c5eb8ed193c34bf7512d41b140b26cac84363b" translate="yes" xml:space="preserve">
          <source>This step is the last one for all constructs except regular expressions, which are processed further.</source>
          <target state="translated">이 단계는 정규식을 제외한 모든 구성에 대한 마지막 단계이며 추가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="821b4588528e230329db6b553dfd4048a67b80be" translate="yes" xml:space="preserve">
          <source>This still doesn't guarantee that a real person is answering your prompts or reading your output.</source>
          <target state="translated">그래도 실제 사람이 프롬프트에 응답하거나 출력을 읽도록 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7c9161f97b6f8900f13bf7304c1db4d0488adaf" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">패턴에 평가 그룹 수를 저장합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 사용하여 컴파일 된 정규 표현식을 더 큰 패턴으로 임베드 할 때 보안 목적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc862416697ee8a2c0658635a4952465e7e9a208" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="translated">이것은 패턴에 평가 그룹의 수를 저장합니다. 이것은 &lt;code&gt;qr//&lt;/code&gt; 사용하여 컴파일 된 정규식을 더 큰 패턴에 임베드 할 때 보안 목적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc38633b5aabfda04a32707218d9bef85297337b" translate="yes" xml:space="preserve">
          <source>This strategy can employ a network connection. As such it would be computationally expensive.</source>
          <target state="translated">이 전략은 네트워크 연결을 사용할 수 있습니다. 따라서 계산 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="55b6f7ba63a618224a4b898bcbb27d9706c30d52" translate="yes" xml:space="preserve">
          <source>This string tells Perl to consult the CRTL's internal &lt;code&gt;environ&lt;/code&gt; array of key-value pairs, using</source>
          <target state="translated">이 문자열은 Perl에게 다음을 사용하여 키-값 쌍 의 CRTL의 내부 &lt;code&gt;environ&lt;/code&gt; 배열 을 참조하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7ae6448a0aa9566553b6817c071e02a343cc087d" translate="yes" xml:space="preserve">
          <source>This struct typedef</source>
          <target state="translated">이 구조체 typedef</target>
        </trans-unit>
        <trans-unit id="f1bc15138286b1a37e209e8a6243ffb9f2ea5373" translate="yes" xml:space="preserve">
          <source>This structure is used for handling data structures that the regex engine needs to handle specially during a clone or free operation on the compiled product. Each element in the data array has a corresponding element in the what array. During compilation regops that need special structures stored will add an element to each array using the add_data() routine and then store the index in the regop.</source>
          <target state="translated">이 구조는 정규식 엔진이 컴파일 된 제품에서 복제 또는 자유 작업 중에 특별히 처리해야하는 데이터 구조를 처리하는 데 사용됩니다. 데이터 배열의 각 요소는 what 배열의 해당 요소를 갖습니다. 컴파일하는 동안 특수 구조가 필요한 regop은 add_data () 루틴을 사용하여 각 배열에 요소를 추가 한 다음 인덱스를 regop에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="313e4efa9f1c4a624d38d9de85969d28133dcf4f" translate="yes" xml:space="preserve">
          <source>This stuff if needed to allow me to play with other ways of monitoring the test results.</source>
          <target state="translated">테스트 결과를 모니터링하는 다른 방법으로 플레이 할 수 있도록 필요한 경우이 항목을 사용합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="d78d4b0d4925694b27ab08d1c6e58334dc8e28bc" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;//x&lt;/code&gt; modifier.</source>
          <target state="translated">이 스타일의 주석은 &lt;code&gt;//x&lt;/code&gt; 수정 자 와 함께 허용되는 원시 자유형 주석으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="057805a7554b8dd392dcf60ed8e3b1750c015cb9" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;/x&lt;/code&gt; modifier.</source>
          <target state="translated">이 스타일의 주석은 &lt;code&gt;/x&lt;/code&gt; 수정 자 와 함께 허용되는 원시 자유 형식 주석으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9149446c6e172d289bce208ab7502a726c607dbb" translate="yes" xml:space="preserve">
          <source>This subkey gives the integer</source>
          <target state="translated">이 하위 키는 정수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97f344b018a57310e7df154cc09c4a4c8ffc8347" translate="yes" xml:space="preserve">
          <source>This subroutine accepts a new style name and three style arguments as above, and creates, registers, and selects the newly named style. It is an error to re-add a style; call set_style_standard() to switch between several styles.</source>
          <target state="translated">이 서브 루틴은 위와 같이 새 스타일 이름과 세 가지 스타일 인수를 허용하고 새로 이름 지정된 스타일을 작성, 등록 및 선택합니다. 스타일을 다시 추가하는 것은 오류입니다. 여러 스타일 사이를 전환하려면 set_style_standard ()를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d4edd10fd3d7f6f2e8552ea6e5bfd25a981a931d" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">이 서브 루틴은 &lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage를&lt;/a&gt; 사용하여 프로그램의 POD 섹션 SYNOPSIS에서 파생 된 표준 도움말 메시지를 생성합니다 . VersionMessage ()와 동일한 인수를 사용합니다. 특히 다음과 같은 옵션에 직접 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b889ca4ce29aee9a3861172160f0fc1f9aa54f8" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;Pod::Usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">이 서브 루틴은 &lt;a href=&quot;Pod::Usage&quot;&gt;Pod :: Usage를&lt;/a&gt; 사용하는 프로그램의 POD 섹션 SYNOPSIS에서 파생 된 표준 도움말 메시지를 생성합니다 . VersionMessage ()와 동일한 인수를 사용합니다. 특히 다음과 같이 옵션에 직접 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5689fa040b7fc66f95972afdb83490d423250c81" translate="yes" xml:space="preserve">
          <source>This subroutine provides a standard version message. Its argument can be:</source>
          <target state="translated">이 서브 루틴은 표준 버전 메시지를 제공합니다. 그 주장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ecee5dd8e0a61ddae4c3d45c386aa7954dd0f33" translate="yes" xml:space="preserve">
          <source>This subroutine will add commas to your number:</source>
          <target state="translated">이 서브 루틴은 번호에 쉼표를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="f33530c08d2ea0b801b43fac5cff8bb563110c57" translate="yes" xml:space="preserve">
          <source>This succeeds if the &quot;martian&quot; character GX is in the string, and fails otherwise. If you don't like using (?&amp;lt;!), a zero-width negative look-behind assertion, you can replace (?&amp;lt;![A-Z]) with (?:^|[^A-Z]).</source>
          <target state="translated">&quot;martian&quot;문자 GX가 문자열에 있으면 성공하고 그렇지 않으면 실패합니다. 너비가 0 인 음수 룩 어설 션 인 (? &amp;lt;!)를 사용하지 않으려면 (? &amp;lt;! [AZ])를 (? : ^ | [^ AZ])로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a98330f72d7fa29e768ec7aa2344fb1a20cbca" translate="yes" xml:space="preserve">
          <source>This suppresses printing of VMS status messages to SYS$OUTPUT and SYS$ERROR if Perl terminates with an error status, and allows programs that are expecting &quot;unix-style&quot; Perl to avoid having to parse VMS error messages. It does not suppress any messages from Perl itself, just the messages generated by DCL after Perl exits. The DCL symbol $STATUS will still have the termination status, but with a high-order bit set:</source>
          <target state="translated">이것은 Perl이 오류 상태로 종료되면 VMS 상태 메시지가 SYS $ OUTPUT 및 SYS $ ERROR로 인쇄되지 않도록하고 &quot;unix-style&quot;Perl을 기대하는 프로그램이 VMS 오류 메시지를 구문 분석하지 않아도되도록합니다. Perl 자체의 메시지는 표시하지 않으며 Perl이 종료 된 후 DCL에 의해 생성 된 메시지 만 표시합니다. DCL 기호 $ STATUS는 여전히 종료 상태이지만 상위 비트 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a73c08f06f0acf42846845d03633aa9b47905a33" translate="yes" xml:space="preserve">
          <source>This surprising autovivification in what does not at first--or even second--glance appear to be an lvalue context may be fixed in a future release.</source>
          <target state="translated">언뜻보기에 또는 심지어 두 번째로 보이지 않는 것에서 의이 놀라운 자생은 다음 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56b6634af06492105c8150cce8eec38c642722a" translate="yes" xml:space="preserve">
          <source>This switch causes Perl to dump core after compiling your program. You can then in theory take this core dump and turn it into an executable file by using the</source>
          <target state="translated">이 스위치는 프로그램을 컴파일 한 후 Perl이 코어를 덤프하도록합니다. 이론적 으로이 코어 덤프를 가져 와서 실행 파일로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdeac32803cbaac383dc34d3e5d5f188b61766f8" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">이 스위치는 실제로 글로벌 &lt;code&gt;$^W&lt;/code&gt; 변수 만 활성화합니다 . 일반적으로 어휘 범위 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma가 선호됩니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;functions/warn&quot;&gt;warn에&lt;/a&gt; 설명 된대로 &lt;code&gt;__WARN__&lt;/code&gt; 후크를 사용하여 치명적 오류 관련 경고를 사용하지 않도록 설정하거나 승격시킬 수 있습니다 . &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 및 &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; 도 참조하십시오 . 전체 클래스의 경고를 조작하려는 경우 세분화 된 경고 기능도 사용할 수 있습니다. &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eec8c1e53eca861ae72403ed034c71d15de36a4" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;use warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#warn&quot;&gt;&quot;warn&quot; in perlfunc&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">이 스위치는 실제로 전역 &lt;code&gt;$^W&lt;/code&gt; 변수를 활성화합니다 . 일반적으로 어휘 범위 &lt;code&gt;use warnings&lt;/code&gt; pragma가 선호됩니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;perlfunc#warn&quot;&gt;perlfunc의 &quot;warn&quot;에&lt;/a&gt; 설명 된대로 &lt;code&gt;__WARN__&lt;/code&gt; 후크를 사용하여 치명적인 오류 관련 경고를 비활성화하거나 승격 할 수 있습니다 . &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 및 &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; 도 참조하십시오 . 전체 경고 클래스를 조작하려는 경우 세분화 된 경고 기능도 사용할 수 있습니다. &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9aace5953cb75e0bd50c74f57a0b38f9c0103c2" translate="yes" xml:space="preserve">
          <source>This symbol conditionally defines the symbol &lt;code&gt;BSD&lt;/code&gt; when running on a &lt;code&gt;BSD&lt;/code&gt; system.</source>
          <target state="translated">이 기호 는 &lt;code&gt;BSD&lt;/code&gt; 시스템 에서 실행될 때 &lt;code&gt;BSD&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9dffb9b12a2139e8c4c666d76c2bbb94b410515d" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt; .</source>
          <target state="translated">이 기호에는 mmap ()에 의해 반환되는 포인터 유형과 동시에 첫 번째 인수 유형이 포함됩니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;caddr_t&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fb35656fbf4e4b9cf3733e209ae82b04049909" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt;.</source>
          <target state="translated">이 기호는 mmap ()에 의해 반환 된 포인터 유형과 동시에 첫 번째 인수 유형을 포함합니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;caddr_t&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e78cc593a5e3d5f9580ef534ee09e8fe0d641140" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt; .</source>
          <target state="translated">이 기호에는 shmat ()에서 반환 한 포인터 유형이 포함되어 있습니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;char *&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="784f8163b2c96f5e1ad2d33b1877166fe69ae941" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">이 기호는 shmat ()에 의해 반환 된 포인터 유형을 포함합니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;char *&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584f3ba36a4f3dda7bd8acb2eea24bb10daa748c" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n has the side effect of decreasing the value of File_cnt(fp) by n.</source>
          <target state="translated">이 기호는 &lt;code&gt;FILE_ptr&lt;/code&gt; 매크로를 lvalue로 사용하여 포인터를 n만큼 늘리면 File_cnt (fp)의 값이 n만큼 감소하는 부작용이있는 경우에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0683919acfce603ad7685e97943788fb4e37c119" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n leaves File_cnt(fp) unchanged.</source>
          <target state="translated">이 기호는 &lt;code&gt;FILE_ptr&lt;/code&gt; 매크로를 lvalue로 사용하여 포인터를 n만큼 늘리면 File_cnt (fp)가 변경되지 않은 경우에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93f9dcbec7fb63d67f75a0e1d4dc9ae41d2b59f2" translate="yes" xml:space="preserve">
          <source>This symbol is set to &lt;code&gt;struct direct&lt;/code&gt; or &lt;code&gt;struct dirent&lt;/code&gt; depending on whether dirent is available or not. You should use this pseudo type to portably declare your directory entries.</source>
          <target state="translated">이 기호는 dirent의 사용 가능 여부에 따라 &lt;code&gt;struct direct&lt;/code&gt; 또는 &lt;code&gt;struct dirent&lt;/code&gt; 를 구성하도록 설정됩니다 . 디렉토리 유형을 이식 가능하게 선언하려면이 의사 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac5221df55c0b6f88cbdccf1d492a80ec8b042ec" translate="yes" xml:space="preserve">
          <source>This symbol reflects the patchlevel, if available. Will usually come from the</source>
          <target state="translated">이 기호는 가능한 경우 패치 수준을 나타냅니다. 보통에서 올 것이다</target>
        </trans-unit>
        <trans-unit id="b709a76faa1011cf3f1c524bd59100484a2a8c2a" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports fpos64_t.</source>
          <target state="translated">C 컴파일러가 fpos64_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="343c9a95f0e1882d7b8de9c8d965312cb38ddb59" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports int64_t.</source>
          <target state="translated">이 기호는 C 컴파일러가 int64_t를 지원하는 경우 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9fabec6c07d2b2eb93287e97cce2db59d9d91ab9" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports off64_t.</source>
          <target state="translated">이 기호는 C 컴파일러가 off64_t를 지원하는 경우 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="425b3d025cac3f927d48be352caec0255a6ff1f6" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports ptrdiff_t.</source>
          <target state="translated">C 컴파일러가 ptrdiff_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8b08c311a150e9da2b658a2599a4ffb33ccacd56" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports socklen_t.</source>
          <target state="translated">C 컴파일러가 socklen_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="025aea88f0880f5a01a7cfa41a1296fe3bb5e473" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_good_size routine is available for use.</source>
          <target state="translated">이 기호는 정의 된 경우 malloc_good_size 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a656f9000aaa7b4a0b80166141d60895ed70146" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_size routine is available for use.</source>
          <target state="translated">이 기호는 정의 된 경우 malloc_size 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f16a25b173530b121560b8b39634ea26912b006" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system provides a prototype for the modfl() function. Otherwise, it is up to the program to supply one. C99 says it should be long double modfl(long double, long double *);</source>
          <target state="translated">이 기호는 정의 된 경우 시스템이 modfl () 함수의 프로토 타입을 제공함을 나타냅니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다. C99는 long double modfl (long double, long double *)이어야한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="46fd1ea7339001ddcefcaaf1e70c3783b77303d2" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system stores the variable argument list datatype, va_list, in a format that cannot be copied by simple assignment, so that some other means must be used when copying is required. As such systems vary in their provision (or non-provision) of copying mechanisms,</source>
          <target state="translated">이 기호가 정의 된 경우 시스템이 변수 인수 목록 데이터 유형 va_list를 단순 지정으로 복사 할 수없는 형식으로 저장하므로 복사가 필요한 경우 다른 수단을 사용해야 함을 나타냅니다. 이러한 시스템은 복사 메커니즘의 제공 (또는 비 제공)이 다양하므로</target>
        </trans-unit>
        <trans-unit id="33cfc6c8458868fdba1853ad63d6a5ab248c80dd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that we can use _NSGetExecutablePath and realpath to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">이 기호가 정의되어 있으면 _NSGetExecutablePath 및 realpath를 사용하여 실행 파일의 전체 경로를 얻을 수 있으므로 $ ^ X를 절대 경로로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c755fed5c388f41a69a9c083b151ea18f5a79b60" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates to the C program that it should include &amp;lt;xlocale.h&amp;gt; to get uselocale() and its friends</source>
          <target state="translated">정의 된 경우이 기호는 uselocale () 및 그 친구들을 얻기 위해 &amp;lt;xlocale.h&amp;gt;를 포함해야 함을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46cca9096a2b0dd91e445763521373111ae6cf7d" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells how many mantissa bits there are in double precision floating point format. Note that this is usually &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; minus one, since with the standard &lt;code&gt;IEEE&lt;/code&gt; 754 formats &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; includes the implicit bit which doesn't really exist.</source>
          <target state="translated">정의 된 경우이 기호는 배정 밀도 부동 소수점 형식에있는 가수 비트 수를 나타냅니다. 표준 &lt;code&gt;IEEE&lt;/code&gt; 754 형식에서 &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; 는 실제로 존재하지 않는 암시 적 비트를 포함 하므로 일반적으로 &lt;code&gt;DBL_MANT_DIG&lt;/code&gt; 에서 1을 뺀 값 입니다.</target>
        </trans-unit>
        <trans-unit id="60cda7b3100613ca1663cb55bf36b335f38c04e0" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells how many mantissa bits there are in long double precision floating point format. Note that this can be &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; minus one, since &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; can include the &lt;code&gt;IEEE&lt;/code&gt; 754 implicit bit. The common x86-style 80-bit long double does not have an implicit bit.</source>
          <target state="translated">정의 된 경우이 기호는 long double precision 부동 소수점 형식에있는 가수 비트 수를 나타냅니다. &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; 는 &lt;code&gt;IEEE&lt;/code&gt; 754 암시 적 비트를 포함 할 수 있으므로 &lt;code&gt;LDBL_MANT_DIG&lt;/code&gt; 에서 1을 뺀 값일 수 있습니다 . 일반적인 x86 스타일 80 비트 long double에는 암시 적 비트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e5579cd2141da02375bbc1afc9cdf3e216d16eb" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt; ) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt; ) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">이 기호는 정의 된 경우 fflush ( &lt;code&gt;NULL&lt;/code&gt; )가 부작용없이 보류중인 모든 stdio 출력을 올바르게 플러시 함을 나타냅니다. 특히, 일부 플랫폼에서 fflush ( &lt;code&gt;NULL&lt;/code&gt; ) * still *을 호출 하면 파이프 인 경우 &lt;code&gt;STDIN&lt;/code&gt; 이 손상 됩니다.</target>
        </trans-unit>
        <trans-unit id="864f27e3d5797754ededc663f882621f2b6e62f1" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt;) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt;) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">정의 된 경우이 기호는 fflush ( &lt;code&gt;NULL&lt;/code&gt; )가 부작용없이 모든 보류중인 stdio 출력을 올바르게 플러시 함을 나타냅니다. 특히 일부 플랫폼에서 fflush ( &lt;code&gt;NULL&lt;/code&gt; ) * still *을 호출 하면 파이프 인 경우 &lt;code&gt;STDIN&lt;/code&gt; 이 손상 됩니다.</target>
        </trans-unit>
        <trans-unit id="345492b736fde856a18832ea228dc15b7f57e1fd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that to flush all pending stdio output one must loop through all the stdio file handles stored in an array and fflush them. Note that if fflushNULL is defined, fflushall will not even be probed for and will be left undefined.</source>
          <target state="translated">이 기호가 정의되어 있으면 보류중인 모든 stdio 출력을 플러시하려면 배열에 저장된 모든 stdio 파일 핸들을 반복하여 플러시해야합니다. fflushNULL이 정의 된 경우 fflushall은 검사되지 않으며 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd9bfb79795353183cc954075073576d42a4a96" translate="yes" xml:space="preserve">
          <source>This syntax can be used with any class or object method:</source>
          <target state="translated">이 구문은 모든 클래스 또는 객체 메소드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361a88cbd3ef11a7c4b058ea6f65a1768cf1bf06" translate="yes" xml:space="preserve">
          <source>This syntax make the caret a special character inside a bracketed character class, but only if it is the first character of the class. So if you want the caret as one of the characters to match, either escape the caret or else don't list it first.</source>
          <target state="translated">이 구문은 캐럿을 대괄호로 묶은 문자 클래스 내부의 특수 문자로 만들지 만 클래스의 첫 번째 문자 인 경우에만 가능합니다. 따라서 캐럿을 문자 중 하나로 일치 시키려면 캐럿을 이스케이프하거나 먼저 나열하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cf8882c6e41ea0e436011545b6eac42846ae64e6" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::postderef'&lt;/code&gt; is in effect.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 활성화해야합니다 . 실험적이며 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::postderef'&lt;/code&gt; 적용 &lt;a href=&quot;functions/no&quot;&gt;되지&lt;/a&gt; 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="2448d5ee0ab20cace7d0d694356cb8b018b6fff7" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">이 구문은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 활성화해야합니다 . 실험적인 것이며 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::refaliasing'&lt;/code&gt; 적용 &lt;a href=&quot;functions/no&quot;&gt;되지&lt;/a&gt; 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="287e0462bd1d909a19c1388821cda96b1374549b" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;use feature 'refaliasing'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">이 구문은 &lt;code&gt;use feature 'refaliasing'&lt;/code&gt; 을 사용 하여 활성화해야합니다 . 실험적이며 &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; 적용 되지 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="17f3dce1b8ffb69288b5e7233eedf50e51bf6d28" translate="yes" xml:space="preserve">
          <source>This table should give some indication on the relative speed of different algorithms. It is sorted by throughput based on a benchmark done with of some implementations of this API:</source>
          <target state="translated">이 표는 다른 알고리즘의 상대 속도에 대한 정보를 제공해야합니다. 이 API의 일부 구현으로 수행 된 벤치 마크를 기반으로 처리량별로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="dd4da486347f5d466977ce9a1a1aa8289c5632b1" translate="yes" xml:space="preserve">
          <source>This table summarizes the mapping of the encodings set up by the &lt;code&gt;Encode::Locale&lt;/code&gt; module:</source>
          <target state="translated">이 표에는 &lt;code&gt;Encode::Locale&lt;/code&gt; 모듈 에서 설정 한 인코딩의 매핑이 요약되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61e7d00a447b322e0b6281e41be210174353561f" translate="yes" xml:space="preserve">
          <source>This tag holds groups of assorted specialist opcodes that don't warrant having optags defined for them.</source>
          <target state="translated">이 태그에는 정의 된 optag가 없음을 보증하지 않는 여러 분류 된 전문 opcode 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b596b3ecff7c84a2d9f652cda2f444e71a7c9fa" translate="yes" xml:space="preserve">
          <source>This tag holds opcodes related to loading modules and getting information about calling environment and args.</source>
          <target state="translated">이 태그에는 모듈로드 및 호출 환경 및 인수에 대한 정보 얻기와 관련된 opcode가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ae009bf5132dad193828814ac61d5405735292" translate="yes" xml:space="preserve">
          <source>This tag is simply a bucket for opcodes that are unlikely to be used via a tag name but need to be tagged for completeness and documentation.</source>
          <target state="translated">이 태그는 단순히 태그 이름을 통해 사용되지 않지만 완전성과 문서화를 위해 태그를 지정해야하는 opcode의 버킷입니다.</target>
        </trans-unit>
        <trans-unit id="2f05cedd800de4070129a2009cffd984beb3db08" translate="yes" xml:space="preserve">
          <source>This takes a list of operator names and returns the corresponding list of operator descriptions.</source>
          <target state="translated">연산자 이름 목록을 가져와 해당 연산자 설명 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c7d2a6226efbfa63a2425be94ed3ca13dcfd261" translate="yes" xml:space="preserve">
          <source>This takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored); and after each one, this function inserts super-ordinate forms that don't already appear in the list. The original list, plus these insertions, is returned.</source>
          <target state="translated">여기에는 문자열 목록이 필요합니다 (언어 태그 인 것으로 추정되고 그렇지 않은 문자열은 무시 됨). 그리고 각 함수 다음에이 함수는 목록에 아직 나타나지 않은 상위 ​​양식을 삽입합니다. 원본 목록과 이러한 삽입이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="13fd8ee50911015c2027466ceb16f127d689e9d2" translate="yes" xml:space="preserve">
          <source>This takes a locale name (like &quot;en&quot;, &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a language tag. If it's not mappable (as with, notably, &quot;C&quot; and &quot;POSIX&quot;), this returns empty-list in a list context, or undef in a scalar context.</source>
          <target state="translated">로캘 이름 (예 : &quot;en&quot;, &quot;en_US&quot;또는 &quot;en_US.ISO8859-1&quot;)을 사용하여 언어 태그에 매핑합니다. 매핑 할 수없는 경우 (특히 &quot;C&quot;및 &quot;POSIX&quot;와 같이) 목록 컨텍스트에서 빈 목록을 반환하거나 스칼라 컨텍스트에서 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bec8c5f2b922f1fda3abe6ef42f1ed85d0f41b3d" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of a .packlist. If the file exists, it will be opened and the contents of the file will be read. The new() method returns a reference to a hash. This hash holds an entry for each line in the .packlist. In the case of old-style .packlists, the value associated with each key is undef. In the case of new-style .packlists, the value associated with each key is a hash containing the key=value pairs following the filename in the .packlist.</source>
          <target state="translated">선택적 매개 변수 인 .packlist의 이름을 사용합니다. 파일이 존재하면 파일이 열리고 파일 내용을 읽습니다. new () 메소드는 해시에 대한 참조를 리턴합니다. 이 해시는 .packlist의 각 줄에 대한 항목을 보유합니다. 이전 스타일의 .packlists의 경우 각 키와 관련된 값은 undef입니다. 새로운 스타일의 .packlist의 경우 각 키와 관련된 값은 .packlist의 파일 이름 뒤에 key = value 쌍을 포함하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="cc773e12adc99441c781ca39ab744dcff4457a5a" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be read. If no file is specified, the .packlist specified to new() will be read. If the .packlist does not exist, Carp::croak will be called.</source>
          <target state="translated">선택적인 매개 변수 인 .packlist의 이름을 읽습니다. 파일을 지정하지 않으면 new ()로 지정된 .packlist를 읽습니다. .packlist가 없으면 Carp :: croak가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1bc9e2453dd25ae8b25a05301cb1b80e688d4f" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be written. If no file is specified, the .packlist specified to new() will be overwritten.</source>
          <target state="translated">이것은 선택적 매개 변수, 작성할 .packlist의 이름을 사용합니다. 파일을 지정하지 않으면 new ()로 지정된 .packlist를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="71c865c7274d3c7e5bfe698effd4f04214f7cd15" translate="yes" xml:space="preserve">
          <source>This takes name/value pairs that effect how the test is run.</source>
          <target state="translated">테스트 실행 방법에 영향을주는 이름 / 값 쌍이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc76b10f19749554379a021ff3eedaa58c818a23" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It checks that all the files listed in the modules .packlist actually exist, and returns a list of any missing files. If an optional second argument which evaluates to true is given any missing files will be removed from the .packlist</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 모듈 .packlist에 나열된 모든 파일이 실제로 존재하는지 확인하고 누락 된 파일 목록을 반환합니다. 선택적인 두 번째 인수가 true로 평가되면 누락 된 파일이 .packlist에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5b5d51a829067c0f74043220e1f7dc0a082fd9a1" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the directories from the package. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program directories, just manual directories or all directories. The remaining parameters are a list of directories. The directories returned will be restricted to those under the specified directories. This method returns only the leaf directories that contain files from the specified module.</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 패키지에서 모든 디렉토리 목록을 리턴합니다. 추가 매개 변수가 허용됩니다. 첫 번째는 &quot;prog&quot;, &quot;doc&quot;또는 &quot;all&quot;문자열 중 하나이며 프로그램 디렉토리, 수동 디렉토리 또는 모든 디렉토리 중 하나를 선택합니다. 나머지 매개 변수는 디렉토리 목록입니다. 리턴 된 디렉토리는 지정된 디렉토리 아래의 디렉토리로 제한됩니다. 이 메소드는 지정된 모듈의 파일을 포함하는 리프 디렉토리 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d2af5c7a635840c9a764106b51edcb4ae7965f15" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the filenames from the package. To obtain a list of core perl files, use the module name 'Perl'. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program files, just manual files or all files. The remaining parameters are a list of directories. The filenames returned will be restricted to those under the specified directories.</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 패키지의 모든 파일 이름 목록을 반환합니다. 코어 perl 파일 목록을 얻으려면 모듈 이름 'Perl'을 사용하십시오. 추가 매개 변수가 허용됩니다. 첫 번째는 문자열 &quot;prog&quot;, &quot;doc&quot;또는 &quot;all&quot;중 하나이며 프로그램 파일, 수동 파일 또는 모든 파일을 선택합니다. 나머지 매개 변수는 디렉토리 목록입니다. 반환 된 파일 이름은 지정된 디렉토리에있는 파일 이름으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c87f6895af9c38d5c250f2c66fe4725760f823f0" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt; . The packlists are read using the &lt;a href=&quot;packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">선택적 명명 된 매개 변수가 필요합니다. 매개 변수가 없으면 &lt;code&gt;%Config::Config&lt;/code&gt; 와 기본 모듈 검색 경로 &lt;code&gt;@INC&lt;/code&gt; 를 사용하여 시스템에 설치된 모든 .packlist를 검색합니다 . 팩리스트는 &lt;a href=&quot;packlist&quot;&gt;ExtUtils :: Packlist를&lt;/a&gt; 사용하여 읽습니다. 모듈을 .</target>
        </trans-unit>
        <trans-unit id="af5e8e4c803265793609442c474430cf073a9f84" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt;. The packlists are read using the &lt;a href=&quot;ExtUtils::Packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">이것은 선택적 명명 된 매개 변수를 사용합니다. 매개 변수가 없으면 &lt;code&gt;%Config::Config&lt;/code&gt; 및 기본 모듈 검색 경로 &lt;code&gt;@INC&lt;/code&gt; 의 정보를 사용하여 시스템에 설치된 모든 .packlists를 검색합니다 . Packlist는 &lt;a href=&quot;ExtUtils::Packlist&quot;&gt;ExtUtils :: Packlist&lt;/a&gt; 모듈을 사용하여 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ac00ded61272ff3715863e3d3dc5ed285ce52be5" translate="yes" xml:space="preserve">
          <source>This takes the hashref from &lt;code&gt;facet_data()&lt;/code&gt; and blesses each facet into the proper &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; subclass. If no class can be found for any given facet it will be passed along unchanged.</source>
          <target state="translated">이것은 &lt;code&gt;facet_data()&lt;/code&gt; 에서 해시 참조를 취하고 각 패싯을 적절한 &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; 하위 클래스 로 축복합니다 . 주어진 패싯에 대한 클래스를 찾을 수 없으면 변경되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0811a32d0bc5998774816ef12efb4252ce7381da" translate="yes" xml:space="preserve">
          <source>This talk of parameters and arbitrary complexity is just another way to say that an entry in a phrasebook is what in a programming language would be called a &quot;function&quot;. Just so you don't miss it, this is the crux of this article:</source>
          <target state="translated">매개 변수와 임의의 복잡성에 대한이 이야기는 표현 집의 항목이 프로그래밍 언어에서 &quot;함수&quot;라고 부르는 것을 말하는 또 다른 방법 일뿐입니다. 놓치지 않도록이 기사의 핵심은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a03ab8b368c68d278641fea23e27727f8dbba74" translate="yes" xml:space="preserve">
          <source>This target is stubbed out. Not sure why.</source>
          <target state="translated">이 목표는 스터브 아웃되었습니다. 이유가 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fab4c4b22d474c11e9a11868afc03c97140845f1" translate="yes" xml:space="preserve">
          <source>This technique is most useful when you have a project that uses a lot of third-party modules. You can define all your possible hints in one-place. This can even be in a sub-class of autodie. For example:</source>
          <target state="translated">이 기술은 많은 타사 모듈을 사용하는 프로젝트가있을 때 가장 유용합니다. 가능한 모든 힌트를 한 곳에서 정의 할 수 있습니다. 이것은 autodie의 하위 클래스에있을 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1ca50a85da91c16a0a908f36c57ff992ef7c02c" translate="yes" xml:space="preserve">
          <source>This technique of separation of the glue part from the workhorse part has obvious tradeoffs: if you want to change a Perl interface, you need to change two places in your code. However, it removes a lot of clutter, and makes the workhorse part independent from idiosyncrasies of Perl calling convention. (In fact, there is nothing Perl-specific in the above description, a different version of &lt;b&gt;xsubpp&lt;/b&gt; might have translated this to TCL glue or Python glue as well.)</source>
          <target state="translated">접착제 부분을 가공물 부분에서 분리하는이 기술은 명백한 절충점이 있습니다. Perl 인터페이스를 변경하려면 코드에서 두 위치를 변경해야합니다. 그러나, 그것은 많은 혼란을 제거하고, 작업 부분을 Perl 호출 규칙의 특유 성과 독립적으로 만듭니다. (실제로, 위의 설명에서 Perl에 특정한 것은 없으며, 다른 버전의 &lt;b&gt;xsubpp&lt;/b&gt; 가 이것을 TCL 접착제 또는 Python 접착제로 변환했을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="579494abf777c1edad219e4e3e72f24bade80f1c" translate="yes" xml:space="preserve">
          <source>This technique was popular for a while (and was recommended in Damian Conway's</source>
          <target state="translated">이 기술은 한동안 인기가 있었고 (Damian Conway 's에서 권장되었습니다)</target>
        </trans-unit>
        <trans-unit id="5e8f5ce6d67f7bf4b479db2dfff968206c152d0a" translate="yes" xml:space="preserve">
          <source>This tells the compiler to use integer operations from here to the end of the enclosing BLOCK. On many machines, this doesn't matter a great deal for most computations, but on those without floating point hardware, it can make a big difference in performance.</source>
          <target state="translated">이것은 컴파일러에게 여기에서 둘러싸는 BLOCK의 끝까지 정수 연산을 사용하도록 지시합니다. 많은 컴퓨터에서 이것은 대부분의 계산에서 큰 문제가되지 않지만 부동 소수점 하드웨어가없는 컴퓨터에서는 성능에 큰 차이를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661943b2ace4b2cbd0e7c782744a83d712cb4bd1" translate="yes" xml:space="preserve">
          <source>This tells the parser that you accept additional formatting codes, beyond just the standard ones (I B C L F S X, plus the two weird ones you don't actually see in the parse tree, Z and E). For example, to also accept codes &quot;N&quot;, &quot;R&quot;, and &quot;W&quot;:</source>
          <target state="translated">이는 표준 코드 (IBCLFSX와 구문 분석 트리에서 실제로 볼 수없는 두 가지 이상한 코드, Z 및 E) 외에 추가 형식화 코드를 허용한다는 것을 파서에 알려줍니다. 예를 들어 &quot;N&quot;, &quot;R&quot;및 &quot;W&quot;코드도 허용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5c227c573c801b67ab844d5a781ca2d861b5ad11" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">이 테스트 하네스는 &lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt; 와 동일 하지만 테스트 결과는 컬러로 출력됩니다. 합격 시험은 녹색으로 인쇄됩니다. 실패한 테스트는 빨간색입니다. 건너 뛴 테스트는 흰색 배경에서 파란색이고 TODO 테스트는 흰색으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5aeeba01de86baa7b8993aef4f94514bdbb7f537" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">이 테스트 하네스는 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt; 와 동일 하지만 테스트 결과는 컬러로 출력됩니다. 합격 한 테스트는 녹색으로 인쇄됩니다. 실패한 테스트는 빨간색으로 표시됩니다. 건너 뛴 테스트는 흰색 바탕에 파란색이고 TODO 테스트는 흰색으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="56c5da5399251bb5e1db8f624c5839bd6c16417b" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">이 테스트가 제대로 수행되지 않으면 bLuRfle.pm 모듈을 실제로 설치했거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 테스트를 수행하면 perl을 설치하면 잘못된 결과를 초래할 수 있습니다. 후자의 경우 저자에게 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="f1a47c3ed2c720af6cbbff7d8f1fba90981d6cf7" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;eval &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">이 테스트가 제대로 나오지 않으면 실제로 bLuRfle.pm 모듈을 설치했거나 &lt;code&gt;eval &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 테스트가 perl 설치에 잘못된 결과를 제공 할 수 있음을 나타낼 수 있습니다. 귀하의 것이 후자의 경우라면 저자에게 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d7779eb97d1704eb5b38f4af625c19d04da87929" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">이 세 번째 프로그램 은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 이 (가) 오염 되어 실행되지 않습니다 : &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 결과입니다 . 이 적용 .</target>
        </trans-unit>
        <trans-unit id="d68ad58afc351b6be0d95c3d8369561b57239182" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="translated">이 세 번째 프로그램 은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 가 오염 되었기 때문에 실행에 실패합니다 . 이것은 &lt;code&gt;use locale&lt;/code&gt; 이 적용 되는 동안 &lt;code&gt;\w&lt;/code&gt; 를 포함하는 일치의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="1dae3d33db186460fb270be827c017862ed6f4c9" translate="yes" xml:space="preserve">
          <source>This thread can change the locale all it wants and it won't affect any other thread, except any that also have been switched to the global locale. This means that a multi-threaded application can have a single thread using an alien library without a problem; but no more than a single thread can be so-occupied. Bad results likely will happen.</source>
          <target state="translated">이 스레드는 원하는 모든 로케일을 변경할 수 있으며 글로벌 로케일로 전환 된 스레드를 제외하고는 다른 스레드에 영향을주지 않습니다. 이것은 다중 스레드 응용 프로그램이 문제없이 외계인 라이브러리를 사용하는 단일 스레드를 가질 수 있음을 의미합니다. 그러나 하나의 스레드 만 그렇게 차지할 수 없습니다. 나쁜 결과가 발생할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3af2bc97cd9f37316fc3da9caf4914a2a7462bf" translate="yes" xml:space="preserve">
          <source>This threshold can be changed from 100, by recompiling the</source>
          <target state="translated">이 임계 값을 다시 컴파일하여 100에서 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43eef0f764abc7110894418223db6c40d531f70" translate="yes" xml:space="preserve">
          <source>This throws an exception at the frame (filename and line number where errors should be reported).</source>
          <target state="translated">프레임에서 예외가 발생합니다 (오류가보고되어야하는 파일 이름 및 줄 번호).</target>
        </trans-unit>
        <trans-unit id="2a47e3515c81e527144a0c9b60fab0d504885832" translate="yes" xml:space="preserve">
          <source>This tie class has chosen to return an error rather than raising an exception if its constructor should fail. While this is how dbmopen() works, other classes may well not wish to be so forgiving. It checks the global variable &lt;code&gt;$^W&lt;/code&gt; to see whether to emit a bit of noise anyway.</source>
          <target state="translated">이 타이 클래스는 생성자가 실패해야하는 경우 예외를 발생시키는 대신 오류를 반환하도록 선택했습니다. 이것이 dbmopen ()의 작동 방식이지만 다른 클래스는 그렇게 용서하고 싶지 않을 수 있습니다. 어쨌든 약간의 노이즈를 방출할지 여부를 확인하기 위해 전역 변수 &lt;code&gt;$^W&lt;/code&gt; 를 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="65215d2823f33c6578d2c1ee584a26f404ed972a" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used -- we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">이번에는 두 개의 필터 만 사용되었습니다. 키의 내용 만 조작하면되므로 값 필터를 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce475e5b88de267f8c35364dcce4ac0349ad1b9f" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used; we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">이번에는 두 개의 필터 만 사용되었습니다. 키의 내용 만 조작하면되므로 값 필터를 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33080a774d1683a847960294bf99870a610d6d24" translate="yes" xml:space="preserve">
          <source>This time we get the right answer:</source>
          <target state="translated">이번에는 정답을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="de132ff4c4de4a8dae8876bdea9d65e3845d2e34" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt; .</source>
          <target state="translated">이번에는 &lt;code&gt;Wall&lt;/code&gt; 키와 관련된 여러 값을 포함하여 모든 키 / 값 쌍을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="dc46887a2d3ce4b75ca14523b77c1875e5b5f923" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt;.</source>
          <target state="translated">이번에는 &lt;code&gt;Wall&lt;/code&gt; 키와 관련된 여러 값을 포함하여 모든 키 / 값 쌍을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="549daec07a3febc80783db85efb5cb76a1300cf5" translate="yes" xml:space="preserve">
          <source>This time we've decided to blow up (raise an exception) if the renice fails--there's no place for us to return an error otherwise, and it's probably the right thing to do.</source>
          <target state="translated">이번에 우리는 renice가 실패 할 경우 폭발 (예외 발생)하기로 결정했습니다. 그렇지 않으면 오류를 반환 할 수있는 곳이 없으며 아마도 옳은 일일 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8220bb1a44581d2e3ca1f66709b3d28e4dca5ce" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;CallSavedSub1&lt;/code&gt; 는 CallSavedSub1 이 호출 될 때마다 원래 &lt;code&gt;SaveSub1&lt;/code&gt; 호출에서 요청한 &lt;code&gt;fred&lt;/code&gt; 대신 Perl 서브 루틴 &lt;code&gt;joe&lt;/code&gt; (존재한다고 가정) 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="9585799a0bb025c0fc2a5fb468e2e0510621cfe4" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CallSavedSub1&lt;/code&gt; 는 CallSavedSub1 이 호출 될 때마다 SaveSub1 에 대한 호출에서 원래 요청 된대로 &lt;code&gt;fred&lt;/code&gt; 가 아니라 Perl 서브 루틴 &lt;code&gt;joe&lt;/code&gt; (존재한다고 가정) 를 &lt;code&gt;SaveSub1&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f97f664a05e05836532f171c31abc8294dc4fa2e" translate="yes" xml:space="preserve">
          <source>This timeout prevents CPAN from hanging when trying to parse a pathologically coded $VERSION from a module.</source>
          <target state="translated">이 시간 종료는 모듈에서 병적으로 코딩 된 $ VERSION을 구문 분석 할 때 CPAN이 정지되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="818cb77ceebe03d7349ba167c3cce5e948a3bb9b" translate="yes" xml:space="preserve">
          <source>This tip has been brought to you by Nick Ing-Simmons and Stas Bekman.</source>
          <target state="translated">이 팁은 Nick Ing-Simmons와 Stas Bekman이 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="d27a6342f3cf97c393debaf5d2880083dadfb79d" translate="yes" xml:space="preserve">
          <source>This toggle lets you turn off the abort logic for the hub. When this is toggled to true &lt;b&gt;you&lt;/b&gt; are responsible for ensuring no additional events are generated.</source>
          <target state="translated">이 토글을 사용하면 허브에 대한 중단 논리를 끌 수 있습니다. 이 true로 전환 될 때 &lt;b&gt;당신은&lt;/b&gt; 생성되는 추가 이벤트를 보장하지 않습니다에 대한 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad35df16ed4d238965d8000164af0c76d6be400" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">이 토큰은 아래에만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &quot;current_sub&quot;기능. &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35716269721e35aed3ed9931d09baf8957f4a7d8" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">이 토큰은 아래에만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &quot;current_sub&quot;기능. &lt;a href=&quot;../feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8782e676913565f7b95bd8b849e9d4513a4cab5" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;use v5.16&lt;/code&gt; or the &lt;a href=&quot;feature#The-%27current_sub%27-feature&quot;&gt;&lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; feature&lt;/a&gt;. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">이 토큰은 &lt;code&gt;use v5.16&lt;/code&gt; 또는 &lt;a href=&quot;feature#The-%27current_sub%27-feature&quot;&gt; &lt;code&gt;&quot;current_sub&quot;&lt;/code&gt; 기능&lt;/a&gt; 에서만 사용할 수 있습니다 . &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a442863544084141507fc6b9cc253372f4528af" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers for all subsequently listed signals. This is the default behavior.</source>
          <target state="translated">이 토큰은 &lt;b&gt;sigtrap&lt;/b&gt; 에게 이후에 나열된 모든 신호에 대한 핸들러를 설치하도록 지시 합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="563416938874462a6a3a7e213b018a4bbf3569b4" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers only for subsequently listed signals which aren't already trapped or ignored.</source>
          <target state="translated">이 토큰은 &lt;b&gt;sigtrap&lt;/b&gt; 에게 아직 트랩되거나 무시되지 않은 이후에 나열된 신호에 대해서만 핸들러를 설치하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="0c3e36d66e90a38e2c172eb5380aff092f3d8aff" translate="yes" xml:space="preserve">
          <source>This tool is most useful when you want to return the value you get from calling a function that needs to see the current context:</source>
          <target state="translated">이 도구는 현재 컨텍스트를 확인해야하는 함수를 호출하여 얻은 값을 반환하려는 경우 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dbef2365e83f0b66bb2b5afb7a58a64a398a46f8" translate="yes" xml:space="preserve">
          <source>This tool isn't appropriate for reporting bugs in any version prior to Perl 5.0.</source>
          <target state="translated">이 도구는 Perl 5.0 이전 버전의 버그를보고하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b1f48f2009eaba595386dfcdaf2125e0a97a308" translate="yes" xml:space="preserve">
          <source>This tool will hide a context for the provided block of code. This means any tools run inside the block will get a completely new context if they acquire one. The new context will be inherited by tools nested below the one that acquired it.</source>
          <target state="translated">이 도구는 제공된 코드 블록에 대한 컨텍스트를 숨 깁니다. 즉, 블록 내에서 실행되는 모든 도구가 하나를 획득하면 완전히 새로운 컨텍스트를 얻게됩니다. 새 컨텍스트는 획득 한 컨텍스트 아래에 중첩 된 도구에 의해 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="88cd36d63ba450353c54dc7196ff92a040ad99b2" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt; , which we have set to 20.</source>
          <target state="translated">등이를 번역 &quot;세트 &lt;code&gt;TARG&lt;/code&gt; 10는 포인터 푸시 &lt;code&gt;TARG&lt;/code&gt; 를 스택에, 세트 &lt;code&gt;TARG&lt;/code&gt; (20)는 포인터를 밀어 &lt;code&gt;TARG&lt;/code&gt; 스택으로&quot;. 작업이 끝나면 스택에는 값 10과 20이 포함되지 않지만 실제로는 &lt;code&gt;TARG&lt;/code&gt; 에 대한 두 개의 포인터가 포함되어 있습니다.이 포인터 는 20으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="b327555f1c252fbe229268edcab000a9e602b1a9" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt;, which we have set to 20.</source>
          <target state="translated">이것은 &quot; &lt;code&gt;TARG&lt;/code&gt; 를 10으로 설정 하고, &lt;code&gt;TARG&lt;/code&gt; 에 대한 포인터를 스택으로 밀고, &lt;code&gt;TARG&lt;/code&gt; 를 20으로 설정하고, TARG 에 대한 포인터를 스택 에 밀기 &quot; 로 &lt;code&gt;TARG&lt;/code&gt; 합니다. 연산이 끝나면 스택은 10과 20 값을 포함하지 않지만 실제로는 20으로 설정 한 &lt;code&gt;TARG&lt;/code&gt; 에 대한 두 개의 포인터를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="ba94eb90171beedcd9bec6456a8694f27844f356" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses SSL and can authenticate to the server via SASL.</source>
          <target state="translated">이 전송은 TCP를 통해 원격 SMTP 서버에 연결합니다. 선택적으로 SSL을 사용하고 SASL을 통해 서버를 인증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40f9d55c5ee498252f4f99087dcea386954252b" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses TLS or SSL and can authenticate to the server via SASL.</source>
          <target state="translated">이 전송은 TCP를 통해 원격 SMTP 서버에 연결합니다. 선택적으로 TLS 또는 SSL을 사용하고 SASL을 통해 서버에 인증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f84e699be8b82423bdf0c8efc71c8b6cffc002" translate="yes" xml:space="preserve">
          <source>This tree has 5 nodes (one per &lt;code&gt;TYPE&lt;/code&gt; specifier), only 3 of them are not optimized away (one per number in the left column). The immediate children of the given node correspond to &lt;code&gt;{}&lt;/code&gt; pairs on the same level of indentation, thus this listing corresponds to the tree:</source>
          <target state="translated">이 트리에는 5 개의 노드 ( &lt;code&gt;TYPE&lt;/code&gt; 지정 자당 하나 )가 있으며 그 중 3 개만 최적화되지 않습니다 (왼쪽 열의 숫자 당 하나). 주어진 노드의 직계 자식은 같은 들여 쓰기 수준의 &lt;code&gt;{}&lt;/code&gt; 쌍에 해당하므로이 목록은 트리에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="10bdb23da270b66c79801ca69744614d31056771" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; , and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">이렇게하면 제공하는 언어 태그 (예 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; 기반으로 클래스를로드하려고합니다. 및 첫 번째에 대한 합니다. 성공한 클래스는 YourProjClass :를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="babb439fd1f2025fd1dc37240e930742af072a8e" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt;, and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">클래스를 로딩이 시도는 당신이 좋아하는 (제공 언어 태그를 기준으로 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; , 그리고에 대한 첫 번째 성공하면 YourProjClass ::</target>
        </trans-unit>
        <trans-unit id="2350736fbbdb09c3e03af560458218f7c39a0887" translate="yes" xml:space="preserve">
          <source>This tries to get the title string out of $parser, by getting some tokens, and scanning them for the title, and then ungetting them so that you can process the token-stream from the beginning.</source>
          <target state="translated">이것은 토큰을 가져 와서 제목을 스캔 한 다음 토큰 스트림을 가져 와서 처음부터 토큰 스트림을 처리하여 $ parser에서 제목 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7a0a5100eb7d660c79e344156a06e5739ae3e99" translate="yes" xml:space="preserve">
          <source>This turns</source>
          <target state="translated">이것은 변합니다.</target>
        </trans-unit>
        <trans-unit id="2c43b29369b0643df2b475c636f7ba4a7760104c" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt; . Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">이 튜토리얼은 펄이 사용하도록 구성되어 있는지 만들기 프로그램이 호출한다고 가정 &lt;code&gt;make&lt;/code&gt; . 다음 예제에서 &quot;make&quot;를 실행하는 대신 Perl이 사용하도록 구성된 make 프로그램을 대체해야 할 수도 있습니다. &lt;b&gt;perl -V : make를&lt;/b&gt; 실행 하면 그것이 무엇인지 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="99b5d150876f05176f523c02a4521b0203e2d731" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt;. Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">이 튜토리얼은 펄이 사용하도록 구성되어 있는지 만들기 프로그램이 호출한다고 가정 &lt;code&gt;make&lt;/code&gt; . 다음 예제에서 &quot;make&quot;를 실행하는 대신 Perl이 사용하도록 구성된 make 프로그램을 대체해야 할 수 있습니다. &lt;b&gt;perl -V : make를&lt;/b&gt; 실행 하면 그것이 무엇인지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8c02c1e1c4554cfc38ab4519576c46376d729f42" translate="yes" xml:space="preserve">
          <source>This tutorial can still be used on such a system. The XSUB build mechanism will check the system and build a dynamically-loadable library if possible, or else a static library and then, optionally, a new statically-linked executable with that static library linked in.</source>
          <target state="translated">이 튜토리얼은 여전히 ​​그러한 시스템에서 사용될 수 있습니다. XSUB 빌드 메커니즘은 시스템을 확인하고 가능하면 동적으로로드 가능한 라이브러리 또는 정적 라이브러리를 빌드 한 다음 선택적으로 해당 정적 라이브러리가 링크 된 새 정적 링크 실행 파일을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="042a6a29ffea342487866bd18b2ff67e8550a4e6" translate="yes" xml:space="preserve">
          <source>This tutorial describes the use of Perl interpreter threads (sometimes referred to as</source>
          <target state="translated">이 학습서에서는 Perl 인터프리터 스레드 (때로는</target>
        </trans-unit>
        <trans-unit id="584c62ddbbc858e85333edcc1d7b6494d833b45b" translate="yes" xml:space="preserve">
          <source>This tutorial flattens the learning curve by discussing regular expression concepts, along with their notation, one at a time and with many examples. The first part of the tutorial will progress from the simplest word searches to the basic regular expression concepts. If you master the first part, you will have all the tools needed to solve about 98% of your needs. The second part of the tutorial is for those comfortable with the basics and hungry for more power tools. It discusses the more advanced regular expression operators and introduces the latest cutting-edge innovations.</source>
          <target state="translated">이 튜토리얼은 정규 표현 개념과 표기법, 한 번에 하나씩 그리고 많은 예제를 논의함으로써 학습 곡선을 평평하게합니다. 학습서의 첫 번째 부분은 가장 간단한 단어 검색에서 기본 정규 표현식 개념으로 진행됩니다. 첫 번째 부분을 마스터하면 약 98 %의 요구를 해결하는 데 필요한 모든 도구가 제공됩니다. 튜토리얼의 두 번째 부분은 기본 사항에 익숙하고 더 많은 전동 공구를 원하는 사람들을위한 것입니다. 보다 고급 정규 표현식 연산자에 대해 설명하고 최신 최첨단 혁신을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="09418d1e9dc1ccd649181b2ae1d0e9cc30227030" translate="yes" xml:space="preserve">
          <source>This tutorial speaks in rather absolute terms, and provides only a limited view of the wealth of character string related features that Perl has to offer. For most projects, this information will probably suffice.</source>
          <target state="translated">이 튜토리얼은 절대적인 용어로 설명하고 Perl이 제공해야하는 다양한 문자열 관련 기능에 대한 제한된보기 만 제공합니다. 대부분의 프로젝트에서이 정보로 충분할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a1babab3f5740242709a97dfef0170b83cfd116" translate="yes" xml:space="preserve">
          <source>This tutorial starts with very simple examples and becomes more complex, with each new example adding new features. Certain concepts may not be completely explained until later in the tutorial in order to slowly ease the reader into building extensions.</source>
          <target state="translated">이 튜토리얼은 매우 간단한 예제로 시작하여 새로운 예제를 추가 할 때마다 새로운 기능을 추가함으로써 더욱 복잡해집니다. 독자가 건물 확장을 천천히 편하게하기 위해 튜토리얼 후반까지 특정 개념을 완전히 설명하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513743e90a808d724cf722e256c18c6a577aed36" translate="yes" xml:space="preserve">
          <source>This tutorial was written from a Unix point of view. Where I know them to be otherwise different for other platforms (e.g. Win32), I will list them. If you find something that was missed, please let me know.</source>
          <target state="translated">이 튜토리얼은 유닉스 관점에서 작성되었습니다. 다른 플랫폼 (예 : Win32)과 다른 점을 알고있는 경우 이들을 나열합니다. 놓친 부분이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="2d3bc7e20dd6d03170372006d4bcd471be2b1a05" translate="yes" xml:space="preserve">
          <source>This tutorial will educate the reader on the steps involved in creating a Perl extension. The reader is assumed to have access to &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">이 학습서에서는 Perl 확장 작성과 관련된 단계에 대해 독자에게 교육합니다. 독자는 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; , &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 및 &lt;a href=&quot;perlxs&quot;&gt;perlxs에&lt;/a&gt; 액세스 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="73d6133ba18859a5eaedd64f01ef459aa33a4f61" translate="yes" xml:space="preserve">
          <source>This ucfirst form of #var generates a tag-value form of itself for display; it converts '#Var' into a 'Var =&amp;gt; #var' style, which is then handled as described above. (Imp-note: #Vars cannot be used for conditional-fills, because the =&amp;gt; #var transform is done after the check for #Var's value).</source>
          <target state="translated">이 ucfirst 형식의 #var은 표시 할 자체의 태그-값 형식을 생성합니다. '#Var'을 'Var =&amp;gt; #var'스타일로 변환 한 다음 위에서 설명한대로 처리합니다. 참고 : #Var의 값을 확인한 후 =&amp;gt; #var 변환이 수행되므로 조건부 채우기에는 #Vars를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1c48ccdb02bacfa9c7db277adb42c2586c3c859" translate="yes" xml:space="preserve">
          <source>This unloading is usually necessary when embedding a shared-object perl (e.g. one configured with -Duseshrplib) within a larger application, and the perl interpreter is created and destroyed several times within the lifetime of the application. In this case it is possible that the system dynamic linker will unload and then subsequently reload the shared libperl without relocating any references to it from any files DynaLoaded by the previous incarnation of the interpreter. As a result, any shared objects opened by DynaLoader may point to a now invalid 'ghost' of the libperl shared object, causing apparently random memory corruption and crashes. This behaviour is most commonly seen when using Apache and mod_perl built with the APXS mechanism.</source>
          <target state="translated">이 언로드는 일반적으로 더 큰 응용 프로그램 내에 공유 오브젝트 perl (예 : -Duseshrplib로 구성된 것)을 임베드 할 때 필요하며 perl 인터프리터는 응용 프로그램의 수명 내에 여러 번 작성되어 파괴됩니다. 이 경우, 시스템 동적 링커는 인터프리터의 이전 구현에 의해 DynaLoaded 파일에서 참조를 재배치하지 않고 공유 libperl을 언로드 한 다음 다시로드 할 수 있습니다. 결과적으로, DynaLoader에 의해 열린 공유 객체는 libperl 공유 객체의 현재 유효하지 않은 '고스트'를 가리켜 서 임의의 메모리 손상 및 충돌을 일으킬 수 있습니다. 이 동작은 APXS 메커니즘으로 빌드 된 Apache 및 mod_perl을 사용할 때 가장 일반적으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1b13f3deb5370e5675a9d76c565d42ae5d602f71" translate="yes" xml:space="preserve">
          <source>This usage is deprecated, because the behavior is likely to change in a future version of Perl.</source>
          <target state="translated">향후 버전의 Perl에서는 동작이 변경 될 수 있으므로이 사용법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8cc0202ec780bce218b4e5dcccd13c92cdafc61" translate="yes" xml:space="preserve">
          <source>This usage was deprecated and as of Perl 5.32 is no longer allowed.</source>
          <target state="translated">이 사용은 더 이상 사용되지 않으며 Perl 5.32부터는 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8628227b2034eb7bb5d1a38319f1096e92570eb" translate="yes" xml:space="preserve">
          <source>This usage was deprecated, and as of Perl 5.32 is no longer allowed, making it possible to change the behavior in the future.</source>
          <target state="translated">이 사용은 더 이상 사용되지 않으며 Perl 5.32부터는 더 이상 허용되지 않으므로 향후 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2bf7571677624aefcaac6c0acb5fa38635561cd" translate="yes" xml:space="preserve">
          <source>This use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated since Perl 5.10, and it will become a fatal error in Perl 5.30.</source>
          <target state="translated">이 사용 &lt;code&gt;my()&lt;/code&gt; 거짓 조건에서이 펄 5.10 이후 사용되지 않습니다, 그것은 펄 5.30에 치명적인 오류가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbb7ee3adb793d7785e44f4cd1c475bc562072ff" translate="yes" xml:space="preserve">
          <source>This use of &lt;code&gt;my()&lt;/code&gt; in a false conditional was deprecated beginning in Perl 5.10 and became a fatal error in Perl 5.30.</source>
          <target state="translated">이 사용 &lt;code&gt;my()&lt;/code&gt; 거짓 조건에 펄 5.10에서 시작하여 사용되지 않습니다 펄 5.30에 치명적인 오류가되었다.</target>
        </trans-unit>
        <trans-unit id="0fa749e21deac96525cb24d3358da4f7fb5f0d24" translate="yes" xml:space="preserve">
          <source>This use of my() in false conditional is no longer allowed</source>
          <target state="translated">false 조건부에서 my () 사용은 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8b6fb62901deb9e84ba258e77b4c4979b396131" translate="yes" xml:space="preserve">
          <source>This used to provide support for the old 5.005 threading module. It now does nothing.</source>
          <target state="translated">이전 5.005 스레딩 모듈을 지원하는 데 사용되었습니다. 이제는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad74ce7c330e222ac3a23c23df9097ca9cc782c1" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;[...]&lt;/code&gt; 표기법을 사용하여 새로운 익명 배열을 만들고 &lt;code&gt;$aref2&lt;/code&gt; 에 새로운 배열에 대한 참조가 할당됩니다. 새 배열은 &lt;code&gt;$aref1&lt;/code&gt; 참조하는 배열의 내용으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f780e61f5be8b67d8a73b7a70cd2de66ca725d92" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;[...]&lt;/code&gt; 표기법을 사용하여 새로운 익명 배열을 만들고 &lt;code&gt;$aref2&lt;/code&gt; 에 새 배열에 대한 참조가 할당됩니다. 새 배열은 &lt;code&gt;$aref1&lt;/code&gt; 참조하는 배열의 내용으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ec25d0bdb752659175b1040a999aeb2b6d490b8" translate="yes" xml:space="preserve">
          <source>This uses a comment character so that we can distinguish a &lt;code&gt;set&lt;/code&gt; value (from a previous</source>
          <target state="translated">주석 문자를 사용하여 &lt;code&gt;set&lt;/code&gt; 값을 이전 과 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1cad67a921e3eb4640eba7ead1b7740937eea5" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ef0715f911bf2d7dde414c04ee4f2d77679374e6" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb8309f8b6f133836961834b1a77c15524062381" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;LIB$FID_TO_NAME&lt;/code&gt; run-time library call to find the name of the primary link to a file, and returns the filename in VMS format. This function is not available on non-VMS systems.</source>
          <target state="translated">이것은 사용 &lt;code&gt;LIB$FID_TO_NAME&lt;/code&gt; VMS 형식의 파일 이름을 파일로 기본 링크의 이름을 찾기 위해 런타임 라이브러리 호출을하고 돌아갑니다. 이 기능은 비 VMS 시스템에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c7665ba2d9d5783e7fcf462d2624ff87c082afc" translate="yes" xml:space="preserve">
          <source>This uses the git protocol (port 9418).</source>
          <target state="translated">이것은 git 프로토콜 (포트 9418)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f46aaaf1565e8957012263096fadaa9a048c4d5" translate="yes" xml:space="preserve">
          <source>This utility allows you to apply pattern matching to &lt;b&gt;the contents&lt;/b&gt; of files contained in a tar archive. You might use this to identify all files in an archive which contain lines matching the specified pattern and either print out the pathnames or extract the files.</source>
          <target state="translated">이 유틸리티를 사용하면 tar 아카이브에 포함 된 파일 &lt;b&gt;의 내용&lt;/b&gt; 에 패턴 일치를 적용 할 수 있습니다 . 이를 사용하여 지정된 패턴과 일치하는 행을 포함하는 아카이브의 모든 파일을 식별하고 경로 이름을 인쇄하거나 파일을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9ad1aba7c9a639b483b1f8f929290363dd11bd" translate="yes" xml:space="preserve">
          <source>This utility is designed to write a Makefile for an extension module from a Makefile.PL. It is based on the Makefile.SH model provided by Andy Dougherty and the perl5-porters.</source>
          <target state="translated">이 유틸리티는 Makefile.PL에서 확장 모듈의 Makefile을 작성하도록 설계되었습니다. Andy Dougherty와 perl5-porter가 제공 한 Makefile.SH 모델을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="b24b7df29646f7c014772e5059f3068df5bbacbd" translate="yes" xml:space="preserve">
          <source>This utility takes a list of libraries in the form &lt;code&gt;-llib1 -llib2
-llib3&lt;/code&gt; and returns lines suitable for inclusion in an extension Makefile. Extra library paths may be included with the form &lt;code&gt;-L/another/path&lt;/code&gt; this will affect the searches for all subsequent libraries.</source>
          <target state="translated">이 유틸리티는 &lt;code&gt;-llib1 -llib2 -llib3&lt;/code&gt; 형식의 라이브러리 목록을 사용 하여 확장자 Makefile에 포함하기에 적합한 행을 리턴합니다. 추가 라이브러리 경로는 &lt;code&gt;-L/another/path&lt;/code&gt; 형식으로 포함될 수 있으며 이는 이후의 모든 라이브러리 검색에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b766c16803f46a0ae895c110a4b6edf915519f91" translate="yes" xml:space="preserve">
          <source>This utility will read *.pl files (given as parameters) and write corresponding *.pm files. The pl2pm utilities does the following:</source>
          <target state="translated">이 유틸리티는 * .pl 파일 (매개 변수로 제공)을 읽고 해당 * .pm 파일을 작성합니다. pl2pm 유틸리티는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a410c695becbafd5bc2593139ba56b80c63242e8" translate="yes" xml:space="preserve">
          <source>This utility, that comes with the &lt;code&gt;Digest::SHA&lt;/code&gt; module, is used to print or verify SHA checksums.</source>
          <target state="translated">&lt;code&gt;Digest::SHA&lt;/code&gt; 모듈 과 함께 제공되는이 유틸리티 는 SHA 체크섬을 인쇄하거나 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f272981cac4ae61e9e9e8d75fb4dc12762de509" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when &lt;code&gt;safe_level&lt;/code&gt; is set to MEDIUM or higher.</source>
          <target state="translated">필요한 경우이 값을 조정하여 보안 검사를 줄일 수 있습니다. 이 값은 &lt;code&gt;safe_level&lt;/code&gt; 이 MEDIUM 이상으로 설정된 경우에만 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa4ff7242b8a2fd67b36df12914e2cc6d1af606d" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when C</source>
          <target state="translated">필요한 경우 보안 검사를 줄이기 위해이 값을 조정할 수 있습니다. 이 값은 C</target>
        </trans-unit>
        <trans-unit id="cdc136e48e274a6f45986365041835b0a320611a" translate="yes" xml:space="preserve">
          <source>This value may be set when embedding for full cleanup.</source>
          <target state="translated">이 값은 전체 정리를 위해 포함 할 때 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7591c615f6c14e41979e1eaadb2f09a869a865a0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; . Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">이 값은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용하도록&lt;/a&gt; 주어진 &lt;code&gt;stack_size&lt;/code&gt; 매개 변수를 대체합니다 . 주요 목적은 레거시 스레드 응용 프로그램의 스레드 별 스택 크기를 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8d10aaff4c3d6cbb1dc6581ac92ed77de4530c0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;use threads&lt;/code&gt;. Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">이 값은 &lt;code&gt;use threads&lt;/code&gt; 를 사용 하기 위해 제공된 모든 &lt;code&gt;stack_size&lt;/code&gt; 매개 변수를 대체합니다 . 주요 목적은 레거시 스레드 응용 프로그램에 대한 스레드 별 스택 크기 설정을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f89d32d5d5695a0582f22913b8f68fcff2f07a33" translate="yes" xml:space="preserve">
          <source>This variable (and the corresponding &lt;code&gt;array_base&lt;/code&gt; feature and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module) allowed changing the base for array and string indexing operations.</source>
          <target state="translated">이 변수 (및 해당하는 &lt;code&gt;array_base&lt;/code&gt; 기능 및 &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; 모듈)를 사용하면 배열 및 문자열 인덱싱 작업의 기준을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ecf008113019e40a6e54f73ff5a98b48282c9e" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt; -like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt; -like id prepended, some not.)</source>
          <target state="translated">이 변수 (기본값은 1)는 $ ^ E의 내용을 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 id 로 시작할지 여부를 제어합니다 . 0으로 설정되면 문자열 값 $ ^ E는 OS / 2 메시지 파일에서 사용 가능한 값입니다. (이 파일의 일부 메시지는 앞에 추가 된 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 ID를 갖습니다 .)</target>
        </trans-unit>
        <trans-unit id="0e88ea105d4b7ad833e8f62738de77591c442f12" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt;-like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt;-like id prepended, some not.)</source>
          <target state="translated">이 변수 (기본값은 1)는 $ ^ E의 내용이 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 id 로 시작하도록 강제할지 여부를 제어합니다 . 0으로 설정하면 $ ^ E의 문자열 값이 OS / 2 메시지 파일에서 사용 가능합니다. (이 파일의 일부 메시지에는 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 ID가 추가되어 있지만 일부는 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="16732492f2d070676c6f99bbc0efae47b95f7071" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt; ) instead, but that is only supported by some devices.</source>
          <target state="translated">이 변수는 open () 또는 fcntl () 중에 파일 디스크립터에 대한 비 블로킹 I / O를 설정하는 데 사용되는 기호 값을 갖습니다. 차단과 비 차단간에 전환하려면 대신 ioctl ( &lt;code&gt;FIOSNBIO&lt;/code&gt; )을 시도 할 수 있지만 일부 장치에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="15ff3c0604e1d75a5342996d8934873f8d50aeb1" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt;) instead, but that is only supported by some devices.</source>
          <target state="translated">이 변수는 open () 또는 fcntl () 동안 파일 설명자에 대한 비 블로킹 I / O를 켜는 동안 사용할 기호 값을 포함합니다. 차단과 비 차단 사이를 전환하려면 대신 ioctl ( &lt;code&gt;FIOSNBIO&lt;/code&gt; )을 시도해 볼 수 있지만 이는 일부 장치에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cca2eeea3350d961dcaad04aa855c2a1f247bac2" translate="yes" xml:space="preserve">
          <source>This variable bears the symbolic errno code set by read() when no data is present on the file and non-blocking I/O was enabled (otherwise, read() blocks naturally).</source>
          <target state="translated">이 변수는 파일에 데이터가없고 비 차단 I / O가 활성화 된 경우 (그렇지 않으면 자연스럽게 read () 블록) read ()로 설정된 기호 errno 코드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="248382abe33b16964803e73f6ecfb34faabcc93f" translate="yes" xml:space="preserve">
          <source>This variable can be used to determine whether the Perl interpreter executing a script is in the right range of versions:</source>
          <target state="translated">이 변수는 스크립트를 실행하는 Perl 인터프리터가 올바른 버전의 버전인지 여부를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfea1020f3dea68d67242c313286038f4a0d0e35" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt; , a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt; , the test program will be run as well as being compiled.</source>
          <target state="translated">nm가 심볼을 찾지 못하는 경우에이 변수를 사용하여 폴 스루를 설정할 수 있습니다. usenm가 false이거나 usenm가 true이고 mistrustnm이 false 인 경우이 변수는 영향을 미치지 않습니다. usenm이 true이고 mistrustnm이 &lt;code&gt;compile&lt;/code&gt; 인 경우 nm 검색을 통해 찾을 수없는 기호를 찾기 위해 테스트 프로그램이 컴파일됩니다. mistrustnm이 &lt;code&gt;run&lt;/code&gt; 되면 테스트 프로그램이 실행되고 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3e9ceee71cdc320b5939b5ceda3cad1b31e64c" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt;, a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt;, the test program will be run as well as being compiled.</source>
          <target state="translated">이 변수는 nm가 기호를 찾지 못하는 경우에 대한 폴 스루를 설정하는 데 사용할 수 있습니다. usenm가 false이거나 usenm가 true이고 mistrustnm이 false이면이 변수는 효과가 없습니다. usenm가 true이고 mistrustnm이 &lt;code&gt;compile&lt;/code&gt; 이면 nm 조회를 통해 찾을 수없는 기호를 찾기 위해 테스트 프로그램이 컴파일됩니다. mistrustnm이 &lt;code&gt;run&lt;/code&gt; 되면 테스트 프로그램이 실행되고 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0fbadd8567e78cf31399e6a2260ad4aafcd61e" translate="yes" xml:space="preserve">
          <source>This variable combines api_revision, api_version, and api_subversion in a format such as 5.6.1 (or 5_6_1) suitable for use as a directory name. This is filesystem dependent.</source>
          <target state="translated">이 변수는 api_revision, api_version 및 api_subversion을 디렉토리 이름으로 사용하기에 적합한 5.6.1 (또는 5_6_1) 형식으로 결합합니다. 이것은 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3a2c3f8de756634885e7def1800fcfd4dd0d57a3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 를 정의 했습니다 .</target>
        </trans-unit>
        <trans-unit id="a0b791466461b0141a9f42bfce168d808b632ccd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt;.</source>
          <target state="translated">이 변수는 조건부로 정의 된 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="efd929c3d0bcbeeec8636fa669401d4e86c870d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;ARCHLIB&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $archlib is the same as $privlib, then this is set to undef.</source>
          <target state="translated">이 변수는 $ package에 대한 아키텍처 종속 라이브러리 파일의 경로 이름을 보유하도록 &lt;code&gt;ARCHLIB&lt;/code&gt; 를 조건부로 정의 합니다. $ archlib가 $ privlib와 같으면 undef로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef97d2a231904adfc4265eba4006701690eed6ca" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CAN_VAPROTO&lt;/code&gt; on systems supporting prototype declaration of functions with a variable number of arguments. See also prototype.</source>
          <target state="translated">이 변수 는 가변 개수의 인수로 함수의 프로토 타입 선언을 지원하는 시스템에서 조건 적으로 &lt;code&gt;CAN_VAPROTO&lt;/code&gt; 를 정의합니다 . 프로토 타입도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="980485e36e7b05790618d387e3c7b5f9dffdd4ab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt; , which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;CASTNEG&lt;/code&gt; 를 정의 하는데 , 이는 C 컴파일러가 음수 부동 소수점을 부호없는 것으로 캐스트 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e6c288a30b9263a34f361a5d921f5d74655c9671" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt;, which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">이 변수 는 C 컴파일러가 음의 부동 소수점을 부호없는 것으로 캐스트 할 수 있는지 여부를 나타내는 &lt;code&gt;CASTNEG&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6a2c21b1fb400d236c7f8b93084483db1894c446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CHARVSPRINTF&lt;/code&gt; if this system has vsprintf returning type (char*). The trend seems to be to declare it as &quot;int vsprintf()&quot;.</source>
          <target state="translated">이 시스템에 vsprintf 리턴 유형 (char *)이있는 &lt;code&gt;CHARVSPRINTF&lt;/code&gt; 변수는 조건부로 CHARVSPRINTF를 정의합니다 . 트렌드는 이것을 &quot;int vsprintf ()&quot;로 선언하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5078955ce08b58cadcdb20d3c38df82d26ee60ff" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CTERMID&lt;/code&gt; if ctermid() is available to generate filename for terminal.</source>
          <target state="translated">이 변수는 ctermid ()를 사용하여 터미널의 파일 이름을 생성 할 수있는 경우 조건 적으로 &lt;code&gt;CTERMID&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="978df228f8d800c08979baf4f0b9bb0fc46ebfa9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt; , which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">이 변수는 &lt;code&gt;DIRNAMLEN&lt;/code&gt; 을 조건부로 정의 하며 , 이는 디렉토리 항목 이름의 길이가 d_namelen 필드에 의해 제공됨을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dc998e2c8c6e574860ee6fbf06818e7c667f7aa2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt;, which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;DIRNAMLEN&lt;/code&gt; 을 정의 하는데 , 이는 디렉토리 항목 이름의 길이가 d_namelen 필드에 의해 제공됨을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="df3c72fff3ec53eb910b33c4d8de7ba859b22249" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; , which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; 를 정의합니다 . 이는 dlsym ()을 호출하기 전에 기호 이름 앞에 밑줄을 추가해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8582344f9c7c22d7833d9ec106477884283a6de7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt;, which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; 를 정의합니다 . 이는 dlsym ()을 호출하기 전에 심볼 이름 앞에 밑줄을 추가해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49b013eda5d273dde0c71244769fe3ad52ab910f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EBCDIC&lt;/code&gt; if this system uses &lt;code&gt;EBCDIC&lt;/code&gt; encoding.</source>
          <target state="translated">이 시스템이 &lt;code&gt;EBCDIC&lt;/code&gt; 인코딩을 사용하는 경우이 변수는 조건부로 &lt;code&gt;EBCDIC&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="95f5847b07ee6a0574affcb0afba6691ba0cb5dc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; if &lt;code&gt;EOF&lt;/code&gt; can be seen when reading from a non-blocking I/O source.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; 을 경우 &lt;code&gt;EOF&lt;/code&gt; 가 비 블로킹 I / O 소스에서 읽을 때 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af8dac12168ddb05c87d99076fc3d364dbfc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt; , which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;GRPASSWD&lt;/code&gt; 를 정의합니다 . 이는 &amp;lt;grp.h&amp;gt;의 구조체 그룹에 gr_passwd가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cca67ae13cb5b5216b026f087e4c9cd2724e9abd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt;, which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">이 변수 는 &amp;lt;grp.h&amp;gt;의 구조체 그룹에 gr_passwd가 포함되어 있음을 나타내는 &lt;code&gt;GRPASSWD&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e239460b32f067f0e57a573c2a38cc269c4e8cf6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; , which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; 를 정의합니다 . 이는 &lt;code&gt;GCC&lt;/code&gt; 가 더 이상 사용되지 않는 API를 표시하기위한 속성을 처리 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a3ce902111f1fb6ddfbb032a62404920f5f0a69" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt;, which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">이 변수는 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; 를 조건부로 정의합니다 . 이는 &lt;code&gt;GCC&lt;/code&gt; 가 더 이상 사용되지 않는 API를 표시하기위한 속성을 처리 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="096a4e7335c9e97171f7b50c60f3c4f1d139650c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; , which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 printf와 같은 형식을 확인할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f0f60c4dd5eeeaebaa985d1b6354c9a991633b8e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt;, which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">이 변수 는 C 컴파일러가 printf와 유사한 형식을 확인할 수 있음을 나타내는 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc32aff59b98aa4940aa65546e2ce2f0bae5f6b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; , which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 malloc와 유사한 의미를 갖는 것으로 함수를 이해할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bf5374f94e92fd1cc3e01675dd69dfccafafe1cf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt;, which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 malloc과 유사한 의미를 갖는 것으로 함수를 이해할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc77040e22d8dbd38fd3bdef2b4c807ff2648d0f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; , which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt; , and will check accordingly at compile time.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 인수가 &lt;code&gt;NULL&lt;/code&gt; 이 아니어야한다는 것을 알 수 있으며 컴파일시 적절하게 검사합니다.</target>
        </trans-unit>
        <trans-unit id="0d008cebd99a9203bb4aed19e68f0fe934a519a6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt;, which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt;, and will check accordingly at compile time.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 인수가 &lt;code&gt;NULL&lt;/code&gt; 이 아니어야한다는 것을 알 수 있고 컴파일 타임에 그에 따라 검사 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c1ca1b192eaeeef39ff342721f49f9732f5c25b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; , which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 함수가 절대 리턴하지 않을 것임을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db7d6ff22150607f2faf6e212132ffd7e2e815da" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt;, which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 함수가 절대로 반환되지 않는다는 것을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35f0cde07593cb535b92fefc63eb7d81d46fe8bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; , which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 함수가 &lt;code&gt;pure&lt;/code&gt; 함수임을 알 수 있으며, 이는 부작용이 없으며 함수 입력에만 의존 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="17b724553d5b8a923ac88e7dad14f63c4b3879af" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt;, which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">이 변수는 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; 를 조건부로 정의합니다 . 이는 C 컴파일러가 특정 함수가 &lt;code&gt;pure&lt;/code&gt; 함수라는 것을 알 수 있다는 것을 나타냅니다. 즉, 부작용이없고 함수 입력에만 의존 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="420fa8e106aa6be346627e32f034151a52362ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; , which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 변수 및 인수가 항상 사용되지 않을 수 있음을 알 수 있으며 사용되지 않을 경우 경고를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd8f83fc842425448043adda2ad084876969855e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt;, which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 변수와 인수가 항상 사용되는 것은 아니라는 것을 알 수 있고 사용하지 않을 경우 경고를 발생시키지 않을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ddcad35f0c318736909295f4f6cd964d37f1a53f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; , which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 malloc () 또는 open ()과 같이 특정 함수에 무시해서는 안되는 반환 값이 있음을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b236732aa4e34a009b54dcede2dfd55e746dc6ee" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt;, which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 함수에 malloc () 또는 open ()과 같이 무시해서는 안되는 반환 값이 있음을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4f215b234b46ef7c56eb723ad08f919ae0a7c950" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ACCESS&lt;/code&gt; if the access() system call is available to check for access permissions using real IDs.</source>
          <target state="translated">이 변수 는 access () 시스템 호출이 실제 ID를 사용하여 액세스 권한을 확인할 수있는 경우 &lt;code&gt;HAS_ACCESS&lt;/code&gt; 를 조건부로 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="79fed26f317480a67e604252b89c9e7cd20f70a5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_ADD_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_add_overflow(x,y,&amp;amp;z) for safely adding x and y into z while checking for overflow.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_BUILTIN_ADD_OVERFLOW&lt;/code&gt; 를 조건부로 정의합니다 . 이는 컴파일러가 오버플로를 확인하는 동안 x와 y를 z에 안전하게 추가하기 위해 __builtin_add_overflow (x, y, &amp;amp; z)를 지원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6ffb21d9b86f1027201a5668c38e081eccafe1d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_MUL_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_mul_overflow(x,y,&amp;amp;z) for safely multiplying x and y into z while checking for overflow.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_BUILTIN_MUL_OVERFLOW&lt;/code&gt; 를 조건부로 정의합니다 . 이는 컴파일러가 오버플로를 확인하는 동안 x와 y를 z에 안전하게 곱하기 위해 __builtin_mul_overflow (x, y, &amp;amp; z)를 지원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="45b292063a7933d4c21b5fe0bdc942a12c561f5a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_BUILTIN_SUB_OVERFLOW&lt;/code&gt;, which indicates that the compiler supports __builtin_sub_overflow(x,y,&amp;amp;z) for safely subtracting y from x into z while checking for overflow.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_BUILTIN_SUB_OVERFLOW&lt;/code&gt; 를 조건부로 정의합니다 . 이는 컴파일러가 오버플로를 확인하는 동안 y를 x에서 z로 안전하게 빼기 위해 __builtin_sub_overflow (x, y, &amp;amp; z)를 지원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7c105d4e6058827fec8056bf20316718cbab9faa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; if closedir() is available.</source>
          <target state="translated">closedir ()를 사용할 수있는 &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; 변수는 조건부로 HAS_CLOSEDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="8654218934b9b6758432460c578cc5a644b91d92" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; if endhostent() is available to close whatever was being used for host queries.</source>
          <target state="translated">endhostent ()를 사용하여 호스트 쿼리에 사용중인 항목을 닫을 수있는 &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; 변수는 조건부로 HAS_ENDHOSTENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="79e5c8edfd4691e1b4f25bb1c714fe1507e829f4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; if endnetent() is available to close whatever was being used for network queries.</source>
          <target state="translated">endnetent ()를 사용하여 네트워크 쿼리에 사용중인 항목을 모두 닫을 수있는 &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; 변수는 조건부로 HAS_ENDNETENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="23979ba16f9e3dd7409c1aeb4d7d4d5911e864e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; if endprotoent() is available to close whatever was being used for protocol queries.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; ()를 사용하여 프로토콜 쿼리에 사용중인 항목을 닫을 수있는 경우 조건부로 HAS_ENDPROTOENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1f85023e116dfb459bcb6c6b9ea107e1880da801" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; if endservent() is available to close whatever was being used for service queries.</source>
          <target state="translated">이 변수는 endservent ()를 사용하여 서비스 쿼리에 사용중인 항목을 닫을 수있는 경우 조건부로 &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9026ce557a983587089262cdc30c657f39523536" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; if fegetround() is available to get the floating point rounding mode.</source>
          <target state="translated">부동 소수점 반올림 모드를 얻기 위해 fegetround ()를 사용할 수있는 &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; 변수는 조건부로 HAS_FEGETROUND를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="a5695e9822f626cc75613841b734f1880b97e1cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FGETPOS&lt;/code&gt; if fgetpos() is available to get the file position indicator.</source>
          <target state="translated">이 변수는 fgetpos ()를 사용하여 파일 위치 표시기를 가져올 수있는 경우 조건부로 &lt;code&gt;HAS_FGETPOS&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ecd11d67113d55076e38c3f87fbec174b96046c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FLOCK&lt;/code&gt; if flock() is available to do file locking.</source>
          <target state="translated">이 변수는 flock ()을 사용하여 파일 잠금을 수행 할 수있는 경우 조건부로 &lt;code&gt;HAS_FLOCK&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d12df32e7c3e2769df2173cc4aeba55819c508b3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; if fpgetround() is available to get the floating point rounding mode.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; ()를 사용하여 부동 소수점 반올림 모드를 사용할 수있는 경우 조건부로 HAS_FPGETROUND를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7caed5a67bbd1068f15dc1afc8a52fbcbb8a3a6c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FSETPOS&lt;/code&gt; if fsetpos() is available to set the file position indicator.</source>
          <target state="translated">이 변수는 fsetpos ()를 사용하여 파일 위치 표시기를 설정할 수있는 경우 조건부로 &lt;code&gt;HAS_FSETPOS&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca1f26e1ee2a6d6b7bcc20d2c601de0d8652782" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; if getespwnam() is available to retrieve enhanced (shadow) password entries by name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; ()을 사용하여 강화 된 (그림자) 비밀번호 항목을 이름으로 검색 할 수있는 경우 조건부로 HAS_GETESPWNAM을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="523b849ed0e10fbdf244f4e8cd77184e7b2e7e2e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; if gethostent() is available to look up host names in some data base or another.</source>
          <target state="translated">이 변수는 gethostent ()를 사용하여 일부 데이터베이스 나 다른 호스트에서 호스트 이름을 조회 할 수있는 경우 조건부로 &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c477102d11cefe29ba1af921e3e01940cce25886" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETNETENT&lt;/code&gt; if getnetent() is available to look up network names in some data base or another.</source>
          <target state="translated">이 변수는 getnetent ()를 사용하여 일부 데이터베이스에서 네트워크 이름을 조회 할 수있는 경우 &lt;code&gt;HAS_GETNETENT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3dd4221c56df17e7463336ebb61e6a0a59685106" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; if getpagesize() is available to get the system page size.</source>
          <target state="translated">getpagesize ()를 사용하여 시스템 페이지 크기를 가져올 수있는 &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; 변수는 조건부로 HAS_GETPAGESIZE를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="008f90e9dce5e248f0a062499f460cbfe1316a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPGRP&lt;/code&gt; if getpgrp() is available to get the current process group.</source>
          <target state="translated">이 변수는 getpgrp ()를 사용하여 현재 프로세스 그룹을 가져올 수있는 경우 조건부로 &lt;code&gt;HAS_GETPGRP&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="466f30d3944227e178d079578b5e186c11b86479" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; if getpriority() is available to get a process's priority.</source>
          <target state="translated">프로세스 우선 순위를 얻기 위해 getpriority ()를 사용할 수있는 &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; 변수는 조건부로 HAS_GETPRIORITY를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a60b1d5d8d846ce3f5e6fe4d7b072471b5e6c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; if getprotoent() is available to look up protocols in some data base or another.</source>
          <target state="translated">getprotoent ()를 사용하여 일부 데이터베이스에서 프로토콜을 조회 할 수있는 &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; 변수는 조건부로 HAS_GETPROTOENT를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="703bdebcae3a9b18831e785584b8e179d8f5569d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; if getprpwnam() is available to retrieve protected (shadow) password entries by name.</source>
          <target state="translated">getprpwnam ()을 사용하여 보호 된 (그림자) 비밀번호 항목을 이름으로 검색 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d470dbda91b75051a9116195c5471b4cc0a994bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; if getservent() is available to look up network services in some data base or another.</source>
          <target state="translated">getservent ()를 사용하여 일부 데이터베이스에서 네트워크 서비스를 검색 할 수있는 &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; 변수는 조건부로 HAS_GETSERVENT를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8f1532a01e5d8ec8dbefe92231b99738657124d6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; if getspnam() is available to retrieve SysV shadow password entries by name.</source>
          <target state="translated">getspnam ()을 사용하여 SysV 섀도우 암호 항목을 이름으로 검색 할 수있는 &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; 변수는 조건부로 HAS_GETSPNAM을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="cfad68a688a0a88c6b15faed3a855ee7ed81db88" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HTONL&lt;/code&gt; if htonl() and its friends are available to do network order byte swapping.</source>
          <target state="translated">이 변수는 htonl ()과 그 친구가 네트워크 순서 바이트 교환을 수행 할 수있는 경우 조건부로 &lt;code&gt;HAS_HTONL&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="36ae55fc8ab6d9db052670febb9d6c73ffc9c7fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HYPOT&lt;/code&gt; if hypot is available for numerically stable hypotenuse function.</source>
          <target state="translated">이 변수는 수치 적으로 안정적인 빗변 함수에 hypot를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_HYPOT&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1c8f906308fe5425fd5dc9fc6c65283219211f28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_INDEX&lt;/code&gt; if index() and rindex() are available for string searching.</source>
          <target state="translated">문자열 검색에 index () 및 rindex ()를 사용할 수있는 &lt;code&gt;HAS_INDEX&lt;/code&gt; 변수는 조건부로 HAS_INDEX를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f58665b1066bffd31d93be9865becf02e07fbc33" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LINK&lt;/code&gt; if link() is available to create hard links.</source>
          <target state="translated">이 변수는 하드 링크를 만드는 데 link ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_LINK&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f7aaa9b5790c7fed2f4557a1b76230d9dee2b872" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; if localeconv() is available for numeric and monetary formatting conventions.</source>
          <target state="translated">localeconv ()를 숫자 및 통화 형식 규칙에 사용할 수있는 &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; 변수는 조건부로 HAS_LOCALECONV를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a3c4adc80b08fec49de9e85a9758844bbed93d4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCKF&lt;/code&gt; if lockf() is available to do file locking.</source>
          <target state="translated">lockf ()를 사용하여 파일 잠금을 수행 할 수있는 &lt;code&gt;HAS_LOCKF&lt;/code&gt; 변수는 조건부로 HAS_LOCKF를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a3309e731f7ec54de80f5709f885fa11f752d281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; if the long double type is supported.</source>
          <target state="translated">long double 유형이 지원되는 &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; 변수는 조건부로 HAS_LONG_DOUBLE을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f96dc22b2fabc7d6becfede8302b062283c67511" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; if the long long type is supported.</source>
          <target state="translated">이 변수 는 long long 유형이 지원되는 경우 조건부로 &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="bde46e5f10d187a1e49089e8f14937e758db8660" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LSTAT&lt;/code&gt; if lstat() is available to do file stats on symbolic links.</source>
          <target state="translated">lstat ()를 사용하여 기호 링크에서 파일 통계를 수행 할 수있는 &lt;code&gt;HAS_LSTAT&lt;/code&gt; 변수는 조건부로 HAS_LSTAT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9c29d2f5108f120fc070de1998bbec52bcea01c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MADVISE&lt;/code&gt; if madvise() is available to map a file into memory.</source>
          <target state="translated">이 변수는 madvise ()를 사용하여 파일을 메모리에 맵핑 할 수있는 경우 조건부로 &lt;code&gt;HAS_MADVISE&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a0176dd527685bd6e90190916167c20eaf54f9cf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MKOSTEMP&lt;/code&gt; if mkostemp() is available to exclusively create and open a uniquely named (with a suffix) temporary file.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_MKOSTEMP&lt;/code&gt; ()를 사용하여 고유하게 명명 된 (접미사 포함) 임시 파일을 독점적으로 만들고 열 수있는 경우 HAS_MKOSTEMP를 조건부로 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9773977cefbb09ffe9bf40f7bdd75aa66788128d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MMAP&lt;/code&gt; if mmap() is available to map a file into memory.</source>
          <target state="translated">이 변수는 mmap ()을 사용하여 파일을 메모리에 매핑 할 수있는 경우 조건부로 &lt;code&gt;HAS_MMAP&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e49a09fbe97831dedb0097fc04c353ecd4fdc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MPROTECT&lt;/code&gt; if mprotect() is available to modify the access protection of a memory mapped file.</source>
          <target state="translated">이 변수는 mprotect ()를 사용하여 메모리 매핑 된 파일의 액세스 보호를 수정할 수있는 경우 조건부로 &lt;code&gt;HAS_MPROTECT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d39b4760c4a7ddea99da224cda29212d2ef99aed" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MSYNC&lt;/code&gt; if msync() is available to synchronize a mapped file.</source>
          <target state="translated">이 변수는 msync ()를 사용하여 매핑 된 파일을 동기화 할 수있는 경우 조건부로 &lt;code&gt;HAS_MSYNC&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="542bb319608c7eec938e5b98398f37ee190044a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MUNMAP&lt;/code&gt; if munmap() is available to unmap a region mapped by mmap().</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_MUNMAP&lt;/code&gt; ()을 사용하여 mmap ()에 의해 매핑 된 영역을 매핑 해제 할 수있는 경우 HAS_MUNMAP을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="02d3878b96b9be7c2121b2227ea0c924b133a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NAN&lt;/code&gt; if nan() is available to generate NaN.</source>
          <target state="translated">nan ()을 사용하여 NaN을 생성 할 수있는 &lt;code&gt;HAS_NAN&lt;/code&gt; 변수는 조건부로 HAS_NAN을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8ac0a1512388c05f6e3f6942497c27a45e8e3efe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NANOSLEEP&lt;/code&gt; if nanosleep() is available to sleep with 1E-9 sec accuracy.</source>
          <target state="translated">이 변수는 nanosleep ()을 1E-9 초 정확도로 절전 모드로 사용할 수있는 경우 &lt;code&gt;HAS_NANOSLEEP&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4b6ab26a7e66c25dc87e4ed8365e14b5b776d611" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; if nearbyint() is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">nearint ()를 사용하여 현재 반올림 모드에 따라 가장 가까운 정수 값을 x에 반환 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9de8df4ca9d3107d7b5e197ebc2f8b56f2a456de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; if nextafter() is available to return the next machine representable double from x in direction y.</source>
          <target state="translated">nextafter ()를 사용하여 x에서 y 방향으로 표현할 수있는 다음 기계를 두 번 리턴 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="09cc9884f832b1e2f2ad4607b97076420d46d665" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; if nexttoward() is available to return the next machine representable long double from x in direction y.</source>
          <target state="translated">nexttoward ()를 사용하여 x에서 y 방향으로 표현할 수있는 다음 long long을 리턴 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e84d3a1694bc236dbf1d7993a1d2c9255724da86" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; if pthread_attr_setscope() is available to set the contention scope attribute of a thread attribute object.</source>
          <target state="translated">pthread_attr_setscope ()를 사용하여 스레드 속성 오브젝트의 경합 범위 속성을 설정할 수있는 &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; 변수는 조건부로 HAS_PTHREAD_ATTR_SETSCOPE를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ca9e53f6ec390b98dfba5bb4f284367970f8d262" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_READDIR&lt;/code&gt; if readdir() is available to read directory entries.</source>
          <target state="translated">readdir ()을 사용하여 디렉토리 항목을 읽을 수있는 &lt;code&gt;HAS_READDIR&lt;/code&gt; 변수는 조건부로 HAS_READDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="c772ddc21b6658b7802061d88a44caa292765ab3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; if rewinddir() is available.</source>
          <target state="translated">rewinddir ()을 사용할 수있는 &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; 변수는 조건부로 HAS_REWINDDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="102609636e6adf43c7c619fd51b5305af390db97" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_RMDIR&lt;/code&gt; if rmdir() is available to remove directories.</source>
          <target state="translated">이 변수는 rmdir ()을 사용하여 디렉토리를 제거 할 수있는 경우 조건부로 &lt;code&gt;HAS_RMDIR&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="887794d99137721bdeb0c86f2844b40ead019692" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; if seekdir() is available.</source>
          <target state="translated">seekdir ()을 사용할 수있는 &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; 변수는 조건부로 HAS_SEEKDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="eabab054867a6e7a1fda52591f68108f354fff8a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SELECT&lt;/code&gt; if select() is available to select active file descriptors. A &amp;lt;sys/time.h&amp;gt; inclusion may be necessary for the timeout field.</source>
          <target state="translated">이 변수는 select ()를 사용하여 활성 파일 디스크립터를 선택할 수있는 경우 조건부로 &lt;code&gt;HAS_SELECT&lt;/code&gt; 를 정의합니다 . 시간 초과 필드에 &amp;lt;sys / time.h&amp;gt; 포함이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc33f5c99454e91ae2ee5c0078387d95e7d2e9a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; if sethostent() is available.</source>
          <target state="translated">이 변수는 sethostent ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="75151e22ebcabc154ea71d8ff2b10a358ed030a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; if setlocale() is available to handle locale-specific ctype implementations.</source>
          <target state="translated">로케일 별 ctype 구현을 처리하기 위해 setlocale ()을 사용할 수있는 &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; 변수는 조건부로 HAS_SETLOCALE을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3d673facbb75d108913e27f1a2486a73d55d0236" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETNETENT&lt;/code&gt; if setnetent() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETNETENT&lt;/code&gt; ()를 사용할 수있는 경우 조건부로 HAS_SETNETENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7914dcc37c31303f3da0f6e201df5d765f8aa85c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPGRP&lt;/code&gt; if setpgrp() is available to set the current process group.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETPGRP&lt;/code&gt; ()를 사용하여 현재 프로세스 그룹을 설정할 수있는 경우 조건부로 HAS_SETPGRP를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2002a17a2c2a55f6f40172b2b8fb58d5b76cdd2a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; if setpriority() is available to set a process's priority.</source>
          <target state="translated">프로세스 우선 순위를 설정하기 위해 setpriority ()를 사용할 수있는 &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; 변수는 조건부로 HAS_SETPRIORITY를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3c631092c3030de3575c0a7a87bf0eb17b021238" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; if setprotoent() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; ()를 사용할 수있는 경우 조건부로 HAS_SETPROTOENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="0f78400a8b12f8656f01ebbdf5086223548e1e83" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREGID&lt;/code&gt; if setregid() is available to change the real and effective gid of the current process.</source>
          <target state="translated">이 변수는 setregid ()를 사용하여 현재 프로세스의 실제 및 유효 gid를 변경할 수있는 경우 조건부로 &lt;code&gt;HAS_SETREGID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="30c69bd63c2acea93583c8f9220b4a879c50d781" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETRESGID&lt;/code&gt; if setresgid() is available to change the real, effective and saved gid of the current process.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETRESGID&lt;/code&gt; ()를 사용하여 현재 프로세스의 실제 유효하고 저장된 gid를 변경할 수있는 경우 조건부로 HAS_SETRESGID를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="35485f4098b6c1c258054bdb628277a4ccf112e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setresuid() is available to change the real, effective and saved uid of the current process.</source>
          <target state="translated">setresuid ()를 사용하여 현재 프로세스의 실제 유효하고 저장된 uid를 변경할 수있는 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 변수는 조건부로 HAS_SETREUID를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="aba8a0bc40989a1ca38df2aae3c387f371d5192b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setreuid() is available to change the real and effective uid of the current process.</source>
          <target state="translated">setreuid ()를 사용하여 현재 프로세스의 실제 유효 uid를 변경할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6783028c86e7bf10a2b92123734f47a7944fac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; if setservent() is available.</source>
          <target state="translated">이 변수는 setservent ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="56d4df6b62a7f4a67414b6f9ecb8ddad65efc719" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">이 변수는 setsid ()를 사용하여 프로세스 그룹 &lt;code&gt;ID&lt;/code&gt; 를 설정할 수있는 경우 조건부로 &lt;code&gt;HAS_SETSID&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="7ef408c79ac243069730beb417294ee15f89a8da" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt;.</source>
          <target state="translated">이 변수는 setsid ()를 사용하여 프로세스 그룹 &lt;code&gt;ID&lt;/code&gt; 를 설정할 수있는 경우 &lt;code&gt;HAS_SETSID&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a53a8b438b669e85e8dac90bda9a163f72b38dcd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; if sigprocmask() is available to examine or change the signal mask of the calling process.</source>
          <target state="translated">sigprocmask ()를 사용하여 호출 프로세스의 신호 마스크를 검사하거나 변경할 수있는 &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; 변수는 조건부로 HAS_SIGPROCMASK를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="fedaa514d1228b3cb8d459d4c50ec34f00f6ac02" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt; , which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;BSD&lt;/code&gt; 소켓 인터페이스가 지원됨 을 나타내는 &lt;code&gt;HAS_SOCKET&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d90f4b16cfc328489f9f3e006e37192e3670ab4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt;, which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">이 변수 는 &lt;code&gt;BSD&lt;/code&gt; 소켓 인터페이스가 지원됨 을 나타내는 &lt;code&gt;HAS_SOCKET&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5acf41a0b06778d8de2ab0c3e21b6db83e6e1a26" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STAT&lt;/code&gt; if stat() is available to get file status.</source>
          <target state="translated">stat ()를 사용하여 파일 상태를 가져올 수있는 &lt;code&gt;HAS_STAT&lt;/code&gt; 변수는 조건부로 HAS_STAT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="104dec5b82fbc045989fe3c8c4ef8fa75c373740" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCHR&lt;/code&gt; if strchr() and strrchr() are available for string searching.</source>
          <target state="translated">strchr () 및 strrchr ()을 문자열 검색에 사용할 수있는 &lt;code&gt;HAS_STRCHR&lt;/code&gt; 변수는 조건부로 HAS_STRCHR을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="66c65e480ececd2a54e0b9068f9890c68b2b94ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCOLL&lt;/code&gt; if strcoll() is available to compare strings using collating information.</source>
          <target state="translated">이 변수는 배열 정보를 사용하여 문자열을 비교하기 위해 strcoll ()을 사용할 수있는 경우 &lt;code&gt;HAS_STRCOLL&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b82eb75e3b5d7a021a62e68340d85ee6ee407d5d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRERROR&lt;/code&gt; if strerror() is available to translate error numbers to strings.</source>
          <target state="translated">strerror ()를 사용하여 오류 번호를 문자열로 변환 할 수있는 &lt;code&gt;HAS_STRERROR&lt;/code&gt; 변수는 조건부로 HAS_STRERROR를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="157fd2966246701c1e0fd97cb121f370d5243dfd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRXFRM&lt;/code&gt; if strxfrm() is available to transform strings.</source>
          <target state="translated">이 변수는 strxfrm ()을 사용하여 문자열을 변환 할 수있는 경우 조건부로 &lt;code&gt;HAS_STRXFRM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f665cc4a3804d1cfbb21ea5e1e553f34ba0001f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSCALL&lt;/code&gt; if syscall() is available call arbitrary system calls.</source>
          <target state="translated">이 변수는 syscall ()을 사용할 수있는 경우 임의의 시스템 호출을 호출하는 경우 조건부로 &lt;code&gt;HAS_SYSCALL&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="76958e03c19c57ba5daadf788ceb559703fda4a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSTEM&lt;/code&gt; if system() is available to issue a shell command.</source>
          <target state="translated">이 변수는 system ()을 사용하여 쉘 명령을 발행 할 수있는 경우 조건부로 &lt;code&gt;HAS_SYSTEM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fba0f75ab5519c316f7379166065cac7a0fa0f08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; if sys_errlist[] is available to translate error numbers to strings.</source>
          <target state="translated">sys_errlist []를 사용하여 오류 번호를 문자열로 변환 할 수있는 &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; 변수는 조건부로 HAS_SYS_ERRLIST를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3133e51b2626aefa90c83a60c2bc07b45364f9d8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; if sys_errnolist[] is available to translate error numbers to the symbolic name.</source>
          <target state="translated">sys_errnolist []를 사용하여 오류 번호를 기호 이름으로 변환 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3b6cc938eb6588fef7831af7c25c38df6b393dba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TELLDIR&lt;/code&gt; if telldir() is available.</source>
          <target state="translated">이 변수는 조건부로 정의합니다 &lt;code&gt;HAS_TELLDIR&lt;/code&gt; telldir ()을 사용할 수있는 경우이 HAS_TELLDIR을 합니다.</target>
        </trans-unit>
        <trans-unit id="13376d783be11f279f6a31e5dca53c18c5518beb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; 를 정의합니다 . 이는 struct tm에 tm_gmtoff 필드가 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1086cb9c5e3f467454832b8b12812058cd92e06e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt;, which indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">이 변수 는 struct tm에 tm_gmtoff 필드가 있음을 C 프로그램에 나타내는 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; 를 조건부로 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="a5fdffc25ffd7e4584eb45e68410699ffcf4500b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; 을 정의합니다 . , 이는 struct tm에 tm_zone 필드가 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c04ef66c28333bfa29c16eb97a4f1bf1a07a865b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt;, which indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">이 변수 는 struct tm에 tm_zone 필드가 있음을 C 프로그램에 나타내는 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; 을 조건부로 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="56c5c15d4eddf8d206488d6739d6fd8de91eb4bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; if truncate() is available to truncate files.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; 를 정의합니다 truncate ()를 사용하여 파일을자를 수있는 경우 합니다.</target>
        </trans-unit>
        <trans-unit id="e2b911e2460cf128e44ed370b2980c2209097f87" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TZNAME&lt;/code&gt; if tzname[] is available to access timezone names.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TZNAME&lt;/code&gt; 을 정의합니다 .tzname []을 사용하여 시간대 이름에 액세스 할 수있는 합니다.</target>
        </trans-unit>
        <trans-unit id="0d2899983d1ce6900d5663872bcf0fe4bc31fe25" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; if the union semun is defined by including &amp;lt;sys/sem.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; 을 정의합니다 노조 semun는 &amp;lt;SYS / sem.h에&amp;gt; 포함하여 정의 된 경우.</target>
        </trans-unit>
        <trans-unit id="9dbad1c6f722a7fb60b2580c6825a89a0875ea78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USLEEP&lt;/code&gt; if usleep() is available to do high granularity sleeps.</source>
          <target state="translated">usleep ()을 사용하여 세분화 된 휴면을 수행 할 수있는 &lt;code&gt;HAS_USLEEP&lt;/code&gt; 변수는 조건부로 HAS_USLEEP을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="62fcdd3f292691fc949ae90083b1d7e19d396383" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USTAT&lt;/code&gt; if ustat() is available to query file system statistics by dev_t.</source>
          <target state="translated">이 변수는 ustat ()을 dev_t로 파일 시스템 통계를 조회 할 수있는 경우 &lt;code&gt;HAS_USTAT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e6da30a5484ed0715193a06b75bbdc0f387b14b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_WAITPID&lt;/code&gt; if waitpid() is available to wait for child process.</source>
          <target state="translated">이 변수는 waitpid ()를 사용하여 하위 프로세스를 기다릴 수있는 경우 조건부로 &lt;code&gt;HAS_WAITPID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ea1ebdb3e07eb3cfa8774547eb7eca99b9cbda6a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS__FWALK&lt;/code&gt; if _fwalk() is available to apply a function to all the file handles.</source>
          <target state="translated">_fwalk ()를 사용하여 모든 파일 핸들에 함수를 적용 할 수있는 &lt;code&gt;HAS__FWALK&lt;/code&gt; 변수는 조건부로 HAS__FWALK를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ccfbe62640f2e7f4d3f434546f57dde1c801c589" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_DIRENT&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;dirent.h&amp;gt;가 포함되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a9a787f2a18f3b44e560a5f3940cd8e2d3a4e477" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_DIRENT&lt;/code&gt; 를 정의 하며 , 이는 &amp;lt;dirent.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b09b17b8feebed4fb31ad1053dd929b31fc1552d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_NETINET_IN&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &amp;lt;netinet / in.h&amp;gt;를 포함해야 함을 나타냅니다. 그렇지 않으면 &amp;lt;sys / in.h&amp;gt;를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6229f1fa60966db3808987381a186cc7f8635df8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_NETINET_IN&lt;/code&gt; 을 정의 하며 , 이는 &amp;lt;netinet / in.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다. 그렇지 않으면 &amp;lt;sys / in.h&amp;gt;를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18545a27b23f4ec408fe168cb07019ddd52aeb9d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_PWD&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;pwd.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb803936d76c5aab724f9475cc78845aadf9c816" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_PWD&lt;/code&gt; 를 정의합니다 . 이는 &amp;lt;pwd.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3999885997764e29fe1e4dcd432c1a48f0dbd137" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_QUADMATH&lt;/code&gt; 를 정의 하며 , 이는 C 프로그램에 &amp;lt;quadmath.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="84ed6ce0c86d5ff27c690b2ddda9c899654179c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_QUADMATH&lt;/code&gt; 를 정의 하며 , 이는 &amp;lt;quadmath.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2a59b19169614e1208d6a92cb8cd08ec908a8e0b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_IN&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &amp;lt;netinet / in.h&amp;gt; 대신 &amp;lt;sys / in.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03b21042961935fbfbefec3a909d5794f5de25f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_IN&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &amp;lt;netinet / in.h&amp;gt; 대신 &amp;lt;sys / in.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b72fad23f2686fa8a3b7ba796dba5e928d3c1193" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">이 변수는 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; 를 조건부로 정의 하며 , 이는 구조체 타임스 벌의 정의를 얻기 위해 &amp;lt;sys / select.h&amp;gt;를 포함해야한다는 것을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="be7898505b9471576bb5b430ec24e9c34c7b1a55" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">이 변수는 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 구조체 timeval의 정의를 얻기 위해 &amp;lt;sys / select.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="46b3e1dfb1e11c227d687db5d0baaa2e450457de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; to indicate to the C program that socket ioctl codes may be found in &amp;lt;sys/sockio.h&amp;gt; instead of &amp;lt;sys/ioctl.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; 를 정의 하여 소켓 ioctl 코드가 &amp;lt;sys / ioctl.h&amp;gt; 대신 &amp;lt;sys / sockio.h&amp;gt;에 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="abc49b9ac08dff6a9f6857ae04835d4e61d8c3d9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_TIME&lt;/code&gt; 을 정의 하며 , 이는 C 프로그램에 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a05fce4796eb0a468ac066cc59e0a4dc57538112" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_TIME&lt;/code&gt; 을 정의 하며 , 이는 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="134ce192071bcaa440fc2e6dd10833f44f8a3750" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &lt;code&gt;KERNEL&lt;/code&gt; 이 정의 된 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f179c336e76408f1f071c7e6f1d598b7e1ea26ef" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">이 변수는 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; 을 조건부로 정의 하는데 , 이는 &lt;code&gt;KERNEL&lt;/code&gt; 이 정의 된 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="939cb7b0620edee4edc61983e7278fc31a5c1093" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_UN&lt;/code&gt; 을 정의 하며 , 이는 &lt;code&gt;UNIX&lt;/code&gt; 도메인 소켓 정의 를 가져 오기 위해 &amp;lt;sys / un.h&amp;gt;를 포함해야 함을 C 프로그램에 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ff1d57c77149a8f8965a9ee33bf60883847c53e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_UN&lt;/code&gt; 을 정의합니다 . 이는 &lt;code&gt;UNIX&lt;/code&gt; 도메인 소켓 정의 를 가져 오기 위해 &amp;lt;sys / un.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="d05b60d3b34826e6947a78549014fc461f91e426" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;sys / wait.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f8afd487363c7052289252816c4039d5e7259ee5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt;, which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; 를 정의합니다 . 이는 &amp;lt;sys / wait.h&amp;gt;를 포함해야 함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="cbee00fea0a0e43a823409e3c9ea7ecbe6db0995" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;time.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_TIME&lt;/code&gt; 을 정의 하며 , C 프로그램에 &amp;lt;time.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e26138c57947cb8f890b9cb6f5d5a73c355cb2b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_VARARGS&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;varargs.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_VARARGS&lt;/code&gt; 를 정의합니다.이 변수 는 C 프로그램에 &amp;lt;varargs.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="adacd8529d588003400a218d9efa8778e7c5a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE&lt;/code&gt; if the long double is any of the &lt;code&gt;IEEE&lt;/code&gt; 754 style long doubles: &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt;, &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt;, &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt;.</source>
          <target state="translated">이 변수 는 long double이 &lt;code&gt;IEEE&lt;/code&gt; 754 스타일 long double 인 경우 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE&lt;/code&gt; 를 조건부로 정의합니다 . &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; , &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; , &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f34f3c21fd0b8ede657c0701ed24331b130440cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;IEEE&lt;/code&gt; 754 double-double.</source>
          <target state="translated">이 변수 는 long double이 128 비트 &lt;code&gt;IEEE&lt;/code&gt; 754 double-double 인 경우 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_DOUBLEDOUBLE&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="756980c20db36fe0dd46d4db8127dd1afbfcd959" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; if the long double is the 80-bit &lt;code&gt;IEEE&lt;/code&gt; 754 extended precision. Note that despite the &lt;code&gt;extended&lt;/code&gt; this is less than the &lt;code&gt;std&lt;/code&gt;, since thisis an extension of the double precision.</source>
          <target state="translated">이 변수 는 long double이 80 비트 &lt;code&gt;IEEE&lt;/code&gt; 754 확장 정밀도 인 경우 조건부로 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_EXTENDED&lt;/code&gt; 를 정의합니다 . &lt;code&gt;extended&lt;/code&gt; 에도 불구하고 이것은 배정 밀도의 확장이므로 &lt;code&gt;std&lt;/code&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="83aa1379dea829947822c99c195a810d06bb4a38" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;IEEE&lt;/code&gt; 754.</source>
          <target state="translated">이 변수 는 long double이 128 비트 &lt;code&gt;IEEE&lt;/code&gt; 754 인 경우 조건부로 &lt;code&gt;LONG_DOUBLE_STYLE_IEEE_STD&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ce75ff7631bbaf803d0ace7a33143e12192218ef" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;LONG_DOUBLE_STYLE_VAX&lt;/code&gt; if the long double is the 128-bit &lt;code&gt;VAX&lt;/code&gt; format H.</source>
          <target state="translated">이 변수 는 long double이 128 비트 &lt;code&gt;VAX&lt;/code&gt; 형식 H 인 경우 조건부로 &lt;code&gt;LONG_DOUBLE_STYLE_VAX&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="58139b2e3b281a9a118c344ae314fa19f7ef819b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;MYMALLOC&lt;/code&gt; in case other parts of the source want to take special action if &lt;code&gt;MYMALLOC&lt;/code&gt; is used. This may include different sorts of profiling or error detection.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;MYMALLOC&lt;/code&gt; 를 소스의 다른 부분이있는 경우 특별한 조치를 취해야 할 경우에 &lt;code&gt;MYMALLOC&lt;/code&gt; 가 사용된다. 여기에는 다양한 종류의 프로파일 링 또는 오류 감지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8fdadfdd30950a7b700d396be77876a6f4c5f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; . It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 를 정의합니다 . &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 가 비어 있으면 undef로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b135860345eb1cb4ecb8f5dbf25f3b80d9663cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt;. It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">이 변수는 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 를 조건부로 정의합니다 . &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 가 비어 있으면 undef로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ff46e0082d05a29ab6252efc4bd771d18d5878f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; , which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt; . See also otherlibdirs.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; 를 정의합니다 . 여기에는 @ &lt;code&gt;INC&lt;/code&gt; 에 포함 할 perl 바이너리에 대한 콜론으로 구분 된 경로 세트가 포함됩니다 . otherlibdirs도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="792edce2f8757d59c45987f57e7fea3d6b286f1e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt;, which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt;. See also otherlibdirs.</source>
          <target state="translated">이 변수는 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; 를 조건부로 정의합니다. PERL_OTHERLIBDIRS 는 @ &lt;code&gt;INC&lt;/code&gt; 에 포함 할 perl 바이너리에 대한 콜론으로 구분 된 경로 집합을 포함 합니다. otherlibdirs도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="caef6d2331c84b17275d3f9012789c819b377ba9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5d76f60666c8aecb525e5906ff962481dc318171" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="533111c8d8f10b6751abb6a1a0088f4c19073d3e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="871a0cb0554ef284df45b5e6ac6f30c717bd50ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="177a5dd44b77ca5ced87275d19c31e96d16bc7b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="7969ccc81d5cd924a862496e98d359f5c4fdb7ba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6cc9c3d91fb6f28bed8329dae1d992b2ddc3b88b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; , which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 printf와 같은 형식을 null로 허용 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a63de281be650d131b0dada057dda3c788db87bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt;, which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">이 변수는 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; 를 조건부로 정의합니다 . 이는 C 컴파일러가 printf와 유사한 형식이 null이되도록 허용 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b45d18a0fa0b9cd91b944a53b1e7323f8adc333" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt; , which indicates that struct passwd contains pw_age.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWAGE&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_age가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f93b894ca294b4b089fefb4c8e130735fcaeb5c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt;, which indicates that struct passwd contains pw_age.</source>
          <target state="translated">이 변수는 struct passwd에 pw_age가 포함되어 있음을 나타내는 &lt;code&gt;PWAGE&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6b184e19c4dcc5f872f5344f6afc9d5aa8890c36" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt; , which indicates that struct passwd contains pw_change.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;PWCHANGE&lt;/code&gt; 를 정의합니다 . 이는 struct passwd에 pw_change가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8441cd9467c256bdc9b09035b7b1876a361955b4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt;, which indicates that struct passwd contains pw_change.</source>
          <target state="translated">이 변수는 struct passwd에 pw_change가 포함되어 있음을 나타내는 &lt;code&gt;PWCHANGE&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="da5fb50ace415a9312b25c289ac7ee228f0dd1f8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt; , which indicates that struct passwd contains pw_class.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWCLASS&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_class가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bf37296a4f626e5d681b9f335125151376abd8ce" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt;, which indicates that struct passwd contains pw_class.</source>
          <target state="translated">이 변수는 struct passwd에 pw_class가 포함되어 있음을 나타내는 &lt;code&gt;PWCLASS&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9f567085df536f85d28a3794c7c79c2f135c39fc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt; , which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWCOMMENT&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_comment가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d446c0dd2bd7215acf1c8d761e1c367d9b022427" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt;, which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">이 변수는 struct passwd에 pw_comment가 포함되어 있음을 나타내는 &lt;code&gt;PWCOMMENT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2223305749b21469a0762164dc8dc0df3aaa8c7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt; , which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PWEXPIRE&lt;/code&gt; 를 정의합니다 . 이는 struct passwd에 pw_expire가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9992e4d0615a9aacf641f7f53cfe12ded3beec47" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt;, which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">이 변수는 struct passwd에 pw_expire가 포함되어 있음을 나타내는 &lt;code&gt;PWEXPIRE&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf2af3d9e7342f5f1fe442fb4ba6590cba3aeaf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt; , which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWGECOS&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_gecos가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b8016818095e885888a0aca57a1a20c790843e4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt;, which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">이 변수는 struct passwd에 pw_gecos가 포함되어 있음을 나타내는 &lt;code&gt;PWGECOS&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e4df7b4ce4ecdac74c8fac53257d7c54e9e2b1d2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt; , which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWPASSWD&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_passwd가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="abe328a44bbcae89a29efb7320b5f4698e2f3a19" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt;, which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">이 변수는 struct passwd에 pw_passwd가 포함되어 있음을 나타내는 &lt;code&gt;PWPASSWD&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f6f5c85237fcc07cb2101d49b94de63960320aab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt; , which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWQUOTA&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 구조체 passwd에 pw_quota가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9226e8f3babf511a24917282807de2e020e40767" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt;, which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">이 변수는 struct passwd에 pw_quota가 포함되어 있음을 나타내는 &lt;code&gt;PWQUOTA&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d7b4b9ba5cff92bc6dcdb8d6c8455ba666662fc3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&lt;/code&gt; if setlocale() accepts any locale name.</source>
          <target state="translated">이 변수는 setlocale ()이 로케일 이름을 허용하는 경우 &lt;code&gt;SETLOCALE_ACCEPTS_ANY_LOCALE_NAME&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6dc66871cca735678df0954175fa95cf018eb7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; if setuid scripts can be secure. This test looks in</source>
          <target state="translated">setuid 스크립트를 보호 할 수있는 &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 변수는 조건 적으로 SETUID_SCRIPTS_ARE_SECURE_NOW를 정의합니다 . 이 테스트는</target>
        </trans-unit>
        <trans-unit id="81f004e1abf850968e0e52c15f9f6cad13d862f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SITEARCH&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $sitearch is the same as $archlib, then this is set to undef.</source>
          <target state="translated">이 변수는 $ package에 대한 아키텍처 종속 라이브러리 파일의 경로 이름을 보유하도록 &lt;code&gt;SITEARCH&lt;/code&gt; 를 조건부로 정의 합니다. $ sitearch가 $ archlib와 같으면 undef로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8b1027f2dc2d15c75eedea147e9dd18e08a6014d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDCHAR&lt;/code&gt; to be the type of char used in</source>
          <target state="translated">이 변수는 &lt;code&gt;STDCHAR&lt;/code&gt; 을 조건부 에서 사용되는 char 유형으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f33764730e4076b75f7a54ca0311a31df43bbaae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_cnt&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; 을 경우 &lt;code&gt;FILE_cnt&lt;/code&gt; 의 매크로 좌변로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e69f3a8bd1de18db50aaf0b9ef5033e3dafd978" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_ptr&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; 을 경우 &lt;code&gt;FILE_ptr&lt;/code&gt; 의 매크로 좌변로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bc8c4e73c6aaa4fc8b7bd3db1eed9675bd50c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; if getpgrp needs one arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none.</source>
          <target state="translated">이 변수는 getpgrp에 하나의 인수가 필요한 반면 &lt;code&gt;USG&lt;/code&gt; 에는 하나의 인수 가 필요하지 않은 경우 조건부로 &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4cb9da0f1f2c05f27c0a4f7de8f8706f136adf70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; if setpgrp needs two arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none. See also d_setpgid for a &lt;code&gt;POSIX&lt;/code&gt; interface.</source>
          <target state="translated">이 변수는 &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; 두 개의 인수가 필요한 반면 &lt;code&gt;USG&lt;/code&gt; 하나에는 필요하지 않은 경우 조건부로 USE_BSD_SETPGRP를 정의합니다 . &lt;code&gt;POSIX&lt;/code&gt; 인터페이스에 대해서는 d_setpgid도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f057b25789e3d0c0c978f875ab711fef26822396" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; to indicate that the ioctl() call with &lt;code&gt;TIOCNOTTY&lt;/code&gt; should be used to void tty association. Otherwise (on &lt;code&gt;USG&lt;/code&gt; probably), it is enough to close the standard file descriptors and do a setpgrp().</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; 을 가진 IOCTL () 호출을 나타 내기 위해 &lt;code&gt;TIOCNOTTY&lt;/code&gt; 가 무효 TTY 조합으로 사용되어야한다. 그렇지 않으면 ( &lt;code&gt;USG&lt;/code&gt; 에서 ) 표준 파일 디스크립터를 닫고 setpgrp ()를 수행하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c86f9683041fce14f0acc7f22e22cb66e7ecf21d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; , which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; 를 정의합니다 . 이는 struct semid_ds *가 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1109513dd38439e5fff1a28d882ff5dff7ec9cbf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt;, which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct semid_ds *가 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 사용될 것임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="165216a22f48262f27b72dd85b30d1c442227e08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; , which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; 을 정의 하며 , 이는 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 Union semun이 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e4aafdea14d415917179c68732185373f4c70028" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt;, which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; 을 조건부로 정의 하는데 , 이는 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 공용체 semun이 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d946a174db1c59c6d451a81dd08b793b70e50298" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; if this system has a stat structure declaring st_blksize and st_blocks.</source>
          <target state="translated">이 시스템에 st_blksize 및 st_blocks를 선언하는 통계 구조가있는 &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; 변수는 조건부로 USE_STAT_BLOCKS를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4f2a34f2d97a9448f367a3e7dc94f6a98d0c8541" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring a usable _base field (or equivalent) in</source>
          <target state="translated">이 시스템 에 사용 가능한 _base 필드 (또는 이와 동등한)를 선언하는 &lt;code&gt;FILE&lt;/code&gt; 구조 가있는 &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; 변수는 조건부로 USE_STDIO_BASE를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="884014009e45fc4b799369297408405b825f05ec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring usable _ptr and _cnt fields (or equivalent) in</source>
          <target state="translated">이 시스템에 사용 가능한 _ptr 및 _cnt 필드 (또는 이에 상응하는)를 선언 하는 &lt;code&gt;FILE&lt;/code&gt; 구조 가있는 &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; 변수는 조건부로 USE_STDIO_PTR을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e2ce6f3e2ba733cc080d545a7f5345eaada6b53b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOIDSIG&lt;/code&gt; if this system declares &quot;void (*signal(...))()&quot; in</source>
          <target state="translated">이 변수는 이 시스템이 &quot;void (* signal (...)) ()&quot;을 선언하면 &lt;code&gt;VOIDSIG&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c1b1eb5455ff0e45585c738f286f73520d2bda4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; if closedir() does not return a value.</source>
          <target state="translated">closedir ()가 값을 반환하지 않으면 이 변수는 조건부로 &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f67d5b9663b7f0f671bc57d6208cef2ecf39a7bd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines CASTI32, which indicates whether the C compiler can cast large floats to 32-bit ints.</source>
          <target state="translated">이 변수는 조건 적으로 CASTI32를 정의하는데, 이는 C 컴파일러가 큰 부동 소수점을 32 비트 정수로 캐스트 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b443cab6a6f837f35bbd4a8391036b60139696" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_ACCEPT4 if accept4() is available to accept socket connections.</source>
          <target state="translated">이 변수는 소켓 연결을 허용하는 데 accept4 ()를 사용할 수있는 경우 HAS_ACCEPT4를 조건부로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1e0e56548eb03f6bba0bfbdaf1893bfedf8b743e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP2 if dup2() is available to duplicate file descriptors.</source>
          <target state="translated">dup2 ()를 사용하여 파일 디스크립터를 복제 할 수있는 경우이 변수는 조건부로 HAS_DUP2를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b26b7adde106aa6278ad18ec71be8d927043d6fd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP3 if dup3() is available to duplicate file descriptors.</source>
          <target state="translated">이 변수는 dup3 ()을 중복 파일 설명자에 사용할 수있는 경우 HAS_DUP3을 조건부로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="439c57e77afcdbc973932168c0d12a970d487a4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_LC_MONETARY_2008 if libc has the international currency locale rules from &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008.</source>
          <target state="translated">libc에 &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008 의 국제 통화 로케일 규칙이있는 경우이 변수는 조건부로 HAS_LC_MONETARY_2008을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3d55d58456df494116e8e08588b498d9a5a4a48d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_dbl_dig if this system's header files provide &lt;code&gt;DBL_DIG&lt;/code&gt; , which is the number of significant digits in a double precision number.</source>
          <target state="translated">이 변수는이 시스템의 헤더 파일 이 배정 밀도 숫자의 유효 자릿수 인 &lt;code&gt;DBL_DIG&lt;/code&gt; 를 제공하는 경우 d_dbl_dig를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="26943f542b57e3d665241442f5609c91f668a2bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt; , which is the number of significant digits in a long double precision number.</source>
          <target state="translated">이 시스템의 헤더 파일이 LDBL_DIG를 제공하는 &lt;code&gt;LDBL_DIG&lt;/code&gt; 변수는 조건부로 d_ldbl_dig를 정의합니다. LDBL_DIG 는 긴 배정도 숫자의 유효 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="0899cdd5463edd7d47e779f47e9d996e29a1d596" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt;, which is the number of significant digits in a long double precision number.</source>
          <target state="translated">이 변수는이 시스템의 헤더 파일 이 긴 배정 밀도 숫자의 유효 자릿수 인 &lt;code&gt;LDBL_DIG&lt;/code&gt; 를 제공하는 경우 d_ldbl_dig를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="41d4367b100c21704ff1afa07d5fcbbbff3622b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines pthread_create_joinable. undef if</source>
          <target state="translated">이 변수는 pthread_create_joinable을 조건부로 정의합니다. 정의하지 않으면</target>
        </trans-unit>
        <trans-unit id="4e65c9696692a1039d19a96f88bbb8715e74549c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CHSIZE&lt;/code&gt; symbol, which indicates to the C program that the chsize() routine is available to truncate files. You might need a -lx to get this routine.</source>
          <target state="translated">이 변수는 &lt;code&gt;CHSIZE&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 chsize () 루틴을 사용하여 파일을자를 수 있음을 C 프로그램에 표시합니다. 이 루틴을 얻으려면 -lx가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846b0e7427992bb9738c034b084170cbd17a9268" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CRYPT&lt;/code&gt; symbol, which indicates to the C program that the crypt() routine is available to encrypt passwords and the like.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;CRYPT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 crypt () 루틴이 암호 등을 암호화하는 데 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="357bf08dc30645376499e133bedc6c5b51689b15" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CSH&lt;/code&gt; symbol, which indicates to the C program that the C-shell exists.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;CSH&lt;/code&gt; 기호를 정의하며 , 이는 C 프로그램이 C 쉘이 존재 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e54e9f341c505bb1d2ec118651994c8e65d0f811" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; symbol and indicates whether file locking with fcntl() works.</source>
          <target state="translated">이 변수는 &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; 기호를 조건부로 정의하고 fcntl ()을 사용한 파일 잠금 작동 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="02d3adba206dca72cb969c2114087d914736e57e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FLEXFILENAMES&lt;/code&gt; symbol, which indicates that the system supports filenames longer than 14 characters.</source>
          <target state="translated">이 변수는 &lt;code&gt;FLEXFILENAMES&lt;/code&gt; 기호를 조건부로 정의하는데 , 이는 시스템이 14 자보다 긴 파일 이름을 지원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b6165df6dc3c074b8386cff10673ed582f2313bf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASCONST&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the const type.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASCONST&lt;/code&gt; 기호를 정의합니다 .이 기호는이 C 컴파일러가 const 유형에 대해 알고 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="514ce51d44fd8efc6f22a726ff2d864524dc5927" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASVOLATILE&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the volatile declaration.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASVOLATILE&lt;/code&gt; 기호를 정의합니다 .이 기호는이 C 컴파일러가 휘발성 선언에 대해 알고 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3baa45e96d482436f92754c7ebdc6a73550f0eae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACCESSX&lt;/code&gt; symbol, which indicates to the C program that the accessx() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 accessx () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ACCESSX&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="12a76ff5170c955de143e03f08fd4db9b4437e7b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACOSH&lt;/code&gt; symbol, which indicates to the C program that the acosh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ACOSH&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 acosh () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bbc6bd18282fbbaa0a5df512d46d448872f79f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_AINTL&lt;/code&gt; symbol, which indicates to the C program that the aintl() routine is available. If copysignl is also present we can emulate modfl.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_AINTL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 aintl () 루틴을 사용할 수 있음을 나타냅니다. copysignl도 있으면 modfl을 에뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac4f3fc539e3b11a8b62b87684564e56d5832bdb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ALARM&lt;/code&gt; symbol, which indicates to the C program that the alarm() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 alarm () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ALARM&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="393748ad8a6e58564f59c88a5a65a0fccff40956" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; symbol, which indicates to the C program that the asctime_r() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 asctime_r () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e6240de5e54fe3a786d797ae169f9a039181d8e9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASINH&lt;/code&gt; symbol, which indicates to the C program that the asinh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ASINH&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 asinh () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="968fc15f09fb64edc7440ecd0aed6b099eb7c13a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATANH&lt;/code&gt; symbol, which indicates to the C program that the atanh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATANH&lt;/code&gt; 기호를 정의하며 , atanh () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0b6ee241d9266a7948fd72b86cd3046b1822d99c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLF&lt;/code&gt; symbol, which indicates to the C program that the atolf() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATOLF&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 atolf () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f44fe9ea95c9ae1f907047c17022ef03aa1acbb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLL&lt;/code&gt; symbol, which indicates to the C program that the atoll() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATOLL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 atoll () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5e0162b328b8a9b754dac6231795ba2f27a65bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; symbol, which indicates to the C program that the backtrace() routine is available to get a stack trace.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 backtrace () 루틴을 사용하여 스택 추적을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e96fa08dff1194cea11b6b542d4bb635e9998fe7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCMP&lt;/code&gt; symbol if the bcmp() routine is available to compare strings.</source>
          <target state="translated">이 변수 는 bcmp () 루틴을 사용하여 문자열을 비교할 수있는 경우 &lt;code&gt;HAS_BCMP&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2c3a347a1f168f38f12b42fec82e5a9d4a71e447" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCOPY&lt;/code&gt; symbol if the bcopy() routine is available to copy strings.</source>
          <target state="translated">이 변수 는 bcopy () 루틴을 사용하여 문자열을 복사 할 수있는 경우 &lt;code&gt;HAS_BCOPY&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fe7d21ac1bac028a9a4864da166ebd5752380e71" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BZERO&lt;/code&gt; symbol if the bzero() routine is available to set memory to 0.</source>
          <target state="translated">bzero () 루틴을 사용하여 메모리를 0으로 설정할 수 있는 &lt;code&gt;HAS_BZERO&lt;/code&gt; 변수는 조건부로 HAS_BZERO 기호를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6ca90016e7f6abf49f24d5147f764f4e266fad51" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CBRT&lt;/code&gt; symbol, which indicates to the C program that the cbrt() (cube root) function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CBRT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 cbrt () (큐브 루트) 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9190489c62bb031470f6a8b4f7cd7a1825719930" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHOWN&lt;/code&gt; symbol, which indicates to the C program that the chown() routine is available.</source>
          <target state="translated">이 변수 는 chown () 루틴을 사용할 수 있음을 C 프로그램에 표시 하는 &lt;code&gt;HAS_CHOWN&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ab782a1830d8f2fd000403d6b221d923f1975987" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHROOT&lt;/code&gt; symbol, which indicates to the C program that the chroot() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CHROOT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 chroot () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32e6c736a6ca4ad0fe4ee89e271bd5cc262bc051" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLASS&lt;/code&gt; symbol, which indicates to the C program that the class() routine is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_CLASS&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 class () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a075a89328697cbb603b70b3c6d8d110f118b481" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLEARENV&lt;/code&gt; symbol, which indicates to the C program that the clearenv () routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_CLEARENV&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 clearenv () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74f77f33bb77370820b1492e4169ae2248f4c8c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; symbol, which indicates to the C program that the copysign() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 copysign () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="98b66499ba2e3361546a98261177f15a6de1a0f6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; symbol, which indicates to the C program that the copysignl() routine is available. If aintl is also present we can emulate modfl.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 copysignl () 루틴을 사용할 수 있음을 나타냅니다. 만약 aintl도 존재한다면 우리는 modfl을 흉내낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df0f6e4346afa66f63cca26a76d791fade6366c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; symbol, which indicates to the C program that the crypt_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 crypt_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="953edbb919ba277a0602d4f2fae83655b7094d65" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; symbol, which indicates to the C program that the ctermid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ctermid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88f0e31c279f299ee13d676f3280ed80bdc1ec78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTIME_R&lt;/code&gt; symbol, which indicates to the C program that the ctime_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CTIME_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ctime_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f94152d7278e725fe89c658a702df792c385b802" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CUSERID&lt;/code&gt; symbol, which indicates to the C program that the cuserid() routine is available to get character login names.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CUSERID&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 cuserid () 루틴을 사용하여 문자 로그인 이름을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce2c192cea1c48bf6a95dcfd9e173ca30310cf0e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the dbminit() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 시스템이 dbminit () 함수의 프로토 타입을 제공함을 C 프로그램에 표시합니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="9f277ae3e34118b1fe4f7a94827507d1e32928ea" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; symbol, which indicates to the C program that the difftime() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 difftime () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a13740603c74d16121c0903202111151cb13d77c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIRFD&lt;/code&gt; constant, which indicates to the C program that dirfd() is available to return the file descriptor of a directory stream.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIRFD&lt;/code&gt; 상수를 정의합니다 .이 상수는 C 프로그램에 dirfd ()를 사용하여 디렉토리 스트림의 파일 디스크립터를 리턴 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="87bbbc4e9449012cc05f3e6c9ced36d1a9bc5f01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; symbol, which indicates that the &lt;code&gt;DIR&lt;/code&gt; directory stream type contains a member variable called dd_fd.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; 기호를 정의합니다 . 이는 &lt;code&gt;DIR&lt;/code&gt; 디렉토리 스트림 유형에 dd_fd라는 멤버 변수가 포함되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca28447a8986907b62f8a42e124cc4cf1327b826" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLADDR&lt;/code&gt; symbol, which indicates to the C program that the dladdr() routine is available to get a stack trace.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLADDR&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 dladdr () 루틴을 사용하여 스택 추적을 얻을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44450e1cdbf629ec9119c59c9f90d2b874b7e95d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLERROR&lt;/code&gt; symbol, which indicates to the C program that the dlerror() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLERROR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 dlerror () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed1d2043eb098d6534774a50acff39bfc0910625" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLOPEN&lt;/code&gt; symbol, which indicates to the C program that the dlopen() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLOPEN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 dlopen () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="da5e762f36d24957c21350e93040120e9b2b637e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DUPLOCALE&lt;/code&gt; symbol, which indicates to the C program that the duplocale() routine is available to duplicate a locale object.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DUPLOCALE&lt;/code&gt; 기호를 정의하며 , 이는 duplocale () 루틴을 사용하여 로케일 오브젝트를 복제 할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="feae0a63aaa2182b296fd904e1c563d6c234cfec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_EACCESS&lt;/code&gt; symbol, which indicates to the C program that the eaccess() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_EACCESS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 eaccess () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc59246a386f8974acd05f0aa4d2f594daee00df" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; symbol, which indicates to the C program that the endgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 endgrent () 루틴이 그룹 데이터베이스의 순차적 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3521391643a5fa8000971d289ffbc808252e90e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the endgrent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; 기호를 정의하며 endgrent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8ceecbf6a76e7908e513f849eb1de5b3d245fac5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the endhostent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; 기호를 정의하며 endhostent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="85d098e6acbbd799d64738081bddb484d9041c70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the endnetent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; 기호를 정의하며 endnetent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="416322d92948c65411d0e4d7da6d1b4fcb72938b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the endprotoent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; 기호를 정의하며 endprotoent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="93b579b440342c900503cc17debbb4a84724f3f2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; symbol, which indicates to the C program that the endpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 endpwent () 루틴이 passwd 데이터베이스의 순차 액세스에 사용 가능하다는 것을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5fd0311a9220d51e48d013d60dc59e4fb98646e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the endpwent_r() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 endpwent_r () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1975eb77352c3791983498df03109baa693a8003" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the endservent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; 기호를 정의하며 endservent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b18c6ff2e894197a9996c9fa5fb041fb1da60ebb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERF&lt;/code&gt; symbol, which indicates to the C program that the erf() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ERF&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 erf () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11cfc319c8768f753a10806f70be842234f0d8c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERFC&lt;/code&gt; symbol, which indicates to the C program that the erfc() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ERFC&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 erfc () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="607d8c09f8852e64deb233f04ab669fe416307e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; symbol, which indicates to the C program that the &quot;fast stdio&quot; is available to manipulate the stdio buffers directly.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 &quot;고속 stdio&quot;를 사용하여 stdio 버퍼를 직접 조작 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ccef8ea96652d985074f68d669458feccd5e889" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHDIR&lt;/code&gt; symbol, which indicates to the C program that the fchdir() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FCHDIR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fchdir () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2b2fd22f810dafdb7f08dee5c7b2267e8ea89ef0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHMOD&lt;/code&gt; symbol, which indicates to the C program that the fchmod() routine is available to change mode of opened files.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FCHMOD&lt;/code&gt; 기호를 정의합니다 .이 기호는 fchmod () 루틴을 사용하여 열린 파일의 모드를 변경할 수 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b106888c38a0833e62ad3d18b096af53fba36f85" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHMODAT&lt;/code&gt; symbol, which indicates the &lt;code&gt;POSIX&lt;/code&gt; fchmodat() function is available.</source>
          <target state="translated">이 변수 는 &lt;code&gt;POSIX&lt;/code&gt; fchmodat () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_FCHMODAT&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9c49735af970135b28a3d9f02063c62ac7d11452" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHOWN&lt;/code&gt; symbol, which indicates to the C program that the fchown() routine is available to change ownership of opened files.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FCHOWN&lt;/code&gt; 기호를 정의합니다 .이 기호는 fchown () 루틴을 사용하여 열린 파일의 소유권을 변경할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f77965caac290b89da17681f28495b9f8fdfe67f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCNTL&lt;/code&gt; symbol, and indicates whether the fcntl() function exists</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FCNTL&lt;/code&gt; 기호를 조건부로 정의 하고 fcntl () 함수가 존재하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cee857783e2b5506137b733e1de2e80aa525f2cc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FDCLOSE&lt;/code&gt; symbol, which indicates to the C program that the fdclose() routine is available.</source>
          <target state="translated">이 변수 는 Fdclose () 루틴을 사용할 수 있음을 C 프로그램에 나타내는 &lt;code&gt;HAS_FDCLOSE&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a2fcb0bfc83505fad937da436d307c0c9ada3232" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FDIM&lt;/code&gt; symbol, which indicates to the C program that the fdim() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FDIM&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fdim () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11e2724a5c3ae4b7f0de83cc60d5928d8a3f4d81" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITE&lt;/code&gt; symbol, which indicates to the C program that the finite() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FINITE&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 finite () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0caf0447193e8dd99c3be264377abad5f070779b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITEL&lt;/code&gt; symbol, which indicates to the C program that the finitel() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FINITEL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 finitel () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef6f0d37edde2d9b9e3068f863ad72dfd028852d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the flock() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 시스템이 flock () 함수의 프로토 타입을 제공함을 C 프로그램에 표시합니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b7230abc643d63b3ff949047a34fa476fec01c89" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMA&lt;/code&gt; symbol, which indicates to the C program that the fma() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FMA&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fma () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe2ccccffbf8d2f15aa401771663c24fe0ef72b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMAX&lt;/code&gt; symbol, which indicates to the C program that the fmax() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FMAX&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fmax () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3df9fdbc0ab5f9af76565f047d2b383854350a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMIN&lt;/code&gt; symbol, which indicates to the C program that the fmin() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FMIN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fmin () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4c07c14ce41ab8f9b9c87417a26676cf07833635" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FORK&lt;/code&gt; symbol, which indicates to the C program that the fork() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FORK&lt;/code&gt; 기호를 정의하며 , 이는 fork () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c926988df26ecaa58ebdfaa007ae97cb94e0a26e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; symbol, which indicates to the C program that the pathconf() routine is available to determine file-system related limits and options associated with a given open file descriptor.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 pathconf () 루틴을 사용하여 주어진 열린 파일 디스크립터와 연관된 파일 시스템 관련 한계 및 옵션을 판별 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bbd2019de42dcc3e64e59b2a0a5d922b5b1d74e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASS&lt;/code&gt; symbol, which indicates to the C program that the fpclass() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclass () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5fe50cfedd8bbd389632006ec016bddca06ada9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fpclassify() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclassify () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="917f1d97f54623a4d5b664a0773e1e59567c63fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; symbol, which indicates to the C program that the fpclassl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclassl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d55b5137fd8aae7bd0294444ae3398b83ef2eb0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; symbol, which indicates to the C program that the fp_class() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_class () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b4998906b4a9ccf7bdee0f004832d674aa7bbd9a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fp_classify() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_classify () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="41f0ce9e1b9e64ce9cd583c93400552f4e5a6a52" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; symbol, which indicates to the C program that the fp_classl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_classl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3413f93599429afe464b8d3f686c3db466d81209" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FREELOCALE&lt;/code&gt; symbol, which indicates to the C program that the freelocale() routine is available to deallocates the resources associated with a locale object.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FREELOCALE&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 freelocale () 루틴이 로케일 오브젝트와 연관된 자원을 할당 해제하는 데 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9a718ac3558705993c3b67243a1457d9b8addbd1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FREXPL&lt;/code&gt; symbol, which indicates to the C program that the frexpl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FREXPL&lt;/code&gt; 기호를 정의합니다 . 이는 frexpl () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80c041b61a3854b0c9acdcab50bfa3457a568fcc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSEEKO&lt;/code&gt; symbol, which indicates to the C program that the fseeko() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FSEEKO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fseeko () 루틴이 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4051a12dce9cc656f7cd21a6c5cca4ada63aa004" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATFS&lt;/code&gt; symbol, which indicates to the C program that the fstatfs() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSTATFS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fstatfs () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="376e9454716c971bba83efc24ced69d3a6928836" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; symbol, which indicates to the C program that the fstatvfs() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fstatvfs () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="435d2dacb00d4fba9f51b8f56fc86f2e5cd1c130" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSYNC&lt;/code&gt; symbol, which indicates to the C program that the fsync() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSYNC&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fsync () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d1a5f264f0ada9a48dfb15cda9ab839d11e60e6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTELLO&lt;/code&gt; symbol, which indicates to the C program that the ftello() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FTELLO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 ftello () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4064b0e9f22fe23434bd0ec738f58649333e1d6f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTIME&lt;/code&gt; symbol, which indicates that the ftime() routine exists. The ftime() routine is basically a sub-second accuracy clock.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FTIME&lt;/code&gt; 기호를 정의 하여 ftime () 루틴이 존재 함을 나타냅니다. ftime () 루틴은 기본적으로 1 초 미만의 정확도 클럭입니다.</target>
        </trans-unit>
        <trans-unit id="993d1a28d890386a8f56af4b9e1e99b1a4831c24" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FUTIMES&lt;/code&gt; symbol, which indicates to the C program that the futimes() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FUTIMES&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 futimes () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="430e1b55a3f8e2489975bca6250ad0a05f75ddda" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GAI_STRERROR&lt;/code&gt; symbol if the gai_strerror() routine is available and can be used to translate error codes returned by getaddrinfo() into human readable strings.</source>
          <target state="translated">이 변수 는 gai_strerror () 루틴을 사용할 수 있고 getaddrinfo ()에서 반환 된 오류 코드를 사람이 읽을 수있는 문자열로 변환하는 데 사용할 수있는 경우 &lt;code&gt;HAS_GAI_STRERROR&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="43ac0e0e1a1e5f5c73c1a3d69bc5a74620bbdbac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; symbol, which indicates to the C program that the getaddrinfo() function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getaddrinfo () 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7cc91f8b53047d998123d92a6d27f96f7dfebc76" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETCWD&lt;/code&gt; symbol, which indicates to the C program that the getcwd() routine is available to get the current working directory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETCWD&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getcwd () 루틴을 사용하여 현재 작업 디렉토리를 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e7004f7e14bed6afec5bd1f4a037a94dbc84c28f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; symbol, which indicates to the C program that the getfsstat() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getfsstat () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2938f1d0c5a29f26cd258b1d2d58005964b3f928" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT&lt;/code&gt; symbol, which indicates to the C program that the getgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETGRENT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getgrent () 루틴이 그룹 데이터베이스의 순차 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="09573807a7f9ee202cbace6d8d9b71d9e084b114" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the getgrent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffdee0c89f8e16f98534bde8ff72861b068f14e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; symbol, which indicates to the C program that the getgrgid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrgid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="030e0d1f9c9ec5d5113cadafdb1d46cca6636eba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getgrnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5df49eaa2617f7f95ae5a3bfea499bb49b6e147a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; symbol, which indicates to the C program that the getgroups() routine is available to get the list of process groups.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getgroups () 루틴을 사용하여 프로세스 그룹 목록을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="800265a52655b0eed9fc30b1377171be6fe75acb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr() routine is available to look up hosts by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 gethostbyaddr () 루틴을 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소로 호스트를 검색 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3ea6fb7457d69ab022ea88e866995c66dd82da32" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostbyaddr_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6e8e21dbcc61a6d007e0d9229782dc31b5d46a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname() routine is available to look up host names in some data base or other.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 gethostbyname () 루틴을 사용하여 일부 데이터베이스 또는 다른 호스트에서 호스트 이름을 찾을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bf98ecfa6e8572b6387b8b2c890ea9af37d6e48" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ab2674e64e01f9d704936c384471673343e5f6d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the gethostent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5275b5b15c84ca1128b06be5161f949867399a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostname() routine may be used to derive the host name.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostname () 루틴을 사용하여 호스트 이름을 파생시킬 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db277869ea8d6e46267e65bb1f91f362288123a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various gethost*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 gethost * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 나타냅니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="6911ca40dacf0175aa25657133be0fd097867be4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETITIMER&lt;/code&gt; symbol, which indicates to the C program that the getitimer() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETITIMER&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getitimer () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f04b4d71f3b0d33d951527806b9faa1b90d89c13" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; symbol, which indicates to the C program that the getlogin() routine is available to get the login name.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getlogin () 루틴을 사용하여 로그인 이름을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf1e0fa70097167eda24ba22a85cbfefb047a83b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; symbol, which indicates to the C program that the getlogin_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getlogin_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3040c09147f006139a9558f8a311da05ada71cc3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNT&lt;/code&gt; symbol, which indicates to the C program that the getmnt() routine is available to retrieve one or more mount info blocks by filename.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETMNT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getmnt () 루틴이 파일 이름별로 하나 이상의 마운트 정보 블록을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df153c694674c9eb98ea57c25cde4b2529e93311" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; symbol, which indicates to the C program that the getmntent() routine is available to iterate through mounted files to get their mount info.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 마운트 된 파일을 통해 반복 정보를 얻기 위해 getmntent () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="998b35a864ca7293bfdbdc5a68d5a152a1d7c29e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; symbol, which indicates to the C program that the getnameinfo() function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnameinfo () 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8474869224bdf2ca0fc35d392c15a984241143e3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr() routine is available to look up networks by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyaddr () 루틴을 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소로 네트워크를 검색 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f75e54ebc6a22f2ef91ec6d724d333f9d033387c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyaddr_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6b5ef841b8644e4d43f32175f64b87de38e60b50" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname() routine is available to look up networks by their names.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyname () 루틴을 사용하여 이름으로 네트워크를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="721c47b838e08cebc4dfc525ba1a86bef8ed22b8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e1f8d2dc25f66de5fe6af8a19d35c75f17a5000" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the getnetent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bceed1c7ecb752248dae3627ddd88c982cb3b42e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getnet*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getnet * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 표시합니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="7aa9f35159df360d21bd577eca2bcbf715c7998d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPGID&lt;/code&gt; symbol, which indicates to the C program that the getpgid(pid) function is available to get the process group id.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPGID&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpgid (pid) 함수를 사용하여 프로세스 그룹 ID를 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04f375e83ea7b8de60cfb2691530d1bc9774418d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPPID&lt;/code&gt; symbol, which indicates to the C program that the getppid() routine is available to get the parent process &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETPPID&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getppid () 루틴을 사용하여 상위 프로세스 &lt;code&gt;ID&lt;/code&gt; 를 가져올 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bd53aba7859e8609cee2c8eef7587e2855275107" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPPID&lt;/code&gt; symbol, which indicates to the C program that the getppid() routine is available to get the parent process &lt;code&gt;ID&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETPPID&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 getppid () 루틴이 상위 프로세스 &lt;code&gt;ID&lt;/code&gt; 를 가져 오는 데 사용할 수 있음을 C 프로그램에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7a78c1d0e9007adf39f8c4627cff4de19b836276" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname() routine is available to look up protocols by their name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getprotobyname () 루틴을 사용하여 이름으로 프로토콜을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94ee0c74e30f9d4b71ac73fae7e719b93f83ff28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotobyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89d5b6b59bfef172f96bfa6cc53c69ec52250783" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber() routine is available to look up protocols by their number.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getprotobynumber () 루틴이 번호로 프로토콜을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="368c95f7c37edd3f397895e63f2b56a7b2a21f03" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotobynumber_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d05bd546cb9ce10a4ef01cbbaaa2e5620cb6fb98" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the getprotoent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotoent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f547c005ea9729c6769bbf465f8db85dfc630fb1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getproto*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getproto * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 나타냅니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="eaee5a550cc6a07f34637bc2870d60dbfb57bba0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT&lt;/code&gt; symbol, which indicates to the C program that the getpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETPWENT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getpwent () 루틴이 passwd 데이터베이스의 순차적 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0cfeae59d099abce81836530d715a51913eaf2a9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the getpwent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9275e131831690787dbdc11f7dfcedfb8c9f2eda" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getpwnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8827a97094e26a9a854d28073049c8082dc5d239" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; symbol, which indicates to the C program that the getpwuid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwuid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ddc4a151da38a54d4688d4389e590a62e281759b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getservbyname() routine is available to look up services by their name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 getservbyname () 루틴이 이름별로 서비스를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f63223f218d82f595643d54737913a982ed89b01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getservbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2233b0d3a5dbbbc8649c940b930ca9249fb21aa0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; symbol, which indicates to the C program that the getservbyport() routine is available to look up services by their port.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 getservbyport () 루틴이 포트별로 서비스를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e47e4595e0b65cee2c0cb9c76e2aaaffe9e90733" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyport_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getservbyport_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07df398a34922beccb5e215e721d52f31b38b932" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the getservent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getservent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08eec3a50cec026084bfb933ad487f92365051f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getserv*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getserv * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 표시합니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="6ee9b27273c95fe6af664a46ca2e4b018eb2a3bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getspnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getspnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e672430eb4f4b23e7c8ea71a0d9547945979104c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; symbol, which indicates that the gettimeofday() system call exists (to obtain a sub-second accuracy clock). You should probably include &amp;lt;sys/resource.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; 기호를 정의합니다 .이 기호는 gettimeofday () 시스템 호출이 있음을 나타냅니다 (1 초 미만의 정확도 클럭을 얻기 위해). &amp;lt;sys / resource.h&amp;gt;를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="84fced701ac1d8972ad41c237d19c362f2099ca2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; symbol, which indicates to the C program that the gmtime_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gmtime_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fd3c7d3ad1a3dfa9df8edc33011f70a34e07812" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; symbol, which indicates to the C program that the hasmntopt() routine is available to query the mount options of file systems.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 hasmntopt () 루틴이 파일 시스템의 마운트 옵션을 조회하는 데 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="00e5a920dcdf38a72d0e1f65eec67c25b8f6b02e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGB&lt;/code&gt; symbol, which indicates to the C program that the ilogb() routine is available for extracting the exponent of double x as a signed integer.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ILOGB&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ilogb () 루틴을 사용하여 double x의 지수를 부호있는 정수로 추출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08c0b5bc5432877b8453b37bdcbcd6004c0f3533" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGBL&lt;/code&gt; symbol, which indicates to the C program that the ilogbl() routine is available for extracting the exponent of long double x as a signed integer. If scalbnl is also present we can emulate frexpl.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ILOGBL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ilogbl () 루틴이 부호있는 정수로 long double x의 지수를 추출 할 수 있음을 나타냅니다. scalbnl도 있으면 frexpl을 에뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a6e67ac883b1040cb0eb3aa3cd89d5352feb93" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETNTOP&lt;/code&gt; symbol, which indicates to the C program that the inet_ntop() function is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 inet_ntop () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_INETNTOP&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="22502f98a24d835efbc320660dd0c293f19ac278" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETPTON&lt;/code&gt; symbol, which indicates to the C program that the inet_pton() function is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 inet_pton () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_INETPTON&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ff67d886f79098d9924c2d3ff3d0db78ccef4ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INET_ATON&lt;/code&gt; symbol, which indicates to the C program that the inet_aton() function is available to parse &lt;code&gt;IP&lt;/code&gt; address &lt;code&gt;dotted-quad&lt;/code&gt; strings.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_INET_ATON&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 inet_aton () 함수를 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소 점진 &lt;code&gt;dotted-quad&lt;/code&gt; 문자열 을 구문 분석 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ab41c4767757cf5520d581b43402f2b69d925446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq.</source>
          <target state="translated">이 변수 는 struct ip_mreq의 가용성을 나타내는 &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="55f85ff4272b951d973813125721ee335bf64458" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq_source.</source>
          <target state="translated">이 변수 는 struct ip_mreq_source의 가용성을 나타내는 &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="72388a4f1ba17b3fd0e62b5152d323f4548da870" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISASCII&lt;/code&gt; constant, which indicates to the C program that isascii() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_ISASCII&lt;/code&gt; 상수를 조건부로 정의하며 , 이는 isascii ()가 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5a5c21b2a9944da065cad96d5e707e6c815182d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISBLANK&lt;/code&gt; constant, which indicates to the C program that isblank() is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ISBLANK&lt;/code&gt; 상수를 정의합니다 . 이는 C 프로그램에 isblank ()를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fcfef1f9f54abc2b109ba1f21e62b9cb30d767cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITE&lt;/code&gt; symbol, which indicates to the C program that the isfinite() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isfinite () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISFINITE&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b52552318ae18b7d8b2396ea779d84538ec17c45" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; symbol, which indicates to the C program that the isfinitel() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 isfinitel () 루틴이 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5cd5f09b0af60ecfb75127a22d7e1ee2c772c023" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINF&lt;/code&gt; symbol, which indicates to the C program that the isinf() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isinf () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISINF&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a94a2b2142e85325054f5f4823ba6b83d8fa642a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINFL&lt;/code&gt; symbol, which indicates to the C program that the isinfl() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isinfl () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISINFL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e264280a9cf9d3d86b3d9d38e5fb7995161a3146" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISLESS&lt;/code&gt; symbol, which indicates to the C program that the isless() routine is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_ISLESS&lt;/code&gt; () 루틴을 사용할 수 있음을 C 프로그램에 나타내는 HAS_ISLESS 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd09d1b06bd7c7d728ac0ffd960b30379c4a768" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNAN&lt;/code&gt; symbol, which indicates to the C program that the isnan() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnan () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNAN&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae4b6ae907fe92bcc5cb3aa1a2e0540e4b58a60" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNANL&lt;/code&gt; symbol, which indicates to the C program that the isnanl() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnanl () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNANL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="94a6de8a4e8a40a43a72c3936b6277b9b9b82512" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; symbol, which indicates to the C program that the isnormal() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnormal () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9461c7ba3e2b8bec7df67bc8c282aae74033fc39" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_KILLPG&lt;/code&gt; symbol, which indicates to the C program that the killpg() routine is available to kill process groups.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_KILLPG&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 killpg () 루틴이 프로세스 그룹을 강제 종료 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="274a3e469317759be16452a214542288c6b937a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LCHOWN&lt;/code&gt; symbol, which indicates to the C program that the lchown() routine is available to operate on a symbolic link (instead of following the link).</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LCHOWN&lt;/code&gt; 기호를 정의합니다 .이 기호는 lchown () 루틴이 기호 링크에서 작동 할 수 있음을 C 프로그램에 표시합니다 (링크를 따르는 대신).</target>
        </trans-unit>
        <trans-unit id="0f56859453fc1d27f3f17bb37fc0a2d155502907" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LDEXPL&lt;/code&gt; symbol, which indicates to the C program that the ldexpl() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_LDEXPL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 ldexpl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a37d8cf4a0848f3d9bb4cc5545717c3e60e45b64" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA&lt;/code&gt; symbol, which indicates to the C program that the lgamma() routine is available for the log gamma function. See also d_tgamma and d_lgamma_r.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LGAMMA&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lgamma () 루틴이 로그 감마 함수에 사용 가능함을 나타냅니다. d_tgamma 및 d_lgamma_r도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b284947de52d44afb16de832ba8c676b549a69b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; symbol, which indicates to the C program that the lgamma_r() routine is available for the log gamma function, without using the global signgam variable.</source>
          <target state="translated">이 변수 는 전역 signgam 변수를 사용하지 않고 lgamma_r () 루틴을 로그 감마 함수에 사용할 수 있음을 C 프로그램에 표시 하는 &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="30fc562f2935f09f17639cc31ad06d2ee83886f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LINKAT&lt;/code&gt; symbol, which indicates the &lt;code&gt;POSIX&lt;/code&gt; linkat() function is available.</source>
          <target state="translated">이 변수 는 &lt;code&gt;POSIX&lt;/code&gt; linkat () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_LINKAT&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ffb5213a88acb50acec17dbb6c54f9e6a79439a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLRINT&lt;/code&gt; symbol, which indicates to the C program that the llrint() routine is available to return the long long value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LLRINT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 llrint () 루틴이 현재 반올림 모드에 따라 가장 긴 long 값을 x에 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
