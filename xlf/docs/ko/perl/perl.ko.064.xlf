<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f98e934e3e323aad56091ee9d3930f3ae8c104b6" translate="yes" xml:space="preserve">
          <source>This facet is used when an event needs to convey errors.</source>
          <target state="translated">이 패싯은 이벤트가 오류를 전달해야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4863e39f3d637a78fc09d7f47d55d55f765845fe" translate="yes" xml:space="preserve">
          <source>This facet is used when the event needs to give instructions to the Test2 internals.</source>
          <target state="translated">이 패싯은 이벤트가 Test2 내부에 지침을 제공해야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bdf2c23c1dbe14f4057ac7c561201a88d7beb7e" translate="yes" xml:space="preserve">
          <source>This facet represents messages intended for humans that will help them either understand a result, or diagnose a failure.</source>
          <target state="translated">이 패싯은 결과를 이해하거나 실패를 진단하는 데 도움이되는 사람을위한 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b436b8e968978315244cf53329a37437a8e57692" translate="yes" xml:space="preserve">
          <source>This facet tells the system that a plan has been set. The &lt;code&gt;details&lt;/code&gt; field of this is usually left empty, but when present explains why the plan is what it is, this is most useful if the plan is to skip-all.</source>
          <target state="translated">이 패싯은 계획이 설정되었음을 시스템에 알려줍니다. 이 항목의 &lt;code&gt;details&lt;/code&gt; 필드는 일반적으로 비어 있지만 현재 계획이 왜 그런지 설명 할 때 계획이 모두 건너 뛰는 경우 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="31882b218e30926e9578b39c27a5a21498d0f3ba" translate="yes" xml:space="preserve">
          <source>This fails because the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; makes STDERR go to where STDOUT was going at the time of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;. The backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old STDOUT).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 이 STDERR이 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 당시 STDOUT이 가고 있던 곳으로 이동하기 때문에 실패합니다 . 백틱은 STDOUT을 문자열로 만들지 만 STDERR을 변경하지는 않습니다 (이전 STDOUT으로 계속 이동 함).</target>
        </trans-unit>
        <trans-unit id="a78c35501bcdeef5fb990dd2af9d2dc008f91164" translate="yes" xml:space="preserve">
          <source>This fails because the &lt;code&gt;open()&lt;/code&gt; makes STDERR go to where STDOUT was going at the time of the &lt;code&gt;open()&lt;/code&gt;. The backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old STDOUT).</source>
          <target state="translated">때문에 실패 &lt;code&gt;open()&lt;/code&gt; STDOUT이시가는 곳 STDERR의 이동하게 &lt;code&gt;open()&lt;/code&gt; . 그런 다음 백틱은 STDOUT을 문자열로 이동하지만 STDERR을 변경하지 마십시오 (여전히 이전 STDOUT으로 이동).</target>
        </trans-unit>
        <trans-unit id="31d57b0a4260007b8d7df0d0cf0818de49b401fd" translate="yes" xml:space="preserve">
          <source>This failure does not seem to cause any problems. With older gcc versions, &quot;parse error&quot; is reported instead of &quot;missing binary operator&quot;.</source>
          <target state="translated">이 실패는 문제를 일으키지 않는 것 같습니다. 이전 gcc 버전에서는 &quot;이진 연산자 누락&quot;대신 &quot;구문 분석 오류&quot;가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="10989604ee7346d15c921f024379a02bc163f4ba" translate="yes" xml:space="preserve">
          <source>This feature (introduced in Perl 5.10) significantly extends the power of Perl's pattern matching. By referring to some other capture group anywhere in the pattern with the construct &lt;code&gt;(?&lt;i&gt;group-ref&lt;/i&gt;)&lt;/code&gt;, the</source>
          <target state="translated">이 기능 (Perl 5.10에 도입 됨)은 Perl의 패턴 일치 기능을 크게 확장합니다. &lt;code&gt;(?&lt;i&gt;group-ref&lt;/i&gt;)&lt;/code&gt; 구문을 사용하여 패턴의 다른 캡처 그룹을 &lt;i&gt;참조&lt;/i&gt; 하면</target>
        </trans-unit>
        <trans-unit id="7e96692d6e8677f9247e8d718c35a2f5314dd78a" translate="yes" xml:space="preserve">
          <source>This feature (introduced in Perl 5.10) significantly extends the power of Perl's pattern matching. By referring to some other capture group anywhere in the pattern with the construct &lt;code&gt;(?group-ref)&lt;/code&gt;, the</source>
          <target state="translated">이 기능 (Perl 5.10에서 도입)은 Perl의 패턴 일치 기능을 크게 확장합니다. 구문 &lt;code&gt;(?group-ref)&lt;/code&gt; 을 사용하여 패턴의 임의의 다른 캡처 그룹을 참조 하면</target>
        </trans-unit>
        <trans-unit id="39313d94f9ceb03c0da32836d49794a646f76b32" translate="yes" xml:space="preserve">
          <source>This feature allows code like this to work :</source>
          <target state="translated">이 기능을 사용하면 다음과 같은 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3ea6b65f631960dbd85e9aa9e98d367d0a330dd1" translate="yes" xml:space="preserve">
          <source>This feature allows the use of &lt;a href=&quot;perlobj#Indirect-Object-Syntax&quot;&gt;indirect object syntax&lt;/a&gt; for method calls, e.g. &lt;code&gt;new Foo 1, 2;&lt;/code&gt;. It is enabled by default, but can be turned off to disallow indirect object syntax.</source>
          <target state="translated">이 기능을 사용하면 메소드 호출 에 &lt;a href=&quot;perlobj#Indirect-Object-Syntax&quot;&gt;간접 객체 구문&lt;/a&gt; 을 사용할 수 있습니다 ( 예 : &lt;code&gt;new Foo 1, 2;&lt;/code&gt; . 기본적으로 활성화되어 있지만 간접 개체 구문을 허용하지 않도록 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d279f2466dab661314717405c1c291df785e033f" translate="yes" xml:space="preserve">
          <source>This feature hasn't been tested with multiple threads, but it will only show the backtrace of the thread doing the backtracing.</source>
          <target state="translated">이 기능은 여러 스레드에서 테스트되지 않았지만 백 트레이싱을 수행하는 스레드의 역 추적 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3f31330eeb1eb16a4131ea44941bd450e02ba159" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.16 onwards.</source>
          <target state="translated">이 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0eb6c955c276bb211d5f6e97040a35b64f681c9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.18 onwards.</source>
          <target state="translated">이 기능은 Perl 5.18부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc734671a99ea7c893dbf1eee20f1120694c5664" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.18 onwards. From Perl 5.18 to 5.24, it was classed as experimental, and Perl emitted a warning for its usage, except when explicitly disabled:</source>
          <target state="translated">이 기능은 Perl 5.18부터 사용할 수 있습니다. Perl 5.18에서 5.24까지는 실험용으로 분류되었으며 Perl은 명시 적으로 비활성화 된 경우를 제외하고는 사용에 대한 경고를 내보냈습니다.</target>
        </trans-unit>
        <trans-unit id="5350c7db9e5ccded478eeb543bf7a26b7856c3e9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.20 onwards.</source>
          <target state="translated">이 기능은 Perl 5.20부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912ee35f2cf624d52ab346e73c3923159bdb7d37" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.20 onwards. In Perl 5.20 and 5.22, it was classed as experimental, and Perl emitted a warning for its usage, except when explicitly disabled:</source>
          <target state="translated">이 기능은 Perl 5.20부터 사용할 수 있습니다. Perl 5.20 및 5.22에서는 실험용으로 분류되었으며 Perl은 명시 적으로 비활성화 된 경우를 제외하고는 사용에 대한 경고를 내보냈습니다.</target>
        </trans-unit>
        <trans-unit id="d594f14a3251cf1780c8a95d14833fb1764cbcb5" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.22 onwards.</source>
          <target state="translated">이 기능은 Perl 5.22부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812da9afcec2dd5dbb225d365cc307499de91303" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.22 onwards. Starting in Perl 5.28, &lt;code&gt;use v5.28&lt;/code&gt; will enable the feature. Before 5.28, it was still experimental and would emit a warning in the &quot;experimental::bitwise&quot; category.</source>
          <target state="translated">이 기능은 Perl 5.22부터 사용할 수 있습니다. Perl 5.28부터 &lt;code&gt;use v5.28&lt;/code&gt; 을 사용하면 기능이 활성화됩니다. 5.28 이전에는 아직 실험적이었으며 &quot;experimental :: bitwise&quot;범주에서 경고를 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="37f5953cd1a4e50648fa5b5a07b6072cdf30f093" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.26 onwards.</source>
          <target state="translated">이 기능은 Perl 5.26부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c28ac324833990916ac9b2e82a500932e6c840" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.32 onwards.</source>
          <target state="translated">이 기능은 Perl 5.32 이상에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd060361bef60c9e8d128e54b15bdf49a0df3f0" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.10.</source>
          <target state="translated">이 기능은 Perl 5.10부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f16229bb3e38370fa369bac03ef842b45e6ac174" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.12; was almost fully implemented in Perl 5.14; and extended in Perl 5.16 to cover &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 Perl 5.12부터 사용할 수 있습니다. Perl 5.14에서 거의 완전히 구현되었습니다. 그리고 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 를 포함하도록 Perl 5.16에서 확장되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b5524e6a39157c705251929d1a0f3ddb30671307" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.12; was almost fully implemented in Perl 5.14; and extended in Perl 5.16 to cover &lt;code&gt;quotemeta&lt;/code&gt;; was extended further in Perl 5.26 to cover &lt;a href=&quot;perlop#Range-Operators&quot;&gt;the range operator&lt;/a&gt;; and was extended again in Perl 5.28 to cover &lt;a href=&quot;perlfunc#split&quot;&gt;special-cased whitespace splitting&lt;/a&gt;.</source>
          <target state="translated">이 기능은 Perl 5.12부터 사용할 수 있습니다. Perl 5.14에서 거의 완벽하게 구현되었습니다. &lt;code&gt;quotemeta&lt;/code&gt; 를 포함하도록 Perl 5.16에서 확장되었습니다 . &lt;a href=&quot;perlop#Range-Operators&quot;&gt;범위 연산자&lt;/a&gt; 를 포함 하도록 Perl 5.26에서 추가로 확장되었습니다 . &lt;a href=&quot;perlfunc#split&quot;&gt;특수한 경우의 공백 분할&lt;/a&gt; 을 다루기 위해 Perl 5.28에서 다시 확장되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fa1f4ec8b7292a36ec1d671af80c0ba1c4dbf6" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.16.</source>
          <target state="translated">이 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0f06ce5a1bc9813d47f25141700a05f2802346" translate="yes" xml:space="preserve">
          <source>This feature is available under this name from Perl 5.32 onwards. In previous versions, it was simply on all the time. To disallow (or warn on) indirect object syntax on older Perls, see the &lt;a href=&quot;indirect&quot;&gt;indirect&lt;/a&gt; CPAN module.</source>
          <target state="translated">이 기능은 Perl 5.32부터이 이름으로 사용할 수 있습니다. 이전 버전에서는 항상 켜져있었습니다. 이전 Perls에서 간접 객체 구문을 허용하지 않거나 경고하려면 &lt;a href=&quot;indirect&quot;&gt;간접&lt;/a&gt; CPAN 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cf7997500a8320557eaa4d36e75775cc5a5b761" translate="yes" xml:space="preserve">
          <source>This feature is available under this name starting with Perl 5.16. In previous versions, it was simply on all the time, and this pragma knew nothing about it.</source>
          <target state="translated">이 기능은 Perl 5.16부터이 이름으로 제공됩니다. 이전 버전에서는 항상 간단하게 작동했으며이 pragma는 이에 대해 전혀 몰랐습니다.</target>
        </trans-unit>
        <trans-unit id="b957d6504ae997d3a3efef291b5e1aad2b736b3a" translate="yes" xml:space="preserve">
          <source>This feature is enabled by 'importing' the non-existent symbol 'verbose'. You would typically enable it by saying</source>
          <target state="translated">이 기능은 존재하지 않는 기호 'verbose'를 '가져 오기'하여 활성화됩니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="02d76db5faed0f26a8be3e80c39fd86b2f9e9ac8" translate="yes" xml:space="preserve">
          <source>This feature is implemented as a new op type, &lt;code&gt;OP_CUSTOM&lt;/code&gt; . The Perl core does not &quot;know&quot; anything special about this op type, and so it will not be involved in any optimizations. This also means that you can define your custom ops to be any op structure -- unary, binary, list and so on -- you like.</source>
          <target state="translated">이 기능은 새로운 op 유형 인 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 으로 구현됩니다 . Perl 코어는이 op 유형에 대해 특별한 것을 &quot;알지&quot;않으므로 최적화에 관여하지 않습니다. 즉, 원하는 op 구조 (단항, 이진, 목록 등)로 사용자 지정 op를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7a3b666f950bccfb4edd15bc8cc86185353e0d" translate="yes" xml:space="preserve">
          <source>This feature is implemented as a new op type, &lt;code&gt;OP_CUSTOM&lt;/code&gt;. The Perl core does not &quot;know&quot; anything special about this op type, and so it will not be involved in any optimizations. This also means that you can define your custom ops to be any op structure -- unary, binary, list and so on -- you like.</source>
          <target state="translated">이 기능은 새로운 작업 유형 인 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 으로 구현됩니다 . Perl 코어는이 작업 유형에 대해 특별한 것을 &quot;알지&quot;못하므로 최적화에 관여하지 않습니다. 이는 또한 사용자 지정 작업을 단항, 이진, 목록 등 원하는 모든 작업 구조로 정의 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a96f74e82c64c1fcb6aeb933d3cba439c5534f0" translate="yes" xml:space="preserve">
          <source>This feature is not available when the left-hand side is prefixed by &lt;code&gt;Is_&lt;/code&gt;, nor for any form that is marked as &quot;Discouraged&quot; in &lt;a href=&quot;perluniprops#Discouraged&quot;&gt;&quot;Discouraged&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="translated">이 기능은 왼쪽에 &lt;code&gt;Is_&lt;/code&gt; 접두사가 붙은 경우 나 perluniprops의 &quot;Discouraged&quot;에서 &lt;a href=&quot;perluniprops#Discouraged&quot;&gt;&quot;Discouraged&quot;&lt;/a&gt; 로 표시된 양식에 대해서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d3d9a13d27e32567256bd5ed07966300b2843571" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip) and there is useful data immediately after the deflation stream.</source>
          <target state="translated">이 기능은 압축 된 데이터 스트림 (예 : gzip, zip)을 캡슐화하는 파일 형식을 처리 할 때 유용하며 수축 스트림 직후에 유용한 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ff4f5cd1e98da8a085f691d09087dfafce10bc" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip).</source>
          <target state="translated">이 기능은 압축 된 데이터 스트림을 캡슐화하는 파일 형식 (예 : gzip, zip)을 처리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="def031dfec2b62faefb35716ef0923bb4937a5cd" translate="yes" xml:space="preserve">
          <source>This feature makes these:</source>
          <target state="translated">이 기능은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1209b27a133e6af72a5c8528b176699143400cab" translate="yes" xml:space="preserve">
          <source>This feature requires configuration option &lt;b&gt;permute&lt;/b&gt;, see section &lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;&quot;Configuring Getopt::Long&quot;&lt;/a&gt;.</source>
          <target state="translated">이 기능에는 구성 옵션 &lt;b&gt;permute&lt;/b&gt; 가 필요합니다 . &lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;&quot;Getopt :: Long 구성&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4da939b7443e26e164efdaa4d6f81b9bc175434" translate="yes" xml:space="preserve">
          <source>This feature requires configuration option &lt;b&gt;permute&lt;/b&gt;, see section &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt;.</source>
          <target state="translated">이 기능에는 &lt;b&gt;permute&lt;/b&gt; 구성 옵션이 필요합니다 ( &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Getopt :: Long 구성&lt;/a&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="17e7c4a42ab4fd0bc0d9658f7d9d343681a4a3e3" translate="yes" xml:space="preserve">
          <source>This feature supported the legacy &lt;code&gt;$[&lt;/code&gt; variable. See &lt;a href=&quot;perlvar#%24%5B&quot;&gt;&quot;$[&quot; in perlvar&lt;/a&gt;. It was on by default but disabled under &lt;code&gt;use v5.16&lt;/code&gt; (see &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;&quot;IMPLICIT LOADING&quot;&lt;/a&gt;, below) and unavailable since perl 5.30.</source>
          <target state="translated">이 기능은 레거시 &lt;code&gt;$[&lt;/code&gt; 변수를 지원했습니다 . &lt;a href=&quot;perlvar#%24%5B&quot;&gt;perlvar의 &quot;$ [&quot;를&lt;/a&gt; 참조하십시오 . 기본적으로 켜져 있지만 &lt;code&gt;use v5.16&lt;/code&gt; (아래 &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;&quot;IMPLICIT LOADING&quot;&lt;/a&gt; 참조) 에서는 비활성화되어 있으며 perl 5.30 이후로는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b84829a17ad80817afc9eefb1b49f97bfdfe8fac" translate="yes" xml:space="preserve">
          <source>This feature supports the legacy &lt;code&gt;$[&lt;/code&gt; variable. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;. It is on by default but disabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (see &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;IMPLICIT LOADING&lt;/a&gt;, below).</source>
          <target state="translated">이 기능은 레거시 &lt;code&gt;$[&lt;/code&gt; 변수를 지원합니다 . &lt;a href=&quot;perlvar#%24%5b&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;arybase&quot;&gt;arybase의 &lt;/a&gt;$ [를 참조하십시오 . 기본적으로 켜져 있지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 에는 비활성화되어 &lt;a href=&quot;functions/use&quot;&gt;있습니다&lt;/a&gt; (아래의 &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;IMPLICIT LOADING&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="00aefaa433583952978113c93d5aa269ecab2168" translate="yes" xml:space="preserve">
          <source>This feature was inspired by, and small portions of code copied from, &lt;a href=&quot;ExtUtils::MakeMaker::BigHelper&quot;&gt;ExtUtils::MakeMaker::BigHelper&lt;/a&gt;. Hopefully this feature will render that module mainly obsolete.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;ExtUtils::MakeMaker::BigHelper&quot;&gt;ExtUtils :: MakeMaker :: BigHelper&lt;/a&gt; 에서 복사 된 코드의 일부에서 영감을 얻었습니다 . 바라건대이 기능이 해당 모듈을 주로 쓸모 없게 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="ccaa07991a8c1bc153311bc6ab0dcadf92aec838" translate="yes" xml:space="preserve">
          <source>This feature, available starting in v5.12, matches any character that is &lt;b&gt;not&lt;/b&gt; a newline. It is a short-hand for writing &lt;code&gt;[^\n]&lt;/code&gt;, and is identical to the &lt;code&gt;.&lt;/code&gt; metasymbol, except under the &lt;code&gt;/s&lt;/code&gt; flag, which changes the meaning of &lt;code&gt;.&lt;/code&gt;, but not &lt;code&gt;\N&lt;/code&gt; .</source>
          <target state="translated">v5.12부터 사용 가능한이 기능 은 줄 바꿈 이 &lt;b&gt;아닌&lt;/b&gt; 모든 문자와 일치합니다 . &lt;code&gt;[^\n]&lt;/code&gt; 쓰기의 축약 형 이며와 동일합니다 &lt;code&gt;.&lt;/code&gt; metasymbol는 제외하고 &lt;code&gt;/s&lt;/code&gt; 의 의미를 변경 플래그 &lt;code&gt;.&lt;/code&gt; , 그러나 &lt;code&gt;\N&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8e4badd2bd0b3314de1d21b3c6a19a2f1bd377e8" translate="yes" xml:space="preserve">
          <source>This feature, available starting in v5.12, matches any character that is &lt;b&gt;not&lt;/b&gt; a newline. It is a short-hand for writing &lt;code&gt;[^\n]&lt;/code&gt;, and is identical to the &lt;code&gt;.&lt;/code&gt; metasymbol, except under the &lt;code&gt;/s&lt;/code&gt; flag, which changes the meaning of &lt;code&gt;.&lt;/code&gt;, but not &lt;code&gt;\N&lt;/code&gt;.</source>
          <target state="translated">v5.12부터 사용할 수있는이 기능 은 개행 문자 가 &lt;b&gt;아닌&lt;/b&gt; 모든 문자와 일치합니다 . &lt;code&gt;[^\n]&lt;/code&gt; 쓰기의 약자 이며 &lt;code&gt;.&lt;/code&gt; 의 의미를 변경하는 &lt;code&gt;/s&lt;/code&gt; 플래그 아래를 제외하고 &lt;code&gt;.&lt;/code&gt; 하지만하지 &lt;code&gt;\N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86eab6101dbb39be1f4756f21ad94b3dc3f5b53a" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object was created if this option is not specified.</source>
          <target state="translated">이 필드는 기본적 으로이 옵션이 지정되지 않은 경우 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 오브젝트가 작성된 시간으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae6e594e4f58006926409640dc519990e005708" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object was created if this option is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename.</source>
          <target state="translated">이 필드 는이 옵션이 지정되지 않고 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름이 아닌 경우 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 오브젝트가 작성된 시간으로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="29150647b17fb2eaf032ae7f9cf1edf0d8a40273" translate="yes" xml:space="preserve">
          <source>This field describes resources related to this distribution.</source>
          <target state="translated">이 필드는이 배포와 관련된 리소스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="faabe301b626421e79d9a93a3746c1a4c23e996c" translate="yes" xml:space="preserve">
          <source>This field explicitly &lt;b&gt;does not&lt;/b&gt; indicate whether installation may be safely performed without using a Makefile or Build file, as there may be special files to install or custom installation targets (e.g. for dual-life modules that exist on CPAN as well as in the Perl core). This field only defines whether or not prerequisites are exactly as given in the metadata.</source>
          <target state="translated">이 필드 &lt;b&gt;는&lt;/b&gt; 설치할 특수 파일이나 사용자 지정 설치 대상 (예 : CPAN 및 Perl 코어에 존재하는 이중 수명 모듈의 경우)이있을 수 있으므로 Makefile 또는 Build 파일을 사용하지 않고 설치를 안전하게 수행 할 수 있는지 여부를 명시 적으로 &lt;b&gt;나타내지 않습니다.&lt;/b&gt; ). 이 필드는 전제 조건이 메타 데이터에 제공된 것과 정확히 일치하는지 여부 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b737c95cac471ad0db737bd55f2afa0ecc00e9d6" translate="yes" xml:space="preserve">
          <source>This field gives the version of the distribution to which the metadata structure refers.</source>
          <target state="translated">이 필드는 메타 데이터 구조가 참조하는 배포 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28ed5ad05bf9538c83d6f4c31b8d8168c6ea1afe" translate="yes" xml:space="preserve">
          <source>This field has been renamed to &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt;.</source>
          <target state="translated">이 필드는 &lt;a href=&quot;#no_index&quot;&gt;&quot;no_index&quot;&lt;/a&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6d61de930b74d19121949eaba54d44d9e597bc04" translate="yes" xml:space="preserve">
          <source>This field indicated 'module' or 'script' but was considered meaningless, since many distributions are hybrids of several kinds of things.</source>
          <target state="translated">이 필드는 '모듈'또는 '스크립트'를 나타내지 만 많은 분포가 여러 종류의 하이브리드이기 때문에 의미가없는 것으로 간주되었습니다.</target>
        </trans-unit>
        <trans-unit id="f4a131922fb04db9781571b4e2c9fc5802f7ed1d" translate="yes" xml:space="preserve">
          <source>This field indicates the tool that was used to create this metadata. There are no defined semantics for this field, but it is traditional to use a string in the form &quot;Generating::Package version 1.23&quot; or the author's name, if the file was generated by hand.</source>
          <target state="translated">이 필드는이 메타 데이터를 만드는 데 사용 된 도구를 나타냅니다. 이 필드에 대해 정의 된 의미는 없지만 파일이 수동으로 생성 된 경우 &quot;Generating :: Package version 1.23&quot;형식의 문자열 또는 작성자 이름을 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="81dca640acbfe709e984ed290704a109d285fb13" translate="yes" xml:space="preserve">
          <source>This field indicates the version of the CPAN Meta Spec that should be used to interpret the metadata. Consumers must check this key as soon as possible and abort further metadata processing if the meta-spec version is not supported by the consumer.</source>
          <target state="translated">이 필드는 메타 데이터를 해석하는 데 사용해야하는 CPAN 메타 사양의 버전을 나타냅니다. 소비자는 가능한 한 빨리이 키를 확인해야하며 소비자가 메타 사양 버전을 지원하지 않는 경우 추가 메타 데이터 처리를 중단해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4b23162f25251f9c8794e4f7fc74132947318185" translate="yes" xml:space="preserve">
          <source>This field is basically meaningless, and tools (like Module::Build or MakeMaker) will likely stop generating it in the future.</source>
          <target state="translated">이 필드는 기본적으로 무의미하며 도구 (예 : Module :: Build 또는 MakeMaker)는 향후 생성을 중지 할 가능성이 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="f1537025bf1561c07253d5a4a656431e7bfecfa5" translate="yes" xml:space="preserve">
          <source>This field is required. It must contain a Unix-style relative file path from the root of the distribution directory to a file that contains or generates the package. It may be given as &lt;code&gt;META.yml&lt;/code&gt; or &lt;code&gt;META.json&lt;/code&gt; to claim a package for indexing without needing a &lt;code&gt;*.pm&lt;/code&gt;.</source>
          <target state="translated">이 필드는 필수입니다. 배포 디렉터리의 루트에서 패키지를 포함하거나 생성하는 파일까지의 Unix 스타일 상대 파일 경로를 포함해야합니다. &lt;code&gt;*.pm&lt;/code&gt; 필요없이 인덱싱을 위해 패키지를 &lt;code&gt;META.json&lt;/code&gt; 하려면 &lt;code&gt;META.yml&lt;/code&gt; 또는 META.json 으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b47519bc5424cf5de4e08e39bba85f5f5e7d4927" translate="yes" xml:space="preserve">
          <source>This field is the name of the distribution. This is often created by taking the &quot;main package&quot; in the distribution and changing &lt;code&gt;::&lt;/code&gt; to &lt;code&gt;-&lt;/code&gt;, but the name may be completely unrelated to the packages within the distribution. For example, &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; is distributed as part of the distribution name &quot;libwww-perl&quot;.</source>
          <target state="translated">이 필드는 배포의 이름입니다. 이것은 종종 배포판에서 &quot;메인 패키지&quot;를 가져와 &lt;code&gt;::&lt;/code&gt; 를 &lt;code&gt;-&lt;/code&gt; 로 변경 하여 생성 되지만 이름은 배포판 내의 패키지와 완전히 관련이 없을 수 있습니다. 예를 들어, &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt; 는 배포 이름 &quot;libwww-perl&quot;의 일부로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="e1736869f31835444fcd2554056bb1bdc04ff6bd" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;reg_data&lt;/code&gt; structure, which is defined as follows</source>
          <target state="translated">이 필드 는 다음과 같이 정의되는 &lt;code&gt;reg_data&lt;/code&gt; 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="990821d4ec37cddf0c064311fa9c677b83df34b2" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;regexp_engine&lt;/code&gt; structure which contains pointers to the subroutines that are to be used for performing a match. It is the compiling routine's responsibility to populate this field before returning the regexp object.</source>
          <target state="translated">이 필드 는 일치를 수행하는 데 사용될 서브 루틴에 대한 포인터를 포함 하는 &lt;code&gt;regexp_engine&lt;/code&gt; 구조를 가리 킵니다 . regexp 객체를 반환하기 전에이 필드를 채우는 것은 컴파일 루틴의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="d3115586186f239f2cdb97a74488a09390946c64" translate="yes" xml:space="preserve">
          <source>This field provides a general contact list independent of other structured fields provided within the &lt;a href=&quot;#resources&quot;&gt;&quot;resources&quot;&lt;/a&gt; field, such as &lt;code&gt;bugtracker&lt;/code&gt;. The addressee(s) can be contacted for any purpose including but not limited to (security) problems with the distribution, questions about the distribution or bugs in the distribution.</source>
          <target state="translated">이 필드는 &lt;code&gt;bugtracker&lt;/code&gt; 와 같이 &lt;a href=&quot;#resources&quot;&gt;&quot;resources&quot;&lt;/a&gt; 필드 내에 제공된 다른 구조화 된 필드와 독립적 인 일반 연락처 목록을 제공합니다 . 수취인 (들)은 배포 관련 (보안) 문제, 배포에 대한 질문 또는 배포의 버그를 포함하되 이에 국한되지 않는 모든 목적으로 연락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29c3b5fab49e3420f92d746ba1cbdbe08c72d5d" translate="yes" xml:space="preserve">
          <source>This field provides the release status of this distribution. If the &lt;code&gt;version&lt;/code&gt; field contains an underscore character, then &lt;code&gt;release_status&lt;/code&gt;&lt;b&gt;must not&lt;/b&gt; be &quot;stable.&quot;</source>
          <target state="translated">이 필드는이 배포의 릴리스 상태를 제공합니다. &lt;code&gt;version&lt;/code&gt; 필드에 밑줄 문자가 포함 된 경우 &lt;code&gt;release_status&lt;/code&gt; &lt;b&gt;는&lt;/b&gt; &quot;stable&quot;이 &lt;b&gt;아니어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5405199dbad0bce0901c037dfa0366548623a8d9" translate="yes" xml:space="preserve">
          <source>This field should be set to a true value if the distribution performs some dynamic configuration (asking questions, sensing the environment, etc.) as part of its configuration. This field should be set to a false value to indicate that prerequisites included in metadata may be considered final and valid for static analysis.</source>
          <target state="translated">배포가 구성의 일부로 일부 동적 구성 (질문, 환경 감지 등)을 수행하는 경우이 필드는 참 값으로 설정되어야합니다. 이 필드는 메타 데이터에 포함 된 전제 조건이 정적 분석에 대해 최종적이고 유효한 것으로 간주 될 수 있음을 나타 내기 위해 false 값으로 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="da956943782a68bad0050c69ab023b35da3d16ff" translate="yes" xml:space="preserve">
          <source>This file adds no new information not already present in other files</source>
          <target state="translated">이 파일은 다른 파일에 아직없는 새로운 정보를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ee1cf43e9a6c3ca6d1e4006823b69dbad7f2bcb" translate="yes" xml:space="preserve">
          <source>This file came from the &quot;IO-stringy&quot; Perl5 toolkit.</source>
          <target state="translated">이 파일은 &quot;IO-stringy&quot;Perl5 툴킷에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="423f1e020ff559262836a01099aa9f00246b3cb0" translate="yes" xml:space="preserve">
          <source>This file contains instructions how to build Perl for Haiku and lists known problems.</source>
          <target state="translated">이 파일은 Perl for Haiku를 빌드하는 방법과 알려진 문제를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3f97544476d7e0ff75b590bf2fb66c36a8e55e0a" translate="yes" xml:space="preserve">
          <source>This file contains most of the documentation of the perl public API, as generated by</source>
          <target state="translated">이 파일에는 펄 퍼블릭 API에 대한 대부분의 문서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddfb6f3949b158a34147e69be5f3f78a6a15fb6" translate="yes" xml:space="preserve">
          <source>This file contains notes for building perl on the Stratus OpenVOS operating system. Perl is a scripting or macro language that is popular on many systems. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlbook&quot;&gt;perlbook&lt;/a&gt; for a number of good books on Perl.</source>
          <target state="translated">이 파일에는 Stratus OpenVOS 운영 체제에서 perl을 빌드하기위한 참고 사항이 포함되어 있습니다. Perl은 많은 시스템에서 널리 사용되는 스크립팅 또는 매크로 언어입니다. Perl에 대한 많은 좋은 책 은 &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlbook&quot;&gt;perlbook&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16e77d17e03a82d35fe5f118c6d17cc03a2f5d43" translate="yes" xml:space="preserve">
          <source>This file contains notes for building perl on the Stratus OpenVOS operating system. Perl is a scripting or macro language that is popular on many systems. See &lt;a href=&quot;perlbook&quot;&gt;perlbook&lt;/a&gt; for a number of good books on Perl.</source>
          <target state="translated">이 파일에는 Stratus OpenVOS 운영 체제에서 perl을 빌드하기위한 참고 사항이 포함되어 있습니다. Perl은 많은 시스템에서 널리 사용되는 스크립팅 또는 매크로 언어입니다. Perl에 관한 많은 훌륭한 책들에 대해서는 &lt;a href=&quot;perlbook&quot;&gt;perlbook&lt;/a&gt; 을 보십시오 .</target>
        </trans-unit>
        <trans-unit id="1b8ecba533b9b274e408d86f1a2361d08ce45153" translate="yes" xml:space="preserve">
          <source>This file contains the documentation of the perl public API generated by</source>
          <target state="translated">이 파일에는 다음에 의해 생성 된 perl public API의 문서가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="772ef66d2f091024ffe5331d4173bb5adc436597" translate="yes" xml:space="preserve">
          <source>This file gives instructions for building Perl 5.7 and above, and also Perl modules for NetWare. Before you start, you may want to read the README file found in the top level directory into which the Perl source code distribution was extracted. Make sure you read and understand the terms under which the software is being distributed.</source>
          <target state="translated">이 파일은 Perl 5.7 이상을 빌드하기위한 지침과 NetWare 용 Perl 모듈을 제공합니다. 시작하기 전에 Perl 소스 코드 분배가 추출 된 최상위 디렉토리에있는 README 파일을 읽을 수 있습니다. 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ec203908c78957c98ea92f12965f186f5810be8" translate="yes" xml:space="preserve">
          <source>This file gives the instructions for building Perl5.8 and above for WinCE. Please read and understand the terms under which this software is distributed.</source>
          <target state="translated">이 파일은 WinCE 용 Perl5.8 이상 빌드 지침을 제공합니다. 이 소프트웨어가 배포되는 조건을 읽고 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="cf6acf338e7fac3c001977fe9f2038807c39d850" translate="yes" xml:space="preserve">
          <source>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, &lt;b&gt;they are not for use in extensions&lt;/b&gt;!</source>
          <target state="translated">이 파일은 Perl의 내부 문서 형식을 사용하여 문서화되었지만 Perl API의 일부로 표시되지 않은 Perl 인터프리터 기능의 자동 생성 문서입니다. 즉, &lt;b&gt;확장에 사용되지 않습니다&lt;/b&gt; !</target>
        </trans-unit>
        <trans-unit id="37bc1fa4735275726caf451da3d6c18e093591a1" translate="yes" xml:space="preserve">
          <source>This file lists everyone who's contributed to Perl. If you submit a patch, you should add your name to this file as part of the patch.</source>
          <target state="translated">이 파일은 Perl에 기여한 모든 사람을 나열합니다. 패치를 제출하면 패치의 일부로이 파일에 이름을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfb66abe74ae898df9c2dbe0e11c53cf1576bcaf" translate="yes" xml:space="preserve">
          <source>This file resides somewhere deep in the location you installed your perl library, find it out by</source>
          <target state="translated">이 파일은 펄 라이브러리를 설치 한 위치의 어딘가에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb5bba8cb2fb8c111c0a512a6843cebdb2655ae" translate="yes" xml:space="preserve">
          <source>This file will get parsed, and produce a maybe empty &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array for the current architecture. That will be extended by $BSLOADLIBS, which was computed by ExtUtils::Liblist::ext(). If this array still is empty, we do nothing, else we write a .bs file with an &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array.</source>
          <target state="translated">이 파일은 파싱 되어 현재 아키텍처에 대해 비어있는 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 배열을 생성합니다. ExtUtils :: Liblist :: ext ()에 의해 계산 된 $ BSLOADLIBS로 확장됩니다. 이 배열이 여전히 비어 있으면 아무것도하지 않습니다. 그렇지 않으면 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 배열 로 .bs 파일을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="77507ae6fec16ecb1a49a0d13053514b63919993" translate="yes" xml:space="preserve">
          <source>This filter ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">이 필터는 DBM 파일에 기록 된 모든 데이터가 널 종료되도록합니다. 이는 C 프로그램이 사용하는 DBM 파일과 상호 운용해야하는 perl 스크립트가있는 경우 유용합니다. 상당히 일반적인 문제는 C 애플리케이션이 DBM 파일에 쓸 때 문자열에 종료 널을 포함시키는 것입니다. 이 필터는 C 응용 프로그램이 DBM 파일에 기록 된 모든 데이터를 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="1a16c760c71ffbcc7dbae1135b5e99738b98c9c4" translate="yes" xml:space="preserve">
          <source>This filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">이 필터는 데이터베이스에 기록되기 전에 모든 데이터를 압축하고 읽을 때 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="915eb343b20bf6c5f1c528d637992be8d7bcc44e" translate="yes" xml:space="preserve">
          <source>This final example contains both ordinary and pattern code expressions. It detects whether a binary string &lt;code&gt;1101010010001...&lt;/code&gt; has a Fibonacci spacing 0,1,1,2,3,5,... of the &lt;code&gt;'1'&lt;/code&gt;'s:</source>
          <target state="translated">이 마지막 예제에는 일반 및 패턴 코드 표현식이 모두 포함되어 있습니다. 이진 문자열 &lt;code&gt;1101010010001...&lt;/code&gt; 에 &lt;code&gt;'1'&lt;/code&gt; 의 피보나치 간격이 0,1,1,2,3,5, ... 인지 여부를 감지합니다 .</target>
        </trans-unit>
        <trans-unit id="ff45bc95d2be91a9f62c2d432c6510d29da26205" translate="yes" xml:space="preserve">
          <source>This final example contains both ordinary and pattern code expressions. It detects whether a binary string &lt;code&gt;1101010010001...&lt;/code&gt; has a Fibonacci spacing 0,1,1,2,3,5,... of the &lt;code&gt;1&lt;/code&gt; 's:</source>
          <target state="translated">이 마지막 예제에는 일반 및 패턴 코드 표현식이 모두 포함되어 있습니다. 이진 문자열 여부를 감지 &lt;code&gt;1101010010001...&lt;/code&gt; 피보나치가의 ..., 0,1,1,2,3,5 간격했다 &lt;code&gt;1&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="4dfd467bd9194695ec17711b8f65393c531e176b" translate="yes" xml:space="preserve">
          <source>This finishes implementation of a primitive symbolic calculator in 50 lines of Perl code. Since the numeric values of subexpressions are not cached, the calculator is very slow.</source>
          <target state="translated">이것으로 50 줄의 Perl 코드로 원시 기호 계산기의 구현을 마칩니다. 하위 표현식의 숫자 값이 캐시되지 않으므로 계산기가 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="432b2214978806677872de825506327a25e6c8da" translate="yes" xml:space="preserve">
          <source>This first trivial example will call a Perl subroutine,</source>
          <target state="translated">이 첫 번째 간단한 예제는 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7a73aefe087a5a3cae31e7663f998536b4f2db63" translate="yes" xml:space="preserve">
          <source>This flag has 2 effects:</source>
          <target state="translated">이 플래그에는 2 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa34b07e62e9949dde06d4f7ad8cedfd3b7de3f" translate="yes" xml:space="preserve">
          <source>This flag has an important effect on Perl's treatment of the string: if UTF-8 data is not properly distinguished, regular expressions, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; and other string handling operations will have undesirable (wrong) results.</source>
          <target state="translated">이 플래그는 Perl의 문자열 처리에 중요한 영향을 미칩니다. UTF-8 데이터가 제대로 구별되지 않으면 정규식, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 및 기타 문자열 처리 조작이 바람직하지 않은 (잘못된) 결과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c9629c786021db29caecd61cf856ee5127e01fba" translate="yes" xml:space="preserve">
          <source>This flag has an important effect on Perl's treatment of the string: if UTF-8 data is not properly distinguished, regular expressions, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;substr&lt;/code&gt; and other string handling operations will have undesirable (wrong) results.</source>
          <target state="translated">이 플래그는 Perl의 문자열 처리에 중요한 영향을 미칩니다. UTF-8 데이터가 제대로 구별되지 않으면 정규식, &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;substr&lt;/code&gt; 및 기타 문자열 처리 작업이 바람직하지 않은 (잘못된) 결과를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="a176da4e70ce1acc6541f9df33982a6b757fc468" translate="yes" xml:space="preserve">
          <source>This flag is set to true if the API is tracing through subroutine calls.</source>
          <target state="translated">API가 서브 루틴 호출을 통해 추적하는 경우이 플래그가 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="201e9afdfb172b15efef161ffd6b8fd219c793ac" translate="yes" xml:space="preserve">
          <source>This flag is supported in Sun WorkShop Compilers 5.0 and onwards (now marketed under the name Forte) when used on Solaris 7 or later on UltraSparc systems.</source>
          <target state="translated">이 플래그는 UltraSparc 시스템의 Solaris 7 이상에서 사용될 때 Sun WorkShop Compilers 5.0 이상 (현재는 Forte라는 이름으로 판매 됨)에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b160cdb384c536dc3f048d4a9c7c790cc3b24bae" translate="yes" xml:space="preserve">
          <source>This flag tells Perl to interpret the supplied string as a vector of integers, one for each character in the string. Perl applies the format to each integer in turn, then joins the resulting strings with a separator (a dot &lt;code&gt;.&lt;/code&gt; by default). This can be useful for displaying ordinal values of characters in arbitrary strings:</source>
          <target state="translated">이 플래그는 Perl에게 제공된 문자열을 문자열의 각 문자마다 하나씩 정수 벡터로 해석하도록 지시합니다. 펄은, 차례로 각각의 정수 포맷을 적용 세퍼레이터 얻어진 문자열을 조인 (도트 &lt;code&gt;.&lt;/code&gt; 기본값). 임의의 문자열로 문자의 서수 값을 표시하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f881a1e5bd78a37c63f807e7bc9fe5e3e92898af" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; is now special-cased solely in the parser. RXf_SPLIT is still #defined, so you can test for it. This is how it used to work:</source>
          <target state="translated">이 플래그는 perl 5.18.0에서 제거되었습니다. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 은 (는) 이제 구문 분석기에서만 특수한 경우입니다. RXf_SPLIT은 여전히 ​​#defined이므로 테스트 할 수 있습니다. 이것이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="149e3a434b8c79c17c15e7dd1bfeeec79cac366d" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. &lt;code&gt;split ' '&lt;/code&gt; is now special-cased solely in the parser. RXf_SPLIT is still #defined, so you can test for it. This is how it used to work:</source>
          <target state="translated">이 플래그는 perl 5.18.0에서 제거되었습니다. &lt;code&gt;split ' '&lt;/code&gt; 은 이제 파서에서만 특수한 경우입니다. RXf_SPLIT는 여전히 #defined이므로 테스트 할 수 있습니다. 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d833b586ef20499906978002bb10914b6b58edd4" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. It is still #defined, so you can set it, but doing so will have no effect. This is how it used to work:</source>
          <target state="translated">이 플래그는 perl 5.18.0에서 제거되었습니다. 여전히 #defined이므로 설정할 수 있지만 아무런 효과가 없습니다. 이것이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="dc95d1efdd1713c3cca7c0b3c4bdefdda1fde08a" translate="yes" xml:space="preserve">
          <source>This flag, if given, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 플래그가 지정되면 앵커 텍스트가 제공 될 때 URL을 억제하므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 로 형식화됩니다 . 이것은 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c97210a38063d077fd5dfe5b874dc5c9ec99795" translate="yes" xml:space="preserve">
          <source>This flag, if given, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt;. This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 플래그가 주어지면 앵커 텍스트가 주어질 때 URL을 억제하므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 형식으로 지정됩니다 . 이렇게하면 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0dbb07c9842c891feb553c44a3898bc7209b8ed" translate="yes" xml:space="preserve">
          <source>This flag, used in the length slot of hash entries and magic structures, specifies the structure contains an &lt;code&gt;SV*&lt;/code&gt; pointer where a &lt;code&gt;char*&lt;/code&gt; pointer is to be expected. (For information only--not to be used).</source>
          <target state="translated">해시 항목 및 매직 구조의 길이 슬롯에 사용되는이 플래그는 구조체 에 &lt;code&gt;char*&lt;/code&gt; 포인터가 필요한 &lt;code&gt;SV*&lt;/code&gt; 포인터가 포함되도록 지정합니다 . 정보 용으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6617f4f7a980e05c925f274014a2ec6bb8531a4e" translate="yes" xml:space="preserve">
          <source>This fools Perl into not matching the ligatures.</source>
          <target state="translated">이로 인해 Perl이 합자와 일치하지 않도록 속입니다.</target>
        </trans-unit>
        <trans-unit id="bbab49144d33f97cf4910c662167d2afe655dc3e" translate="yes" xml:space="preserve">
          <source>This forces the &lt;code&gt;AUTOLOAD&lt;/code&gt; for &lt;code&gt;SO_LINGER&lt;/code&gt; to take place before SO_LINGER is encountered later in &lt;code&gt;My&lt;/code&gt; package.</source>
          <target state="translated">이 힘은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대한 &lt;code&gt;SO_LINGER&lt;/code&gt; 는 SO_LINGER가 나중에 발생하기 전에 장소를 취할 &lt;code&gt;My&lt;/code&gt; 패키지.</target>
        </trans-unit>
        <trans-unit id="b15b4ab4a7170566f869487aafa326bf0ce9445d" translate="yes" xml:space="preserve">
          <source>This forces the short and the long members to be little-endian, and is just fine if you don't have too many struct members. But we could also use the byte-order modifier on a group and write the following:</source>
          <target state="translated">이렇게하면 짧은 멤버와 긴 멤버가 리틀 엔디안이되며 너무 많은 구조체 멤버가 없으면 괜찮습니다. 그러나 그룹에서 바이트 순서 수정자를 사용하여 다음을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="de46dfb71b9966e3e11ff89ec998704c30ddf969" translate="yes" xml:space="preserve">
          <source>This form guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvIV&lt;/code&gt;.</source>
          <target state="translated">이 양식은 &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장합니다 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면 더 효율적인 &lt;code&gt;SvIV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="319008616c679e138429b5bd14ecb2239c8ff654" translate="yes" xml:space="preserve">
          <source>This form guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvNV&lt;/code&gt;.</source>
          <target state="translated">이 양식은 &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장합니다 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면 더 효율적인 &lt;code&gt;SvNV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="748f2a390c701e3448b1a19dc8793fdea5346721" translate="yes" xml:space="preserve">
          <source>This form guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvTRUE&lt;/code&gt;.</source>
          <target state="translated">이 양식은 &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장합니다 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면 더 효율적인 &lt;code&gt;SvTRUE&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad206f71367b2c3bbee0a58f60190a76076a07f1" translate="yes" xml:space="preserve">
          <source>This form guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvUV&lt;/code&gt;.</source>
          <target state="translated">이 양식은 &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장합니다 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면 더 효율적인 &lt;code&gt;SvUV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc4f84b6cad0b1ebbd95d56cd730e6ae5313c6f1" translate="yes" xml:space="preserve">
          <source>This form of the pragma allows essentially seamless handling of locales with Unicode. The collation order will be by Unicode code point order. &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt; can be used to get Unicode rules collation.</source>
          <target state="translated">이 형식의 pragma를 사용하면 유니 코드를 사용하여 기본적으로 로케일을 원활하게 처리 할 수 ​​있습니다. 데이터 정렬 순서는 유니 코드 코드 포인트 순서입니다. &lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 는 유니 코드 규칙 데이터 정렬을 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f05df3e2fa93dbc3244d6e8aa705438a4243e3" translate="yes" xml:space="preserve">
          <source>This form of the pragma allows essentially seamless handling of locales with Unicode. The collation order will be by Unicode code point order. It is strongly recommended that when you need to order and sort strings that you use the standard module &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; which gives much better results in many instances than you can get with the old-style locale handling.</source>
          <target state="translated">이 형식의 pragma는 기본적으로 유니 코드를 사용하여 로캘을 원활하게 처리 할 수 ​​있도록합니다. 데이터 정렬 순서는 유니 코드 코드 포인트 순서입니다. 표준 모듈 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 를 사용하여 문자열을 정렬하고 정렬해야하는 경우 구식 로케일 처리에서 얻을 수있는 것보다 훨씬 더 나은 결과를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cdc9f2e82b133c2773ec210a8571ca6b553d5115" translate="yes" xml:space="preserve">
          <source>This formality is needed when properties are not binary; that is, if they can take on more values than just &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; . For example, the &lt;code&gt;Bidi_Class&lt;/code&gt; property (see &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidirectional Character Types&lt;/a&gt; below), can take on several different values, such as &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; , and others. To match these, one needs to specify both the property name (&lt;code&gt;Bidi_Class&lt;/code&gt; ), AND the value being matched against (&lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</source>
          <target state="translated">이 형식은 속성이 이진이 아닌 경우에 필요합니다. 즉, &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 보다 많은 값을 사용할 수있는 경우 입니다. 예를 들어 &lt;code&gt;Bidi_Class&lt;/code&gt; 속성 (아래의 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;양방향 문자 유형&lt;/a&gt; 참조)은 &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; 등과 같은 여러 가지 다른 값을 사용할 수 있습니다 . 이를 일치 시키려면 속성 이름 ( &lt;code&gt;Bidi_Class&lt;/code&gt; )과 일치하는 값 ( &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6c29258146f5f20ab2294915f5c82cbdb06ae407" translate="yes" xml:space="preserve">
          <source>This formality is needed when properties are not binary; that is, if they can take on more values than just &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. For example, the &lt;code&gt;Bidi_Class&lt;/code&gt; property (see &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;&quot;Bidirectional Character Types&quot;&lt;/a&gt; below), can take on several different values, such as &lt;code&gt;Left&lt;/code&gt;, &lt;code&gt;Right&lt;/code&gt;, &lt;code&gt;Whitespace&lt;/code&gt;, and others. To match these, one needs to specify both the property name (&lt;code&gt;Bidi_Class&lt;/code&gt;), AND the value being matched against (&lt;code&gt;Left&lt;/code&gt;, &lt;code&gt;Right&lt;/code&gt;,</source>
          <target state="translated">이 형식은 속성이 바이너리가 아닐 때 필요합니다. 즉, &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 보다 더 많은 값을 취할 수있는 경우 입니다. 예를 들어 &lt;code&gt;Bidi_Class&lt;/code&gt; 속성 (아래의 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;&quot;양방향 문자 유형&quot;&lt;/a&gt; 참조)은 &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; 등과 같은 여러 다른 값을 가질 수 있습니다 . 이들을 일치 시키려면 속성 이름 ( &lt;code&gt;Bidi_Class&lt;/code&gt; )과 일치하는 값 ( &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="e6b05c6c31caa81ea454aca24f6c1d1188903888" translate="yes" xml:space="preserve">
          <source>This formatting code is syntactically simple, but semantically complex. What it means is that each space in the printable content of this code signifies a non-breaking space.</source>
          <target state="translated">이 형식화 코드는 구문 상 단순하지만 의미 상 복잡합니다. 의미하는 것은이 코드의 인쇄 가능한 내용의 각 공간이 비 공백 공간을 의미한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d77c232922b63b050101d5932a616e0ed5728461" translate="yes" xml:space="preserve">
          <source>This free toolkit contains the same compiler and linker that ship with Visual C++ .NET 2003 Professional, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">이 무료 툴킷에는 Visual C ++ .NET 2003 Professional과 함께 제공되는 것과 동일한 컴파일러 및 링커가 포함되어 있지만 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c5a6423b0a65bc38b33d48cf33a85a24bf291a8" translate="yes" xml:space="preserve">
          <source>This free version of Visual C++ 2005 Professional contains the same compiler and linker that ship with the full version, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">이 무료 버전의 Visual C ++ 2005 Professional에는 정식 버전과 함께 제공되는 것과 동일한 컴파일러 및 링커가 포함되어 있지만 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb31e64d6cc8d22ff5f69477b5a67be71c8242ad" translate="yes" xml:space="preserve">
          <source>This function (not exported) lets you reset the sequence numbers (note that they're numbered arbitrarily, their goal being to be human readable). Its purpose is mostly to support testing, i.e. to compare the concise output from two identical anonymous subroutines (but different instances). Without the reset, B::Concise, seeing that they're separate optrees, generates different sequence numbers in the output.</source>
          <target state="translated">이 기능 (내보내기 안 함)을 사용하면 시퀀스 번호를 재설정 할 수 있습니다 (순서 번호는 임의로 번호가 매겨져 있으며 목표는 사람이 읽을 수있는 것입니다). 그 목적은 주로 테스트를 지원하는 것입니다. 즉 두 개의 동일한 익명 서브 루틴 (그러나 다른 인스턴스)의 간결한 결과를 비교하는 것입니다. 재설정하지 않고 B :: Concise는 별도의 optree임을보고 출력에서 ​​다른 시퀀스 번호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1f57c1588a54710c722f648f2f8000721f89bfc3" translate="yes" xml:space="preserve">
          <source>This function accepts any UV as input. To forbid or warn on non-Unicode code points, or those that may be problematic, see &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">이 기능은 모든 UV를 입력으로 받아들입니다. 비 유니 코드 코드 포인트 또는 문제가있는 코드 포인트를 금지하거나 경고하려면 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f691de76bb17beb8b2cbb40c7e4e7d2820166ad" translate="yes" xml:space="preserve">
          <source>This function accepts any code point from 0..&lt;code&gt;IV_MAX&lt;/code&gt; as input. &lt;code&gt;IV_MAX&lt;/code&gt; is typically 0x7FFF_FFFF in a 32-bit word.</source>
          <target state="translated">이 함수는 0 .. &lt;code&gt;IV_MAX&lt;/code&gt; 의 모든 코드 포인트를 입력으로받습니다. &lt;code&gt;IV_MAX&lt;/code&gt; 는 일반적으로 32 비트 워드에서 0x7FFF_FFFF 입니다.</target>
        </trans-unit>
        <trans-unit id="bcc1cbc95f41c6ca77822a286a66032b96a97b23" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments, adds them, and prints their sum. Its return value is the numuber of characters it printed, but you probably didn't care about that. But &lt;code&gt;Memoize&lt;/code&gt; doesn't understand that. If you memoize this function, you will get the result you expect the first time you ask it to print the sum of 2 and 3, but subsequent calls will return 1 (the return value of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;) without actually printing anything.</source>
          <target state="translated">이 함수는 두 개의 인수를 허용하고 추가 한 다음 합계를 인쇄합니다. 반환 값은 인쇄 된 문자의 숫자이지만, 신경 쓰지 않았을 것입니다. 그러나 &lt;code&gt;Memoize&lt;/code&gt; 는 그것을 이해하지 못합니다. 이 함수를 기억하면 처음에 2와 3의 합계를 인쇄하도록 요청할 때 예상되는 결과를 얻을 수 있지만 후속 호출은 실제로 인쇄하지 않고 1 ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 반환 값)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b9fe9891651290ed3a76f635027aadcf27a76a" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments, adds them, and prints their sum. Its return value is the numuber of characters it printed, but you probably didn't care about that. But &lt;code&gt;Memoize&lt;/code&gt; doesn't understand that. If you memoize this function, you will get the result you expect the first time you ask it to print the sum of 2 and 3, but subsequent calls will return 1 (the return value of &lt;code&gt;print&lt;/code&gt;) without actually printing anything.</source>
          <target state="translated">이 함수는 두 개의 인수를 받아 추가하고 합계를 인쇄합니다. 반환 값은 인쇄 된 문자 수이지만 아마 신경 쓰지 않았을 것입니다. 그러나 &lt;code&gt;Memoize&lt;/code&gt; 는 그것을 이해하지 못합니다. 이 함수를 메모하면 2와 3의 합계를 인쇄하도록 요청했을 때 예상 한 결과를 얻을 수 있지만, 후속 호출은 실제로 아무것도 인쇄하지 않고 1 ( &lt;code&gt;print&lt;/code&gt; 의 반환 값)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb8ff2980a7098008fca7a80ae815b328b64b56a" translate="yes" xml:space="preserve">
          <source>This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options have long names instead of single letters, and are introduced with a double dash &quot;--&quot;. Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">이 함수는 GNU 확장을 사용하여 명령 행 옵션의 POSIX 구문을 준수합니다. 일반적으로 이는 옵션이 단일 문자 대신 긴 이름을 가지며 이중 대시 &quot;-&quot;로 소개됨을 의미합니다. 보다 전통적인 단일 문자 접근 방식과 마찬가지로 명령 줄 옵션 번들 지원이 제공되지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecc6287822eead2b98d6d43c71be2ea5a869ec7f" translate="yes" xml:space="preserve">
          <source>This function allows one to violate the abstraction of variables and get or set the refcount of a variable, and in generally is really only useful in code that is testing refcount behavior.</source>
          <target state="translated">이 함수는 변수의 추상화를 위반하고 변수의 refcount를 가져 오거나 설정할 수 있도록합니다. 일반적으로 in은 refcount 동작을 테스트하는 코드에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e55f008cc8679ba993acc354409c0dcb4424edfc" translate="yes" xml:space="preserve">
          <source>This function applies some optimisations to the optree in top-down order. It is called before the peephole optimizer, which processes ops in execution order. Note that finalize_optree() also does a top-down scan, but is called *after* the peephole optimizer.</source>
          <target state="translated">이 함수는 하향식 순서로 optree에 일부 최적화를 적용합니다. 실행 순서에 따라 ops를 처리하는 peephole optimizer보다 먼저 호출됩니다. finalize_optree ()도 하향식 스캔을 수행하지만 엿보기 최적화 프로그램이 * 후 * 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7b0b646247c6327383124f41d35ef99ac00aaf8b" translate="yes" xml:space="preserve">
          <source>This function assigns the prototype of the named core function to &lt;code&gt;sv&lt;/code&gt; , or to a new mortal SV if &lt;code&gt;sv&lt;/code&gt; is NULL. It returns the modified &lt;code&gt;sv&lt;/code&gt; , or NULL if the core function has no prototype. &lt;code&gt;code&lt;/code&gt; is a code as returned by &lt;code&gt;keyword()&lt;/code&gt; . It must not be equal to 0.</source>
          <target state="translated">이 함수는 명명 된 핵심 함수의 프로토 타입을 &lt;code&gt;sv&lt;/code&gt; 에 할당 하거나 &lt;code&gt;sv&lt;/code&gt; 가 NULL 인 경우 새로운 필적 SV에 할당합니다 . 수정 된 &lt;code&gt;sv&lt;/code&gt; 또는 코어 함수에 프로토 타입이없는 경우 NULL을 리턴합니다. &lt;code&gt;code&lt;/code&gt; 는 &lt;code&gt;keyword()&lt;/code&gt; 반환 한 코드 입니다. 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="d51d61d384048f31db1722374f5b372c545260fb" translate="yes" xml:space="preserve">
          <source>This function assigns the prototype of the named core function to &lt;code&gt;sv&lt;/code&gt;, or to a new mortal SV if &lt;code&gt;sv&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;. It returns the modified &lt;code&gt;sv&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if the core function has no prototype. &lt;code&gt;code&lt;/code&gt; is a code as returned by &lt;code&gt;keyword()&lt;/code&gt;. It must not be equal to 0.</source>
          <target state="translated">이 함수는 명명 된 핵심 함수의 프로토 타입을 &lt;code&gt;sv&lt;/code&gt; 에 할당 하거나 &lt;code&gt;sv&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 새 필멸 SV에 할당합니다 . 수정 된 &lt;code&gt;sv&lt;/code&gt; 를 반환 하거나 핵심 함수에 프로토 타입이없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 . &lt;code&gt;code&lt;/code&gt; 는 &lt;code&gt;keyword()&lt;/code&gt; 의해 반환 된 코드 입니다. 0과 같지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2917be492c6121d8b92df9a8721147dc2a9433ef" translate="yes" xml:space="preserve">
          <source>This function bears the same relationship to the CORE function &lt;code&gt;sysopen&lt;/code&gt; as &lt;code&gt;vmsopen&lt;/code&gt; does to &lt;code&gt;open&lt;/code&gt;. Its first three arguments are the name, access flags, and permissions for the file. Like &lt;code&gt;vmsopen&lt;/code&gt;, it takes up to 8 additional string arguments which specify file characteristics. Its return value is identical to that of &lt;code&gt;vmsopen&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;vmsopen&lt;/code&gt; 이 &lt;code&gt;open&lt;/code&gt; 위해하는 것처럼 CORE 함수 &lt;code&gt;sysopen&lt;/code&gt; 과 동일한 관계 를가 집니다 . 처음 세 개의 인수는 파일에 대한 이름, 액세스 플래그 및 권한입니다. &lt;code&gt;vmsopen&lt;/code&gt; 과 마찬가지로 파일 특성을 지정하는 최대 8 개의 추가 문자열 인수를 사용합니다. 반환 값은 &lt;code&gt;vmsopen&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3df224a5aaa78b74e3701bf43347f5a463966d33" translate="yes" xml:space="preserve">
          <source>This function behaves the same way that scalar(%hash) behaved prior to Perl 5.25. Specifically if the hash is tied, then it calls the SCALAR tied hash method, if untied then if the hash is empty it return 0, otherwise it returns a string containing the number of used buckets in the hash, followed by a slash, followed by the total number of buckets in the hash.</source>
          <target state="translated">이 함수는 Perl 5.25 이전에 스칼라 (% hash)가 작동했던 것과 동일한 방식으로 작동합니다. 특히 해시가 묶인 경우 SCALAR 묶인 해시 메서드를 호출하고, 묶이지 않으면 해시가 비어 있으면 0을 반환하고, 그렇지 않으면 해시에서 사용 된 버킷 수를 포함하는 문자열을 반환하고 그 뒤에 슬래시를 입력 한 다음 해시의 총 버킷 수입니다.</target>
        </trans-unit>
        <trans-unit id="14c8f38efd4e3476b651d12afb352ad397950bd5" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일과 같이 다양한 pragma에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8378e0b6c78c094cc27c1f818ab7aa1e8291a68d" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일과 같이 다양한 pragma에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="bdf27edd1f3ed7033638bb2d9262acb5626e2202" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">이 기능은 내 각종 프라그 하에서 동일한 방법으로 동작하는 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; 로, &lt;a href=&quot;#lc&quot;&gt;LC는&lt;/a&gt; 수행의 단일 제외 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 의 범위 내 라틴 대문자 SHARP S (U + 1E9E)의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . 이 문자의 접는 문자는 일반적으로 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 이지만 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 섹션에 설명 된대로 255/256 경계를 넘는 경우 변경은 로케일에서 문제가되므로 금지됩니다. 따라서 로케일 아래의이 함수는 대신 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; 문자열을 리턴합니다.이 문자는 라틴 문자 중 LONG S입니다. 해당 문자 자체는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 로 접 힙니다., 둘 중 하나의 문자열은 접을 때 단일 U + 1E9E와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ceceba872ecbef53671fa2bb946f4d1ad71c1d4b" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">이 기능은 내 각종 프라그 하에서 동일한 방법으로 동작하는 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; 로, &lt;a href=&quot;lc&quot;&gt;LC는&lt;/a&gt; 수행의 단일 제외 &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 의 범위 내 라틴 대문자 SHARP S (U + 1E9E)의 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . 이 문자의 접는 문자는 일반적으로 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 이지만 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 섹션에 설명 된대로 255/256 경계를 넘는 경우 변경은 로케일에서 문제가되므로 금지됩니다. 따라서 로케일 아래의이 함수는 대신 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; 문자열을 리턴합니다.이 문자는 라틴 문자 중 LONG S입니다. 해당 문자 자체는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 로 접 힙니다., 둘 중 하나의 문자열은 접을 때 단일 U + 1E9E와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cd562e4f2bd434b520cfc039a6795314edcac57" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmas, such as in a locale, as &lt;a href=&quot;#lc-EXPR&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lc-EXPR&quot;&gt; &lt;code&gt;lc&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 로케일에서와 같이 다양한 pragma에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="c0500dee2324da9704afaaade800515e656abcf2" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmas, such as within &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;#lc-EXPR&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt; does, with the single exception of &lt;a href=&quot;#fc-EXPR&quot;&gt;&lt;code&gt;fc&lt;/code&gt;&lt;/a&gt; of</source>
          <target state="translated">이 기능은 내 다양한 프라 그마, 아래 같은 방식으로 동작합니다 &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; &lt;/a&gt; 로, &lt;a href=&quot;#lc-EXPR&quot;&gt; &lt;code&gt;lc&lt;/code&gt; &lt;/a&gt; 수행의 하나를 제외하고 &lt;a href=&quot;#fc-EXPR&quot;&gt; &lt;code&gt;fc&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="8e622f55ce5e0f86a0059d75a25d61e3419fef9f" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 와 같이 로케일과 같이 다양한 pragmata에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a06484c004f74f9c8853b354936ff3f59e84875a" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 와 같이 로케일과 같이 다양한 pragmata에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d07fce4b805ea45a197ef238496fb301033d2545" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">이 함수는 변수를 구현할 패키지 클래스에 변수를 바인딩합니다. VARIABLE은 매혹 될 변수의 이름입니다. CLASSNAME은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. 추가 인수는 클래스의 적절한 생성자 메서드 ( &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; 또는 &lt;code&gt;TIEHASH&lt;/code&gt; 의미 )에 전달됩니다. 일반적으로 이들은 C의 &lt;code&gt;dbm_open()&lt;/code&gt; 함수에 전달 될 수있는 것과 같은 인수 입니다. 생성자가 리턴 한 오브젝트도 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되므로 CLASSNAME의 다른 메소드에 액세스하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c3bc0e801ef7f17e4d79ee445885b2be27f25c2b" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">이 함수는 변수를 구현할 패키지 클래스에 변수를 바인딩합니다. VARIABLE은 매혹 될 변수의 이름입니다. CLASSNAME은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. 추가 인수는 클래스의 적절한 생성자 메서드 ( &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; 또는 &lt;code&gt;TIEHASH&lt;/code&gt; 의미 )에 전달됩니다. 일반적으로 이들은 C의 &lt;code&gt;dbm_open()&lt;/code&gt; 함수에 전달 될 수있는 것과 같은 인수 입니다. 생성자가 리턴 한 오브젝트도 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되므로 CLASSNAME의 다른 메소드에 액세스하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6ec28b6239b28c7a96697e70b1eb97107ed2b3c3" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt;, &lt;code&gt;TIEHANDLE&lt;/code&gt;, &lt;code&gt;TIEARRAY&lt;/code&gt;, or &lt;code&gt;TIEHASH&lt;/code&gt;). Typically these are arguments such as might be passed to the &lt;a href=&quot;http://man.he.net/man3/dbm_open&quot;&gt;dbm_open(3)&lt;/a&gt; function of C. The object returned by the constructor is also returned by the &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">이 함수는 변수에 대한 구현을 제공 할 패키지 클래스에 변수를 바인딩합니다. VARIABLE은 부여 할 변수의 이름입니다. CLASSNAME은 올바른 유형의 오브젝트를 구현하는 클래스의 이름입니다. 추가 인수는 클래스의 적절한 생성자 메서드 ( &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; 또는 &lt;code&gt;TIEHASH&lt;/code&gt; 의미 )에 전달됩니다. 일반적으로 C의 &lt;a href=&quot;http://man.he.net/man3/dbm_open&quot;&gt;dbm_open (3)&lt;/a&gt; 함수에 전달 될 수있는 인수 입니다. 생성자에 의해 반환 된 객체는 &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되기 때문에 CLASSNAME의 다른 메서드에 액세스하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="174d0316fff2fa450076f65b703c67678039564b" translate="yes" xml:space="preserve">
          <source>This function call is functionally identical to:</source>
          <target state="translated">이 함수 호출은 다음과 기능적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a37cdb55fc25f73489ad091a40f3985d29053240" translate="yes" xml:space="preserve">
          <source>This function can cause reliability issues if you are likely to pass in empty strings that are not null terminated, because it will run strlen on the string and potentially run past valid memory.</source>
          <target state="translated">이 함수는 문자열에서 strlen을 실행하고 잠재적으로 유효한 메모리를 지나서 실행되기 때문에 null로 끝나지 않은 빈 문자열을 전달할 가능성이있는 경우 안정성 문제를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5132f8607896a5505c904bfd8891d2794b3208e8" translate="yes" xml:space="preserve">
          <source>This function can take a hash of options:</source>
          <target state="translated">이 함수는 해시 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cccb23235ebb22439bd8ff2e5a998bf5aa962e" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">이 함수는 전체 배열이나 해시에서 사용되어 몇 개의 요소가 있는지 알아낼 수 없습니다. 이를 위해 각각 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ba6657c5fa298f8f6fa2444117335de3f819a9a" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">이 함수는 전체 배열이나 해시에서 사용되어 몇 개의 요소가 있는지 알아낼 수 없습니다. 이를 위해 각각 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d80cd513c1eb2f06188d940dc75b413064ad04e" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;scalar @array&lt;/code&gt; and &lt;code&gt;scalar keys %hash&lt;/code&gt;, respectively.</source>
          <target state="translated">이 함수는 전체 배열이나 해시에서 얼마나 많은 요소가 있는지 알아내는 데 사용할 수 없습니다. 이를 위해 &lt;code&gt;scalar @array&lt;/code&gt; 및 &lt;code&gt;scalar keys %hash&lt;/code&gt; 를 각각 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d46229c4291d3a22177a19f68cea8c921f320b75" translate="yes" xml:space="preserve">
          <source>This function causes Perl to wait for the completion of an I/O operation on the file handle specified as its argument. It is used with handles opened for asynchronous I/O, and performs its task by calling the CRTL routine fwait().</source>
          <target state="translated">이 함수는 Perl이 인수로 지정된 파일 핸들에서 I / O 작업이 완료 될 때까지 기다리도록합니다. 비동기 I / O를 위해 열린 핸들과 함께 사용되며 CRTL 루틴 fwait ()를 호출하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="118dd1a89ee26e341a24a616a4886c6624f3f97c" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">이 기능은 즉시 코어 덤프를 발생시킵니다. &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-u&lt;/b&gt; 명령 행 스위치 도 참조하십시오 . 기본적으로 이것은 프로그램 시작시 모든 변수를 초기화 한 후 &lt;b&gt;undump&lt;/b&gt; 프로그램 (제공되지 않음)을 사용하여 코어 덤프를 실행 가능한 이진 파일로 전환 할 수 있습니다. 새로운 바이너리가 실행될 때 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL ( &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 겪는 모든 제한 사항)을 실행하여 시작합니다 . 코어 덤프와 환생의 개입으로 생각하십시오. 경우 &lt;code&gt;LABEL&lt;/code&gt; 이 생략 상단에서 프로그램을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;Perl 5.18.0부터 사용 가능한 form은 런타임시 이름을 계산할 수있게하며 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2644b0d090106df2bac79cc1278fe935e270aa17" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">이 기능은 즉시 코어 덤프를 발생시킵니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-u&lt;/b&gt; 명령 행 스위치 도 참조하십시오 . 기본적으로 이것은 프로그램 시작시 모든 변수를 초기화 한 후 &lt;b&gt;undump&lt;/b&gt; 프로그램 (제공되지 않음)을 사용하여 코어 덤프를 실행 가능한 이진 파일로 전환 할 수 있습니다. 새로운 바이너리가 실행될 때 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL ( &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 겪는 모든 제한 사항)을 실행하여 시작합니다 . 코어 덤프와 환생의 개입으로 생각하십시오. 경우 &lt;code&gt;LABEL&lt;/code&gt; 이 생략 상단에서 프로그램을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;Perl 5.18.0부터 사용 가능한 form은 런타임시 이름을 계산할 수있게하며 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="26c8dfb8fe670903069c0f17a57b74ae3b1595ea" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;perlrun#-u&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;goto LABEL&lt;/code&gt; (with all the restrictions that &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;dump EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;dump LABEL&lt;/code&gt;.</source>
          <target state="translated">이 기능은 즉각적인 코어 덤프를 발생시킵니다. 동일한 작업을 수행하는 &lt;a href=&quot;perlrun#-u&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-u&lt;/b&gt; 명령 줄 스위치 도 참조하십시오 . 주로 이것은 프로그램 시작시 모든 변수를 초기화 한 후 &lt;b&gt;undump&lt;/b&gt; 프로그램 (제공되지 않음)을 사용하여 코어 덤프를 실행 가능한 바이너리로 전환 할 수 있도록하기위한 &lt;b&gt;것&lt;/b&gt; 입니다. 새 바이너리가 실행되면 &lt;code&gt;goto LABEL&lt;/code&gt; ( &lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt; 가 겪는 모든 제한 사항 포함)을 실행하여 시작됩니다 . 중간에 코어 덤프와 환생이있는 고토라고 생각하면됩니다. 경우 &lt;code&gt;LABEL&lt;/code&gt; 이 생략 상단에서 프로그램을 다시 시작합니다. &lt;code&gt;dump EXPR&lt;/code&gt; &lt;b&gt;&lt;/b&gt;Perl 5.18.0부터 사용할 수있는 form은 런타임에 이름을 계산할 수 있도록합니다 . 그렇지 않으면 &lt;code&gt;dump LABEL&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bc06b6c797a2d8e55ea244af674579a07a667a16" translate="yes" xml:space="preserve">
          <source>This function causes the contents of stdio buffers for the specified file handle to be flushed. If &lt;code&gt;undef&lt;/code&gt; is used as the argument to &lt;code&gt;flush&lt;/code&gt;, all currently open file handles are flushed. Like the CRTL fflush() routine, it does not flush any underlying RMS buffers for the file, so the data may not be flushed all the way to the disk. &lt;code&gt;flush&lt;/code&gt; returns a true value if successful, and &lt;code&gt;undef&lt;/code&gt; if not.</source>
          <target state="translated">이 함수는 지정된 파일 핸들에 대한 stdio 버퍼의 내용이 플러시되도록합니다. &lt;code&gt;undef&lt;/code&gt; 가 &lt;code&gt;flush&lt;/code&gt; 인수로 사용 되면 현재 열려있는 모든 파일 핸들이 플러시됩니다. CRTL fflush () 루틴과 마찬가지로 파일에 대한 기본 RMS 버퍼를 플러시하지 않으므로 데이터가 디스크로 완전히 플러시되지 않을 수 있습니다. &lt;code&gt;flush&lt;/code&gt; 는 성공하면 참 값을 반환하고 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8630b301b33e076db45af073be1b800df9e17ac" translate="yes" xml:space="preserve">
          <source>This function causes the file handle to be reopened with the CRTL's carriage control processing disabled; its effect is the same as that of the &lt;code&gt;b&lt;/code&gt; access mode in &lt;code&gt;vmsopen&lt;/code&gt;. After the file is reopened, the file pointer is positioned as close to its position before the call as possible (</source>
          <target state="translated">이 함수는 CRTL의 캐리지 제어 처리가 비활성화 된 상태에서 파일 핸들이 다시 열리도록합니다. 그 효과는 &lt;code&gt;vmsopen&lt;/code&gt; 의 &lt;code&gt;b&lt;/code&gt; 액세스 모드와 동일 합니다. 파일이 다시 열리면 파일 포인터는 가능한 한 호출하기 전에 해당 위치에 가깝게 배치됩니다 (</target>
        </trans-unit>
        <trans-unit id="8952b46dfeb17de53351ddf4d21ae7d55c07b2d8" translate="yes" xml:space="preserve">
          <source>This function combines &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; and &lt;code&gt;ccdlflags()&lt;/code&gt; into one.</source>
          <target state="translated">이 함수는 &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; 및 &lt;code&gt;ccdlflags()&lt;/code&gt; 를 하나로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="fdb27a1411185bddb95e30d045e37f8e2d566456" translate="yes" xml:space="preserve">
          <source>This function combines &lt;code&gt;perl_inc()&lt;/code&gt;, &lt;code&gt;ccflags()&lt;/code&gt; and &lt;code&gt;ccdlflags()&lt;/code&gt; into one.</source>
          <target state="translated">이 함수는 &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; 및 &lt;code&gt;ccdlflags()&lt;/code&gt; 를 하나로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="86046dee569875e1ad9a6f7dd87a2c295e238ac4" translate="yes" xml:space="preserve">
          <source>This function considers Perl's extended UTF-8 to be valid. That means that code points above Unicode, surrogates, and non-character code points are considered valid by this function. Use &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; to restrict what code points are considered valid.</source>
          <target state="translated">이 함수는 Perl의 확장 UTF-8이 유효한 것으로 간주합니다. 이는 유니 코드 위의 코드 포인트, 서로 게이트 및 비 문자 코드 포인트가이 함수에 의해 유효한 것으로 간주됨을 의미합니다. 유효한 것으로 간주되는 코드 포인트를 제한 하려면 &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a5339a84b7a169eedebef1ec60274699210a516" translate="yes" xml:space="preserve">
          <source>This function deletes the file named in its argument, returning a true value if successful and &lt;code&gt;undef&lt;/code&gt; if not. It differs from the CORE Perl function &lt;code&gt;unlink&lt;/code&gt; in that it does not try to reset file protection if the original protection does not give you delete access to the file (cf. &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;). In other words, &lt;code&gt;remove&lt;/code&gt; is equivalent to</source>
          <target state="translated">이 함수는 인수에 명명 된 파일을 삭제하고 성공하면 참 값을 반환하고 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다. 원래 보호가 파일에 대한 삭제 액세스를 제공하지 않는 경우 파일 보호를 재설정하지 않는다는 점에서 CORE Perl 기능 링크 &lt;code&gt;unlink&lt;/code&gt; 와 다릅니다 (참조 : &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; ). 즉, &lt;code&gt;remove&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3221a438c3aad48b5c48a805755ad197928b0f99" translate="yes" xml:space="preserve">
          <source>This function detects things that can't be modified, such as &lt;code&gt;$x+1&lt;/code&gt; , and generates errors for them. For example, &lt;code&gt;$x+1 = 2&lt;/code&gt; would cause it to be called with an op of type OP_ADD and a &lt;code&gt;type&lt;/code&gt; argument of OP_SASSIGN.</source>
          <target state="translated">이 함수는 &lt;code&gt;$x+1&lt;/code&gt; 과 같이 수정할 수없는 것을 감지 하여 오류를 생성합니다. 예를 들어 &lt;code&gt;$x+1 = 2&lt;/code&gt; 는 OP_ADD 유형의 op와 OP_SASSIGN의 &lt;code&gt;type&lt;/code&gt; 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="439b917328feb1c4b646d8fdc7cd70b863c018c7" translate="yes" xml:space="preserve">
          <source>This function detects things that can't be modified, such as &lt;code&gt;$x+1&lt;/code&gt;, and generates errors for them. For example, &lt;code&gt;$x+1 = 2&lt;/code&gt; would cause it to be called with an op of type &lt;code&gt;OP_ADD&lt;/code&gt; and a &lt;code&gt;type&lt;/code&gt; argument of &lt;code&gt;OP_SASSIGN&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;$x+1&lt;/code&gt; 과 같이 수정할 수없는 항목을 감지 하고 이에 대한 오류를 생성합니다. 예를 들어, &lt;code&gt;$x+1 = 2&lt;/code&gt; 는 &lt;code&gt;OP_ADD&lt;/code&gt; 유형의 op 및 OP_SASSIGN &lt;code&gt;type&lt;/code&gt; 인수로 &lt;code&gt;OP_SASSIGN&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="42ac83507e6cd72323712112c6adca5c1d64b54a" translate="yes" xml:space="preserve">
          <source>This function differs from &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; only in that the latter returns FALSE if the final few bytes of the string don't form a complete code point.</source>
          <target state="translated">이 함수는 문자열의 마지막 몇 바이트가 완전한 코드 포인트를 형성하지 않는 경우 후자가 FALSE를 반환한다는 점에서만 &lt;code&gt;&lt;a href=&quot;#is_utf8_string_flags&quot;&gt;&quot;is_utf8_string_flags&quot;&lt;/a&gt;&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="50025265ce70752e52bdd20aeddabe5be1d58395" translate="yes" xml:space="preserve">
          <source>This function does not use a typemap. Instead, we declare it as accepting one SV* (scalar) parameter, and returning an SV* value, and we take care of populating these scalars within the code. Because we are only returning one value, we don't need a &lt;code&gt;PPCODE:&lt;/code&gt; directive - instead, we use &lt;code&gt;CODE:&lt;/code&gt; and &lt;code&gt;OUTPUT:&lt;/code&gt; directives.</source>
          <target state="translated">이 함수는 타입 맵을 사용하지 않습니다. 대신, 하나의 SV * (스칼라) 매개 변수를 승인하고 SV * 값을 리턴하는 것으로 선언하고 코드 내에서 이러한 스칼라를 채우는 것을 처리합니다. 하나의 값만 반환하므로 &lt;code&gt;PPCODE:&lt;/code&gt; 지시문이 필요하지 않습니다 . 대신 &lt;code&gt;CODE:&lt;/code&gt; 및 &lt;code&gt;OUTPUT:&lt;/code&gt; 지시문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6180191f0bc721d501520e66b164a9ef20a22d11" translate="yes" xml:space="preserve">
          <source>This function enables/disables error popups associated with hardware errors (Disk not ready etc.) and software exceptions.</source>
          <target state="translated">이 기능은 하드웨어 오류 (디스크 준비 안 됨 등) 및 소프트웨어 예외와 관련된 오류 팝업을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="41bdfd24b44f813aba413307b45bfa39cd26febb" translate="yes" xml:space="preserve">
          <source>This function executes code in &lt;code&gt;INIT&lt;/code&gt; blocks, and then executes the main program. The code to be executed is that established by the prior call to &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt;. If the interpreter's &lt;code&gt;PL_exit_flags&lt;/code&gt; word does not have the &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; flag set, then this function will also execute code in &lt;code&gt;END&lt;/code&gt; blocks. If it is desired to make any further use of the interpreter after calling this function, then &lt;code&gt;END&lt;/code&gt; blocks should be postponed to &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; time by setting that flag.</source>
          <target state="translated">이 함수는 &lt;code&gt;INIT&lt;/code&gt; 블록 에서 코드 를 실행 한 다음 메인 프로그램을 실행합니다. 실행될 코드는 &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; 에 대한 이전 호출에 의해 설정된 코드 입니다. 인터프리터의 &lt;code&gt;PL_exit_flags&lt;/code&gt; 단어에 &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; 플래그가 설정되어 있지 않으면 이 함수는 &lt;code&gt;END&lt;/code&gt; 블록 에서도 코드를 실행합니다 . 이 함수를 호출 한 후 인터프리터를 더 사용하려면 해당 플래그를 설정 하여 &lt;code&gt;END&lt;/code&gt; 블록을 &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; 시간 으로 연기해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9a4b4452d2c9e5e96e8d371d230a62875ce95c48" translate="yes" xml:space="preserve">
          <source>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal &lt;code&gt;ck_&lt;/code&gt;xxx functions and makes the tree thread-safe.</source>
          <target state="translated">이 함수는 optree를 마무리합니다. 완전한 optree가 빌드 된 후 직접 호출되어야합니다. 일반 &lt;code&gt;ck_&lt;/code&gt; xxx 함수 에서는 수행 할 수없는 추가 검사를 수행 하고 트리를 스레드로부터 안전하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="467712b5ef786ba52bfac5af598e2fd6afe41fb8" translate="yes" xml:space="preserve">
          <source>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal ck_xxx functions and makes the tree thread-safe.</source>
          <target state="translated">이 함수는 optree를 마무리합니다. 완전한 optree가 빌드 된 직후에 호출되어야합니다. 일반적인 ck_xxx 함수에서 수행 할 수없는 추가 검사를 수행하고 트리를 스레드로부터 안전하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7cd5d3b31c2df3a00c1280faae47ff4437247a8e" translate="yes" xml:space="preserve">
          <source>This function flushes buffered data for the specified file handle from stdio and RMS buffers all the way to disk. If successful, it returns a true value; otherwise, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">이 함수는 지정된 파일 핸들의 버퍼링 된 데이터를 stdio 및 RMS 버퍼에서 디스크로 플러시합니다. 성공하면 참 값을 반환합니다. 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="529aa240cc0116c0500e7c8811796b1b622bb45e" translate="yes" xml:space="preserve">
          <source>This function has a &lt;code&gt;Perl_&lt;/code&gt; prefix; i.e. it is defined as &lt;code&gt;Perl_av_fetch&lt;/code&gt; .</source>
          <target state="translated">이 함수에는 &lt;code&gt;Perl_&lt;/code&gt; 접두사가 있습니다. 즉, &lt;code&gt;Perl_av_fetch&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4c8d849318248096464684b55db85c231aca3e7" translate="yes" xml:space="preserve">
          <source>This function has been removed as of Perl 5.28; instead convert to call the appropriate one of: &lt;a href=&quot;perlapi#toFOLD_utf8_safe&quot;&gt;&lt;code&gt;toFOLD_utf8_safe&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;perlapi#toLOWER_utf8_safe&quot;&gt;&lt;code&gt;toLOWER_utf8_safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlapi#toTITLE_utf8_safe&quot;&gt;&lt;code&gt;toTITLE_utf8_safe&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perlapi#toUPPER_utf8_safe&quot;&gt;&lt;code&gt;toUPPER_utf8_safe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 Perl 5.28에서 제거되었습니다. 대신 &lt;a href=&quot;perlapi#toFOLD_utf8_safe&quot;&gt; &lt;code&gt;toFOLD_utf8_safe&lt;/code&gt; &lt;/a&gt; 중 적절한 것을 호출하도록 변환 하십시오 . &lt;a href=&quot;perlapi#toLOWER_utf8_safe&quot;&gt; &lt;code&gt;toLOWER_utf8_safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlapi#toTITLE_utf8_safe&quot;&gt; &lt;code&gt;toTITLE_utf8_safe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;perlapi#toUPPER_utf8_safe&quot;&gt; &lt;code&gt;toUPPER_utf8_safe&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85078501581a34823dfc08b6eb6329a48edc2495" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2628b175c2d24277a0337127204502b1f61bdf17" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c51dcb297acb53b80b70f8503b77e24545682a3" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a3e1ad9d7e5fb833c930cfb00998df7f1bf55df" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4b2efde841e51b0d07c870aace74a6c62be34c7" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9f87547ea1196015dca7f56e89130f54f22cb1b" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="240378f462e5da48f4331015b535ca56fa0b083e" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="412915ed27530298d8a82ed72e52493d1ab3961d" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e068961c23381692cac045933729a7a9c74746fc" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad4c7171fd4bdb2f80bf1e964ba7860700e8f9a2" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e9dbf17740431b5f7d9b88f2d682c1cef413410" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.24. It was very similar to matching against &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt;, which you should convert to use instead. See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">이 기능은 v5.24부터 제거되었습니다. 이는 &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt; 에 대한 매칭과 매우 유사하며 대신 사용하도록 변환해야합니다. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 &quot;POSIX 문자 클래스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d75d86010bc99e5342b8fc4788506149d555a48d" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.26. This is identical to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;lc()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot; in perlfunc&lt;/a&gt;, see &lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot; in perlfunc&lt;/a&gt;, or the equivalent &lt;code&gt;\L&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">이 기능은 v5.26부터 제거되었습니다. 단일 문자 또는 전체 문자열에 적용 할 수 있다는 점을 제외하면 C 함수와 동일하며 현재 로케일이 항상 &quot;C&quot;인 것처럼 작동합니다. &lt;code&gt;lc()&lt;/code&gt; 함수 사용을 고려 하십시오 &lt;a href=&quot;perlfunc#lc&quot;&gt;. perlfunc의 &lt;/a&gt;&lt;a href=&quot;perlfunc#lc&quot;&gt;&quot;lc&quot;, perlfunc의 &quot;lc&quot;&lt;/a&gt; 또는 큰 따옴표 문자열 내의 동등한 &lt;code&gt;\L&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9587cdcdc501560277392db1334d4cacc9432bf" translate="yes" xml:space="preserve">
          <source>This function has been removed as of v5.26. This is similar to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;uc()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#uc&quot;&gt;&quot;uc&quot; in perlfunc&lt;/a&gt;, or the equivalent &lt;code&gt;\U&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">이 기능은 v5.26부터 제거되었습니다. 이것은 단일 문자 또는 전체 문자열에 적용 할 수 있다는 점을 제외하고 C 함수와 유사하며 현재 로케일이 항상 &quot;C&quot;인 것처럼 작동합니다. &lt;code&gt;uc()&lt;/code&gt; 함수 사용을 고려 하십시오 &lt;a href=&quot;perlfunc#uc&quot;&gt;. perlfunc의 &quot;uc&quot;&lt;/a&gt; 또는 큰 따옴표 문자열 내의 동등한 &lt;code&gt;\U&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de86eb1f3f7a618ab133b8ece7ae081d7566d329" translate="yes" xml:space="preserve">
          <source>This function has documentation using the &lt;code&gt;apidoc&lt;/code&gt; feature which we'll look at in a second. Some functions have 'd' but not 'A'; docs are good.</source>
          <target state="translated">이 함수에는 &lt;code&gt;apidoc&lt;/code&gt; 기능을 사용하는 문서가 있습니다 . 일부 함수에는 'd'가 있지만 'A'는 없습니다. 문서가 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e5896913a59161466d623bf299d08ae7f2567fac" translate="yes" xml:space="preserve">
          <source>This function has no direct relation to the usage of &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;syswrite&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt;. A handle opened with this function can be used with buffered IO just as one opened with &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; can be used with unbuffered IO.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;sysread&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;syswrite&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek&lt;/code&gt; &lt;/a&gt; 사용과 직접적인 관련이 없습니다 . 이 기능으로 열린 핸들 바로 연 하나로 IO 버퍼로 사용될 수 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 버퍼링 IO 함께 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="757b97be8a26d052ae34b876bf766ef81984a348" translate="yes" xml:space="preserve">
          <source>This function initialises the interpreter, and parses and compiles the script specified by the command-line arguments. This includes executing code in &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, and &lt;code&gt;CHECK&lt;/code&gt; blocks. It does not execute &lt;code&gt;INIT&lt;/code&gt; blocks or the main program.</source>
          <target state="translated">이 함수는 인터프리터를 초기화하고 명령 줄 인수로 지정된 스크립트를 구문 분석하고 컴파일합니다. 여기에는 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 블록의 코드 실행이 포함됩니다 . &lt;code&gt;INIT&lt;/code&gt; 블록이나 메인 프로그램은 실행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0ade2373bef2bb276b87f95d3a360655ec661c9a" translate="yes" xml:space="preserve">
          <source>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">이 함수는 이전 숨김, 중첩 된 모든 하위 패키지 및 &lt;code&gt;stash&lt;/code&gt; 에 해당 항목이있는 존재하지 않는 패키지를 포함하여 모든 하위 패키지의 캐시를 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="163806a2e1a58620114c112d76abd153644c2699" translate="yes" xml:space="preserve">
          <source>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in &lt;code&gt;stash&lt;/code&gt;.</source>
          <target state="translated">이 함수는 이전 숨김, 그 안에 중첩 된 모든 하위 패키지 및 &lt;code&gt;stash&lt;/code&gt; 에 해당 항목이있는 존재하지 않는 패키지를 포함하여 모든 하위 패키지의 하위 클래스에서 isa 캐시를 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="0fcc501ee8274fe4e362635b1b12b9fad07e4cc1" translate="yes" xml:space="preserve">
          <source>This function is a deprecated synonym for &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;&quot;uvoffuni_to_utf8_flags&quot;&lt;/a&gt;, which itself, while not deprecated, should be used only in isolated circumstances. These functions were useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;&quot;uvoffuni_to_utf8_flags&quot;&lt;/a&gt; 의 더 이상 사용되지 않는 동의어입니다.이 함수는 더 이상 사용되지 않지만 격리 된 환경에서만 사용해야합니다. 이러한 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터 플랫폼 간의 구분이 대부분의 코드에서 보이지 않게 되었기 때문에이 함수는 다음과 같을 가능성이 거의 없습니다. 당신이 원합니다.</target>
        </trans-unit>
        <trans-unit id="c21846dd58e70501c7ae85693ffbb155deb7ba64" translate="yes" xml:space="preserve">
          <source>This function is a deprecated synonym for &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt;, which itself, while not deprecated, should be used only in isolated circumstances. These functions were useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt; 의 사용되지 않는 동의어이며, 사용되지는 않지만 격리 된 환경에서만 사용해야합니다. 이러한 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터는 플랫폼 간의 차이점이 대부분의 코드에서 보이지 않게되었으므로이 기능은 당신이 원합니다.</target>
        </trans-unit>
        <trans-unit id="2913484e77586e8d68e21770c7b4063c930b583c" translate="yes" xml:space="preserve">
          <source>This function is a good candidate for memoization. If you memoize the `fib' function above, it will compute fib(14) exactly once, the first time it needs to, and then save the result in a table. Then if you ask for fib(14) again, it gives you the result out of the table. While computing fib(14), instead of computing fib(12) twice, it does it once; the second time it needs the value it gets it from the table. It doesn't compute fib(11) four times; it computes it once, getting it from the table the next three times. Instead of making 1,200 recursive calls to `fib', it makes 15. This makes the function about 150 times faster.</source>
          <target state="translated">이 기능은 메모에 적합합니다. 위의`fib '함수를 기억하면 처음으로 fib (14)를 정확히 한 번 계산 한 다음 결과를 테이블에 저장합니다. 그런 다음 fib (14)를 다시 요청하면 결과가 표에서 나오게됩니다. fib (12)를 두 번 계산하는 대신 fib (14)를 계산하는 동안 한 번 수행합니다. 두 번째로 테이블에서 가져 오는 값이 필요합니다. fib (11)을 네 번 계산하지 않습니다. 한 번 계산하여 테이블에서 다음 세 번 가져옵니다. `fib '에 대해 1,200 회 재귀 호출을하는 대신 15를 만듭니다. 이는 약 150 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8abb1909fce4e7f9c7aa7be2b9644d4d00810b89" translate="yes" xml:space="preserve">
          <source>This function is a part of the public API. All such functions should also have 'd', very few do not.</source>
          <target state="translated">이 함수는 공개 API의 일부입니다. 그러한 모든 기능은 또한 'd'를 가져야하며, 그 중 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="752724e6180b12da8e6cd0e0935f30eed783f92d" translate="yes" xml:space="preserve">
          <source>This function is a stand-in replacement for &lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar::Util::refaddr&lt;/a&gt;, that is, it returns the reference address of its argument as a numeric value. The only difference is that &lt;code&gt;refaddr()&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when given a non-reference while &lt;code&gt;id()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar :: Util :: refaddr&lt;/a&gt; 의 독립형 대체입니다 . 즉, 인수의 참조 주소를 숫자 값으로 리턴합니다. 유일한 차이점은 &lt;code&gt;refaddr()&lt;/code&gt; 이 참조가 아닌 경우 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하는 반면 &lt;code&gt;id()&lt;/code&gt; 는 인수를 변경하지 않고 반환 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6c49d7b5a023a1bdb0c62afc7b7daf87c9518dbf" translate="yes" xml:space="preserve">
          <source>This function is a stand-in replacement for &lt;a href=&quot;Scalar::Util#refaddr&quot;&gt;Scalar::Util::refaddr&lt;/a&gt;, that is, it returns the reference address of its argument as a numeric value. The only difference is that &lt;code&gt;refaddr()&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; when given a non-reference while &lt;code&gt;id()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;Scalar::Util#refaddr&quot;&gt;Scalar :: Util :: refaddr&lt;/a&gt; 의 독립형 대체입니다 . 즉, 인수의 참조 주소를 숫자 값으로 반환합니다. 유일한 차이점은 &lt;code&gt;refaddr()&lt;/code&gt; 은 참조가 아닌 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환 하는 반면 &lt;code&gt;id()&lt;/code&gt; 는 변경되지 않은 인수를 반환 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="57e7b319f75480a4bb2f70f5a0776fcd6fd1010a" translate="yes" xml:space="preserve">
          <source>This function is affected by the &lt;code&gt;$RAND&lt;/code&gt; variable.</source>
          <target state="translated">이 함수는 &lt;code&gt;$RAND&lt;/code&gt; 변수의 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="e32d82df863c1cbf51247765161ee50be4e23d2c" translate="yes" xml:space="preserve">
          <source>This function is deprecated due to the possibility that malformed input could cause reading beyond the end of the input buffer. Use &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 잘못된 입력으로 인해 입력 버퍼의 끝을 넘어서 읽을 수 있기 때문에 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a0d9ec972199a89df14d600a89c7347e29e2743" translate="yes" xml:space="preserve">
          <source>This function is deprecated due to the possibility that malformed input could cause reading beyond the end of the input buffer. Use &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; instead.</source>
          <target state="translated">이 기능은 잘못된 입력이 입력 버퍼의 끝을 넘어 판독을 유발할 수 있기 때문에 사용되지 않습니다. 대신 &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="28ce789b612136fafacb486bd5bb357e8d0e4268" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true and an unlink on open file is supported. If the unlink is to be deferred to the END block, the file is still registered for removal.</source>
          <target state="translated">글로벌 변수 $ KEEP_ALL이 true이고 열린 파일에서 링크 해제가 지원되는 경우이 기능은 사용 불가능합니다. 링크가 END 블록으로 지연되는 경우 파일은 여전히 ​​제거를 위해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff75df81e21a36cc9176732a80e9ccf2b68ffdf" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true.</source>
          <target state="translated">글로벌 변수 $ KEEP_ALL이 true 인 경우이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37256aba6c6729bd5a917fd025e81cedb9d0b6bb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the libc strtod() function, and is available even on platforms that lack plain strtod(). Its return value is the best available precision depending on platform capabilities and</source>
          <target state="translated">이 함수는 libc strtod () 함수와 동일하며 일반 strtod ()가없는 플랫폼에서도 사용할 수 있습니다. 반환 값은 플랫폼 기능 및</target>
        </trans-unit>
        <trans-unit id="f6ac1505f98d117f842948a2e4dbeafd3ff53890" translate="yes" xml:space="preserve">
          <source>This function is expected to be called in a Perl compilation context, and some aspects of the subroutine are taken from global variables associated with compilation. In particular, &lt;code&gt;PL_compcv&lt;/code&gt; represents the subroutine that is currently being compiled. It must be non-null when this function is called, and some aspects of the subroutine being constructed are taken from it. The constructed subroutine may actually be a reuse of the &lt;code&gt;PL_compcv&lt;/code&gt; object, but will not necessarily be so.</source>
          <target state="translated">이 함수는 Perl 컴파일 컨텍스트에서 호출 될 것으로 예상되며 서브 루틴의 일부 측면은 컴파일과 관련된 전역 변수에서 가져옵니다. 특히 &lt;code&gt;PL_compcv&lt;/code&gt; 는 현재 컴파일중인 서브 루틴을 나타냅니다. 이 함수가 호출 될 때 null이 아니어야하며 생성되는 서브 루틴의 일부 측면을 가져옵니다. 구성된 서브 루틴은 실제로 &lt;code&gt;PL_compcv&lt;/code&gt; 객체 의 재사용 일 수 있지만 반드시 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1b3c45f3e25d0a4f2eec52ed9b0f4d623aa7d540" translate="yes" xml:space="preserve">
          <source>This function is expected to be used to signal to perl that this SV is about to be written to, and any extra book-keeping needs to be taken care of. Hence, it croaks on read-only values.</source>
          <target state="translated">이 기능은이 SV가 작성 될 예정임을 perl에 알리는 데 사용될 것으로 예상되며 추가 부기 관리가 필요합니다. 따라서 읽기 전용 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="046e9e5d6bd1398867e1dee81f27fefb4c212d31" translate="yes" xml:space="preserve">
          <source>This function is expensive in time and memory.</source>
          <target state="translated">이 기능은 시간과 메모리가 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="45313cfa765e7987f87b6f11b5766c14f7fa9aff" translate="yes" xml:space="preserve">
          <source>This function is expensive, it must scan all of the buckets to determine which are used, and the count is NOT cached. In a large hash this could be a lot of buckets.</source>
          <target state="translated">이 함수는 비용이 많이 들고 어떤 버킷이 사용되는지 확인하기 위해 모든 버킷을 스캔해야하며 개수는 캐시되지 않습니다. 큰 해시에서 이것은 많은 버킷이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e275fe5def47eb8b770fec4e729d202771a5b5a" translate="yes" xml:space="preserve">
          <source>This function is explicitly exported.</source>
          <target state="translated">이 기능은 명시 적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="1653892f2f39d308f9b0a291eb56cee425def2a1" translate="yes" xml:space="preserve">
          <source>This function is for code that needs to know what the precise malformation(s) are when an error is found, and wants the corresponding warning and/or error messages to be returned to the caller rather than be displayed. All messages that would have been displayed if all lexcial warnings are enabled will be returned.</source>
          <target state="translated">이 함수는 오류가 발견되었을 때 정확한 기형이 무엇인지 알아야하고 해당 경고 및 / 또는 오류 메시지가 표시되지 않고 호출자에게 반환되기를 원하는 코드를위한 것입니다. 모든 어휘 경고가 활성화 된 경우 표시되었을 모든 메시지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4cfc2833ee86dd51e2c0f635f6cf283876c7c4" translate="yes" xml:space="preserve">
          <source>This function is for code that needs to know what the precise malformation(s) are when an error is found. If you also need to know the generated warning messages, use &lt;a href=&quot;#utf8n_to_uvchr_msgs&quot;&gt;&quot;utf8n_to_uvchr_msgs&quot;&lt;/a&gt;() instead.</source>
          <target state="translated">이 함수는 오류가 발견되었을 때 정확한 기형이 무엇인지 알아야하는 코드를위한 것입니다. 생성 된 경고 메시지도 알아야하는 경우 대신 &lt;a href=&quot;#utf8n_to_uvchr_msgs&quot;&gt;&quot;utf8n_to_uvchr_msgs&quot;&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32340b4b7db192c6b9924268289f95c5bca2f985" translate="yes" xml:space="preserve">
          <source>This function is for code that wants any warning and/or error messages to be returned to the caller rather than be displayed. All messages that would have been displayed if all lexical warnings are enabled will be returned.</source>
          <target state="translated">이 함수는 경고 및 / 또는 오류 메시지가 표시되지 않고 호출자에게 반환되기를 원하는 코드를위한 것입니다. 모든 어휘 경고가 활성화 된 경우 표시되었을 모든 메시지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="46c07c7fe871db128f73a62dda492de37210f641" translate="yes" xml:space="preserve">
          <source>This function is internal to Perl because khw thinks that any XS code that would want this is probably operating too close to the internals. Presenting a valid use case could change that.</source>
          <target state="translated">khw는 이것을 원하는 XS 코드가 아마도 내부에 너무 가깝게 작동한다고 생각하기 때문에이 함수는 Perl 내부입니다. 유효한 사용 사례를 제시하면이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baae2ca89cb1960ad8e6c66b2b2c6b874d4b3266" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">이 함수는 항상 인수를 구문 분석하거나 EXPR이 생략 된 경우 &lt;code&gt;$_&lt;/code&gt; 를 바이트 문자열로 해석한다는 점을 제외하고는 문자열 인수가있는 &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; 과 같습니다 . 서 수가 255를 초과하는 문자가 포함 된 문자열은 오류를 발생시킵니다. 평가 된 코드 내에서 활성화 된 소스 필터는 코드 자체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4699e383ec11b8d15b996f85aefd9a02e9b5bdaf" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">이 함수는 항상 인수를 구문 분석하거나 EXPR이 생략 된 경우 &lt;code&gt;$_&lt;/code&gt; 를 바이트 문자열로 해석한다는 점을 제외하고는 문자열 인수가있는 &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; 과 같습니다 . 서 수가 255를 초과하는 문자가 포함 된 문자열은 오류를 발생시킵니다. 평가 된 코드 내에서 활성화 된 소스 필터는 코드 자체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="caeb1cd5a4880a4de69d7c039879029a5a9067db" translate="yes" xml:space="preserve">
          <source>This function is like them, but the input is a strict Unicode (as opposed to native) code point. Only in very rare circumstances should code not be using the native code point.</source>
          <target state="translated">이 함수는 그와 비슷하지만 입력은 엄격한 유니 코드 (기본과 반대) 코드 포인트입니다. 매우 드문 상황에서만 코드가 기본 코드 포인트를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a6987023b3feeacf2b107686c8afb184bf9785b" translate="yes" xml:space="preserve">
          <source>This function is most useful in the idiom</source>
          <target state="translated">이 기능은 관용구에서 가장 유용합니다</target>
        </trans-unit>
        <trans-unit id="6e46549cf4ac0adc9c0ac53e027f514166435b55" translate="yes" xml:space="preserve">
          <source>This function is no longer recommended for use, but is maintained for compatibility with existing code. If you do not want to have it exported to your namespace, use this form:</source>
          <target state="translated">이 함수는 더 이상 사용하지 않는 것이 좋지만 기존 코드와의 호환성을 위해 유지됩니다. 네임 스페이스로 내 보내지 않으려면 다음 양식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba0cefbbfd398911c6a8851cb85930170c481ec" translate="yes" xml:space="preserve">
          <source>This function is not exported by default, so you'll have to ask for it via:</source>
          <target state="translated">이 기능은 기본적으로 내보내지지 않으므로 다음을 통해 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fe47a845128e2d640eed3a78c38850805c099b0" translate="yes" xml:space="preserve">
          <source>This function is now largely obsolete, mostly because it's very hard to convert a core file into an executable. As of Perl 5.30, it must be invoked as &lt;code&gt;CORE::dump()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 이제 대부분 사용되지 않습니다. 대부분 코어 파일을 실행 파일로 변환하기가 매우 어렵 기 때문입니다. Perl 5.30부터 &lt;code&gt;CORE::dump()&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6a1a85d5fc88c0e9364254a35bb1ced4455307" translate="yes" xml:space="preserve">
          <source>This function is now largely obsolete, mostly because it's very hard to convert a core file into an executable. That's why you should now invoke it as &lt;code&gt;CORE::dump()&lt;/code&gt; , if you don't want to be warned against a possible typo.</source>
          <target state="translated">이 기능은 코어 파일을 실행 파일로 변환하기가 매우 어렵 기 때문에 이제는 거의 사용되지 않습니다. 가능한 오타에 대해 경고하지 않으려면 이제 &lt;code&gt;CORE::dump()&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5839521ffabe37be44c9b142d6f0e122410904e4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 기능, &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상의 &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 선언 또는 &lt;code&gt;CORE::&lt;/code&gt; 접두사 에서만 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce5a3cfad478a3c3fe7a7e04e3ec1df865cc5b4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 기능, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상의 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 선언 또는 &lt;code&gt;CORE::&lt;/code&gt; 접두사 에서만 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20d8dc8fedc07f301a7cc15f9e5b8989eceaa3db" translate="yes" xml:space="preserve">
          <source>This function is only used by &lt;code&gt;sv_true()&lt;/code&gt; and friends, and only if the latter's argument is neither &lt;code&gt;SvPOK&lt;/code&gt;, &lt;code&gt;SvIOK&lt;/code&gt; nor &lt;code&gt;SvNOK&lt;/code&gt;. If the flags contain &lt;code&gt;SV_GMAGIC&lt;/code&gt;, then it does an &lt;code&gt;mg_get()&lt;/code&gt; first.</source>
          <target state="translated">이 함수는 &lt;code&gt;sv_true()&lt;/code&gt; 및 친구들 만 사용하고 후자의 인수가 &lt;code&gt;SvPOK&lt;/code&gt; , &lt;code&gt;SvIOK&lt;/code&gt; 또는 &lt;code&gt;SvNOK&lt;/code&gt; 가 아닌 경우 에만 사용됩니다 . 플래그가 포함 된 경우 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 을 , 다음은 않습니다 &lt;code&gt;mg_get()&lt;/code&gt; 처음.</target>
        </trans-unit>
        <trans-unit id="e43d0a24f1f599b09639816ea4bcc88309ead9ce" translate="yes" xml:space="preserve">
          <source>This function is only used by sv_true() and friends, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. If the flags contain SV_GMAGIC, then it does an mg_get() first.</source>
          <target state="translated">이 함수는 sv_true () 및 friends에서만 사용되며 후자의 인수가 SvPOK, SvIOK 또는 SvNOK가 아닌 경우에만 사용됩니다. 플래그에 SV_GMAGIC이 포함되어 있으면 먼저 mg_get ()을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b5776fa05d807fc6265ae0f0ad2309322f8e80a" translate="yes" xml:space="preserve">
          <source>This function is part of the experimental development API, and may change or disappear without notice.</source>
          <target state="translated">이 기능은 실험 개발 API의 일부이며 예고없이 변경되거나 사라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4b28e7c0c75c36faca5ca1d70518986b2de4c0" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;basename(1)&lt;/code&gt; . It does &lt;b&gt;NOT&lt;/b&gt; always return the file name portion of a path as you might expect. To be safe, if you want the file name portion of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 Unix 쉘 명령 &lt;code&gt;basename(1)&lt;/code&gt; 과의 호환성을 위해 제공됩니다 . 예상대로 경로의 파일 이름 부분을 항상 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 파일 이름 부분을 원하면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652405f4a5d205fef6e05d3e71213e7a84c66d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;basename(1)&lt;/code&gt;. It does &lt;b&gt;NOT&lt;/b&gt; always return the file name portion of a path as you might expect. To be safe, if you want the file name portion of a path use &lt;code&gt;fileparse()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 Unix 쉘 명령 &lt;code&gt;basename(1)&lt;/code&gt; 과의 호환성을 위해 제공됩니다 . 예상대로 경로의 파일 이름 부분을 항상 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 파일 이름 부분을 원한다면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deb4ec1fbe8c66b8f2020144f5701828bedcfe14" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;dirname(1)&lt;/code&gt; and has inherited some of its quirks. In spite of its name it does &lt;b&gt;NOT&lt;/b&gt; always return the directory name as you might expect. To be safe, if you want the directory name of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 Unix 쉘 명령 &lt;code&gt;dirname(1)&lt;/code&gt; 과의 호환성을 위해 제공되며 일부 단점을 물려 받았습니다. 이름에도 불구하고 항상 예상대로 디렉토리 이름을 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 디렉토리 이름을 원하면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e38b64af2f6199864b86fbb0e715f9bad1e1c8ab" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;dirname(1)&lt;/code&gt; and has inherited some of its quirks. In spite of its name it does &lt;b&gt;NOT&lt;/b&gt; always return the directory name as you might expect. To be safe, if you want the directory name of a path use &lt;code&gt;fileparse()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 Unix 셸 명령 &lt;code&gt;dirname(1)&lt;/code&gt; 과의 호환성을 위해 제공되며 몇 가지 단점을 상속했습니다. 이름에도 불구하고 예상대로 항상 디렉토리 이름을 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 디렉토리 이름을 원한다면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b43d447b561f6a59c989012be7a2b442524af3a6" translate="yes" xml:space="preserve">
          <source>This function is rarely used since you will usually get the value of a constant by having that constant imported into your package by listing the constant name in the &lt;code&gt;use Win32API::File&lt;/code&gt; statement and then simply using the constant name in your code [perhaps followed by &lt;code&gt;()&lt;/code&gt;]. This function is useful for verifying constant names not in Perl code, for example, after prompting a user to type in a constant name.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;use Win32API::File&lt;/code&gt; 문 에 상수 이름을 나열한 다음 코드에서 상수 이름을 사용하여 상수를 패키지로 가져 와서 상수 값을 가져 오기 때문에 거의 사용되지 않습니다 . &lt;code&gt;()&lt;/code&gt; ]. 이 함수는 사용자에게 상수 이름을 입력하라는 메시지를 표시 한 후 Perl 코드에없는 상수 이름을 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2335958f876fe8dc65dba75c5931c4ccbae47d62" translate="yes" xml:space="preserve">
          <source>This function is similar to a &lt;a href=&quot;#eval-EXPR&quot;&gt;string eval&lt;/a&gt;, except it always parses its argument (or &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; if EXPR is omitted) as a string of independent bytes.</source>
          <target state="translated">이 함수는 항상 인수 (또는 EXPR이 생략 된 경우 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; )를 독립적 인 바이트의 문자열로 구문 분석한다는 점을 제외하면 &lt;a href=&quot;#eval-EXPR&quot;&gt;문자열 eval&lt;/a&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="02937778415d96c12ca24363d4faada4d7809ec7" translate="yes" xml:space="preserve">
          <source>This function is slightly neater and more convenient than the otherwise-equivalent code</source>
          <target state="translated">이 함수는 다른 코드보다 약간 깔끔하고 편리합니다.</target>
        </trans-unit>
        <trans-unit id="824fffad4b877549e966fe37c98ad5fa083fe68c" translate="yes" xml:space="preserve">
          <source>This function is the implementation of the &lt;a href=&quot;#LINKLIST&quot;&gt;&quot;LINKLIST&quot;&lt;/a&gt; macro. It should not be called directly.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#LINKLIST&quot;&gt;&quot;LINKLIST&quot;&lt;/a&gt; 매크로 의 구현입니다 . 직접 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="253b045013c433366a31c2cad960bf3283fd7d39" translate="yes" xml:space="preserve">
          <source>This function is the implementation of the &lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt; macro. It should not be called directly.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt; 매크로 의 구현입니다 . 직접 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a063dac587bf0c596a82a9c061b8f58b0075f3f" translate="yes" xml:space="preserve">
          <source>This function is the reason for &lt;code&gt;Test&lt;/code&gt; 's existence. It's the basic function that handles printing &quot;&lt;code&gt;ok&lt;/code&gt; &quot; or &quot;&lt;code&gt;not ok&lt;/code&gt; &quot;, along with the current test number. (That's what &lt;code&gt;Test::Harness&lt;/code&gt; wants to see.)</source>
          <target state="translated">이 함수는 &lt;code&gt;Test&lt;/code&gt; 가 존재 하는 이유입니다 . 현재 테스트 번호와 함께 &quot; &lt;code&gt;ok&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;not ok&lt;/code&gt; &quot; 인쇄를 처리하는 기본 기능입니다 . (이것이 &lt;code&gt;Test::Harness&lt;/code&gt; 가보고 싶어하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="6652ee7354b55bf19e0dd58db709c8e76f2ecef3" translate="yes" xml:space="preserve">
          <source>This function is the reason for &lt;code&gt;Test&lt;/code&gt;'s existence. It's the basic function that handles printing &quot;&lt;code&gt;ok&lt;/code&gt;&quot; or &quot;&lt;code&gt;not ok&lt;/code&gt;&quot;, along with the current test number. (That's what &lt;code&gt;Test::Harness&lt;/code&gt; wants to see.)</source>
          <target state="translated">이 기능이 &lt;code&gt;Test&lt;/code&gt; 가 존재 하는 이유입니다 . 현재 테스트 번호와 함께 &quot; &lt;code&gt;ok&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;not ok&lt;/code&gt; &quot; 인쇄를 처리하는 기본 기능입니다 . (그게 바로 &lt;code&gt;Test::Harness&lt;/code&gt; 가보고 싶어하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="077b1426e82943be7223b00766173ba5b1d4acf4" translate="yes" xml:space="preserve">
          <source>This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).</source>
          <target state="translated">이 함수는 가능한 최소 gzip 헤더 (정확히 10 바이트)를 사용하여 메모리 내 gzip 파일을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e0a2ccd31b9bdd8066d5b9d22011351f1760ec7" translate="yes" xml:space="preserve">
          <source>This function is used to uncompress an in-memory gzip file.</source>
          <target state="translated">이 기능은 메모리 내 gzip 파일을 압축 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3560ca8857460f655d69dd6b49d96a0f7f4a536" translate="yes" xml:space="preserve">
          <source>This function is useful for producing a directory tree identical to the intended distribution tree.</source>
          <target state="translated">이 기능은 의도 한 배포 트리와 동일한 디렉토리 트리를 생성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1163bbaebdc07bcad37b6297e8e95d441a65c0d1" translate="yes" xml:space="preserve">
          <source>This function is useful in two cases: a) finding the trailing text after a JSON object or b) parsing multiple JSON objects separated by non-JSON text (such as commas).</source>
          <target state="translated">이 함수는 a) JSON 객체 뒤의 후행 텍스트 찾기 또는 b) 비 JSON 텍스트 (예 : 쉼표)로 구분 된 여러 JSON 객체 구문 분석의 두 가지 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f19b2798743cc5e3f86e0124b7ddc89a4b3ff92" translate="yes" xml:space="preserve">
          <source>This function is very slow. Why? To compute fib(14), it first wants to compute fib(13) and fib(12), and add the results. But to compute fib(13), it first has to compute fib(12) and fib(11), and then it comes back and computes fib(12) all over again even though the answer is the same. And both of the times that it wants to compute fib(12), it has to compute fib(11) from scratch, and then it has to do it again each time it wants to compute fib(13). This function does so much recomputing of old results that it takes a really long time to run---fib(14) makes 1,200 extra recursive calls to itself, to compute and recompute things that it already computed.</source>
          <target state="translated">이 기능은 매우 느립니다. 왜? fib (14)를 계산하려면 먼저 fib (13) 및 fib (12)를 계산하고 결과를 추가하려고합니다. 그러나 fib (13)을 계산하려면 먼저 fib (12)와 fib (11)을 계산 한 다음 답이 같더라도 다시 돌아와서 fib (12)를 다시 계산합니다. 그리고 fib (12)를 계산하고자하는 두 시간 모두, 처음부터 fib (11)을 계산해야하며, fib (13)을 계산할 때마다 다시 수행해야합니다. 이 함수는 오래된 결과를 너무 많이 재 계산하므로 실행하는 데 시간이 오래 걸립니다 .-- fib (14)는 이미 계산 한 것을 계산하고 재 계산하기 위해 1,200 개의 재귀 호출을 자체적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="658ccab5957d9fcb5acf02b75800173326f8ac18" translate="yes" xml:space="preserve">
          <source>This function is visible to extensions included in the Perl core.</source>
          <target state="translated">이 기능은 Perl 코어에 포함 된 확장에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab6ba31d01a4a2d9764121a075a301c39db9fb7" translate="yes" xml:space="preserve">
          <source>This function is wrapped by the macro &lt;code&gt;HvFILL&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;HvFILL&lt;/code&gt; 매크로로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="bced169d4ae2df2074f45ec48dfe76cbdcf9e8fb" translate="yes" xml:space="preserve">
          <source>This function isn't exported out of the Perl core.</source>
          <target state="translated">이 함수는 Perl 코어에서 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4db11cb4bc493fbed9591c0f0b07c2a5d596564" translate="yes" xml:space="preserve">
          <source>This function looks at the sequence of bytes between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, which are assumed to be encoded in ASCII/Latin1, and returns how many of them would change should the string be translated into UTF-8. Due to the nature of UTF-8, each of these would occupy two bytes instead of the single one in the input string. Thus, this function returns the precise number of bytes the string would expand by when translated to UTF-8.</source>
          <target state="translated">이 함수는 ASCII / Latin1로 인코딩 된 것으로 가정되는 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 사이 의 바이트 시퀀스를 보고 문자열이 UTF-8로 변환 될 경우 변경 될 바이트 수를 반환합니다. UTF-8의 특성으로 인해 이들 각각은 입력 문자열에서 단일 바이트 대신 2 바이트를 차지합니다. 따라서이 함수는 UTF-8로 변환 될 때 문자열이 확장되는 정확한 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44b0e9309a1e4a7388d6c16c7d9a1708e320c5c8" translate="yes" xml:space="preserve">
          <source>This function makes use of the fact that the presence of tainted data anywhere within an expression renders the entire expression tainted. It would be inefficient for every operator to test every argument for taintedness. Instead, the slightly more efficient and conservative approach is used that if any tainted value has been accessed within the same expression, the whole expression is considered tainted.</source>
          <target state="translated">이 함수는 표현식 내에서 오염 된 데이터가 존재하면 전체 표현식이 오염된다는 사실을 이용합니다. 모든 작업자가 오염에 대한 모든 주장을 테스트하는 것은 비효율적입니다. 대신, 동일한 표현 내에서 오염 된 값에 액세스 한 경우 전체 표현이 오염 된 것으로 간주되는 약간 더 효율적이고 보수적 인 접근 방식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa84a514560c863f7089eb7ca24d6683d764569" translate="yes" xml:space="preserve">
          <source>This function may redirect error popups associated with hardware errors (Disk not ready etc.) and software exceptions to the file POPUPLOG.OS2 at the root directory of the specified drive. Overrides OS2::Error() specified by individual programs. Given argument undef will disable redirection.</source>
          <target state="translated">이 기능은 하드웨어 오류 (디스크 준비 안 됨 등) 및 소프트웨어 예외와 관련된 오류 팝업을 지정된 드라이브의 루트 디렉토리에있는 POPUPLOG.OS2 파일로 리디렉션 할 수 있습니다. 개별 프로그램에 의해 지정된 OS2 :: Error ()를 대체합니다. 주어진 인수 undef는 리디렉션을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="359169950ca6c9680b4088bbfb715818c6d49e24" translate="yes" xml:space="preserve">
          <source>This function may return the pathname in Unicode if it cannot be represented in the system codepage. Use Win32::GetANSIPathName() before passing the path to a system call or another program.</source>
          <target state="translated">이 함수는 시스템 코드 페이지에 표시 할 수없는 경우 유니 코드로 경로 이름을 반환 할 수 있습니다. 시스템 호출이나 다른 프로그램에 경로를 전달하기 전에 Win32 :: GetANSIPathName ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1496d823153f206625abfb243ff632e61577c117" translate="yes" xml:space="preserve">
          <source>This function modifies and queries the program's underlying locale. Users of this function should read &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;, whch provides a comprehensive discussion of Perl locale handling, knowledge of which is necessary to properly use this function. It contains &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;a section devoted to this function&lt;/a&gt;. The discussion here is merely a summary reference for &lt;code&gt;setlocale()&lt;/code&gt;. Note that Perl itself is almost entirely unaffected by the locale except within the scope of &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;. (Exceptions are listed in &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;&quot;Not within the scope of &quot;use locale&quot;&quot; in perllocale&lt;/a&gt;, and locale-dependent functions within the POSIX module ARE always affected by the current locale.)</source>
          <target state="translated">이 함수는 프로그램의 기본 로케일을 수정하고 쿼리합니다. 이 함수의 사용자는 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 읽어야 합니다. 여기서는 Perl 로케일 처리에 대한 포괄적 인 설명을 제공 하며이 함수 를 올바르게 사용하는 데 필요한 지식을 제공합니다. 여기에는 &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;이 기능에 대한 섹션&lt;/a&gt; 이 포함되어 있습니다 . 여기서 논의는 &lt;code&gt;setlocale()&lt;/code&gt; 대한 요약 참조 일뿐 입니다. Perl 자체는 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 범위를 제외하고는 로케일의 영향을 거의받지 않습니다 . (예외는 &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;perllocale의 &quot;&quot;use locale &quot;범위에 속하지 않음&quot;&lt;/a&gt; 에 나열되며 POSIX 모듈 내의 로케일 종속 함수는 항상 현재 로케일의 영향을받습니다.)</target>
        </trans-unit>
        <trans-unit id="1a86c3308b6ed4c9bad7b6ede75664c2fe49a26e" translate="yes" xml:space="preserve">
          <source>This function must only be called during parsing of a subroutine; after &lt;a href=&quot;#start_subparse&quot;&gt;&quot;start_subparse&quot;&lt;/a&gt; has been called. It might allocate lexical variables on the pad for the current subroutine.</source>
          <target state="translated">이 함수는 서브 루틴을 구문 분석하는 동안에 만 호출되어야합니다. 후 &lt;a href=&quot;#start_subparse&quot;&gt;&quot;start_subparse&quot;&lt;/a&gt; 라고되어 있습니다. 현재 서브 루틴에 대해 패드에 어휘 변수를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c43d91069a9273330810504102211439262d63" translate="yes" xml:space="preserve">
          <source>This function never returns; &lt;code&gt;croak&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; and friends.</source>
          <target state="translated">이 함수는 절대 반환하지 않습니다. &lt;code&gt;croak&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 및 친구들.</target>
        </trans-unit>
        <trans-unit id="50a0a533f960128e3a086dc96db9b1aafa52d5a7" translate="yes" xml:space="preserve">
          <source>This function normally returns a list. Suppose you memoize it and merge the caches:</source>
          <target state="translated">이 함수는 일반적으로 목록을 반환합니다. 이를 메모하고 캐시를 병합한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3b85997713311e08de3e59dac5499d89e1dccd03" translate="yes" xml:space="preserve">
          <source>This function only exists if Perl has been compiled to use ithreads.</source>
          <target state="translated">이 함수는 Perl이 ithread를 사용하도록 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="61fee0518a7d8b237d34517bc719658c6b719ec4" translate="yes" xml:space="preserve">
          <source>This function only operates on officially approved (not provisional) named sequences.</source>
          <target state="translated">이 기능은 공식적으로 승인 된 (임시가 아닌) 명명 된 시퀀스에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e59aa3c08f27111519b6ecd9388b33347100905a" translate="yes" xml:space="preserve">
          <source>This function only works on &lt;code&gt;new()&lt;/code&gt; and it assumes &lt;code&gt;new()&lt;/code&gt; will return just a single object which isa &lt;code&gt;$class&lt;/code&gt; .</source>
          <target state="translated">이 기능은 작동 &lt;code&gt;new()&lt;/code&gt; 그리고 가정 &lt;code&gt;new()&lt;/code&gt; 사 단 하나의 객체 반환 &lt;code&gt;$class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984502da18bc523751c7d6b5905d4dbe46c6f445" translate="yes" xml:space="preserve">
          <source>This function only works on &lt;code&gt;new()&lt;/code&gt; and it assumes &lt;code&gt;new()&lt;/code&gt; will return just a single object which isa &lt;code&gt;$class&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;new()&lt;/code&gt; 에서만 작동하며 new ( &lt;code&gt;new()&lt;/code&gt; 가 &lt;code&gt;$class&lt;/code&gt; 단일 객체 만 반환 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="2eb7d023997a73d6817733ba90181d612a2b1cdc" translate="yes" xml:space="preserve">
          <source>This function opens either the</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="441aca7229169cbbddd3f285c046a735dc532182" translate="yes" xml:space="preserve">
          <source>This function performs syntax checking on a prototype, &lt;code&gt;proto&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for &lt;code&gt;name&lt;/code&gt; .</source>
          <target state="translated">이 함수는 프로토 타입 &lt;code&gt;proto&lt;/code&gt; 에서 구문 검사를 수행합니다 . 경우 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 사실, 불법 문자 나 일치하지 않는 괄호은의 프로토 타입에서 검출되었다고 선언, 경고 illegalproto 트리거 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdadd704268c26b65382b6957bee64f00d111837" translate="yes" xml:space="preserve">
          <source>This function performs syntax checking on a prototype, &lt;code&gt;proto&lt;/code&gt;. If &lt;code&gt;warn&lt;/code&gt; is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">이 함수는 프로토 타입 &lt;code&gt;proto&lt;/code&gt; 에서 구문 검사를 수행합니다 . 경우 &lt;code&gt;warn&lt;/code&gt; 사실, 불법 문자 나 일치하지 않는 괄호은의 프로토 타입에서 검출되었다고 선언, 경고 illegalproto 트리거 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91930e6b34fa8d1a9857a2f7de94cb11275f2880" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions gethostbyname(), getservbyname(), inet_aton() and pack_sockaddr_in().</source>
          <target state="translated">이 함수는 레거시 함수 gethostbyname (), getservbyname (), inet_aton () 및 pack_sockaddr_in ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b69a639ae94b0e84e8a91026a470893dc8e2e4fa" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions unpack_sockaddr_in(), inet_ntoa(), gethostbyaddr() and getservbyport().</source>
          <target state="translated">이 함수는 레거시 함수 unpack_sockaddr_in (), inet_ntoa (), gethostbyaddr () 및 getservbyport ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3d1364c8524baa88f5749c97cf4b3c3b92b20d7d" translate="yes" xml:space="preserve">
          <source>This function places an advisory lock on a shared variable or referenced object contained in</source>
          <target state="translated">이 함수는 공유 변수 또는 참조 된 객체에 권고 잠금을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0a506b1319a241ed6545a1f6f58a9a222f9ce6e0" translate="yes" xml:space="preserve">
          <source>This function process get magic on &lt;code&gt;sv&lt;/code&gt;.</source>
          <target state="translated">이 함수 프로세스는 &lt;code&gt;sv&lt;/code&gt; 에서 마법을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="16532d91a655b7f55374b1ff4cdf45a2891edbdc" translate="yes" xml:space="preserve">
          <source>This function reads the environment and generates an appropriate argument hash from it. If given any arguments in &lt;code&gt;%extra_args&lt;/code&gt;, these will override the environmental defaults. In accepts &lt;code&gt;harness_class&lt;/code&gt; (which defaults to &lt;code&gt;TAP::Harness&lt;/code&gt;), and any argument the harness class accepts.</source>
          <target state="translated">이 함수는 환경을 읽고 여기에서 적절한 인수 해시를 생성합니다. &lt;code&gt;%extra_args&lt;/code&gt; 인수가 주어지면 환경 기본값을 재정의합니다. In은 &lt;code&gt;harness_class&lt;/code&gt; (기본값은 &lt;code&gt;TAP::Harness&lt;/code&gt; )와 하네스 클래스가 허용하는 모든 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="36f7d1c76b617d33ccfffcd0313dd243dca9de11" translate="yes" xml:space="preserve">
          <source>This function returns FALSE for strings containing any code points above the Unicode max of 0x10FFFF or surrogate code points, but accepts non-character code points per &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Corrigendum #9&lt;/a&gt;.</source>
          <target state="translated">이 함수는 유니 코드 최대 값 인 0x10FFFF 또는 서로 게이트 코드 포인트를 초과하는 코드 포인트를 포함하는 문자열에 대해 FALSE를 반환하지만 &lt;a href=&quot;http://www.unicode.org/versions/corrigendum9.html&quot;&gt;Corrigendum # 9&lt;/a&gt; 당 비 문자 코드 포인트를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="a5d7a81a9a245d7438fa448545d3c2bf90157fa3" translate="yes" xml:space="preserve">
          <source>This function returns FALSE for strings containing any code points above the Unicode max of 0x10FFFF, surrogate code points, or non-character code points.</source>
          <target state="translated">이 함수는 유니 코드 최대 값 인 0x10FFFF, 서로 게이트 코드 포인트 또는 비 문자 코드 포인트를 초과하는 코드 포인트를 포함하는 문자열에 대해 FALSE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13aa5d944aea63735721eab1c7c43ad176915f14" translate="yes" xml:space="preserve">
          <source>This function returns a string of &lt;code&gt;boot_$ModuleName&lt;/code&gt; prototypes for each @modules.</source>
          <target state="translated">이 함수는 각 @ 모듈에 대해 boot_ &lt;code&gt;boot_$ModuleName&lt;/code&gt; 프로토 타입 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4f9139a43ab3e4540adae4f5d5020617b2e643b8" translate="yes" xml:space="preserve">
          <source>This function returns a string of calls to &lt;code&gt;newXS()&lt;/code&gt; that glue the module</source>
          <target state="translated">이 함수는 모듈을 붙이는 &lt;code&gt;newXS()&lt;/code&gt; 호출 문자열을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="621ba7bc642c79bf406939acb2b7c2b8df3903c7" translate="yes" xml:space="preserve">
          <source>This function returns an encoded version of the string ($str) given as argument.</source>
          <target state="translated">이 함수는 인수로 지정된 인코딩 된 버전의 문자열 ($ str)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44086926e42f35072b303b091e9d9e0a7ca33b91" translate="yes" xml:space="preserve">
          <source>This function returns empty-list if given anything other than a formally valid language tag.</source>
          <target state="translated">이 함수는 공식적으로 유효한 언어 태그 이외의 것이 제공되면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df38023076a41559f21264db80802e81879d618e" translate="yes" xml:space="preserve">
          <source>This function returns the count of used buckets in the hash. It is expensive to calculate and the value is NOT cached, so avoid use of this function in production code.</source>
          <target state="translated">이 함수는 해시에서 사용 된 버킷 수를 반환합니다. 계산하는 데 비용이 많이 들고 값이 캐시되지 않으므로 프로덕션 코드에서이 함수를 사용하지 마십시오. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="865f16a5f2b57a820e8bf84b966f732abf36eb70" translate="yes" xml:space="preserve">
          <source>This function returns the plain text version of the string given as argument. The lines of the result are &quot;\n&quot; terminated, even if the $str argument contains &quot;\r\n&quot; terminated lines.</source>
          <target state="translated">이 함수는 인수로 지정된 문자열의 일반 텍스트 버전을 반환합니다. $ str 인수에 &quot;\ r \ n&quot;종결 행이 포함되어 있더라도 결과의 행은 &quot;\ n&quot;종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ab5fe7ba11e207b5f81eca8f934ec6da3fef9c" translate="yes" xml:space="preserve">
          <source>This function returns the string that results from decoding the scalar value</source>
          <target state="translated">이 함수는 스칼라 값을 디코딩하여 생성 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d6da7152ac538ef94012168e86ee3522aaad549" translate="yes" xml:space="preserve">
          <source>This function returns the string with the first character modified if it is a control character. It converts it to ^X format first, so that &quot;\cG&quot; becomes &quot;^G&quot;. This is used internally by &lt;a href=&quot;#SAFENAME&quot;&gt;B::GV::SAFENAME&lt;/a&gt;, but you can call it directly.</source>
          <target state="translated">이 함수는 제어 문자 인 경우 첫 번째 문자가 수정 된 문자열을 반환합니다. &quot;\ cG&quot;가 &quot;^ G&quot;가되도록 먼저 ^ X 형식으로 변환합니다. &lt;a href=&quot;#SAFENAME&quot;&gt;B :: GV :: SAFENAME&lt;/a&gt; 내부적으로 사용 되지만 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58003204cd5bf3cc0d766f8388948446f273cd60" translate="yes" xml:space="preserve">
          <source>This function returns the total number of buckets the hash holds, or would hold if the array were created. (When a hash is freshly created the array may not be allocated even though this value will be non-zero.)</source>
          <target state="translated">이 함수는 해시가 보유하거나 배열이 생성 된 경우 보유 할 총 버킷 수를 반환합니다. (해시가 새로 생성되면이 값이 0이 아니더라도 배열이 할당되지 않을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2c4a068b79e8f40c3a9e262ab52eb09f9c93a717" translate="yes" xml:space="preserve">
          <source>This function sets the default device and directory for the process. It is identical to the built-in chdir() operator, except that the change persists after Perl exits. It returns a true value on success, and &lt;code&gt;undef&lt;/code&gt; if it encounters an error.</source>
          <target state="translated">이 기능은 프로세스에 대한 기본 장치 및 디렉토리를 설정합니다. Perl이 종료 된 후에도 변경 사항이 지속된다는 점을 제외하면 내장 chdir () 연산자와 동일합니다. 성공하면 참 값을 반환하고 오류가 발생하면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3960f619466a09edf20242d0c7f969690cbc6219" translate="yes" xml:space="preserve">
          <source>This function should be as efficient as possible to keep your programs running as fast as possible.</source>
          <target state="translated">이 기능은 프로그램을 최대한 빠르게 실행하기 위해 가능한 한 효율적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a1ef4b3781258f0fdbabb5991f2b0a7c13aaadc" translate="yes" xml:space="preserve">
          <source>This function should have been named wantlist() instead.</source>
          <target state="translated">이 함수는 대신 wantlist ()라는 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="0b507d2e008bacdbb9e54edf21d0bbb50fdaab83" translate="yes" xml:space="preserve">
          <source>This function should not be called if you are using the object oriented interface since the it will interfere with the object destructor deleting the file.</source>
          <target state="translated">객체 지향 인터페이스를 사용하는 경우 파일을 삭제하는 객체 소멸자를 방해하므로이 함수를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c82575cb1cd9500578e180e36936964e6acbcd65" translate="yes" xml:space="preserve">
          <source>This function should not have a compatibility macro to define, say, &lt;code&gt;Perl_parse&lt;/code&gt; to &lt;code&gt;parse&lt;/code&gt; . It must be called as &lt;code&gt;Perl_parse&lt;/code&gt; .</source>
          <target state="translated">이 함수에는 &lt;code&gt;Perl_parse&lt;/code&gt; to &lt;code&gt;parse&lt;/code&gt; 를 정의하기위한 호환성 매크로가 없어야 합니다 . &lt;code&gt;Perl_parse&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="63eb3b3ba108688ddd872a95b52c197f8b6499d3" translate="yes" xml:space="preserve">
          <source>This function should only be used to display the actual OS name to the user; it should not be used to determine the class of operating systems this system belongs to. The Win32::GetOSName(), Win32::GetOSVersion, Win32::GetProductInfo() and Win32::GetSystemMetrics() functions provide the base information to check for certain capabilities, or for families of OS releases.</source>
          <target state="translated">이 기능은 사용자에게 실제 OS 이름을 표시하는 데만 사용해야합니다. 이 시스템이 속한 운영 체제의 클래스를 결정하는 데 사용해서는 안됩니다. Win32 :: GetOSName (), Win32 :: GetOSVersion, Win32 :: GetProductInfo () 및 Win32 :: GetSystemMetrics () 함수는 특정 기능 또는 OS 릴리스 제품군을 확인하기위한 기본 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd99feaf61a2bec56d635937abeb8d24fef9d878" translate="yes" xml:space="preserve">
          <source>This function simply calls the Microsoft C library _getdcwd() function.</source>
          <target state="translated">이 함수는 단순히 Microsoft C 라이브러리 _getdcwd () 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7c73c162d2f4a3c57002d94f30e626af9a64555c" translate="yes" xml:space="preserve">
          <source>This function simply returns a string defining the same &lt;code&gt;EXTERN_C&lt;/code&gt; macro as</source>
          <target state="translated">이 함수는 단순히 같은 &lt;code&gt;EXTERN_C&lt;/code&gt; 매크로를 정의하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ab2ac7d8042c579036bf811ff64ad55b40d9830" translate="yes" xml:space="preserve">
          <source>This function skips over the automatic calls to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; made on the behalf of the debugger. If the stack frame requested was a sub called by &lt;code&gt;DB::sub&lt;/code&gt; , the return value will be the frame for the call to &lt;code&gt;DB::sub&lt;/code&gt; , since that has the correct line number/etc. for the call site. If</source>
          <target state="translated">이 함수는 디버거를 대신하여 작성된 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 대한 자동 호출을 건너 뜁니다 . 요청 된 스택 프레임이 &lt;code&gt;DB::sub&lt;/code&gt; 의해 호출 된 서브 인 경우, 리턴 값은 올바른 행 번호 등을 가지므로 &lt;code&gt;DB::sub&lt;/code&gt; 에 대한 호출의 프레임이됩니다 . 전화 사이트. 만약</target>
        </trans-unit>
        <trans-unit id="f1861ae5b3c09bcddcc47e8c0460228b36a9717f" translate="yes" xml:space="preserve">
          <source>This function skips over the automatic calls to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; made on the behalf of the debugger. If the stack frame requested was a sub called by &lt;code&gt;DB::sub&lt;/code&gt;, the return value will be the frame for the call to &lt;code&gt;DB::sub&lt;/code&gt;, since that has the correct line number/etc. for the call site. If</source>
          <target state="translated">이 함수는 디버거를 대신하여 만든 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 대한 자동 호출을 건너 뜁니다 . 요청 된 스택 프레임이 &lt;code&gt;DB::sub&lt;/code&gt; 의해 호출 된 서브 인 경우, 반환 값은 올바른 라인 번호 / 등을 가지고 있기 때문에 &lt;code&gt;DB::sub&lt;/code&gt; 호출에 대한 프레임이됩니다 . 전화 사이트. 만약</target>
        </trans-unit>
        <trans-unit id="110e361d90fd374a271ccdacfa1a475088fcdc8e" translate="yes" xml:space="preserve">
          <source>This function takes a codeblock as its only argument, and it has a prototype. It will execute the codeblock, intercepting any generated events in the process. It will return an array reference with all the generated event objects. All events should be subclasses of &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;.</source>
          <target state="translated">이 함수는 코드 블록을 유일한 인수로 사용하며 프로토 타입이 있습니다. 프로세스에서 생성 된 이벤트를 가로 채서 코드 블록을 실행합니다. 생성 된 모든 이벤트 객체와 함께 배열 참조를 반환합니다. 모든 이벤트는 &lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event의&lt;/a&gt; 하위 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="3f1ed900c36dd5852fb31f0242bde189d87ee34e" translate="yes" xml:space="preserve">
          <source>This function takes a list of 0 or more language tags that constitute a given user's Accept-Language list, and returns a list of tags for</source>
          <target state="translated">이 함수는 주어진 사용자의 Accept-Language 목록을 구성하는 0 개 이상의 언어 태그 목록을 가져 와서에 대한 태그 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bddbbd4becb2f5cc5272150e5ca82b4b58f7fa5f" translate="yes" xml:space="preserve">
          <source>This function takes a scalar argument and returns a boolean value indicating whether the argument meets the &quot;lax&quot; rules for a version number. Leading and trailing spaces are not allowed.</source>
          <target state="translated">이 함수는 스칼라 인수를 취하고 인수가 버전 번호에 대한 &quot;lax&quot;규칙을 충족하는지 여부를 나타내는 부울 값을 반환합니다. 선행 및 후행 공백은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38c08de34d39f2e0da8affe01dbc6fa96a8b507f" translate="yes" xml:space="preserve">
          <source>This function takes a scalar argument and returns a boolean value indicating whether the argument meets the &quot;strict&quot; rules for a version number. Leading and trailing spaces are not allowed.</source>
          <target state="translated">이 함수는 스칼라 인수를 사용하고 인수가 버전 번호에 대한 &quot;엄격한&quot;규칙을 충족하는지 여부를 나타내는 부울 값을 반환합니다. 선행 및 후행 공백은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e20c9e90738e4e12b4b244ae6847d7d7fb0c7dd" translate="yes" xml:space="preserve">
          <source>This function takes a variable number of arguments, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; style. The argument list should end with &lt;code&gt;...&lt;/code&gt; , like this:</source>
          <target state="translated">이 함수는 가변 개수의 인자, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 스타일을 취합니다 . 인수 목록은 다음과 같이 &lt;code&gt;...&lt;/code&gt; 로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf2eecbd5d099ce08ffbe9b809327bd3414ba65b" translate="yes" xml:space="preserve">
          <source>This function takes no arguments, and as far as &lt;code&gt;Memoize&lt;/code&gt; is concerned, it always returns the same result. &lt;code&gt;Memoize&lt;/code&gt; is wrong, of course, and the memoized version of this function will call &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; once to get the current time, and it will return that same time every time you call it after that.</source>
          <target state="translated">이 함수는 인수를 취하지 않으며 &lt;code&gt;Memoize&lt;/code&gt; 에 관한 한 항상 동일한 결과를 반환합니다. &lt;code&gt;Memoize&lt;/code&gt; 은 물론, 잘못이며,이 함수의 memoized 버전이 호출 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 현재 시간을 얻기 위해 한 번, 그리고 그 같은 시간에 당신이 그 이후를 호출 할 때마다 반환합니다.</target>
        </trans-unit>
        <trans-unit id="559b31c7b52a11340d8d10694e3f1b4f8fecacfa" translate="yes" xml:space="preserve">
          <source>This function takes no arguments, and as far as &lt;code&gt;Memoize&lt;/code&gt; is concerned, it always returns the same result. &lt;code&gt;Memoize&lt;/code&gt; is wrong, of course, and the memoized version of this function will call &lt;code&gt;time&lt;/code&gt; once to get the current time, and it will return that same time every time you call it after that.</source>
          <target state="translated">이 함수는 인수를 취하지 않으며 &lt;code&gt;Memoize&lt;/code&gt; 에 관한 한 항상 동일한 결과를 반환합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 물론 &lt;code&gt;Memoize&lt;/code&gt; 는 잘못 되었으며이 함수의 메모 화 된 버전은 현재 시간을 얻기 위해 &lt;code&gt;time&lt;/code&gt; 한 번 호출하고 그 이후에 호출 할 때마다 동일한 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44a28d0d2b0d75e1d681cb10ebfe192aa26bfeab" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is an empty string, it is interpreted as referring to the &lt;code&gt;main&lt;/code&gt; package. If CLASSNAME is omitted, the current package is used. Because a &lt;a href=&quot;#bless-REF%2CCLASSNAME&quot;&gt;&lt;code&gt;bless&lt;/code&gt;&lt;/a&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the method doing the blessing. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">이 함수는 REF가 참조하는 사물에게 현재 CLASSNAME 패키지의 객체임을 알려줍니다. CLASSNAME이 빈 문자열이면 &lt;code&gt;main&lt;/code&gt; 패키지 를 참조하는 것으로 해석됩니다 . CLASSNAME이 생략되면 현재 패키지가 사용됩니다. &lt;a href=&quot;#bless-REF%2CCLASSNAME&quot;&gt; &lt;code&gt;bless&lt;/code&gt; &lt;/a&gt; 은 종종 생성자에서 마지막 항목 이기 때문에 편의를 위해 참조를 반환합니다. 파생 클래스가 축복을 수행하는 메서드를 상속 할 수있는 경우 항상 두 인수 버전을 사용합니다. 개체의 축복 (및 축복)에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5edb4f65abb2fc47967dac5333a9e803321aac25" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">이 함수는 REF가 참조하는 것을 CLASSNAME 패키지의 객체라고 알려줍니다. CLASSNAME을 생략하면 현재 패키지가 사용됩니다. a가 있기 때문에 &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 종종 생성자의 마지막 일, 그것은 편의를 위해 참조를 반환합니다. 파생 클래스가 축복을 수행하는 함수를 상속 할 수있는 경우 항상 두 개의 인수 버전을 사용하십시오. 사물의 축복 (및 축복)에 대한 자세한 내용은 &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="264717bee5831f635e17b82abeba8fa8b801090b" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">이 함수는 REF가 참조하는 것을 CLASSNAME 패키지의 객체라고 알려줍니다. CLASSNAME을 생략하면 현재 패키지가 사용됩니다. a가 있기 때문에 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 종종 생성자의 마지막 일, 그것은 편의를 위해 참조를 반환합니다. 파생 클래스가 축복을 수행하는 함수를 상속 할 수있는 경우 항상 두 개의 인수 버전을 사용하십시오. 사물의 축복 (및 축복)에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d01eea1f06346371db6a328408650ca1c6b5ca7" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;load&lt;/code&gt; function or the &lt;code&gt;autoload_remote&lt;/code&gt; function from Module::Load under the hood.</source>
          <target state="translated">이 함수는 후드 아래의 Module :: Load에서 &lt;code&gt;load&lt;/code&gt; 기능 또는 &lt;code&gt;autoload_remote&lt;/code&gt; 기능을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f87dbe6925db468abc769225ebccdc2e0259cd96" translate="yes" xml:space="preserve">
          <source>This function was copied from &lt;code&gt;Sub::Name::subname&lt;/code&gt; and renamed to the naming convention of this module.</source>
          <target state="translated">이 함수는 &lt;code&gt;Sub::Name::subname&lt;/code&gt; 에서 복사 되었으며이 모듈의 명명 규칙으로 이름이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="511fcaf3db3ec5f256e19c49e3e9d50ebc6f2024" translate="yes" xml:space="preserve">
          <source>This function was inspired by &lt;code&gt;sub_fullname&lt;/code&gt; from &lt;a href=&quot;Sub::Identify&quot;&gt;Sub::Identify&lt;/a&gt;. The remaining functions that &lt;code&gt;Sub::Identify&lt;/code&gt; implements can easily be emulated using regexp operations, such as</source>
          <target state="translated">이 함수는 &lt;a href=&quot;Sub::Identify&quot;&gt;Sub :: Identify의 &lt;/a&gt; &lt;code&gt;sub_fullname&lt;/code&gt; 에서 영감을 받았습니다 . &lt;code&gt;Sub::Identify&lt;/code&gt; 구현 하는 나머지 함수는 다음 과 같은 regexp 연산을 사용하여 쉽게 에뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde06d7625f57e7da1a76d11827641ea58931d51" translate="yes" xml:space="preserve">
          <source>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터는 플랫폼 간의 차이점이 대부분의 코드에서 보이지 않게되었으므로이 기능은 당신이 원합니다. 이 정확한 기능이 필요한 경우 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72cf5666687c9403c19f9817bf07791c2373d1e9" translate="yes" xml:space="preserve">
          <source>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터 플랫폼 간의 구분이 대부분의 코드에서 보이지 않게 되었기 때문에이 함수는 다음과 같을 가능성이 거의 없습니다. 당신이 원합니다. 이 정확한 기능이 필요한 경우 &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e428d7e7165fe610c2ec2aae0a7a0abdc81b5d5a" translate="yes" xml:space="preserve">
          <source>This function will calculate and return the binary digest of the bytes of the given file. The function will croak if it fails to open or read the file.</source>
          <target state="translated">이 함수는 주어진 파일의 바이트 이진 다이제스트를 계산하고 반환합니다. 파일을 열거 나 읽지 못하면 함수가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="fd596d51482a44fe07dfcd21f50a65f8052fad22" translate="yes" xml:space="preserve">
          <source>This function will collect the data described in &lt;a href=&quot;#The-hash-structure&quot;&gt;&quot;The hash structure&quot;&lt;/a&gt; below, and return that as a hash reference. It optionally accepts an option to include more entries from %ENV. See &lt;a href=&quot;#environment&quot;&gt;&quot;environment&quot;&lt;/a&gt; below.</source>
          <target state="translated">이 함수는 아래 &lt;a href=&quot;#The-hash-structure&quot;&gt;&quot;해시 구조&quot;에&lt;/a&gt; 설명 된 데이터를 수집하고 이를 해시 참조로 반환합니다. % ENV에서 더 많은 항목을 포함하는 옵션을 선택적으로 허용합니다. 아래의 &lt;a href=&quot;#environment&quot;&gt;&quot;환경&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e710ca7b4ebf9ab0536802088bacbcbd1c5ec7fb" translate="yes" xml:space="preserve">
          <source>This function will concatenate all arguments, calculate the MD5 digest of this &quot;message&quot;, and return it in binary form. The returned string will be 16 bytes long.</source>
          <target state="translated">이 함수는 모든 인수를 연결하고이 &quot;메시지&quot;의 MD5 다이제스트를 계산하여 이진 형식으로 반환합니다. 반환 된 문자열의 길이는 16 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="c489f76d5438c6d22b3cb418ff3f520db9ae337f" translate="yes" xml:space="preserve">
          <source>This function will convert to UTF-8 (and not warn) even code points that aren't legal Unicode or are problematic, unless &lt;code&gt;flags&lt;/code&gt; contains one or more of the following flags:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 가 다음 플래그 중 하나 이상을 포함 하지 않는 한,이 함수는 합법적 인 유니 코드가 아니거나 문제가있는 코드 포인트를 UTF-8로 변환하고 경고하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa2e2cbe1081798fb5dd07961b2589448f68e0d" translate="yes" xml:space="preserve">
          <source>This function will croak if it can't connect to the syslog daemon.</source>
          <target state="translated">이 기능은 syslog 데몬에 연결할 수없는 경우 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="387cb216c9e75c1a719a69623bb869c50aab490e" translate="yes" xml:space="preserve">
          <source>This function will croak if the determined encoding isn't recognized by the Encode module.</source>
          <target state="translated">이 함수는 결정된 인코딩이 Encode 모듈에서 인식되지 않는 경우 비뚤어집니다.</target>
        </trans-unit>
        <trans-unit id="c8fb41e9972ce033692cb3bc009110bcfa6b3909" translate="yes" xml:space="preserve">
          <source>This function will not be confused by overloading or blessing. In internals terms, this extracts the regexp pointer out of the PERL_MAGIC_qr structure so it cannot be fooled.</source>
          <target state="translated">이 기능은 과부 하나 축복으로 혼동되지 않습니다. 내부적으로 말하면 PERL_MAGIC_qr 구조에서 정규 표현식 포인터를 추출하여 속일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e051c29d133cbded6b7972c7afb22f014eeabf3e" translate="yes" xml:space="preserve">
          <source>This function will return an ANSI folder path if the long name cannot be represented in the system codepage. Use Win32::GetLongPathName() on the result of Win32::GetFolderPath() if you want the Unicode version of the folder name.</source>
          <target state="translated">이 함수는 시스템 코드 페이지에 긴 이름을 표시 할 수없는 경우 ANSI 폴더 경로를 반환합니다. 폴더 이름의 유니 코드 버전을 원하는 경우 Win32 :: GetFolderPath ()의 결과에 Win32 :: GetLongPathName ()을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bdf7565f2d5b49ccdcf0417e04e7ffb7876b15d0" translate="yes" xml:space="preserve">
          <source>This function will split up your program into files that the AutoLoader module can handle. It is used by both the standard perl libraries and by the MakeMaker utility, to automatically configure libraries for autoloading.</source>
          <target state="translated">이 기능은 프로그램을 AutoLoader 모듈이 처리 할 수있는 파일로 분할합니다. 표준 perl 라이브러리와 MakeMaker 유틸리티에서 자동로드 용 라이브러리를 자동으로 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7095163faacd01b9504e393cc3471c37894d46cb" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;a href=&quot;#chroot-FILENAME&quot;&gt;&lt;code&gt;chroot&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 동일한 이름의 시스템 호출과 같이 작동 합니다. 프로세스 및 모든 하위에 의해 &lt;code&gt;/&lt;/code&gt; 로 시작하는 모든 추가 경로 이름에 대해 명명 된 디렉토리를 새 루트 디렉토리로 만듭니다. (현재 작업 디렉토리는 변경되지 않으며 영향을받지 않습니다.) 보안상의 이유로이 호출은 수퍼 유저로 제한됩니다. FILENAME이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#chroot-FILENAME&quot;&gt; &lt;code&gt;chroot&lt;/code&gt; &lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="eb5d34127b41d73e4ad33707ae6e0f3468fa3088" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">이 함수는 같은 이름의 시스템 호출처럼 작동 합니다. 프로세스와 모든 자식 에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 모든 추가 경로 이름의 명명 된 디렉토리를 새 루트 디렉토리로 만듭니다. (현재 작업 디렉토리는 변경되지 않으며 영향을받지 않습니다.) 보안상의 이유로이 호출은 수퍼 유저로 제한됩니다. FILENAME을 생략하면 &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;$_&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a4f0880e6d532a1f27ed2ddbef9335a9b1af6165" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">이 함수는 같은 이름의 시스템 호출처럼 작동 합니다. 프로세스와 모든 자식 에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 모든 추가 경로 이름의 명명 된 디렉토리를 새 루트 디렉토리로 만듭니다. (현재 작업 디렉토리는 변경되지 않으며 영향을받지 않습니다.) 보안상의 이유로이 호출은 수퍼 유저로 제한됩니다. FILENAME을 생략하면 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;$_&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b573658383b8e6308fcb8df540075814ffcb1eb9" translate="yes" xml:space="preserve">
          <source>This function writes an EOF to a file handle, if the device driver supports this operation. Its primary use is to send an EOF to a subprocess through a pipe opened for writing without closing the pipe. It returns a true value if successful, and &lt;code&gt;undef&lt;/code&gt; if it encounters an error.</source>
          <target state="translated">이 함수는 장치 드라이버가이 작업을 지원하는 경우 파일 핸들에 EOF를 씁니다. 주요 용도는 파이프를 닫지 않고 쓰기 위해 열린 파이프를 통해 EOF를 하위 프로세스로 보내는 것입니다. 성공하면 참 값을 반환하고 오류가 발생하면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef6e36bc13a174b6b1778b35a2d60399ce6095bb" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns all language tags that are alternate forms of this language tag. (I.e., tags which refer to the same language.) This is meant to handle legacy tags caused by the minor changes in language tag standards over the years; and the x-/i- alternation is also dealt with.</source>
          <target state="translated">언어 태그가 지정된 경우이 함수는이 언어 태그의 대체 형식 인 모든 언어 태그를 반환합니다. (즉, 동일한 언어를 나타내는 태그입니다.) 이는 수년에 걸쳐 언어 태그 표준의 작은 변화로 인한 레거시 태그를 처리하기위한 것입니다. x- / i-alternation도 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8a93fcdf2125a7d09fd995b425967c3b4164e45" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns an encoding of it such that:</source>
          <target state="translated">언어 태그가 지정된 경우이 함수는 다음과 같은 인코딩을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ab422ba4ddb7cdb9c2c2585a4c8bf7188aa9975a" translate="yes" xml:space="preserve">
          <source>This function, which is included in the two export tags listed above, takes one or two arguments. The first is the glob pattern. The second is a set of flags ORed together. The available flags are listed below under &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS&lt;/a&gt;. If the second argument is omitted, &lt;code&gt;GLOB_CSH&lt;/code&gt; (or &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; on VMS and DOSish systems) is used by default.</source>
          <target state="translated">위에 나열된 두 개의 내보내기 태그에 포함 된이 함수는 하나 또는 두 개의 인수를 사용합니다. 첫 번째는 glob 패턴입니다. 두 번째는 OR로 묶인 플래그 집합입니다. 사용 가능한 플래그는 아래 &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS&lt;/a&gt; 아래에 나열되어 있습니다 . 두 번째 인수를 생략하면 &lt;code&gt;GLOB_CSH&lt;/code&gt; (또는 VMS 및 DOSish 시스템의 &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; )가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="270550ffed57f85638e08b5ab27b3fa6e1378d46" translate="yes" xml:space="preserve">
          <source>This function, which is included in the two export tags listed above, takes one or two arguments. The first is the glob pattern. The second, if given, is a set of flags ORed together. The available flags and the default set of flags are listed below under &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;&quot;POSIX FLAGS&quot;&lt;/a&gt;.</source>
          <target state="translated">위에 나열된 두 개의 내보내기 태그에 포함 된이 함수는 하나 또는 두 개의 인수를 사용합니다. 첫 번째는 glob 패턴입니다. 두 번째는 주어지면 함께 OR 된 플래그 집합입니다. 사용 가능한 플래그와 기본 플래그 집합은 &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;&quot;POSIX FLAGS&quot;&lt;/a&gt; 아래에 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7607d86adf25319082630a8f720c18a028dc2b55" translate="yes" xml:space="preserve">
          <source>This functionality is disabled for setuid scripts and for scripts run with &lt;b&gt;-T&lt;/b&gt;.</source>
          <target state="translated">이 기능은 setuid 스크립트 및 &lt;b&gt;-T로&lt;/b&gt; 실행되는 스크립트에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f8830a83703c17da0879b0b7888f8216be9d6342" translate="yes" xml:space="preserve">
          <source>This functionality is disabled for setuid scripts, for scripts run with &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt;, and for scripts run on a Perl built without &lt;code&gt;-DDEBUGGING&lt;/code&gt; support.</source>
          <target state="translated">이 기능은 setuid 스크립트, &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;로&lt;/a&gt; 실행되는 스크립트 및 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 지원 없이 빌드 된 Perl에서 실행되는 스크립트에 대해 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7553b3094129fa58516257b0cce463898fb85b" translate="yes" xml:space="preserve">
          <source>This generates a compile-time error if you access a variable that was neither explicitly declared (using any of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
vars&lt;/code&gt; ) nor fully qualified. (Because this is to avoid variable suicide problems and subtle dynamic scoping issues, a merely &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; variable isn't good enough.) See &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;, &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;, &lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;, and &lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 선언되지 않은 ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용)&lt;/a&gt; 변수가 아닌 정규화 된 변수에 액세스하면 컴파일 타임 오류가 발생합니다 . (이것은 가변 자살 문제와 미묘한 동적 범위 지정 문제를 피하기위한 것이므로 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 변수로는 충분하지 않습니다.) &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; , &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; , &lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; 및 &lt;a href=&quot;vars&quot;&gt;vars를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04dcf622c7ae471e31f3e87386651dc0f523184a" translate="yes" xml:space="preserve">
          <source>This generates a compile-time error if you access a variable that was neither explicitly declared (using any of &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, or &lt;code&gt;use vars&lt;/code&gt;) nor fully qualified. (Because this is to avoid variable suicide problems and subtle dynamic scoping issues, a merely &lt;code&gt;local&lt;/code&gt; variable isn't good enough.) See &lt;a href=&quot;perlfunc#my&quot;&gt;&quot;my&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#our&quot;&gt;&quot;our&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#state&quot;&gt;&quot;state&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#local&quot;&gt;&quot;local&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 선언되지 않았거나 ( &lt;code&gt;my&lt;/code&gt; , &lt;code&gt;our&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; 를 &lt;code&gt;use vars&lt;/code&gt; 하거나 vars를 사용하여 ) 정규화 된 변수에 액세스하면 컴파일 타임 오류가 발생합니다 . (이것은 다양한 자살 문제와 미묘한 동적 범위 지정 문제를 피하기위한 것이기 때문에 &lt;code&gt;local&lt;/code&gt; 변수만으로는 충분하지 않습니다.) &lt;a href=&quot;perlfunc#my&quot;&gt;perlfunc의 &quot;my&quot;, perlfunc&lt;/a&gt; 의 &lt;a href=&quot;perlfunc#our&quot;&gt;&quot;our&quot;, perlfunc&lt;/a&gt; 의 &lt;a href=&quot;perlfunc#state&quot;&gt;&quot;state&quot;, perlfunc&lt;/a&gt; 의 &lt;a href=&quot;perlfunc#local&quot;&gt;&quot;local&quot;참조&lt;/a&gt; , 및 &lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f74c9a11ba157a546c0c89330b1cb3bdd1614525" translate="yes" xml:space="preserve">
          <source>This generates a runtime error if you use symbolic references (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;).</source>
          <target state="translated">기호 참조를 사용하는 경우 런타임 오류가 발생합니다 ( &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b0f601577dbb5896904df9ff737e1fa0298974a" translate="yes" xml:space="preserve">
          <source>This gets interpreted as:</source>
          <target state="translated">이것은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="70bf742be7e750bec7fa9fb8e4b6fe30ec9b5f65" translate="yes" xml:space="preserve">
          <source>This gives nasty overhead when you are trying to dynamically require modules at runtime, since you will need to change the module notation (&lt;code&gt;Acme::Comment&lt;/code&gt; ) to a file notation fitting the particular platform you are on.</source>
          <target state="translated">모듈 표기법 ( &lt;code&gt;Acme::Comment&lt;/code&gt; )을 현재 사용중인 특정 플랫폼에 맞는 파일 표기법 으로 변경해야하므로 런타임에 동적으로 모듈을 요구하려고하면 과도한 오버 헤드가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="216bc650b215bdce0b527db5f48a8452f5403d9b" translate="yes" xml:space="preserve">
          <source>This gives nasty overhead when you are trying to dynamically require modules at runtime, since you will need to change the module notation (&lt;code&gt;Acme::Comment&lt;/code&gt;) to a file notation fitting the particular platform you are on.</source>
          <target state="translated">이는 모듈 표기법 ( &lt;code&gt;Acme::Comment&lt;/code&gt; )을 현재 사용중인 특정 플랫폼에 맞는 파일 표기법 으로 변경해야하기 때문에 런타임에 동적으로 모듈을 요구하려고 할 때 심한 오버 헤드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7c019885847002a06e56f60b480505499d5d7585" translate="yes" xml:space="preserve">
          <source>This gives the name of the extension (</source>
          <target state="translated">확장명을 제공합니다 (</target>
        </trans-unit>
        <trans-unit id="6663727bf6f9219b6a90ea1ea6946a59c195f810" translate="yes" xml:space="preserve">
          <source>This gives the short display label for each define, as used by &lt;code&gt;B::Concise&lt;/code&gt; and &lt;code&gt;perl -Dx&lt;/code&gt;, e.g.</source>
          <target state="translated">이것에 의해 사용 된 각각의 정의에 대한 짧은 표시 라벨을 부여 &lt;code&gt;B::Concise&lt;/code&gt; 하고 &lt;code&gt;perl -Dx&lt;/code&gt; 예</target>
        </trans-unit>
        <trans-unit id="342a7def02667aaf341bdacadaf48888e393c3fe" translate="yes" xml:space="preserve">
          <source>This gives the value of every &lt;code&gt;OPp&lt;/code&gt; define, e.g.</source>
          <target state="translated">이것은 모든 &lt;code&gt;OPp&lt;/code&gt; 정의 의 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bccb3b61d1478918319c14eea9dc5937ac460bf4" translate="yes" xml:space="preserve">
          <source>This gives you the chance to set some default values to your fields. The only argument is &lt;code&gt;$self&lt;/code&gt; with its indexes already set from the constructor.</source>
          <target state="translated">이렇게하면 필드에 몇 가지 기본값을 설정할 수 있습니다. 유일한 인수는 생성자에서 이미 설정된 인덱스 가있는 &lt;code&gt;$self&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b221eef709fb6d96fbb9db3f118edc097a1ba2d" translate="yes" xml:space="preserve">
          <source>This global modifies the argument given to &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;Params::Check::check()&lt;/code&gt; and is useful if you have a custom wrapper function around &lt;code&gt;Params::Check::check()&lt;/code&gt; . The value must be an integer, indicating the number of wrapper functions inserted between the real function call and &lt;code&gt;Params::Check::check()&lt;/code&gt; .</source>
          <target state="translated">이 세계에 주어진 인수 수정 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 에 의해 &lt;code&gt;Params::Check::check()&lt;/code&gt; 및 주변 기능 래퍼 사용자 지정이있는 경우에 유용 &lt;code&gt;Params::Check::check()&lt;/code&gt; . 값은 정수 여야하며, 실제 함수 호출과 &lt;code&gt;Params::Check::check()&lt;/code&gt; 사이에 삽입 된 랩퍼 함수 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e2793ac5b9f6e0e35f292e46fa45362370f25c5a" translate="yes" xml:space="preserve">
          <source>This global modifies the argument given to &lt;code&gt;caller()&lt;/code&gt; by &lt;code&gt;Params::Check::check()&lt;/code&gt; and is useful if you have a custom wrapper function around &lt;code&gt;Params::Check::check()&lt;/code&gt;. The value must be an integer, indicating the number of wrapper functions inserted between the real function call and &lt;code&gt;Params::Check::check()&lt;/code&gt;.</source>
          <target state="translated">이 세계에 주어진 인수 수정 &lt;code&gt;caller()&lt;/code&gt; 에 의해 &lt;code&gt;Params::Check::check()&lt;/code&gt; 및 주변 기능 래퍼 사용자 지정이있는 경우에 유용 &lt;code&gt;Params::Check::check()&lt;/code&gt; . 값은 실제 함수 호출과 &lt;code&gt;Params::Check::check()&lt;/code&gt; 사이에 삽입 된 래퍼 함수의 수를 나타내는 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8923baf9a118df6243078227c2bc3261ab6c170" translate="yes" xml:space="preserve">
          <source>This globally overrides the default behavior of calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside a thread, and effectively causes such calls to behave the same as &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . In other words, with this setting, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; causes only the thread to terminate.</source>
          <target state="translated">이것은 스레드 내부에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 호출의 기본 동작을 전체적으로 무시 하고 효과적으로 이러한 호출이 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 와 동일하게 작동하도록합니다 . 즉,이 설정으로 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 호출 하면 스레드 만 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="60974177d65f638974a74bbf69a2aed83266d31c" translate="yes" xml:space="preserve">
          <source>This globally overrides the default behavior of calling &lt;code&gt;exit()&lt;/code&gt; inside a thread, and effectively causes such calls to behave the same as &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. In other words, with this setting, calling &lt;code&gt;exit()&lt;/code&gt; causes only the thread to terminate.</source>
          <target state="translated">이것은 스레드 내에서 &lt;code&gt;exit()&lt;/code&gt; 호출의 기본 동작을 전역 적으로 재정의하고 이러한 호출이 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 와 동일하게 동작하도록 효과적으로 만듭니다 . 즉,이 설정에서 &lt;code&gt;exit()&lt;/code&gt; 호출 하면 스레드 만 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9d1a7a9bddd9acdc92fdc5c3e015da338283422a" translate="yes" xml:space="preserve">
          <source>This guarantees that STDOUT (where the test results appear) and STDERR (where the diagnostics appear) will stay in sync. The harness will display any diagnostics your tests emit on STDERR.</source>
          <target state="translated">이렇게하면 STDOUT (테스트 결과가 나타나는 곳)과 STDERR (진단이 나타나는 곳)가 동기화 상태를 유지하게됩니다. 하네스는 STDERR에서 테스트가 수행 한 모든 진단을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0e3e5ed908d1238444298278d7f13a68bf8c54c" translate="yes" xml:space="preserve">
          <source>This guide assumes you have obtained a prebuilt archive from os4depot.net.</source>
          <target state="translated">이 가이드는 사용자가 os4depot.net에서 미리 빌드 된 아카이브를 얻은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="42a4c1ea9375fac79bda6e86d1c0d58e79a8f06c" translate="yes" xml:space="preserve">
          <source>This had Test::Builder2 conditionals. This was fixed by removing the conditionals.</source>
          <target state="translated">여기에는 Test :: Builder2 조건이 있습니다. 이것은 조건문을 제거하여 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="06edcd446459b13f358d5f7a1e7f44f85855880a" translate="yes" xml:space="preserve">
          <source>This happened because the presence of overloading was checked too early, before any tie()d access was attempted. If the class of the value FETCH()ed from the tied variable does not change, a simple workaround for code that is to run on older Perl versions is to access the value (via &lt;code&gt;() = $foo&lt;/code&gt; or some such) immediately after tie()ing, so that after this call the</source>
          <target state="translated">이것은 tie () d 액세스가 시도되기 전에 과부하가 너무 일찍 확인 되었기 때문에 발생했습니다. 연결된 변수에서 FETCH () 값의 클래스가 변경되지 않으면 이전 Perl 버전에서 실행되는 코드에 대한 간단한 해결 방법은 연결 직후에 &lt;code&gt;() = $foo&lt;/code&gt; 또는 그와 같은 방법으로) 값에 액세스하는 것입니다. 이 호출 후</target>
        </trans-unit>
        <trans-unit id="4f907111d1d29806bed6e772fe053aff55cf72f3" translate="yes" xml:space="preserve">
          <source>This happens because Berkeley DB uses dynamic memory to allocate buffers which will subsequently be written to the database file. Being dynamic, the memory could have been used for anything before DB malloced it. As Berkeley DB doesn't clear the memory once it has been allocated, the unused portions will contain random junk. In the case where a Perl script gets written to the database, the random junk will correspond to an area of dynamic memory that happened to be used during the compilation of the script.</source>
          <target state="translated">Berkeley DB는 동적 메모리를 사용하여 버퍼를 할당하고 이후 버퍼를 데이터베이스 파일에 기록하기 때문에 발생합니다. 동적이기 때문에 DB가 메모리를 사용하기 전에 메모리가 무엇이든 사용될 수있었습니다. Berkeley DB는 일단 할당 된 메모리를 지우지 않기 때문에 사용하지 않는 부분에는 임의의 정크가 포함됩니다. Perl 스크립트가 데이터베이스에 기록되는 경우 무작위 정크는 스크립트 컴파일 중에 사용 된 동적 메모리 영역에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a1a0c21f8deaf9e9c72ad918fbfe929256d08e89" translate="yes" xml:space="preserve">
          <source>This happens because is_deeply will unoverload all arguments unconditionally. It is probably best not to use is_deeply with overloading. For legacy reasons this is not likely to ever be fixed. If you would like a much better tool for this you should see &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; Specifically &lt;a href=&quot;Test2::Tools::Compare&quot;&gt;Test2::Tools::Compare&lt;/a&gt; has an &lt;code&gt;is()&lt;/code&gt; function that works like &lt;code&gt;is_deeply&lt;/code&gt; with many improvements.</source>
          <target state="translated">이것은 is_deeply가 모든 인수를 무조건 언 오버로드하기 때문에 발생합니다. 오버로딩과 함께 is_deeply를 사용하지 않는 것이 가장 좋습니다. 레거시 이유로이 문제는 해결되지 않을 것입니다. 이것에 대해 훨씬 더 나은 도구를 원한다면 &lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt; 특히 &lt;a href=&quot;Test2::Tools::Compare&quot;&gt;Test2 :: Tools :: Compare&lt;/a&gt; 에는 &lt;code&gt;is_deeply&lt;/code&gt; 처럼 작동 하는 &lt;code&gt;is()&lt;/code&gt; 함수가 있으며 많은 개선 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2287d497a37220b85075e14fb44f3c5f11c4109c" translate="yes" xml:space="preserve">
          <source>This happens because you can't really share arbitrary data structures with foreign processes.</source>
          <target state="translated">외부 프로세스와 임의의 데이터 구조를 실제로 공유 할 수 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3663fa9d53c5bc8b1c430a10078b98451ddfbf78" translate="yes" xml:space="preserve">
          <source>This happens only if your perl is compiled to use stdio instead of perlio, which is the default. Some (maybe all?) stdios set error and eof flags that you may need to clear. The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module defines &lt;code&gt;clearerr()&lt;/code&gt; that you can use. That is the technically correct way to do it. Here are some less reliable workarounds:</source>
          <target state="translated">이는 perl이 perlio 대신 stdio를 사용하도록 컴파일 된 경우에만 발생하며 이것이 기본값입니다. 일부 (아마도?) stdios는 오류와 eof 플래그를 설정해야합니다. &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 정의 &lt;code&gt;clearerr()&lt;/code&gt; 사용할 수있다. 그것이 기술적으로 올바른 방법입니다. 신뢰할 수없는 해결 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40e2474ab2464f5a6d8b366f637789f861001327" translate="yes" xml:space="preserve">
          <source>This happens to avoid shell interpolation problems when whitespace is present in directory names.</source>
          <target state="translated">이것은 디렉토리 이름에 공백이있을 때 쉘 보간 문제를 피하기 위해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76f62e127c6c53c05eb19f5eae3fcd84ce29184a" translate="yes" xml:space="preserve">
          <source>This has a significant advantage in space over reading the whole file in. You can find a proof of this method in</source>
          <target state="translated">이것은 전체 파일을 읽는 것보다 공간에서 중요한 이점이 있습니다.이 방법에 대한 증거는</target>
        </trans-unit>
        <trans-unit id="a19e57e2a77c7fc3b4122f04d13e6469dce9f91c" translate="yes" xml:space="preserve">
          <source>This has been recorded in &lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; as bug #37532: Unable to interleave STDOUT and STDERR.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; 에 버그 # 37532 : STDOUT 및 STDERR을 인터리브 할 수 없음 으로 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cbcdc01d42c333e20ff9808a5f68276ca909022c" translate="yes" xml:space="preserve">
          <source>This has been recorded in &lt;a href=&quot;rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; as bug #37532: Unable to interleave STDOUT and STDERR.</source>
          <target state="translated">이것은 &lt;a href=&quot;rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; 에 bug # 37532 : Unable to interleave STDOUT and STDERR 로 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8f70dda08cfaadcd6df63c157b5e4187c1620e22" translate="yes" xml:space="preserve">
          <source>This has been retracted by Unicode.</source>
          <target state="translated">이것은 유니 코드에 의해 철회되었습니다.</target>
        </trans-unit>
        <trans-unit id="f52d89b3c166d4a363c55e83875dec4c4067987e" translate="yes" xml:space="preserve">
          <source>This has several advantages. Accessors make it easier to change the implementation of an object later while still preserving the original API.</source>
          <target state="translated">이것은 몇 가지 장점이 있습니다. 접근자는 나중에 원래 API를 유지하면서 객체의 구현을 더 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b634ed56e8ae46f559d18b25ae1aeeee821eed7" translate="yes" xml:space="preserve">
          <source>This has the advantage of being backward compatible with older versions of Perl that did not use PerlIO or where &lt;code&gt;:raw&lt;/code&gt; was buggy (as it was before Perl 5.14).</source>
          <target state="translated">이것은 PerlIO를 사용하지 않았거나 &lt;code&gt;:raw&lt;/code&gt; 가 버그가있는 (Perl 5.14 이전과 마찬가지로) 이전 버전의 Perl과 역 호환된다는 장점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34b1eddfb5655aec91f3e8e1f2978f9657ae01a0" translate="yes" xml:space="preserve">
          <source>This has the effect of storing the cache in a &lt;code&gt;DB_File&lt;/code&gt; database whose name is in &lt;code&gt;$filename&lt;/code&gt; . The cache will persist after the program has exited. Next time the program runs, it will find the cache already populated from the previous run of the program. Or you can forcibly populate the cache by constructing a batch program that runs in the background and populates the cache file. Then when you come to run your real program the memoized function will be fast because all its results have been precomputed.</source>
          <target state="translated">이는 이름이 &lt;code&gt;$filename&lt;/code&gt; 인 &lt;code&gt;DB_File&lt;/code&gt; 데이터베이스에 캐시를 저장하는 효과가 있습니다. 캐시는 프로그램이 종료 된 후에도 지속됩니다. 다음에 프로그램이 실행되면 프로그램의 이전 실행에서 이미 채워진 캐시를 찾습니다. 또는 백그라운드에서 실행되고 캐시 파일을 채우는 배치 프로그램을 구성하여 캐시를 강제로 채울 수 있습니다. 그런 다음 실제 프로그램을 실행하면 모든 결과가 사전 계산되어 메모리 기능이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="04a5233be538e5070a6cd575007f00f78a717378" translate="yes" xml:space="preserve">
          <source>This has the effect of storing the cache in a &lt;code&gt;DB_File&lt;/code&gt; database whose name is in &lt;code&gt;$filename&lt;/code&gt;. The cache will persist after the program has exited. Next time the program runs, it will find the cache already populated from the previous run of the program. Or you can forcibly populate the cache by constructing a batch program that runs in the background and populates the cache file. Then when you come to run your real program the memoized function will be fast because all its results have been precomputed.</source>
          <target state="translated">이것은 이름이 &lt;code&gt;$filename&lt;/code&gt; 에있는 &lt;code&gt;DB_File&lt;/code&gt; 데이터베이스에 캐시를 저장하는 효과가 있습니다. 프로그램이 종료 된 후에도 캐시가 유지됩니다. 다음에 프로그램이 실행되면 이전 프로그램 실행에서 이미 채워진 캐시를 찾습니다. 또는 백그라운드에서 실행되고 캐시 파일을 채우는 배치 프로그램을 구성하여 강제로 캐시를 채울 수 있습니다. 그런 다음 실제 프로그램을 실행하면 모든 결과가 미리 계산 되었기 때문에 메모 된 기능이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4f55042605688b1e566dc7078adcb80b2ae71090" translate="yes" xml:space="preserve">
          <source>This has the interesting effect of creating a function local to another function, something not normally supported in Perl.</source>
          <target state="translated">이것은 Perl에서 일반적으로 지원되지 않는 다른 함수의 로컬 함수를 만드는 흥미로운 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04baccbdc9b9fcde7962a296b34a3f02d1708cbd" translate="yes" xml:space="preserve">
          <source>This hash is filled with the variables that &lt;code&gt;perl -V&lt;/code&gt; fills its report with, and it has the same variables that &lt;code&gt;Config::myconfig&lt;/code&gt; returns from &lt;code&gt;%Config&lt;/code&gt;.</source>
          <target state="translated">이 해시는 &lt;code&gt;perl -V&lt;/code&gt; 가 보고서를 채우는 변수로 채워지며 &lt;code&gt;Config::myconfig&lt;/code&gt; 가 &lt;code&gt;%Config&lt;/code&gt; 에서 반환 하는 것과 동일한 변수 를가 집니다.</target>
        </trans-unit>
        <trans-unit id="b1797c70a1d197e558ba86167569174dbeb96a8a" translate="yes" xml:space="preserve">
          <source>This hash should map POD files (or scripts containing POD) to the man file names under the &lt;code&gt;blib/man1/&lt;/code&gt; directory, as in the following example:</source>
          <target state="translated">이 해시는 다음 예와 같이 POD 파일 (또는 POD를 포함하는 스크립트)을 &lt;code&gt;blib/man1/&lt;/code&gt; 디렉토리 의 man 파일 이름에 매핑해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9df8c379bbf80ee5fdd7c982a32f28e6ec7e7ad" translate="yes" xml:space="preserve">
          <source>This holds a hash-of-lists. Each list contains the functions in the category the key denotes.</source>
          <target state="translated">이것은 해시 오브리스트를 보유합니다. 각 목록에는 키가 나타내는 범주의 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d4d81772f7d6d67760a370f3b5798c816acf17" translate="yes" xml:space="preserve">
          <source>This holds a string of the last error that happened during a call to &lt;code&gt;can_load&lt;/code&gt; . It is useful to inspect this when &lt;code&gt;can_load&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;can_load&lt;/code&gt; 호출 중에 발생한 마지막 오류의 문자열을 보유합니다 . &lt;code&gt;can_load&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 할 때 이를 점검하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c00c9aa453b6f56e16b0531efee3c7be9faa87b6" translate="yes" xml:space="preserve">
          <source>This holds a string of the last error that happened during a call to &lt;code&gt;can_load&lt;/code&gt;. It is useful to inspect this when &lt;code&gt;can_load&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; 를 호출하는 동안 발생한 마지막 오류의 문자열을 보유합니다 . &lt;code&gt;can_load&lt;/code&gt; 가 &lt;code&gt;undef&lt;/code&gt; 를 반환 할 때 이를 검사하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="807ff9f1a614524ec64299d0ff11753e548d2db4" translate="yes" xml:space="preserve">
          <source>This holds the cache of the &lt;code&gt;can_load&lt;/code&gt; function. If you explicitly want to remove the current cache, you can set this variable to &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;can_load&lt;/code&gt; 함수 의 캐시를 보유합니다 . 현재 캐시를 명시 적으로 제거하려면이 변수를 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e89b434a4ec5c18b43a734833827829de3493ad4" translate="yes" xml:space="preserve">
          <source>This holds the cache of the &lt;code&gt;can_load&lt;/code&gt; function. If you explicitly want to remove the current cache, you can set this variable to &lt;code&gt;undef&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;can_load&lt;/code&gt; 함수 의 캐시를 보유합니다 . 현재 캐시를 명시 적으로 제거하려면이 변수를 &lt;code&gt;undef&lt;/code&gt; 로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f00ade254acd4a91c287efc124310fc7902663e" translate="yes" xml:space="preserve">
          <source>This idea is from &lt;a href=&quot;JSON::XS::Boolean&quot;&gt;JSON::XS::Boolean&lt;/a&gt; written by Marc Lehmann &amp;lt;schmorp[at]schmorp.de&amp;gt;</source>
          <target state="translated">이 아이디어는 Marc Lehmann이 작성한 &lt;a href=&quot;JSON::XS::Boolean&quot;&gt;JSON :: XS :: Boolean&lt;/a&gt; 에서 나온 것입니다. &amp;lt;schmorp [at] schmorp.de&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0ab611b7e6d978fe2070f07754881b8d06390403" translate="yes" xml:space="preserve">
          <source>This identical to the numerical values of the &lt;code&gt;$!&lt;/code&gt; , see &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$!&lt;/code&gt; 의 숫자 값과 동일합니다 . &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar의 $ ERRNO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34f444d7282d48c73e6ca1798c5dd4a12fb69b6c" translate="yes" xml:space="preserve">
          <source>This identical to the numerical values of the &lt;code&gt;$!&lt;/code&gt;, see &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;&quot;$ERRNO&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$!&lt;/code&gt; , &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar의 &quot;$ ERRNO&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76cd5f270d1b0fd37802c6a7f69eb1401eb75d55" translate="yes" xml:space="preserve">
          <source>This implementation has been moved into the core executable, but you can still load this module for backward compatibility.</source>
          <target state="translated">이 구현은 핵심 실행 파일로 이동되었지만 이전 버전과의 호환성을 위해이 모듈을 계속로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebbc38db38088437ee3de434676f2c9849a55f6" translate="yes" xml:space="preserve">
          <source>This implementation never has to fetch the context using a function call, since it is always passed as an extra argument. Depending on your needs for simplicity or efficiency, you may mix the previous two approaches freely.</source>
          <target state="translated">이 구현은 항상 추가 인수로 전달되므로 함수 호출을 사용하여 컨텍스트를 가져올 필요가 없습니다. 단순성 또는 효율성에 대한 요구에 따라 앞의 두 가지 접근 방식을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6dd1dd5bc3b526c6e18c4c4cf7662fc526f6c1" translate="yes" xml:space="preserve">
          <source>This implements the C library function of the same name, which on most systems returns the current login from</source>
          <target state="translated">이것은 대부분의 시스템에서 현재 로그인을 반환하는 동일한 이름의 C 라이브러리 함수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9b00dbaf392453f8a0c495715d87f8a967ac3280" translate="yes" xml:space="preserve">
          <source>This implicit use of &lt;code&gt;$_&lt;/code&gt; greatly simplifies the filter.</source>
          <target state="translated">이 &lt;code&gt;$_&lt;/code&gt; 의 암시 적 사용은 필터를 크게 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="5b50085de4def35b6bdec8ddfe646e562a42bf85" translate="yes" xml:space="preserve">
          <source>This implicitly turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; .</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을&lt;/a&gt; 암시 적으로 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="b69024702c53c81b289a2bb57c31bbc3bad62a98" translate="yes" xml:space="preserve">
          <source>This implicitly turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;.</source>
          <target state="translated">이것은 암시 적으로 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; 켭니다 .</target>
        </trans-unit>
        <trans-unit id="1913f881cf8f6c8733392373df598260e9eff553" translate="yes" xml:space="preserve">
          <source>This implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; will not have any effect on the internal value of the input record separator.</source>
          <target state="translated">이는 무엇보다도 이러한 변수에 의해 수행되는 모든 마법이 로컬에서 손실된다는 것을 의미합니다. 즉, &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; 을 말하는 것은 입력 레코드 구분 기호의 내부 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42b1909506cafaa0cc94a703a39c522d8ca507d2" translate="yes" xml:space="preserve">
          <source>This implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying &lt;code&gt;local */&lt;/code&gt; will not have any effect on the internal value of the input record separator.</source>
          <target state="translated">이것은 무엇보다도 이러한 변수에 의해 수행되는 모든 마법이 로컬에서 손실된다는 것을 의미합니다. 즉, &lt;code&gt;local */&lt;/code&gt; 이라고 말하면 입력 레코드 구분 기호의 내부 값에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="853b46dcbc0a00c897209b2e5eda11d1bef5190a" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from YourModule's &lt;code&gt;@EXPORT&lt;/code&gt; into the namespace of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">그러면 YourModule &lt;code&gt;@EXPORT&lt;/code&gt; 의 모든 기호 가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문의 네임 스페이스로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a144efc90828bfe698b691d8656be8a5e2096e11" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from YourModule's &lt;code&gt;@EXPORT&lt;/code&gt; into the namespace of the &lt;code&gt;use&lt;/code&gt; statement.</source>
          <target state="translated">이렇게하면 YourModule의 &lt;code&gt;@EXPORT&lt;/code&gt; 에서 모든 기호를 &lt;code&gt;use&lt;/code&gt; 문의 네임 스페이스로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cc30f208dc0886e9e09f0ad72a7741fdb1114419" translate="yes" xml:space="preserve">
          <source>This imports only the symbols listed by the caller into their namespace. All listed symbols must be in your &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , else an error occurs. The advanced export features of Exporter are accessed like this, but with list entries that are syntactically distinct from symbol names.</source>
          <target state="translated">호출자가 나열한 기호 만 해당 네임 스페이스로 가져옵니다. 모든 상장 기호는 당신에 있어야합니다 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , 다른 오류가 발생합니다. Exporter의 고급 내보내기 기능은 이와 같이 액세스되지만 기호 이름과 구문 상 구분되는 목록 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afea1b722b6f3bdd005efaf9802f6bb5f9cce5e7" translate="yes" xml:space="preserve">
          <source>This imports only the symbols listed by the caller into their namespace. All listed symbols must be in your &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;, else an error occurs. The advanced export features of Exporter are accessed like this, but with list entries that are syntactically distinct from symbol names.</source>
          <target state="translated">호출자가 나열한 기호 만 네임 스페이스로 가져옵니다. 모든 상장 기호는 당신에 있어야합니다 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , 다른 오류가 발생합니다. Exporter의 고급 내보내기 기능은 이와 같이 액세스되지만 기호 이름과 구문 적으로 구별되는 목록 항목을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f54334948064b9890996f54ddad24e2c8dcfde1a" translate="yes" xml:space="preserve">
          <source>This incantation is a bit much to remember, but Perl will display it for you if you say &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; .</source>
          <target state="translated">이 주문은 기억해야 할 것이 &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; 이라고 말하면 Perl이 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="1f6ca02a3e63f679a0818fa93fda109eb7890118" translate="yes" xml:space="preserve">
          <source>This incantation is a bit much to remember, but Perl will display it for you if you say &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt;.</source>
          <target state="translated">이 주문은 기억해야 할 부분이 &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; 이라고 말하면 Perl이 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5270d55bdd99c39c88df6b66aa86ef8a427ec941" translate="yes" xml:space="preserve">
          <source>This includes everything before the &amp;lt;title&amp;gt; opening tag including the Document type and including the opening &amp;lt;title&amp;gt; tag. The following call will set it to be a simple HTML file:</source>
          <target state="translated">여기에는 문서 유형을 포함하고 여는 &amp;lt;title&amp;gt; 태그를 포함하여 &amp;lt;title&amp;gt; 여는 태그 앞의 모든 것이 포함됩니다. 다음 호출은 간단한 HTML 파일로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="343b5c0e7585a333dd6568f5785911c3539473ec" translate="yes" xml:space="preserve">
          <source>This indicates a &quot;beta&quot; release that is substantially complete, but has an elevated risk of bugs and requires additional testing. The distribution should not be installed over a stable release without an explicit request or other confirmation from a user. This release status may also be used for &quot;release candidate&quot; versions of a distribution.</source>
          <target state="translated">이는 실질적으로 완료되었지만 버그 위험이 높고 추가 테스트가 필요한 &quot;베타&quot;릴리스를 나타냅니다. 사용자의 명시적인 요청이나 기타 확인없이 안정적인 릴리스 위에 배포를 설치해서는 안됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 릴리스 상태는 배포의 &quot;릴리스 후보&quot;버전에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c991cc788c5d46f7b04a0e2e0cd76cdc76b3e4de" translate="yes" xml:space="preserve">
          <source>This indicates an &quot;alpha&quot; release that is under active development, but has been released for early feedback or testing and may be missing features or may have serious bugs. The distribution should not be installed over a stable release without an explicit request or other confirmation from a user.</source>
          <target state="translated">이는 현재 개발중인 &quot;알파&quot;릴리스를 나타내지 만 초기 피드백 또는 테스트를 위해 릴리스되었으며 기능이 누락되었거나 심각한 버그가있을 수 있습니다. 사용자의 명시적인 요청이나 기타 확인없이 안정적인 릴리스 위에 배포를 설치해서는 안됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="648180ea592e3e8122f6f7de36a2066e615d2ead" translate="yes" xml:space="preserve">
          <source>This indicates an ordinary, &quot;final&quot; release that should be indexed by PAUSE or other indexers.</source>
          <target state="translated">이것은 PAUSE 또는 다른 인덱서에 의해 인덱싱되어야하는 일반적인 &quot;최종&quot;릴리스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e4643de8eedeed9698ffe2974d9db63ab9e6ea1" translate="yes" xml:space="preserve">
          <source>This indicates how numbers should be formatted for human readability, for example the character used as the decimal point.</source>
          <target state="translated">이것은 사람이 읽을 수 있도록 숫자를 형식화하는 방법을 나타냅니다 (예 : 소수점으로 사용되는 문자).</target>
        </trans-unit>
        <trans-unit id="6005230475219b0a5021d5218cbbce15d92f7c81" translate="yes" xml:space="preserve">
          <source>This indicates that Configure is being run with a broken Korn shell (even though you think you are using a Bourne shell by using &quot;sh Configure&quot; or &quot;./Configure&quot;). The Korn shell bug has been reported to Compaq as of February 1999 but in the meanwhile, the reason ksh is being used is that you have the environment variable BIN_SH set to 'xpg4'. This causes /bin/sh to delegate its duties to /bin/posix/sh (a ksh). Unset the environment variable and rerun Configure.</source>
          <target state="translated">이는 &quot;sh Configure&quot;또는 &quot;./Configure&quot;를 사용하여 Bourne 쉘을 사용한다고 생각하더라도 깨진 Korn 쉘로 구성이 실행 중임을 나타냅니다. Korn 쉘 버그는 1999 년 2 월 현재 Compaq에보고되었지만 ksh를 사용하는 이유는 환경 변수 BIN_SH가 'xpg4'로 설정되어 있기 때문입니다. 이로 인해 / bin / sh는 / bin / posix / sh (ksh)에 의무를 위임합니다. 환경 변수를 설정 해제하고 구성을 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="062f44d9692db42f54456303d55718a170b1e245" translate="yes" xml:space="preserve">
          <source>This indicates the ordering of letters for comparison and sorting. In Latin alphabets, for example, &quot;b&quot;, generally follows &quot;a&quot;.</source>
          <target state="translated">비교 및 정렬을위한 문자 순서를 나타냅니다. 라틴 알파벳에서, 예를 들어 &quot;b&quot;는 일반적으로 &quot;a&quot;를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e6751de1d4a71c579b34f21fa42d3fbd6eb68764" translate="yes" xml:space="preserve">
          <source>This indicates, for example if a character is an uppercase letter.</source>
          <target state="translated">예를 들어 문자가 대문자 인 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="101fd7bbc198ec8e6a1a44073eec5c4b13e975cb" translate="yes" xml:space="preserve">
          <source>This information is extracted from the second block that is emitted by &lt;code&gt;perl -V&lt;/code&gt;, and usually looks something like</source>
          <target state="translated">이 정보는 &lt;code&gt;perl -V&lt;/code&gt; 에 의해 방출되는 두 번째 블록에서 추출 되며 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd3774451696e560d0b4cade6d2971bc678079e1" translate="yes" xml:space="preserve">
          <source>This information is not available anywhere else, including &lt;code&gt;%Config&lt;/code&gt;, but it is the information that is only known to the perl binary.</source>
          <target state="translated">이 정보는 &lt;code&gt;%Config&lt;/code&gt; 포함하여 다른 곳에서는 사용할 수 없지만 펄 바이너리에만 알려진 정보입니다.</target>
        </trans-unit>
        <trans-unit id="823a07d7a67d58cd28a477488a1be20465227d53" translate="yes" xml:space="preserve">
          <source>This information is offered in good faith and in the hope that it may be of use, but is not guaranteed to be correct, up to date, or suitable for any particular purpose whatsoever. The authors accept no liability in respect of this information or its use.</source>
          <target state="translated">이 정보는 선의로 제공되며 유용 할 수 있기를 바라지 만 정확하거나 최신 정보이거나 특정 목적에 적합하다고 보장 할 수 없습니다. 저자는이 정보 또는 그 사용과 관련하여 어떠한 책임도지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1ba19f7444dcdb1f5fd5e30a3ff4c300dd9b51b" translate="yes" xml:space="preserve">
          <source>This information should not be considered complete; it includes possibly transient information about idiosyncrasies of some of the ports, almost all of which are in a state of constant evolution. Thus, this material should be considered a perpetual work in progress (&lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</source>
          <target state="translated">이 정보는 완전한 것으로 간주되어서는 안됩니다. 여기에는 일부 포트의 특유성에 대한 일시적인 정보가 포함되며, 거의 모든 포트가 지속적으로 진화하는 상태입니다. 따라서이 자료는 지속적으로 진행되는 작업으로 간주되어야합니다 ( &lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="38a169aa69428d16b9cbc521c5975e7287809e94" translate="yes" xml:space="preserve">
          <source>This information should not be considered complete; it includes possibly transient information about idiosyncrasies of some of the ports, almost all of which are in a state of constant evolution. Thus, this material should be considered a perpetual work in progress (&lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이 정보는 완전한 것으로 간주되어서는 안됩니다. 여기에는 거의 모든 포트가 지속적인 진화 상태에있는 일부 포트의 특이성에 대한 일시적인 정보가 포함됩니다. 따라서이 자료는 진행중인 영구 작업으로 간주되어야합니다 ( &lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1f308a14f85f6b55bddba54f6f0dccb1fe994f0d" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the default MANIFEST.SKIP file</source>
          <target state="translated">기본 MANIFEST.SKIP 파일의 내용이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a183a2a7c1e850deb76aa146e5c8c7d75a1d8b67" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the specified external file</source>
          <target state="translated">지정된 외부 파일의 내용을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="710127152df45ef23f215433723e52cbd88020a4" translate="yes" xml:space="preserve">
          <source>This install method only has the power to install the distribution if there are no dependencies in the way. To install an object along with all its dependencies, use CPAN::Shell-&amp;gt;install.</source>
          <target state="translated">이 설치 방법에는 종속성이없는 경우 분배를 설치할 수있는 기능 만 있습니다. 모든 종속 항목과 함께 오브젝트를 설치하려면 CPAN :: Shell-&amp;gt; install을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="081204399b94282349e76c93ee84e633b6e3ee15" translate="yes" xml:space="preserve">
          <source>This instance of this layer supports the &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot; interface. Normally set based on &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; for the class and by the existence of the function(s) in the table. However a class that normally provides that interface may need to avoid it on a particular instance. The &quot;pending&quot; layer needs to do this when it is pushed above a layer which does not support the interface. (Perl's &lt;code&gt;sv_gets()&lt;/code&gt; does not expect the streams fast &lt;code&gt;gets&lt;/code&gt; behaviour to change during one &quot;get&quot;.)</source>
          <target state="translated">이 계층의 인스턴스는 &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot;인터페이스를 지원합니다 . 일반적으로 클래스의 &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; 및 테이블에 함수의 존재에 따라 설정됩니다. 그러나 일반적으로 해당 인터페이스를 제공하는 클래스는 특정 인스턴스에서 해당 인터페이스를 피해야 할 수도 있습니다. &quot;보류 중&quot;레이어는 인터페이스를 지원하지 않는 레이어 위로 눌렀을 때이 작업을 수행해야합니다. (펄의 &lt;code&gt;sv_gets()&lt;/code&gt; 빨리 스트림을 기대하지 않습니다 &lt;code&gt;gets&lt;/code&gt; &quot;GET&quot;한 동안 변화에 대한 행동을.)</target>
        </trans-unit>
        <trans-unit id="2d3ee171a0ea9e5033b09ded45e89dff7d3a16e0" translate="yes" xml:space="preserve">
          <source>This instance of this layer supports the &quot;fast &lt;code&gt;gets&lt;/code&gt;&quot; interface. Normally set based on &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; for the class and by the existence of the function(s) in the table. However a class that normally provides that interface may need to avoid it on a particular instance. The &quot;pending&quot; layer needs to do this when it is pushed above a layer which does not support the interface. (Perl's &lt;code&gt;sv_gets()&lt;/code&gt; does not expect the streams fast &lt;code&gt;gets&lt;/code&gt; behaviour to change during one &quot;get&quot;.)</source>
          <target state="translated">이 계층의이 인스턴스는 &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot;인터페이스를 지원합니다 . 일반적으로 클래스의 &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; 및 테이블의 함수 존재에 따라 설정됩니다. 그러나 일반적으로 해당 인터페이스를 제공하는 클래스는 특정 인스턴스에서이를 피해야 할 수 있습니다. &quot;보류 중&quot;계층은 인터페이스를 지원하지 않는 계층 위로 푸시 될 때이를 수행해야합니다. (Perl의 &lt;code&gt;sv_gets()&lt;/code&gt; 는 한 번의 &quot;get&quot;동안 스트림 빠른 &lt;code&gt;gets&lt;/code&gt; 오기 동작이 변경 될 것으로 예상하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="7a3d641c3fb98c37692677f17bfddfa4c0c2f88d" translate="yes" xml:space="preserve">
          <source>This integer normally starts off at a value of &lt;code&gt;1&lt;/code&gt; when a package stash is instantiated. Calling it on packages whose stashes do not exist at all will return &lt;code&gt;0&lt;/code&gt; . If a package stash is completely deleted (not a normal occurrence, but it can happen if someone does something like &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; ), the number will be reset to either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; , depending on how completely the package was wiped out.</source>
          <target state="translated">이 정수는 일반적으로 패키지 숨김이 인스턴스화 될 때 값 &lt;code&gt;1&lt;/code&gt; 에서 시작합니다 . 숨김이 전혀없는 패키지에서 호출하면 &lt;code&gt;0&lt;/code&gt; 이 반환 됩니다. 패키지 숨김이 완전히 삭제 된 경우 (정상 발생하지 않지만 누군가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; 와 같은 작업을 수행하는 경우 발생할 수 있음 ) 패키지가 완전히 지워진 정도에 따라 숫자가 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="26a092c71773214e0148af04c00b7d1197971d15" translate="yes" xml:space="preserve">
          <source>This integer normally starts off at a value of &lt;code&gt;1&lt;/code&gt; when a package stash is instantiated. Calling it on packages whose stashes do not exist at all will return &lt;code&gt;0&lt;/code&gt;. If a package stash is completely deleted (not a normal occurrence, but it can happen if someone does something like &lt;code&gt;undef %PkgName::&lt;/code&gt;), the number will be reset to either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, depending on how completely the package was wiped out.</source>
          <target state="translated">이 정수는 일반적으로 패키지 숨김이 인스턴스화 될 때 값 &lt;code&gt;1&lt;/code&gt; 에서 시작합니다 . 스 태시가 전혀없는 패키지에서 호출하면 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다. 패키지 숨김이 완전히 삭제 된 경우 (정상적인 것은 아니지만 누군가가 &lt;code&gt;undef %PkgName::&lt;/code&gt; 과 같은 작업을 수행하면 발생할 수 있음 ) 패키지가 얼마나 완전히 삭제되었는지에 따라 번호가 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc3d65756a4115c5abb43c54741c957341c1c84" translate="yes" xml:space="preserve">
          <source>This interface allows sequential retrieval from the database. See &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; for full details.</source>
          <target state="translated">이 인터페이스를 사용하면 데이터베이스에서 순차적으로 검색 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;dbopen&quot;&gt;dbopen&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="737a7a5efcfd42959d110feeee676008fd682bf1" translate="yes" xml:space="preserve">
          <source>This interface allows sequential retrieval from the database. See &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for full details.</source>
          <target state="translated">이 인터페이스는 데이터베이스에서 순차적 검색을 허용합니다. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cd749bb331e8a5d590f7e5603f780fdc41010317" translate="yes" xml:space="preserve">
          <source>This interface is based on the work and comments of (in no particular order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and others.</source>
          <target state="translated">이 인터페이스는 Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, 나 자신과 다른 사람들의 작업과 의견을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="491fa4fd719b046d8f39f03410b7b5fb6254dca4" translate="yes" xml:space="preserve">
          <source>This interface is handled slightly differently in &lt;b&gt;DB_File&lt;/b&gt;. Here is an equivalent call using &lt;b&gt;DB_File&lt;/b&gt;:</source>
          <target state="translated">이 인터페이스는 &lt;b&gt;DB_File&lt;/b&gt; 에서 약간 다르게 처리 됩니다. 다음은 다음을 사용하는 동등한 통화입니다.&lt;b&gt; DB_File을&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2be334b179b8dd94d5ef9fce8dd2b0dd67fa87fa" translate="yes" xml:space="preserve">
          <source>This interface lets you treat the DCL symbol table as a Perl associative array, in which the key of each element is the symbol name, and the value of the element is that symbol's value. Case is not significant in the key string, as DCL converts symbol names to uppercase, but it is significant in the value string. All of the usual operations on associative arrays are supported. Reading an element retrieves the current value of the symbol, assigning to it defines a new symbol (or overwrites the old value of an existing symbol), and deleting an element deletes the corresponding symbol. Setting an element to &lt;code&gt;undef&lt;/code&gt;, or &lt;code&gt;undef&lt;/code&gt;ing it directly, sets the corresponding symbol to the null string. You may also read the special keys ':GLOBAL' and ':LOCAL' to find out whether a default symbol table has been specified for this hash (see the next paragraph), or set either or these keys to specify a default symbol table.</source>
          <target state="translated">이 인터페이스를 사용하면 DCL 기호 테이블을 Perl 연관 배열로 처리 할 수 ​​있습니다. 여기서 각 요소의 키는 기호 이름이고 요소의 값은 해당 기호의 값입니다. DCL은 기호 이름을 대문자로 변환하므로 대소 문자는 키 문자열에서 중요하지 않지만 값 문자열에서는 중요합니다. 연관 배열에 대한 모든 일반적인 작업이 지원됩니다. 요소를 읽으면 기호의 현재 값을 검색하고 여기에 할당하면 새 기호를 정의하거나 기존 기호의 이전 값을 덮어 쓰며 요소를 삭제하면 해당 기호가 삭제됩니다. 요소를 &lt;code&gt;undef&lt;/code&gt; 또는 &lt;code&gt;undef&lt;/code&gt; 로 설정직접 연결하면 해당 기호를 null 문자열로 설정합니다. 또한 특수 키 ': GLOBAL'및 ': LOCAL'을 읽어이 해시에 대해 기본 기호 테이블이 지정되었는지 확인하거나 (다음 단락 참조) 또는 이러한 키 중 하나를 설정하여 기본 기호 테이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d69eea5115951977bf6e8780a64dd29c4226c4" translate="yes" xml:space="preserve">
          <source>This interpolation combines with the facts that the opening and closing parentheses are optional (except when necessary for precedence) and lists may end with an optional comma to mean that multiple commas within lists are legal syntax. The list &lt;code&gt;1,,3&lt;/code&gt; is a concatenation of two lists, &lt;code&gt;1,&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; , the first of which ends with that optional comma. &lt;code&gt;1,,3&lt;/code&gt; is &lt;code&gt;(1,),(3)&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; (And similarly for &lt;code&gt;1,,,3&lt;/code&gt; is &lt;code&gt;(1,),(,),3&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; and so on.) Not that we'd advise you to use this obfuscation.</source>
          <target state="translated">이 보간은 여는 괄호와 닫는 괄호가 선택 사항이며 (우선 순위에 필요한 경우 제외) 목록 내의 여러 쉼표가 합법적 인 구문임을 의미하는 쉼표로 끝날 수 있습니다. 리스트 &lt;code&gt;1,,3&lt;/code&gt; 개의리스트의 연결 인 &lt;code&gt;1,&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; , 즉 선택적 쉼표되는 단부의 제. &lt;code&gt;1,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(3)&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 입니다 ( &lt;code&gt;1,,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(,),3&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 등입니다). d이 난독 처리를 사용하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="30e99ba80e0a8b5fc3da6de61b068c8145e301f2" translate="yes" xml:space="preserve">
          <source>This interpolation combines with the facts that the opening and closing parentheses are optional (except when necessary for precedence) and lists may end with an optional comma to mean that multiple commas within lists are legal syntax. The list &lt;code&gt;1,,3&lt;/code&gt; is a concatenation of two lists, &lt;code&gt;1,&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;, the first of which ends with that optional comma. &lt;code&gt;1,,3&lt;/code&gt; is &lt;code&gt;(1,),(3)&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; (And similarly for &lt;code&gt;1,,,3&lt;/code&gt; is &lt;code&gt;(1,),(,),3&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; and so on.) Not that we'd advise you to use this obfuscation.</source>
          <target state="translated">이 보간은 여는 괄호와 닫는 괄호가 선택 사항이며 (우선 순위에 필요한 경우 제외) 목록이 선택적 쉼표로 끝날 수 있다는 사실과 결합되어 목록 내의 여러 쉼표가 합법적 인 구문임을 의미합니다. 목록 &lt;code&gt;1,,3&lt;/code&gt; 은 두 목록 &lt;code&gt;1,&lt;/code&gt; 과 &lt;code&gt;3&lt;/code&gt; 을 연결 한 것으로 첫 번째 목록 은 선택적 쉼표로 끝납니다. &lt;code&gt;1,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(3)&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 입니다 ( &lt;code&gt;1,,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(,),3&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 등). d이 난독 화를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff7fca560bcccd2ead2613d40d2441ab2644441f" translate="yes" xml:space="preserve">
          <source>This introduces another problem: what if you just know that your data is UTF-16, but you don't know which endianness? Byte Order Marks, or &lt;code&gt;BOM&lt;/code&gt; 's, are a solution to this. A special character has been reserved in Unicode to function as a byte order marker: the character with the code point &lt;code&gt;U+FEFF&lt;/code&gt; is the &lt;code&gt;BOM&lt;/code&gt; .</source>
          <target state="translated">이것은 또 다른 문제를 일으킨다 : 만약 당신의 데이터가 UTF-16이라는 것을 알고 있지만 어떤 엔디안을 모른다면? 바이트 주문 마크 또는 &lt;code&gt;BOM&lt;/code&gt; 이 이에 대한 솔루션입니다. 바이트 순서 표시 자로 기능하기 위해 특수 문자가 유니 코드로 예약되어 있습니다. 코드 포인트 &lt;code&gt;U+FEFF&lt;/code&gt; 가있는 문자 는 &lt;code&gt;BOM&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7e0886084063bb71aaf0bbd76b1515a17e11d962" translate="yes" xml:space="preserve">
          <source>This introduces another problem: what if you just know that your data is UTF-16, but you don't know which endianness? Byte Order Marks, or &lt;code&gt;BOM&lt;/code&gt;'s, are a solution to this. A special character has been reserved in Unicode to function as a byte order marker: the character with the code point &lt;code&gt;U+FEFF&lt;/code&gt; is the &lt;code&gt;BOM&lt;/code&gt;.</source>
          <target state="translated">이로 인해 또 다른 문제가 발생합니다. 데이터가 UTF-16이라는 것만 알고 있지만 어떤 엔디안인지 모르는 경우에는 어떻게해야합니까? 바이트 순서 표시 ( &lt;code&gt;BOM&lt;/code&gt; )가 이에 대한 해결책입니다. 특수 문자는 유니 코드로 예약되어 바이트 순서 마커로 작동합니다. 코드 포인트 &lt;code&gt;U+FEFF&lt;/code&gt; 가있는 문자 는 &lt;code&gt;BOM&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d98b577e394b09ee4f02d9918217111200cab8f" translate="yes" xml:space="preserve">
          <source>This introductory document does not aim to be complete. It does not even aim to be entirely accurate. In some cases perfection has been sacrificed in the goal of getting the general idea across. You are</source>
          <target state="translated">이 입문서는 완전한 것이 아닙니다. 심지어 완전히 정확하지는 않습니다. 어떤 경우에는 일반적인 아이디어를 얻는 목표에서 완벽 함이 희생되었습니다. 너는</target>
        </trans-unit>
        <trans-unit id="2b646e06b5c6dfedf386d47b899ec3f8734e765d" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;not&lt;/b&gt; the reverse of PerlIO_exportFILE().</source>
          <target state="translated">이것은 PerlIO_exportFILE ()의 반대 가 &lt;b&gt;아닙니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d69879cdfbe586062188f3d7ff676e78424d35" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;very&lt;/b&gt; similar to previous, only the first two ops differ. This subroutine rendering is more representative, insofar as a single main program will have many subs.</source>
          <target state="translated">이것은 이전과 &lt;b&gt;매우&lt;/b&gt; 유사하며 처음 두 작업 만 다릅니다. 이 서브 루틴 렌더링은 하나의 메인 프로그램에 많은 서브가있는 한 더 대표적입니다.</target>
        </trans-unit>
        <trans-unit id="13a9fc12865137f8c322a100d88693c3b3008c0d" translate="yes" xml:space="preserve">
          <source>This is Perl, so it does the exact right thing. It sees that you want to push &lt;code&gt;Athens&lt;/code&gt; onto an array that doesn't exist, so it helpfully makes a new, empty, anonymous array for you, installs it into &lt;code&gt;%table&lt;/code&gt; , and then pushes &lt;code&gt;Athens&lt;/code&gt; onto it. This is called 'autovivification'--bringing things to life automatically. Perl saw that the key wasn't in the hash, so it created a new hash entry automatically. Perl saw that you wanted to use the hash value as an array, so it created a new empty array and installed a reference to it in the hash automatically. And as usual, Perl made the array one element longer to hold the new city name.</source>
          <target state="translated">이것은 Perl이므로 정확한 일을합니다. 존재하지 않는 배열로 &lt;code&gt;Athens&lt;/code&gt; 를 푸시하려고한다는 것을 알았으므로 유용하고 비어있는 익명의 배열을 유용하게 만들고 &lt;code&gt;%table&lt;/code&gt; 설치 한 다음 &lt;code&gt;Athens&lt;/code&gt; 를 밀어 넣습니다. 이것을 '자동화'라고하며, 사물을 자동으로 구현합니다. Perl은 키가 해시에없는 것을 확인하여 새 해시 항목을 자동으로 만들었습니다. Perl은 해시 값을 배열로 사용하려고하므로 빈 배열을 새로 만들어 해시에 참조를 자동으로 설치했습니다. 그리고 평소처럼 Perl은 새로운 도시 이름을 유지하기 위해 배열을 한 요소 더 길게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="6952ffbc36ae125eed2db7e1e92d83483c6c0a22" translate="yes" xml:space="preserve">
          <source>This is Perl, so it does the exact right thing. It sees that you want to push &lt;code&gt;Athens&lt;/code&gt; onto an array that doesn't exist, so it helpfully makes a new, empty, anonymous array for you, installs it into &lt;code&gt;%table&lt;/code&gt;, and then pushes &lt;code&gt;Athens&lt;/code&gt; onto it. This is called</source>
          <target state="translated">이것은 Perl이므로 정확히 옳은 일을합니다. 존재하지 않는 배열에 &lt;code&gt;Athens&lt;/code&gt; 를 밀어 넣고 자 한다는 것을 알기 때문에 새롭고 비어있는 익명 배열을 만들어 &lt;code&gt;%table&lt;/code&gt; 설치 한 다음 &lt;code&gt;Athens&lt;/code&gt; 를 밀어 넣습니다. 이것은 ... 불리운다</target>
        </trans-unit>
        <trans-unit id="d199012301aebd153320803c30f339cb29b9c3f4" translate="yes" xml:space="preserve">
          <source>This is TRUE if the image store data in network order. This means that it was created with nstore() or similar.</source>
          <target state="translated">이미지가 네트워크 순서로 데이터를 저장하는 경우 TRUE입니다. 이것은 nstore () 또는 이와 유사한 것으로 작성되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e89180d701e5f3ba4c51e57a43f46491189b4827" translate="yes" xml:space="preserve">
          <source>This is a</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="701541b651d14d9ce17a8309970ae17dc9d55c05" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to display Pod source as itself! Pretty Zen, huh?</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 포드 소스 자체를 표시 할 수있게합니다! 예쁜 선, 응?</target>
        </trans-unit>
        <trans-unit id="a75770ef9b0c598ca7fde366202ade0c04715297" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man and &lt;code&gt;groff&lt;/code&gt; for reading Pod pages.</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 Pod :: Man 및 &lt;code&gt;groff&lt;/code&gt; 를 사용하여 Pod 페이지를 읽을 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="81393ce7a71c653a02bafc9503ad7f009bece819" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Man을 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="62907aa2e6a91bf9a0b7a6c6e963db493d7938e3" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::Checker as a &quot;formatter&quot; class (or if that is not available, then Pod::Checker), to check for errors in a given Pod file.</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 Pod :: Simple :: Checker를 &quot;포매터&quot;클래스 (또는 사용할 수없는 경우에는 Pod :: Checker)로 사용하여 지정된 포드의 오류를 확인할 수 있습니다. 파일.</target>
        </trans-unit>
        <trans-unit id="55e3a501ab6032afe89831dc532a3a24c547307d" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::RTF as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Simple :: RTF를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="68678eb1c55adc089ba0d404634d06ee4b438a50" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::XMLOutStream as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Simple :: XMLOutStream을 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e1aa800043dc8a94d0d283dacfd5ba2b12a78539" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Text as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Text를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="dddce66063ab47a1230107d6a866110ade33c3fe" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Tk::Pod as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Tk :: Pod를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4275fe3ef141a55b62b40502070bf737ec2ea8ca" translate="yes" xml:space="preserve">
          <source>This is a &quot;postponed&quot; regular subexpression. It behaves in</source>
          <target state="translated">&quot;지연된&quot;정규 하위 표현식입니다. 그것은 행동</target>
        </trans-unit>
        <trans-unit id="a9ec1e3198488308c3643ad69f8d075d9b8f92de" translate="yes" xml:space="preserve">
          <source>This is a 'catch-all' method which returns true if any tests have currently failed, any TODO tests unexpectedly succeeded, or any parse errors occurred.</source>
          <target state="translated">테스트가 현재 실패했거나 TODO 테스트가 예기치 않게 성공했거나 구문 분석 오류가 발생한 경우 true를 리턴하는 'catch-all'메소드입니다.</target>
        </trans-unit>
        <trans-unit id="73b5aab0cb506ed2e80764625faba5043cd5b8ed" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;autodie::exception&quot;&gt;autodie::exception&lt;/a&gt; class for failures from the &lt;code&gt;system&lt;/code&gt; command.</source>
          <target state="translated">이것은 &lt;code&gt;system&lt;/code&gt; 명령의 실패에 대한 &lt;a href=&quot;autodie::exception&quot;&gt;autodie :: exception&lt;/a&gt; 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f9b6bdcb215a6cedd90d3fc776185364f2309aa9" translate="yes" xml:space="preserve">
          <source>This is a CPAN module that has better error handling and more facilities than Open3.</source>
          <target state="translated">이 모듈은 Open3보다 더 나은 오류 처리 및 더 많은 기능을 가진 CPAN 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="5fa45cb9d444efdc2948972c4c5c733896db4c76" translate="yes" xml:space="preserve">
          <source>This is a Map that describes all the prerequisites of the distribution. The keys are phases of activity, such as &lt;code&gt;configure&lt;/code&gt;, &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;runtime&lt;/code&gt;. Values are Maps in which the keys name the type of prerequisite relationship such as &lt;code&gt;requires&lt;/code&gt;, &lt;code&gt;recommends&lt;/code&gt;, or &lt;code&gt;suggests&lt;/code&gt; and the value provides a set of prerequisite relations. The set of relations &lt;b&gt;must&lt;/b&gt; be specified as a Map of package names to version ranges.</source>
          <target state="translated">배포의 모든 전제 조건을 설명하는 맵입니다. 키는 &lt;code&gt;configure&lt;/code&gt; , &lt;code&gt;build&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 또는 &lt;code&gt;runtime&lt;/code&gt; 과 같은 활동 단계입니다 . 값은 키가 &lt;code&gt;requires&lt;/code&gt; , &lt;code&gt;recommends&lt;/code&gt; 또는 &lt;code&gt;suggests&lt;/code&gt; 과 같은 전제 조건 관계 유형을 명명 하고 값이 전제 조건 관계 세트를 제공하는 맵입니다 . 관계 세트는 버전 범위에 대한 패키지 이름의 맵으로 지정 &lt;b&gt;되어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d2a521ae98c293152277e05794dfa3dbb364fa" translate="yes" xml:space="preserve">
          <source>This is a Perl binding for the cross-platform wxWidgets toolkit ( &lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt; ). It works under Unix, Win32 and Mac OS X, using native widgets (Gtk under Unix). The interface follows the C++ interface closely, but the documentation is a little sparse for someone who doesn't know the library, mostly just referring you to the C++ documentation.</source>
          <target state="translated">이것은 크로스 플랫폼 wxWidgets 툴킷 ( &lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt; )에 대한 Perl 바인딩입니다 . 네이티브 위젯 (Unix에서 Gtk)을 사용하여 Unix, Win32 및 Mac OS X에서 작동합니다. 인터페이스는 C ++ 인터페이스를 밀접하게 따르지만, 라이브러리를 모르는 사람에게는 약간 부족합니다. 대부분 C ++ 문서를 참조하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="6e701c73247f5ad9d23c7f590ac02f35efc27631" translate="yes" xml:space="preserve">
          <source>This is a Perl-friendly wrapper around &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;CreateFile&lt;/code&gt; 에 대한 Perl 친화적 인 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="5cbed9dcb1af92fb7554f193074365e1398ba923" translate="yes" xml:space="preserve">
          <source>This is a Perl-friendly wrapper for the &lt;code&gt;GetFileSize&lt;/code&gt; (below) API call.</source>
          <target state="translated">이것은 &lt;code&gt;GetFileSize&lt;/code&gt; (아래) API 호출을 위한 Perl 친화적 인 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="49ff8d67a4c545a99f2af8806bef343c9f8c2fa8" translate="yes" xml:space="preserve">
          <source>This is a String describing the feature. Every optional feature should provide a description</source>
          <target state="translated">기능을 설명하는 문자열입니다. 모든 선택적 기능은 설명을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="64369b0966513691c61b8897fc5c7b37a7f32789" translate="yes" xml:space="preserve">
          <source>This is a big step forward, and can give a threaded program quite a performance boost over non-threaded programs. Threads that block performing I/O, for example, won't block threads that are doing other things. Each process still has only one thread running at once, though, regardless of how many CPUs a system might have.</source>
          <target state="translated">이것은 큰 발전이며, 스레드 프로그램이 스레드가 아닌 프로그램보다 성능을 크게 향상시킬 수 있습니다. 예를 들어 I / O 수행을 차단하는 스레드는 다른 작업을 수행하는 스레드를 차단하지 않습니다. 그러나 각 프로세스에는 시스템의 CPU 수에 관계없이 한 번에 하나의 스레드 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c71251d2a2ccec8dd46781a0eb70dbaafe4b05" translate="yes" xml:space="preserve">
          <source>This is a bit tricky. You can't simply write the command like this:</source>
          <target state="translated">조금 까다 롭습니다. 다음과 같이 간단히 명령을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9988691445fe26ab65af265f99fd095c701fd79e" translate="yes" xml:space="preserve">
          <source>This is a bundled copy of &lt;a href=&quot;Object::HashBase&quot;&gt;Object::HashBase&lt;/a&gt;. This file was generated using the &lt;code&gt;/home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl&lt;/code&gt; script.</source>
          <target state="translated">이것은 &lt;a href=&quot;Object::HashBase&quot;&gt;Object :: HashBase&lt;/a&gt; 의 번들 사본입니다 . 이 파일은 &lt;code&gt;/home/exodist/perl5/perlbrew/perls/main/bin/hashbase_inc.pl&lt;/code&gt; 스크립트를 사용하여 생성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9d5816967d821cb6be38c83ea72dd77eb458d174" translate="yes" xml:space="preserve">
          <source>This is a case of convergent evolution with Joshua Pritikin's &lt;a href=&quot;../test&quot;&gt;Test&lt;/a&gt; module. I was largely unaware of its existence when I'd first written my own &lt;code&gt;ok()&lt;/code&gt; routines. This module exists because I can't figure out how to easily wedge test names into Test's interface (along with a few other problems).</source>
          <target state="translated">이것은 Joshua Pritikin의 &lt;a href=&quot;../test&quot;&gt;Test&lt;/a&gt; 모듈 과 함께 수렴 진화 한 경우입니다 . 나는 내 자신의 &lt;code&gt;ok()&lt;/code&gt; 루틴을 처음 작성할 때 그 존재를 거의 알지 못했습니다 . 이 모듈은 테스트 이름을 Test 인터페이스에 쉽게 쐐기 화하는 방법을 알 수 없기 때문에 존재합니다 (몇 가지 다른 문제와 함께).</target>
        </trans-unit>
        <trans-unit id="54c770ad3f7a82f2269261b07541b2b2f66f381b" translate="yes" xml:space="preserve">
          <source>This is a case of convergent evolution with Joshua Pritikin's &lt;a href=&quot;test&quot;&gt;Test&lt;/a&gt; module. I was largely unaware of its existence when I'd first written my own &lt;code&gt;ok()&lt;/code&gt; routines. This module exists because I can't figure out how to easily wedge test names into Test's interface (along with a few other problems).</source>
          <target state="translated">이것은 Joshua Pritikin의 &lt;a href=&quot;test&quot;&gt;테스트&lt;/a&gt; 모듈을 사용한 수렴 진화의 경우입니다 . 나는 처음에 &lt;code&gt;ok()&lt;/code&gt; 루틴을 작성했을 때 그 존재를 거의 알지 못했습니다 . 이 모듈은 테스트 이름을 Test의 인터페이스에 쉽게 wedge하는 방법을 알아낼 수 없기 때문에 존재합니다 (몇 가지 다른 문제와 함께).</target>
        </trans-unit>
        <trans-unit id="97fc5a87a825ec27b25306a412b0a1048b673845" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object and returns a reference to the new interior sequence object. It should be given two keyword arguments. The &lt;code&gt;-ldelim&lt;/code&gt; keyword indicates the corresponding left-delimiter of the interior sequence (e.g. '&amp;lt;'). The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding interior sequence command, such as &lt;code&gt;I&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; . The &lt;code&gt;-file&lt;/code&gt; and &lt;code&gt;-line&lt;/code&gt; keywords indicate the filename and line number corresponding to the beginning of the interior sequence. If the &lt;code&gt;$ptree&lt;/code&gt; argument is given, it must be the last argument, and it must be either string, or else an array-ref suitable for passing to &lt;b&gt;Pod::ParseTree::new&lt;/b&gt; (or it may be a reference to a Pod::ParseTree object).</source>
          <target state="translated">이것은 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 객체를 구성하고 새 내부 시퀀스 객체에 대한 참조를 반환 하는 클래스 메서드입니다 . 두 개의 키워드 인수가 제공되어야합니다. &lt;code&gt;-ldelim&lt;/code&gt; 키워드 내부 시퀀스의 대응하는 좌측 분리 (예 : '&amp;lt;')를 나타낸다. &lt;code&gt;-name&lt;/code&gt; 키워드 등 해당 내부 시퀀스 명령의 이름을 나타내는 &lt;code&gt;I&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; 또는 &lt;code&gt;C&lt;/code&gt; 를 . &lt;code&gt;-file&lt;/code&gt; 와 &lt;code&gt;-line&lt;/code&gt; 키워드는 내부 시퀀스의 시작에 해당하는 파일 이름과 라인 수를 나타냅니다. 만약 &lt;code&gt;$ptree&lt;/code&gt; 인수가 주어지면 마지막 인수 여야하며 문자열이거나 &lt;b&gt;Pod :: ParseTree :: new&lt;/b&gt; 에 전달하기에 적합한 배열 참조 &lt;b&gt;여야합니다&lt;/b&gt; (또는 Pod :: ParseTree 객체에 대한 참조 일 수 있음). .</target>
        </trans-unit>
        <trans-unit id="29f55cb5b171aa91fa3174d7342b227ed1f417e9" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object and returns a reference to the new paragraph object. It may be given one or two keyword arguments. The &lt;code&gt;-text&lt;/code&gt; keyword indicates the corresponding text of the POD paragraph. The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding POD command, such as &lt;code&gt;head1&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; (it should</source>
          <target state="translated">&lt;code&gt;Pod::Paragraph&lt;/code&gt; 객체를 생성하고 새 단락 객체에 대한 참조를 반환 하는 클래스 메서드입니다 . 하나 또는 두 개의 키워드 인수가 제공 될 수 있습니다. &lt;code&gt;-text&lt;/code&gt; 키워드는 POD 단락의 해당 텍스트를 나타냅니다. &lt;code&gt;-name&lt;/code&gt; 키워드는 다음과 같은 해당 POD 명령의 이름을 나타냅니다 &lt;code&gt;head1&lt;/code&gt; 또는 &lt;code&gt;item&lt;/code&gt; 이해야한다 (</target>
        </trans-unit>
        <trans-unit id="331988b0033be159e38f1f3db9e7086fd5ac78d2" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Parse_tree&lt;/code&gt; object and returns a reference to the new parse-tree. If a single-argument is given, it must be a reference to an array, and is used to initialize the root (top) of the parse tree.</source>
          <target state="translated">이것은 &lt;code&gt;Pod::Parse_tree&lt;/code&gt; 객체를 생성하고 새로운 구문 분석 트리에 대한 참조를 반환 하는 클래스 메소드 입니다. 단일 인수가 제공되면 배열에 대한 참조 여야하며 구문 분석 트리의 루트 (상단)를 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="135e61a3e6ed1b5dcdd255926dda22779c807d83" translate="yes" xml:space="preserve">
          <source>This is a classic race condition: you take two steps to do something which must be done in one. That's why computer hardware provides an atomic test-and-set instruction. In theory, this &quot;ought&quot; to work:</source>
          <target state="translated">이것은 고전적인 경쟁 조건입니다. 한 번에 수행해야하는 작업을 수행하려면 두 단계를 수행하십시오. 이것이 바로 컴퓨터 하드웨어가 원자 테스트 및 설정 명령을 제공하는 이유입니다. 이론적으로 이것은 &quot;작동해야한다&quot;:</target>
        </trans-unit>
        <trans-unit id="06ed0aa0bcc2d08b1ae41c2e1fbf2ac9199a80b7" translate="yes" xml:space="preserve">
          <source>This is a cleanup variable for try test programs. Internal Configure use only.</source>
          <target state="translated">시험 테스트 프로그램을위한 정리 변수입니다. 내부 구성 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15d31d32837b2199fecd9abd8b0259d5c2027995" translate="yes" xml:space="preserve">
          <source>This is a collection of words of wisdom for a Perl porter; some of it is only useful to the pumpkin holder, but most of it applies to anyone wanting to go about Perl development.</source>
          <target state="translated">이것은 Perl 포터를위한 지혜의 단어 모음입니다. 일부는 호박 홀더에만 유용하지만 대부분 Perl 개발에 관심이있는 사람에게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="50e9aa2a5393c1306b4554160b04a4a7e4b9e963" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;fail()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt;. This can be used to write clearer and shorter code.</source>
          <target state="translated">이것은 &lt;code&gt;fail()&lt;/code&gt; 과 &lt;code&gt;release()&lt;/code&gt; 의 조합입니다 . 이것은 더 명확하고 짧은 코드를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf4ec84482d25e756661a254bc11b6d3a2c40470" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;pass()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt;. You can use this if you do not plan to do anything with the context after sending the event. This helps write more clear and compact code.</source>
          <target state="translated">이것은 &lt;code&gt;pass()&lt;/code&gt; 및 &lt;code&gt;release()&lt;/code&gt; 의 조합입니다 . 이벤트를 보낸 후 컨텍스트로 아무것도 할 계획이 없다면 이것을 사용할 수 있습니다. 이것은보다 명확하고 간결한 코드를 작성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="778151eacaa3efa499054aa859852387460cc393" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;send_ev2()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;send_ev2()&lt;/code&gt; 및 &lt;code&gt;release()&lt;/code&gt; 의 조합입니다 .</target>
        </trans-unit>
        <trans-unit id="c70a20942ca880b385d3fc824ba90f3bd360b8ca" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;send_event()&lt;/code&gt; and &lt;code&gt;release()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;send_event()&lt;/code&gt; 및 &lt;code&gt;release()&lt;/code&gt; 의 조합입니다 .</target>
        </trans-unit>
        <trans-unit id="12519510bc7bbd2ae4104e8caa159039e5db37c2" translate="yes" xml:space="preserve">
          <source>This is a combination of the previous two forms. It is valid only when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; (normal identifier rules apply when under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;). The form is a sigil, followed by text in braces, where the first character is any one of the characters in the range &lt;code&gt;[\x80-\xFF]&lt;/code&gt; followed by ASCII word characters up to the trailing brace.</source>
          <target state="translated">이것은 이전 두 가지 형식의 조합입니다. &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아래에 있지 않은 경우에만 유효합니다 ( &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아래에있는 경우 일반 식별자 규칙이 적용됨 ). 형식은시길과 중괄호 안의 텍스트가 뒤 따르고, 첫 번째 문자는 &lt;code&gt;[\x80-\xFF]&lt;/code&gt; 범위의 문자 중 하나이고 뒤에 오는 중괄호까지 ASCII 단어 문자가 이어집니다.</target>
        </trans-unit>
        <trans-unit id="78a03e08bc2123708a34ec2db4804cf0d2100751" translate="yes" xml:space="preserve">
          <source>This is a common error when trying to build perl on Solaris 2.6 with a gcc installation from Solaris 2.5 or 2.5.1. The Solaris header files changed, so you need to update your gcc installation. You can either rerun the fixincludes script from gcc or take the opportunity to update your gcc installation.</source>
          <target state="translated">Solaris 2.5 또는 2.5.1의 gcc 설치로 Solaris 2.6에서 perl을 빌드하려고 할 때 발생하는 일반적인 오류입니다. Solaris 헤더 파일이 변경되었으므로 gcc 설치를 업데이트해야합니다. gcc에서 fixincludes 스크립트를 다시 실행하거나 gcc 설치를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d389ed280acec1d0e8a48d7b965ec940a7e391" translate="yes" xml:space="preserve">
          <source>This is a convenience wrapper around &lt;code&gt;package_versions_from_directory&lt;/code&gt; to generate a CPAN META &lt;code&gt;provides&lt;/code&gt; data structure. It takes key/value pairs. Valid option keys include:</source>
          <target state="translated">이것은 CPAN META &lt;code&gt;provides&lt;/code&gt; 데이터 구조를 제공 하는 것을 생성하기 위해 &lt;code&gt;package_versions_from_directory&lt;/code&gt; 에 대한 편리한 래퍼 입니다. 키 / 값 쌍을 사용합니다. 유효한 옵션 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5e4e2616b1e858820e63e7f00c945ce3c9f307d" translate="yes" xml:space="preserve">
          <source>This is a copy of &lt;a href=&quot;IO::Scalar&quot;&gt;IO::Scalar&lt;/a&gt; which ships with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to support scalar references as filehandles on Perl 5.6. Newer versions of Perl simply use &lt;code&gt;open()&lt;/code&gt;'s built in support.</source>
          <target state="translated">이것은 Perl 5.6에서 파일 핸들로 스칼라 참조를 지원하기 위해 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 와 함께 제공되는 &lt;a href=&quot;IO::Scalar&quot;&gt;IO :: Scalar&lt;/a&gt; 의 사본입니다 . 최신 버전의 Perl은 단순히 &lt;code&gt;open()&lt;/code&gt; 의 내장 지원을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff129a99820711b57abb25f1b58ba7136b7e8cde" translate="yes" xml:space="preserve">
          <source>This is a difficult question to answer, and the best answer is only a guess.</source>
          <target state="translated">이것은 대답하기 어려운 질문이며 최선의 대답은 추측 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="b8d839dd828060570d067675a559441bcbad521a" translate="yes" xml:space="preserve">
          <source>This is a drop in replacement for Test::Simple which you can switch to once you get the hang of basic testing.</source>
          <target state="translated">이것은 Test :: Simple을 대체하는 드롭 인으로, 일단 기본 테스트에 익숙해지면 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d01f884a06c4ddeafbc3fcceec68d66b7b226e93" translate="yes" xml:space="preserve">
          <source>This is a factory class that takes a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and runs it through all the registered &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to see which one should handle the source.</source>
          <target state="translated">이것은 &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; 를 가져 와서 등록 된 모든 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler를&lt;/a&gt; 통해 실행 하여 소스를 처리해야하는 팩토리 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="999f0dc4cf91e26f969aecc31f8b8b85ae8a6af3" translate="yes" xml:space="preserve">
          <source>This is a factory class that takes a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and runs it through all the registered &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to see which one should handle the source.</source>
          <target state="translated">이것은 &lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source를 가져&lt;/a&gt; 오고 등록 된 모든 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 통해 소스를 처리해야하는 팩토리 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="c43e76a8b7a7a6439251d5db4f28f61ba4f7ca79" translate="yes" xml:space="preserve">
          <source>This is a fancy bracketed character class that can be used for more readable and less error-prone classes, and to perform set operations, such as intersection. An example is</source>
          <target state="translated">이 클래스는보다 읽기 쉽고 오류가 적은 클래스에 사용하고 교차점과 같은 세트 작업을 수행하는 데 사용할 수있는 멋진 괄호 문자 클래스입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="bd5b0b089eff91377cede66c47419fc9845c1784" translate="yes" xml:space="preserve">
          <source>This is a fixed variant of T_HVREF that decrements the refcount appropriately when returning an HV*. Introduced in perl 5.15.4.</source>
          <target state="translated">이것은 HV *를 반환 할 때 refcount를 적절하게 감소시키는 T_HVREF의 고정 변형입니다. perl 5.15.4에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2afb142501471156b20b535936f7b6ddbbaafcb0" translate="yes" xml:space="preserve">
          <source>This is a fully ported Perl for OS/390 Version 2 Release 3, 5, 6, 7, 8, and 9. It may work on other versions or releases, but those are the ones we have tested it on.</source>
          <target state="translated">이것은 OS / 390 버전 2 릴리스 3, 5, 6, 7, 8 및 9 용으로 완전히 이식 된 Perl입니다. 다른 버전이나 릴리스에서도 작동 할 수 있지만 테스트 한 버전입니다.</target>
        </trans-unit>
        <trans-unit id="926e4c62112da36d18d2c1c89330bc60c9162eb2" translate="yes" xml:space="preserve">
          <source>This is a fully ported Perl for OS/390 Version 2 Release 3, 5, 6, 7, 8, and 9. It may work on other versions or releases, but those are the ones we've tested it on.</source>
          <target state="translated">OS / 390 버전 2 릴리스 3, 5, 6, 7, 8 및 9 용으로 완전히 포팅 된 Perl입니다. 다른 버전이나 릴리스에서 작동 할 수 있지만 테스트 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="372ffff7fde6d07d99e54e14755b9d58626070f2" translate="yes" xml:space="preserve">
          <source>This is a function which adds a string, &lt;code&gt;ptr&lt;/code&gt; , of length &lt;code&gt;len&lt;/code&gt; onto the end of the PV stored in &lt;code&gt;sv&lt;/code&gt; . The first thing we do in line 6 is make sure that the SV &lt;b&gt;has&lt;/b&gt; a valid PV, by calling the &lt;code&gt;SvPV_force&lt;/code&gt; macro to force a PV. As a side effect, &lt;code&gt;tlen&lt;/code&gt; gets set to the current value of the PV, and the PV itself is returned to &lt;code&gt;junk&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;sv&lt;/code&gt; 에 저장된 PV의 끝에 &lt;code&gt;len&lt;/code&gt; 길이 의 문자열 &lt;code&gt;ptr&lt;/code&gt; 을 추가하는 함수입니다 . 6 행에서 가장 먼저해야 할 일은 &lt;code&gt;SvPV_force&lt;/code&gt; 매크로를 호출하여 PV를 강제 실행 하여 SV 에 유효한 PV &lt;b&gt;가&lt;/b&gt; 있는지 확인하는 것 입니다. 부작용으로 &lt;code&gt;tlen&lt;/code&gt; 은 PV의 현재 값으로 설정되고 PV 자체는 &lt;code&gt;junk&lt;/code&gt; 로 반환됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="708079f015a020d71bf13eeb81d726c588386d85" translate="yes" xml:space="preserve">
          <source>This is a function which adds a string, &lt;code&gt;ptr&lt;/code&gt;, of length &lt;code&gt;len&lt;/code&gt; onto the end of the PV stored in &lt;code&gt;sv&lt;/code&gt;. The first thing we do in line 6 is make sure that the SV &lt;b&gt;has&lt;/b&gt; a valid PV, by calling the &lt;code&gt;SvPV_force&lt;/code&gt; macro to force a PV. As a side effect, &lt;code&gt;tlen&lt;/code&gt; gets set to the current value of the PV, and the PV itself is returned to &lt;code&gt;junk&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 에 저장된 PV 끝에 &lt;code&gt;len&lt;/code&gt; 길이 의 문자열 &lt;code&gt;ptr&lt;/code&gt; 을 추가하는 함수입니다 . 6 행에서 가장 먼저하는 일은 &lt;code&gt;SvPV_force&lt;/code&gt; 매크로를 호출하여 PV를 강제 실행 하여 SV 에 유효한 PV &lt;b&gt;가&lt;/b&gt; 있는지 확인하는 것 입니다. 부작용으로 &lt;code&gt;tlen&lt;/code&gt; 은 PV의 현재 값으로 설정되고 PV 자체는 &lt;code&gt;junk&lt;/code&gt; 로 돌아갑니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2774055b00e3419620eb5d95ca0978a88958d21c" translate="yes" xml:space="preserve">
          <source>This is a fundamental limitation of the way hashes are constructed in Perl. The error messages produced when this happens will often be quite cryptic -- in the worst case there may be none at all, and you'll only later find that something is broken.</source>
          <target state="translated">이것은 Perl에서 해시가 구성되는 방식의 근본적인 한계입니다. 이런 일이 발생했을 때 생성되는 오류 메시지는 종종 매우 비밀 스러울 것입니다. 최악의 경우 전혀 없을 수도 있으며 나중에 무언가가 깨 졌음을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c83f909cdae2425d7ef8f9b618e80ba6342629e" translate="yes" xml:space="preserve">
          <source>This is a generic event that lets you customize all fields in the event API. This is useful if you have need for a custom event that does not make sense as a published reusable event subclass.</source>
          <target state="translated">이벤트 API의 모든 필드를 사용자 정의 할 수있는 일반 이벤트입니다. 이는 게시 된 재사용 가능한 이벤트 하위 클래스로 이해되지 않는 사용자 지정 이벤트가 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5634f9ec91b3e104474c739e05fd80458193ebf9" translate="yes" xml:space="preserve">
          <source>This is a get-or-set method for the compartment's operator mask.</source>
          <target state="translated">구획의 작업자 마스크에 대한 get-or-set 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e894d85c5e9df5228e61b20283457ef4058bfbeb" translate="yes" xml:space="preserve">
          <source>This is a good introduction and will direct you towards other man pages that may interest you.</source>
          <target state="translated">이것은 좋은 소개이며 관심있는 다른 매뉴얼 페이지로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="8c7d928409a2a83d36eb046953e31000e8fced30" translate="yes" xml:space="preserve">
          <source>This is a hash reference which contains a template as explained in the &lt;code&gt;SYNOPSIS&lt;/code&gt; and &lt;code&gt;Template&lt;/code&gt; section.</source>
          <target state="translated">이것은 &lt;code&gt;SYNOPSIS&lt;/code&gt; 및 &lt;code&gt;Template&lt;/code&gt; 섹션에 설명 된 템플릿을 포함하는 해시 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="abdb64e67c36b80a4a66af77ecfc2b1aa4e68e20" translate="yes" xml:space="preserve">
          <source>This is a hash used internally to track named capture groups and their offsets. The keys are the names of the buffers the values are dualvars, with the IV slot holding the number of buffers with the given name and the pv being an embedded array of I32. The values may also be contained independently in the data array in cases where named backreferences are used.</source>
          <target state="translated">명명 된 캡처 그룹 및 해당 오프셋을 추적하기 위해 내부적으로 사용되는 해시입니다. 키는 값이 이중 변수 인 버퍼의 이름이며, IV 슬롯에는 지정된 이름의 버퍼 수가 있고 pv는 I32의 임베디드 배열입니다. 명명 된 역 참조가 사용되는 경우 데이터 배열에 값이 독립적으로 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6914fc9df9304338ddc0f7d1b0a521a431d05b1" translate="yes" xml:space="preserve">
          <source>This is a hash with all the known defines as keys. The value is either 0, which means unknown or unset, or 1, which means defined.</source>
          <target state="translated">이것은 키로 알려진 모든 정의가있는 해시입니다. 값은 알 수 없음 또는 설정되지 않음을 의미하는 0 또는 정의됨을 의미하는 1입니다.</target>
        </trans-unit>
        <trans-unit id="ee128cd6218c9f00f0c878c04ed7c1d2ba1c0dcc" translate="yes" xml:space="preserve">
          <source>This is a hashref of module/version pairs. The version indicates the minimum version to load. If no version is provided, any version is assumed to be good enough.</source>
          <target state="translated">모듈 / 버전 쌍의 해시 참조입니다. 버전은로드 할 최소 버전을 나타냅니다. 버전이 제공되지 않으면 모든 버전이 충분하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ea245b58697360367e48479db117e287399d341e" translate="yes" xml:space="preserve">
          <source>This is a hashref registering what modules/utilities were known to fail for fetching files (mostly because they weren't installed).</source>
          <target state="translated">파일 가져 오기에 실패한 것으로 알려진 모듈 / 유틸리티를 등록하는 해시 참조입니다 (주로 설치되지 않았기 때문).</target>
        </trans-unit>
        <trans-unit id="13f36e17edc5b55eec70028ba183b328e8dbca62" translate="yes" xml:space="preserve">
          <source>This is a helper macro to avoid preprocessor issues, replaced by nothing unless under DEBUGGING, where it expands to an assert of its argument, followed by a comma (hence the comma operator). If we just used a straight assert(), we would get a comma with nothing before it when not DEBUGGING.</source>
          <target state="translated">이것은 전 처리기 문제를 방지하기위한 도우미 매크로이며, DEBUGGING에서 인수의 주장으로 확장되고 쉼표 (따라서 쉼표 연산자)가 뒤 따르는 경우가 아니면 아무것도 대체하지 않습니다. 곧은 assert ()를 사용했다면, DEBUGGING을하지 않을 때 앞에 아무것도없는 쉼표를 얻게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="6db9d2be56e4bd29861b900e47f6610d6d79219d" translate="yes" xml:space="preserve">
          <source>This is a helper module for &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils::Typemaps&lt;/a&gt; for quick one-liners, specifically for inclusion of shared typemaps that live on CPAN into an XS file (see SYNOPSIS).</source>
          <target state="translated">이것은 &lt;a href=&quot;ExtUtils::Typemaps&quot;&gt;ExtUtils :: Typemaps에&lt;/a&gt; 대한 도우미 모듈로 , 특히 CPAN에있는 공유 유형 맵을 XS 파일에 포함시키기위한 빠른 한 줄짜리입니다 (SYNOPSIS 참조).</target>
        </trans-unit>
        <trans-unit id="8b603fea48d1504287b31a7673d8ab99f976baa7" translate="yes" xml:space="preserve">
          <source>This is a historical copy of the version 1.0 specification for</source>
          <target state="translated">이것은 버전 1.0 사양의 역사적 사본입니다.</target>
        </trans-unit>
        <trans-unit id="8b7928f53e6ee2a874629878e189efee32c672b7" translate="yes" xml:space="preserve">
          <source>This is a historical copy of the version 1.1 specification for</source>
          <target state="translated">이것은 버전 1.1 사양의 역사적 사본입니다.</target>
        </trans-unit>
        <trans-unit id="1f9efdce05ccbe2b0c93e1405a345d20446d5db1" translate="yes" xml:space="preserve">
          <source>This is a historical copy of the version 1.2 specification for</source>
          <target state="translated">이것은 버전 1.2 사양의 역사적 사본입니다.</target>
        </trans-unit>
        <trans-unit id="c9f6f354bd0c338955bb1fb9445b4d1cdbc435b5" translate="yes" xml:space="preserve">
          <source>This is a historical copy of the version 1.3 specification for</source>
          <target state="translated">이것은 버전 1.3 사양의 역사적 사본입니다.</target>
        </trans-unit>
        <trans-unit id="578907e068f231060c64ecb50b7600e276be1ad5" translate="yes" xml:space="preserve">
          <source>This is a historical copy of the version 1.4 specification for</source>
          <target state="translated">이것은 버전 1.4 사양의 역사적 사본입니다.</target>
        </trans-unit>
        <trans-unit id="4a1fab382e0a7925a5c811854a65acd65148efbd" translate="yes" xml:space="preserve">
          <source>This is a hook called by &lt;code&gt;Test2::IPC::Driver-&amp;gt;abort()&lt;/code&gt;. This is your chance to cleanup when an abort happens. You cannot prevent the abort, but you can gracefully except it.</source>
          <target state="translated">이것은 &lt;code&gt;Test2::IPC::Driver-&amp;gt;abort()&lt;/code&gt; 의해 호출되는 후크 입니다. 중단이 발생했을 때 정리할 수있는 기회입니다. 중단을 막을 수는 없지만 우아하게 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06620991ffe068dc2736a15c53466ae907b72fa9" translate="yes" xml:space="preserve">
          <source>This is a list of cpan modules that have been known to have been broken by the upgrade at one point.</source>
          <target state="translated">이것은 한 시점에서 업그레이드로 인해 손상된 것으로 알려진 cpan 모듈의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="80a5d6041426b672058c7972e6b8efdd8d6854bf" translate="yes" xml:space="preserve">
          <source>This is a list of optionally locally applied patches. Default is an empty list.</source>
          <target state="translated">선택적으로 로컬로 적용된 패치 목록입니다. 기본값은 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9eb7a0a93db9a83c1c6303ceaf2e042280cc43c1" translate="yes" xml:space="preserve">
          <source>This is a list of questions and answers about Unicode in Perl, intended to be read after &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 다음에 읽히 도록 의도 된 Perl의 유니 코드에 대한 질문 및 답변 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="36d9a4f8cf6a08db2c492aa7d56c16aa12a7c5d3" translate="yes" xml:space="preserve">
          <source>This is a little bit more complex in the case of UTF-8, see what &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; does with &lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;is_utf8_string_loclen&lt;/a&gt;.</source>
          <target state="translated">UTF-8의 경우 조금 더 복잡합니다 . &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; 가 is_utf8_string_loclen으로 수행하는 &lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4901f78af354a736c130e92964e260be63c159d4" translate="yes" xml:space="preserve">
          <source>This is a macro that evaluates to a string constant of the UTF-8 bytes that define the Unicode BYTE ORDER MARK (U+FEFF) for the platform that perl is compiled on. This allows code to use a mnemonic for this character that works on both ASCII and EBCDIC platforms. &lt;code&gt;sizeof(BOM_UTF8) - 1&lt;/code&gt; can be used to get its length in bytes.</source>
          <target state="translated">이것은 perl이 컴파일되는 플랫폼에 대한 유니 코드 BYTE ORDER MARK (U + FEFF)를 정의하는 UTF-8 바이트의 문자열 상수로 평가되는 매크로입니다. 이를 통해 코드는 ASCII 및 EBCDIC 플랫폼 모두에서 작동하는이 문자에 대한 니모닉을 사용할 수 있습니다. &lt;code&gt;sizeof(BOM_UTF8) - 1&lt;/code&gt; 은 길이를 바이트 단위로 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bb2f1fa60e6e4aabfb57df2cd30391606718c5" translate="yes" xml:space="preserve">
          <source>This is a macro that evaluates to a string constant of the UTF-8 bytes that define the Unicode REPLACEMENT CHARACTER (U+FFFD) for the platform that perl is compiled on. This allows code to use a mnemonic for this character that works on both ASCII and EBCDIC platforms. &lt;code&gt;sizeof(REPLACEMENT_CHARACTER_UTF8) - 1&lt;/code&gt; can be used to get its length in bytes.</source>
          <target state="translated">이것은 perl이 컴파일되는 플랫폼에 대한 Unicode REPLACEMENT CHARACTER (U + FFFD)를 정의하는 UTF-8 바이트의 문자열 상수로 평가되는 매크로입니다. 이를 통해 코드는 ASCII 및 EBCDIC 플랫폼 모두에서 작동하는이 문자에 대한 니모닉을 사용할 수 있습니다. &lt;code&gt;sizeof(REPLACEMENT_CHARACTER_UTF8) - 1&lt;/code&gt; 은 길이를 바이트 단위로 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2ee3c54bcb807a66fe7b80e3caf8861bbb44a5c" translate="yes" xml:space="preserve">
          <source>This is a message from your shell telling you that the command 'ar' was not found. You need to check your PATH environment variable to make sure that it includes the directory with the 'ar' command. This is a common problem on Solaris, where 'ar' is in the /usr/ccs/bin/ directory.</source>
          <target state="translated">셸에서 'ar'명령을 찾을 수 없다는 메시지입니다. PATH 환경 변수에 'ar'명령이있는 디렉토리가 포함되어 있는지 확인해야합니다. 이는 'ar'이 / usr / ccs / bin / 디렉토리에있는 Solaris의 일반적인 문제입니다.</target>
        </trans-unit>
        <trans-unit id="7be9582165bd5c245d33269d0775adef5b86c2d1" translate="yes" xml:space="preserve">
          <source>This is a misleadingly-named synonym for &lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string&lt;/a&gt;. On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters are exactly the UTF-8 invariants. But EBCDIC machines have more invariants than just the ASCII characters, so &lt;code&gt;is_invariant_string&lt;/code&gt; is preferred.</source>
          <target state="translated">이것은 &lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string과 동일하게&lt;/a&gt; 잘못 명명 된 동의어입니다 . ASCII-ish 플랫폼에서 이름은 오해의 소지가 없습니다. ASCII 범위 문자는 정확히 UTF-8 불변입니다. 그러나 EBCDIC 시스템은 ASCII 문자보다 더 많은 불변을 가지므로 &lt;code&gt;is_invariant_string&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c69da4ed0205aa990de29ccffe5609edc6392c10" translate="yes" xml:space="preserve">
          <source>This is a misleadingly-named synonym for &lt;a href=&quot;#is_utf8_invariant_string&quot;&gt;&quot;is_utf8_invariant_string&quot;&lt;/a&gt;. On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters are exactly the UTF-8 invariants. But EBCDIC machines have more invariants than just the ASCII characters, so &lt;code&gt;is_utf8_invariant_string&lt;/code&gt; is preferred.</source>
          <target state="translated">이것은 &lt;a href=&quot;#is_utf8_invariant_string&quot;&gt;&quot;is_utf8_invariant_string&quot;&lt;/a&gt; 의 오해의 소지가있는 이름의 동의어입니다 . ASCII-ish 플랫폼에서 이름은 오해의 소지가 없습니다. ASCII 범위 문자는 정확히 UTF-8 불변입니다. 그러나 EBCDIC 머신은 ASCII 문자보다 더 많은 불변성이 있으므로 &lt;code&gt;is_utf8_invariant_string&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="de824f4204bca39b6173554bd682eeaf59e1fe59" translate="yes" xml:space="preserve">
          <source>This is a no-op on Win32.</source>
          <target state="translated">이것은 Win32에서 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7c97b390951ae9bd8a25bf05c714cdf4d686ebf3" translate="yes" xml:space="preserve">
          <source>This is a noop provided for completeness.</source>
          <target state="translated">완전성을 위해 제공되는 스눕입니다.</target>
        </trans-unit>
        <trans-unit id="cad6dd9d37300229c43fc4982c7046b422a38ba9" translate="yes" xml:space="preserve">
          <source>This is a perl-friendly wrapper for the SetFilePointer API (below). &lt;code&gt;$ivOffset&lt;/code&gt; can be a 64 bit integer or &lt;code&gt;Math::BigInt&lt;/code&gt; object if your Perl doesn't have 64 bit integers. The return value is the new offset and will likewise be a 64 bit integer or a &lt;code&gt;Math::BigInt&lt;/code&gt; object.</source>
          <target state="translated">이것은 SetFilePointer API를위한 Perl 친화적 인 래퍼입니다 (아래). &lt;code&gt;$ivOffset&lt;/code&gt; 은 64 비트 정수이거나 Perl에 64 비트 정수가없는 경우 &lt;code&gt;Math::BigInt&lt;/code&gt; 개체 일 수 있습니다. 반환 값은 새 오프셋이며 마찬가지로 64 비트 정수 또는 &lt;code&gt;Math::BigInt&lt;/code&gt; 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="09b98a2fdc86ae4c3444a314c0304e18f2968e2d" translate="yes" xml:space="preserve">
          <source>This is a placeholder option.</source>
          <target state="translated">자리 표시 자 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="7c861f566285d766324a3adafaf95c9b329a80f7" translate="yes" xml:space="preserve">
          <source>This is a port of Perl 5.22.1, it is a fresh port and not in any way compatible with my previous ports of Perl 5.8 and 5.16.3. This means you will need to reinstall / rebuild any third party modules you have installed.</source>
          <target state="translated">이것은 Perl 5.22.1의 포트이며 새로운 포트이며 Perl 5.8 및 5.16.3의 이전 포트와 호환되지 않습니다. 즉, 설치 한 타사 모듈을 다시 설치 / 재 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="309f4be6a68d1ca1ce9f563923f5229fee286990" translate="yes" xml:space="preserve">
          <source>This is a ported perl for the POSIX subsystem in BS2000 VERSION OSD V3.1A or later. It may work on other versions, but we started porting and testing it with 3.1A and are currently using Version V4.0A.</source>
          <target state="translated">이것은 BS2000 VERSION OSD V3.1A 이상의 POSIX 서브 시스템에 대한 포트 펄입니다. 다른 버전에서도 작동 할 수 있지만 3.1A로 포팅 및 테스트를 시작했으며 현재 버전 V4.0A를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="639c8df7e83fc87480520c466044037ac91d5b6f" translate="yes" xml:space="preserve">
          <source>This is a protocol used by some firewall ftp proxies. It is used to authorise the user to send data out. If both arguments are not specified then &lt;code&gt;authorize&lt;/code&gt; uses &lt;code&gt;Net::Netrc&lt;/code&gt; to do a lookup.</source>
          <target state="translated">일부 방화벽 ftp 프록시에서 사용되는 프로토콜입니다. 사용자에게 데이터를 보내도록 권한을 부여하는 데 사용됩니다. 두 인수를 모두 지정하지 않으면 &lt;code&gt;authorize&lt;/code&gt; 는 &lt;code&gt;Net::Netrc&lt;/code&gt; 를 사용 하여 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="82750308b15340e2bc5e38d801e8c14df884ca99" translate="yes" xml:space="preserve">
          <source>This is a quick reference to Perl's regular expressions. For full information see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, as well as the &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; section in this document.</source>
          <target state="translated">이것은 Perl의 정규식에 대한 빠른 참조입니다. 자세한 내용은 이 문서 의 &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; 섹션 뿐만 아니라 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35b9db060b8091b2af5afc80f2eb9e19755899c4" translate="yes" xml:space="preserve">
          <source>This is a quick reference to Perl's regular expressions. For full information see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, as well as the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section in this document.</source>
          <target state="translated">이것은 Perl의 정규 표현식에 대한 빠른 참조입니다. 자세한 정보는 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 이 문서 의 &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d47823b6d4d1bf90c0ec374b8fb409bfdb682e4b" translate="yes" xml:space="preserve">
          <source>This is a re-implementation of stdio-like buffering written as a PerlIO layer. As such it will call whatever layer is below it for its operations, typically &lt;code&gt;:unix&lt;/code&gt; .</source>
          <target state="translated">이것은 PerlIO 레이어로 작성된 stdio와 같은 버퍼링을 다시 구현 한 것입니다. 따라서 작업을 위해 아래에있는 모든 레이어, 일반적으로 &lt;code&gt;:unix&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c07aa2f3524b873fd324bdd6f2f6fa2ff3e120b7" translate="yes" xml:space="preserve">
          <source>This is a re-implementation of stdio-like buffering written as a PerlIO layer. As such it will call whatever layer is below it for its operations, typically &lt;code&gt;:unix&lt;/code&gt;.</source>
          <target state="translated">이것은 PerlIO 계층으로 작성된 stdio와 유사한 버퍼링의 재 구현입니다. 따라서 작업을 위해 그 아래에있는 모든 레이어를 호출합니다 (일반적으로 &lt;code&gt;:unix&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="44e930eeb8d1107d985a15ebeb47b4f046e00dd2" translate="yes" xml:space="preserve">
          <source>This is a real error, and the partial sequence is all we're going to get.</source>
          <target state="translated">이것은 실제 오류이며 부분적인 시퀀스가 ​​우리가 얻을 수있는 전부입니다.</target>
        </trans-unit>
        <trans-unit id="f72833b07fdaaa27353877ad8c40f0425a069181" translate="yes" xml:space="preserve">
          <source>This is a reference card for people who are familiar with the C library and who want to do things the Perl way; to tell them which functions they ought to use instead of the more normal C functions.</source>
          <target state="translated">이것은 C 라이브러리에 익숙하고 Perl 방식으로 일을하고 싶은 사람들을위한 참조 카드입니다. 더 일반적인 C 함수 대신 어떤 함수를 사용해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c471b4ac155563a00fba4ae9a0887cfc3abb5085" translate="yes" xml:space="preserve">
          <source>This is a reference to a hash of named arguments which need checking.</source>
          <target state="translated">이것은 검사가 필요한 명명 된 인수의 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="3afd1b8fae5b72ccc5141dfe79c691921d5825d2" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Parser, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">Tom Christiansen이 작성한 이전 포드 :: 텍스트 모듈을 대체합니다. 이제 Pod :: Parser를 사용하기 때문에 인터페이스가 개선되었지만 이전 Pod :: Text :: pod2text () 함수와 거의 호환되는 인터페이스를 계속 사용할 수 있습니다. 그래도 새로운 통화 규칙으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c47cbb12fb76c06a9104b6dcce71cb1371c44a36" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Simple, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">Tom Christiansen이 작성한 이전 포드 :: 텍스트 모듈을 대체합니다. 이제 Pod :: Simple을 사용하기 때문에 인터페이스가 개선되었지만 이전 Pod :: Text :: pod2text () 함수와 거의 호환되는 인터페이스를 계속 사용할 수 있습니다. 그래도 새로운 통화 규칙으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="3b47b707c5aa2685e694887a6a732f13742fa45a" translate="yes" xml:space="preserve">
          <source>This is a runtime equivalent to &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;\N{...}&lt;/code&gt; 과 동등한 런타임 입니다.</target>
        </trans-unit>
        <trans-unit id="7df2ed11242941585186bf8621f08062eb4ee123" translate="yes" xml:space="preserve">
          <source>This is a runtime equivalent to &lt;code&gt;\N{...}&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;\N{...}&lt;/code&gt; 해당하는 런타임 입니다.</target>
        </trans-unit>
        <trans-unit id="8d9da988cd5eab1bf4131dbddff40049241ae791" translate="yes" xml:space="preserve">
          <source>This is a safer version of &lt;a href=&quot;#UTF8SKIP&quot;&gt;&quot;&lt;code&gt;UTF8SKIP&lt;/code&gt;&quot;&lt;/a&gt;, but still not as safe as &lt;a href=&quot;#UTF8_SAFE_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_SAFE_SKIP&lt;/code&gt;&quot;&lt;/a&gt;. This version doesn't blindly assume that the input string pointed to by &lt;code&gt;s&lt;/code&gt; is well-formed, but verifies that there isn't a NUL terminating character before the expected end of the next character in &lt;code&gt;s&lt;/code&gt;. The length &lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt; returns stops just before any such NUL.</source>
          <target state="translated">이것은 &lt;a href=&quot;#UTF8SKIP&quot;&gt;&quot; &lt;code&gt;UTF8SKIP&lt;/code&gt; &quot;&lt;/a&gt; 의 더 안전한 버전 이지만 여전히 &lt;a href=&quot;#UTF8_SAFE_SKIP&quot;&gt;&quot; &lt;code&gt;UTF8_SAFE_SKIP&lt;/code&gt; &quot;&lt;/a&gt; 만큼 안전하지는 않습니다 . 이 버전은 맹목적으로 입력 문자열을 가리키는 것으로 가정하지 않습니다 &lt;code&gt;s&lt;/code&gt; 에서 다음 문자의 예상 종료 전에 NUL 종료 문자가없는 것을 잘 형성되지만를 검증 &lt;code&gt;s&lt;/code&gt; . 길이 &lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt; 는 이러한 NUL 바로 전에 중지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7a879136a0009e169d98349a2353c9b002b70d9" translate="yes" xml:space="preserve">
          <source>This is a set of four-letter (capitalized) codes from ISO 15924 such as 'Phnx' for Phoenician. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">페니키아 (Phoenician)의 경우 'Phnx'와 같은 ISO 15924의 4 자리 (자본) 코드 세트입니다. 또한 IANA 언어 레지스트리에 포함 된이 세트의 추가 사항도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6ef813cd850a9f27ba1c4663d4e71f25b5053fb3" translate="yes" xml:space="preserve">
          <source>This is a set of three-digit numeric codes from ISO 15924 such as 115 for Phoenician.</source>
          <target state="translated">페니키아 (Phoenician)의 경우 115와 같은 ISO 15924의 3 자리 숫자 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="349f283b1feb640d3ec35d62b03e25d6ddada207" translate="yes" xml:space="preserve">
          <source>This is a set of three-letter (uppercase) codes from ISO 4217 such as EUR for Euro.</source>
          <target state="translated">이것은 유로에 대한 EUR와 같은 ISO 4217의 3 문자 (대문자) 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="17d4b87831fc36eb513ece10122e95f8dc8ba998" translate="yes" xml:space="preserve">
          <source>This is a short description of the purpose of the distribution.</source>
          <target state="translated">배포 목적에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="6241a7679be2105aef445a1326e4d5af9e0ed08e" translate="yes" xml:space="preserve">
          <source>This is a short tutorial on writing a simple module with MakeMaker. It's really not that hard.</source>
          <target state="translated">MakeMaker로 간단한 모듈을 작성하는 방법에 대한 간단한 튜토리얼입니다. 정말 그렇게 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53100bf0748f5ba489bc4dc460d2dfa8f3afc641" translate="yes" xml:space="preserve">
          <source>This is a short way of setting &lt;code&gt;gnu_compat&lt;/code&gt;&lt;code&gt;bundling&lt;/code&gt;&lt;code&gt;permute&lt;/code&gt;&lt;code&gt;no_getopt_compat&lt;/code&gt; . With &lt;code&gt;gnu_getopt&lt;/code&gt; , command line handling should be fully compatible with GNU getopt_long().</source>
          <target state="translated">이것은 &lt;code&gt;gnu_compat&lt;/code&gt; &lt;code&gt;bundling&lt;/code&gt; &lt;code&gt;permute&lt;/code&gt; &lt;code&gt;no_getopt_compat&lt;/code&gt; 를 설정하는 간단한 방법입니다 . &lt;code&gt;gnu_getopt&lt;/code&gt; 를 사용하면 명령 행 처리가 GNU getopt_long ()과 완전히 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6c30e1d8e68a2b36cd4e4515119a97629e3b7f3" translate="yes" xml:space="preserve">
          <source>This is a short way of setting &lt;code&gt;gnu_compat&lt;/code&gt;&lt;code&gt;bundling&lt;/code&gt;&lt;code&gt;permute&lt;/code&gt;&lt;code&gt;no_getopt_compat&lt;/code&gt;. With &lt;code&gt;gnu_getopt&lt;/code&gt;, command line handling should be reasonably compatible with GNU getopt_long().</source>
          <target state="translated">이것은 &lt;code&gt;gnu_compat&lt;/code&gt; &lt;code&gt;bundling&lt;/code&gt; &lt;code&gt;permute&lt;/code&gt; &lt;code&gt;no_getopt_compat&lt;/code&gt; 를 설정하는 간단한 방법입니다 . &lt;code&gt;gnu_getopt&lt;/code&gt; 를 사용하면 명령 줄 처리가 GNU getopt_long ()과 합리적으로 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7af9997becadfe87d824ab8762ffccd7719bb2b4" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt; 의 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="588934f1b5f409b7ed4ee0102675e3e7a80e417d" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt; 의 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="cf3172ad5af1d75bb916c8179d00c2eb32b1726b" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt; 의 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="14414929d404b298096e05330ae3a552582cc596" translate="yes" xml:space="preserve">
          <source>This is a shortcut method for creating a new parser object, setting the output handle to STDOUT, and then processing the specified file (or filehandle, or in-memory document). This is handy for one-liners like this:</source>
          <target state="translated">새 파서 객체를 생성하고 출력 핸들을 STDOUT으로 설정 한 다음 지정된 파일 (또는 파일 핸들 또는 인 메모리 문서)을 처리하는 바로 가기 방법입니다. 이것은 다음과 같이 한 줄짜리 사람에게 편리합니다.</target>
        </trans-unit>
        <trans-unit id="dcc6d2562c6f7206f328c3550bdc5e8e52460de3" translate="yes" xml:space="preserve">
          <source>This is a side-effect of &lt;code&gt;$^W&lt;/code&gt; being dynamically scoped.</source>
          <target state="translated">이것은 &lt;code&gt;$^W&lt;/code&gt; 가 동적으로 범위를 정하는 부작용입니다 .</target>
        </trans-unit>
        <trans-unit id="8fa6df25c130c949bab77362ff50f938867d104d" translate="yes" xml:space="preserve">
          <source>This is a simple base class used by &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; to store objects that represent the current bit of test output data from TAP (usually a single line). Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 가 TAP 의 테스트 출력 데이터의 현재 비트를 나타내는 객체 (보통 한 줄)를 저장 하는 데 사용하는 간단한 기본 클래스 입니다. 서브 클래 싱하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="70e0073b6d6a8609dc729e6d6d928dac9be45307" translate="yes" xml:space="preserve">
          <source>This is a simple base class used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; to store objects that represent the current bit of test output data from TAP (usually a single line). Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 에서 TAP의 테스트 출력 데이터의 현재 비트 (보통 한 줄)를 나타내는 객체를 저장 하는 데 사용하는 간단한 기본 클래스 입니다. 서브 클래 싱이 아니라면이 모듈을 직접 사용할 필요가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7185e61c4885f8a233ed21b8b5981172205d46a1" translate="yes" xml:space="preserve">
          <source>This is a simple factory class which returns a &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass representing the current bit of test data from TAP (usually a single line). It is used primarily by &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;. Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP&lt;/a&gt; 에서 테스트 데이터의 현재 비트를 나타내는 TAP :: Parser :: Result 하위 클래스를 반환하는 간단한 팩토리 클래스입니다 (보통 한 줄). 주로 &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP :: Parser :: Grammar에서 사용&lt;/a&gt; 됩니다. 서브 클래 싱이 아니라면이 모듈을 직접 사용할 필요가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a6a517a000eee7c9d8650e790b06bace86ece1d" translate="yes" xml:space="preserve">
          <source>This is a simple factory class which returns a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass representing the current bit of test data from TAP (usually a single line). It is used primarily by &lt;a href=&quot;grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;. Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;result&quot;&gt;TAP&lt;/a&gt; 에서 테스트 데이터의 현재 비트를 나타내는 TAP :: Parser :: Result 서브 클래스 (보통 단일 행) 를 리턴하는 간단한 팩토리 클래스입니다 . 주로 &lt;a href=&quot;grammar&quot;&gt;TAP :: Parser :: Grammar에&lt;/a&gt; 의해 사용됩니다 . 서브 클래 싱하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae7e075e46130a389abcce2b8eca77b2b0799334" translate="yes" xml:space="preserve">
          <source>This is a simple iterator base class that defines &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s iterator API. Iterators are typically created from &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s.</source>
          <target state="translated">이것은 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 의 반복자 API 를 정의하는 간단한 반복자 기본 클래스입니다 . 반복자는 일반적으로 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4069d913ee16241ecc681da22f86977bd49afb8f" translate="yes" xml:space="preserve">
          <source>This is a simple iterator base class that defines &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;'s iterator API. Iterators are typically created from &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 의 반복자 API 를 정의하는 간단한 반복기 기본 클래스입니다 . 반복자는 일반적으로 &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ef2b28fd5eff705f1f406ac6e66e9bba64a8d81" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for arrays of scalar content, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용하는 스칼라 컨텐츠의 배열을위한 간단한 반복자 랩퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6d417eccb38d31c23ab96e3cf68e4a816b76541" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for arrays of scalar content, used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 에서 사용하는 스칼라 콘텐츠 배열에 대한 간단한 반복기 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6211175f40b02f3bcb25615dc63d424f5b04b85e" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for executing external processes, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용하는 외부 프로세스를 실행하기위한 간단한 반복자 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c2b745b6dbe4af61d1702703c27d1890df50b85" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for executing external processes, used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 에서 사용하는 외부 프로세스를 실행하기위한 간단한 반복기 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="08f74f820359ec13407ecd95ebc00861df2faa4a" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for reading from filehandles, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 의해 사용되는 파일 핸들에서 읽기위한 간단한 반복자 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="50c897102f8db883c5b03ed2150ab040040eb6e3" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for reading from filehandles, used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt; 에서 사용하는 파일 핸들에서 읽기위한 간단한 반복기 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb6d528be7b9b50f443385c12d7c3581d3c5b271" translate="yes" xml:space="preserve">
          <source>This is a simple test harness which allows tests to be run and results automatically aggregated and output to STDOUT.</source>
          <target state="translated">이는 테스트를 실행하고 결과를 자동으로 집계하여 STDOUT에 출력 할 수있는 간단한 테스트 하네스입니다.</target>
        </trans-unit>
        <trans-unit id="94c2e1c3d42721757938806d86cea256f2130297" translate="yes" xml:space="preserve">
          <source>This is a small simple module which simplifies the manipulation of @INC at compile time.</source>
          <target state="translated">이것은 컴파일 타임에 @INC의 조작을 단순화하는 작은 간단한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="9fc66897af3216d370b7d29148cefcd6ce1895da" translate="yes" xml:space="preserve">
          <source>This is a somewhat misleadingly-named synonym for &lt;a href=&quot;#is_utf8_invariant_string&quot;&gt;&quot;is_utf8_invariant_string&quot;&lt;/a&gt;. &lt;code&gt;is_utf8_invariant_string&lt;/code&gt; is preferred, as it indicates under what conditions the string is invariant.</source>
          <target state="translated">이것은 &lt;a href=&quot;#is_utf8_invariant_string&quot;&gt;&quot;is_utf8_invariant_string&quot;&lt;/a&gt; 의 다소 오해의 소지가있는 동의어입니다 . &lt;code&gt;is_utf8_invariant_string&lt;/code&gt; 은 어떤 조건에서 문자열이 불변인지를 나타내므로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="ed45414649005cf46b9b142e78787c7d0efdd654" translate="yes" xml:space="preserve">
          <source>This is a standard message issued by OS/2 applications. *nix applications die in silence. It is considered to be a feature. One can easily disable this by appropriate sighandlers.</source>
          <target state="translated">이것은 OS / 2 어플리케이션이 발행 한 표준 메시지입니다. * nix 애플리케이션은 조용히 죽습니다. 기능으로 간주됩니다. 적절한 sighandler에 의해이를 쉽게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae30c10c2c1eb9a5c4373e69ebda02e4f56fd6ac" translate="yes" xml:space="preserve">
          <source>This is a static function and is defined as &lt;code&gt;STATIC S_whatever&lt;/code&gt; , and usually called within the sources as &lt;code&gt;whatever(...)&lt;/code&gt; .</source>
          <target state="translated">이것은 정적 함수이며 &lt;code&gt;STATIC S_whatever&lt;/code&gt; 로 정의되며 일반적으로 소스 내에서 &lt;code&gt;whatever(...)&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="93db2ec99a46178540e6d933d3db3e813cba4109" translate="yes" xml:space="preserve">
          <source>This is a statically linked &lt;code&gt;a.out&lt;/code&gt; -style executable. It cannot load dynamic Perl extensions. The executable supplied in binary distributions has a lot of extensions prebuilt, thus the above restriction is important only if you use custom-built extensions. This executable is a VIO application.</source>
          <target state="translated">이것은 정적으로 링크 된 &lt;code&gt;a.out&lt;/code&gt; 스타일 실행 파일입니다. 동적 Perl 확장을로드 할 수 없습니다. 바이너리 배포판에 제공된 실행 파일에는 많은 확장이 사전 빌드되어 있으므로 사용자 정의 빌드 확장을 사용하는 경우에만 위의 제한 사항이 중요합니다. 이 실행 파일은 VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="6050386124f32e151c85ac19e4bf7f179cc7ee17" translate="yes" xml:space="preserve">
          <source>This is a statically linked &lt;code&gt;a.out&lt;/code&gt;-style executable. It cannot load dynamic Perl extensions. The executable supplied in binary distributions has a lot of extensions prebuilt, thus the above restriction is important only if you use custom-built extensions. This executable is a VIO application.</source>
          <target state="translated">이것은 정적으로 링크 된 &lt;code&gt;a.out&lt;/code&gt; 스타일 실행 파일입니다. 동적 Perl 확장을로드 할 수 없습니다. 바이너리 배포판에서 제공되는 실행 파일에는 미리 빌드 된 많은 확장이 있으므로 위의 제한은 사용자 지정 빌드 된 확장을 사용하는 경우에만 중요합니다. 이 실행 파일은 VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="fc094e72af8b9d6622201511120df9125d5e32ff" translate="yes" xml:space="preserve">
          <source>This is a string combining version, subversion and perl_patchlevel (if perl_patchlevel is non-zero). It is typically something like 'version 7 subversion 1' or 'version 7 subversion 1 patchlevel 11224' It is computed here to avoid duplication of code in</source>
          <target state="translated">버전, subversion 및 perl_patchlevel을 결합하는 문자열입니다 (perl_patchlevel이 0이 아닌 경우). 일반적으로 'version 7 subversion 1'또는 'version 7 subversion 1 patchlevel 11224'와 같습니다. 코드 중복을 피하기 위해 여기에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="344924719b1bae83eead5b685f2904260f7cb31e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a YAML block is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . YAML 블록이 발생하면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf06d3cd2a668f16a1a9ea1434ebed8459984ced" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a bail out line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 이 클래스의 토큰은 구제 금융 라인이 발생하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c79fb77a91aa29bad4fe0d58e746157c12b1af2" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a comment line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 주석 행이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e73059f9980ac5f029fc80717ab9da6cff6341" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a plan line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 계획 라인이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dc05d4de16b8c5b025bf96846c216318ce2e7788" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a pragma is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . pragma가 발생하면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="173909c91c915dbe5ae4e1761f6ce3015f27ac8e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a test line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 테스트 라인이 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d99a6f5c44525e8196b8a9f8f432a4c8297fe174" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a version line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 버전 줄이 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9dc0dfab2b15f7dcded6106f389d289ed7b45a8" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if the parser does not recognize the token line. For example:</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 파서가 토큰 라인을 인식하지 못하면이 클래스의 토큰이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed4cd1012a41fb5a1a7060605167f8be93252008" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.</source>
          <target state="translated">이것은 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="01955ea22dd8df7278eac44c179e1001f2515492" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; which contains functionality for AIX.</source>
          <target state="translated">이것은 AIX 용 기능을 포함하는 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="7c1e32adacf76af516c3dc09a8537a0753efa981" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; which contains functionality for DOS.</source>
          <target state="translated">이것은 DOS 용 기능을 포함하는 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="47b129a643b34901e62e29707350a374de0680ca" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; which contains functionality for QNX.</source>
          <target state="translated">이것은 QNX에 대한 기능을 포함하는 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0b6e1e6b486dea407e580c0e2cc2d98b00f22af0" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; which contains functionality for VOS.</source>
          <target state="translated">이것은 VOS에 대한 기능을 포함하는 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="799835149ca383aa8b305d5ede1d01edcaa0b5f8" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; which contains functionality for the AT&amp;amp;T U/WIN UNIX on Windows environment.</source>
          <target state="translated">이것은 Windows 환경에서 AT &amp;amp; T U / WIN UNIX에 대한 기능을 포함하는 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix&lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="340bbc2ea6963bffbbe6941993555f290666f4a1" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;ExtUtils::MM_Win32&quot;&gt;ExtUtils::MM_Win32&lt;/a&gt; containing changes necessary to get MakeMaker playing nice with command.com and other Win9Xisms.</source>
          <target state="translated">이것은 &lt;a href=&quot;ExtUtils::MM_Win32&quot;&gt;ExtUtils :: MM_Win32&lt;/a&gt; 의 하위 클래스로, makeMaker가 command.com 및 기타 Win9Xisms와 잘 어울리도록하는 데 필요한 변경 사항이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b53215134f5cbc383cac750029f65d6450131026" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.</source>
          <target state="translated">이것은 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="cbfa4855e0a827a4f18e0ec314a0ed35780940c3" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; and inherits all its methods. And since, that in turn is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;, you can use any of its methods. This means you can output to a string instead of a file, or you can parse from an array.</source>
          <target state="translated">이것은 &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod :: Simple :: Methody&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속합니다. 그리고 이는 차례로 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 하위 클래스이므로 모든 메서드를 사용할 수 있습니다. 즉, 파일 대신 문자열로 출력하거나 배열에서 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b62d9459ef18f1f9c6c03ce30dfa6880d75c6b4" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; and inherits all its methods. The implementation is entirely different than &lt;a href=&quot;Pod::Simple::HTML&quot;&gt;Pod::Simple::HTML&lt;/a&gt;, but it largely preserves the same interface.</source>
          <target state="translated">이것은 &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod :: Simple :: Methody&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속합니다. 구현은 &lt;a href=&quot;Pod::Simple::HTML&quot;&gt;Pod :: Simple :: HTML&lt;/a&gt; 과 완전히 다르지만 대체로 동일한 인터페이스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d70cd484c0a00bbdef362df23c2f73605109ad33" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; and inherits all its methods (and options).</source>
          <target state="translated">이것은 &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 의 하위 클래스이며 모든 메서드 (및 옵션)를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="e5da5a6e2b57264768645b40fe22cfe9caefff93" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt; and inherits all its methods, and adds these methods:</source>
          <target state="translated">이것은 &lt;a href=&quot;Pod::Simple::PullParserToken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 하위 클래스이며 모든 메서드를 상속하고 다음 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="107e81f4b7474c7feada5a435bb6963d4db8b587" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a YAML block is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . YAML 블록이 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc8b3158257a5918480b25430da2f5fef788dee" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a bail out line is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 이 클래스의 토큰은 구제 금융 라인이 발견되면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="de2ba624d979718ad574a041ef9fc50c38c57f03" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a comment line is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 주석 행이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8a263d9e5f13e496a231697a80b724925ad6b4f7" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a plan line is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 계획 라인이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="453ae9574c31155ff549670fec7286c3d2e506ee" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a pragma is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . pragma가 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="68b32ff46cc448ac4738c305e0535bec308e1368" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a test line is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 테스트 라인이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="853461077f357c4d07d54dbd6052fe8b4b619b06" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a version line is encountered.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 버전 행이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1f89869b3ae635a087404851a64447d99201105d" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if the parser does not recognize the token line. For example:</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 하위 클래스입니다 . 구문 분석기가 토큰 행을 인식하지 못하면이 클래스의 토큰이 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81afca9fe5e8caf5fd548b6ee9f92134f9dc21dc" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; and inherits all its methods. The implementation is entirely different than &lt;a href=&quot;html&quot;&gt;Pod::Simple::HTML&lt;/a&gt;, but it largely preserves the same interface.</source>
          <target state="translated">이것은 &lt;a href=&quot;methody&quot;&gt;Pod :: Simple :: Methody&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속합니다. 구현은 &lt;a href=&quot;html&quot;&gt;Pod :: Simple :: HTML&lt;/a&gt; 과 완전히 다르지만 대부분 동일한 인터페이스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="5a42087b4a78a20207066122ca4141600c24be72" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; and inherits all its methods (and options).</source>
          <target state="translated">이것은 &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 의 서브 클래스이며 모든 메소드와 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="ea32c34eae791ae221ac4a3cce2869532666d30e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt; and inherits all its methods, and adds these methods:</source>
          <target state="translated">이것은 &lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속하며 다음 메소드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aa9cce04d90d56b725964eab73e0fca5ac743d29" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for AIX.</source>
          <target state="translated">이것은 AIX 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0d4a1a4cfdafa1cb09a4fb89fe42af2c7616286a" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for DOS.</source>
          <target state="translated">이것은 ExtUtils :: MM_Unix의 서브 클래스이며 DOS 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1586bedfb51abdc0ca225f9c3db5c388bf3fe7c7" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for QNX.</source>
          <target state="translated">이것은 QNX 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c6edbaa56530abda8144785f91c81fc02ebf9b90" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for VOS.</source>
          <target state="translated">VOS 용 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2e5c7251645932dc8d1dc7c962cbf2e45c3f4094" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for the AT&amp;amp;T U/WIN UNIX on Windows environment.</source>
          <target state="translated">이것은 ExtUtils :: MM_Unix의 서브 클래스이며 Windows 환경의 AT &amp;amp; T U / WIN UNIX에 대한 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="93a42e55d1097c11d0072e86d7f542b3230e6bcf" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Win32 containing changes necessary to get MakeMaker playing nice with command.com and other Win9Xisms.</source>
          <target state="translated">이것은 ExtUtils :: MM_Win32의 서브 클래스로, makeMaker가 command.com 및 기타 Win9Xism과 잘 작동하는 데 필요한 변경 사항을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e0b4c6da331b58235bc356124916aaee144c5df3" translate="yes" xml:space="preserve">
          <source>This is a subclass of Test::Builder that overrides many of the methods so that they don't output anything. It also keeps track of its own set of test results so that you can use Test::Builder based modules to perform tests on other Test::Builder based modules.</source>
          <target state="translated">이것은 아무 것도 출력하지 않도록 많은 메서드를 재정의하는 Test :: Builder의 하위 클래스입니다. 또한 Test :: Builder 기반 모듈을 사용하여 다른 Test :: Builder 기반 모듈에서 테스트를 수행 할 수 있도록 자체 테스트 결과 집합을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="fb8a82ae7e4bcc23be8b85858941e5009748ca04" translate="yes" xml:space="preserve">
          <source>This is a suggestion to the OS to let this thread yield CPU time to other threads. What actually happens is highly dependent upon the underlying thread implementation.</source>
          <target state="translated">이것은이 스레드가 다른 스레드에 CPU 시간을 양보하도록 OS에 대한 제안입니다. 실제로 발생하는 것은 기본 스레드 구현에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="a6edb8217d2751ef4a763256a458a4449c4b36b5" translate="yes" xml:space="preserve">
          <source>This is a superclass for &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;-based modules. It provides a handful of common functionality and a method of getting at the underlying &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 기반 모듈 의 수퍼 클래스입니다 . 몇 가지 일반적인 기능과 기본 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 객체 를 얻는 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="86dcc93cd0bd00d838160a4be7abd927dfe38deb" translate="yes" xml:space="preserve">
          <source>This is a superclass for &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;-based modules. It provides a handful of common functionality and a method of getting at the underlying &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 기반 모듈 의 수퍼 클래스입니다 . 몇 가지 일반적인 기능과 기본 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 객체 를 얻는 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="55903e986f0ab6ec743472dc06cf20bffa759a05" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ())</source>
          <target state="translated">이것은 (! foldEQ ())의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="53444e6b25598bcd7a21f4559d1c88a0a3357fc9" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ_locale())</source>
          <target state="translated">이것은 (! foldEQ_locale ())의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="fcc6c9fb8ee9fa78c05691f7ab1cdadcae007699" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;a href=&quot;#UTF8SKIP&quot;&gt;&quot;&lt;code&gt;UTF8SKIP&lt;/code&gt;&quot;&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;#UTF8SKIP&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;UTF8SKIP&lt;/code&gt; &quot; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="24e385b7e36cb7a0ced0df625995ab1044114a0c" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;a href=&quot;#my_strtod&quot;&gt;&quot;my_strtod&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#my_strtod&quot;&gt;&quot;my_strtod&quot;&lt;/a&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="b7a79d3b8039acc12b5d9216412b8358571878c3" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;code&gt;(! foldEQ())&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;(! foldEQ())&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="21d7c8aad7ed8e1a708d44906c3480702f1f0148" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;code&gt;(! foldEQ_locale())&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;(! foldEQ_locale())&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="0fc9211f34524643d77b88ccf3fbe69c0926ca68" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;code&gt;\p{Present_In=*}&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;\p{Present_In=*}&lt;/code&gt; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="ef2cd0a3571852b5da355e5994ba81184e031c06" translate="yes" xml:space="preserve">
          <source>This is a template for a function suitable for the &lt;code&gt;uf_val&lt;/code&gt; field in a &lt;code&gt;ufuncs&lt;/code&gt; structure for this call. The &lt;code&gt;uf_set&lt;/code&gt; and &lt;code&gt;uf_index&lt;/code&gt; fields are irrelevant.</source>
          <target state="translated">이 호출 에 대한 &lt;code&gt;ufuncs&lt;/code&gt; 구조 의 &lt;code&gt;uf_val&lt;/code&gt; 필드에 적합한 함수의 템플리트입니다 . &lt;code&gt;uf_set&lt;/code&gt; 및 &lt;code&gt;uf_index&lt;/code&gt; 필드는 무관하다.</target>
        </trans-unit>
        <trans-unit id="9a3d72bf731a4c00183b3bacd2aaed590afe1490" translate="yes" xml:space="preserve">
          <source>This is a term used for characters occupying more than one byte.</source>
          <target state="translated">이것은 2 바이트 이상을 차지하는 문자에 사용되는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="da67b166e535d5aab2dfd4a4bef7fa2c7dc18440" translate="yes" xml:space="preserve">
          <source>This is a useful alternative to the &lt;code&gt;verbose&lt;/code&gt; key.</source>
          <target state="translated">이것은 &lt;code&gt;verbose&lt;/code&gt; 키에 대한 유용한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="618f9f0ef250e390bb1ce0844593906ed698aa6a" translate="yes" xml:space="preserve">
          <source>This is a user-pragma. If you're very lucky some code you're using will know that you asked for less CPU usage or ram or fat or... we just can't know. Consult your documentation on everything you're currently using.</source>
          <target state="translated">이것은 사용자 프 래그 마입니다. 운이 좋으면 사용중인 코드 중 CPU 사용량이나 램 또는 지방을 적게 요청했음을 알 수 있습니다 ... 우리는 알 수 없습니다. 현재 사용중인 모든 것에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="549c7013b9e1e79516da2acbe0f4cbcc8a435b4f" translate="yes" xml:space="preserve">
          <source>This is a very low-level subtest tool. This is useful for writing tools which produce subtests. This is not intended for people simply writing tests.</source>
          <target state="translated">이것은 매우 낮은 수준의 하위 테스트 도구입니다. 이것은 하위 테스트를 생성하는 도구를 작성하는 데 유용합니다. 이것은 단순히 테스트를 작성하는 사람들을위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9072caacce10e18c36561023f1a3fb675f058f90" translate="yes" xml:space="preserve">
          <source>This is a very scary API function. Please do not use this unless you need to. This is here for &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; and backwards compatibility. This has you directly manipulate the hash instead of returning a new one for performance reasons.</source>
          <target state="translated">이것은 매우 무서운 API 함수입니다. 필요한 경우가 아니면 사용하지 마십시오. 이것은 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 및 이전 버전과의 호환성을 위해 여기에 있습니다. 이렇게하면 성능상의 이유로 새 해시를 반환하는 대신 해시를 직접 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfd131d8c6fe42fe0bb5d3832bf575939c9777d0" translate="yes" xml:space="preserve">
          <source>This is a very simple HTTP/1.1 client, designed for doing simple requests without the overhead of a large framework like &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt; 와 같은 대형 프레임 워크의 오버 헤드없이 간단한 요청을 수행하도록 설계된 매우 간단한 HTTP / 1.1 클라이언트 입니다.</target>
        </trans-unit>
        <trans-unit id="64e767810034132a2b4c4370f6987205b3130d0d" translate="yes" xml:space="preserve">
          <source>This is a work in progress. Not much progress by now :-)</source>
          <target state="translated">진행중인 작업입니다. 지금까지 많은 진전이 없습니다 :-)</target>
        </trans-unit>
        <trans-unit id="e65d4664502f4836edff6c3f42d466dce62c114e" translate="yes" xml:space="preserve">
          <source>This is achieved by creating separate watchdog process which spawns the specified program in a separate process session and supervises it: optionally feeds it with input, stores its exit code, stdout and stderr, terminates it in case it runs longer than specified.</source>
          <target state="translated">이는 별도의 프로세스 세션에서 지정된 프로그램을 생성하고이를 감시하는 별도의 감시 프로세스를 생성하여 수행됩니다. 선택적으로 입력을 통해 피드를 제공하고 종료 코드, stdout 및 stderr을 저장하고 지정된 것보다 오래 실행될 경우 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bb7efcdf0700fbaadbdc0f648a8badbdf9664612" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::Checker (or Pod::Checker) subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: Checker (또는 Pod :: Checker) 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="e4a943560ee56b7076fa64d64bd3da44e85a30ca" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::RTF subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: RTF 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="92b8d72a94a8da6c54d9f33ab092eb620ca878de" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::XMLOutStream subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: XMLOutStream 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8eda3362231deb25dfd89db58202611c06a3d40c" translate="yes" xml:space="preserve">
          <source>This is all very powerful, of course, and should be used only in moderation to make the world a better place.</source>
          <target state="translated">물론 이것은 매우 강력하며 세상을 더 나은 곳으로 만들기 위해 적당히 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0a76465b05604833b1a2e0c25409dcb3ddad85c" translate="yes" xml:space="preserve">
          <source>This is also a no-op on Win32.</source>
          <target state="translated">이것은 또한 Win32에서 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="a906c4fc08f6c0cd00609aae3ea9167c7850d130" translate="yes" xml:space="preserve">
          <source>This is also helpful for the case where a package lives within a differently named file:</source>
          <target state="translated">패키지가 다른 이름의 파일 내에있는 경우에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="783e4cc092057905b6553d7a8d798ecf7ac0db31" translate="yes" xml:space="preserve">
          <source>This is also invalid:</source>
          <target state="translated">이것은 또한 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="c1d7e1e2839d2377297de367eca0902f0ba00891" translate="yes" xml:space="preserve">
          <source>This is also the logical inverse of Perl_isfinite().</source>
          <target state="translated">이것은 또한 Perl_isfinite ()의 논리적 역수입니다.</target>
        </trans-unit>
        <trans-unit id="b3fd8f0524f7cd7ff14e2f99856ad3f41ff313f3" translate="yes" xml:space="preserve">
          <source>This is also used to store the name of an autoloaded subroutine in an XS AUTOLOAD routine. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">이것은 또한 XS AUTOLOAD 루틴에서 자동로드 된 서브 루틴의 이름을 저장하는 데 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts의 &quot;XSUB로 자동로드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c778320b203a5e38261d5a20fb7ed1b70340a749" translate="yes" xml:space="preserve">
          <source>This is also used to store the name of an autoloaded subroutine in an XS AUTOLOAD routine. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">XS AUTOLOAD 루틴에 자동로드 서브 루틴의 이름을 저장하는 데에도 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts에서 XSUB로 자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dda58eafcf63f43293998602056ada9565deb26" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">또한 &lt;code&gt;tail -f&lt;/code&gt; 를 에뮬레이트하는 응용 프로그램에도 유용합니다 . 읽기에서 EOF를 누른 다음 잠시 잠을 자면 (아마) 더미 seek ()를 사용하여 재설정해야합니다. 가 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 위치를 변경하지 않지만, 그것을</target>
        </trans-unit>
        <trans-unit id="545e9279207dbe359d514df130705d9c342445f3" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">또한 &lt;code&gt;tail -f&lt;/code&gt; 를 에뮬레이트하는 응용 프로그램에도 유용합니다 . 읽기에서 EOF를 누른 다음 잠시 잠을 자면 (아마) 더미 seek ()를 사용하여 재설정해야합니다. 가 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 위치를 변경하지 않지만, 그것을</target>
        </trans-unit>
        <trans-unit id="a52e0f7ca96a5fbe75f9443a3f0c72752cfbabc6" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt;. Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; to reset things. The &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; doesn't change the position, but it</source>
          <target state="translated">이것은 또한 &lt;code&gt;tail -f&lt;/code&gt; 를 에뮬레이트하는 애플리케이션에도 유용합니다 . 당신이 잠시 후 잠을 당신의 읽기에 EOF를 명중하고 나면, 당신은 (아마도) 더미에 스틱이 &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 물건을 재설정 할 수 있습니다. 가 &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; 위치를 변경하지 않지만, 그것을</target>
        </trans-unit>
        <trans-unit id="43e213b7894a106692ed41475e921810e2f2ef96" translate="yes" xml:space="preserve">
          <source>This is an</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="4c90f14631981742f71c6736d15ae2f064f77f93" translate="yes" xml:space="preserve">
          <source>This is an (almost) drop-in replacement for the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt;, taking the same parameters, and returning the same information, except that it returns the correct underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. Regular &lt;code&gt;setlocale&lt;/code&gt; will instead return &lt;code&gt;C&lt;/code&gt; if the underlying locale has a non-dot decimal point character, or a non-empty thousands separator for displaying floating point numbers. This is because perl keeps that locale category such that it has a dot and empty separator, changing the locale briefly during the operations where the underlying one is required. &lt;code&gt;Perl_setlocale&lt;/code&gt; knows about this, and compensates; regular &lt;code&gt;setlocale&lt;/code&gt; doesn't.</source>
          <target state="translated">이는 시스템 &lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt; 대한 (거의) 드롭 인 대체로 , 동일한 매개 변수를 사용하고 올바른 기본 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일을 리턴한다는 점을 제외하고 동일한 정보를 리턴합니다 . 기본 로케일에 점이 아닌 소수점 문자가 있거나 부동 소수점 숫자를 표시하기위한 비어 있지 않은 천 단위 구분 기호가있는 경우 일반 &lt;code&gt;setlocale&lt;/code&gt; 은 대신 &lt;code&gt;C&lt;/code&gt; 를 리턴 합니다. 이는 perl이 해당 로케일 범주를 유지하여 점과 빈 구분 기호를 갖도록하여 기본이 필요한 작업 중에 로케일을 잠깐 변경하기 때문입니다. &lt;code&gt;Perl_setlocale&lt;/code&gt; 은 이에 대해 알고 보상합니다. 일반 &lt;code&gt;setlocale&lt;/code&gt; 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd976a317a3ec6f0b4a27e94361a936461d6f366" translate="yes" xml:space="preserve">
          <source>This is an (almost) drop-in replacement for the system &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/nl_langinfo&quot;&gt;nl_langinfo(3)&lt;/a&gt;&lt;/code&gt;, taking the same &lt;code&gt;item&lt;/code&gt; parameter values, and returning the same information. But it is more thread-safe than regular &lt;code&gt;nl_langinfo()&lt;/code&gt;, and hides the quirks of Perl's locale handling from your code, and can be used on systems that lack a native &lt;code&gt;nl_langinfo&lt;/code&gt;.</source>
          <target state="translated">이것은 시스템 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/nl_langinfo&quot;&gt;nl_langinfo(3)&lt;/a&gt;&lt;/code&gt; 대한 (거의) 드롭 인 대체이며 동일한 &lt;code&gt;item&lt;/code&gt; 매개 변수 값을 취하고 동일한 정보를 리턴합니다. 그러나 일반 &lt;code&gt;nl_langinfo()&lt;/code&gt; 보다 스레드 안전성이 더 높고 코드에서 Perl 로케일 처리의 단점을 숨기고 기본 &lt;code&gt;nl_langinfo&lt;/code&gt; 가없는 시스템에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a6f47fb722d0ea7678e717327e932adc89f5068" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;omf&lt;/code&gt; -style executable which is dynamically linked to</source>
          <target state="translated">이것은 동적으로 연결된 &lt;code&gt;omf&lt;/code&gt; 스타일 실행 파일입니다.</target>
        </trans-unit>
        <trans-unit id="dabefce59e417333ca600bd4dd8db5a16251cbf7" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;omf&lt;/code&gt;-style executable which is dynamically linked to</source>
          <target state="translated">이것은 동적으로 링크되는 &lt;code&gt;omf&lt;/code&gt; 스타일 실행 파일입니다.</target>
        </trans-unit>
        <trans-unit id="8d756c24376672373a010de25a2097378db4129a" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="af496b01592b41744cf75154ff216cf0d89995f5" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="0f224ebf8b5ff108eba2dd2634ead001d06cfcd1" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;die&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;die&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="e4572b24f1be3de6a2a765b1a1cc604739ba54f5" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;warn&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;warn&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="444ad3c538b41852126460958182410c9e29526a" translate="yes" xml:space="preserve">
          <source>This is an abstract base class for &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; handlers / handlers.</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; 핸들러 / 핸들러에 대한 추상 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="3e6cd5c9b47acd371c49a0cb03b008b70d97eb82" translate="yes" xml:space="preserve">
          <source>This is an advisory and may not be called in the case where tests are being supplied to Test::Harness by an iterator.</source>
          <target state="translated">이것은 권고이며 반복자에 의해 Test :: Harness에 테스트가 제공되는 경우에는 호출되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19e78208159ce9aa0dcbe21965a831175a968be" translate="yes" xml:space="preserve">
          <source>This is an alias to &lt;code&gt;_to_bytes()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;_to_bytes()&lt;/code&gt; 의 별칭 입니다.</target>
        </trans-unit>
        <trans-unit id="75a8c80d2e7e01dabcc4dbb94c6ee5f84830f182" translate="yes" xml:space="preserve">
          <source>This is an alternate constructor for a CPAN::Meta::Requirements object. It takes a hash of module names and version requirement strings and returns a new CPAN::Meta::Requirements object. As with add_string_requirement, a version can be a Perl &quot;v-string&quot;. Optionally, you can supply a hash-reference of options, exactly as with the &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; method.</source>
          <target state="translated">이것은 CPAN :: Meta :: Requirements 객체의 대체 생성자입니다. 모듈 이름과 버전 요구 사항 문자열의 해시를 취하고 새로운 CPAN :: Meta :: Requirements 객체를 반환합니다. add_string_requirement와 마찬가지로 버전은 Perl &quot;v-string&quot;이 될 수 있습니다. 선택적으로 &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; 메소드 와 똑같이 옵션의 해시 참조를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e308dd432d69b5157566a6a8a06cea4450cd898c" translate="yes" xml:space="preserve">
          <source>This is an architecture-independent macro to copy one structure to another.</source>
          <target state="translated">하나의 구조를 다른 구조로 복사하기위한 아키텍처 독립적 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="142891d3e046c25d09b04f0976a954076a30931f" translate="yes" xml:space="preserve">
          <source>This is an array ref holding blacklisted modules/utilities for fetching files with.</source>
          <target state="translated">이것은 파일을 가져 오기위한 블랙리스트 모듈 / 유틸리티를 보유하는 배열 참조입니다.</target>
        </trans-unit>
        <trans-unit id="491c41877d76840e5259e347f3a17d7e2c10b8de" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output sent to STDOUT the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;&quot;full_buffer&quot;&lt;/a&gt; apply.</source>
          <target state="translated">생성 된 명령이 STDOUT에 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;&quot;full_buffer&quot;&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="df12371f4d4ec63415fcab8f4e275a767f08fe3d" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output sent to STDOUT the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">이것은 생성 된 명령으로 STDOUT에 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="65d3c0310d92313bd54c100e1d80d7755b1697de" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output the command generated. Note that buffers are only available if you have &lt;a href=&quot;IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; installed, or if your system is able to work with &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; -- see below). Otherwise, this element will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">이것은 명령이 생성 한 모든 출력을 포함하는 배열 참조입니다. 버퍼는 &lt;a href=&quot;IPC::Run&quot;&gt;IPC :: Run이&lt;/a&gt; 설치되어 있거나 시스템이 &lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt; 에서 작동 할 수 있는 경우에만 사용할 수 있습니다 (아래 참조). 그렇지 않으면이 요소는 &lt;code&gt;undef&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8a9ac748db8e604ab1a3be03c2cd4ff11d70fa" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output the command generated. Note that buffers are only available if you have &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; installed, or if your system is able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; -- see below). Otherwise, this element will be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">명령이 생성 한 모든 출력을 포함하는 배열 참조입니다. 버퍼는 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run이&lt;/a&gt; 설치되어 있거나 시스템이 &lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; 에서 작동 할 수 있는 경우에만 사용할 수 있습니다 (아래 참조). 그렇지 않으면이 요소는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e51b6f86f1f86cad28f13e9b83a9b2933429150" translate="yes" xml:space="preserve">
          <source>This is an arrayreference containing all the output sent to STDERR the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;&quot;full_buffer&quot;&lt;/a&gt; apply.</source>
          <target state="translated">이것은 명령이 생성 한 STDERR로 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;&quot;full_buffer&quot;&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c18758c49f12c582c5080bf3c3ccaff6f97f99da" translate="yes" xml:space="preserve">
          <source>This is an arrayreference containing all the output sent to STDERR the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">이것은 명령이 생성 한 STDERR에 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35261ed11f8f6da05d71e00af479e064b704d1d3" translate="yes" xml:space="preserve">
          <source>This is an error because the region is opened by &quot;thing&quot;, and the &quot;=end&quot; tries to close &quot;hting&quot; [sic].</source>
          <target state="translated">&quot;thing&quot;에 의해 영역이 열리고 &quot;= end&quot;가 &quot;hting&quot;[sic]을 닫으려고하기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d3257f4ef00c0a5618b58e5b8a2d35eebd0a3ad" translate="yes" xml:space="preserve">
          <source>This is an experimental feature and is available from Perl 5.31.6 when enabled by &lt;code&gt;use feature 'isa'&lt;/code&gt;. It emits a warning in the &lt;code&gt;experimental::isa&lt;/code&gt; category.</source>
          <target state="translated">이것은 실험적인 기능이며 &lt;code&gt;use feature 'isa'&lt;/code&gt; 을 사용하여 활성화 된 경우 Perl 5.31.6에서 사용할 수 있습니다 . &lt;code&gt;experimental::isa&lt;/code&gt; 범주 에서 경고를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="b79a05e5e946ef4d9b0147040712489ddfe70bec" translate="yes" xml:space="preserve">
          <source>This is an experimental feature and the interface may change.</source>
          <target state="translated">이것은 실험적인 기능이며 인터페이스가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038057198b05cf435f922989a902c34a0ad8bec5" translate="yes" xml:space="preserve">
          <source>This is an experimental feature available starting in 5.18, and is subject to change as we gain field experience with it. Any attempt to use it will raise a warning, unless disabled via</source>
          <target state="translated">이것은 5.18부터 사용할 수있는 실험적인 기능이며 현장 경험을 쌓으면 변경 될 수 있습니다. 사용하지 않으면 경고 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="52d334621bd62974acc022322ae25fb3c75cd6d1" translate="yes" xml:space="preserve">
          <source>This is an extremely simple, extremely basic module for writing tests suitable for CPAN modules and other pursuits. If you wish to do more complicated testing, use the Test::More module (a drop-in replacement for this one).</source>
          <target state="translated">CPAN 모듈 및 기타 목적에 적합한 테스트 작성을위한 매우 단순하고 매우 기본적인 모듈입니다. 보다 복잡한 테스트를 수행하려면 Test :: More 모듈 (이 모듈 대신 드롭 인 대체)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3bd2379bc5006f607adb4e525b61ae72a1758dea" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;a href=&quot;perlvar#%24%5EA&quot;&gt;&lt;code&gt;$^A&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;). Eventually, when a &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; is done, the contents of &lt;a href=&quot;perlvar#%24%5EA&quot;&gt;&lt;code&gt;$^A&lt;/code&gt;&lt;/a&gt; are written to some filehandle. You could also read &lt;a href=&quot;perlvar#%24%5EA&quot;&gt;&lt;code&gt;$^A&lt;/code&gt;&lt;/a&gt; and then set &lt;a href=&quot;perlvar#%24%5EA&quot;&gt;&lt;code&gt;$^A&lt;/code&gt;&lt;/a&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt;. Note that a format typically does one &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; per line of form, but the &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; compiler.</source>
          <target state="translated">이것은 &lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; s에서 사용하는 내부 함수 이지만 호출 할 수도 있습니다. 그것은 (참조 포맷 &lt;a href=&quot;perlform&quot;&gt;perlform를&lt;/a&gt; 서식 출력 누산기로 출력 배치 PICTURE의 내용에 따른 값 목록) &lt;a href=&quot;perlvar#%24%5EA&quot;&gt; &lt;code&gt;$^A&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; 에서 &lt;a href=&quot;english&quot;&gt;영어&lt;/a&gt; ). 결국 &lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 가 완료되면 &lt;a href=&quot;perlvar#%24%5EA&quot;&gt; &lt;code&gt;$^A&lt;/code&gt; &lt;/a&gt; 의 내용이 일부 파일 핸들에 기록됩니다. &lt;a href=&quot;perlvar#%24%5EA&quot;&gt; &lt;code&gt;$^A&lt;/code&gt; &lt;/a&gt; 읽은 다음 &lt;a href=&quot;perlvar#%24%5EA&quot;&gt; &lt;code&gt;$^A&lt;/code&gt; &lt;/a&gt; 다시 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정할 수도 있습니다 . 주 형식은 일반적으로 일한다는 것을 &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt; &lt;code&gt;formline&lt;/code&gt; &lt;/a&gt; 형태의 라인 당하지만 &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt; &lt;code&gt;formline&lt;/code&gt; 을&lt;/a&gt;함수 자체는 PICTURE에 몇 개의 줄 바꿈이 삽입되었는지는 신경 쓰지 않습니다. 이것은 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~~&lt;/code&gt; 토큰이 전체 PICTURE를 한 줄로 취급 함을 의미합니다 . 따라서 &lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 컴파일러 와 마찬가지로 단일 레코드 형식을 구현하려면 여러 폼 라인을 사용해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc193a250bf3f7bae0644ab68952c14087e27f56" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s에서 사용하는 내부 함수 이지만 호출 할 수도 있습니다. PICTURE의 내용에 따라 값 목록을 형식화하고 ( &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; 참조 ) 출력을 형식 출력 누산기 &lt;code&gt;$^A&lt;/code&gt; (또는 영어의 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; )에 배치합니다. 결국, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 가 완료되면 &lt;code&gt;$^A&lt;/code&gt; 의 내용이 일부 파일 핸들에 기록됩니다. &lt;code&gt;$^A&lt;/code&gt; 읽은 다음 &lt;code&gt;$^A&lt;/code&gt; 를 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 다시 설정할 수도 있습니다 . 주 형식은 일반적으로 일한다는 것을 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 형태의 라인 당하지만 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 을함수 자체는 얼마나 많은 줄 바꿈이 PICTURE에 포함되는지 상관하지 않습니다. 이것은 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~~&lt;/code&gt; 토큰이 전체 PICTURE를 한 줄로 취급 한다는 것을 의미합니다 . 따라서 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 컴파일러 와 마찬가지로 단일 레코드 형식을 구현하기 위해 여러 양식을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd310f7276a510d01ce03cf67c2975df5756cafc" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s에서 사용하는 내부 함수 이지만 호출 할 수도 있습니다. PICTURE의 내용에 따라 값 목록을 형식화하고 ( &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 참조 ) 출력을 형식 출력 누산기 &lt;code&gt;$^A&lt;/code&gt; (또는 영어의 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; )에 배치합니다. 결국, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 가 완료되면 &lt;code&gt;$^A&lt;/code&gt; 의 내용이 일부 파일 핸들에 기록됩니다. &lt;code&gt;$^A&lt;/code&gt; 읽은 다음 &lt;code&gt;$^A&lt;/code&gt; 를 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 다시 설정할 수도 있습니다 . 주 형식은 일반적으로 일한다는 것을 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 형태의 라인 당하지만 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 을함수 자체는 얼마나 많은 줄 바꿈이 PICTURE에 포함되는지 상관하지 않습니다. 이것은 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~~&lt;/code&gt; 토큰이 전체 PICTURE를 한 줄로 취급 한다는 것을 의미합니다 . 따라서 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 컴파일러 와 마찬가지로 단일 레코드 형식을 구현하기 위해 여러 양식을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10fae8cad46b6999dd334a3e0cee274316414176" translate="yes" xml:space="preserve">
          <source>This is an internal module for controlling the debug level (a.k.a. trace level) of Pod::Simple. This is of interest only to Pod::Simple developers.</source>
          <target state="translated">Pod :: Simple의 디버그 수준 (일명 추적 수준)을 제어하기위한 내부 모듈입니다. 이것은 Pod :: Simple 개발자에게만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91ad54ddf5b339889a4d7e36baa90c6c5e3e7226" translate="yes" xml:space="preserve">
          <source>This is an internal routine that turns scalars into objects.</source>
          <target state="translated">이것은 스칼라를 객체로 바꾸는 내부 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="8cdba91d1ae6fc951cd637b385ae75d511979603" translate="yes" xml:space="preserve">
          <source>This is an introduction to the use of performance and optimization techniques which can be used with particular reference to perl programs. While many perl developers have come from other languages, and can use their prior knowledge where appropriate, there are many other people who might benefit from a few perl specific pointers. If you want the condensed version, perhaps the best advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:</source>
          <target state="translated">이것은 perl 프로그램을 특별히 참조하여 사용할 수있는 성능 및 최적화 기술 사용에 대한 소개입니다. 많은 perl 개발자들이 다른 언어에서 왔으며 적절한 경우 사전 지식을 사용할 수 있지만 perl 특정 포인터로 혜택을 볼 수있는 다른 사람들이 많이 있습니다. 압축 버전을 원한다면 가장 유명한 조언은 유명한 일본 사무라이 미야모토 무사시 (Miyamoto Musashi)의 조언입니다.</target>
        </trans-unit>
        <trans-unit id="ebf9799eb4583d152aed8c96794440fad527a142" translate="yes" xml:space="preserve">
          <source>This is an obscure but effective optimization that used to live in &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; directly. Not implementing it should never result in incorrect use of typemaps, just less efficient code.</source>
          <target state="translated">이것은 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 직접 살았던 모호하지만 효과적인 최적화입니다 . 이를 구현하지 않으면 typemap의 잘못된 사용이 발생해서는 안되며 효율성이 떨어지는 코드 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="1366a76cfef4230c6beae74ce2285fa6d6be94b2" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _a.</source>
          <target state="translated">이것은 _a의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="18fb271daf0d1e76d3278d9f0bd4670eecfaa747" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _exe.</source>
          <target state="translated">이것은 _exe의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="e951b381a4c4d96fa5592d033afe7d8fa718b152" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _o.</source>
          <target state="translated">이것은 _o의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="cb104080e92edd7dc3925f96e9fda2c7d309ad5a" translate="yes" xml:space="preserve">
          <source>This is an old synonym for p_ in</source>
          <target state="translated">이것은 p_에 대한 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="b5fc26e5565eebc6d4044fbce473b9eb67351b9f" translate="yes" xml:space="preserve">
          <source>This is an optimal representation of a failed assertion.</source>
          <target state="translated">이것은 실패한 주장을 최적으로 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b4cfcf0ffea37b688372b80ff163b43d18f9321" translate="yes" xml:space="preserve">
          <source>This is an optimal representation of a passing assertion.</source>
          <target state="translated">이것은 전달 된 주장을 최적으로 표현한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cff524bb64d56edc3bbefa9dc9ce6f39390a4745" translate="yes" xml:space="preserve">
          <source>This is an unnecessary synonym for &lt;a href=&quot;#SvUVX&quot;&gt;&quot;SvUVX&quot;&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;#SvUVX&quot;&gt;&quot;SvUVX&quot;&lt;/a&gt; 의 불필요한 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="f5d749cd3a1da6fa9f5e91de2edcf596acd57750" translate="yes" xml:space="preserve">
          <source>This is an upper limit on the amount of memory that &lt;code&gt;Tie::File&lt;/code&gt; will consume at any time while managing the file. This is used for two things: managing the</source>
          <target state="translated">이것은 &lt;code&gt;Tie::File&lt;/code&gt; 이 파일 을 관리하는 동안 언제든지 사용할 메모리 양의 상한입니다 . 이것은 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50601fd9eec31dfdb13471caa9bb11bc5c6a291d" translate="yes" xml:space="preserve">
          <source>This is another step where the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant. The RE engine scans the string from left to right and converts it into a finite automaton.</source>
          <target state="translated">이것은 &lt;code&gt;/x&lt;/code&gt; 수정 자의 존재와 관련된 또 다른 단계 입니다. RE 엔진은 문자열을 왼쪽에서 오른쪽으로 스캔하여 유한 오토 마톤으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc6e3e8d1b2d61b10ef0d4362b29339c92de71f" translate="yes" xml:space="preserve">
          <source>This is bad because splice is already O(N), and since you do it N times, you just invented a quadratic algorithm; that is, O(N**2). This does not scale, although Perl is so efficient that you probably won't notice this until you have rather largish arrays.</source>
          <target state="translated">스플 라이스는 이미 O (N)이기 때문에 나쁘고, N 번 수행하기 때문에 2 차 알고리즘을 발명했습니다. 즉, O (N ** 2)입니다. Perl이 너무 효율적이어서 배열이 다소 지연 될 때까지이 사실을 알 수 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c8339d12c8a36725299f222df00f24cfd8f69bf" translate="yes" xml:space="preserve">
          <source>This is basically shorthand for saying:</source>
          <target state="translated">이것은 기본적으로 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="df105f720cfd558cf78bf5414610fa1937dfed89" translate="yes" xml:space="preserve">
          <source>This is because math with overloaded operators follows the first (dominating) operand, and the operation of that is called and returns thus the result. So, Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether the result should be a Math::BigFloat or the second operant is one.</source>
          <target state="translated">오버로드 된 연산자가있는 수학은 첫 번째 (주요) 피연산자를 따르고 그 연산이 호출되어 결과를 반환하기 때문입니다. 따라서 Math :: BigInt :: bdiv ()는 결과가 Math :: BigFloat인지 아니면 두 번째 피연산자가 1인지에 관계없이 항상 Math :: BigInt를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d0c7a7cdf189de0cf4679b172df320157dc1c04" translate="yes" xml:space="preserve">
          <source>This is because named subroutines are created at compile time so their lexical variables get assigned to the parent lexicals from the first execution of the parent block. If a parent scope is entered a second time, its lexicals are created again, while the nested subs still reference the old ones.</source>
          <target state="translated">이는 명명 된 서브 루틴이 컴파일시 작성되므로 해당 어휘 변수가 상위 블록의 첫 번째 실행에서 상위 어휘에 할당되기 때문입니다. 상위 범위를 두 번 입력하면 해당 어휘가 다시 작성되고 중첩 된 하위는 여전히 이전 하위를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c5db892d6d5c6549aeb31514ada7ecd4f892effe" translate="yes" xml:space="preserve">
          <source>This is best demonstrated by example. Normally copy-on-write will prevent the substitution from operator from using this hack, but if you can craft a string for which copy-on-write is not possible, you can see it in play. In the current implementation, the final byte of a string buffer is used as a copy-on-write reference count. If the buffer is not big enough, then copy-on-write is skipped. First have a look at an empty string:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다. 일반적으로 write-on-write는 운영자가이 해킹을 사용하지 못하도록 막지 만, copy-on-write가 불가능한 문자열을 만들 수 있다면이를 볼 수 있습니다. 현재 구현에서 문자열 버퍼의 마지막 바이트는 COW (Copy-On-Write) 참조 카운트로 사용됩니다. 버퍼가 충분히 크지 않으면 기록 중 복사를 건너 뜁니다. 먼저 빈 문자열을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="110ec42eab0899b77be520515c85d69e76f3210b" translate="yes" xml:space="preserve">
          <source>This is best explained using the following example:</source>
          <target state="translated">이것은 다음 예제를 사용하여 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="f18232fd55c0dd0336666ad63ee77513a795d985" translate="yes" xml:space="preserve">
          <source>This is called &lt;b&gt;AFTER&lt;/b&gt; your event has been passed to the formatter. This should normally return undef, only change this if your event should cause the test to exit immediately.</source>
          <target state="translated">이 호출됩니다 &lt;b&gt;후에&lt;/b&gt; 이벤트가 포맷터에 전달되었습니다. 일반적으로 undef를 반환해야하며 이벤트로 인해 테스트가 즉시 종료되어야하는 경우에만 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d13eb30802d08c5a4630281699a434fbfa155eb" translate="yes" xml:space="preserve">
          <source>This is called &lt;b&gt;BEFORE&lt;/b&gt; your event is passed to the formatter.</source>
          <target state="translated">이벤트가 포맷터로 전달되기 &lt;b&gt;전에&lt;/b&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="62d099fbd21a2722c14b492d9b8d41121c1c7ad0" translate="yes" xml:space="preserve">
          <source>This is called after the event has been sent to the formatter in order to ensure the event is seen and understood.</source>
          <target state="translated">이벤트를보고 이해할 수 있도록 이벤트가 포맷터로 전송 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccb22d8b75566be2249f3211df19f165abb3a07" translate="yes" xml:space="preserve">
          <source>This is called an &quot;array slice&quot;.</source>
          <target state="translated">이것을 &quot;배열 슬라이스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="891aecbf1a8602556b6b3c6e2627cb164d6eebbc" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just after unwinding the stack.</source>
          <target state="translated">이것은 스택을 풀고 난 직후 어휘 범위의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7256e74371eb8bec49de48cf27c3c7d965b76d10" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just before unwinding the stack.</source>
          <target state="translated">이것은 스택을 풀기 직전에 어휘 범위의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="39c51821499fb79c1bf1a7b16255cbfad901f488" translate="yes" xml:space="preserve">
          <source>This is called by -&amp;gt;new to initialize newly-constructed language handles. If you define an init method in your class, remember that it's usually considered a good idea to call $lh-&amp;gt;SUPER::init in it (presumably at the beginning), so that all classes get a chance to initialize a new object however they see fit.</source>
          <target state="translated">새로 생성 된 언어 핸들을 초기화하기 위해-&amp;gt; new로 호출됩니다. 클래스에서 init 메소드를 정의하는 경우 일반적으로 $ lh-&amp;gt; SUPER :: init을 호출하는 것이 좋습니다 (아마도 처음에). 그러나 모든 클래스가 새 객체를 초기화 할 수있는 기회를 얻습니다. 그들은 적합하다고 본다.</target>
        </trans-unit>
        <trans-unit id="e4805289702db36154b2249d52aefe1a17a7d5f2" translate="yes" xml:space="preserve">
          <source>This is called by send after it does any IPC handling. You can use this to bypass the IPC process, but in general you should avoid using this.</source>
          <target state="translated">이것은 IPC 처리를 수행 한 후 send에 의해 호출됩니다. 이를 사용하여 IPC 프로세스를 우회 할 수 있지만 일반적으로 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b963d05b2faeedd3e7684268626d977cadc59512" translate="yes" xml:space="preserve">
          <source>This is called in the parent process when it is complete and waiting for all child processes and threads to complete.</source>
          <target state="translated">이것은 완료 될 때 부모 프로세스에서 호출되고 모든 자식 프로세스와 스레드가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="0f9664c006f22f51b95f420aa8dd1316340a796c" translate="yes" xml:space="preserve">
          <source>This is called just after starting a new lexical scope. Note that Perl code like</source>
          <target state="translated">이것은 새로운 어휘 범위를 시작한 직후에 호출됩니다. 펄 코드는</target>
        </trans-unit>
        <trans-unit id="1b4b72a19d24ff4c03ca59dfaf92e37705fe82d9" translate="yes" xml:space="preserve">
          <source>This is called just before starting to compile an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;
FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, after the eval has been set up.</source>
          <target state="translated">이것은 단지 컴파일을 시작하기 전에이라고 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 평가 후면을 설정 한 후,.</target>
        </trans-unit>
        <trans-unit id="e905c8b1f7afa99e8dea0f4bbd692d727b21d405" translate="yes" xml:space="preserve">
          <source>This is called just before starting to compile an &lt;code&gt;eval STRING&lt;/code&gt;, &lt;code&gt;do FILE&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;, after the eval has been set up.</source>
          <target state="translated">&lt;code&gt;eval STRING&lt;/code&gt; , &lt;code&gt;do FILE&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; , eval이 설정된 후 컴파일을 시작하기 직전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="63bc4c621adbf8f868c20e693d52ccd14e7f8bee" translate="yes" xml:space="preserve">
          <source>This is called just like any other method, with the object as the first argument. It does not receive any additional arguments. However, the &lt;code&gt;$_[0]&lt;/code&gt; variable will be read-only in the destructor, so you cannot assign a value to it.</source>
          <target state="translated">이것은 객체를 첫 번째 인수로 사용하여 다른 방법과 마찬가지로 호출됩니다. 추가 인수를받지 않습니다. 그러나 &lt;code&gt;$_[0]&lt;/code&gt; 변수는 소멸자에서 읽기 전용이므로 값을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2a0ca9ad6271402577255f9f1a63a32921a68ca" translate="yes" xml:space="preserve">
          <source>This is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">때 호출 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 발생합니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e84adc942d2fd7506d95b14fe0cd63bb7b960df2" translate="yes" xml:space="preserve">
          <source>This is called when &lt;code&gt;untie&lt;/code&gt; occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="translated">이것은 &lt;code&gt;untie&lt;/code&gt; 가 발생할 때 호출됩니다 . 아래의 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="85277e9fbb24fb6a920480ff94a71d2b7d6a947a" translate="yes" xml:space="preserve">
          <source>This is called when a stash is assigned to a new location in the symbol table.</source>
          <target state="translated">이것은 기호 테이블의 새 위치에 숨김이 지정 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="89a93e1f017cbb5b7b2446a6eb7bdd8163601a7e" translate="yes" xml:space="preserve">
          <source>This is called when a stash is deleted from the symbol table.</source>
          <target state="translated">이것은 기호 테이블에서 숨김이 삭제 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b2997f38c0b7e9990683c7e251969c88bfd04c59" translate="yes" xml:space="preserve">
          <source>This is called when the hash is evaluated in scalar context, and in 5.28 onwards, by &lt;code&gt;keys&lt;/code&gt; in boolean context. In order to mimic the behaviour of untied hashes, this method must return a value which when used as boolean, indicates whether the tied hash is considered empty. If this method does not exist, perl will make some educated guesses and return true when the hash is inside an iteration. If this isn't the case, FIRSTKEY is called, and the result will be a false value if FIRSTKEY returns the empty list, true otherwise.</source>
          <target state="translated">이것은 해시가 스칼라 컨텍스트에서 평가되고 5.28 이후 에는 부울 컨텍스트의 &lt;code&gt;keys&lt;/code&gt; 에 의해 평가 될 때 호출됩니다 . 묶이지 않은 해시의 동작을 모방하기 위해이 메서드는 부울로 사용될 때 묶인 해시가 비어있는 것으로 간주되는지 여부를 나타내는 값을 반환해야합니다. 이 메서드가 존재하지 않으면 perl은 몇 가지 정보를 바탕으로 추측하고 해시가 반복 안에있을 때 true를 반환합니다. 그렇지 않은 경우 FIRSTKEY가 호출되고 FIRSTKEY가 빈 목록을 반환하면 결과는 false 값이되고 그렇지 않으면 true가됩니다.</target>
        </trans-unit>
        <trans-unit id="92909fe70994d8eb483f136285b4a0530d9ad33d" translate="yes" xml:space="preserve">
          <source>This is called when the hash is evaluated in scalar context. In order to mimic the behaviour of untied hashes, this method should return a false value when the tied hash is considered empty. If this method does not exist, perl will make some educated guesses and return true when the hash is inside an iteration. If this isn't the case, FIRSTKEY is called, and the result will be a false value if FIRSTKEY returns the empty list, true otherwise.</source>
          <target state="translated">스칼라 컨텍스트에서 해시가 평가 될 때 호출됩니다. 묶이지 않은 해시의 동작을 모방하기 위해이 메서드는 연결된 해시가 비어있는 것으로 간주 될 때 false 값을 반환해야합니다. 이 메소드가 존재하지 않으면, perl은 약간의 추측 된 추측을하고 해시가 반복 내에있을 때 true를 리턴합니다. 그렇지 않으면 FIRSTKEY가 호출되고 FIRSTKEY가 빈 목록을 반환하면 결과가 false가되고 그렇지 않으면 true가됩니다.</target>
        </trans-unit>
        <trans-unit id="75a78a913b495a7f524d17a56a48057715c5e55f" translate="yes" xml:space="preserve">
          <source>This is caused by the fact that a block by itself acts as a loop that executes once, see &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;&quot;Basic BLOCKs&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 블록 자체가 한 번 실행되는 루프 역할을하기 때문에 발생합니다 . &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;&quot;Basic BLOCK&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b19ffb80b780fe42418c60b4b551943190ef11" translate="yes" xml:space="preserve">
          <source>This is caused by the fact that a block by itself acts as a loop that executes once, see &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;Basic BLOCKs&lt;/a&gt;.</source>
          <target state="translated">이것은 그 자체로 블록이 실행 한 번 참조하는 루프로서 작용한다는 사실에 의해 야기되는 &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;기본 블록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52af186e7022d7cef4d799cfdb6b5d984aef07fe" translate="yes" xml:space="preserve">
          <source>This is commonly used to suppress the creation of man pages. MAN3PODS takes a hash ref not a string, but the above worked by accident in old versions of MakeMaker.</source>
          <target state="translated">이것은 일반적으로 매뉴얼 페이지 작성을 억제하는 데 사용됩니다. MAN3PODS는 문자열이 아닌 해시 참조를 사용하지만 위의 이전 버전의 MakeMaker에서는 실수로 위의 작업을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="e5f528c0702057989be1850bcd519b0dfbd35566" translate="yes" xml:space="preserve">
          <source>This is complete documentation about all aspects of references. For a shorter, tutorial introduction to just the essential features, see &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;.</source>
          <target state="translated">이것은 참조의 모든 측면에 대한 완전한 문서입니다. 필수 기능에 대한 짧은 자습서 소개는 &lt;a href=&quot;perlreftut&quot;&gt;perlreftut를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49ca539e3859d247b8a2739f333e60f8db59abef" translate="yes" xml:space="preserve">
          <source>This is completely general, but the most computationally expensive strategy. Choose one or the other character set and transform to that for every sort comparision. Here's a complete example that transforms to ASCII sort order:</source>
          <target state="translated">이것은 완전히 일반적이지만 가장 계산 비용이 많이 드는 전략입니다. 하나 이상의 문자 세트를 선택하고 모든 정렬 비교에 대해 해당 문자 세트로 변환하십시오. 다음은 ASCII 정렬 순서로 변환하는 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="53bdad63238a05204a8a287f80428f65796d2cf9" translate="yes" xml:space="preserve">
          <source>This is completely general, but the most computationally expensive strategy. Choose one or the other character set and transform to that for every sort comparison. Here's a complete example that transforms to ASCII sort order:</source>
          <target state="translated">이것은 완전히 일반적이지만 계산 비용이 가장 많이 드는 전략입니다. 하나 또는 다른 문자 세트를 선택하고 모든 정렬 비교에 대해 해당 문자 세트로 변환하십시오. 다음은 ASCII 정렬 순서로 변환하는 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="94195eae88e55c65702824bf560045165c39578d" translate="yes" xml:space="preserve">
          <source>This is converted to a tree similar to this one:</source>
          <target state="translated">이것은 다음과 비슷한 트리로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6748d7a69c27bb3281328ef679799289a62c1105" translate="yes" xml:space="preserve">
          <source>This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man), and any other pod2xxx or Pod::Xxxx translators that use Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.</source>
          <target state="translated">현재 pod2text (Pod :: Text), pod2man (Pod :: Man) 및 Pod :: Parser 1.093 이상 또는 Pod :: Tree 1.02 이상을 사용하는 다른 pod2xxx 또는 Pod :: Xxxx 변환기에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="34e3a39567aab8112767c4a4aa9742d8df037b43" translate="yes" xml:space="preserve">
          <source>This is different from finding out the package an object is blessed into, which might not be the current package. For that, use &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;, part of the Standard Library since Perl 5.8:</source>
          <target state="translated">이것은 현재 패키지가 아닐 수도있는 개체가 축복받은 패키지를 찾는 것과 다릅니다. 이를 위해 Perl 5.8 이후 표준 라이브러리의 일부인 &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar :: Util&lt;/a&gt; 에서 &lt;code&gt;blessed&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="593812f69db240f293446ffb5751455ff8815826" translate="yes" xml:space="preserve">
          <source>This is different from finding out the package an object is blessed into, which might not be the current package. For that, use &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, part of the Standard Library since Perl 5.8:</source>
          <target state="translated">이것은 물건이 축복받은 패키지를 찾는 것과 다릅니다. 현재 패키지가 아닐 수도 있습니다. 이를 위해 Perl 5.8 이후 표준 라이브러리의 일부인 &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util의 &lt;/a&gt; &lt;code&gt;blessed&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="fb97ecda4c6d5be858b3ffd4a4b01f62707feb1c" translate="yes" xml:space="preserve">
          <source>This is different than printing the array without the interpolation:</source>
          <target state="translated">보간없이 배열을 인쇄하는 것과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2e89efe08d07d2fc445ecb0a49388c2db1540bc9" translate="yes" xml:space="preserve">
          <source>This is disabled by default.</source>
          <target state="translated">기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9b83c7f438982c73dfeaa8ce24f6687d2ff66f7" translate="yes" xml:space="preserve">
          <source>This is discussed in more detail in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;; see the entry on</source>
          <target state="translated">이것은 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 에서 더 자세히 논의됩니다 . 에 항목을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="d40247f5c8bc9b3099a9637c357fd1f201252c74" translate="yes" xml:space="preserve">
          <source>This is documented because it is used by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt;, but it's not intended for general consumption. May be removed at any time.</source>
          <target state="translated">이것은 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 에서 사용되기 때문에 문서화 되었지만 일반적인 사용을위한 것은 아닙니다. 언제든지 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fae6a858b50aa10f361d29a97f6c807c02664b" translate="yes" xml:space="preserve">
          <source>This is documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;, and although it's not the easiest thing to read, it does work. In each of these examples, we call the function inside the braces used to dereference a reference. If we have more than one return value, we can construct and dereference an anonymous array. In this case, we call the function in list context.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 문서화되어 있으며 가장 쉬운 것은 아니지만 작동합니다. 이러한 각 예에서 참조를 역 참조하는 데 사용되는 중괄호 안의 함수를 호출합니다. 반환 값이 둘 이상인 경우 익명 배열을 구성하고 역 참조 할 수 있습니다. 이 경우 목록 컨텍스트에서 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cc9f74e233591efd345d524b870503e793053031" translate="yes" xml:space="preserve">
          <source>This is done by using hostname lookup and the &lt;code&gt;local_netmask&lt;/code&gt; entry in the configuration data.</source>
          <target state="translated">이는 구성 데이터에서 호스트 이름 조회 및 &lt;code&gt;local_netmask&lt;/code&gt; 항목 을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="454855df818209bc8493bdfbab3f2ca7ae6dfdc7" translate="yes" xml:space="preserve">
          <source>This is done for a breakpoint in the current file.</source>
          <target state="translated">이것은 현재 파일의 중단 점에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c9cb4520228cecded3e0a1cfc382595df81ccf66" translate="yes" xml:space="preserve">
          <source>This is done primarily to avoid the problems Test::Builder had by exposing its singleton. We do not want anyone to replace this singleton, rebless it, or directly muck with its internals. If you need to do something and cannot because of the restrictions placed here, then please report it as an issue. If possible, we will create a way for you to implement your functionality without exposing things that should not be exposed.</source>
          <target state="translated">이것은 주로 Test :: Builder가 싱글 톤을 노출하여 가지고있는 문제를 피하기 위해 수행됩니다. 우리는 누구도이 싱글 톤을 대체하거나, 그것을 축복하거나, 내부로 직접 찌르기를 원하지 않습니다. 여기에 규정 된 제한 사항으로 인해 무언가를해야하는데 할 수없는 경우 문제로보고하십시오. 가능하다면 노출하지 말아야 할 사항을 노출하지 않고 기능을 구현할 수있는 방법을 만들 것입니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4a47be7db788c450b66cdea2d395c9b71203ef53" translate="yes" xml:space="preserve">
          <source>This is due to a bug in the C library's printf routine. printf(&quot;'%e'&quot;, 0. ) produces '0.000000e+0', but ANSI requires '0.000000e+00'. QNX has acknowledged the bug.</source>
          <target state="translated">이것은 C 라이브러리의 printf 루틴의 버그로 인한 것입니다. printf ( &quot; '% e'&quot;, 0.)는 '0.000000e + 0'을 생성하지만 ANSI에는 '0.000000e + 00'이 필요합니다. QNX는 버그를 인정했습니다.</target>
        </trans-unit>
        <trans-unit id="71e4fa6fb5f00ffdde6cecd71fb22bb161db5777" translate="yes" xml:space="preserve">
          <source>This is due to the performance optimisation of using &lt;code&gt;MULTICALL&lt;/code&gt; for the code block, which means that fresh SVs do not get allocated for each call to the block. Instead, the same SV is re-assigned for each iteration, and all the closures will share the value seen on the final iteration.</source>
          <target state="translated">이는 코드 블록에 &lt;code&gt;MULTICALL&lt;/code&gt; 을 사용하는 성능 최적화 때문 입니다. 즉, 새로운 SV는 블록에 대한 각 호출에 할당되지 않습니다. 대신 각 반복에 대해 동일한 SV가 재 할당되며 모든 클로저는 최종 반복에 표시된 값을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="50a12de62b1d872f1cb83dc14807dc4865d7fade" translate="yes" xml:space="preserve">
          <source>This is easier that you might expect if you realise that all the &lt;code&gt;IO::Compress::*&lt;/code&gt; objects are derived from &lt;code&gt;IO::File&lt;/code&gt; and that all the &lt;code&gt;IO::Uncompress::*&lt;/code&gt; modules can read from an &lt;code&gt;IO::File&lt;/code&gt; filehandle.</source>
          <target state="translated">모든 &lt;code&gt;IO::Compress::*&lt;/code&gt; 개체가 &lt;code&gt;IO::File&lt;/code&gt; 에서 파생되고 모든 &lt;code&gt;IO::Uncompress::*&lt;/code&gt; 모듈이 &lt;code&gt;IO::File&lt;/code&gt; 핸들 에서 읽을 수 있다는 것을 알고 있다면 예상 할 수있는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="447f198b012c8346529f18f6ac62c32d7efbbdb9" translate="yes" xml:space="preserve">
          <source>This is elaborately and painstakingly described in the</source>
          <target state="translated">이것은 정교하고 힘들게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="821291d0776e9b5b0d39c1a20f26c0a1d006ccf3" translate="yes" xml:space="preserve">
          <source>This is enabled by default.</source>
          <target state="translated">기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dc6a6637a3cd1c406048840a442a226332304e" translate="yes" xml:space="preserve">
          <source>This is equivalent to putting &lt;code&gt;?:&lt;/code&gt; at the beginning of every capturing group:</source>
          <target state="translated">이것은 모든 캡처 그룹의 시작 부분에 &lt;code&gt;?:&lt;/code&gt; 를 넣는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8b27aed9ee162e49847966b3b51b71c4860ae778" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following code:</source>
          <target state="translated">이것은 다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="db66d69de876b62af8e4e583ee35fa7336ce738e" translate="yes" xml:space="preserve">
          <source>This is especially handy for the handles that Perl has already opened for you.</source>
          <target state="translated">이것은 Perl이 이미 열어 놓은 핸들에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f8d05739ccb676f898da1bfecdf838eee060521a" translate="yes" xml:space="preserve">
          <source>This is especially noticeable in scripts like Makefiles and test suites, which often assume &lt;code&gt;/&lt;/code&gt; as a path separator for subdirectories.</source>
          <target state="translated">이는 Makefile 및 테스트 스위트와 같은 스크립트에서 특히 두드러지며 하위 디렉토리의 경로 구분 기호로 종종 &lt;code&gt;/&lt;/code&gt; 를 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="55e960bba2c8937bb3441980100a3402c2c9ceb2" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">이는 &lt;code&gt;__DIE__&lt;/code&gt; 후크가 &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; 를&lt;/a&gt; 다시 호출 할 수 있다는 점을 고려할 때 특히 중요하며 , 이는 오류 메시지를 변경하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f527eac137b06210e13666ef8269894d061c4071" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; 후크가 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 할 수 있다는 점을 감안할 때 이는 특히 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="e72ff779e72b05ba7f524c22b987a33b6ce734c7" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; 후크가 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 할 수 있다는 점을 감안할 때 이는 특히 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="881721fff940bf0d898fd3674c7f0d11e0a2ff4e" translate="yes" xml:space="preserve">
          <source>This is especially true if trying to catch &lt;code&gt;SIGALRM&lt;/code&gt; in a thread. To handle alarms in threads, set up a signal handler in the main thread, and then use &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot;&lt;/a&gt; to relay the signal to the thread:</source>
          <target state="translated">스레드에서 &lt;code&gt;SIGALRM&lt;/code&gt; 을 잡으려고 할 때 특히 그렇습니다 . 스레드에서 경보를 처리하려면 기본 스레드에서 신호 처리기를 설정 한 다음 &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot;&lt;/a&gt; 을 사용 하여 신호를 스레드에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="818858cb9601e6ed62390539756668bab6bf2c4d" translate="yes" xml:space="preserve">
          <source>This is especially true if trying to catch &lt;code&gt;SIGALRM&lt;/code&gt; in a thread. To handle alarms in threads, set up a signal handler in the main thread, and then use &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING&lt;/a&gt; to relay the signal to the thread:</source>
          <target state="translated">스레드에서 &lt;code&gt;SIGALRM&lt;/code&gt; 을 잡으려는 경우 특히 그렇습니다 . 스레드에서 알람을 처리하려면 메인 스레드에서 신호 처리기를 설정 한 다음 &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;스레드 신호&lt;/a&gt; 를 사용 하여 신호를 스레드에 릴레이합니다.</target>
        </trans-unit>
        <trans-unit id="3baa440856e5960eab1aef2ecf34be88a790df5d" translate="yes" xml:space="preserve">
          <source>This is essentially a helper to do the following:</source>
          <target state="translated">이것은 본질적으로 다음을 수행하는 도우미입니다.</target>
        </trans-unit>
        <trans-unit id="fd6dde33455dcaab484709ef3e2e047ba6858d2a" translate="yes" xml:space="preserve">
          <source>This is essentially a linear encoding of a nondeterministic finite-state machine (aka syntax charts or &quot;railroad normal form&quot; in parsing technology).</source>
          <target state="translated">이것은 본질적으로 비 결정적 유한 상태 머신 (구문 분석에서 구문 도표 또는 &quot;철도 정규 형식&quot;)의 선형 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="c2c33667b47416ed635e9db2747270d43c9fb79e" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to</source>
          <target state="translated">이것은 정확히</target>
        </trans-unit>
        <trans-unit id="2888d5ca02740e184f93a1ad103d7f0d59cf4bf3" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to writing &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; . You may see this idiom in the wild combined with a call to &lt;code&gt;can&lt;/code&gt; :</source>
          <target state="translated">이것은 &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; 작성과 정확히 같습니다 . 이 관용구는 야생에서 &lt;code&gt;can&lt;/code&gt; 에 대한 호출과 결합하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0addd03d3f0285338de29174c6b972eb46d8e3c5" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to writing &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt;. You may see this idiom in the wild combined with a call to &lt;code&gt;can&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; 작성하는 것과 정확히 동일합니다 . &lt;code&gt;can&lt;/code&gt; 호출과 결합 된이 관용구를 야생에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0020f4d9923684685bbbcf57921ec11fb0aac1" translate="yes" xml:space="preserve">
          <source>This is exactly the problem the</source>
          <target state="translated">이것은 정확히 문제입니다</target>
        </trans-unit>
        <trans-unit id="1323ae3621b03444ef40592d920a99e3788e04fe" translate="yes" xml:space="preserve">
          <source>This is exactly the same as:</source>
          <target state="translated">이것은 정확히 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="5350516b52a22254c5df97eb2c2d9b4520e43a69" translate="yes" xml:space="preserve">
          <source>This is fairly secure because &lt;code&gt;/\w+/&lt;/code&gt; doesn't normally match shell metacharacters, nor are dot, dash, or at going to mean something special to the shell. Use of &lt;code&gt;/.+/&lt;/code&gt; would have been insecure in theory because it lets everything through, but Perl doesn't check for that. The lesson is that when untainting, you must be exceedingly careful with your patterns. Laundering data using regular expression is the</source>
          <target state="translated">&lt;code&gt;/\w+/&lt;/code&gt; 는 일반적으로 쉘 메타 문자와 일치하지 않으며 도트, 대시 또는 쉘에 특별한 의미가 없기 때문에 상당히 안전 합니다. &lt;code&gt;/.+/&lt;/code&gt; 의 사용은 모든 것을 통과시킬 수 있기 때문에 이론상 안전하지 않았지만 Perl 은이를 확인하지 않습니다. 교훈은 오염을 풀 때 패턴에 매우주의를 기울여야한다는 것입니다. 정규식을 사용한 세탁 데이터는</target>
        </trans-unit>
        <trans-unit id="4d2e8c2e8c603b9443a2fa3515b87175734dfedd" translate="yes" xml:space="preserve">
          <source>This is faster than using the &lt;b&gt;-exec&lt;/b&gt; switch of</source>
          <target state="translated">이것은 &lt;b&gt;-exec&lt;/b&gt; 스위치를 사용하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="9163849a1830b363f8878e26cd69e4bcbea10076" translate="yes" xml:space="preserve">
          <source>This is fine for systems programming when sendmail is known to be available. But it is not fine for many non-Unix systems, and even some Unix systems that may not have sendmail installed. If a portable solution is needed, see the various distributions on CPAN that deal with it. &lt;a href=&quot;Mail::Mailer&quot;&gt;&lt;code&gt;Mail::Mailer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;Mail::Send&quot;&gt;&lt;code&gt;Mail::Send&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;MailTools&lt;/code&gt; distribution are commonly used, and provide several mailing methods, including &lt;code&gt;mail&lt;/code&gt;, &lt;code&gt;sendmail&lt;/code&gt;, and direct SMTP (via &lt;a href=&quot;Net::SMTP&quot;&gt;&lt;code&gt;Net::SMTP&lt;/code&gt;&lt;/a&gt;) if a mail transfer agent is not available. &lt;a href=&quot;Mail::Sendmail&quot;&gt;&lt;code&gt;Mail::Sendmail&lt;/code&gt;&lt;/a&gt; is a standalone module that provides simple, platform-independent mailing.</source>
          <target state="translated">이것은 sendmail을 사용할 수 있다고 알려진 시스템 프로그래밍에 적합합니다. 그러나 많은 비 유닉스 시스템과 센드 메일이 설치되지 않은 일부 유닉스 시스템에는 좋지 않습니다. 휴대용 솔루션이 필요한 경우이를 다루는 CPAN의 다양한 배포를 참조하십시오. &lt;a href=&quot;Mail::Mailer&quot;&gt; &lt;code&gt;Mail::Mailer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;Mail::Send&quot;&gt; &lt;code&gt;Mail::Send&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;MailTools&lt;/code&gt; 배포에서 일반적으로 사용 되며 메일 전송 에이전트를 사용할 수없는 경우 &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; 및 직접 SMTP ( &lt;a href=&quot;Net::SMTP&quot;&gt; &lt;code&gt;Net::SMTP&lt;/code&gt; &lt;/a&gt; 를 통해)를 포함한 여러 메일 링 방법을 제공 합니다. &lt;a href=&quot;Mail::Sendmail&quot;&gt; &lt;code&gt;Mail::Sendmail&lt;/code&gt; &lt;/a&gt; 은 단순하고 플랫폼에 독립적 인 메일 링을 제공하는 독립형 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1aa28f8ff665fed944de016ad1db63136902800f" translate="yes" xml:space="preserve">
          <source>This is fine for systems programming when sendmail is known to be available. But it is not fine for many non-Unix systems, and even some Unix systems that may not have sendmail installed. If a portable solution is needed, see the various distributions on CPAN that deal with it. &lt;code&gt;Mail::Mailer&lt;/code&gt; and &lt;code&gt;Mail::Send&lt;/code&gt; in the &lt;code&gt;MailTools&lt;/code&gt; distribution are commonly used, and provide several mailing methods, including &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; , and direct SMTP (via &lt;code&gt;Net::SMTP&lt;/code&gt; ) if a mail transfer agent is not available. &lt;code&gt;Mail::Sendmail&lt;/code&gt; is a standalone module that provides simple, platform-independent mailing.</source>
          <target state="translated">sendmail을 사용할 수있는 경우 시스템 프로그래밍에 적합합니다. 그러나 많은 비 유닉스 시스템, 심지어 sendmail이 설치되지 않은 일부 유닉스 시스템에는 적합하지 않습니다. 휴대용 솔루션이 필요한 경우 CPAN의 다양한 배포판을 참조하십시오. &lt;code&gt;MailTools&lt;/code&gt; 배포 에서 &lt;code&gt;Mail::Mailer&lt;/code&gt; 및 &lt;code&gt;Mail::Send&lt;/code&gt; 가 일반적으로 사용되며, 메일 전송 에이전트를 사용할 수없는 경우 &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; 및 Direct SMTP ( &lt;code&gt;Net::SMTP&lt;/code&gt; ) 를 포함한 여러 가지 메일 방법을 제공 합니다. &lt;code&gt;Mail::Sendmail&lt;/code&gt; 은 플랫폼 독립적 인 간단한 메일 링을 제공하는 독립형 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="3aabced6833bcc3911383da0e252138fb5ec6985" translate="yes" xml:space="preserve">
          <source>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; won't work. What you can do is wrap a while() loop around a global pattern match. For example, let's count negative integers:</source>
          <target state="translated">단일 문자를 찾고 있다면 괜찮습니다. 그러나 더 큰 문자열 내에서 여러 문자 하위 문자열을 계산하려고하면 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 가 작동하지 않습니다. 전역 패턴 일치에 while () 루프를 래핑하는 것이 가능합니다. 예를 들어, 음의 정수를 세어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="03d778e077bb45a64c448d2b3e047900fa7a45f9" translate="yes" xml:space="preserve">
          <source>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, &lt;code&gt;tr///&lt;/code&gt; won't work. What you can do is wrap a while() loop around a global pattern match. For example, let's count negative integers:</source>
          <target state="translated">단일 캐릭터를 찾고 있다면 괜찮습니다. 그러나 더 큰 문자열 내에서 여러 문자 하위 문자열을 계산하려는 경우 &lt;code&gt;tr///&lt;/code&gt; 가 작동하지 않습니다. 당신이 할 수있는 일은 전역 패턴 일치를 둘러싸는 while () 루프를 감싸는 것입니다. 예를 들어 음의 정수를 세어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fe90dbc3c5695d7e2fdf0f285c383fc23541d231" translate="yes" xml:space="preserve">
          <source>This is for Test2 API and related packages.</source>
          <target state="translated">이것은 Test2 API 및 관련 패키지 용입니다.</target>
        </trans-unit>
        <trans-unit id="9cfd669832389228af06dec1239a8521733d9cc4" translate="yes" xml:space="preserve">
          <source>This is for backwards compatibility, and may be deprecated in the future.</source>
          <target state="translated">이는 이전 버전과의 호환성을위한 것으로 향후 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1feb67b0818a9b1deb572f5e23a9f9edab3c53" translate="yes" xml:space="preserve">
          <source>This is for clustering, not capturing; it groups subexpressions like &quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does. So</source>
          <target state="translated">이는 캡처가 아니라 클러스터링을위한 것입니다. 하위 표현식을 &quot;()&quot;과 같이 그룹화하지만 &quot;()&quot;과 같이 역 참조를하지 않습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="04947ad410e88320dbe79a5cb81a4af421f2255b" translate="yes" xml:space="preserve">
          <source>This is for clustering, not capturing; it groups subexpressions like &lt;code&gt;&quot;()&quot;&lt;/code&gt;, but doesn't make backreferences as &lt;code&gt;&quot;()&quot;&lt;/code&gt; does. So</source>
          <target state="translated">이것은 캡처가 아닌 클러스터링을위한 것입니다. 그것과 같은 그룹 표현식 &lt;code&gt;&quot;()&quot;&lt;/code&gt; ,하지만 같은 역 참조를하지 않습니다 &lt;code&gt;&quot;()&quot;&lt;/code&gt; 한다. 그래서</target>
        </trans-unit>
        <trans-unit id="fd0c739b12ea8f303fae64c2fc3f585b7a17c56e" translate="yes" xml:space="preserve">
          <source>This is for heuristics which attempt to create directory structures that mirror those of the installed perl.</source>
          <target state="translated">이것은 설치된 perl의 구조를 반영하는 디렉토리 구조를 작성하려는 휴리스틱을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8b7de1b28f0c9aa17d5f75d5f2141f8c81f40ef" translate="yes" xml:space="preserve">
          <source>This is for unsigned integers. It is equivalent to using T_UV but explicitly casts the variable to type &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; . The default type for &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 정수를위한 것입니다. T_UV를 사용하는 것과 동일하지만 변수를 &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형으로 명시 적으로 캐스팅합니다 . &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; 의 기본 유형 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="5749c6a5070ee50c1f99db6f471f9cdfac379662" translate="yes" xml:space="preserve">
          <source>This is for unsigned integers. It is equivalent to using T_UV but explicitly casts the variable to type &lt;code&gt;unsigned int&lt;/code&gt;. The default type for &lt;code&gt;unsigned int&lt;/code&gt; is T_UV.</source>
          <target state="translated">이것은 부호없는 정수를위한 것입니다. T_UV를 사용하는 것과 동일하지만 변수를 &lt;code&gt;unsigned int&lt;/code&gt; 유형으로 명시 적으로 캐스팅합니다 . &lt;code&gt;unsigned int&lt;/code&gt; 의 기본 유형 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="04f20cedd41a4e00c24f8fc66e090f062e1c8652" translate="yes" xml:space="preserve">
          <source>This is free software. You may modify and/or redistribute this code under the same terms as Perl 5.10 itself, or, at your option, any later version of Perl 5.</source>
          <target state="translated">이것은 무료 소프트웨어입니다. 이 코드는 Perl 5.10 자체와 동일한 조건으로 수정 및 / 또는 재배포 할 수 있으며, 선택에 따라 Perl 5의 이후 버전을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223ca8fc8e06498b8700fcaf3a5b924a9287e801" translate="yes" xml:space="preserve">
          <source>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</source>
          <target state="translated">이것은 무료 소프트웨어입니다. Perl 5 프로그래밍 언어 시스템 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b876192e43b0c3f007bf98e622b2f335f00b0f03" translate="yes" xml:space="preserve">
          <source>This is functionally identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function for suspending the execution of the current for process for certain number of seconds, see &lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;. There is one significant difference, however: &lt;code&gt;POSIX::sleep()&lt;/code&gt; returns the number of &lt;b&gt;unslept&lt;/b&gt; seconds, while the &lt;code&gt;CORE::sleep()&lt;/code&gt; returns the number of slept seconds.</source>
          <target state="translated">이것은 특정 시간 (초) 동안 프로세스에 대한 전류 실행을 일시 중단하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 함수와 기능적으로 동일합니다 (&lt;a href=&quot;functions/sleep&quot;&gt; sleep&lt;/a&gt; 참조) . 그러나 한 가지 중요한 차이점이 있습니다. &lt;code&gt;POSIX::sleep()&lt;/code&gt; 은 &lt;b&gt;잠자 지 않은&lt;/b&gt; 초 수를 반환 하지만 &lt;code&gt;CORE::sleep()&lt;/code&gt; 반환하고 은 잠은 시간 (초 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bbf2660e26252d7fe7043cdc5fb90594bfb18a79" translate="yes" xml:space="preserve">
          <source>This is functionally identical to Perl's builtin &lt;code&gt;sleep()&lt;/code&gt; function for suspending the execution of the current for process for certain number of seconds, see &lt;a href=&quot;perlfunc#sleep&quot;&gt;&quot;sleep&quot; in perlfunc&lt;/a&gt;. There is one significant difference, however: &lt;code&gt;POSIX::sleep()&lt;/code&gt; returns the number of &lt;b&gt;unslept&lt;/b&gt; seconds, while the &lt;code&gt;CORE::sleep()&lt;/code&gt; returns the number of slept seconds.</source>
          <target state="translated">이것은 기능적으로 Perl의 내장 &lt;code&gt;sleep()&lt;/code&gt; 함수와 동일합니다. 특정 시간 동안 프로세스에 대한 현재 실행을 일시 중단하는 것 입니다. &lt;a href=&quot;perlfunc#sleep&quot;&gt;perlfunc의 &quot;sleep&quot;을&lt;/a&gt; 참조하십시오 . 그러나 한 가지 중요한 차이점이 있습니다. &lt;code&gt;POSIX::sleep()&lt;/code&gt; 은 &lt;b&gt;잠들지 않은&lt;/b&gt; 초 수를 반환 하고 &lt;code&gt;CORE::sleep()&lt;/code&gt; 는 잠자기 초 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fb4b681258fa0233585a271cede9e357d7bbce9" translate="yes" xml:space="preserve">
          <source>This is generally meant to be called from inside Bracket Notation (which is discussed later), as in</source>
          <target state="translated">이것은 일반적으로 다음과 같이 브라켓 표기법 (나중에 설명 함)에서 호출하도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="487a457dae8e51eb07ff40b59ced8f82c47ea01f" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, but large testing systems often have weird internal needs.</source>
          <target state="translated">이것은 일반적으로 권장되지 않지만 대규모 테스트 시스템에는 종종 내부 요구가 이상합니다.</target>
        </trans-unit>
        <trans-unit id="abeb233860c7acca6119cb787cba71a4bde24872" translate="yes" xml:space="preserve">
          <source>This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid shocking the &lt;b&gt;sed&lt;/b&gt; addicts, but it's a dirty habit to get into. That's because in PerlThink, the righthand side of an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; is a double-quoted string. &lt;code&gt;\1&lt;/code&gt; in the usual double-quoted string means a control-A. The customary Unix meaning of &lt;code&gt;\1&lt;/code&gt; is kludged in for &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;. However, if you get into the habit of doing that, you get yourself into trouble if you then add an &lt;code&gt;/e&lt;/code&gt; modifier.</source>
          <target state="translated">이것은 &lt;b&gt;sed&lt;/b&gt; 중독자를 충격을 피하기 위해 RHS를 대체하기 위해 할아버지 (1 ~ 9 인) 이지만, 들어가는 것은 더러운 습관입니다. PerlThink에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 오른쪽 이 큰 따옴표로 묶인 문자열 이기 때문입니다 . 일반적인 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\1&lt;/code&gt; 은 control-A를 의미합니다. &lt;code&gt;\1&lt;/code&gt; 의 관습적인 유닉스 의미는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 에 대해 잘 알려져 있습니다. 그러나 그렇게하는 습관을들이는 경우, &lt;code&gt;/e&lt;/code&gt; 수정자를 추가하면 문제가 생길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f03f0363c9fb43987481968ea231e7a1a5d22aaa" translate="yes" xml:space="preserve">
          <source>This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid shocking the &lt;b&gt;sed&lt;/b&gt; addicts, but it's a dirty habit to get into. That's because in PerlThink, the righthand side of an &lt;code&gt;s///&lt;/code&gt; is a double-quoted string. &lt;code&gt;\1&lt;/code&gt; in the usual double-quoted string means a control-A. The customary Unix meaning of &lt;code&gt;\1&lt;/code&gt; is kludged in for &lt;code&gt;s///&lt;/code&gt;. However, if you get into the habit of doing that, you get yourself into trouble if you then add an &lt;code&gt;/e&lt;/code&gt; modifier.</source>
          <target state="translated">이것은 &lt;b&gt;sed&lt;/b&gt; 중독자들 에게 충격을주지 않기 위해 대용품의 RHS에 대해 할아버지 (1 ~ 9 엔) 이지만 들어가는 것은 더러운 버릇입니다. PerlThink에서 &lt;code&gt;s///&lt;/code&gt; 의 오른쪽 은 큰 따옴표로 묶인 문자열 이기 때문입니다 . 일반적인 큰 따옴표 문자열에서 &lt;code&gt;\1&lt;/code&gt; 은 control-A를 의미합니다. &lt;code&gt;\1&lt;/code&gt; 의 관습적인 유닉스 의미는 &lt;code&gt;s///&lt;/code&gt; 에 대해 kludged in for s /// 입니다. 그러나 그렇게하는 습관이 생기면 &lt;code&gt;/e&lt;/code&gt; 수정자를 추가하면 문제가 생깁니다.</target>
        </trans-unit>
        <trans-unit id="2b17cc705ed9e94610433e56fe234d47d65c2826" translate="yes" xml:space="preserve">
          <source>This is handy for output formats that don't have anything quite like an &quot;S&amp;lt;...&amp;gt;&quot; code, but which do have a code for non-breaking space.</source>
          <target state="translated">이것은 &quot;S &amp;lt;...&amp;gt;&quot;코드와 같은 것은 없지만 비 분리 공백을위한 코드가있는 출력 형식에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a33e8e516c4662a8793090c4f24cce78089ad98d" translate="yes" xml:space="preserve">
          <source>This is handy when you want to do a list assignment in a Boolean context, because most list functions return a null list when finished, which when assigned produces a 0, which is interpreted as FALSE.</source>
          <target state="translated">부울 컨텍스트에서 목록 할당을 수행하려고 할 때 편리합니다. 대부분의 목록 함수는 완료되면 null 목록을 반환하므로 할당되면 0을 생성하므로 FALSE로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="260dc37b9db5709300e390ddfe39e24b64c85308" translate="yes" xml:space="preserve">
          <source>This is here for backwards compatibility only</source>
          <target state="translated">이것은 이전 버전과의 호환성을 위해서만 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2cfb1906a45c414c7c96fc609271f7955af896" translate="yes" xml:space="preserve">
          <source>This is how it works now:</source>
          <target state="translated">이것이 지금 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="57a7770321f001633ec82b62ab1060f627617660" translate="yes" xml:space="preserve">
          <source>This is how you add a global init callback. Global callbacks happen for every context for any hub or stack.</source>
          <target state="translated">이것이 글로벌 초기화 콜백을 추가하는 방법입니다. 전역 콜백은 모든 허브 또는 스택의 모든 컨텍스트에 대해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d5549f5f96f9ae515ac59159e1ec8e9b00ca6c3" translate="yes" xml:space="preserve">
          <source>This is how you add a global release callback. Global callbacks happen for every context for any hub or stack.</source>
          <target state="translated">이것이 글로벌 릴리스 콜백을 추가하는 방법입니다. 전역 콜백은 모든 허브 또는 스택의 모든 컨텍스트에 대해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b14ec31d0ca231ad81e0d297fc944474a8c2ffd" translate="yes" xml:space="preserve">
          <source>This is how you add a release callback for all contexts created for a given hub. These callbacks will not run for other hubs.</source>
          <target state="translated">이것은 주어진 허브에 대해 생성 된 모든 컨텍스트에 대한 릴리스 콜백을 추가하는 방법입니다. 이러한 콜백은 다른 허브에 대해서는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28bd6a385ed391a50e1e6dfd6905efadad76fde5" translate="yes" xml:space="preserve">
          <source>This is how you add an init callback for all contexts created for a given hub. These callbacks will not run for other hubs.</source>
          <target state="translated">이것은 주어진 허브에 대해 생성 된 모든 컨텍스트에 대해 초기화 콜백을 추가하는 방법입니다. 이러한 콜백은 다른 허브에 대해서는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="571f913a0d93b0bc29621a81946f5e000acc80d1" translate="yes" xml:space="preserve">
          <source>This is how you add release callbacks directly to a context. The callback will &lt;b&gt;ALWAYS&lt;/b&gt; be added to the context that gets returned, it does not matter if a new one is generated, or if an existing one is returned.</source>
          <target state="translated">컨텍스트에 릴리스 콜백을 직접 추가하는 방법입니다. 콜백은 반환되는 컨텍스트에 &lt;b&gt;항상&lt;/b&gt; 추가 됩니다. 새 콜백 이 생성되었는지 또는 기존 콜백이 반환되었는지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05b45755b9a2299dd81f964dd03d663b8bf8ee2f" translate="yes" xml:space="preserve">
          <source>This is how you specify an init hook that will only run if your call to &lt;code&gt;context()&lt;/code&gt; generates a new context. The callback will be ignored if &lt;code&gt;context()&lt;/code&gt; is returning an existing context.</source>
          <target state="translated">이것이 &lt;code&gt;context()&lt;/code&gt; 호출 이 새 컨텍스트를 생성하는 경우에만 실행되는 init 후크를 지정하는 방법 입니다. &lt;code&gt;context()&lt;/code&gt; 가 기존 컨텍스트를 반환 하면 콜백이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dbdb31e7c27bacbcb7fe1d4ef14ea6d653940f1" translate="yes" xml:space="preserve">
          <source>This is identical in operation to directories(), except that it includes all the intermediate directories back up to the specified directories.</source>
          <target state="translated">이는 지정된 디렉토리로 백업 된 모든 중간 디렉토리를 포함한다는 점을 제외하고는 directory ()와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e351930a2f0204ac9b6b12368a795bebdda09c11" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function for returning the absolute value of the numerical argument, see &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;.</source>
          <target state="translated">이 펄의 내장에 동일 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 수치 인수의 절대치를 반환하는 함수, 참조 &lt;a href=&quot;functions/abs&quot;&gt;복근&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="695d548bdbb7db69858dd0c63a58915988364e1a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function, returning the absolute value of its numerical argument.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 동일합니다 함수와 하며 숫자 인수의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9120a2adefbe5ba2e37ba001760405e7d0a7dbe" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, either for arming or disarming the &lt;code&gt;SIGARLM&lt;/code&gt; timer.</source>
          <target state="translated">이는 &lt;code&gt;SIGARLM&lt;/code&gt; 의 무장 해제를위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다. 타이머 합니다.</target>
        </trans-unit>
        <trans-unit id="48a476413067dd99ab4121abaa36c23eb2d9f153" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; function, returning the arcus tangent defined by its two numerical arguments, the</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 함수와 동일 하며 두 개의 숫자 인수로 정의 된 아크 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a05756bd65e3a6ef14f82f8385fe7e460811d0b5" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; function, allowing one to change the working (default) directory, see &lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일하며 , 작동하는 (기본) 디렉토리를 변경할 수 있습니다 ( &lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e888ff11c427adcd230a49c55dda839ea4139d83" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory permissions, see &lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; 함수와 동일하므로 파일 및 디렉토리 권한을 변경할 수 있습니다 ( &lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="43527baa97f98b6bb9f0a7d166453b7ea32ff963" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory owners and groups, see &lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 함수와 동일하므로 파일 및 디렉토리 소유자 및 그룹을 변경할 수 있습니다 ( &lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="137a34ed8adb7ab17d656d13fbf0961186414eb0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; function for closing a directory handle, see &lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;.</source>
          <target state="translated">이것은 펄의 내장의 동일 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; 디렉토리 핸들을 닫는 기능을 참조 &lt;a href=&quot;functions/closedir&quot;&gt;closedir을&lt;/a&gt; . .</target>
        </trans-unit>
        <trans-unit id="e039818d97c69012826d73ac04fb7fe2694eb5b3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; function, for returning the cosine of its numerical argument, see &lt;a href=&quot;functions/cos&quot;&gt;cos&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이는 숫자 인수의 코사인을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/cos&quot;&gt;cos를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7986353e4fd90f34533ad5983c9c0772e03e142" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function for exiting the program, see &lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;.</source>
          <target state="translated">이것은 프로그램을 종료하기위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/exit&quot;&gt;exit를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2c5c838eac2ca99b87036128b4be02041ba664e" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; function for returning the exponent (</source>
          <target state="translated">이것은 지수를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f8afa6cc9b9bce42a0f876c4312c43a9b501d34" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/fcntl&quot;&gt; fcntl&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="0526f440f4487b3f67fbf7e27396c04e1d2573cc" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; function for duplicating the current process, see &lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt; and &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; if you are in Windows.</source>
          <target state="translated">이것은 현재 프로세스를 복제하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;a href=&quot;perlfork&quot;&gt;동일합니다. &lt;/a&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt; 및 perlfork를 참조하십시오. 합니다. Windows에있는 경우 .</target>
        </trans-unit>
        <trans-unit id="f40ae5570bc527bc5a1dd6d93c31c6aa0f593934" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getc&quot;&gt; getc&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="35d7514c028c77e7ca42538761981fea1a5e7fde" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group identifiers, see &lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;.</source>
          <target state="translated">이는 그룹 식별자로 그룹 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getgrgid&quot;&gt; getgrgid&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="60e26e2d8720ed0149b7b87c377d73417035968a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group names, see &lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;.</source>
          <target state="translated">이는 그룹 이름으로 그룹 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getgrnam&quot;&gt; getgrnam&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="d15624acd39757d16036f7262ed6bcece3061f3a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; function for returning the user name associated with the current session, see &lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 세션과 연관된 사용자 이름을 리턴하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다. &lt;a href=&quot;functions/getlogin&quot;&gt;getlogin을&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="186fcd1d3a57037edb361be5db32f5f007ca9211" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; function for returning the process group identifier of the current process, see &lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 프로세스 그룹 식별자를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getpgrp&quot;&gt; getpgrp&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e1809496150480256c93f1aafd87f931437ce086" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; function for returning the process identifier of the parent process of the current process , see &lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 부모 프로세스의 프로세스 식별자를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getppid&quot;&gt; getppid&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="457ce51591f9cb379a5adb26605bff1ac3f4ef40" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user names, see &lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;.</source>
          <target state="translated">이는 사용자 이름으로 사용자 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getpwnam&quot;&gt; getpwnam&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="099bdffd8de12dde36332facd7fd521fe7604dc8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user identifiers, see &lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;.</source>
          <target state="translated">이 펄 내장 된 동일 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; 사용자에 의해 사용자 식별자 항목을 리턴하는 함수, 참조 &lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f87263d58fd06391e632ecc597293fca726096" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date in Greenwich Mean Time, see &lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;.</source>
          <target state="translated">이것은 신기원 이후의 초를 그리니치 표준시의 날짜로 변환 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/gmtime&quot;&gt; gmtime&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f3c0f6e328c0a9e84f4089fb4367baf98b6b1c72" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/index&quot;&gt; index&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="b121ee200825f5ba836e4ff9ea046596d9a0669c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function for sending signals to processes (often to terminate them), see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;.</source>
          <target state="translated">이것은 프로세스에 신호를 보내는 (종종 종료하는) Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다 ( &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b81f62db22691a94ae2b3fa4ba9674d2bf0b3fd0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; function for creating hard links into files, see &lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">이것은 파일에 하드 링크를 만드는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/link&quot;&gt; link&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="44d5f3c7d27301e5eb1acf76c204cabece604701" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date see &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장과 동일합니다 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; epoch 이후의 초를 날짜로 변환 localtime () 함수와.&lt;a href=&quot;functions/localtime&quot;&gt; localtime&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e0909781f3283ef9c3e20db724f85b91f439d90" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; function, returning the natural (</source>
          <target state="translated">이것은 Perl의 내장과 동일합니다 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; 함수와, 자연 (</target>
        </trans-unit>
        <trans-unit id="e971f99436b45984924e279dba0a0153fd2a323c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; function for creating directories, see &lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; 과 동일합니다 디렉토리 작성을위한 함수와&lt;a href=&quot;functions/mkdir&quot;&gt; mkdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b41549ebc9ad587ccb819b0a3ec0f8792362c7d3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; function for reading directory entries, see &lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 과 동일합니다 디렉토리 항목을 읽는 함수와&lt;a href=&quot;functions/readdir&quot;&gt; readdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="35438e0216a544df5038b4544cbb587885a54611" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; function for renaming files, see &lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 과 동일합니다. 파일 이름 바꾸기를위한 함수와 . &lt;a href=&quot;functions/rename&quot;&gt;rename을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d513c94dc874928c142ca043089cff6c9b7ef0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; function for rewinding directory entry streams, see &lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 과 동일합니다. 디렉토리 엔트리 스트림을 되감기위한 기능을 참조 &lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb204757196695331f28a45173a4730e85e7f0fb" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; function for removing (empty) directories, see &lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;.</source>
          <target state="translated">이것은 (빈) 디렉토리를 제거하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/rmdir&quot;&gt; rmdir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d85ea0b853465bcc33fe450ea49c14a87d8b77" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; function for returning the sine of the numerical argument, see &lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 사인을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt; 참조하십시오 . 또한보십시오&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="919e7a21c6ecbb020823d058dd90c7b0a9eb3a55" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; function. for returning the square root of the numerical argument, see &lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다. 숫자 인수의 제곱근을 반환하려면&lt;a href=&quot;functions/sqrt&quot;&gt; sqrt를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0eaf8f167427908f7febf3b312f3b5eb7b5e1919" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; function for returning information about files and directories.</source>
          <target state="translated">이것은 Perl의 내장과 동일합니다 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 파일과 디렉토리에 대한 정보를 반환 stat () 함수와.</target>
        </trans-unit>
        <trans-unit id="41d6fd8cbb0b29357e5142e667be5a61001f2978" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/system&quot;&gt; system&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3273b4b3b0615a180eb23eebf260bd07416587ce" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function for returning the number of seconds since the epoch (whatever it is for the system), see &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">이것은 epoch 이후의 초 수를 리턴하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (시스템에 관계없이).&lt;a href=&quot;functions/time&quot;&gt;&lt;/a&gt; . time .</target>
        </trans-unit>
        <trans-unit id="c38ab013e5c6afb6168a48634dc91f08bf30d4f9" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; function for setting (and querying) the file creation permission mask, see &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 생성 권한 마스크를 설정하고 쿼리 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/umask&quot;&gt; umask&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88df1d410534e354bba714dca11791a1312464a8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; function for removing files, see &lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;.</source>
          <target state="translated">이것은 파일을 제거하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/unlink&quot;&gt; unlink&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb3ad24016b3eaa5941feee2fcd750ab1532552" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; function for changing the time stamps of files and directories, see &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;.</source>
          <target state="translated">이것은 파일과 디렉토리의 타임 스탬프를 변경하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/utime&quot;&gt; utime&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c58755bc175c3890516b5d42561515cbd4c528" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.&lt;a href=&quot;functions/wait&quot;&gt;&lt;/a&gt; . wait .</target>
        </trans-unit>
        <trans-unit id="f13c2b63ac14ab4bd5f10ae515b06359ca5e4d21" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;abs()&lt;/code&gt; function for returning the absolute value of the numerical argument, see &lt;a href=&quot;perlfunc#abs&quot;&gt;&quot;abs&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 절대 값을 반환하는 Perl의 내장 &lt;code&gt;abs()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#abs&quot;&gt;perlfunc의 &quot;abs&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeba6e922a9db20d2f88f41c166aa3a545a6731a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;abs()&lt;/code&gt; function, returning the absolute value of its numerical argument (except that &lt;code&gt;POSIX::abs()&lt;/code&gt; must be provided an explicit value (rather than relying on an implicit &lt;code&gt;$_&lt;/code&gt;):</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;abs()&lt;/code&gt; 함수와 동일하며 , 숫자 인수의 절대 값을 반환합니다 ( &lt;code&gt;POSIX::abs()&lt;/code&gt; 에 명시 적 값을 제공해야 한다는 점을 제외하고 (암시 적 &lt;code&gt;$_&lt;/code&gt; 에 의존하지 않음)) :</target>
        </trans-unit>
        <trans-unit id="d9272bd8809bf23877d5d262cbbf69c42040e282" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;alarm()&lt;/code&gt; function, either for arming or disarming the &lt;code&gt;SIGARLM&lt;/code&gt; timer, except that &lt;code&gt;POSIX::alarm()&lt;/code&gt; must be provided an explicit value (rather than relying on an implicit &lt;code&gt;$_&lt;/code&gt;):</source>
          <target state="translated">이것은 &lt;code&gt;POSIX::alarm()&lt;/code&gt; 에 명시 적 값을 제공해야 한다는 점을 제외하고 는 &lt;code&gt;SIGARLM&lt;/code&gt; 타이머 를 준비하거나 해제하는 Perl의 내장 &lt;code&gt;alarm()&lt;/code&gt; 함수와 동일합니다 (암시 적 &lt;code&gt;$_&lt;/code&gt; 에 의존하는 대신 ) :</target>
        </trans-unit>
        <trans-unit id="1d3051de63b274bf89d617977e27b1e44500fb09" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;atan2()&lt;/code&gt; function, returning the arcus tangent defined by its two numerical arguments, the</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;atan2()&lt;/code&gt; 함수와 동일하며 , 두 개의 숫자 인수로 정의 된 arcus tangent를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e1ff0f865c69120ee10570db31d0b1d2c0c062f" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;chdir()&lt;/code&gt; function, allowing one to change the working (default) directory -- see &lt;a href=&quot;perlfunc#chdir&quot;&gt;&quot;chdir&quot; in perlfunc&lt;/a&gt; -- with the exception that &lt;code&gt;POSIX::chdir()&lt;/code&gt; must be provided an explicit value (rather than relying on an implicit &lt;code&gt;$_&lt;/code&gt;):</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;chdir()&lt;/code&gt; 함수와 동일하므로 작업 (기본) 디렉토리 ( &lt;a href=&quot;perlfunc#chdir&quot;&gt;perlfunc의 &quot;chdir&quot;&lt;/a&gt; 참조)를 변경할 수 있습니다 . 단, &lt;code&gt;POSIX::chdir()&lt;/code&gt; 에는 명시 적 값이 제공되어야합니다. 암시 적 &lt;code&gt;$_&lt;/code&gt; 의존 ) :</target>
        </trans-unit>
        <trans-unit id="f676f007cd841319686436bdb4f53d41b3e4ebac" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;chmod()&lt;/code&gt; function, allowing one to change file and directory permissions -- see &lt;a href=&quot;perlfunc#chmod&quot;&gt;&quot;chmod&quot; in perlfunc&lt;/a&gt; -- with the exception that &lt;code&gt;POSIX::chmod()&lt;/code&gt; can only change one file at a time (rather than a list of files):</source>
          <target state="translated">이는 펄의 내장의 동일 &lt;code&gt;chmod()&lt;/code&gt; 변경 파일 및 디렉토리 권한을 허용 기능 - 볼 &lt;a href=&quot;perlfunc#chmod&quot;&gt;을 perlfunc에서 &quot;chmod를&quot;을&lt;/a&gt; 것을 제외 - &lt;code&gt;POSIX::chmod()&lt;/code&gt; 한 번에 하나 개의 파일을 변경할 수 있습니다 (이 아니라 파일 목록) :</target>
        </trans-unit>
        <trans-unit id="041ab8f9027b39ef8749ecf23de9f449349be363" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;chown()&lt;/code&gt; function, allowing one to change file and directory owners and groups, see &lt;a href=&quot;perlfunc#chown&quot;&gt;&quot;chown&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;chown()&lt;/code&gt; 함수와 동일하여 파일 및 디렉토리 소유자 및 그룹을 변경할 수 있습니다 . &lt;a href=&quot;perlfunc#chown&quot;&gt;perlfunc의 &quot;chown&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61f95aa5daddf7fe2d2d73fca7e7d94eeb6c29f6" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;closedir()&lt;/code&gt; function for closing a directory handle, see &lt;a href=&quot;perlfunc#closedir&quot;&gt;&quot;closedir&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 핸들을 닫기위한 Perl의 내장 &lt;code&gt;closedir()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#closedir&quot;&gt;perlfunc의 &quot;closedir&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0812d720d3d8b9aac1e21c57a80f20bcf2f9c3ab" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;cos()&lt;/code&gt; function, for returning the cosine of its numerical argument, see &lt;a href=&quot;perlfunc#cos&quot;&gt;&quot;cos&quot; in perlfunc&lt;/a&gt;. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;cos()&lt;/code&gt; 함수와 동일합니다. 숫자 인수의 코사인을 반환하려면 &lt;a href=&quot;perlfunc#cos&quot;&gt;perlfunc의 &quot;cos&quot;를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6faa18c6cf2e2bdf15486fb7413251a6c95a308" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;exit()&lt;/code&gt; function for exiting the program, see &lt;a href=&quot;perlfunc#exit&quot;&gt;&quot;exit&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 프로그램을 종료하기위한 Perl의 내장 &lt;code&gt;exit()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#exit&quot;&gt;perlfunc의 &quot;exit&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a090250e226891fdf51f2235b04607999ab01e5b" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;exp()&lt;/code&gt; function for returning the exponent (</source>
          <target state="translated">이 펄 내장 된 동일 &lt;code&gt;exp()&lt;/code&gt; (지수를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="586ed7b1cf8385f5f84201e041a4c9b38b7cf920" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;fcntl()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#fcntl&quot;&gt;&quot;fcntl&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;fcntl()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#fcntl&quot;&gt;perlfunc의 &quot;fcntl&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59914e126bdf7d613799ed2b869017e992d88d81" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;fork()&lt;/code&gt; function for duplicating the current process, see &lt;a href=&quot;perlfunc#fork&quot;&gt;&quot;fork&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; if you are in Windows.</source>
          <target state="translated">이것은 현재 프로세스를 복제하기위한 Perl의 내장 &lt;code&gt;fork()&lt;/code&gt; 함수 와 &lt;a href=&quot;perlfork&quot;&gt;동일&lt;/a&gt; 합니다. Windows &lt;a href=&quot;perlfunc#fork&quot;&gt;에서는 perlfunc&lt;/a&gt; 및 perlfork의 &quot;fork&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2bcde2f841642aa747906d112793663d02a4ef4" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getc()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;getc()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getc&quot;&gt;perlfunc의 &quot;getc&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf81bd9cceb40440442cab792009031a27722e2d" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getgrgid()&lt;/code&gt; function for returning group entries by group identifiers, see &lt;a href=&quot;perlfunc#getgrgid&quot;&gt;&quot;getgrgid&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 그룹 식별자로 그룹 항목을 반환 하는 Perl의 내장 &lt;code&gt;getgrgid()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getgrgid&quot;&gt;perlfunc의 &quot;getgrgid&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f12c9c925dd97923ec1ba9d2494d7e7cc8c09b5" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getgrnam()&lt;/code&gt; function for returning group entries by group names, see &lt;a href=&quot;perlfunc#getgrnam&quot;&gt;&quot;getgrnam&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 그룹 이름으로 그룹 항목을 반환 하는 Perl의 내장 &lt;code&gt;getgrnam()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getgrnam&quot;&gt;perlfunc의 &quot;getgrnam&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="061d771b45fe6fdb91ab663f301fc5a4200fb6c2" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getlogin()&lt;/code&gt; function for returning the user name associated with the current session, see &lt;a href=&quot;perlfunc#getlogin&quot;&gt;&quot;getlogin&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 세션과 관련된 사용자 이름을 반환하는 Perl의 내장 &lt;code&gt;getlogin()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getlogin&quot;&gt;perlfunc의 &quot;getlogin&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b6c96531c8f8c469ecd59a4d48093daaf34500a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getpgrp()&lt;/code&gt; function for returning the process group identifier of the current process, see &lt;a href=&quot;perlfunc#getpgrp&quot;&gt;&quot;getpgrp&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 프로세스 그룹 식별자를 반환하는 Perl의 내장 &lt;code&gt;getpgrp()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getpgrp&quot;&gt;perlfunc의 &quot;getpgrp&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdbc6cb1c29cf9bd86eed81cc69e1c840c81478c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getppid()&lt;/code&gt; function for returning the process identifier of the parent process of the current process , see &lt;a href=&quot;perlfunc#getppid&quot;&gt;&quot;getppid&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 부모 프로세스의 프로세스 식별자를 반환하는 Perl의 내장 &lt;code&gt;getppid()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getppid&quot;&gt;perlfunc의 &quot;getppid&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b56bed142f19ad2080bf45ae8481e1ee1fb488e1" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getpwnam()&lt;/code&gt; function for returning user entries by user names, see &lt;a href=&quot;perlfunc#getpwnam&quot;&gt;&quot;getpwnam&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 사용자 이름으로 사용자 항목을 반환 하는 Perl의 내장 &lt;code&gt;getpwnam()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getpwnam&quot;&gt;perlfunc의 &quot;getpwnam&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1acc60524b9abec089e2c6f8c95b08eb6714a8db" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;getpwuid()&lt;/code&gt; function for returning user entries by user identifiers, see &lt;a href=&quot;perlfunc#getpwuid&quot;&gt;&quot;getpwuid&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 사용자 식별자로 사용자 항목을 반환 하는 Perl의 내장 &lt;code&gt;getpwuid()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#getpwuid&quot;&gt;perlfunc의 &quot;getpwuid&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="179770df8af708d05f10bcd98500a9e7e79703eb" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;gmtime()&lt;/code&gt; function for converting seconds since the epoch to a date in Greenwich Mean Time, see &lt;a href=&quot;perlfunc#gmtime&quot;&gt;&quot;gmtime&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 epoch 이후의 초를 그리니치 표준시의 날짜로 변환 하는 Perl의 내장 &lt;code&gt;gmtime()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#gmtime&quot;&gt;perlfunc의 &quot;gmtime&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a268d454fa73c16bee33c404cb94d081cc9c3644" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;index()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#index&quot;&gt;&quot;index&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;index()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#index&quot;&gt;perlfunc의 &quot;index&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dc3cee015e8a57d47d2c57b6b03b7fdf0cfd74c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;kill()&lt;/code&gt; function for sending signals to processes (often to terminate them), see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 신호를 프로세스에 보내는 (종종 그들을 종료하기 위해 &lt;code&gt;kill()&lt;/code&gt; Perl의 내장 kill () 함수와 동일합니다 . &lt;a href=&quot;perlfunc#kill&quot;&gt;perlfunc의 &quot;kill&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed0e4e90b9f46713a350fa47e616a04d2e30537a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;link()&lt;/code&gt; function for creating hard links into files, see &lt;a href=&quot;perlfunc#link&quot;&gt;&quot;link&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 파일에 대한 하드 링크를 생성하기위한 Perl의 내장 &lt;code&gt;link()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#link&quot;&gt;perlfunc의 &quot;link&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e011fd93298aca0de0c1a897aa121a02b4277007" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;localtime()&lt;/code&gt; function for converting seconds since the epoch to a date see &lt;a href=&quot;perlfunc#localtime&quot;&gt;&quot;localtime&quot; in perlfunc&lt;/a&gt; except that &lt;code&gt;POSIX::localtime()&lt;/code&gt; must be provided an explicit value (rather than relying on an implicit &lt;code&gt;$_&lt;/code&gt;):</source>
          <target state="translated">이는 펄의 내장의 동일 &lt;code&gt;localtime()&lt;/code&gt; 를 참조 날짜로 신기원부터 초를 변환하는 기능 &lt;a href=&quot;perlfunc#localtime&quot;&gt;을 perlfunc에 &quot;의 현지&quot;를&lt;/a&gt; 제외하고 &lt;code&gt;POSIX::localtime()&lt;/code&gt; (오히려 암시에 의존하는 것보다 명시 적 값을 제공해야합니다 &lt;code&gt;$_&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="5a2226cccc38cb9670469353b71c92d291f37e36" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;log()&lt;/code&gt; function, returning the natural (</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;log()&lt;/code&gt; 함수와 동일 하며 자연 (</target>
        </trans-unit>
        <trans-unit id="eaa3dae63b59e4b6788fcb579b64e550147a8385" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;mkdir()&lt;/code&gt; function for creating directories, see &lt;a href=&quot;perlfunc#mkdir&quot;&gt;&quot;mkdir&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 생성을위한 Perl의 내장 &lt;code&gt;mkdir()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#mkdir&quot;&gt;perlfunc의 &quot;mkdir&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8372bc5819fbb2b69c11355ff429f873a1d19d34" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;readdir()&lt;/code&gt; function for reading directory entries, see &lt;a href=&quot;perlfunc#readdir&quot;&gt;&quot;readdir&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 항목을 읽기위한 Perl의 내장 &lt;code&gt;readdir()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#readdir&quot;&gt;perlfunc의 &quot;readdir&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc44a32d8bf4a587e48ef68a6399c088ca095e76" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;rename()&lt;/code&gt; function for renaming files, see &lt;a href=&quot;perlfunc#rename&quot;&gt;&quot;rename&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 이름을 바꾸는 Perl의 내장 &lt;code&gt;rename()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#rename&quot;&gt;perlfunc의 &quot;rename&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9807c8d4769fe887205ad2c319e1b6b6f530cfa0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;rewinddir()&lt;/code&gt; function for rewinding directory entry streams, see &lt;a href=&quot;perlfunc#rewinddir&quot;&gt;&quot;rewinddir&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 항목 스트림을 되감기위한 Perl의 내장 &lt;code&gt;rewinddir()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#rewinddir&quot;&gt;perlfunc의 &quot;rewinddir&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca175f2947c71a8d62582ef5092aec4bf6d13dff" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;rmdir()&lt;/code&gt; function for removing (empty) directories, see &lt;a href=&quot;perlfunc#rmdir&quot;&gt;&quot;rmdir&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 (빈) 디렉토리를 제거하기위한 Perl의 내장 &lt;code&gt;rmdir()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#rmdir&quot;&gt;perlfunc의 &quot;rmdir&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e5ced0975ffedcd4b86d361ab8c812058cf8570" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;sin()&lt;/code&gt; function for returning the sine of the numerical argument, see &lt;a href=&quot;perlfunc#sin&quot;&gt;&quot;sin&quot; in perlfunc&lt;/a&gt;. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 사인을 반환하는 Perl의 내장 &lt;code&gt;sin()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#sin&quot;&gt;perlfunc의 &quot;sin&quot;을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e5b6569126a0ff525866fa62adee3690d41b326" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;sqrt()&lt;/code&gt; function. for returning the square root of the numerical argument, see &lt;a href=&quot;perlfunc#sqrt&quot;&gt;&quot;sqrt&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;sqrt()&lt;/code&gt; 함수와 동일 합니다. 숫자 인수의 제곱근을 반환하려면 &lt;a href=&quot;perlfunc#sqrt&quot;&gt;perlfunc의 &quot;sqrt&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc889395d59d965a8ac912064a8cc9050755ed00" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;stat()&lt;/code&gt; function for returning information about files and directories.</source>
          <target state="translated">이것은 파일과 디렉토리에 대한 정보를 반환 하는 Perl의 내장 &lt;code&gt;stat()&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e8832a10bfda45b41af5380174e01f618872f3ff" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;system()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;system()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#system&quot;&gt;perlfunc의 &quot;system&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5066c0194994f20427059d8e1f43ba7326ce9f4a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;time()&lt;/code&gt; function for returning the number of seconds since the epoch (whatever it is for the system), see &lt;a href=&quot;perlfunc#time&quot;&gt;&quot;time&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이는 펄의 내장의 동일 &lt;code&gt;time()&lt;/code&gt; 을 참조하십시오 (이 시스템을 위해 무엇이든) 신기원부터 초 수를 반환하는 기능 &lt;a href=&quot;perlfunc#time&quot;&gt;을 perlfunc에서 &quot;시간&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15a23c736c7514772cb5de8b72d105ced2014902" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;umask()&lt;/code&gt; function for setting (and querying) the file creation permission mask, see &lt;a href=&quot;perlfunc#umask&quot;&gt;&quot;umask&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 생성 권한 마스크를 설정 (및 쿼리)하기위한 Perl의 내장 &lt;code&gt;umask()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#umask&quot;&gt;perlfunc의 &quot;umask&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d3d6c3a129925b0029f640eeed5c30997e2fe6b" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;unlink()&lt;/code&gt; function for removing files, see &lt;a href=&quot;perlfunc#unlink&quot;&gt;&quot;unlink&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 제거를위한 Perl의 내장 &lt;code&gt;unlink()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#unlink&quot;&gt;perlfunc의 &quot;unlink&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c122efad471753582acea85c0f5c56e9dd6cb21b" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;utime()&lt;/code&gt; function for changing the time stamps of files and directories, see &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 파일과 디렉토리의 타임 스탬프를 변경하기위한 Perl의 내장 &lt;code&gt;utime()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#utime&quot;&gt;perlfunc의 &quot;utime&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5374f3dbfc8104dc52a46f4e1cac38e75ea3732" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;wait()&lt;/code&gt; function, see &lt;a href=&quot;perlfunc#wait&quot;&gt;&quot;wait&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;wait()&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;perlfunc#wait&quot;&gt;perlfunc의 &quot;wait&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c33a2624a3bac1d7979963b70993ae442f03646c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;_exit()&lt;/code&gt; . It exits the program immediately which means among other things buffered I/O is &lt;b&gt;not&lt;/b&gt; flushed.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;_exit()&lt;/code&gt; 동일합니다 . 버퍼링 된 I / O가 &lt;b&gt;아닌&lt;/b&gt; 다른 것을 의미하는 즉시 프로그램을 종료합니다.&lt;b&gt;&lt;/b&gt; 플러시 .</target>
        </trans-unit>
        <trans-unit id="00e254fcf98c61ec0f416895b5a730cc21dd60c2" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;_exit()&lt;/code&gt;. It exits the program immediately which means among other things buffered I/O is &lt;b&gt;not&lt;/b&gt; flushed.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;_exit()&lt;/code&gt; 동일합니다 . 즉, 버퍼링 된 I / O가 플러시 &lt;b&gt;되지 않음&lt;/b&gt; 을 의미하는 프로그램을 즉시 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="f80c449f3b57bbebcb07635c9eb453473b86c188" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;abort()&lt;/code&gt; . It terminates the process with a &lt;code&gt;SIGABRT&lt;/code&gt; signal unless caught by a signal handler or if the handler does not return normally (it e.g. does a &lt;code&gt;longjmp&lt;/code&gt; ).</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;abort()&lt;/code&gt; 동일합니다 . 신호 처리기에 의해 포착되지 않거나 처리기가 정상적으로 반환되지 않으면 &lt;code&gt;SIGABRT&lt;/code&gt; 신호로 프로세스를 종료합니다 (예 : &lt;code&gt;longjmp&lt;/code&gt; 수행 ) .</target>
        </trans-unit>
        <trans-unit id="20cdd3c3d411f66ac2cf90136127302421076da0" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;abort()&lt;/code&gt;. It terminates the process with a &lt;code&gt;SIGABRT&lt;/code&gt; signal unless caught by a signal handler or if the handler does not return normally (it e.g. does a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;abort()&lt;/code&gt; 동일합니다 . 신호 처리기에 의해 포착되지 않거나 처리기가 정상적으로 반환되지 않는 경우 (예 : &lt;code&gt;longjmp&lt;/code&gt; 수행 ) &lt;code&gt;SIGABRT&lt;/code&gt; 신호로 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="d259a90ce3ab2f4e634cfbde2a7c2b688963f261" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acos()&lt;/code&gt; , returning the arcus cosine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;acos()&lt;/code&gt; 와 동일 하며 숫자 인수의 아크 코사인을 반환합니다. 또한보십시오&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e673d5033a6bd97125eca8bcd1d7b8d61c4bb0ee" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acos()&lt;/code&gt;, returning the arcus cosine of its numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 arcus cosine을 반환 하는 C 함수 &lt;code&gt;acos()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccee1e25346b17fb481ba7f4de4b0b4f50758bcf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acosh()&lt;/code&gt; , returning the hyperbolic arcus cosine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;acosh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 사인을 반환합니다. 또한보십시오&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="222701acaff9ce2c807037cd58cb7be89c8e135d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acosh()&lt;/code&gt;, returning the hyperbolic arcus cosine of its numerical argument [C99]. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수 [C99]의 쌍곡선 아크 스 코사인을 반환 하는 C 함수 &lt;code&gt;acosh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8333095da54e7a945d4144cea8a756431c8956dd" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asctime()&lt;/code&gt; . It returns a string of the form</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asctime()&lt;/code&gt; 동일합니다 . 그것은 형식의 문자열을 반환</target>
        </trans-unit>
        <trans-unit id="48d0b6399063cccc6c529b55c31cc0b8ab41e44e" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asctime()&lt;/code&gt;. It returns a string of the form</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asctime()&lt;/code&gt; 동일합니다 . 다음 형식의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83275b8475bd60ebbcd493cefc6cdd7a1783a9d1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asin()&lt;/code&gt; , returning the arcus sine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asin()&lt;/code&gt; 과 동일 하며 숫자 인수의 아크 사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54c609704a8db4a3b622bf9cc7b83ccb3470173b" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asin()&lt;/code&gt;, returning the arcus sine of its numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asin()&lt;/code&gt; 과 동일 하며 숫자 인수의 arcus sine을 반환합니다. &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c416500eafa9e5a5d6b613f8969a9c043a063d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asinh()&lt;/code&gt; , returning the hyperbolic arcus sine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asinh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f3336a617e3723139602480ac46beceda806087" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asinh()&lt;/code&gt;, returning the hyperbolic arcus sine of its numerical argument [C99]. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수 [C99]의 쌍곡선 아크 스 사인을 반환 하는 C 함수 &lt;code&gt;asinh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1e5aa7da9f697f4c8ff8dc1fb698909d946bb08" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atan()&lt;/code&gt; , returning the arcus tangent of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이는 C 함수 &lt;code&gt;atan()&lt;/code&gt; 과 동일 하며 숫자 인수의 아크 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00b11961b84c9839acb25a23858dc26ef9cc84ec" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atan()&lt;/code&gt;, returning the arcus tangent of its numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 arcus tangent를 반환 하는 C 함수 &lt;code&gt;atan()&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f0cbd1a192e343ff198d459f44a118616c801d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atanh()&lt;/code&gt; , returning the hyperbolic arcus tangent of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;atanh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aacbec97967534e4e0da192e27504c8b78773bf1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atanh()&lt;/code&gt;, returning the hyperbolic arcus tangent of its numerical argument [C99]. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수 [C99]의 쌍곡선 아크 스 탄젠트를 반환 하는 C 함수 &lt;code&gt;atanh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1019f8f1ad013c7cb1f6add559add30196a2727" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ceil()&lt;/code&gt; , returning the smallest integer value greater than or equal to the given numerical argument.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;ceil()&lt;/code&gt; 과 동일하며 주어진 숫자 인수보다 크거나 같은 가장 작은 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09aef5268ee130db39b796423ddf5bc05a67f7d9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ceil()&lt;/code&gt;, returning the smallest integer value greater than or equal to the given numerical argument.</source>
          <target state="translated">이것은 주어진 숫자 인수보다 크거나 같은 가장 작은 정수 값을 반환 하는 C 함수 &lt;code&gt;ceil()&lt;/code&gt; 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d09fd6d4a60edcd6b29ae2efeeb92f7f1a3032dc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;clock()&lt;/code&gt; , returning the amount of spent processor time in microseconds.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;clock()&lt;/code&gt; 과 동일하며 소비 된 프로세서 시간을 마이크로 초 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb64ec4bf06850ca41b665cf03b415935ba00a08" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;clock()&lt;/code&gt;, returning the amount of spent processor time in microseconds.</source>
          <target state="translated">이것은 마이크로 초 단위로 소비 된 프로세서 시간을 반환 하는 C 함수 &lt;code&gt;clock()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ed50101b37aabb6ccd0f72bf1cd12dc057e125c6" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;cosh()&lt;/code&gt; , for returning the hyperbolic cosine of its numeric argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이는 숫자 인수의 쌍곡 코사인을 반환 하는 C 함수 &lt;code&gt;cosh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3eb4801a049bd3b441ac59627ccf364d2f377e67" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;cosh()&lt;/code&gt;, for returning the hyperbolic cosine of its numeric argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡선 코사인을 반환 하는 C 함수 &lt;code&gt;cosh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f87a9c64391c986e35e0df3a461ddde69989f77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ctime()&lt;/code&gt; and equivalent to &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; , see &lt;a href=&quot;#asctime&quot;&gt;asctime&lt;/a&gt; and &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 동일 &lt;code&gt;ctime()&lt;/code&gt; 및 등가 &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; 을 참조 &lt;a href=&quot;#asctime&quot;&gt;asctime과&lt;/a&gt; 및&lt;a href=&quot;#localtime&quot;&gt;&lt;/a&gt; . localtime을 .</target>
        </trans-unit>
        <trans-unit id="6d3b737efaa2b1ca101fca77dad87f1948da80de" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ctime()&lt;/code&gt; and equivalent to &lt;code&gt;asctime(localtime(...))&lt;/code&gt;, see &lt;a href=&quot;#asctime&quot;&gt;&quot;asctime&quot;&lt;/a&gt; and &lt;a href=&quot;#localtime&quot;&gt;&quot;localtime&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;ctime()&lt;/code&gt; 과 동일하고 &lt;code&gt;asctime(localtime(...))&lt;/code&gt; 과 동일합니다. &lt;a href=&quot;#asctime&quot;&gt;&quot;asctime&quot;&lt;/a&gt; 및 &lt;a href=&quot;#localtime&quot;&gt;&quot;localtime&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98a7a8b5298975e8b4638f6e08f625101ddd94f1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;difftime()&lt;/code&gt; , for returning the time difference (in seconds) between two times (as returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;), see &lt;a href=&quot;#time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 동일 &lt;code&gt;difftime()&lt;/code&gt; (의해 반환 두 시간 사이에 시간 (초)의 차이를 복귀 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; ) 참조 &lt;a href=&quot;#time&quot;&gt;시간&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="697a72690b71691d80d753e57df20f9ff5b09479" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;difftime()&lt;/code&gt;, for returning the time difference (in seconds) between two times (as returned by &lt;code&gt;time()&lt;/code&gt;), see &lt;a href=&quot;#time&quot;&gt;&quot;time&quot;&lt;/a&gt;.</source>
          <target state="translated">이는 C 함수 &lt;code&gt;difftime()&lt;/code&gt; 과 동일합니다. 두 시간 사이의 시간 차이 (초)를 반환하려면 ( &lt;code&gt;time()&lt;/code&gt; 반환 됨 ) &lt;a href=&quot;#time&quot;&gt;&quot;time&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3400f6cf25b03ffea13db374eb3a67b922b12f5c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;floor()&lt;/code&gt; , returning the largest integer value less than or equal to the numerical argument.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;floor()&lt;/code&gt; 과 동일합니다. 와 동일하며 숫자 인수보다 작거나 같은 가장 큰 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b9055c370577838fb2e4da609111c91973145a3" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;floor()&lt;/code&gt;, returning the largest integer value less than or equal to the numerical argument.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;floor()&lt;/code&gt; 와 동일하며 숫자 인수보다 작거나 같은 가장 큰 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b40ee9ab2883fdc4ea6712b24d8986ecec5f39fc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;fmod()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;fmod()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3287da7f52ceaee5a8201c36c4596dffd105daf4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;fmod()&lt;/code&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;fmod()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7b7a8f7914876d99686857a5b212ffa67a406bf2" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ldexp()&lt;/code&gt; for multiplying floating point numbers with powers of two.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;ldexp()&lt;/code&gt; 동일합니다 부동 소수점 숫자에 2의 거듭 제곱을 곱하는 와 .</target>
        </trans-unit>
        <trans-unit id="5967c218ae5e6977bcfb278510b90089a48661b4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;log10()&lt;/code&gt; , returning the 10-base logarithm of the numerical argument. You can also use</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;log10()&lt;/code&gt; 과 동일 하며 숫자 인수의 10-베이스 로그를 반환합니다. 당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="08dc53f13307f9a7669daa41059fc0f3ab144475" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;log10()&lt;/code&gt;, returning the 10-base logarithm of the numerical argument. You can also use</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;log10()&lt;/code&gt; 과 동일 하며 숫자 인수의 10 밑 로그를 반환합니다. 당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d960a256a04c197a9681bc6a5b2df4621c6abcef" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mblen()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mblen()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="72da259370ed7368b03117d248a4d69905a2aec8" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbstowcs()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mbstowcs()&lt;/code&gt; 동일합니다. .</target>
        </trans-unit>
        <trans-unit id="e9cb9e5092c37fe36ba32ebf9a50fb911920ee05" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbtowc()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mbtowc()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="34c30fa04962ce474f9dd2f58f200b70edfa44f9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;perror()&lt;/code&gt; , which outputs to the standard error stream the specified message followed by &lt;code&gt;&quot;: &quot;&lt;/code&gt; and the current error string. Use the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; function and the &lt;code&gt;$!&lt;/code&gt; variable instead, see &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; and &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;perror()&lt;/code&gt; 와 동일합니다.이 함수 는 지정된 메시지와 &lt;code&gt;&quot;: &quot;&lt;/code&gt; 및 현재 오류 문자열이 뒤에 오는 표준 오류 스트림으로 출력 합니다. 사용 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 함수와 &lt;code&gt;$!&lt;/code&gt; 대신 변수, &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar에서 &lt;/a&gt;&lt;a href=&quot;functions/warn&quot;&gt;경고&lt;/a&gt; 및 $ ERRNO 참조 .</target>
        </trans-unit>
        <trans-unit id="e999e8bd354cec8599d88611d60fa296f4268ab9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;perror()&lt;/code&gt;, which outputs to the standard error stream the specified message followed by &lt;code&gt;&quot;: &quot;&lt;/code&gt; and the current error string. Use the &lt;code&gt;warn()&lt;/code&gt; function and the &lt;code&gt;$!&lt;/code&gt; variable instead, see &lt;a href=&quot;perlfunc#warn&quot;&gt;&quot;warn&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;&quot;$ERRNO&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;perror()&lt;/code&gt; 와 동일하며, 지정된 메시지 뒤에 &lt;code&gt;&quot;: &quot;&lt;/code&gt; 및 현재 오류 문자열을 표준 오류 스트림에 출력 합니다. 사용 &lt;code&gt;warn()&lt;/code&gt; 함수와 &lt;code&gt;$!&lt;/code&gt; 변수 대신 &lt;a href=&quot;perlfunc#warn&quot;&gt;perlfunc의 &quot;warn&quot;&lt;/a&gt; 및 &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar의 &quot;$ ERRNO&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cc1118a61c7aca10633514f234f4da1ee0e5bc3" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;setsid()&lt;/code&gt; for setting the session identifier of the current process.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;setsid()&lt;/code&gt; 동일 현재 프로세스의 세션 식별자를 설정 와 .</target>
        </trans-unit>
        <trans-unit id="cd2e30a5d85631fe96db821f94473755dc93c4ea" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;sinh()&lt;/code&gt; for returning the hyperbolic sine of the numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡 사인을 반환 하는 C 함수 &lt;code&gt;sinh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8b9a9e6d01fce018b50fa102ad5992e876d6995" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;sinh()&lt;/code&gt; for returning the hyperbolic sine of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡 사인을 리턴 하는 C 함수 &lt;code&gt;sinh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5620e4c58d5e806939f06354c891f33af057e241" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;strcoll()&lt;/code&gt; for collating (comparing) strings transformed using the &lt;code&gt;strxfrm()&lt;/code&gt; function. Not really needed since Perl can do this transparently, see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">이는 &lt;code&gt;strxfrm()&lt;/code&gt; 함수를 사용하여 변환 된 문자열을 대조 하는 C 함수 &lt;code&gt;strcoll()&lt;/code&gt; 과 동일 합니다. Perl이 투명하게 할 수 있기 때문에 실제로는 필요하지 않습니다 . &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c1de6e40d16de1b4908183780ee818a15a66a41" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tan()&lt;/code&gt; , returning the tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;tan()&lt;/code&gt; 과 동일 하며 숫자 인수의 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f498da9b7b8a82d92561bf26d0e1756b0d1ee8f4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tan()&lt;/code&gt;, returning the tangent of the numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 탄젠트를 반환하는 C 함수 &lt;code&gt;tan()&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53070d8b102022984bacaa431429b0ea23b53bf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tanh()&lt;/code&gt; , returning the hyperbolic tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;tanh()&lt;/code&gt; 와 동일 하며 숫자 인수의 쌍곡 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="619493a33623a4d1d100c28c84312cd640352776" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tanh()&lt;/code&gt;, returning the hyperbolic tangent of the numerical argument. See also &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡 탄젠트를 반환 하는 C 함수 &lt;code&gt;tanh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4339b3026b6818ba331f4b8dad83033d79b015ba" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tcgetpgrp()&lt;/code&gt; for returning the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">이것은 제어 터미널의 포 그라운드 프로세스 그룹의 프로세스 그룹 식별자를 반환 하는 C 함수 &lt;code&gt;tcgetpgrp()&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="10385672619fbe5424be8d41f4c81323dffb2c77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ttyname()&lt;/code&gt; for returning the name of the current terminal.</source>
          <target state="translated">이것은 현재 터미널의 이름을 반환하는 C 함수 &lt;code&gt;ttyname()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="61c4adb4504ab133429c5dcca9e634dda0234fa4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tzset()&lt;/code&gt; for setting the current timezone based on the environment variable &lt;code&gt;TZ&lt;/code&gt; , to be used by &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;mktime()&lt;/code&gt; , and &lt;code&gt;strftime()&lt;/code&gt; functions.</source>
          <target state="translated">이는 &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mktime()&lt;/code&gt; 및 &lt;code&gt;strftime()&lt;/code&gt; 의해 사용되는 환경 변수 &lt;code&gt;TZ&lt;/code&gt; 를 기반으로 현재 시간대를 설정 하는 C 함수 &lt;code&gt;tzset()&lt;/code&gt; 과 동일합니다. 함수에서 합니다.</target>
        </trans-unit>
        <trans-unit id="c8d5049412005d34781dc9061461ec11720e4de6" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tzset()&lt;/code&gt; for setting the current timezone based on the environment variable &lt;code&gt;TZ&lt;/code&gt;, to be used by &lt;code&gt;ctime()&lt;/code&gt;, &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;mktime()&lt;/code&gt;, and &lt;code&gt;strftime()&lt;/code&gt; functions.</source>
          <target state="translated">이는 &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;localtime()&lt;/code&gt; , &lt;code&gt;mktime()&lt;/code&gt; 및 &lt;code&gt;strftime()&lt;/code&gt; 함수에서 사용할 환경 변수 &lt;code&gt;TZ&lt;/code&gt; 를 기반으로 현재 시간대를 설정 하는 C 함수 &lt;code&gt;tzset()&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6eac2e9b93151c25128e8b44336e559f1ca26691" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wcstombs()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;wcstombs()&lt;/code&gt; 동일합니다. .</target>
        </trans-unit>
        <trans-unit id="6531eaab1a3fcd3d02f83fe194ba892352425032" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wctomb()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;wctomb()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2b638e3d48a14e811a63d8a3b93348f1843f5897" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, or the equivalent &lt;code&gt;\L&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">이는 단일 문자 또는 전체 문자열에 적용 할 수 있다는 점을 제외하고 C 함수와 동일하며 현재 로케일이 항상 &quot;C&quot;인 것처럼 작동합니다. &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 함수 사용을 고려 하십시오 ( &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 참조, &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 참조 또는 큰 따옴표 안에 있는 동등한 &lt;code&gt;\L&lt;/code&gt; 연산자).</target>
        </trans-unit>
        <trans-unit id="30976c7fff7754f905b7e098aaebc37d849842e9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except the order of arguments is consistent with Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; with the added restriction of only one path, not a list of paths. Does the same thing as the &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function but changes the owner of a symbolic link instead of the file the symbolic link points to.</source>
          <target state="translated">인수 순서가 경로 목록이 아닌 하나의 경로 만 추가 된 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 과 일치한다는 점을 제외하면 C 함수와 동일합니다 . &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 과 같은 일을 함수 하지만 심볼릭 링크가 가리키는 파일 대신 심볼릭 링크의 소유자를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f2df656889ea7332cb6bc09e8c0d267a915a4923" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except the order of arguments is consistent with Perl's builtin &lt;code&gt;chown()&lt;/code&gt; with the added restriction of only one path, not a list of paths. Does the same thing as the &lt;code&gt;chown()&lt;/code&gt; function but changes the owner of a symbolic link instead of the file the symbolic link points to.</source>
          <target state="translated">이것은 C 함수와 동일합니다. 단, 인수의 순서는 경로 목록이 아닌 하나의 경로에 대한 추가 제한이 있는 Perl의 내장 &lt;code&gt;chown()&lt;/code&gt; 과 일치 합니다. &lt;code&gt;chown()&lt;/code&gt; 함수 와 동일한 작업을 수행하지만 심볼릭 링크가 가리키는 파일 대신 심볼릭 링크의 소유자를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="cec15e827312e3918cb71e034a41abdc4f73a598" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_FUNCS attribute available via MakeMaker, from which it is usually taken. Its value is a reference to an associative array, in which each key is the name of a package, and each value is an a reference to an array of function names which should be exported by the extension. For instance, one might say &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ],
Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; . The function names should be identical to those in the XSUB code; &lt;code&gt;Mksymlists&lt;/code&gt; will alter the names written to the linker option file to match the changes made by</source>
          <target state="translated">이는 일반적으로 사용되는 MakeMaker를 통해 사용 가능한 DL_FUNCS 속성과 동일합니다. 값은 연관 배열에 대한 참조이며 각 키는 패키지의 이름이고 각 값은 확장에 의해 내 보내야하는 함수 이름의 배열에 대한 참조입니다. 예를 들어 &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ], Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; 라고 말할 수 있습니다 . 함수 이름은 XSUB 코드와 동일해야합니다. &lt;code&gt;Mksymlists&lt;/code&gt; 는 링커 옵션 파일에 작성된 이름을 변경하여</target>
        </trans-unit>
        <trans-unit id="05f95b67712ddc6756ad05c6f1a80aa7067863ef" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_FUNCS attribute available via MakeMaker, from which it is usually taken. Its value is a reference to an associative array, in which each key is the name of a package, and each value is an a reference to an array of function names which should be exported by the extension. For instance, one might say &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ], Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt;. The function names should be identical to those in the XSUB code; &lt;code&gt;Mksymlists&lt;/code&gt; will alter the names written to the linker option file to match the changes made by</source>
          <target state="translated">이것은 MakeMaker를 통해 사용 가능한 DL_FUNCS 속성과 동일하며 일반적으로 가져옵니다. 그 값은 연관 배열에 대한 참조이며 각 키는 패키지의 이름이고 각 값은 확장에서 내 보내야하는 함수 이름의 배열에 대한 참조입니다. 예를 들어, &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ], Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; 라고 말할 수 있습니다 . 함수 이름은 XSUB 코드의 이름과 동일해야합니다. &lt;code&gt;Mksymlists&lt;/code&gt; 는 링커 옵션 파일에 기록 된 이름을 다음과 같이 변경합니다.</target>
        </trans-unit>
        <trans-unit id="310f96db114f72f372da9166d69a4cc6f2cae9b1" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_VARS attribute available via MakeMaker, and, like DL_FUNCS, it is usually specified via MakeMaker. Its value is a reference to an array of variable names which should be exported by the extension.</source>
          <target state="translated">이는 MakeMaker를 통해 사용 가능한 DL_VARS 속성과 동일하며 DL_FUNCS와 마찬가지로 일반적으로 MakeMaker를 통해 지정됩니다. 이 값은 확장명으로 내 보내야하는 변수 이름 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="b412f9ab149e41469d7ba2eef653a9c88721e439" translate="yes" xml:space="preserve">
          <source>This is identical to the macro &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt;.</source>
          <target state="translated">매크로 &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1adbe800aa3e5b1f98201baedb59f2c206a1c29e" translate="yes" xml:space="preserve">
          <source>This is identical to the macro &lt;a href=&quot;perlapi#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlapi#isUTF8_CHAR&quot;&gt;perlapi의 &quot;isUTF8_CHAR&quot;&lt;/a&gt; 매크로와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6cee0007e2daab07905e6dc7537e69cd21d5b2ba" translate="yes" xml:space="preserve">
          <source>This is ignored by most formatters, but some may use it for building indexes. It always renders as empty-string. Example: &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</source>
          <target state="translated">대부분의 포맷터에서는이를 무시하지만 일부는 인덱스 작성에 사용할 수 있습니다. 항상 빈 문자열로 렌더링됩니다. 예 : &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be9929994c9a23587b60ac75552db3fe41c07468" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro.</source>
          <target state="translated">이것은 매크로로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="667c85db18e1907f43da9d70ad90da9e90ed961a" translate="yes" xml:space="preserve">
          <source>This is important because miniperl, used to build XS modules in the core, can not load XS.</source>
          <target state="translated">코어에 XS 모듈을 빌드하는 데 사용되는 miniperl이 XS를로드 할 수 없기 때문에 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="144222a27e6ef028e4173cd0825a23a1090abbf3" translate="yes" xml:space="preserve">
          <source>This is in contrast to many other dynamic languages, where the operation is determined by the type of the first argument. It also means that Perl has two versions of some operators, one for numeric and one for string comparison. For example &lt;code&gt;$x == $y&lt;/code&gt; compares two numbers for equality, and &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; compares two strings.</source>
          <target state="translated">이것은 다른 많은 동적 언어와 대조적으로 작동이 첫 번째 인수의 유형에 의해 결정됩니다. 또한 Perl에는 숫자와 문자열 비교를위한 두 가지 버전의 일부 연산자가 있음을 의미합니다. 예를 들어 &lt;code&gt;$x == $y&lt;/code&gt; 는 두 숫자가 같은지 비교하고 &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; 는 두 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3bc5ead38c3990127ff9d0720451c4bddc83a1e1" translate="yes" xml:space="preserve">
          <source>This is in contrast to many other dynamic languages, where the operation is determined by the type of the first argument. It also means that Perl has two versions of some operators, one for numeric and one for string comparison. For example &lt;code&gt;$x == $y&lt;/code&gt; compares two numbers for equality, and &lt;code&gt;$x eq $y&lt;/code&gt; compares two strings.</source>
          <target state="translated">이것은 연산이 첫 번째 인수의 유형에 의해 결정되는 다른 많은 동적 언어와는 대조적입니다. 또한 Perl에는 숫자 및 문자열 비교를위한 두 가지 버전의 일부 연산자가 있습니다. 예를 들어 &lt;code&gt;$x == $y&lt;/code&gt; 는 두 숫자가 같은지 비교하고 &lt;code&gt;$x eq $y&lt;/code&gt; 는 두 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="6d09a7649982765a4ac03ceb6ff657832053b721" translate="yes" xml:space="preserve">
          <source>This is independent of other methods (except that it operates after any verbatim input stripping is done).</source>
          <target state="translated">이것은 다른 방법과는 무관합니다 (완전히 입력 스트리핑이 완료된 후에 작동한다는 점을 제외하고).</target>
        </trans-unit>
        <trans-unit id="1dc4ce8a710f4fb316b8dc52b8dcce601b6a9b9f" translate="yes" xml:space="preserve">
          <source>This is indexed by op name and then bit number (0..7). For single bit flags, it returns the name of the define (if any) for that bit:</source>
          <target state="translated">이것은 연산 이름과 비트 번호 (0..7)로 인덱싱됩니다. 단일 비트 플래그의 경우 해당 비트에 대한 정의 (있는 경우)의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb4362971c4874b5e0e3d89683d64eb2597dab60" translate="yes" xml:space="preserve">
          <source>This is intended as a shortcut that lets you release your context and return a value in one statement. This function will get your context, and an optional return value. It will release your context, then return your value. Scalar context is always assumed.</source>
          <target state="translated">이는 컨텍스트를 해제하고 하나의 문에서 값을 반환 할 수있는 바로 가기로 사용됩니다. 이 함수는 컨텍스트와 선택적 반환 값을 가져옵니다. 컨텍스트를 해제 한 다음 값을 반환합니다. 스칼라 컨텍스트는 항상 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="17fded423d74ecd2cac30cc09f0fef74a562c96a" translate="yes" xml:space="preserve">
          <source>This is intended for authors of modules which do lots of class introspection, as it allows them to very quickly check if anything important about the local properties of a given class have changed since the last time they looked. It does not increment on method/&lt;code&gt;@ISA&lt;/code&gt; changes in superclasses.</source>
          <target state="translated">이것은 많은 클래스 내부 검사를 수행하는 모듈 작성자를 대상으로합니다. 마지막으로 본 이후 지정된 클래스의 로컬 속성에 중요한 것이 변경되었는지 매우 빠르게 확인할 수 있기 때문입니다. 수퍼 클래스 에서 메소드 / &lt;code&gt;@ISA&lt;/code&gt; 변경시 증가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f3febce058bf2848f33dea0d5ca24d955e2c8d64" translate="yes" xml:space="preserve">
          <source>This is intended to be a human readable summary of the event. This should ideally only be one line long, but you can use multiple lines if necessary. This is intended for human consumption. You do not need to make it easy for machines to understand.</source>
          <target state="translated">이것은 사람이 읽을 수있는 이벤트 요약입니다. 이상적으로는 한 줄 길이 여야하지만 필요한 경우 여러 줄을 사용할 수 있습니다. 이것은 인간이 소비하기위한 것입니다. 기계가 이해하기 쉽게 만들 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f0be3b75ce6b3c6941246d7312f0a73c8b3d2d9" translate="yes" xml:space="preserve">
          <source>This is intended to be called in an &lt;code&gt;END { ... }&lt;/code&gt; block. This will look at test state and set $?. This will also call any end callbacks, and wait on child processes/threads.</source>
          <target state="translated">이것은 &lt;code&gt;END { ... }&lt;/code&gt; 블록 에서 호출하기위한 것 입니다. 이것은 테스트 상태를보고 $?를 설정합니다. 이것은 또한 모든 종료 콜백을 호출하고 자식 프로세스 / 스레드를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="8048e3a62929d8c0b743c4d8a83b98f6eb0f81fb" translate="yes" xml:space="preserve">
          <source>This is intended to largely replace the deprecated pseudo-hashes.</source>
          <target state="translated">이것은 더 이상 사용되지 않는 의사 해시를 대체하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="db4b800255fcc3a17f2b811fc2b88aebde232685" translate="yes" xml:space="preserve">
          <source>This is invalid because every &quot;=end&quot; command must have a formatname parameter.</source>
          <target state="translated">모든 &quot;= end&quot;명령에 formatname 매개 변수가 있어야하므로 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61a2277b2bd23db81a91f83c4d1f3dd9feb9a041" translate="yes" xml:space="preserve">
          <source>This is just a basic proof of concept. It should be seriously expanded to support configurable coloration via options passed to the constructor, and &lt;b&gt;pod2text&lt;/b&gt; should be taught about those.</source>
          <target state="translated">이것은 단지 기본 개념 증명입니다. 생성자에 전달 된 옵션을 통해 구성 가능한 채색을 지원하도록 심각하게 확장 되어야하며 &lt;b&gt;pod2text&lt;/b&gt; 에 대해 &lt;b&gt;알려야&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="68c9d184917794ed93e7fda1e4971f91e0c45375" translate="yes" xml:space="preserve">
          <source>This is just a beta release -- there are a good number of things still left to do. Notably, support for EBCDIC platforms is still half-done, an untested.</source>
          <target state="translated">이것은 베타 버전 일뿐입니다. 아직해야 할 일이 많습니다. 특히 EBCDIC 플랫폼에 대한 지원은 아직 완료되지 않았으며 아직 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="219ed1315313e10e560072058c3673015172eb8a" translate="yes" xml:space="preserve">
          <source>This is just a quick start guide. For a more in-depth tutorial on regexes, see &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and for the reference page, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">이것은 단지 빠른 시작 안내서입니다. &lt;a href=&quot;perlretut&quot;&gt;정규 표현식&lt;/a&gt; 에 대한 자세한 자습서는 perlretut 를 참조하고 참조 페이지는 &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="285e57010c635f262d70613679ce183fe2c1fc6d" translate="yes" xml:space="preserve">
          <source>This is just a restatement of the previous section. Unless you are completely certain you know what you are doing, avoid mixing filtered &amp;amp; non-filtered data.</source>
          <target state="translated">이것은 이전 섹션의 설명입니다. 자신이하는 일을 완전히 확신하지 않는 한 필터링 된 데이터와 필터링되지 않은 데이터를 혼합하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0eb6c125a87601bb415e7dd8ac4261d5f4ccd383" translate="yes" xml:space="preserve">
          <source>This is just a shorthand for a typeglob assignment at compile time:</source>
          <target state="translated">이것은 컴파일 타임에 타입 글로브 할당의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="15b35232b5a8087ae488ff75565de5703f14864d" translate="yes" xml:space="preserve">
          <source>This is just a tutorial. For the full story on Perl regular expressions, see the &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; regular expressions reference page.</source>
          <target state="translated">이것은 단지 튜토리얼입니다. Perl 정규 표현식에 대한 전체 내용은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 정규 표현식 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9456d5890fbed572d26379cc56324c8cfe828e36" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">이것은 Perl의 일반적인 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 둘러싼 래퍼 입니다. 대괄호 표기법에서 &quot;sprintf&quot;를 사용할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ff27b6bada60e402e6197635d038979041e1aa" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;sprintf&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">이것은 Perl의 정상적인 &lt;code&gt;sprintf&lt;/code&gt; 함수를 둘러싼 래퍼 일뿐 입니다. 대괄호 표기법에서 &quot;sprintf&quot;를 사용할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="77266324e65b81993bcee36043a748db86e77bf5" translate="yes" xml:space="preserve">
          <source>This is just an alias for $ctx-&amp;gt;new.</source>
          <target state="translated">이것은 $ ctx-&amp;gt; new의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="4341fe03623ad4301c3243c214057adf6cd69228" translate="yes" xml:space="preserve">
          <source>This is just an alias for $md5-&amp;gt;new.</source>
          <target state="translated">이것은 $ md5-&amp;gt; new의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="99b8f0dcbd7ef8ebc2a3383d96beb914e7c2ab77" translate="yes" xml:space="preserve">
          <source>This is just an alias for &lt;code&gt;to_bytes()&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;to_bytes()&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="abb98ec9f418273dc2ca6cd9acdcab91a8675d3b" translate="yes" xml:space="preserve">
          <source>This is just like get_title, except that it returns just the modulename, if the title seems to be of the form &quot;SomeModuleName -- description&quot;.</source>
          <target state="translated">제목이 &quot;SomeModuleName-description&quot;형식 인 경우 모듈 이름 만 반환한다는 점을 제외하면 get_title과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3efe951774b37c8f5ed5c70b61d80e43335a5d14" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 연산자 호출 사이에 한 번만 일치한다는 점을 제외 하면 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search 와 같습니다 . 예를 들어 파일 세트의 각 파일에서 처음 나타나는 항목 만 보려는 경우 유용한 최적화입니다. 오직 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; 현재 패키지에 로컬 인 패턴이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d73aff15bc3ff484da433da10ce9913b15e17a51" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;reset()&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;m??&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">이것은 &lt;code&gt;reset()&lt;/code&gt; 연산자 에 대한 호출 사이에 한 번만 일치한다는 점을 제외 하면 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; 검색 과 같습니다 . 예를 들어 파일 집합의 각 파일에서 처음 나타나는 항목 만보고 싶을 때 유용한 최적화입니다. 오직 &lt;code&gt;m??&lt;/code&gt; 현재 패키지에 로컬 인 패턴이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="380457e35227699cc7301b94acae78bea6e5c126" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for &quot;=cut&quot; lines, not code lines. The same caveats apply. &quot;=cut&quot; lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">이것은 코드 라인이 아니라 &quot;= cut&quot;라인에 대한 것을 제외하고는 code_handler 속성과 같습니다. 동일한 경고가 적용됩니다. &quot;= cut&quot;줄은 흥미롭지 않을 것 같지만 완전성을 위해 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0695e20ad7060a9368dde02cbfce95268dbd1b5b" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for &quot;=pod&quot; lines, not code lines. The same caveats apply. &quot;=pod&quot; lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">이것은 코드 라인이 아니라 &quot;= pod&quot;라인에 대한 것을 제외하고는 code_handler 속성과 같습니다. 동일한 경고가 적용됩니다. &quot;= pod&quot;라인은 흥미로울 것 같지 않지만 완전성을 위해 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="2022f30d9b2a5b27c04280f1ebd50a51bbc345d3" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for lines that are seemingly blank but have whitespace (&quot; &quot; and/or &quot;\t&quot;) on them, not code lines. The same caveats apply. These lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">이것은 코드 행이 아니라 공백 ( &quot;&quot;및 / 또는 &quot;\ t&quot;)이있는 행을 제외하고는 code_handler 속성과 같습니다. 동일한 경고가 적용됩니다. 이 라인은 흥미로울 것 같지 않지만 완전성을 위해 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="d1f273b15a0cb3300a978b7939f344dd1d08639d" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt; , but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">이것은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 같지만 일부 요소는 빈 문자열이므로 조정할 수 없습니다. &lt;code&gt;prop_invmap&lt;/code&gt; 으로 액세스 할 수있는 내부 Perl 특성 중 하나 는이 유형입니다. &quot;Perl_Decimal_Digit&quot;는 유니 코드 10 진수 문자로 표시되는 숫자 값을 제공하는 반전 맵을 리턴합니다. 10 진수를 나타내지 않는 문자는 다음과 같이 빈 문자열에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0c85507fc9c8edf048dedc4d8b1c473489d69c9b" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt;, but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">이것은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 비슷하지만 일부 요소는 빈 문자열이므로 조정해서는 안됩니다. &lt;code&gt;prop_invmap&lt;/code&gt; 에서 액세스 할 수있는 내부 Perl 속성 은 다음 유형입니다. &quot;Perl_Decimal_Digit&quot;은 유니 코드 십진수 문자로 표시되는 숫자 값을 제공하는 반전 맵을 반환합니다. 10 진수를 나타내지 않는 문자는 다음과 같이 빈 문자열에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8d1dd5dc0a1e329de530690bfade7652c51e667a" translate="yes" xml:space="preserve">
          <source>This is like accept_targets, except that it specifies also that the content of sections for this target should be treated as Pod text even if the target name in &quot;=for</source>
          <target state="translated">이는 &quot;= for&quot;의 대상 이름이 있더라도이 대상에 대한 섹션의 내용이 Pod 텍스트로 처리되어야 함을 지정한다는 점을 제외하면 accept_targets와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed31723489424c54355ea43ef7bfdd64197f0ef8" translate="yes" xml:space="preserve">
          <source>This is like the &quot;over-bullet&quot; event structure; but note that the contents are &quot;item-number&quot; instead of &quot;item-bullet&quot;, and note that they will have a &quot;number&quot; attribute, which some formatters/processors may ignore (since, for example, there's no need for it in HTML when producing an &quot;&amp;lt;UL&amp;gt;&amp;lt;LI&amp;gt;...&amp;lt;/LI&amp;gt;...&amp;lt;/UL&amp;gt;&quot; structure), but which any processor may use.</source>
          <target state="translated">이것은 &quot;over-bullet&quot;이벤트 구조와 같습니다. 그러나 내용은 &quot;item-bullet&quot;대신 &quot;item-number&quot;이고 일부 포맷터 / 프로세서가 무시할 수있는 &quot;number&quot;속성이 있다는 점에 유의하십시오 (예를 들어, &quot;&amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; ... &amp;lt;/ LI&amp;gt; ... &amp;lt;/ UL&amp;gt;&quot;구조를 생성 할 때 HTML), 그러나 모든 프로세서가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c2c127a4acabd567283fc3055323b13e8a32015" translate="yes" xml:space="preserve">
          <source>This is like the SMTP transport, but uses TLS security. You can authenticate with this module as well, using any mechanisms your server supports after STARTTLS.</source>
          <target state="translated">이것은 SMTP 전송과 비슷하지만 TLS 보안을 사용합니다. STARTTLS 이후 서버가 지원하는 메커니즘을 사용하여이 모듈로 인증 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a91727b3a107b517a647724e9523d6e1a6aa45f" translate="yes" xml:space="preserve">
          <source>This is mainly used by legacy &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; tests which set the plan to &lt;code&gt;no plan&lt;/code&gt;, a construct that predates the much better &lt;code&gt;done_testing()&lt;/code&gt;.</source>
          <target state="translated">이것은 주로 계획을 &lt;code&gt;no plan&lt;/code&gt; 으로 설정하는 레거시 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt; 테스트에서 사용되며 훨씬 더 나은 &lt;code&gt;done_testing()&lt;/code&gt; 이전의 구성입니다 .</target>
        </trans-unit>
        <trans-unit id="9bbc2d6ed341b1ef3ce37675e465b3be11154914" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">이것은 주로 &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 및 저수준 POSIX tty 처리 작업을 위한 비트 맵을 구성하는 데 유용 합니다. FILEHANDLE이 표현식이면 값은 일반적으로 이름 인 간접 파일 핸들로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ee19061e56d9213c77400710440b7c20343ebe03" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">이는 주로 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 저수준 POSIX tty 처리 작업을 위한 비트 맵을 구성하는 데 유용 합니다. FILEHANDLE이 표현식 인 경우 값은 간접 파일 핸들 (일반적으로 이름)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4451800d0e0114802550054b61665e033a2b00a5" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">이는 주로 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 저수준 POSIX tty 처리 작업을 위한 비트 맵을 구성하는 데 유용 합니다. FILEHANDLE이 표현식 인 경우 값은 간접 파일 핸들 (일반적으로 이름)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37ce9a12e2723922e8bd944d2d5d67e411bc7f1f" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;as_string&lt;/code&gt; 과 동의어 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="2ff1814bfd6950f7490c26d111f974fff43e1eff" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;as_string&lt;/code&gt; 의 동의어 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="4dab1c8c1fba88ee26cb0159afceae84eeab9c5c" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">이것은 원시 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 보다 이식성이 뛰어나지 만 실례는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="358b6febc6a20347552685e4650bab012743d763" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;ioctl&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">이것은 원시 &lt;code&gt;ioctl&lt;/code&gt; 보다 이식성이 더 좋지만 설명이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a905466f9a6fe7fba1c2ba03bc5e341bea7a9afa" translate="yes" xml:space="preserve">
          <source>This is most likely the same as &lt;code&gt;$Config{osname}&lt;/code&gt;, and was the name known when perl was built. It might be different if perl was cross-compiled.</source>
          <target state="translated">이것은 &lt;code&gt;$Config{osname}&lt;/code&gt; 과 같을 가능성이 높으며 perl이 빌드되었을 때 알려진 이름이었습니다. perl이 크로스 컴파일 된 경우 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ef392975ecd504b3ac95743d2709331ec1fc38" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">이것은 단순성이나 이식성의 모범은 아니지만 요점을 보여줍니다. 우리는 무대 뒤에서 몰래 들어와 Perl의 잘 보호 된 기억에 접근 할 수 있습니다! (중요한 메모 : Perl의 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="3f30d05de7dd225aaab947f0992ea2b7121ca260" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;syscall&lt;/code&gt; does</source>
          <target state="translated">이것은 단순함의 표본도 아니고 휴대 성의 모범도 아니지만 요점을 보여줍니다. 우리는 은밀히 은밀히 펄의 보호 된 메모리에 액세스 할 수 있습니다! (중요 사항 : Perl의 &lt;code&gt;syscall&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="10ebf1cbe04784f38db52da63b8ec5a60455457d" translate="yes" xml:space="preserve">
          <source>This is normally all you need to know. However, many options are available:</source>
          <target state="translated">이것은 일반적으로 당신이 알아야 할 전부입니다. 그러나 많은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00bfe25391751730fea233731dd8b0f5f6ab569" translate="yes" xml:space="preserve">
          <source>This is not &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;, which tells you how to use the debugger. This manpage describes low-level details concerning the debugger's internals, which range from difficult to impossible to understand for anyone who isn't incredibly intimate with Perl's guts. Caveat lector.</source>
          <target state="translated">이것은 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 가 아니며 디버거 사용 방법을 알려줍니다. 이 맨 페이지는 디버거의 내부에 관한 저수준의 세부 사항을 설명합니다. Perl의 내장에 굉장히 친밀하지 않은 사람에게는 이해하기 어렵거나 불가능합니다. 주의 사항 강사.</target>
        </trans-unit>
        <trans-unit id="33bd7c44464b83d74ae2002b960a112388650681" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the &lt;code&gt;Encode&lt;/code&gt; extension for that.</source>
          <target state="translated">이것은 범용 유니 코드 대 바이트 인코딩 인터페이스가 아닙니다.이를 위해 &lt;code&gt;Encode&lt;/code&gt; 확장을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f404a9e2e0db79bb4f43c8d7bbb05496d430ba62" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the Encode extension for that.</source>
          <target state="translated">이것은 일반적인 유니 코드에서 바이트 인코딩 인터페이스가 아닙니다.이를 위해 Encode 확장을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7457d8ee09385437d0b615e7e131b4e9c0b973a9" translate="yes" xml:space="preserve">
          <source>This is not a general purpose byte encoding to Unicode interface: use the Encode extension for that.</source>
          <target state="translated">이것은 유니 코드 인터페이스에 대한 범용 바이트 인코딩이 아닙니다.이를 위해 Encode 확장을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4bba8250f7720ad535561da71f3cfe66f5ce3b19" translate="yes" xml:space="preserve">
          <source>This is not actually a Unicode-specified obsolescence, but applies to certain Perl extensions that are present for backwards compatibility, but are discouraged from being used. These are not obsolete, but their meanings are not stable. Future Unicode versions could force any of these extensions to be removed without warning, replaced by another property with the same name that means something different. An '&lt;b&gt;X&lt;/b&gt;' flags each such entry in the table. Use the equivalent shown instead.</source>
          <target state="translated">이것은 실제로 유니 코드로 지정된 노후화가 아니지만 이전 버전과의 호환성을 위해 존재하지만 사용을 권장하지 않는 특정 Perl 확장에 적용됩니다. 이것들은 구식이 아니지만 그 의미는 안정적이지 않습니다. 향후 유니 코드 버전은 경고없이 이러한 확장을 강제로 제거하고 다른 것을 의미하는 동일한 이름을 가진 다른 속성으로 대체 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ' &lt;b&gt;X&lt;/b&gt; '는 테이블의 각 항목에 플래그를 지정합니다. 대신 표시된 동등한 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d116bb6d0c3c84c2243b689bc93fe4a6155eb5cb" translate="yes" xml:space="preserve">
          <source>This is not as short as before, but it makes it more obvious that we intend to have little-endian byte-order for a whole group, not only for individual template codes. It can also be more readable and easier to maintain.</source>
          <target state="translated">이것은 이전만큼 짧지는 않지만 개별 템플릿 코드뿐만 아니라 전체 그룹에 리틀 엔디안 바이트 순서를 가지고 있음을 더 분명하게합니다. 또한 더 읽기 쉽고 유지 관리하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="21c82389f9ec1dc190c296dba01242b89223a846" translate="yes" xml:space="preserve">
          <source>This is not ideal, but it seems to be the best compromise. If it doesn't work for you, please let me know the details of how it broke.</source>
          <target state="translated">이것은 이상적이지는 않지만 최선의 절충안 인 것 같습니다. 그래도 문제가 해결되지 않으면 어떻게 파산했는지 자세히 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="a8f2331f9105fa67d4e126b8930145be58fae503" translate="yes" xml:space="preserve">
          <source>This is not ok:</source>
          <target state="translated">이것은 좋지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="909f3f0de148a4f0a784930ff89af77cea3c7576" translate="yes" xml:space="preserve">
          <source>This is not really a &quot;severe&quot; error, but it is supposed to be raised by default even if warnings are not enabled, and currently the only way to do that in Perl is to mark it as serious.</source>
          <target state="translated">이 오류는 실제로 &quot;심각한&quot;오류는 아니지만 경고를 사용하지 않는 경우에도 기본적으로 발생해야하며 현재 Perl에서이를 수행하는 유일한 방법은 오류로 심각하게 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b98cc8fd878d4e526c57ff147de3c4320ff2bb7" translate="yes" xml:space="preserve">
          <source>This is not required, but is recommended in case any code is called which may reset or alter &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">필수는 아니지만 &lt;code&gt;$@&lt;/code&gt; 재설정하거나 변경할 수있는 코드가 호출되는 경우 권장됩니다 .</target>
        </trans-unit>
        <trans-unit id="99cb1cc350f7652ef06061348fb3eea6152592f9" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 어휘 텍스트를 사용하는 일반적인 방법이 아닙니다. 이를 위해 &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="197111743c19bce55304223ee2f18830ead89426" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;.</source>
          <target state="translated">이것은 어휘 텍스트를 소비하는 일반적인 방법이 아닙니다. 이를 위해 &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f9e6c0b666a1af0815bd174af9f121c2162997f" translate="yes" xml:space="preserve">
          <source>This is not the right answer at all, but the sum looks correct. I wonder if it's anything to do with operator precedence? We'll try a couple of other possibilities with our sum:</source>
          <target state="translated">이것은 정답이 아니지만 합계는 정확 해 보입니다. 연산자 우선 순위와 관련이 있는지 궁금합니다. 우리는 우리의 합으로 몇 가지 다른 가능성을 시도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a04fbe62aa8087e67610ad69a72c7364e385eaa" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt; . That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">&lt;code&gt;$#array&lt;/code&gt; 와 같이 마지막 색인을 얻기 위해 배열 이름 앞에서 사용하는 시일이 아닙니다 . 그것이 여전히 Perl에서 배열의 마지막 인덱스를 얻는 방법입니다. 두 사람은 서로 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0152b6d921fb917b16faa5b33711753db7914ad7" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt;. That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">이것은 &lt;code&gt;$#array&lt;/code&gt; 와 같이 마지막 인덱스를 얻기 위해 배열 이름 앞에 사용하는시길이 아닙니다 . 이것이 Perl에서 배열의 마지막 인덱스를 얻는 방법입니다. 두 사람은 서로 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a71eefb6bc615d22ea75cd4d866e05c590f48f94" translate="yes" xml:space="preserve">
          <source>This is not to say that Perl threads are completely different from everything that's ever come before. They're not. Perl's threading model owes a lot to other thread models, especially POSIX. Just as Perl is not C, though, Perl threads are not POSIX threads. So if you find yourself looking for mutexes, or thread priorities, it's time to step back a bit and think about what you want to do and how Perl can do it.</source>
          <target state="translated">이것은 Perl 스레드가 이전의 모든 것과 완전히 다르다는 것을 말하는 것은 아닙니다. 그들은 아니다. Perl의 스레딩 모델은 다른 스레드 모델, 특히 POSIX에 많이 의존합니다. Perl이 C가 아닌 것처럼 Perl 스레드는 POSIX 스레드가 아닙니다. 따라서 뮤텍스 또는 스레드 우선 순위를 찾고 있다면 조금 뒤로 물러서서 원하는 것을하고 Perl이 어떻게 할 수 있는지 생각할 때입니다.</target>
        </trans-unit>
        <trans-unit id="1490fa72c1eafb91d46399cb68efda52398b105d" translate="yes" xml:space="preserve">
          <source>This is not very useful, and perl currently optimizes this away.</source>
          <target state="translated">이것은별로 유용하지 않으며 perl은 현재이를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="719ad110f9ecd2d06449f518fe559ae60b466e21" translate="yes" xml:space="preserve">
          <source>This is now the recommended interface to install().</source>
          <target state="translated">이것은 현재 install ()에 권장되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8dd3c5aefc65986cd4924a120675ce7dc9b1881f" translate="yes" xml:space="preserve">
          <source>This is of paramount importance, since it's the documentation of what goes where in the Perl source. Read it over a couple of times and it might start to make sense - don't worry if it doesn't yet, because the best way to study it is to read it in conjunction with poking at Perl source, and we'll do that later on.</source>
          <target state="translated">이것은 Perl 소스에서 어디로 가는지에 대한 문서이므로 가장 중요합니다. 두 번 이상 읽으면 이해하기 시작할 수 있습니다. 아직 이해가되지 않아도 걱정하지 마십시오. 공부하는 가장 좋은 방법은 Perl 소스에서 파킹과 함께 읽는 것이므로 우리는 할 것입니다. 나중에.</target>
        </trans-unit>
        <trans-unit id="5903d2508c471509c3a8871c1121aaa61b5835b7" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">이것은 이전 버전의 Perl에서 작동하지 않는 라이브러리 모듈을 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 하기 전에 현재 Perl 버전을 확인해야 할 때 유용합니다 . (우리는해야 할 것보다 더 많이하지 않으려 고 노력합니다.)</target>
        </trans-unit>
        <trans-unit id="fadd54f30e37dbf502c0a6893df00ea6b04ab979" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">이전 버전의 Perl에서 작동하지 않는 라이브러리 모듈을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하기 전에 현재 Perl 버전을 확인해야하는 경우에 유용합니다 . (우리는 이보다 더 많은 일을하지 않기 위해 노력합니다.)</target>
        </trans-unit>
        <trans-unit id="96345383ecfecda78d417eea671d77452c1d163e" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">이전 버전의 Perl에서 작동하지 않는 라이브러리 모듈을 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하기 전에 현재 Perl 버전을 확인해야하는 경우에 유용합니다 . (우리는 이보다 더 많은 일을하지 않기 위해 노력합니다.)</target>
        </trans-unit>
        <trans-unit id="b7065d0815c75fb916f5ccef644a97fc5f9a5ab5" translate="yes" xml:space="preserve">
          <source>This is one of the cases we mentioned earlier in which references could spring into existence when in an lvalue context. Before this statement, &lt;code&gt;$array[$x]&lt;/code&gt; may have been undefined. If so, it's automatically defined with a hash reference so that we can look up &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; in it. Likewise &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; will automatically get defined with an array reference so that we can look up &lt;code&gt;[0]&lt;/code&gt; in it. This process is called</source>
          <target state="translated">이것은 lvalue 컨텍스트에서 참조가 생길 수있는 앞에서 언급 한 사례 중 하나입니다. 이 문장 이전에 &lt;code&gt;$array[$x]&lt;/code&gt; 가 정의되지 않았을 수 있습니다. 그렇다면 해시 참조로 자동 정의되므로 &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; 를 찾을 수 있습니다. 마찬가지로 &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; 는 배열 참조로 자동 정의되므로 &lt;code&gt;[0]&lt;/code&gt; 을 찾을 수 있습니다. 이 과정을</target>
        </trans-unit>
        <trans-unit id="6a3344e74e174252dc0aef67360fb712feea83d3" translate="yes" xml:space="preserve">
          <source>This is one of the only places where giving a prototype to a closure makes much sense. If you wanted to impose scalar context on the arguments of these functions (probably not a wise idea for this particular example), you could have written it this way instead:</source>
          <target state="translated">클로저에 프로토 타입을 제공하는 것이 의미가있는 유일한 곳 중 하나입니다. 이러한 함수의 인수에 스칼라 컨텍스트를 적용하려면 (이 특정 예제에서는 현명한 아이디어가 아닐 수도 있음) 대신 다음과 같이 작성했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e82904f13aaec8c8bc429b12fde4bbb0fe088f" translate="yes" xml:space="preserve">
          <source>This is only needed when converting a metadata fragment that does not include a &lt;code&gt;meta-spec&lt;/code&gt; field.</source>
          <target state="translated">이는 &lt;code&gt;meta-spec&lt;/code&gt; 필드를 포함하지 않는 메타 데이터 조각을 변환 할 때만 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="8815273ee560d0448d9c01c105592b19a9f70fd8" translate="yes" xml:space="preserve">
          <source>This is only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. It is the $Config{byteorder} string of the perl that created this image. It is a string like &quot;1234&quot; (32 bit little endian) or &quot;87654321&quot; (64 bit big endian). This must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">&lt;code&gt;netorder&lt;/code&gt; 가 FALSE 인 경우에만 존재 합니다. 이 이미지를 작성한 펄의 $ Config {byteorder} 문자열입니다. &quot;1234&quot;(32 비트 리틀 엔디안) 또는 &quot;87654321&quot;(64 비트 빅 엔디안)과 같은 문자열입니다. Storable이 이미지를 읽을 수있게하려면 현재 perl과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="84ff724c95d2598efdb8d7d443f2851d8e9c24b5" translate="yes" xml:space="preserve">
          <source>This is only required on some platforms which do not handle dependent libraries automatically. For example the Socket Perl extension library (</source>
          <target state="translated">종속 라이브러리를 자동으로 처리하지 않는 일부 플랫폼에서만 필요합니다. 예를 들어 Socket Perl 확장 라이브러리 (</target>
        </trans-unit>
        <trans-unit id="3167fd37c36e8874785bfe9f3f3013cce7f288bd" translate="yes" xml:space="preserve">
          <source>This is open source software. The code repository is available for public review and contribution under the terms of the license.</source>
          <target state="translated">이것은 오픈 소스 소프트웨어입니다. 코드 저장소는 라이센스 조건에 따라 공개 검토 및 기고가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bcfe5a91a20366b07a20b45c08c83d2cb3335747" translate="yes" xml:space="preserve">
          <source>This is our final regexp. To recap, we built a regexp by</source>
          <target state="translated">이것이 최종 정규 표현식입니다. 요약하자면, 우리는 정규 표현식을</target>
        </trans-unit>
        <trans-unit id="55cbe19c15cda5405c9b99032930566aa6e4cd4b" translate="yes" xml:space="preserve">
          <source>This is parsed as:</source>
          <target state="translated">이것은 다음과 같이 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="4f7853da7a16df56ba94a3f89eeeb6c41db7cabc" translate="yes" xml:space="preserve">
          <source>This is partially implemented now.</source>
          <target state="translated">이것은 부분적으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a6f22dd0203804895067e4cd94d48784411f916" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">이것은 구성 파일에서 읽거나, 인수에서 가져 오거나, 어딘가에 테이블에 지정된 것과 같은 동적 패턴에 특히 유용합니다. 대소 문자를 구분하지 않는 일부 패턴은 대소 문자를 구분하지 않으려는 경우를 고려하십시오. 대소 문자를 구분하지 않는 패턴은 패턴 앞에 &lt;code&gt;(?i)&lt;/code&gt; 만 포함 하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9a8ef21b0f21974a251d0cd49767a5e49f56bc4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamically-generated patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">이는 구성 파일에서 읽거나 인수에서 가져 오거나 테이블 어딘가에 지정된 것과 같이 동적으로 생성 된 패턴에 특히 유용합니다. 일부 패턴은 대소 문자를 구분하고 일부는 구분하지 않는 경우를 고려하십시오. 대소 문자를 구분하지 않는 패턴은 패턴 앞에 &lt;code&gt;(?i)&lt;/code&gt; 를 포함하기 만하면됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaa59114ea7716b61a1b0ecf212fbfdac38cd5ec" translate="yes" xml:space="preserve">
          <source>This is particularly useful if you have More Than One Way (tm) to solve a problem in a program, and only wish to continue down a path if all modules could be loaded, and not load them if they couldn't.</source>
          <target state="translated">프로그램에서 문제를 해결하기 위해 여러 가지 방법 (tm)이 있고 모든 모듈을로드 할 수있는 경우 경로를 계속 진행하고로드 할 수없는 경우로드하지 않으려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f5141125aa28c42d6dec636c32fcbaa85fe78c3" translate="yes" xml:space="preserve">
          <source>This is particularly useful when applied to code references returned from reval().</source>
          <target state="translated">reval ()에서 반환 된 코드 참조에 적용 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3afdcef939cf6d1f8b0ef2be038cdb0c7d7984fa" translate="yes" xml:space="preserve">
          <source>This is powerful, and slightly dangerous, in that it's possible to intend (with the utmost sincerity) to use a hard reference, and accidentally use a symbolic reference instead. To protect against that, you can say</source>
          <target state="translated">이것은 강력하고 약간 위험합니다. (최대한 성실로) 단단한 참조를 사용하고 실수로 기호 참조를 사용하는 것이 가능합니다. 그것을 막기 위해, 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1d61b3fe5532441244041a6185a4d7b90b80ec48" translate="yes" xml:space="preserve">
          <source>This is primarily meant for the use of modules such as FTP where passwords are sent, but we do not want to display them in the debugging information.</source>
          <target state="translated">이것은 주로 암호가 전송되는 FTP와 같은 모듈을 사용하기위한 것이지만 디버깅 정보에는 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01c91853268ed50e9d0a33c6896652af44de4d99" translate="yes" xml:space="preserve">
          <source>This is primarily of use for people who repackage Perl modules.</source>
          <target state="translated">이것은 주로 Perl 모듈을 다시 포장하는 사람들에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="831dab0bf255edc5ba7e605462344bdbe78142e8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">이것은 최근에 일치 한 텍스트를 검사하기 위해 &lt;code&gt;(?{...})&lt;/code&gt; 블록 내부에서 주로 사용됩니다 . 예를 들어 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 의 변수에 텍스트를 효과적으로 캡처하려면 &lt;code&gt;(...)&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="785aba462ddf893b4d7d212c5fc066f6e4b29bd8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">이것은 주로 최근 일치 된 텍스트를 검사하기 위해 &lt;code&gt;(?{...})&lt;/code&gt; 블록 내부에서 사용됩니다 . 예를 들어, 텍스트를 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등) 에 효과적으로 캡처하려면 &lt;code&gt;(...)&lt;/code&gt; 를 다음으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="471731e21edc337b491a7b40340da72650201ff9" translate="yes" xml:space="preserve">
          <source>This is primarily used when you need to make several actions atomic (against some signals anyway).</source>
          <target state="translated">이것은 (어쨌든 일부 신호에 대해) 여러 작업을 원자 적으로 만들어야 할 때 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43405231d7a3fc726c046090388674dddde66ec5" translate="yes" xml:space="preserve">
          <source>This is primarily useful for install scripts.</source>
          <target state="translated">이것은 주로 설치 스크립트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="71555351eedbd86160cbba934f94d326494c3535" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; in perl sources.</source>
          <target state="translated">이것은 printf ()와 동일합니다. printf는이 함수에 # 정의되어 있으므로, 현재 perl 소스에서 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="5a921444f0499fb36eee87f18490349a0c0c08e2" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;printf(fmt,...)&lt;/code&gt; in perl sources.</source>
          <target state="translated">이것은 printf ()와 동일합니다. printf는 #이 함수에 정의되어 있으므로 (현재) perl 소스에서 &lt;code&gt;printf(fmt,...)&lt;/code&gt; 를 사용하는 것이 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="4ea35349c6ed8d6a98b7de634d09f57721480861" translate="yes" xml:space="preserve">
          <source>This is private to the Perl core and subject to change. Should be left null.</source>
          <target state="translated">이것은 Perl 코어 전용이며 변경 될 수 있습니다. null로 남겨 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="a42a74dee5bfb28b5a2d265ff8a638902c0a2d41" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;&quot;sv_setpvn&quot;&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;&quot;sv_setpvs&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 아마도 여러분이 사용하고 싶은 것이 아닐 것입니다. 아마도 &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvn&quot;&gt;&quot;sv_setpvn&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvs&quot;&gt;&quot;sv_setpvs&quot;를 원했을 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98fa02440d9fac9b73c470e7ca881854b6795009" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;.</source>
          <target state="translated">이것은 아마도 당신이 사용하려는 것이 아니며, 아마도 &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs를 원했을 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="697287005f5cb5ed6d011d9e5061126f21f55b05" translate="yes" xml:space="preserve">
          <source>This is provided as a more readable version of &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt; 의보다 읽기 쉬운 버전으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cabb9b2376d3134de9c8bd807fc2548baba2fca" translate="yes" xml:space="preserve">
          <source>This is quite different, however, from not even trusting the writer of the code not to try to do something evil. That's the kind of trust needed when someone hands you a program you've never seen before and says, &quot;Here, run this.&quot; For that kind of safety, you might want to check out the Safe module, included standard in the Perl distribution. This module allows the programmer to set up special compartments in which all system operations are trapped and namespace access is carefully controlled. Safe should not be considered bullet-proof, though: it will not prevent the foreign code to set up infinite loops, allocate gigabytes of memory, or even abusing perl bugs to make the host interpreter crash or behave in unpredictable ways. In any case it's better avoided completely if you're really concerned about security.</source>
          <target state="translated">그러나 이것은 악의적 인 일을하지 않기 위해 코드 작성자를 신뢰하지 않는 것과는 상당히 다릅니다. 그것은 당신이 전에 보지 못했던 프로그램을 누군가가 당신에게 건네 줄 때 필요한 신뢰입니다. &quot;여기, 이것을 실행하십시오.&quot; 이러한 종류의 안전을 위해 Perl 배포에 표준이 포함 된 안전 모듈을 확인하십시오. 이 모듈을 통해 프로그래머는 모든 시스템 작업이 갇히고 네임 스페이스 액세스가 신중하게 제어되는 특수 구획을 설정할 수 있습니다. 안전은 방탄으로 간주되어서는 안됩니다. 외부 코드가 무한 루프를 설정하거나 기가 바이트의 메모리를 할당하거나 펄 버그를 학대하여 호스트 인터프리터가 충돌하거나 예측할 수없는 방식으로 작동하지 못하게하지는 않습니다. 어쨌든 보안에 정말로 관심이 있다면 완전히 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="50d419167936516f6bf9a1f029bd288bcc5eb141" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">이것은 .xs 파일의 경우 매우 일반적입니다. 일반적으로 .xs 파일은 기존 C 함수에 대한 인터페이스를 제공합니다. 그런 다음이 C 함수는 어딘가 (외부 라이브러리 또는 .xs 파일의 첫 번째 부분)에 정의되고이 함수에 대한 Perl 인터페이스 (예 : &quot;Perl glue&quot;)는 .xs 파일의 두 번째 부분에 설명되어 있습니다. 모든 작업이 &quot;Perl glue&quot;내부에서 수행 되는 &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt; 및 &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt; 의 상황은 규칙 이라기보다는 다소 예외입니다.</target>
        </trans-unit>
        <trans-unit id="fc844a09760bd8a2dc9b577b36da09548b575605" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">이것은 .xs 파일의 경우 매우 일반적입니다. 일반적으로 .xs 파일은 기존 C 함수에 대한 인터페이스를 제공합니다. 그런 다음이 C 함수는 외부 라이브러리 또는 .xs 파일의 첫 부분에 정의되어 있으며이 함수에 대한 Perl 인터페이스 (예 : &quot;Perl glue&quot;)는 .xs 파일의 두 번째 부분에 설명되어 있습니다. &quot;Perl glue&quot;내에서 모든 작업이 수행 되는 &lt;a href=&quot;#EXAMPLE-1&quot;&gt;예 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;예 2&lt;/a&gt; 및 &lt;a href=&quot;#EXAMPLE-3&quot;&gt;예 3&lt;/a&gt; 의 상황은 규칙이 아닌 다소 예외입니다.</target>
        </trans-unit>
        <trans-unit id="c3a982ed6685f74bf9f57db540f3caed5035dcd6" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt; , it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">이것은 일반적으로 가독성을 향상시키기 때문에 매우 유용합니다. 이것은 &lt;code&gt;SV *&lt;/code&gt; 에 잘 작동하지만 불행히도 &lt;code&gt;AV *&lt;/code&gt; 또는 &lt;code&gt;HV *&lt;/code&gt; 를 반환 값으로 갖는 것은 쉽지 않습니다 . 당신</target>
        </trans-unit>
        <trans-unit id="02c1d462530bf64748def6c496de1d6240bfa91b" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt;, it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">이것은 일반적으로 가독성을 향상시키기 때문에 매우 유용합니다. 이것은 &lt;code&gt;SV *&lt;/code&gt; 에서는 잘 작동하지만 , 불행히도 &lt;code&gt;AV *&lt;/code&gt; 또는 &lt;code&gt;HV *&lt;/code&gt; 를 반환 값으로 사용하는 것은 쉽지 않습니다 . 당신</target>
        </trans-unit>
        <trans-unit id="df9aa2c2c409f58ba99139ca42f157f4afdf7a29" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">이것은 거의 사용되지 않습니다. 때로는 E &amp;lt;...&amp;gt; 코드를 사용하여 돌아 다니는 한 가지 방법입니다. 예를 들어 &quot;N &amp;lt;3 &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; &quot;( &quot;N &amp;lt;3&quot;의 경우) 대신 &quot; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot;( &quot;Z &amp;lt;&amp;gt;&quot;은 &quot;N&quot;과 &quot;&amp;lt;&quot;을 구분하므로 (가상) &quot;N &amp;lt;...&amp;gt;&quot;코드의 일부로 간주 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c3972509e727368d3c5e9a50516482551fe729d" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt;&quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">이것은 거의 사용되지 않습니다. 때때로 E &amp;lt;...&amp;gt; 코드를 사용하여 돌아 다니는 한 가지 방법입니다. 예를 들어, &quot; &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; &quot;( &quot;N &amp;lt;3&quot;의 경우) 대신 &quot; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot;( &quot;Z &amp;lt;&amp;gt;&quot;는 &quot;N&quot;과 &quot;&amp;lt;&quot;를 분리하여 (가상) &quot;N &amp;lt;...&amp;gt;&quot;코드의 일부로 간주 될 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="5c569493cb06e371332b5d2d180bdd4a7a876b1d" translate="yes" xml:space="preserve">
          <source>This is required by some servers. For example if you are connecting to an INN server and you have transfer permission your connection will be connected to the transfer daemon, not the NNTP daemon. Issuing this command will cause the transfer daemon to hand over control to the NNTP daemon.</source>
          <target state="translated">이것은 일부 서버에서 필요합니다. 예를 들어, INN 서버에 연결 중이고 전송 권한이 있으면 연결이 NNTP 데몬이 아닌 전송 데몬에 연결됩니다. 이 명령을 실행하면 전송 데몬이 제어를 NNTP 데몬으로 넘겨줍니다.</target>
        </trans-unit>
        <trans-unit id="cbdfb46249e842a142c962c6d9643c65a18e64d0" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems &lt;code&gt;/tmp&lt;/code&gt; is not owned by root.</source>
          <target state="translated">많은 유닉스 시스템에서 &lt;code&gt;/tmp&lt;/code&gt; 는 루트가 소유하지 않기 때문에 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="1aba726220151e0bdd8e20f672a38f3cb853c543" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems C is not owned by root.</source>
          <target state="translated">많은 유닉스 시스템에서 C는 루트가 소유하지 않기 때문에 이것은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="53e759494f9bf8d7efd9149cfc161ebbf71db524" translate="yes" xml:space="preserve">
          <source>This is safer than and replaces the &quot;no_plan&quot; plan.</source>
          <target state="translated">이것은 &quot;no_plan&quot;계획보다 안전하며이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ce8477bd1dd658eb92098ae32e26b04afeab44b4" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;new()&lt;/code&gt;, except that &lt;code&gt;generated_by&lt;/code&gt; and &lt;code&gt;meta-spec&lt;/code&gt; fields will be generated if not provided. This means the metadata structure is assumed to otherwise follow the latest &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;.</source>
          <target state="translated">이것은 동일하다 &lt;code&gt;new()&lt;/code&gt; 것 이외에는 &lt;code&gt;generated_by&lt;/code&gt; 및 &lt;code&gt;meta-spec&lt;/code&gt; 제공되지 않는 경우, 필드가 생성된다. 즉, 메타 데이터 구조가 최신 &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec을&lt;/a&gt; 따르는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7ebcb8463dd98d519e70a00c26fec5b1949c87c" translate="yes" xml:space="preserve">
          <source>This is seldom necessary, though, because this is done automatically, like when you access an array:</source>
          <target state="translated">그러나 배열에 액세스 할 때와 같이 자동으로 수행되므로 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b39df7c425593c524473bd917a5316f755e7f35" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;true&lt;/code&gt; in</source>
          <target state="translated">이것은 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bda100b399c447a02432db64ae424bebb5a77bb3" translate="yes" xml:space="preserve">
          <source>This is set to a true value. It allows the tests to determine if they are being executed through the harness or by any other means.</source>
          <target state="translated">이것은 실제 값으로 설정됩니다. 테스트를 통해 하네스 또는 다른 수단으로 실행되고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784e1d59cc78e03dfce5c4eb5ddb5046b2ae8797" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, &lt;a href=&quot;http://man.he.net/man1/grep&quot;&gt;grep(1)&lt;/a&gt; and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">이것은 정신적으로는 &lt;a href=&quot;http://man.he.net/man1/grep&quot;&gt;grep (1)&lt;/a&gt; 및 그 친척과 비슷하지만 같지는 않습니다 . 특히 정규식 사용에 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8825b383410611d9ab88c7c6da41a37ab67b7bd2" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, grep(1) and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">이것은 grep (1) 및 그 친척과 동일하지만 동일하지는 않습니다. 특히 정규식을 사용하는 것으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">이것은 비슷합니다</target>
        </trans-unit>
        <trans-unit id="3e6ba00cc4274369aaec7e06e964eb77cd40c12d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이것은 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; ( &lt;code&gt;$MATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b7e216fa4594cbacfaf20854b0ab30d1c8d5c1e2" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt;) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하면 &lt;code&gt;$&amp;amp;&lt;/code&gt; ( &lt;code&gt;$MATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="95e9006abb746eec00ddbe6c7b21cfe4ec62c97b" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$'&lt;/code&gt; ( &lt;code&gt;$POSTMATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="6fd5c8a1ee96062bbcb6f2a27266f07276bffe2f" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt;) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하면 &lt;code&gt;$'&lt;/code&gt; ( &lt;code&gt;$POSTMATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="62e38c00b725c5a13563494b1438770078513b03" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$`&lt;/code&gt; ($PREMATCH) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$`&lt;/code&gt; ($ PREMATCH) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b7b04635104076e8869c03a97df7510eda62d809" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 이 이름의 메소드가 더 이상 존재하지 않음을 나타 내기 위해 코드 참조 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="c76a101755f29c4620b6ee3b21e4e2a7b2d96005" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;next::method&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;undef&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">&lt;code&gt;next::method&lt;/code&gt; 와 유사 하지만 이 이름의 더 이상 메서드가 없음을 나타 내기 위해 코드 참조 또는 &lt;code&gt;undef&lt;/code&gt; 중 하나만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f73fed07cf9661cd5a76d43367f7870e1dfd1e63" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt; . The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">이것은 &lt;code&gt;string_vianame&lt;/code&gt; 과 유사합니다 . 가장 큰 차이점은 대부분의 상황에서,이다 &lt;code&gt;vianame&lt;/code&gt; 는 반면, 서수 코드 포인트를 반환 &lt;code&gt;string_vianame&lt;/code&gt; 의 반환 문자열. 예를 들어</target>
        </trans-unit>
        <trans-unit id="035b09da2ed8ab563a4781cdc8cd00f1a372a968" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt;. The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">이것은 &lt;code&gt;string_vianame&lt;/code&gt; 과 유사합니다 . 가장 큰 차이점은 대부분의 상황에서,이다 &lt;code&gt;vianame&lt;/code&gt; 는 반면, 서수 코드 포인트를 반환 &lt;code&gt;string_vianame&lt;/code&gt; 의 반환 문자열. 예를 들면</target>
        </trans-unit>
        <trans-unit id="82735301d82a0dc4313bb1d53ad031d27f023c2f" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">이것은 요청에 따라 형식이 지정된 인수를 가진 문자열을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 함수 와 유사합니다 (&lt;a href=&quot;functions/sprintf&quot;&gt; sprintf&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4a0b7112ac62ec6b0732258b7ebbd4369edb185a" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;sprintf()&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;perlfunc#sprintf&quot;&gt;&quot;sprintf&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">이것은 요청 된 형식의 인수가있는 문자열을 반환하기위한 Perl의 내장 &lt;code&gt;sprintf()&lt;/code&gt; 함수 와 유사합니다 . &lt;a href=&quot;perlfunc#sprintf&quot;&gt;perlfunc의 &quot;sprintf&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb9fc002d8f7d1fdb8d39dcb8cc96f69462055b3" translate="yes" xml:space="preserve">
          <source>This is similar to calling the &lt;code&gt;x&lt;/code&gt; command on each applicable var.</source>
          <target state="translated">이것은 적용 가능한 각 var 에서 &lt;code&gt;x&lt;/code&gt; 명령 을 호출하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c882c2e2c2f32205e6402773c4c5a8648cf274ab" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Perl 6. Like &lt;code&gt;(*PRUNE)&lt;/code&gt; , this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">이것은 Perl 6 의 &quot;cut group&quot;연산자 &lt;code&gt;::&lt;/code&gt; 와 유사합니다. &lt;code&gt;(*PRUNE)&lt;/code&gt; 처럼 ,이 동사는 항상 일치하며, 실패시 역 추적 할 때 정규식 엔진이 가장 안쪽의 묶음 그룹에서 다음 번 대체를 시도합니다 ( 교체 또는 다른 방법). &lt;code&gt;(*THEN)&lt;/code&gt; 에 관한 한, &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; 의 2 개의 분기 는 교대로 간주되지 않는다 .</target>
        </trans-unit>
        <trans-unit id="789212497ee1cf1f776a732c31bef719dc8f5cde" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Raku. Like &lt;code&gt;(*PRUNE)&lt;/code&gt;, this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)&lt;i&gt;yes-pattern&lt;/i&gt;|&lt;i&gt;no-pattern&lt;/i&gt;)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">이것은 Raku 의 &quot;컷 그룹&quot;연산자 &lt;code&gt;::&lt;/code&gt; 와 유사합니다 . &lt;code&gt;(*PRUNE)&lt;/code&gt; 와 마찬가지로이 동사는 항상 일치하며 실패시 역 추적 될 때 정규식 엔진이 교체가있는 가장 안쪽에있는 그룹 (캡처 또는 기타)에서 다음 교체를 시도하도록합니다. &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)&lt;i&gt;yes-pattern&lt;/i&gt;|&lt;i&gt;no-pattern&lt;/i&gt;)&lt;/code&gt; 의 두 가지 분기는 &lt;code&gt;(*THEN)&lt;/code&gt; 에 관한 한 교대로 계산되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b23340a8a44f500f9fdd2f514353aafef1f1600" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt; , for duplicating a file descriptor.</source>
          <target state="translated">이것은 파일 기술자를 복제하는 C 함수 &lt;code&gt;dup()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ae6596049dbd554c0142eb69dbcbdccd65d36765" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt;, for duplicating a file descriptor.</source>
          <target state="translated">이것은 파일 설명자를 복제하기위한 C 함수 &lt;code&gt;dup()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="bc59e25f670eb40f71d53b45961566d88e8da8a1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt; , for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">이것은 다른 알려진 파일 디스크립터에 파일 디스크립터를 복제하기위한 C 함수 &lt;code&gt;dup2()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f1e6999776f77cce2c537978df0c9c5950783832" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt;, for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">이것은 파일 설명자를 다른 알려진 파일 설명자에 복제하는 C 함수 &lt;code&gt;dup2()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ae23dd5fc0059c09ec24ea0c5ef5acb6d58fa1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;mkfifo()&lt;/code&gt; for creating FIFO special files.</source>
          <target state="translated">이것은 FIFO 특수 파일 작성을위한 C 함수 &lt;code&gt;mkfifo()&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="cb82e089ae466005cc0dc383a964501667069da5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt; , for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">이것은 현재 프로세스의 스케줄링 환경 설정을 변경 하는 C 함수 &lt;code&gt;nice()&lt;/code&gt; 와 유사합니다 . 긍정적 인 주장은 더 정중 한 과정을 의미하고, 부정적인 가치는 더 필요한 과정을 의미합니다. 루트가 아닌 일반 사용자 프로세스는 더 정중 한 방향으로 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0808a5ff368707577d5e1f0e5bcb31b1f6ad15" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt;, for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">이것은 현재 프로세스의 스케줄링 환경 설정을 변경하기위한 C 함수 &lt;code&gt;nice()&lt;/code&gt; 와 유사합니다 . 긍정적 인 주장은 더 공손한 과정을 의미하고, 부정적인 가치는 더 필요한 과정을 의미합니다. 일반 (루트가 아닌) 사용자 프로세스는 더 정중하게 변경 될 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
