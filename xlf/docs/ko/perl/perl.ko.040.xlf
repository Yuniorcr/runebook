<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9adb69905ef42f7e50e2708e20623f57aec71e19" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 6. This value is manually set in</source>
          <target state="translated">5.6.2와 같은 Perl 버전 번호는 6입니다.이 값은</target>
        </trans-unit>
        <trans-unit id="00e75241de38f496d3e98c78e65b223be163fce0" translate="yes" xml:space="preserve">
          <source>In a UTF-8 locale in v5.20 and later, the only visible difference between locale and non-locale in regular expressions should be tainting (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;).</source>
          <target state="translated">v5.20 이상의 UTF-8 로케일에서 정규식에서 로케일과 로케일이 아닌 유일한 차이는 오염이어야합니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="684ae84268e30b89f35130d6bd4027aeb36b7294" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt; , and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">정규 표현식 패턴의 대괄호로 묶은 문자 클래스에서 &lt;code&gt;\N{}&lt;/code&gt; 사용하여 정확히 한 쪽 끝이 지정되고 다른 쪽 끝은 이식 불가능한 메커니즘을 사용하여 지정됩니다. Perl은 범위를 유니 코드 범위로 취급합니다. 즉, 범위 내의 모든 문자는 유니 코드 문자로 간주되며 Perl이 실행되는 일부 플랫폼에서 다른 코드 포인트 일 수 있습니다. 예를 들어, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; 은 &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; 이라고 말한 것처럼 취급됩니다. 즉 , 코드 포인트가있는 문자와 일치합니다 유니 코드의 6, 7, 8입니다. 그러나 &lt;code&gt;\x08&lt;/code&gt; 은 다른 의미를 나타낼 수 있으므로 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56b5f943e2723e6656ff71443d600b126557a979" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt;, and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt;, that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">정규식 패턴의 대괄호 문자 클래스에는 &lt;code&gt;\N{}&lt;/code&gt; 사용하여 정확히 한쪽 끝이 지정된 범위가 있고 다른 쪽 끝은 이식 불가능한 메커니즘을 사용하여 지정되었습니다. Perl은 범위를 유니 코드 범위로 취급합니다. 즉, 그 안의 모든 문자는 유니 코드 문자로 간주되며 Perl이 실행되는 일부 플랫폼에서는 다른 코드 포인트 일 수 있습니다. 예를 들어, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; 은 대신 &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; 라고 말한 것처럼 취급됩니다. 즉 , 코드가 가리키는 문자와 일치합니다. 유니 코드에서는 6, 7, 8입니다.하지만 &lt;code&gt;\x08&lt;/code&gt; 은 당신이 뭔가 다른 것을 의미했음을 나타낼 수 있으므로 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94d73a68cf480ae509179c7a8fbc1f901fa2e9db" translate="yes" xml:space="preserve">
          <source>In a chained comparison, each argument expression is evaluated at most once, even if it takes part in two comparisons, but the result of the evaluation is fetched for each comparison. (It is not evaluated at all if the short-circuiting means that it's not required for any comparisons.) This matters if the computation of an interior argument is expensive or non-deterministic. For example,</source>
          <target state="translated">연결 비교에서 각 인수 표현식은 두 비교에 참여하더라도 최대 한 번만 평가되지만 평가 결과는 각 비교에 대해 가져옵니다. (단락이 비교에 필요하지 않음을 의미하는 경우에는 전혀 평가되지 않습니다.) 이것은 내부 인수의 계산이 비싸거나 결정적이지 않은 경우 중요합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="1004ce202059ee590c51b52b194413677ea17ca4" translate="yes" xml:space="preserve">
          <source>In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element, as with the C comma operator. For example,</source>
          <target state="translated">리스트 값을 요구하지 않는 문맥에서리스트 리터럴로 보이는 것의 값은 단순히 C 쉼표 연산자와 마찬가지로 최종 요소의 값입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c0a278d73a0b72613c40dbe8d0193bd356d40954" translate="yes" xml:space="preserve">
          <source>In a first-hack implementation of Maketext, each language-module's lexicon looked like this:</source>
          <target state="translated">Maketext의 첫 번째 해킹 구현에서 각 언어 모듈의 어휘는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c9fb939bd1697123252f0ff4192d8603d7b42ba" translate="yes" xml:space="preserve">
          <source>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether.</source>
          <target state="translated">이후 버전의 Storable에서는 클래스에 대한 모듈로드를 비활성화하고 객체를 직렬화 해제하는 옵션을 제공 할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="7f48268e7084e302cd8de3636cf3c45d91f67d83" translate="yes" xml:space="preserve">
          <source>In a list context it returns a list of all the operator names. (Not yet implemented, use @names = opset_to_ops(full_opset).)</source>
          <target state="translated">목록 컨텍스트에서 모든 연산자 이름의 목록을 반환합니다. (아직 구현되지 않은 경우 @names = opset_to_ops (full_opset)을 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="b5d9986ae8bd12e0cac8222f9f5aeaf66d07a75b" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 객체 &lt;code&gt;$i&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="a2be3d9cfb3783d19a27056a4954efa7988e1874" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt;, and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 객체 인 &lt;code&gt;$i&lt;/code&gt; 반환 하고</target>
        </trans-unit>
        <trans-unit id="145c4668502bd10d7409835c5418f6cbabe20a25" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 스트림 &lt;code&gt;$i&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="19840bfce1f7d4562308d36f49b5b530cfea492a" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt;, and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 스트림 &lt;code&gt;$i&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="1cf4f84fa82dd8ae218d529ba322249a8b367063" translate="yes" xml:space="preserve">
          <source>In a list context, &lt;code&gt;extract_quotelike&lt;/code&gt; would return the list</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7602890513e241f884402d4ec0723dbc5ab2f461" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">목록 컨텍스트에서 모든 함수 는 실패시 &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; 를 반환 합니다. 스칼라 컨텍스트에서 실패는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환하여 표시됩니다. (이 경우 입력 텍스트는 어떤 식 으로든 수정되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="d4b6138bd9c8bc770c89fa1734f707bd100e5c6b" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(undef,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;undef&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">목록 컨텍스트에서 모든 함수 는 실패시 &lt;code&gt;(undef,$original_text)&lt;/code&gt; 를 반환 합니다. 스칼라 컨텍스트에서 실패는 &lt;code&gt;undef&lt;/code&gt; 를 반환하여 표시됩니다 (이 경우 입력 텍스트는 어떤 방식으로도 수정되지 않음).</target>
        </trans-unit>
        <trans-unit id="9a94ef45d6203b10b750123aea4390fcb5b00e20" translate="yes" xml:space="preserve">
          <source>In a list context, all the subroutines return a list, the first three elements of which are always:</source>
          <target state="translated">리스트 컨텍스트에서 모든 서브 루틴은리스트를 리턴하며 처음 세 요소는 항상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3d0f0be64532af27f8e2b721243720c0db92d9a" translate="yes" xml:space="preserve">
          <source>In a list context, an array of 11 elements is returned. The elements are:</source>
          <target state="translated">목록 컨텍스트에서 11 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="908708042ec2a982cddb96ed31208bb8910e08cf" translate="yes" xml:space="preserve">
          <source>In a nutshell, this will check whether the output code involves calling &lt;code&gt;sv_setiv&lt;/code&gt;, &lt;code&gt;sv_setuv&lt;/code&gt;, &lt;code&gt;sv_setnv&lt;/code&gt;, &lt;code&gt;sv_setpv&lt;/code&gt; or &lt;code&gt;sv_setpvn&lt;/code&gt; to set the special &lt;code&gt;$arg&lt;/code&gt; placeholder to a new value &lt;b&gt;AT THE END OF THE OUTPUT CODE&lt;/b&gt;. If that is the case, the code is eligible for using the &lt;code&gt;TARG&lt;/code&gt;-related macros to optimize this. Thus the name of the method: &lt;code&gt;targetable&lt;/code&gt;.</source>
          <target state="translated">간단히 말해서, 출력 코드가 &lt;code&gt;sv_setiv&lt;/code&gt; , &lt;code&gt;sv_setuv&lt;/code&gt; , &lt;code&gt;sv_setnv&lt;/code&gt; , &lt;code&gt;sv_setpv&lt;/code&gt; 또는 &lt;code&gt;sv_setpvn&lt;/code&gt; 을 호출 하여 특수 &lt;code&gt;$arg&lt;/code&gt; 자리 표시자를 &lt;b&gt;출력 코드 끝&lt;/b&gt; 에서 새 값 으로 설정 하는지 여부를 확인합니다 . 이 경우 코드는이 를 최적화하기 위해 &lt;code&gt;TARG&lt;/code&gt; 관련 매크로를 사용할 수 있습니다. 따라서 메소드의 이름 : &lt;code&gt;targetable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3d6cbfb7caf07ade67b0cd6e1a9dc2096892c7" translate="yes" xml:space="preserve">
          <source>In a pinch, if you cannot wait for Configure to be educated, or if you have a good hunch of where quux() might be available, you can temporarily try the following:</source>
          <target state="translated">핀치에서 Configure가 교육 될 때까지 기다릴 수 없거나 quux ()를 사용할 수있는 곳을 잘 알고 있다면 일시적으로 다음을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8904deace3383be6f62627ad2fa40ed65a69d2bd" translate="yes" xml:space="preserve">
          <source>In a plain &lt;code&gt;eval&lt;/code&gt; without an EXPR argument, being in &lt;code&gt;use utf8&lt;/code&gt; or not is irrelevant; the UTF-8ness of &lt;code&gt;$_&lt;/code&gt; itself determines the behavior.</source>
          <target state="translated">EXPR 인수가없는 일반 &lt;code&gt;eval&lt;/code&gt; 에서 &lt;code&gt;use utf8&lt;/code&gt; 을 사용 하는지 여부는 관련이 없습니다. &lt;code&gt;$_&lt;/code&gt; 자체 의 UTF-8ness가 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8692c1987c2bd18d4696b2de38e79ce9a490834f" translate="yes" xml:space="preserve">
          <source>In a real situation, care should be taken that all threads are finished executing before the program exits. That care has &lt;b&gt;not&lt;/b&gt; been taken in these examples in the interest of simplicity. Running these examples</source>
          <target state="translated">실제 상황에서는 프로그램이 종료되기 전에 모든 스레드 실행이 완료되도록주의해야합니다. 이 예제에서는 단순성을 위해 주의를 기울이지 &lt;b&gt;않았습니다&lt;/b&gt; . 이 예제를 실행</target>
        </trans-unit>
        <trans-unit id="81c10dc0ae0ebb18c61b259ddfe6843d666964b7" translate="yes" xml:space="preserve">
          <source>In a reciprocal fashion, an operation provides either a scalar or a list context to each of its arguments. For example, if you say</source>
          <target state="translated">역수 방식으로 연산은 스칼라 또는 목록 컨텍스트를 각 인수에 제공합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7ae53fee8d17396b84228f6cefecffeb87519079" translate="yes" xml:space="preserve">
          <source>In a regex set</source>
          <target state="translated">정규식 세트에서</target>
        </trans-unit>
        <trans-unit id="c78cf6df929776e529a74a77e45234f404202f1c" translate="yes" xml:space="preserve">
          <source>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, &lt;code&gt;\|&lt;/code&gt; matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.</source>
          <target state="translated">정규식에서 백 슬래시는 다음 두 가지 작업 중 하나를 수행 할 수 있습니다. 예를 들어, &lt;code&gt;\|&lt;/code&gt; 는 세로 막대와 일치하거나 대체가 아닙니다. 백 슬래시 또는 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="81b5d9cd571e9943815277ab89c7fe545d260e8a" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;deflate&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;deflate&lt;/code&gt; 는 &lt;code&gt;$out&lt;/code&gt; 만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d751225aea131e8c18607565afa032c5caedabd6" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;flush&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;flush&lt;/code&gt; 는 &lt;code&gt;$out&lt;/code&gt; 만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="24a49c87bdb8b460c4017296f34ddb336c87c832" translate="yes" xml:space="preserve">
          <source>In a scalar context it returns the group name.</source>
          <target state="translated">스칼라 컨텍스트에서 그룹 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32d6c6f3bf39438d4047ce657137dce5d3577d7c" translate="yes" xml:space="preserve">
          <source>In a scalar context opcodes returns the number of opcodes in this version of perl (around 350 for perl-5.7.0).</source>
          <target state="translated">스칼라 컨텍스트에서 opcodes는이 버전의 perl에서 opcode 수를 리턴합니다 (perl-5.7.0의 경우 약 350).</target>
        </trans-unit>
        <trans-unit id="208f6e20787f24b907ff451f1741888a45d23759" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서이 메소드는 키 &lt;code&gt;$key&lt;/code&gt; 와 연관된 값의 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e9df32f544b32017f1a687d3dc29e952bea935c6" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="translated">스칼라 컨텍스트에서 메서드는 키 &lt;code&gt;$key&lt;/code&gt; 와 관련된 값의 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="432d105e0c68a882f3e01defe90d20d01d0c26a5" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or &lt;code&gt;undef&lt;/code&gt; upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">스칼라 컨텍스트에서 새 소켓이 반환되거나 실패시 &lt;code&gt;undef&lt;/code&gt; 가 반환 됩니다. 목록 컨텍스트에서 새 소켓과 피어 주소를 포함하는 두 요소 배열이 반환됩니다. 실패하면 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec0bad3cd5e75ede69094662ac02e11b4300440" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or undef upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">스칼라 컨텍스트에서 새 소켓이 리턴되거나 실패시 정의되지 않습니다. 리스트 문맥에서, 새로운 소켓과 피어 주소를 포함하는 2 요소 배열이 반환됩니다. 실패하면 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d1e3370613f74b8985a6b3b39b4a2c46223d16" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 따옴표와 같은 연산 (또는 실패시 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 과 일치하는 완전한 하위 문자열 만 반환합니다 . 스칼라 또는 공백 컨텍스트에서 입력 텍스트는 동일한 서브 스트링 (및 지정된 접 두부)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cb043da2c0d1ddbcbe23b4dfa1c70dc8d30d93aa" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;undef&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 quotelike 연산 (또는 실패시 &lt;code&gt;undef&lt;/code&gt; ) 과 일치하는 전체 하위 문자열 만 반환합니다 . 스칼라 또는 void 컨텍스트에서 입력 텍스트에는 동일한 하위 문자열 (및 지정된 접두사)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b8dc86dc00a1f2952c9a2e48c451d832e4c066" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_tagged&lt;/code&gt; 는 태그 지정된 텍스트 (시작 및 종료 태그 포함)와 일치하는 완전한 하위 문자열 만 리턴합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실패시 리턴됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 모든 접두사)이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="58e1b2c9f41d6622189dffef6c6b3c984f3970a5" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;undef&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_tagged&lt;/code&gt; 는 태그가 지정된 텍스트 (시작 및 종료 태그 포함)와 일치하는 전체 하위 문자열 만 반환합니다. 실패시 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 접두사)이 제거되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9900a2af209760381e75d8f7a14615b5a9bdbec" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_variable&lt;/code&gt; 은 변수 표현식과 일치하는 완전한 하위 문자열 만 리턴합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실패시 리턴됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 모든 접두사)이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="29022909d0ff04a63844f8132ef7f7171aee73fe" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;undef&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_variable&lt;/code&gt; 은 가변 식과 일치하는 전체 하위 문자열 만 반환합니다. 실패시 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 접두사)이 제거되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="945278245cb407350f6bc45cb3b502fc5ad85d58" translate="yes" xml:space="preserve">
          <source>In a scalar context, just the extracted substring is returned. In a void context, the extracted substring (and any prefix) are simply removed from the beginning of the first argument.</source>
          <target state="translated">스칼라 컨텍스트에서는 추출 된 하위 문자열 만 리턴됩니다. 빈 공간에서 추출 된 부분 문자열 (및 모든 접두사)은 단순히 첫 번째 인수의 시작 부분에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7e3e24a2a724494140e588e3803a95e574330808" translate="yes" xml:space="preserve">
          <source>In a scalar context, the extracted string is returned, having first been removed from the input text. Thus, the following code also processes each quote-like operation, but actually removes them from $text:</source>
          <target state="translated">스칼라 컨텍스트에서 추출 된 문자열이 입력 텍스트에서 먼저 제거 된 상태로 리턴됩니다. 따라서 다음 코드는 각 따옴표와 같은 연산을 처리하지만 실제로 $ text에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0d5544cfc850136e8726fbbd9c72234c9b7ae747" translate="yes" xml:space="preserve">
          <source>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I'll demonstrate embedding with</source>
          <target state="translated">어떤 의미에서 perl (C 프로그램)은 Perl (언어)을 포함시키는 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ff595beb69ecf8f38b6337a9d03b24a9b262246c" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Also, overriding &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비슷한 방식으로 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 함수를 재정의하면 동등한 I / O 연산자 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; 도 재정의 됩니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; 를 재정의하면 연산자 &lt;code&gt;``&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 재정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="a7df5882938822589a5bd41ee1d3ff81d5d0fe68" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;readline&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt;. Also, overriding &lt;code&gt;readpipe&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;qx//&lt;/code&gt;.</source>
          <target state="translated">비슷한 방식으로 &lt;code&gt;readline&lt;/code&gt; 함수를 재정의하면 동등한 I / O 연산자 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; 도 재정의 됩니다. 또한 &lt;code&gt;readpipe&lt;/code&gt; 를 재정의하면 &lt;code&gt;``&lt;/code&gt; 및 &lt;code&gt;qx//&lt;/code&gt; 연산자도 재정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d250c896d3f5eb11d7a648b3bc78f5925e2fcce" translate="yes" xml:space="preserve">
          <source>In a void context the behaviour of the extraction subroutines is exactly the same as in a scalar context, except (of course) that the extracted substring is not returned.</source>
          <target state="translated">공백 컨텍스트에서 추출 서브 루틴의 동작은 스칼라 컨텍스트와 정확히 동일하지만 추출 된 서브 스트링이 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="164ac7c993944f12e7319a81a34bfbc9042d71d4" translate="yes" xml:space="preserve">
          <source>In a void context, the input text just has the matched substring (and any specified prefix) removed.</source>
          <target state="translated">빈 공간에서 입력 텍스트는 일치하는 부분 문자열 (및 지정된 접두사) 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a9b13f420194df675e5068f5af3ab2ba48ac53e8" translate="yes" xml:space="preserve">
          <source>In a word - don't, at least not without a *very* good reason. Your scripts can just as easily begin with &quot;#!/usr/local/bin/perl&quot; as with &quot;#!/usr/bin/perl&quot;. Scripts supplied by Apple and other third parties as part of installation packages and such have generally only been tested with the /usr/bin/perl that's installed by Apple.</source>
          <target state="translated">한마디로, * 아주 * 좋은 이유 없이는하지 마십시오. 스크립트는 &quot;#! / usr / bin / perl&quot;과 마찬가지로 &quot;#! / usr / local / bin / perl&quot;로 쉽게 시작할 수 있습니다. 설치 패키지의 일부로 Apple 및 기타 제 3자가 제공 한 스크립트는 일반적으로 Apple에서 설치 한 / usr / bin / perl에서만 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="fcf1ea0b348743b5d23b285ecea8c108896961cc" translate="yes" xml:space="preserve">
          <source>In academia, a curriculum vit&amp;aelig;, a fancy kind of r&amp;eacute;sum&amp;eacute;. In Perl, an internal &amp;ldquo;code value&amp;rdquo; typedef holding a &lt;b&gt;subroutine&lt;/b&gt;. The &lt;code&gt;CV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">학계에서는 커리큘럼 vit&amp;aelig;, 멋진 이력서입니다. Perl에서 &lt;b&gt;서브 루틴을&lt;/b&gt; 보유하는 내부 &quot;코드 값&quot;typedef . &lt;code&gt;CV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f52867b2f837c43cc5640194de947dbf1e2090" translate="yes" xml:space="preserve">
          <source>In actuality, the period and &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations are themselves types of character classes, so the ones surrounded by brackets are just one type of character class. When we need to make a distinction, we refer to them as &quot;bracketed character classes.&quot;</source>
          <target state="translated">실제로 마침표와 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 약어는 그 자체가 문자 클래스 유형이므로 대괄호로 묶인 문자는 문자 클래스 유형 중 하나 일뿐입니다. 구별해야 할 때는 &quot;브래킷 문자 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="46e3a38016d86ba7214b26757c2cfc95f05dd8d8" translate="yes" xml:space="preserve">
          <source>In addition</source>
          <target state="translated">게다가</target>
        </trans-unit>
        <trans-unit id="7e82af699df6da7e07e9ea8a98307994127655f1" translate="yes" xml:space="preserve">
          <source>In addition EXTEND will be called when perl would have pre-extended allocation in a real array.</source>
          <target state="translated">또한 EXTEND는 perl이 실제 배열에서 사전 확장 된 할당을 가질 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2d1a9f24dc62aaee4efacb9df22dbcc5333d73" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and &lt;code&gt;pprivate&lt;/code&gt; members. &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</source>
          <target state="translated">또한 패턴을 컴파일 한 정규식 엔진을 개인적으로 사용하기위한 두 개의 필드가 포함되어 있습니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 &lt;code&gt;pprivate&lt;/code&gt; 멤버입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 임의의 구조에 대한 무효 포인터이며, 사용 및 관리는 컴파일 엔진의 책임입니다. Perl은 이러한 값 중 어느 것도 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7aa9ca3525844fd7a1f1f038ab777e0241661c46" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</source>
          <target state="translated">또한 패턴을 컴파일 한 정규식 엔진을 개인적으로 사용하기위한 두 개의 필드가 포함되어 있습니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 개인 멤버입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 사용 및 관리 컴파일 엔진의 책임이다 임의의 구조에 대한 무효 포인터입니다. perl은 이러한 값 중 어느 것도 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="152b5f495da9efbec00e14f0ef1bc85e80c4a061" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</source>
          <target state="translated">유니 코드는 &lt;b&gt;스크립트&lt;/b&gt; 외에도 문자 &lt;b&gt;블록&lt;/b&gt; 을 정의 합니다. 스크립트와 블록의 차이점은 스크립트 개념은 자연어에 더 가깝고 블록 개념은 연속 서수 값을 갖는 유니 코드 문자 그룹을 기반으로 한 인공 그룹화에 가깝다는 것입니다. 예를 들어, &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; 블록은 서 수가 0에서 127 사이의 모든 문자입니다. 다시 말해 ASCII 문자입니다. &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; 스크립트처럼,이뿐만 아니라 여러 다른 블록에서 일부 문자가 들어 있습니다 &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7f09088f954a7db82a8b57fd467bd7775553888e" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt;, &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt;,</source>
          <target state="translated">&lt;b&gt;스크립트&lt;/b&gt; 외에도 유니 코드는 문자 &lt;b&gt;블록&lt;/b&gt; 도 정의 합니다. 스크립트와 블록의 차이점은 스크립트 개념이 자연어에 더 가깝고 블록 개념은 연속 서수 값을 가진 유니 코드 문자 그룹을 기반으로하는 인위적인 그룹화에 가깝다는 것입니다. 예를 들어, &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; 블록은 서 수가 0에서 127 (포함) 사이 인 모든 문자입니다. 즉, ASCII 문자입니다. &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; 스크립트처럼,이뿐만 아니라 여러 다른 블록에서 일부 문자가 들어 있습니다 &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="fc1471fd86b05121c975247d3ecf108832020f99" translate="yes" xml:space="preserve">
          <source>In addition to accepting the &lt;code&gt;collect_pod&lt;/code&gt; and &lt;code&gt;decode_pod&lt;/code&gt; arguments as described above, this method accepts a &lt;code&gt;inc&lt;/code&gt; argument which is a reference to an array of directories to search for the module. If none are given, the default is @INC.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;collect_pod&lt;/code&gt; 및 &lt;code&gt;decode_pod&lt;/code&gt; 인수 를 허용하는 것 외에도이 메소드는 모듈을 검색 할 디렉토리 배열에 대한 참조 인 &lt;code&gt;inc&lt;/code&gt; 인수를 허용 합니다. 아무것도 지정하지 않으면 기본값은 @INC입니다.</target>
        </trans-unit>
        <trans-unit id="f86a4eaf10c727caafeb64d3a643f53ff65e9454" translate="yes" xml:space="preserve">
          <source>In addition to adding seconds, there are two APIs for adding months and years:</source>
          <target state="translated">초를 추가하는 것 외에도 몇 달과 몇 년을 추가하는 두 가지 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2fd5a60f4cdde51801210d2d64a0096f9f11eee" translate="yes" xml:space="preserve">
          <source>In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32. Your options include</source>
          <target state="translated">편집기 / IDE 외에도 Win32를위한보다 강력한 쉘 환경에 관심이있을 수 있습니다. 귀하의 옵션은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="00eb917cf5efd07f43486b691141200c354a7e24" translate="yes" xml:space="preserve">
          <source>In addition to arranging for various Encode aliases the following functions and variables are provided:</source>
          <target state="translated">다양한 Encode 별칭을 정렬하는 것 외에도 다음 함수와 변수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1749590c161975b92597e609a16d593c1ab667da" translate="yes" xml:space="preserve">
          <source>In addition to being Unix, we're U/WIN.</source>
          <target state="translated">유닉스 일뿐 아니라 우리는 U / WIN입니다.</target>
        </trans-unit>
        <trans-unit id="59ad52f794c0c2f95e95db00a5db4b0758359fc7" translate="yes" xml:space="preserve">
          <source>In addition to computing what you expected, the last example also does &lt;b&gt;not&lt;/b&gt; &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</source>
          <target state="translated">마지막 예제는 예상 한 것을 계산하는 것 외에도 정확도 나 정밀 설정으로 결과를 &quot;보관&quot; 하지 &lt;b&gt;않으므로&lt;/b&gt; 이후 작업에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="28f0a444647c3ca604a27ded60bf62b43ff7e031" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. The checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;ord($char)&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 에서 허용되는 필드 외에도 항목 자체 대신 항목의 &amp;lt;number&amp;gt; 비트 체크섬을 원한다는 것을 나타 내기 위해 필드 앞에 % &amp;lt;number&amp;gt; 를 붙일 수 있습니다. 기본값은 16 비트 체크섬입니다. 체크섬은 확장 된 값의 숫자 값을 합산하여 계산됩니다 (문자열 필드의 경우 &lt;code&gt;ord($char)&lt;/code&gt; 의 합계를 사용하고 비트 필드의 경우 0과 1의 합계).</target>
        </trans-unit>
        <trans-unit id="ae2d9c47551f30ac79ac4fb8a4a7835684b54313" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack ()에서 허용되는 필드 외에도 항목 앞에 &amp;lt;숫자&amp;gt; 비트 체크섬을 원한다는 것을 나타 내기 위해 % &amp;lt;숫자&amp;gt;를 필드 앞에 붙일 수 있습니다. 기본값은 16 비트 체크섬입니다. 체크섬은 확장 값의 숫자 값을 합산하여 계산됩니다 (문자열 필드의 경우 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 의 합이 취해지고 비트 필드의 경우 0과 1의 합).</target>
        </trans-unit>
        <trans-unit id="8fab1ee4cfb63b6e2e7d76c7cfd5888f6ab2e679" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack ()에서 허용되는 필드 외에도 항목 앞에 &amp;lt;숫자&amp;gt; 비트 체크섬을 원한다는 것을 나타 내기 위해 % &amp;lt;숫자&amp;gt;를 필드 앞에 붙일 수 있습니다. 기본값은 16 비트 체크섬입니다. 체크섬은 확장 값의 숫자 값을 합산하여 계산됩니다 (문자열 필드의 경우 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 의 합이 취해지고 비트 필드의 경우 0과 1의 합).</target>
        </trans-unit>
        <trans-unit id="11a4b3be42c1bc1c34ed610faa54c6750890304a" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">&lt;code&gt;(*SKIP)&lt;/code&gt; 패턴 과 상호 작용하는 것 외에도 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 을 사용하여 패턴 분기에 &quot;레이블&quot;을 지정할 수 있으므로 일치 후 프로그램은 일치에 포함 된 패턴의 분기를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ec63aed202427c78ae99bf79365c2b0344aea9" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">&lt;code&gt;(*SKIP)&lt;/code&gt; 패턴 과 상호 작용하는 것 외에도 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 을 사용하여 패턴 분기를 &quot;라벨&quot;할 수 있으므로, 일치 후 프로그램이 패턴의 어느 분기가 일치 하는지를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea68ca5519ffc8129501826ad0bb9062eef1e64" translate="yes" xml:space="preserve">
          <source>In addition to possible bugs and an inability to follow changes to the translation policy with off/on switches of TERMIO translation, this introduces a serious incompatible change: before sysread() on text-mode filehandles would go through the translation layer, now it would not.</source>
          <target state="translated">가능한 버그 및 TERMIO 변환 스위치를 켜고 끄는 변환 정책 변경 사항을 수행 할 수 없다는 점 외에도 텍스트 모드 파일 핸들의 sysread ()가 변환 계층을 통과하기 전에 호환되지 않는 심각한 변경이 발생합니다. 아니.</target>
        </trans-unit>
        <trans-unit id="d4d69cf9bd1e25a37f285dc63efc29fb797f0fe0" translate="yes" xml:space="preserve">
          <source>In addition to standard-like API defined so far above there is an &quot;implementation&quot; interface which allows perl to get at internals of PerlIO. The following calls correspond to the various FILE_xxx macros determined by Configure - or their equivalent in other implementations. This section is really of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping or writing code which can make use of the &quot;read ahead&quot; that has been done by the IO system in the same way perl does. Note that any code that uses these interfaces must be prepared to do things the traditional way if a handle does not support them.</source>
          <target state="translated">지금까지 정의 된 표준 유사 API 외에도 perlIO가 PerlIO 내부에 액세스 할 수있는 &quot;구현&quot;인터페이스가 있습니다. 다음 호출은 Configure에 의해 결정된 다양한 FILE_xxx 매크로 또는 다른 구현에서 동등한 FILE_xxx 매크로에 해당합니다. 이 섹션은 perl과 동일한 방식으로 IO 시스템에 의해 수행 된 &quot;미리 읽기&quot;를 사용할 수있는 PerlIO 매핑 또는 코드 작성을 구현하는 자세한 perl-core 동작에 관심이있는 사용자에게만 관심이 있습니다. 이러한 인터페이스를 사용하는 코드는 핸들이 지원하지 않는 경우 전통적인 방식으로 작업 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="c328df560ff213b6d17abffac103ff94284e681e" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; sysconf() function. If this is a possibility, each directory in the path is checked in turn for safeness, recursively walking back to the root directory.</source>
          <target state="translated">MEDIUM 보안 검사 외에도 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; sysconf () 함수를 사용하여``chown () 공짜 ''가능성을 확인하십시오 . 이것이 가능한 경우 경로의 각 디렉토리가 안전을 위해 차례로 확인되고 반복적으로 루트 디렉토리로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="17eaea3931a67cb37ce8cb0cb3c4e8d09398b8c0" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the L</source>
          <target state="translated">MEDIUM 보안 검사 외에도 L을 사용하여``chown () 공짜 ''가능성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="89182cb06f6668d208e0619e4cbe15cde7591879" translate="yes" xml:space="preserve">
          <source>In addition to the OVERLOAD keyword, if you need to control how Perl autogenerates missing overloaded operators, you can set the FALLBACK keyword in the module header section, like this:</source>
          <target state="translated">OVERLOAD 키워드 외에도 Perl이 누락 된 오버로드 된 연산자를 자동 생성하는 방법을 제어해야하는 경우 다음과 같이 모듈 헤더 섹션에서 FALLBACK 키워드를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf43e38422f03f19f7c8bc12dfe3cf7238322b4f" translate="yes" xml:space="preserve">
          <source>In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.</source>
          <target state="translated">STANDARD 보안 외에도 출력 디렉토리가 루트 또는 프로그램을 실행중인 사용자가 소유하고 있는지 확인합니다. 디렉토리가 그룹 또는 다른 디렉토리에 의해 쓰기 가능한 경우, 고정 비트가 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a6827bb11452b38549da194a0e9f946e676fb6ab" translate="yes" xml:space="preserve">
          <source>In addition to the compiler flags used to select the SDK, also add the flags for creating a universal binary:</source>
          <target state="translated">SDK를 선택하는 데 사용되는 컴파일러 플래그 외에도 범용 바이너리를 생성하기위한 플래그를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="73c76010fe3f7536529c60cd357cfa7c8e4a0b21" translate="yes" xml:space="preserve">
          <source>In addition to the different levels of OS involvement in threads, different OSes (and different thread implementations for a particular OS) allocate CPU cycles to threads in different ways.</source>
          <target state="translated">스레드에 다양한 수준의 OS 관련 외에도 다른 OS (및 특정 OS에 대한 다른 스레드 구현)는 다른 방식으로 스레드에 CPU주기를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="79a96fb0aa6c1ca892c14d42638abd6240d03e9c" translate="yes" xml:space="preserve">
          <source>In addition to the file and subroutine-related variables mentioned above, the debugger also maintains various magical internal variables.</source>
          <target state="translated">위에서 언급 한 파일 및 서브 루틴 관련 변수 외에도 디버거는 다양한 마법의 내부 변수를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="bab0de29db31c89ae8ab9839888cf6f1bf406c03" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt; 에서 허용되는 키-값 쌍 외에도 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a72b31c557cda8bc1b722b2e6a26c2c901af09d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">에서 허용하는 키 - 값 쌍 외에도 &lt;a href=&quot;../socket&quot;&gt;IO :: 소켓&lt;/a&gt; , &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c8512896a52a4b21163cc6634b2cdd39a0ba342" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt; 에서 허용하는 키-값 쌍 외에도 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c27e58eddb584a8c9586d7873c892baa74f4f56d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt; 에서 허용하는 키-값 쌍 외에도 &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7c45e877ad35106ffbe7de68a1cdc70a047e523f" translate="yes" xml:space="preserve">
          <source>In addition to the metacharacters, there are some ASCII characters which don't have printable character equivalents and are instead represented by</source>
          <target state="translated">메타 문자 외에도 인쇄 가능한 문자가없는 ASCII 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08676326b07558d72976a15d2e5ea67b5354d4ab" translate="yes" xml:space="preserve">
          <source>In addition to the perl API described above, a C API is available for extension writers. The following C functions are available in the modglobal hash:</source>
          <target state="translated">위에서 설명한 perl API 외에도 확장 작성기에 C API를 사용할 수 있습니다. modglobal 해시에서 다음 C 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef88c015cd90a62555639afdea15aa945900339f" translate="yes" xml:space="preserve">
          <source>In addition to the quote delimiters &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, and &lt;code&gt;`&lt;/code&gt;, full Perl quote-like quoting (i.e. q{string}, qq{string}, etc) can be specified by including the letter 'q' as a delimiter. Hence:</source>
          <target state="translated">따옴표 구분자 &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; 및 &lt;code&gt;`&lt;/code&gt; 외에도, 문자'q '를 구분 기호로 포함하여 전체 Perl 따옴표와 같은 인용 (예 : q {string}, qq {string} 등)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee26c7c2937194436d9d08c9a82ea42e06abcd1" translate="yes" xml:space="preserve">
          <source>In addition to the six exported functions there exists one function that can only be accessed with a fully qualified function call.</source>
          <target state="translated">6 개의 내 보낸 함수 외에도 정규화 된 함수 호출로만 액세스 할 수있는 하나의 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="048f808ac9289a4a6c87dcb85ac0e60ea7b3a024" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt;.</source>
          <target state="translated">tie () 인터페이스 외에도 Berkeley DB API에서 제공하는 대부분의 함수에 직접 액세스 할 수도 있습니다. &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;API 인터페이스&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fd0fd0dfb0a01af1b34dd0a74cf43897f0a81ea" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;.</source>
          <target state="translated">tie () 인터페이스 외에도 Berkeley DB API에서 제공하는 대부분의 기능에 직접 액세스 할 수도 있습니다. &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85ce3c1d378a3aef7a0dc077cfad69336b01172a" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">기존의 Perl 기본 MRO ( 여기서는 &lt;code&gt;DFS&lt;/code&gt; 라고하는 깊이 우선 검색 ) 외에도 Perl은 이제 C3 MRO도 제공합니다. C3에 대한 Perl의 지원은 Stevan Little의 모듈 &lt;a href=&quot;Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 에서 수행 한 작업을 기반으로하며 여기에있는 대부분의 C3 관련 문서는 거기에서 직접 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="53b1ffa79f559c5952d0b2eca922c0eb1fe018a7" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">기존 Perl 기본 MRO ( 여기서는 &lt;code&gt;DFS&lt;/code&gt; 라고하는 깊이있는 첫 번째 검색 ) 외에도 이제 C3 MRO도 제공합니다. C3에 대한 Perl의 지원은 Stevan Little의 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 에서 수행 된 작업을 기반으로하며 여기에서 대부분의 C3 관련 문서는 직접 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="8eca212407dc344e58d9927ac55df67e502679ba" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt; , as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">반전 맵을 구성하는 두 배열 외에도 &lt;code&gt;prop_invmap&lt;/code&gt; 은 다른 두 값을 반환합니다. 하나는 맵 배열의 항목 형식에 대한 세부 사항을 제공하는 스칼라입니다. 다른 하나는 기본 값으로, &lt;a href=&quot;#a&quot;&gt;아래 하위 섹션에서&lt;/a&gt; 설명하는 것처럼 형식 이름이 문자 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 로 시작하는 맵에 유용합니다 . 이 주요 섹션의 끝에 설명 된 다른 데이터 구조로 변환하는 것과 같은 특수한 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="a95287c02690513e66aa164f6a62d254e29970f0" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt;, as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">반전 맵을 형성하는 두 배열 외에도 &lt;code&gt;prop_invmap&lt;/code&gt; 은 두 개의 다른 값을 반환합니다. 하나는 맵 배열 항목의 형식에 대한 세부 정보를 제공하는 스칼라입니다. 다른 하나는 기본값으로, &lt;a href=&quot;#a&quot;&gt;아래 하위 섹션에&lt;/a&gt; 설명 된 대로 형식 이름이 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 문자로 시작하는 맵에서 유용합니다 . 이 기본 섹션의 끝에 설명 된 다른 데이터 구조로의 변환과 같은 특수한 목적을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5681bb6c22a6fc5f25fa9d9c98d1119dc3e69d9b" translate="yes" xml:space="preserve">
          <source>In addition to the version objects, this modules also replaces the core UNIVERSAL::VERSION function with one that uses version objects for its comparisons. The return from this operator is always the stringified form as a simple scalar (i.e. not an object), but the warning message generated includes either the stringified form or the normal form, depending on how it was called.</source>
          <target state="translated">버전 개체 외에도이 모듈은 핵심 UNIVERSAL :: VERSION 함수를 비교를 위해 버전 개체를 사용하는 함수로 대체합니다. 이 연산자의 반환은 항상 단순 스칼라 (즉, 객체가 아님)로 문자열 화 된 형식이지만 생성 된 경고 메시지에는 호출 방법에 따라 문자열 형식 또는 일반 형식이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dab2897e25695e7867181ff90ba23794c8c60c0d" translate="yes" xml:space="preserve">
          <source>In addition to using the &lt;code&gt;\p{Blk=...}&lt;/code&gt; and &lt;code&gt;\P{Blk=...}&lt;/code&gt; constructs, you can also test whether a code point is in the</source>
          <target state="translated">&lt;code&gt;\p{Blk=...}&lt;/code&gt; 및 &lt;code&gt;\P{Blk=...}&lt;/code&gt; 구문 을 사용하는 것 외에도 코드 포인트가</target>
        </trans-unit>
        <trans-unit id="dac7bc321eb3333dc44a14f1d9acf1fbd74fd29b" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt; . Then this code</source>
          <target state="translated">일치하는 것 외에도 Perl은 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 배열의 내용으로 일치 된 위치를 제공합니다 . &lt;code&gt;$-[0]&lt;/code&gt; 은 전체 경기의 시작 위치이고 &lt;code&gt;$+[0]&lt;/code&gt; 은 끝의 위치입니다. 마찬가지로 &lt;code&gt;$-[n]&lt;/code&gt; 은 &lt;code&gt;$n&lt;/code&gt; 일치 의 시작 위치 이고 &lt;code&gt;$+[n]&lt;/code&gt; 은 끝의 위치입니다. &lt;code&gt;$n&lt;/code&gt; 이 정의되지 않은 경우 $ &lt;code&gt;$-[n]&lt;/code&gt; 및 &lt;code&gt;$+[n]&lt;/code&gt; 도 정의 됩니다. 그런 다음이 코드</target>
        </trans-unit>
        <trans-unit id="ccbfdb924619efe15959974a161721499fe098ee" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt;. Then this code</source>
          <target state="translated">일치 된 항목 외에도 Perl은 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 배열의 내용으로 일치 된 항목의 위치를 ​​제공합니다 . &lt;code&gt;$-[0]&lt;/code&gt; 은 전체 경기의 시작 위치이고 &lt;code&gt;$+[0]&lt;/code&gt; 은 끝 위치입니다. 마찬가지로 &lt;code&gt;$-[n]&lt;/code&gt; 은 &lt;code&gt;$n&lt;/code&gt; 일치 의 시작 위치 이고 &lt;code&gt;$+[n]&lt;/code&gt; 은 끝 위치입니다. &lt;code&gt;$n&lt;/code&gt; 이 정의되지 않은 경우 $ &lt;code&gt;$-[n]&lt;/code&gt; 및 &lt;code&gt;$+[n]&lt;/code&gt; 도 마찬가지 입니다. 그런 다음이 코드</target>
        </trans-unit>
        <trans-unit id="7741b40dbd2e708ac5c5d3ad7fd7389004debdeb" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;GetFileAttributes&lt;/code&gt; can return these constants (or INVALID_FILE_ATTRIBUTES in case of an error).</source>
          <target state="translated">또한 &lt;code&gt;GetFileAttributes&lt;/code&gt; 는 이러한 상수 (또는 오류의 경우 INVALID_FILE_ATTRIBUTES)를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="340df59f8245bd9d352756a2f3fe84ca2ba2b14a" translate="yes" xml:space="preserve">
          <source>In addition, Perl defines the following:</source>
          <target state="translated">또한 Perl은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7b18dfd70f7fb70cb969c8b7231702490b8ef572" translate="yes" xml:space="preserve">
          <source>In addition, Perl permits the following widely-supported conversions:</source>
          <target state="translated">또한 Perl은 다음과 같이 광범위하게 지원되는 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="58a30b45039ea55ccfbff7c03b534706dd5f4a4e" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt; , as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">또한 두 번째 패키지 변수 ( &lt;code&gt;@Filter::Simple::components&lt;/code&gt; )에는 원래 &lt;code&gt;$_&lt;/code&gt; 자리 표시자를 삽입하기 위해 분할 된 다양한 $ _ 조각 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ff23c18253f069733b435a5b431ccd9634d8e2" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt;) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt;, as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">또한 두 번째 패키지 변수 ( &lt;code&gt;@Filter::Simple::components&lt;/code&gt; )에는 원래 자리 표시자를 삽입 할 수 있도록 분할 된 &lt;code&gt;$_&lt;/code&gt; 의 다양한 부분 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b824cddab0454f6fa746f5f5efb2df055e6a062" translate="yes" xml:space="preserve">
          <source>In addition, an attempt is made to recognize several common Unix library names, and filter them out or convert them to their VMS equivalents, as appropriate.</source>
          <target state="translated">또한 여러 공통 Unix 라이브러리 이름을 인식하고이를 필터링하거나 해당하는 VMS로 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="20f0764c130ac7b7bb4ff76a14f2a6cf3a71b811" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">또한 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 간단한 파일 이름 인 경우 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션의 기본값 이 해당 파일에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc3e8410e98f27c3f135fcd34c0e133beddff18" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">또한 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 간단한 파일 이름 인 경우 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Time&lt;/code&gt; 옵션 의 기본값 이 해당 파일에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d0ae1b4a0292104ef4e7dc7c425220d101005db4" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">또한 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 간단한 파일 이름 인 경우 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션의 기본값 은 해당 파일에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="91ed0a2f179c5ac2d45e1e913820f71e61b32911" translate="yes" xml:space="preserve">
          <source>In addition, if the input file/buffer does contain compressed data and there is non-compressed data immediately following it, setting this option will make this module treat the whole file/buffer as a single data stream.</source>
          <target state="translated">또한 입력 파일 / 버퍼에 압축 된 데이터가 있고 그 뒤에 바로 압축되지 않은 데이터가있는 경우이 옵션을 설정하면이 모듈이 전체 파일 / 버퍼를 단일 데이터 스트림으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a03250cf8d36596835773013a7ed159131abe9f9" translate="yes" xml:space="preserve">
          <source>In addition, on failure in</source>
          <target state="translated">또한 고장시</target>
        </trans-unit>
        <trans-unit id="1d296f66c5968bb02c723c76da82a489ff4f8824" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;Getopt::Long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">또한 다른 &lt;a href=&quot;Getopt::Long&quot;&gt;Getopt :: Long&lt;/a&gt; 오류 메시지는 잘못된 명령 줄 옵션으로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="289227a7d3ba6bcbce57645ed49463f1d7e46764" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;getopt/long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">또한 다른 &lt;a href=&quot;getopt/long&quot;&gt;Getopt :: Long&lt;/a&gt; 오류 메시지는 잘못된 명령 줄 옵션으로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="147a39b11e58c10277c6a279d8224a769b9bb498" translate="yes" xml:space="preserve">
          <source>In addition, output may be piped to a subprocess, using the character '|'. Anything after this character on the command line is passed to a subprocess for execution; the subprocess takes the output of Perl as its input.</source>
          <target state="translated">또한 문자 '|'를 사용하여 출력을 하위 프로세스로 파이프 할 수 있습니다. 명령 행에서이 문자 다음에 나오는 것은 실행을 위해 서브 프로세스로 전달됩니다. 서브 프로세스는 Perl의 출력을 입력으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99121fa175239d30527a66db54352aec9e7f4845" translate="yes" xml:space="preserve">
          <source>In addition, plenty of code in the wild does all of its OO &quot;by hand&quot;, using just the Perl built-in OO features. If you need to maintain such code, you should read &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; to understand exactly how Perl's built-in OO works.</source>
          <target state="translated">또한, Perl에 내장 된 OO 기능 만 사용하여 모든 OO를 &quot;수동으로&quot;수행하는 코드가 많이 있습니다. 이러한 코드를 유지 관리해야하는 경우 &lt;a href=&quot;perlobj&quot;&gt;Perlobj&lt;/a&gt; 를 읽고 Perl의 기본 제공 OO 작동 방식을 정확하게 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="df2c5f9f6d74347865f1b7d8c718b9166dce24c6" translate="yes" xml:space="preserve">
          <source>In addition, subroutines are named with an initial '&amp;amp;', though this is optional when unambiguous, just as the word &quot;do&quot; is often redundant in English. Symbol table entries can be named with an initial '*', but you don't really care about that yet (if ever :-).</source>
          <target state="translated">또한 서브 루틴은 초기 '&amp;amp;'로 이름이 지정되지만 &quot;do&quot;라는 단어가 영어로 중복되는 경우와 같이 모호하지 않은 경우에는 선택 사항입니다. 심볼 테이블 항목은 초기 '*'로 이름을 지정할 수 있지만 실제로는 신경 쓰지 않습니다 (언제나 :-).</target>
        </trans-unit>
        <trans-unit id="e4639b7e9ac66cd60ee8c3525c4580bbed98b234" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">또한 생성 된 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴은 자체 인수 목록을 필터링 서브 루틴으로 전달하므로 BANG.pm 필터를 쉽게 매개 변수화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="804038d4a839a29500af9574b5756d8de10f044f" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;import&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">또한 생성 된 &lt;code&gt;import&lt;/code&gt; 서브 루틴은 자체 인수 목록을 필터링 서브 루틴에 전달하므로 BANG.pm 필터를 쉽게 매개 변수로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9370bc00f7d65fe78c300f43b36130879db13c63" translate="yes" xml:space="preserve">
          <source>In addition, the new IO system can also be configured to read/write UTF-8 encoded characters (as noted above, this is efficient):</source>
          <target state="translated">또한 새로운 IO 시스템은 UTF-8로 인코딩 된 문자를 읽고 쓰도록 구성 할 수도 있습니다 (위에서 언급했듯이 효율적 임).</target>
        </trans-unit>
        <trans-unit id="3e36eb4b4d16be01e13411f12c4f853328d8d124" translate="yes" xml:space="preserve">
          <source>In addition, the returned value will be unique within the context of the Pod::Simple::XHTML object unless a second argument is passed a true value. ID attributes should always be unique within a single XHTML document, but pass the true value if you are creating not an ID but a URL hash to point to an ID (i.e., if you need to put the &quot;#foo&quot; in &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한 두 번째 인수에 true 값이 전달되지 않으면 반환 된 값은 Pod :: Simple :: XHTML 객체의 컨텍스트 내에서 고유합니다. ID 속성은 항상 단일 XHTML 문서 내에서 고유해야하지만 ID가 아닌 ID를 가리키는 URL 해시를 만드는 경우 (예 : &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt; 에 &quot;#foo&quot;를 넣어야하는 경우) true 값을 전달하십시오. = &quot;# foo&quot;&amp;gt; foo &amp;lt;/a&amp;gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de0edea48e0434c59597ceff4d726d410f442fce" translate="yes" xml:space="preserve">
          <source>In addition, when ldopts is called with parameters, it will return the argument string rather than print it to STDOUT.</source>
          <target state="translated">또한 ldopts가 매개 변수와 함께 호출되면 인수 문자열을 STDOUT에 인쇄하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3769f70780de829d878e1b8185000692b19a1f05" translate="yes" xml:space="preserve">
          <source>In addition, you must define a &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; subroutine that returns a hash-reference containing the hints for your subroutines:</source>
          <target state="translated">또한 서브 루틴에 대한 힌트가 포함 된 해시 참조를 반환하는 &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; 서브 루틴을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fe8a6e2911b84e5bf182d375e70d71ebf4dcde5" translate="yes" xml:space="preserve">
          <source>In all Perl versions you can use &lt;code&gt;as_number()&lt;/code&gt; or &lt;code&gt;as_int&lt;/code&gt; for the same effect:</source>
          <target state="translated">모든 Perl 버전 에서 동일한 효과를 위해 &lt;code&gt;as_number()&lt;/code&gt; 또는 &lt;code&gt;as_int&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a826c545f2fecb5bd50e173dbd7f3d696f12f03" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">모든 Perl 버전에서 &lt;code&gt;\s&lt;/code&gt; 는 5 개의 문자 [\ t \ n \ f \ r]와 일치합니다. 즉, 가로 탭, 줄 바꿈, 용지 공급, 캐리지 리턴 및 공백입니다. Perl v5.18부터는 세로 탭 &lt;code&gt;\cK&lt;/code&gt; 와도 일치합니다 . 이에 대한 설명은 아래의 참고 &lt;code&gt;[1]&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c841b634904e3955229cb8026fd88108b68b251d" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">모든 Perl 버전에서 &lt;code&gt;\s&lt;/code&gt; 는 5 개의 문자 [\ t \ n \ f \ r]와 일치합니다. 즉, 가로 탭, 줄 바꿈, 용지 공급, 캐리지 리턴 및 공백입니다. Perl v5.18부터 수직 탭 &lt;code&gt;\cK&lt;/code&gt; 와도 일치합니다 . 이에 대한 논의는 아래의 참고 &lt;code&gt;[1]&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="781b45f1e32e901ab32d784bb9ee31c8ef4d8da4" translate="yes" xml:space="preserve">
          <source>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</source>
          <target state="translated">가장 많은 메모리-파라노이드 구성 (예 : PURIFY)을 제외한 모든 헤드와 바디는 경기장에서 할당되며 기본적으로 N 헤드 또는 바디로 소포 된 약 4K의 메모리 청크입니다. Sv-body는 sv 유형으로 할당되므로 배열에서 안전하게 할당하는 데 필요한 크기 일관성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="82cf0166b1026f5214dc5e9dee6752fb9c70f2f9" translate="yes" xml:space="preserve">
          <source>In all cases shown above, the line indentation shows the call tree. If bit 2 of &lt;code&gt;frame&lt;/code&gt; is set, a line is printed on exit from a subroutine as well. If bit 4 is set, the arguments are printed along with the caller info. If bit 8 is set, the arguments are printed even if they are tied or references. If bit 16 is set, the return value is printed, too.</source>
          <target state="translated">위에 표시된 모든 경우에 줄 들여 쓰기는 호출 트리를 보여줍니다. &lt;code&gt;frame&lt;/code&gt; 비트 2 가 설정되면 서브 루틴에서 나올 때에도 라인이 인쇄됩니다. 비트 4가 설정되면 인수가 호출자 정보와 함께 인쇄됩니다. 비트 8이 설정되면 인수가 묶여 있거나 참조 되더라도 인수가 인쇄됩니다. 비트 16이 설정되면 반환 값도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6061ee2ae8dec0f2b671e0d3e14bae7a6b818d83" translate="yes" xml:space="preserve">
          <source>In all cases where the very common phenomenon of quantification (saying &quot;</source>
          <target state="translated">매우 일반적인 정량화 현상 ( &quot;</target>
        </trans-unit>
        <trans-unit id="e3c2c7f74b86dde15a7c489ee7be1789b4697e9f" translate="yes" xml:space="preserve">
          <source>In all dealings with contributed modules, everyone maintaining Perl should keep in mind that the code belongs to the original author, that they may not be on perl5-porters at any given time, and that a patch is not official unless it has been integrated into the author's copy of the module. To aid with this, and with points #1, #2, and #3 above, contact information for the authors of all contributed modules should be kept with the Perl distribution.</source>
          <target state="translated">기여한 모듈을 다룰 때마다 Perl을 유지 관리하는 모든 사람은 코드가 원래 작성자에 속하며 주어진 시간에 perl5 포터에 있지 않을 수 있으며 패치가 통합되지 않은 한 공식적이지 않다는 점을 명심해야합니다. 작성자의 모듈 사본. 이를 지원하고 위의 # 1, # 2 및 # 3 지점을 사용하려면 모든 기여 모듈의 작성자에 대한 연락처 정보를 Perl 배포와 함께 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f633a9cd1f1e79fef8f8eaa0a6cfd15cedc67ef" translate="yes" xml:space="preserve">
          <source>In all of the above cases, option values may be inserted in the bundle. For example:</source>
          <target state="translated">위의 모든 경우에 옵션 값이 번들에 삽입 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2383a8bd7489fcdd2f83ac67cbbc873796c97eb5" translate="yes" xml:space="preserve">
          <source>In all operations on %ENV, the key string is treated as if it were entirely uppercase, regardless of the case actually specified in the Perl expression.</source>
          <target state="translated">% ENV에 대한 모든 연산에서 키 문자열은 실제로 Perl 표현식에 지정된 대소 문자에 관계없이 완전히 대문자 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="95b3792cd6f5e2af35835ac883e0e6a53f125114" translate="yes" xml:space="preserve">
          <source>In all the above examples, &lt;code&gt;minus()&lt;/code&gt; is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should</source>
          <target state="translated">위의 모든 예제에서 &lt;code&gt;minus()&lt;/code&gt; 결과 만 반환하려면 빼기 () 가 필요합니다. Perl은 할당을 $ x로 처리합니다. 실제로 이러한 방법은</target>
        </trans-unit>
        <trans-unit id="62e6398632ccd73e2b501ee72778e7e043a2eb59" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script, and you'll want to use &lt;a href=&quot;perlapi#call_sv&quot;&gt;call_sv&lt;/a&gt;.</source>
          <target state="translated">이전의 모든 예제에서는 C에서 호출 할 Perl 서브 루틴의 이름을 '하드 와이어로 연결'했습니다.하지만 대부분의 경우 Perl 스크립트 내에서 Perl 서브 루틴의 이름을 지정할 수있는 것이 더 편리합니다. , 그리고 &lt;a href=&quot;perlapi#call_sv&quot;&gt;call_sv&lt;/a&gt; 를 사용하고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="97f2c173d7ed4e9aee1d1f9fb64f4d9f9b0ea2fe" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script.</source>
          <target state="translated">이전의 모든 예에서 C에서 호출 할 Perl 서브 루틴의 이름을 '하드 와이어드'했습니다. 그러나 대부분 Perl 스크립트 내에서 Perl 서브 루틴의 이름을 지정하는 것이 더 편리합니다. .</target>
        </trans-unit>
        <trans-unit id="ff04c34f746275001332ffb6b05f235dced368be" translate="yes" xml:space="preserve">
          <source>In all these calls, the &lt;code&gt;U32 w&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; parameters are warning category constants. You can see the ones currently available in &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;&quot;Category Hierarchy&quot; in warnings&lt;/a&gt;, just capitalize all letters in the names and prefix them by &lt;code&gt;WARN_&lt;/code&gt;. So, for example, the category &lt;code&gt;void&lt;/code&gt; used in a perl program becomes &lt;code&gt;WARN_VOID&lt;/code&gt; when used in XS code and passed to one of the calls below.</source>
          <target state="translated">이러한 모든 호출에서 &lt;code&gt;U32 w&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; 매개 변수는 경고 범주 상수입니다. &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;경고의 &quot;카테고리 계층&quot;에서&lt;/a&gt; 현재 사용할 수있는 항목을 볼 수 있습니다 . 이름의 모든 문자를 대문자로하고 &lt;code&gt;WARN_&lt;/code&gt; 접두사를 붙이기 만하면 됩니다. 따라서 예를 들어, perl 프로그램에서 사용되는 &lt;code&gt;void&lt;/code&gt; 범주 는 XS 코드에서 사용될 때 &lt;code&gt;WARN_VOID&lt;/code&gt; 가되고 아래 호출 중 하나에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="aaae17ed6f36eac3220705015e0ea930013f7c8e" translate="yes" xml:space="preserve">
          <source>In all these cases, the user can override this stubborn behaviour by prepending the command with the word force, for example:</source>
          <target state="translated">이 모든 경우에 사용자는 명령에 단어 force를 추가하여이 완고한 동작을 무시할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cbe02d68ddbd502acef7d9e9916746fae4beca6" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; instead of resorting to a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">이와 같은 거의 모든 경우 에 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 대신에 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 의 구조적 제어 흐름 메커니즘을 사용하는 것이 일반적으로 훨씬 더 나은 아이디어 입니다. 특정 애플리케이션의 경우 예외 처리를위한 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 및 die () 의 catch 및 throw 쌍 도 신중한 접근 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd7916d5198052c029284d36ab0810a786fae19" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, or &lt;code&gt;redo&lt;/code&gt; instead of resorting to a &lt;code&gt;goto&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;eval{}&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">이와 같은 거의 모든 경우에 일반적으로 &lt;code&gt;goto&lt;/code&gt; 에 의존하는 대신 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;last&lt;/code&gt; 또는 &lt;code&gt;redo&lt;/code&gt; 의 구조화 된 제어 흐름 메커니즘을 사용하는 것이 훨씬 더 나은 아이디어 입니다. 특정 애플리케이션의 경우 예외 처리를위한 &lt;code&gt;eval{}&lt;/code&gt; 및 die () 의 catch 및 throw 쌍 도 신중한 접근 방식이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cf0558a3828c482ff92b5a9786f51b397db3041" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; of the string, and sets that &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">배열 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 지정된 추출기에 의해 추출 된 원래 문자열의 하위 문자열 배열을 반환합니다. 스칼라 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 원래 문자열에서 성공적으로 추출 된 첫 번째 하위 문자열을 리턴합니다. 스칼라 및 공백 컨텍스트 모두에서 원래 문자열에는 성공적으로 추출 된 첫 번째 부분 문자열이 제거됩니다. 모든 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 문자열 의 현재 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 에서 시작하여 일치 하는 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 적절하게 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="64f4703d98a2bbd61fb2abe591377e6cc1a8eae4" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;pos&lt;/code&gt; of the string, and sets that &lt;code&gt;pos&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">배열 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 지정된 추출기에 의해 추출 된대로 원래 문자열의 하위 문자열 배열을 반환합니다. 스칼라 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 원래 문자열에서 성공적으로 추출 된 첫 번째 부분 문자열을 반환합니다. 스칼라 및 보이드 컨텍스트 모두에서 원래 문자열에는 첫 번째로 성공적으로 추출 된 하위 문자열이 제거되었습니다. 모든 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 문자열 의 현재 &lt;code&gt;pos&lt;/code&gt; 에서 시작 하고 일치 한 후에 해당 &lt;code&gt;pos&lt;/code&gt; 적절하게 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0bf045366670deb82562441b69ea96760a43c736" translate="yes" xml:space="preserve">
          <source>In an array context the return value is a list containing, the number of articles in the group, the number of the first article, the number of the last article and the group name.</source>
          <target state="translated">배열 컨텍스트에서 반환 값은 그룹의 기사 수, 첫 번째 기사 수, 마지막 기사 수 및 그룹 이름을 포함하는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5a5982cddd4d8975197c2744da1608d9e4548d41" translate="yes" xml:space="preserve">
          <source>In an array context, returns a list of lines returned from the server. In a scalar context, returns a reference to a list.</source>
          <target state="translated">배열 컨텍스트에서 서버에서 반환 된 행 목록을 반환합니다. 스칼라 컨텍스트에서 목록에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c41a798a42099e75be11d7d0369af1bc79b214a4" translate="yes" xml:space="preserve">
          <source>In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its number using the &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">큰 따옴표로 묶은 문자열이든 정규 표현식이든 보간 된 리터럴에서 &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; 이스케이프를 사용하여 숫자로 문자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4918ab5fdbd686e859250551837a7ee9a52207eb" translate="yes" xml:space="preserve">
          <source>In ancient times, Unix was also used to refer to some code that a couple of people at Bell Labs wrote to make use of a PDP-7 computer that wasn&amp;rsquo;t doing much of anything else at the time.</source>
          <target state="translated">고대에 유닉스는 Bell Labs의 두 사람이 당시에 다른 일을 많이하지 않는 PDP-7 컴퓨터를 사용하기 위해 작성한 일부 코드를 가리키는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d17b1ed4f6399a33863173b63d7cf4eeef9ce1db" translate="yes" xml:space="preserve">
          <source>In any case do not expect nanosecond resolution, or even a microsecond resolution. Also note that the modify/access timestamps might have different resolutions, and that they need not be synchronized, e.g. if the operations are</source>
          <target state="translated">어쨌든 나노초 해상도 또는 마이크로 초 해상도를 기대하지 마십시오. 또한 수정 / 액세스 타임 스탬프의 해상도가 다를 수 있으며 동기화 할 필요가 없습니다 (예 : 작업이</target>
        </trans-unit>
        <trans-unit id="a2ea48b73fadf70f92647ed4cbbc7d19e3016b8b" translate="yes" xml:space="preserve">
          <source>In any case you will be prompted with the correct invocation of the &lt;code&gt;inst_perl&lt;/code&gt; target that installs the new binary into INSTALLBIN.</source>
          <target state="translated">&lt;code&gt;inst_perl&lt;/code&gt; 새 바이너리를 INSTALLBIN에 설치하는 inst_perl 대상을 올바르게 호출하라는 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="416ebb085a2d5e940040c711d2f8d1e17ddebb19" translate="yes" xml:space="preserve">
          <source>In any way, if you're seeing failures beyond those mentioned in this document, please consider upgrading to the latest Hurd before reporting the failure as a bug.</source>
          <target state="translated">어떤 식 으로든이 문서에서 언급 된 것 이외의 오류가 발생하면 오류로보고하기 전에 최신 Hurd로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="86069d4fc266f927b18d767a1cba7026af51c3e5" translate="yes" xml:space="preserve">
          <source>In array context returns a two-element array with the seconds and microseconds since the epoch. In scalar context returns floating seconds like &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (see below).</source>
          <target state="translated">배열 컨텍스트에서 에포크 (epoch) 이후 초와 마이크로 초를 갖는 2 요소 배열을 리턴합니다. 스칼라 컨텍스트에서 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 과 같은 부동 초를 반환합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="16582d55b272e81d53e1e61c0aba11a653333faf" translate="yes" xml:space="preserve">
          <source>In between two &lt;b&gt;subscripts&lt;/b&gt;, the arrow is optional.</source>
          <target state="translated">두 &lt;b&gt;첨자&lt;/b&gt; 사이 에서 화살표는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e15bc0bc69692882714387f5e16ad85b014d51b1" translate="yes" xml:space="preserve">
          <source>In block mode, &lt;code&gt;filter_read&lt;/code&gt; will append a block of data which is &amp;lt;= &lt;code&gt;$size&lt;/code&gt; to the end of the &lt;code&gt;$_&lt;/code&gt; scalar. It is important to emphasise the that &lt;code&gt;filter_read&lt;/code&gt; will not necessarily read a block which is</source>
          <target state="translated">블록 모드에서 &lt;code&gt;filter_read&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 스칼라 끝에 &amp;lt;= &lt;code&gt;$size&lt;/code&gt; 인 데이터 블록을 추가합니다 . &lt;code&gt;filter_read&lt;/code&gt; 가 반드시 블록을 읽을 필요는 없다는 것을 강조하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="86311b9447535cd22a0807e557574828944f0087" translate="yes" xml:space="preserve">
          <source>In bootstrapping situations it is usually sufficient to translate only a few YAML files to Data::Dumper for crucial modules like &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; and &lt;code&gt;Expect.pm&lt;/code&gt; . If you prefer Storable over Data::Dumper, remember to pull out a Storable version that writes an older format than all the other Storable versions that will need to read them.</source>
          <target state="translated">부트 스트랩 상황에서는 일반적으로 &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; 및 &lt;code&gt;Expect.pm&lt;/code&gt; 과 같은 중요한 모듈의 경우 일부 YAML 파일 만 Data :: Dumper로 변환하면 충분합니다 . Data :: Dumper보다 Storable을 선호하는 경우이를 읽어야하는 다른 모든 Storable 버전보다 오래된 형식을 작성하는 Storable 버전을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="193c5d594ac73cc20a544832d2468fc8181bf983" translate="yes" xml:space="preserve">
          <source>In both cases events are generated and stored in an array. This array is eventually used to populate the &lt;code&gt;subevents&lt;/code&gt; attribute on the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event that is generated at the end of the subtest. This flag has no effect on this part, it always happens.</source>
          <target state="translated">두 경우 모두 이벤트가 생성되고 배열에 저장됩니다. 이 배열은 결국 채우는 데 사용되는 &lt;code&gt;subevents&lt;/code&gt; 의 온 속성 &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2를 :: 이벤트 :: 보조 시험&lt;/a&gt; 하위 검사의 끝에서 생성되는 이벤트를. 이 플래그는이 부분에 영향을주지 않으며 항상 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d32bdf3cfc0bcbd8616099443aea4c2f02bae5f" translate="yes" xml:space="preserve">
          <source>In both cases this should only be considered to be a temporary measure - you should upgrade to the later version of perl as soon as is practicable.</source>
          <target state="translated">두 경우 모두 이는 일시적인 조치로만 간주되어야합니다. 가능한 한 빨리 최신 버전의 perl로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2a841147fc72cc4482e0a7e84067a22e8db15fe" translate="yes" xml:space="preserve">
          <source>In both cases, if you want access to the original, unaltered routine, use the &lt;code&gt;CORE::&lt;/code&gt; prefix:</source>
          <target state="translated">두 경우 모두 변경되지 않은 원래 루틴에 액세스하려면 &lt;code&gt;CORE::&lt;/code&gt; 접 두부를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b49d045d120cddc991a05308fecf5d02438bfd9" translate="yes" xml:space="preserve">
          <source>In both cases, it is strongly recommended that you use these flags when you run Configure. If you do not use do this, but later answer the questions about 64-bit numbers when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">두 경우 모두 Configure를 실행할 때이 플래그를 사용하는 것이 좋습니다. 사용하지 않지만 나중에 Configure에서 요청할 때 64 비트 숫자에 대한 질문에 대답하면 컴파일 할 수 없거나 예상대로 작동하지 않는 구성이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb84a1bc50cca6fcae9507ee085502026d5e423b" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may also be used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;eval&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;&lt;code&gt;wantarray&lt;/code&gt;&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">두 형식 모두에서 반환 된 값은 미니 프로그램 내에서 평가 된 마지막 표현식의 값입니다. 서브 루틴과 마찬가지로 return 문을 사용할 수도 있습니다. 반환 값을 제공하는 표현식은 평가 자체 의 컨텍스트에 따라 void, 스칼라 또는 목록 컨텍스트에서 &lt;code&gt;eval&lt;/code&gt; 됩니다. 평가 컨텍스트를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#wantarray&quot;&gt; &lt;code&gt;wantarray&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28f5f411ebc893dbf219e8f06f5338fdd368072e" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">두 형식 모두에서 반환 된 값은 미니 프로그램 내에서 평가 된 마지막 식의 값입니다. 서브 루틴과 마찬가지로 리턴 문도 사용할 수 있습니다. 반환 값을 제공하는 식은 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체 의 컨텍스트에 따라 void, 스칼라 또는 목록 컨텍스트에서 평가 됩니다. 평가 컨텍스트를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a7857febf47f6d9d7d4d6147004e7ae7af4e0b5" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">두 형식 모두에서 반환 된 값은 미니 프로그램 내에서 평가 된 마지막 식의 값입니다. 서브 루틴과 마찬가지로 리턴 문도 사용할 수 있습니다. 반환 값을 제공하는 식은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체 의 컨텍스트에 따라 void, 스칼라 또는 목록 컨텍스트에서 평가 됩니다. 평가 컨텍스트를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9f62f445147592772dba8cf7d0b7f085f6d5d1f" translate="yes" xml:space="preserve">
          <source>In both last cases, the last expression is evaluated in the context that was applied to the &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">마지막 두 경우 모두 마지막 블록 은 &lt;code&gt;given&lt;/code&gt; 블록 에 적용된 컨텍스트에서 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="faca50452b363bafe8294bb759677cc9d971a027" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt; .) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">인용되지 않은 명령 행 인수의 경우 또는 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS 와일드 카드 확장의 경우 모두 수행됩니다. ( &lt;code&gt;File::Glob::glob&lt;/code&gt; 를 사용하는 경우 csh 스타일 와일드 카드 확장을 사용할 수 있습니다 .) 와일드 카드 파일 스펙에 디바이스 또는 디렉토리 스펙이 포함 된 경우 결과 파일 스펙에도 디바이스 및 디렉토리가 포함됩니다. 그렇지 않으면 장치 및 디렉토리 정보가 제거됩니다. VMS 스타일 결과 파일 사양에는 전체 장치 및 디렉토리가 포함되지만 Unix 스타일 결과 파일 사양에는 입력 파일 사양에 존재했던만큼의 디렉토리 경로 만 포함됩니다. 예를 들어, 기본 디렉토리가 Perl_Root : [000000] 인 경우 &lt;code&gt;[.t]*.*&lt;/code&gt; 의 확장은 &quot;perl_root : [t] base.dir&quot;과 같은 파일 스펙을 생성하지만 &lt;code&gt;t/*/*&lt;/code&gt; 의 확장은&quot;t / base.dir&quot;과 같은 파일 스펙을 생성합니다. (이것은 Unix 쉘이 수행하는 glob 확장의 동작과 일치시키기 위해 수행됩니다.)</target>
        </trans-unit>
        <trans-unit id="151a64667d69a6e020ca3351948ca015aaa39af7" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;glob()&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt;.) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">인용되지 않은 명령 줄 인수의 경우 또는 &lt;code&gt;glob()&lt;/code&gt; VMS 와일드 카드 확장 에 대한 호출 모두에서 수행됩니다. ( &lt;code&gt;File::Glob::glob&lt;/code&gt; 을 사용하는 경우 csh 스타일 와일드 카드 확장을 사용할 수 있습니다 .) 와일드 카드 파일 사양에 장치 또는 디렉터리 사양이 포함 된 경우 결과 파일 사양에는 장치 및 디렉터리도 포함됩니다. 그렇지 않으면 장치 및 디렉토리 정보가 제거됩니다. VMS 스타일 결과 파일 사양에는 전체 장치와 디렉토리가 포함되는 반면 Unix 스타일 결과 파일 사양에는 입력 파일 사양에있는만큼의 디렉토리 경로 만 포함됩니다. 예를 들어 기본 디렉토리가 Perl_Root : [000000] 인 경우 &lt;code&gt;[.t]*.*&lt;/code&gt; 를 확장 하면 &quot;perl_root : [t] base.dir&quot;과 같은 파일 사양이 생성되고 &lt;code&gt;t/*/*&lt;/code&gt; 가 확장됩니다.&quot;t / base.dir&quot;과 같은 파일 사양이 생성됩니다. (이는 Unix 셸에서 수행되는 glob 확장 동작과 일치시키기 위해 수행됩니다.)</target>
        </trans-unit>
        <trans-unit id="7acbdc4bab7e93326f2e293e78aa137135b956f7" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt; , result. So a warning is raised for it.</source>
          <target state="translated">이 두 예제에서 일치하는 문자는 유니 코드가 아니므로 유니 코드는 일치하는 방법을 정의하지 않습니다. 분명히 ASCII 16 진수가 아니므로 첫 번째 예는 경고없이 실패해야합니다. 그러나 두 번째 예제는 정의되지 않은 &lt;code&gt;FALSE&lt;/code&gt; 결과 를 가져야한다는 것은 논쟁의 여지가 있습니다. 따라서 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ada6e60fc27e067365f9bf0a0ffb98e7d709449e" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt;, result. So a warning is raised for it.</source>
          <target state="translated">이 두 예에서 일치하는 문자는 유니 코드가 아니므로 유니 코드는 일치하는 방법을 정의하지 않습니다. 분명히 ASCII 16 진수 숫자가 아니므로 첫 번째 예제는 분명히 실패해야하며 경고없이 실패합니다. 그러나 두 번째 예제가 정의되지 않은 결과 를 가져야한다는 것은 논쟁의 여지가 있습니다. 따라서 &lt;code&gt;FALSE&lt;/code&gt; . 따라서 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f0223354df20f59a567232c3197191e5bff5d52" translate="yes" xml:space="preserve">
          <source>In both usages of the autosplitter, only subroutines defined following the perl</source>
          <target state="translated">자동 스플리터의 두 가지 용도 모두에서 perl 다음에 정의 된 서브 루틴 만</target>
        </trans-unit>
        <trans-unit id="406fcea7e1602f14dd1022ebb22952808a0b1f3f" translate="yes" xml:space="preserve">
          <source>In case</source>
          <target state="translated">경우</target>
        </trans-unit>
        <trans-unit id="e541d9732ad7ef01278201444dc42735718b9c21" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt; &quot;.</source>
          <target state="translated">&quot;text |&quot;가없는 L &amp;lt;...&amp;gt; 코드의 경우 그들 중 일부에서, 오래된 포매터는 실제로 링크 또는 상호 참조를 표시하는 데 큰 변화를 보였다. 예를 들어, L &amp;lt;crontab (5)&amp;gt;는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; 맨 페이지&quot;또는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; 맨 페이지&quot;또는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; &quot; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="2814b51f24a73a872d7d804cf971bb1ce84fc6ad" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt;&quot;.</source>
          <target state="translated">&quot;text |&quot;가없는 L &amp;lt;...&amp;gt; 코드의 경우 일부는 이전 포맷터가 실제로 링크 또는 상호 참조를 표시하는 데 큰 변화를 보였습니다. 예를 들어, L &amp;lt;crontab (5)&amp;gt;은 &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;또는 &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;또는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; &quot; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="365d296ccf4014f926ba35dfa5ea9a2c360d66e7" translate="yes" xml:space="preserve">
          <source>In case of doubt, insert the following statement in front of your Perl program:</source>
          <target state="translated">의심스러운 경우 Perl 프로그램 앞에 다음 명령문을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="dfdb2521cd21a1ef333094706d67bdf22192a8cc" translate="yes" xml:space="preserve">
          <source>In case the advice in this guide has been updated recently, read the latest version directly from the perl source:</source>
          <target state="translated">이 안내서의 권고 사항이 최근에 업데이트 된 경우, perl 소스에서 직접 최신 버전을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="23c62db8a34f2416b1d1b03ee56f5f1471c6e5f5" translate="yes" xml:space="preserve">
          <source>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the</source>
          <target state="translated">하나의 연산 결과에 지정된 것보다 많은 숫자가있는 경우 반올림됩니다. 반올림 모드는 기본 모드이거나 이후에 작업에 제공된 모드입니다.</target>
        </trans-unit>
        <trans-unit id="4ff81268a14bba4a99da29ff2559bdaaf817ec79" translate="yes" xml:space="preserve">
          <source>In case you can choose between running a Makefile.PL or a Build.PL, which installer would you prefer (EUMM or MB or RAND)?</source>
          <target state="translated">Makefile.PL 또는 Build.PL 실행 중에서 선택할 수있는 경우 어떤 설치 프로그램을 선호합니까 (EUMM 또는 MB 또는 RAND)?</target>
        </trans-unit>
        <trans-unit id="4bcc550b219bf3be3a6806897874d6bb2e99f2b2" translate="yes" xml:space="preserve">
          <source>In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.</source>
          <target state="translated">&quot;일반&quot;버전 8 정규식 루틴에 익숙하지 않은 경우 위에서 설명하지 않은 패턴 일치 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62dab9a7c702990dbb833dc9d9dafc87377a09a8" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt; ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">예외적으로 비정상적인 문서의 경우 포드 파서는 파싱을 중단 할 수 있습니다. 그렇다하더라도, 사용 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ING / &lt;code&gt;croak&lt;/code&gt; ING 피해야한다; 가능한 경우 파서 라이브러리는 입력 파일을 닫고 (부분적인) 메모리 내 문서의 끝에 &quot;*** Formatting Aborted ***&quot;와 같은 텍스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59217a1c8a005c9ab6145ee6ec0ce18535c0415" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;die&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt;ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">예외적으로 비정상적인 문서의 경우 Pod 파서가 파싱을 중단 할 수 있습니다. 그렇다하더라도, 사용 &lt;code&gt;die&lt;/code&gt; ING / &lt;code&gt;croak&lt;/code&gt; ING 피해야한다; 가능한 경우 파서 라이브러리는 단순히 입력 파일을 닫고 &quot;*** Formatting Aborted ***&quot;와 같은 텍스트를 (부분) 메모리 내 문서 끝에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="951ca6ae3fa63f2c3fd17e15460e33ec812d0590" translate="yes" xml:space="preserve">
          <source>In cases of links to a section in a different Pod document, there are both a</source>
          <target state="translated">다른 Pod 문서의 섹션에 대한 링크의 경우</target>
        </trans-unit>
        <trans-unit id="145ce40561aae9dcc1363caeb763ac38680de18e" translate="yes" xml:space="preserve">
          <source>In cases of links to a section in the current Pod document, there is a</source>
          <target state="translated">현재 Pod 문서의 섹션에 대한 링크의 경우</target>
        </trans-unit>
        <trans-unit id="59b86d710288939d8eb974b61f2bbf30d7a131a6" translate="yes" xml:space="preserve">
          <source>In cases where get_title can't find the title, it will return empty-string (&quot;&quot;).</source>
          <target state="translated">get_title이 제목을 찾을 수없는 경우 빈 문자열 ( &quot;&quot;)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="973bb49bb790d075ff05520ff06dce4f9260825c" translate="yes" xml:space="preserve">
          <source>In cases where there is link-text explicitly specified, it is to be found in the content of the element (and not the attributes), just as with the L&amp;lt;</source>
          <target state="translated">링크 텍스트가 명시 적으로 지정된 경우 L &amp;lt;과 마찬가지로 요소의 콘텐츠 (속성 아님)에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bf9664b1f4d1fbea5b6e435c9a6c227eff0e2f3" translate="yes" xml:space="preserve">
          <source>In certain cases, the OS-level handles created by the pipe(), socket(), and accept() operators are apparently not duplicated accurately in pseudo-processes. This only happens in some situations, but where it does happen, it may result in deadlocks between the read and write ends of pipe handles, or inability to send or receive data across socket handles.</source>
          <target state="translated">경우에 따라 pipe (), socket () 및 accept () 연산자로 작성된 OS 레벨 핸들은 의사 프로세스에서 정확하게 복제되지 않습니다. 이는 일부 상황에서만 발생하지만 발생하는 경우 파이프 핸들의 읽기 및 쓰기 끝 사이에 교착 상태가 발생하거나 소켓 핸들을 통해 데이터를 보내거나받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0057891cced8b178aba4808a03218c5201e0280" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;</source>
          <target state="translated">특정 시스템에서 운영 체제의 로케일 지원이 중단되어 Perl에서 수정하거나 사용할 수 없습니다. 이러한 결함은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용시&lt;/a&gt; 신비한 정지 및 / 또는 Perl 코어 덤프 를 초래할 수 있습니다. 이러한 시스템에 직면 한 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc5ce54a3d04a968232d4bfde109041471f0d94a" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;use locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;&amp;gt;, and also contact your vendor: bug fixes may exist for these problems in your operating system. Sometimes such bug fixes are called an operating system upgrade. If you have the source for Perl, include in the bug report the output of the test described above in &lt;a href=&quot;#Testing-for-broken-locales&quot;&gt;&quot;Testing for broken locales&quot;&lt;/a&gt;.</source>
          <target state="translated">특정 시스템에서는 운영 체제의 로케일 지원이 중단되어 Perl에서 수정하거나 사용할 수 없습니다. 이러한 결함은 &lt;code&gt;use locale&lt;/code&gt; 이 유효 할 때 알 수없는 정지 및 / 또는 Perl 코어 덤프 를 초래할 수 있습니다. 이러한 시스템에 직면하면 &amp;lt; &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; &amp;gt; 에 매우 자세한 내용을보고하고 공급 업체에 문의하십시오. 운영 체제에서 이러한 문제에 대한 버그 수정이있을 수 있습니다. 때때로 이러한 버그 수정을 운영 체제 업그레이드라고합니다. Perl의 소스가있는 경우 위의 &lt;a href=&quot;#Testing-for-broken-locales&quot;&gt;&quot;깨진 로케일 테스트&quot;&lt;/a&gt; 에서 설명한 테스트의 출력을 버그 보고서에 포함 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="60c7a29f6dd0bd0c499c2a79f889945240814e67" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</source>
          <target state="translated">현재 코드에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . @ISA = qw (오토로더); @ISA에서 AutoLoader를 제거하고 AutoLoader &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; 변경해야합니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용하려면&lt;/a&gt; ; .</target>
        </trans-unit>
        <trans-unit id="520a5e3954242a96e3ad7ef22ff14d7e52ffc0e7" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;use AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;use AutoLoader;&lt;/code&gt; to &lt;code&gt;use AutoLoader 'AUTOLOAD';&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;use AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; 하는 코드에서 ; @ISA = qw (자동 로더); @ISA에서 AutoLoader를 제거하고 AutoLoader &lt;code&gt;use AutoLoader;&lt;/code&gt; 변경해야합니다 . &lt;code&gt;use AutoLoader 'AUTOLOAD';&lt;/code&gt; 를 사용하려면; .</target>
        </trans-unit>
        <trans-unit id="b746a74a7b045be066091fe7c51bf38b893c45a1" translate="yes" xml:space="preserve">
          <source>In comparison to the standard implementation where the object is a hash and the fields correspond to hash keys, here the fields correspond to hashes, and the object determines the hash key. Thus the hashes appear to be turned</source>
          <target state="translated">객체가 해시이고 필드가 해시 키에 해당하는 표준 구현과 비교할 때 여기서 필드는 해시에 해당하며 객체는 해시 키를 결정합니다. 따라서 해시는 뒤집힌 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="402b2ae815c1f3f49820717ee0f679511f29fbf5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">관련하여 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 는 단순히 비트를 추가하고,이 효율적 비트 세트를 계산하는 어법 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="f5310c67f357a7a6bdb19f2c82ce4734dee7eee5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">관련하여 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 는 단순히 비트를 추가하고,이 효율적 비트 세트를 계산하는 어법 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="ed09b7a66d2eaa93bbb9724cd18388dac9e53c52" translate="yes" xml:space="preserve">
          <source>In consequence, if two or more classes want to access an object they</source>
          <target state="translated">결과적으로 둘 이상의 클래스가 객체에 액세스하려는 경우</target>
        </trans-unit>
        <trans-unit id="f69c1a7795cd05f1f7a1c806e629e11c671e5598" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types currently available are:</source>
          <target state="translated">반대로 &lt;code&gt;\b{...}&lt;/code&gt; 및 &lt;code&gt;\B{...}&lt;/code&gt; 는 경계 유형에 따라 줄의 시작과 끝에서 일치하거나 일치하지 않을 수 있습니다. 이들은 &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/에&lt;/a&gt; 지정된 유니 코드 기본 경계를 구현합니다 . 현재 사용 가능한 경계 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc44b4fc0c973a2fe9378a9f6c2bc3a5ba5d5988" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https://www.unicode.org/reports/tr14/&lt;/a&gt; and &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types are:</source>
          <target state="translated">반대로 &lt;code&gt;\b{...}&lt;/code&gt; 및 &lt;code&gt;\B{...}&lt;/code&gt; 는 경계 유형에 따라 줄의 시작과 끝에서 일치하거나 일치하지 않을 수 있습니다. 이들은 &lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https://www.unicode.org/reports/tr14/&lt;/a&gt; 및 &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/에&lt;/a&gt; 지정된 유니 코드 기본 경계를 구현합니다 . 경계 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01521aaa27588449bcad287436418e3fa90af89f" translate="yes" xml:space="preserve">
          <source>In contrast, INSTALL_BASE has predictable, easy to explain installation locations. Now that Module::Build and MakeMaker both have INSTALL_BASE there is little reason to use PREFIX other than to preserve your existing installation locations. If you are starting a fresh Perl installation we encourage you to use INSTALL_BASE. If you have an existing installation installed via PREFIX, consider moving it to an installation structure matching INSTALL_BASE and using that instead.</source>
          <target state="translated">반대로 INSTALL_BASE에는 예측 가능하고 설명이 쉬운 설치 위치가 있습니다. 이제 Module :: Build 및 MakeMaker에 INSTALL_BASE가 있으므로 기존 설치 위치를 유지하는 것 외에 PREFIX를 사용해야 할 이유가 거의 없습니다. 새로 Perl 설치를 시작하는 경우 INSTALL_BASE를 사용하는 것이 좋습니다. PREFIX를 통해 기존 설치가 설치된 경우 INSTALL_BASE와 일치하는 설치 구조로 이동하고 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b83a5099aeab352d7a9903a13c782e0d912d2e78" translate="yes" xml:space="preserve">
          <source>In contrast, hard references are more like hard links in a Unix file system: They are used to access an underlying object without concern for what its (other) name is. When the word &quot;reference&quot; is used without an adjective, as in the following paragraph, it is usually talking about a hard reference.</source>
          <target state="translated">반대로 하드 참조는 유닉스 파일 시스템의 하드 링크와 비슷합니다. 다른 참조 이름에 관계없이 기본 개체에 액세스하는 데 사용됩니다. 다음 단락과 같이 형용사없이 &quot;참조&quot;라는 단어를 사용하는 경우 일반적으로 어려운 참조에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="4fefb1775bf2d6d801dc0e18387b980f80b2a1f8" translate="yes" xml:space="preserve">
          <source>In contrast, modules in the</source>
          <target state="translated">대조적으로</target>
        </trans-unit>
        <trans-unit id="d9d8046b6af82f0d0498eb1133f08ab96606ff69" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">기업 생활에서&amp;ldquo;엔지니어링 부사장이 WebCruncher 프로젝트를 축복했습니다. 이와 유사하게, Perl로하는 공식적인 승인을 부여하는 &lt;b&gt;지시 대상을&lt;/b&gt; 그것이로 작동 할 수 있도록 &lt;b&gt;객체&lt;/b&gt; 와 같은 WebCruncher 개체로. 낙타 27 장 &quot;기능&quot; 의 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4625f6aedb66ab6c0cd003200a635f106d69fe95" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;bless&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">기업 생활에서 &quot;엔지니어링 부사장이 WebCruncher 프로젝트를 축복했습니다.&quot;와 같이 사물에 대한 공식 승인을 부여합니다. 마찬가지로 Perl에서는 WebCruncher 개체와 같은 &lt;b&gt;개체&lt;/b&gt; 로 작동 할 수 있도록 &lt;b&gt;참조 대상&lt;/b&gt; 에게 공식 승인을 부여 합니다. Camel 27 장 &quot;기능&quot; 의 &lt;code&gt;bless&lt;/code&gt; 기능을 참조하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="790c2868d3d66b4c19140a7f88a9ac87243f5c3f" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What%27s-a-closure%3F&quot;&gt;&quot;What's a closure?&quot;&lt;/a&gt;.</source>
          <target state="translated">딥 바인딩에서 익명 서브 루틴에 언급 된 어휘 변수는 서브 루틴이 생성 될 때 범위에 있던 것과 동일합니다. 얕은 바인딩에서는 서브 루틴이 호출 될 때 범위에있는 동일한 이름의 변수입니다. Perl은 항상 어휘 변수 (즉, my ()로 생성 된 변수)의 깊은 바인딩을 사용합니다. 그러나 동적 변수 (일명 전역, 로컬 또는 패키지 변수)는 효과적으로 얕게 바인딩됩니다. 이것을 사용하지 않는 또 하나의 이유를 고려하십시오. &lt;a href=&quot;#What%27s-a-closure%3F&quot;&gt;&quot;종료 란 무엇입니까?&quot;에&lt;/a&gt; 대한 답변을 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="d9b2433b690bbfb6a8d4a6c1783fb717c5f969db" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;What's a closure?&lt;/a&gt;.</source>
          <target state="translated">깊은 바인딩에서 익명 서브 루틴에 언급 된 어휘 변수는 서브 루틴이 작성 될 때 범위에 있던 것과 동일합니다. 얕은 바인딩에서는 서브 루틴이 호출 될 때 동일한 이름을 가진 변수가 범위 내에있는 것입니다. Perl은 항상 어휘 변수 (즉, my ()로 작성된 변수)의 딥 바인딩을 사용합니다. 그러나 동적 변수 (일명 글로벌, 로컬 또는 패키지 변수)는 사실상 얕은 범위에 속합니다. 이것을 사용하지 않는 또 하나의 이유를 고려하십시오. &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;폐쇄 란 무엇입니까?에&lt;/a&gt; 대한 답변을 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="99e7fbb09770b6f32c5f70c75d8aea1be23012f2" translate="yes" xml:space="preserve">
          <source>In default</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="20fadc3ec5ca97e1da30f076e8b9de4f5b9c66b4" translate="yes" xml:space="preserve">
          <source>In directories where either &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; exist, &lt;code&gt;perldoc&lt;/code&gt; will add &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; first to its search path, and as long as you're not the superuser will add &lt;code&gt;blib&lt;/code&gt; too. This is really helpful if you're working inside of a build directory and want to read through the docs even if you have a version of a module previously installed.</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 또는 &lt;code&gt;Build.PL&lt;/code&gt; 이 존재하는 디렉토리에 &lt;code&gt;perldoc&lt;/code&gt; 이 추가 &lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;lib&lt;/code&gt; 는 검색 경로로 먼저 가고, 수퍼 유저가 아닌 한 &lt;code&gt;blib&lt;/code&gt; 도 추가 합니다. 이것은 빌드 디렉토리 내부에서 작업 중이고 이전에 설치된 모듈 버전이 있어도 문서를 읽고 싶을 때 정말 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ea11b5cca3eecd37f4df3d54042b48987e1a258f" translate="yes" xml:space="preserve">
          <source>In double-quotish context, as is usually the case, you need to be careful about &lt;code&gt;&quot;$&quot;&lt;/code&gt; and the non-metacharacter &lt;code&gt;&quot;@&quot;&lt;/code&gt;. Those could interpolate variables, which may or may not be what you intended.</source>
          <target state="translated">큰 따옴표 문맥에서 일반적으로 그렇듯이 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 및 메타 문자가 아닌 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 에 대해주의해야합니다 . 그것들은 당신이 의도 한 바일 수도 있고 아닐 수도있는 변수를 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd19cad20b9e59643f15ee87358174035c99ef1" translate="yes" xml:space="preserve">
          <source>In each case, the port or service name (e.g. &lt;code&gt;80&lt;/code&gt;) is passed as the &lt;code&gt;LocalService&lt;/code&gt; or &lt;code&gt;PeerService&lt;/code&gt; argument.</source>
          <target state="translated">각각의 경우 포트 또는 서비스 이름 (예 : &lt;code&gt;80&lt;/code&gt; )이 &lt;code&gt;LocalService&lt;/code&gt; 또는 &lt;code&gt;PeerService&lt;/code&gt; 인수 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b98ec9678a77351791b177991b84c25fc1205921" translate="yes" xml:space="preserve">
          <source>In each of the following groups, there may be many more constants provided than just the ones given as examples in the section heading. If the heading ends &lt;code&gt;...&lt;/code&gt; then this means there are likely more; the exact constants provided will depend on the OS and headers found at compile-time.</source>
          <target state="translated">다음의 각 그룹에는 섹션 제목의 예제로 제공된 것보다 더 많은 상수가 제공 될 수 있습니다. 제목이 끝나면 &lt;code&gt;...&lt;/code&gt; 더 많은 것이 있음을 의미합니다. 제공되는 정확한 상수는 컴파일 타임에 찾은 OS 및 헤더에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b68e75d7a1476c3ad7fa38606ac2d7ce5e34258a" translate="yes" xml:space="preserve">
          <source>In earlier Perl versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">이전 Perl 버전에서는 바이트와 문자 데이터가 연결되었을 때 때때로 바이트 문자열을 다음과 같이 디코딩하여 새 문자열이 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="85963e44254facb2c74a4ad36d06d1d324a0415d" translate="yes" xml:space="preserve">
          <source>In earlier Perls, this bit was named &lt;code&gt;UTF8_GOT_ABOVE_31_BIT&lt;/code&gt;, which you still may use for backward compatibility. That name is misleading, as this flag may be set when the code point actually does fit in 31 bits. This happens on EBCDIC platforms, and sometimes when the &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;overlong malformation&lt;/a&gt; is also present. The new name accurately describes the situation in all cases.</source>
          <target state="translated">이전 Perls에서는이 비트의 이름이 &lt;code&gt;UTF8_GOT_ABOVE_31_BIT&lt;/code&gt; 였으며 여전히 이전 버전과의 호환성을 위해 사용할 수 있습니다. 코드 포인트가 실제로 31 비트에 맞을 때이 플래그가 설정 될 수 있으므로이 이름은 잘못된 것입니다. 이것은 EBCDIC 플랫폼에서 발생하며 때로는 &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;지나치게 긴 기형&lt;/a&gt; 이 있을 때도 발생합니다 . 새 이름은 모든 경우의 상황을 정확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6cd886bd81b2389456301c1edaca970f0fd117a3" translate="yes" xml:space="preserve">
          <source>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">이전 버전에서 바이트 및 문자 데이터가 연결되면 바이트 문자열을 다음과 같이 디코딩하여 새 문자열이 생성되는 경우가있었습니다.</target>
        </trans-unit>
        <trans-unit id="7dc7a0656f22946eb4e770e46a3f69e5d6f40e31" translate="yes" xml:space="preserve">
          <source>In effect, your search prefix is ignored and $Config{vms_prefix} is used instead.</source>
          <target state="translated">실제로 검색 접두사는 무시되고 대신 $ Config {vms_prefix}가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94c2468a1701c5657c0fd595d96849c8e021725b" translate="yes" xml:space="preserve">
          <source>In either case, please &lt;b&gt;attach&lt;/b&gt; patches to the bug report rather than including them inline in the web post or the body of the email.</source>
          <target state="translated">두 경우 모두 웹 게시물이나 이메일 본문에 패치를 인라인으로 포함하지 말고 버그 보고서 &lt;b&gt;에&lt;/b&gt; 패치를 &lt;b&gt;첨부하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="4c62ad53bb4b783795294732eef580256b60e336" translate="yes" xml:space="preserve">
          <source>In either case, you should still be able to run the scripts with perl explicitly:</source>
          <target state="translated">두 경우 모두 perl을 사용하여 스크립트를 명시 적으로 실행할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="10204eb47c47fbf1753216a2fbda8ce2e5713135" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; or &lt;b&gt;perl -V&lt;/b&gt; to get system configuration information to include in your issue report.</source>
          <target state="translated">극단적 인 경우 &lt;b&gt;perlbug&lt;/b&gt; 는 시스템에서 버그 보고서 작성을 안내하기에 충분하지 않을 수 있습니다. 이 경우 &lt;b&gt;perlbug -d&lt;/b&gt; 또는 &lt;b&gt;perl -V&lt;/b&gt; 를 사용 하여 문제 보고서에 포함 할 시스템 구성 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb41a30683f07ad432fb7627b6f4d0b50b059664" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; to get system configuration information to include in a manually composed bug report to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">극단적 인 경우 시스템에서 버그 보고서 작성을 안내하기에 &lt;b&gt;perlbug&lt;/b&gt; 가 제대로 작동하지 않을 수 있습니다. 이러한 경우 &lt;b&gt;perlbug -d&lt;/b&gt; 를 사용 하여 수동으로 구성된 버그 보고서에 &lt;b&gt;perlbug@perl.org&lt;/b&gt; 에 포함시킬 시스템 구성 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="937f09e779144f446b6eecefbcdc1c71e24ac90e" translate="yes" xml:space="preserve">
          <source>In fact if you want to update your local repository without touching your working directory you do:</source>
          <target state="translated">실제로 작업 디렉토리를 건드리지 않고 로컬 저장소를 업데이트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="abe9c1f86e0ce32785f02f8f2556f43d9ccd3599" translate="yes" xml:space="preserve">
          <source>In fact it is not 100% true that a compiled unit contains a pointer to the scratchpad AV. In fact it contains a pointer to an AV of (initially) one element, and this element is the scratchpad AV. Why do we need an extra level of indirection?</source>
          <target state="translated">실제로 컴파일 된 장치에 스크래치 패드 AV에 대한 포인터가 포함되어 있다는 것은 100 % 사실이 아닙니다. 실제로 여기에는 한 요소의 AV에 대한 포인터가 포함되어 있으며이 요소는 스크래치 패드 AV입니다. 왜 간접적 인 수준의 간접 성이 필요한가?</target>
        </trans-unit>
        <trans-unit id="e844204f376cced819af429b122503a8c0eba54a" translate="yes" xml:space="preserve">
          <source>In fact mangling of</source>
          <target state="translated">실제로 맹 글링</target>
        </trans-unit>
        <trans-unit id="3370e0fda40977698cd4fccd53b4e05e504a7a69" translate="yes" xml:space="preserve">
          <source>In fact numbers stored in the native integer format may be stored either in the signed native form, or in the unsigned native form. Thus the limits for Perl numbers stored as native integers would typically be -2**31..2**32-1, with appropriate modifications in the case of 64-bit integers. Again, this does not mean that Perl can do operations only over integers in this range: it is possible to store many more integers in floating point format.</source>
          <target state="translated">사실, 고유 정수 형식으로 저장된 숫자는 부호있는 고유 형식 또는 부호없는 고유 형식으로 저장 될 수 있습니다. 따라서 원시 정수로 저장된 Perl 수의 한계는 일반적으로 -2 ** 31..2 ** 32-1이며 64 비트 정수의 경우 적절하게 수정됩니다. 다시 말해 이것은 Perl이이 범위의 정수에 대해서만 연산을 수행 할 수 있다는 것을 의미하지는 않습니다. 더 많은 정수를 부동 소수점 형식으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c12119d45a0a6b7a7d70173ad8a47276ea5e91" translate="yes" xml:space="preserve">
          <source>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified &lt;code&gt;::&lt;/code&gt; notation even while a lexical of the same name is also visible:</source>
          <target state="translated">사실, 동적 인 변수 (패키지 또는 전역 변수라고도 함)는 동일한 이름의 어휘가 보이는 경우에도 정규화 된 &lt;code&gt;::&lt;/code&gt; 표기법을 사용하여 여전히 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fe617e28edf5522d6d7a7c2fe5c4bc3af16527" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt; , not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</source>
          <target state="translated">실제로, 그러한 curly 내의 간단한 식별자는 문자열이되어야하고 마찬가지로 해시 첨자 내에 있어야합니다. 인용도 필요 없습니다. 이전 예인 &lt;code&gt;$days{'Feb'}&lt;/code&gt; 는 &lt;code&gt;$days{Feb}&lt;/code&gt; 로 작성 될 수 있으며 따옴표는 자동으로 가정됩니다. 그러나 아래 첨자에서 더 복잡한 것은 표현식으로 해석됩니다. 예를 들어 &lt;code&gt;$version{2.0}++&lt;/code&gt; 는 &lt;code&gt;$version{'2.0'}++&lt;/code&gt; 아니라 &lt;code&gt;$version{2}++&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="870d18d0761d61a25a30e29a5f77ba577a01c448" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt;, not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt;.</source>
          <target state="translated">사실, 그러한 컬리 내의 간단한 식별자는 문자열이되어야하며 마찬가지로 해시 첨자 내에서도 마찬가지입니다. 인용 할 필요도 없습니다. 이전 예인 &lt;code&gt;$days{'Feb'}&lt;/code&gt; 는 &lt;code&gt;$days{Feb}&lt;/code&gt; 로 작성할 수 있으며 따옴표는 자동으로 가정됩니다. 그러나 아래 첨자에서 더 복잡한 것은 표현식으로 해석됩니다. 이는 예를 들어 &lt;code&gt;$version{2.0}++&lt;/code&gt; 이 &lt;code&gt;$version{'2.0'}++&lt;/code&gt; 아니라 &lt;code&gt;$version{2}++&lt;/code&gt; 과 동일 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="721f4b0102ec5d45627b4acee4d7283205201fd1" translate="yes" xml:space="preserve">
          <source>In fact, if you predeclare functions you want to call that way, you don't even need parentheses:</source>
          <target state="translated">실제로, 그런 식으로 호출하려는 함수를 미리 선언하면 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84798f732a21afa219bddab775dec767e752c195" translate="yes" xml:space="preserve">
          <source>In fact, one can put this check into a POSTCALL: section as well. Together with PREINIT: simplifications, this leads to:</source>
          <target state="translated">실제로이 검사를 POSTCALL : 섹션에도 넣을 수 있습니다. PREINIT : 단순화와 함께 이로 인해 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebdfc7c600521f2938c49c5c2856e2e2b5dd3018" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">사실 위의 내용은보다 일반적인 문제의 구체적인 예입니다. BEGIN 블록을 생성하거나 정확한 장소에서 선언을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고 보장 할 수 없습니다 . 따라서 컴파일에 영향을 미치는 모듈 (예 : 키워드 오버라이드, 상수 오버로드 등)을 사용하면 출력 코드가 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ab69392f6a1419564af0b0e6efcb82e0db27bf" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;use&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">사실, 위는보다 일반적인 문제의 특정 사례입니다. BEGIN 블록을 생성하거나 정확한 위치에서 선언을 &lt;code&gt;use&lt;/code&gt; 한다고 보장 할 수는 없습니다 . 따라서 컴파일에 영향을주는 모듈을 사용하는 경우 (예 : 키워드 재정의, 상수 재정의 등) 출력 코드가 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e1b83f62468f002550abce8cac5172e95bf62f" translate="yes" xml:space="preserve">
          <source>In fact, the context stack is actually part of a stack-of-stacks system; whenever something unusual is done such as calling a &lt;code&gt;DESTROY&lt;/code&gt; or tie handler, a new stack is pushed, then popped at the end.</source>
          <target state="translated">사실 컨텍스트 스택은 실제로 스택 스택 시스템의 일부입니다. &lt;code&gt;DESTROY&lt;/code&gt; 또는 타이 핸들러 를 호출하는 것과 같은 비정상적인 작업이 수행 될 때마다 새 스택이 푸시 된 다음 끝에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7429eb30ff20d649952850c91750d9f7b5208e" translate="yes" xml:space="preserve">
          <source>In fact, the skeleton modules shown above are fully functional</source>
          <target state="translated">사실, 위에 표시된 골격 모듈은 완벽하게 작동합니다</target>
        </trans-unit>
        <trans-unit id="c08ff00d22228fb68d08d8dbc97cd530161909a6" translate="yes" xml:space="preserve">
          <source>In fact, what can happen is that the Perl subroutine you have called can access the &lt;code&gt;@_&lt;/code&gt; array from a previous Perl subroutine. This will occur when the code that is executing the</source>
          <target state="translated">실제로, 호출 한 Perl 서브 루틴이 이전 Perl 서브 루틴에서 &lt;code&gt;@_&lt;/code&gt; 배열에 액세스 할 수 있습니다 . 실행중인 코드가</target>
        </trans-unit>
        <trans-unit id="5159536cbfaf213ba408ca2109f0a550ad3339ea" translate="yes" xml:space="preserve">
          <source>In fact, you can use as many repeated angle-brackets as you like so long as you have the same number of them in the opening and closing delimiters, and make sure that whitespace immediately follows the last '&amp;lt;' of the opening delimiter, and immediately precedes the first '&amp;gt;' of the closing delimiter. (The whitespace is ignored.) So the following will also work:</source>
          <target state="translated">실제로, 여는 구분 기호와 닫는 구분 기호에 같은 수의 숫자가 있으면 원하는만큼 반복 된 꺾쇠 괄호를 사용할 수 있고 공백이 여는 구분 기호의 마지막 '&amp;lt;'바로 뒤에 오도록해야합니다. 닫는 구분 기호의 첫 번째 '&amp;gt;'바로 앞에옵니다. (공백은 무시됩니다.) 따라서 다음도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eeef4cfd76862c3bdd64f8624b59be39f324bbb5" translate="yes" xml:space="preserve">
          <source>In former versions of FindBin there was no &lt;code&gt;again&lt;/code&gt; function. The workaround was to force the &lt;code&gt;BEGIN&lt;/code&gt; block to be executed again:</source>
          <target state="translated">이전 버전의 FindBin에서는 &lt;code&gt;again&lt;/code&gt; 기능 이 없었 습니다 . 해결 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 을 강제로 다시 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="81bdf0d224677096b960b752cf09cb19f280de31" translate="yes" xml:space="preserve">
          <source>In function definitions, name starts in column 0 (return value-type is on previous line)</source>
          <target state="translated">함수 정의에서 이름은 열 0에서 시작합니다 (반환 값 유형은 이전 행에 있음)</target>
        </trans-unit>
        <trans-unit id="bd418e3b4eaab23d82d37560db5e07798de430bc" translate="yes" xml:space="preserve">
          <source>In general the flags should be preserved in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</source>
          <target state="translated">정규식 엔진은 Perl에서 일부 특수 동작을 호출하거나 비활성화하기 위해 일부를 추가 또는 삭제하려고 할 수 있지만 일반적으로 컴파일 후 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 에 플래그를 유지해야합니다 . 특수한 동작과 함께 플래그가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f8c3a47d2c8a27c27215b79122a4036f3b68a20" translate="yes" xml:space="preserve">
          <source>In general you will not be creating contexts directly. To obtain a context you should always use &lt;code&gt;context()&lt;/code&gt; which is exported by the &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; module.</source>
          <target state="translated">일반적으로 컨텍스트를 직접 생성하지 않습니다. 컨텍스트를 얻으려면 항상 &lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt; 모듈 에서 내보내는 &lt;code&gt;context()&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="76fd7f62eb6b7876bb97cdf2307bf8323fe78e66" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; should be called after &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; but before any I/O is done on the filehandle. Calling &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 후 파일 핸들에서 I / O가 수행되기 전에 호출되어야합니다 . &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; 를&lt;/a&gt; 호출하면 일반적으로 핸들에서 보류중인 버퍼링 된 출력 데이터 (및 보류중인 입력 데이터)를 플러시합니다. 이에 대한 예외 는 핸들의 기본 문자 인코딩을 변경하는 &lt;code&gt;:encoding&lt;/code&gt; 레이어입니다. &lt;code&gt;:encoding&lt;/code&gt; 층 때로는 중반 스트림에서 호출 할 필요가, 그리고 스트림을 플러시하지 않습니다. &lt;code&gt;:encoding&lt;/code&gt; 은 내부적으로 Perl이 UTF8로 인코딩 된 유니 코드 문자에서 작동하기 때문에 암시 적으로 자체적으로 &lt;code&gt;:utf8&lt;/code&gt; 레이어를 푸시 합니다.</target>
        </trans-unit>
        <trans-unit id="cf0fc22fd30f9556953173964854405f4701bcb8" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; is recommended over &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">일반적으로, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; 통해 추천 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; 이 아닌 프로그램의 실행의 중간에, 컴파일시에 모듈 가용성을 결정하기 때문에. 두 모듈이 서로를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하려고 시도 하고 각 모듈이 다른 모듈에서 함수를 호출 한 경우는 예외입니다 . 이 경우 대신 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="f3cf26c1ed42bf5b3d9ea8691cda05dc89cb71bf" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;use Module ()&lt;/code&gt; is recommended over &lt;code&gt;require Module&lt;/code&gt;, because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;use&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;require&lt;/code&gt; instead.</source>
          <target state="translated">일반적으로 &lt;code&gt;require Module&lt;/code&gt; 보다 &lt;code&gt;use Module ()&lt;/code&gt; 것이 좋습니다 . 이는 프로그램 실행 중간이 아닌 컴파일 타임에 모듈 가용성을 결정하기 때문입니다. 두 모듈이 각각 서로를 &lt;code&gt;use&lt;/code&gt; 하려고 시도 하고 각각 다른 모듈에서 함수를 호출하는 경우는 예외입니다 . 사용에이 경우, 그것은 쉽게 &lt;code&gt;require&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="781b20a886715083a2a3027ccb146131c22fb0e2" translate="yes" xml:space="preserve">
          <source>In general, Dotted-Decimal Versions permit the greatest amount of freedom to specify a version, whereas Decimal Versions enforce a certain uniformity.</source>
          <target state="translated">일반적으로 Dotted-Decimal 버전은 버전을 지정하는 데 최대한의 자유를 허용하는 반면 Decimal 버전은 일정한 균일 성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f587f957aa9f0d170955c8740a69ee20fd8f9433" translate="yes" xml:space="preserve">
          <source>In general, a value of 256MB (or &quot;256*1024*1024&quot;) is sufficient for Perl to compile at maximum optimization.</source>
          <target state="translated">일반적으로 Perl이 최대 최적화에서 컴파일하려면 256MB (또는 &quot;256 * 1024 * 1024&quot;)의 값으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="131ff1b059b6e02af211bb33de067db4f34cad70" translate="yes" xml:space="preserve">
          <source>In general, any generated Makefile checks for the current version of MakeMaker and the version the Makefile was built under. If NO_VC is set, the version check is neglected. Do not write this into your Makefile.PL, use it interactively instead.</source>
          <target state="translated">일반적으로 생성 된 모든 Makefile은 현재 버전의 MakeMaker와 Makefile이 작성된 버전을 확인합니다. NO_VC를 설정하면 버전 확인이 무시됩니다. 이것을 Makefile.PL에 쓰지 말고 대신 대화식으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ed1c758f94f821404f1b8e30ece4cfe61ee49211" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">일반적으로 binmode ()는 open () 이후에 또는 파일 핸들에서 I / O가 수행되기 전에 호출되어야합니다. binmode ()를 호출하면 일반적으로 핸들에서 보류중인 버퍼링 된 출력 데이터 (및 보류중인 입력 데이터)를 플러시합니다. 이에 대한 예외 는 핸들의 기본 문자 인코딩을 변경하는 &lt;code&gt;:encoding&lt;/code&gt; 레이어입니다. &lt;a href=&quot;#open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . &lt;code&gt;:encoding&lt;/code&gt; 층 때로는 중반 스트림에서 호출 할 필요가, 그리고 스트림을 플러시하지 않습니다. 는 &lt;code&gt;:encoding&lt;/code&gt; 암시 또한 그 자체의 위에 가압 &lt;code&gt;:utf8&lt;/code&gt; 내부적 펄 UTF8 인코딩 유니 코드 문자 동작하기 때문에 층.</target>
        </trans-unit>
        <trans-unit id="fcb23e7c19f51e6c8ab203413d609cc6c59591a8" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">일반적으로 binmode ()는 open () 이후에 또는 파일 핸들에서 I / O가 수행되기 전에 호출되어야합니다. binmode ()를 호출하면 일반적으로 핸들에서 보류중인 버퍼링 된 출력 데이터 (및 보류중인 입력 데이터)를 플러시합니다. 이에 대한 예외 는 핸들의 기본 문자 인코딩을 변경하는 &lt;code&gt;:encoding&lt;/code&gt; 레이어입니다. &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . &lt;code&gt;:encoding&lt;/code&gt; 층 때로는 중반 스트림에서 호출 할 필요가, 그리고 스트림을 플러시하지 않습니다. 는 &lt;code&gt;:encoding&lt;/code&gt; 암시 또한 그 자체의 위에 가압 &lt;code&gt;:utf8&lt;/code&gt; 내부적 펄 UTF8 인코딩 유니 코드 문자 동작하기 때문에 층.</target>
        </trans-unit>
        <trans-unit id="9112f219636184c8537b2886b966af1ac78ce610" translate="yes" xml:space="preserve">
          <source>In general, documentation should describe what Perl does &quot;now&quot; rather than what it used to do. It's perfectly reasonable to include notes in documentation about how behaviour has changed from previous releases, but, with very few exceptions, documentation isn't &quot;dual-life&quot; -- it doesn't need to fully describe how all old versions used to work.</source>
          <target state="translated">일반적으로, 문서는 Perl이 이전에 수행했던 것보다 &quot;현재&quot;하는 것을 설명해야합니다. 동작이 이전 릴리스에서 변경된 방식에 대한 메모를 문서에 포함하는 것이 합리적이지만 예외는 거의 없지만 문서가 &quot;이중 수명&quot;이 아니므로 모든 이전 버전의 작동 방식을 완전히 설명 할 필요는 없습니다. .</target>
        </trans-unit>
        <trans-unit id="a074510bee3b614b8e7a71cd1b464639580f9e03" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;``&lt;/code&gt; or &lt;code&gt;qx//&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">일반적으로 이식 가능한 코드로 시스템에 직접 액세스하지 마십시오. 그 수단없이 &lt;a href=&quot;perlfunc#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt; &lt;code&gt;``&lt;/code&gt; 또는 &lt;code&gt;qx//&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; A를 &lt;code&gt;|&lt;/code&gt; , 또는 Perl 해커가 될 가치가있는 다른 것들도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c3bded401bb84dc2978238aa4ca8d1e409847f99" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">일반적으로 이식성이 뛰어난 코드로 시스템에 직접 액세스하지 마십시오. 수단, 아니 그 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; A를 &lt;code&gt;|&lt;/code&gt; 그리고 Perl 해커가 될만한 다른 것들도 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d0cabae10db7de03b357778791ebb3ae57baf9a" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like &lt;a href=&quot;http://man.he.net/man2/chown&quot;&gt;chown(2)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man2/closedir&quot;&gt;closedir(2)&lt;/a&gt;, etc.) return true when they succeed and &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#waitpid-PID%2CFLAGS&quot;&gt;&lt;code&gt;waitpid&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt;. System calls also set the special &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">일반적으로 동일한 이름 (예 : &lt;a href=&quot;http://man.he.net/man2/chown&quot;&gt;chown (2)&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork (2)&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man2/closedir&quot;&gt;closedir (2)&lt;/a&gt; 등)의 시스템 호출 ( &quot;syscalls&quot;)에 대한 래퍼 역할을하는 Perl의 함수는 성공하면 true를 반환하고 그렇지 않으면 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 반환합니다. , 일반적으로 아래 설명에 언급되어 있습니다. 이는 실패시 &lt;code&gt;-1&lt;/code&gt; 을 반환하는 C 인터페이스와 다릅니다 . 이 규칙에 대한 예외에는 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#waitpid-PID%2CFLAGS&quot;&gt; &lt;code&gt;waitpid&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; 이 포함&lt;/a&gt; 됩니다. 시스템 호출도 특별 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt; 실패시 변수. 우연한 경우를 제외하고는 다른 기능은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4812a1f34a0b31a652cad991bba82f8957d788f2" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like chown(2), fork(2), closedir(2), etc.) return true when they succeed and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;. System calls also set the special &lt;code&gt;$!&lt;/code&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">일반적으로 같은 이름의 시스템 호출 ( &quot;syscalls&quot;)에 대한 래퍼 역할을하는 Perl의 함수 (예 : chown (2), fork (2), closedir (2) 등)는 성공하면 true를 반환하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 아래 설명에서 일반적으로 언급 한대로 이는 실패시 &lt;code&gt;-1&lt;/code&gt; 을 반환하는 C 인터페이스와 다릅니다 . 이 규칙의 예외에는 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 이 포함 됩니다. 시스템 호출은 또한 특별한 &lt;code&gt;$!&lt;/code&gt; 실패시 변수. 실수로 제외하고 다른 기능은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c889b6cf9a5ef75bf23f5e723b8633717436597" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;&lt;/b&gt; and &lt;b&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">일반적으로 프로그램에 이상이 발생하여 어디에서 도움을 받아야할지 확실하지 않은 경우 코드가 &lt;b&gt;use &lt;a href=&quot;strict&quot;&gt;strict를 준수&lt;/a&gt;&lt;/b&gt; 하고 &lt;b&gt;&lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt;&lt;/b&gt;&lt;b&gt; 사용하도록하십시오&lt;/b&gt; . 이들은 종종 문제가 정확히 어디에 있는지 지적합니다.</target>
        </trans-unit>
        <trans-unit id="2d920741739edbfdbddc6a5906e0b7d1f697b74b" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;use warnings&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">일반적으로, 뭔가 이상한 프로그램과 함께 사라지다 잘못이 있고 확실하지 않은 도움을 찾아야한다 곳에, 코드를 준수하고 시도하는 경우에 &lt;b&gt;사용 엄격한&lt;/b&gt; 및 &lt;b&gt;사용 경고&lt;/b&gt; . 이것들은 종종 문제가있는 곳을 정확히 지적합니다.</target>
        </trans-unit>
        <trans-unit id="4f338449d4134d94449e7a10434356d790a883d8" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">일반적으로 허용 MASK를 사용하여 디렉토리를 작성하고 사용자 가 제한 MASK를 제공하는 것보다 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일을 수정하도록 하는 것이 더 사용자에게 더 허용적인 방법을 제공하지 않는 것이 좋습니다. 이 규칙의 예외는 파일 또는 디렉토리를 개인용으로 유지해야하는 경우입니다 (예 : 메일 파일). &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목 은 MASK의 선택에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="859fd0676cfab168da7696f014146535cbe0534d" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">일반적으로 허용 MASK를 사용하여 디렉토리를 작성하고 사용자 가 제한 MASK를 제공하는 것보다 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일을 수정하도록 하는 것이 더 사용자에게 더 허용적인 방법을 제공하지 않는 것이 좋습니다. 이 규칙의 예외는 파일 또는 디렉토리를 개인용으로 유지해야하는 경우입니다 (예 : 메일 파일). &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목 은 MASK의 선택에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="545124287118e73717798516d78a3a8f08195676" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MODE and let the user modify that with their &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; than it is to supply a restrictive MODE and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The documentation for &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; discusses the choice of MODE in more detail.</source>
          <target state="translated">일반적으로 허용 모드를 사용하여 디렉토리를 만들고 사용자가 &lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt; 를 사용하여 수정하도록하는 것이 제한 모드를 제공하고 사용자에게 더 허용 할 수있는 방법을 제공하는 것보다 낫습니다 . 이 규칙의 예외는 파일 또는 디렉토리를 비공개로 유지해야하는 경우입니다 (예 : 메일 파일). &lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; 에&lt;/a&gt; 대한 문서 는 MODE 선택에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fa73f4a0bd2efbebe02160b7edc4173916c47a23" translate="yes" xml:space="preserve">
          <source>In general, it is necessary to evaluate the suitaility of a script to run under &lt;code&gt;sudo&lt;/code&gt; specifically with that kind of execution environment in mind. It is neither necessary nor sufficient for the same script to be suitable to run in a traditional set-id arrangement, though many of the issues overlap.</source>
          <target state="translated">일반적으로 이러한 종류의 실행 환경을 염두에두고 &lt;code&gt;sudo&lt;/code&gt; 에서 실행할 스크립트의 적합성을 평가할 필요가 있습니다. 많은 문제가 겹치지 만 동일한 스크립트를 기존의 set-id 배열로 실행하는 데 적합 할 필요도없고 충분하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="cad59e50fb94fade64091c926ff1356d37dc6324" translate="yes" xml:space="preserve">
          <source>In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3. Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example). However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated.</source>
          <target state="translated">일반적으로 예 3에서와 같이 입력 매개 변수를 수정하는 확장을 작성하는 것은 좋지 않습니다. 대신 배열에서 여러 값을 반환하고 호출자가 처리하도록 할 수 있습니다 (나중의 예에서 수행) . 그러나 종종 입력 매개 변수를 수정하는 기존 C 루틴 호출을 더 잘 수용하기 위해이 동작은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="183640340bc430e8d749b47027dff4d3c19e6dde" translate="yes" xml:space="preserve">
          <source>In general, memory allocation and de-allocation isn't something you can or should be worrying about much in Perl.</source>
          <target state="translated">일반적으로 메모리 할당 및 할당 해제는 Perl에서 많이 걱정할 수있는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="694bbd0c5ca4e3fe0dcb487e904ca0b8ccaba6cd" translate="yes" xml:space="preserve">
          <source>In general, please follow the particular style of the code you are patching.</source>
          <target state="translated">일반적으로 패치하려는 코드의 특정 스타일을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="76448cd179f9ee3d08189e3b4f4ab1ba0deb68f0" translate="yes" xml:space="preserve">
          <source>In general, production code should not have file paths hardcoded. Making them user-supplied or read from a configuration file is better, keeping in mind that file path syntax varies on different machines.</source>
          <target state="translated">일반적으로 프로덕션 코드에는 파일 경로가 하드 코드되어 있지 않아야합니다. 파일 경로 구문은 시스템마다 다르므로 사용자가 제공하거나 구성 파일에서 읽도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="15ebd5f7d0f38eb2ba1e333ec5e5f7197b5f77f7" translate="yes" xml:space="preserve">
          <source>In general, the VMS version of ext() should properly handle input from extensions originally designed for a Unix or VMS environment. If you encounter problems, or discover cases where the search could be improved, please let us know.</source>
          <target state="translated">일반적으로 ext ()의 VMS 버전은 원래 Unix 또는 VMS 환경 용으로 설계된 확장의 입력을 올바르게 처리해야합니다. 문제가 발생하거나 검색이 개선 될 수있는 사례를 발견 한 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="6fd9faf570da706152bccbfe022ff5b9665bb3b0" translate="yes" xml:space="preserve">
          <source>In general, the benefit of a language is closely related to the skill of the people using that language. If you or your team can be faster, better, and stronger through Perl, you'll deliver more value. Remember, people often respond better to what they get out of it. If you run into resistance, figure out what those people get out of the other choice and how Perl might satisfy that requirement.</source>
          <target state="translated">일반적으로 언어의 이점은 해당 언어를 사용하는 사람들의 기술과 밀접한 관련이 있습니다. Perl을 통해 귀하 또는 귀하의 팀이 더 빠르고 우수하며 강해지면 더 많은 가치를 제공 할 수 있습니다. 사람들은 종종 자신이 얻는 것에 더 잘 반응한다는 것을 기억하십시오. 저항에 부딪 치면, 사람들이 다른 선택에서 무엇을 얻는 지, 그리고 Perl이 어떻게 그 요구 사항을 충족시킬 수 있는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="c1872d2ad517d8a6c01a447283eab0112566170f" translate="yes" xml:space="preserve">
          <source>In general, the distributed kit for a Perl extension includes a file named Makefile.PL, which is a Perl program which is used to create a</source>
          <target state="translated">일반적으로 Perl 확장 용 배포 키트에는 Makefile.PL이라는 파일이 포함되어 있습니다.이 파일은 Perl 프로그램을 만드는 데 사용되는 Perl 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f86589e39189e52cad67f339850bc9ac0faa4d19" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt; module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">일반적으로 이식성에 대한 가장 쉬운 경로는 원시 명령이나 유틸리티로 처리 할 필요가없는 한 항상 Unix 형식으로 파일 이름을 지정하는 것입니다. 후자의 고려 사항 때문에 &lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt; 모듈은 기본적으로 입력 형식에 관계없이 기본 형식 사양을 반환합니다. 이 기본값은 환경에서 논리적 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 기능 을 지정하여 파일 이름이 항상 Unix 형식으로보고되도록 반전 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3997a59e30d7c4c978daa07218b367eb8d7c9173" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the File::Spec module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">일반적으로 이식성에 대한 가장 쉬운 경로는 기본 명령이나 유틸리티로 처리 할 필요가없는 한 항상 파일 이름을 Unix 형식으로 지정하는 것입니다. 후자의 고려 사항으로 인해 File :: Spec 모듈은 기본적으로 입력 형식에 관계없이 기본 형식 사양을 반환합니다. 환경에서 논리적으로 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 기능 을 지정하여 파일 이름이 항상 Unix 형식으로보고되도록이 기본값을 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28770c3025c0aede638f676bb8209a09acd6f0b6" translate="yes" xml:space="preserve">
          <source>In general, the perl interpreter views itself as the center of the universe as far as the Perl program goes. XS code is viewed as a help-mate, to accomplish things that perl doesn't do, or doesn't do fast enough, but always subservient to perl. The closer XS code adheres to this model, the less likely conflicts will occur.</source>
          <target state="translated">일반적으로 펄 통역사는 펄 프로그램이 진행되는 한 자신을 우주의 중심으로 본다. XS 코드는 펄이하지 않거나 충분히 빠르지 않지만 항상 펄에 종속적 인 일을 수행하기위한 도우미로 간주됩니다. XS 코드가이 모델에 가까울수록 충돌 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="0cb5716a5153b7e57dae5aef701221e438dfda22" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;a href=&quot;cpan&quot;&gt;&lt;code&gt;CPAN&lt;/code&gt;&lt;/a&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;a href=&quot;ExtUtils::MM_VMS&quot;&gt;&lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt;&lt;/a&gt;), and DBM modules.</source>
          <target state="translated">일반적으로 표준 모듈은 여러 플랫폼에서 작동합니다. 주목할만한 예외는 &lt;a href=&quot;cpan&quot;&gt; &lt;code&gt;CPAN&lt;/code&gt; &lt;/a&gt; 모듈 (현재는 사용할 수없는 외부 프로그램에 연결), 플랫폼 별 모듈 (예 &lt;a href=&quot;ExtUtils::MM_VMS&quot;&gt; &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; &lt;/a&gt; ) 및 DBM 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="a1d0e4d941599d8b8058171587801ee612197c61" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;code&gt;CPAN&lt;/code&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ), and DBM modules.</source>
          <target state="translated">일반적으로 표준 모듈은 여러 플랫폼에서 작동합니다. 주목할만한 예외가 있습니다 &lt;code&gt;CPAN&lt;/code&gt; 의 (현재는 사용하지 못할 수 있습니다 외부 프로그램에 대한 연결을 만드는) 모듈, (같은 플랫폼 별 모듈을 &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; 및 DBM 모듈).</target>
        </trans-unit>
        <trans-unit id="95121980b89b7a9fb796f03c8d74599823515afb" translate="yes" xml:space="preserve">
          <source>In general, there's no need to worry about the order of calls. They will be left-to-right, breadth-first, most-derived-first. This works perfectly for most inherited methods (including destructors), but is inappropriate for some kinds of methods (such as constructors, cloners, debuggers, and initializers) where it's more appropriate that the least-derived methods be called first (as more-derived methods may rely on the behaviour of their &quot;ancestors&quot;). In that case, instead of using the &lt;code&gt;EVERY&lt;/code&gt; pseudo-class:</source>
          <target state="translated">일반적으로 통화 순서에 대해 걱정할 필요가 없습니다. 그것들은 왼쪽에서 오른쪽으로, 가장 넓고, 가장 먼저 파생 될 것입니다. 이것은 대부분의 상속 된 메소드 (소멸자를 포함)에 완벽하게 작동하지만 가장 파생되지 않은 메소드를 먼저 호출하는 것이 더 적합한 일부 생성자 (생성자, 복제기, 디버거 및 초기화 프로그램)에는 부적합합니다 방법은 &quot;조상&quot;의 행동에 의존 할 수 있습니다). 이 경우 &lt;code&gt;EVERY&lt;/code&gt; 의사 클래스 를 사용하는 대신 :</target>
        </trans-unit>
        <trans-unit id="294f7f9dd3d63c6c658291241c38389ef5522490" translate="yes" xml:space="preserve">
          <source>In general, though, it's best to use the &lt;code&gt;Sv*V&lt;/code&gt; macros.</source>
          <target state="translated">그러나 일반적으로 &lt;code&gt;Sv*V&lt;/code&gt; 매크로 를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="aabaf80efaeb23cca024ae206403fa19e6f8a255" translate="yes" xml:space="preserve">
          <source>In general, with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, more detailed information will be available in the exit status for DCL scripts or other native VMS tools, and will give the expected information for Posix programs. It has not been made the default in order to preserve backward compatibility.</source>
          <target state="translated">일반적으로 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 를 사용하면 DCL 스크립트 또는 기타 기본 VMS 도구의 종료 상태에서보다 자세한 정보를 사용할 수 있으며 Posix 프로그램에 대한 예상 정보를 제공합니다. 이전 버전과의 호환성을 유지하기 위해 기본값으로 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1d7815f81eaaf88a2d89c1f351c700ea10be85e9" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3F&quot;&gt;&quot;How can I make my Perl program run faster?&quot;&lt;/a&gt;).</source>
          <target state="translated">일반적으로이 작업을 수행 할 수 없습니다. 하지만 상황에 맞는 몇 가지가 있습니다. 사람들은 일반적으로 소스 코드를 제공하지 않고 자신의 작품을 배포하기를 원하기 때문에이 질문을하며 대부분의 솔루션은 편의를 위해 디스크 공간을 교환합니다. 대부분의 솔루션은 단순히 최종 제품에 Perl 인터프리터를 번들로 묶기 때문에 속도가 크게 증가하지 않을 것입니다 ( &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3F&quot;&gt;&quot;Perl 프로그램을 더 빠르게 실행하려면 어떻게해야합니까?&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d941c018a8912081ee9a18eaddf237ed10e20a20" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;How can I make my Perl program run faster?&lt;/a&gt;).</source>
          <target state="translated">일반적으로이 작업을 수행 할 수 없습니다. 그래도 상황에 맞는 몇 가지가 있습니다. 사람들은 일반적으로 소스 코드를 제공하지 않고 자신의 작업 물을 배포하려고하기 때문에이 질문을합니다. 대부분의 솔루션은 편의를 위해 디스크 공간을 교환합니다. 대부분의 솔루션은 단순히 최종 제품에 Perl 인터프리터를 번들로 제공하기 때문에 속도가 크게 향상되지는 않을 것입니다 (그러나 &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;Perl 프로그램을 더 빠르게 실행하려면 어떻게해야합니까? 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9eadd2908a4639d8decf9b9f18aef810c6f9990" translate="yes" xml:space="preserve">
          <source>In general, you don't &quot;declare&quot; a structure. Just use a (probably anonymous) hash reference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; for details. Here's an example:</source>
          <target state="translated">일반적으로 구조를 &quot;선언&quot;하지 않습니다. (아마도 익명의) 해시 참조를 사용하십시오. 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 및 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 를 참조하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70d4ca9b1495d90b59e6399e064486d24aa6cc52" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">일반적으로 수신자가 색상 인식 디스플레이 장치를 가지고 있는지 여부를 모르기 때문에 그렇지 않습니다. 색상을 이해하는 ANSI 터미널이 있다는 것을 알고 있다면 CPAN 의 &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f00c5d5b02fc95d1502392b2b9783083f707dee" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">받는 사람에게 색상 인식 디스플레이 장치가 있는지 여부를 모르기 때문에 일반적으로 알 수 없습니다. 색상을 이해하는 ANSI 터미널이있는 경우 CPAN 의 &lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f87cb8b42da40e06ddcf5b3026af1eac6aa3d5a" translate="yes" xml:space="preserve">
          <source>In general, you either have to know what you're dealing with, or you have to guess. The API function &lt;code&gt;is_utf8_string&lt;/code&gt; can help; it'll tell you if a string contains only valid UTF-8 characters, and the chances of a non-UTF-8 string looking like valid UTF-8 become very small very quickly with increasing string length. On a character-by-character basis, &lt;code&gt;isUTF8_CHAR&lt;/code&gt; will tell you whether the current character in a string is valid UTF-8.</source>
          <target state="translated">일반적으로, 당신은 당신이 다루고있는 것을 알아야하거나 추측해야합니다. API 함수 &lt;code&gt;is_utf8_string&lt;/code&gt; 이 도움이 될 수 있습니다. 문자열에 유효한 UTF-8 문자 만 포함되어 있는지 알려주고 UTF-8이 아닌 것처럼 보이는 UTF-8이 아닌 문자열의 문자열 길이가 길어질수록 매우 빠르게 줄어 듭니다. 문자별로 &lt;code&gt;isUTF8_CHAR&lt;/code&gt; 은 문자열의 현재 문자가 유효한 UTF-8인지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0f7f43b24f7b332fad6c89f7cd9bd3e7d7da5112" translate="yes" xml:space="preserve">
          <source>In hints/os390.sh, selecting -Dusedl will default to *also* select -Duseshrplib. Having a shared plib not only requires LIBPATH to be set to the correct location of libperl.so but also makes it close to impossible to run more than one different perl that was built this way at the same time.</source>
          <target state="translated">hints / os390.sh에서 -Dusedl을 선택하면 기본적으로 * 또한 * -Duseshrplib를 선택합니다. 공유 plib를 사용하려면 LIBPATH를 libperl.so의 올바른 위치로 설정해야 할뿐만 아니라 이러한 방식으로 빌드 된 둘 이상의 다른 펄을 동시에 실행할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="26ea48aedd1cf988ca4c353ab67e2113694ba714" translate="yes" xml:space="preserve">
          <source>In human terms, it's a funny way of passing arguments to a subroutine when you define it as well as when you call it. It's useful for setting up little bits of code to run later, such as callbacks. You can even do object-oriented stuff with it, though Perl already provides a different mechanism to do that--see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">휴먼 용어로, 서브 루틴을 정의 할 때와 호출 할 때 서브 루틴에 인수를 전달하는 재미있는 방법입니다. 콜백과 같이 나중에 실행되도록 약간의 코드를 설정하는 데 유용합니다. Perl은 이미 객체 지향 작업을 수행 할 수도 있지만 Perl은 이미이를위한 다른 메커니즘을 제공합니다 ( &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6ba4c53f21b8779523425f16e680264ebae0decb" translate="yes" xml:space="preserve">
          <source>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that named sequence, and certain characters should match a sequence of multiple characters use under caseless &lt;code&gt;/i&lt;/code&gt; matching. Following those rules could lead to highly confusing situations:</source>
          <target state="translated">반전 괄호 문자 클래스에서, 펄은 일반적으로 명명 된 순서라고하는 유니 코드 규칙을 무시하고 특정 문자가 여러 문자의 순서는 대소 문자 구별에 따라 사용과 일치해야합니다 &lt;code&gt;/i&lt;/code&gt; 일치. 이러한 규칙을 따르면 혼란스러운 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a70875c03150cbfc8e14e2cc2dec49ecd50454" translate="yes" xml:space="preserve">
          <source>In its most basic usage, &lt;code&gt;ok(...)&lt;/code&gt; simply takes a single scalar expression. If its value is true, the test passes; if false, the test fails. Examples:</source>
          <target state="translated">가장 기본적인 사용법에서 &lt;code&gt;ok(...)&lt;/code&gt; 는 단일 스칼라 식을 취합니다. 값이 true이면 테스트가 통과됩니다. 거짓이면 테스트가 실패합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4d817298c353371e9d0b73c75cf1950195e64063" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;cond_wait&lt;/code&gt; takes a shared, &lt;b&gt;unlocked&lt;/b&gt; variable followed by a shared, &lt;b&gt;locked&lt;/b&gt; variable. The second variable is unlocked and thread execution suspended until another thread signals the first variable.</source>
          <target state="translated">두번째 형태에서, &lt;code&gt;cond_wait&lt;/code&gt; 는 공유 취 &lt;b&gt;해제&lt;/b&gt; 공유, 다음 가변 &lt;b&gt;로크&lt;/b&gt; 변수. 다른 스레드가 첫 번째 변수에 신호를 보낼 때까지 두 번째 변수가 잠금 해제되고 스레드 실행이 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9702efe584ddf3df38f0a305879394e6c945fd" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;cond_timedwait&lt;/code&gt; takes a &lt;b&gt;locked&lt;/b&gt; variable and an absolute timeout in</source>
          <target state="translated">두 인수 형식에서 &lt;code&gt;cond_timedwait&lt;/code&gt; 는 &lt;b&gt;잠긴&lt;/b&gt; 변수와</target>
        </trans-unit>
        <trans-unit id="fbaa31119043f388b0d536e0c6af6beff83b01ef" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; compares the two scalar values to see if they match. They match if both are undefined, or if</source>
          <target state="translated">두 인수 형식에서 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; 는 두 스칼라 값을 비교하여 일치하는지 확인합니다. 둘 다 정의되지 않은 경우 또는</target>
        </trans-unit>
        <trans-unit id="463cd3fb9dde14730ac60103e974616f5a19b70d" translate="yes" xml:space="preserve">
          <source>In late 2009, David Golden organized the version 2 proposal review process. David and Ricardo Signes drafted the final version 2 spec in April 2010 based on the version 1.4 spec and patches contributed during the proposal process.</source>
          <target state="translated">2009 년 말 David Golden은 버전 2 제안 검토 프로세스를 구성했습니다. David와 Ricardo Signes는 제안 프로세스 중에 기여한 버전 1.4 사양 및 패치를 기반으로 2010 년 4 월에 최종 버전 2 사양 초안을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="278b05f5c861132c7f4bc86f277c1645adbbdf57" translate="yes" xml:space="preserve">
          <source>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</source>
          <target state="translated">덜 장황한 용어로, 작업의 첫 번째 부분은 패턴을 컴퓨터가 문자열에서 일치하는 점을 찾기 위해 효율적으로 사용할 수있는 것으로 바꾸는 것이고, 두 번째 부분은 검색 자체를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f53ef23dfb1a32e84061a4ee3198583f6963d3be" translate="yes" xml:space="preserve">
          <source>In line 7, we make sure that the SV will have enough room to accommodate the old string, the new string and the null terminator. If &lt;code&gt;LEN&lt;/code&gt; isn't big enough, &lt;code&gt;SvGROW&lt;/code&gt; will reallocate space for us.</source>
          <target state="translated">7 행에서 SV에 이전 문자열, 새 문자열 및 널 종료자를 수용 할 수있는 충분한 공간이 있는지 확인하십시오. 경우 &lt;code&gt;LEN&lt;/code&gt; 이 큰만큼이 아닌, &lt;code&gt;SvGROW&lt;/code&gt; 는 우리를 위해 공간을 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="6338eafb38b19e3533d3d49a05621b9aaa4f97d8" translate="yes" xml:space="preserve">
          <source>In line mode, &lt;code&gt;filter_read&lt;/code&gt; will append the next source line to the end of the &lt;code&gt;$_&lt;/code&gt; scalar.</source>
          <target state="translated">라인 모드에서 &lt;code&gt;filter_read&lt;/code&gt; 는 다음 소스 라인을 &lt;code&gt;$_&lt;/code&gt; 스칼라 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a450e27bd36ea332e7d75f6381cc8a12782b5b7a" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , like so:</source>
          <target state="translated">목록 컨텍스트 (보통 원하는 것)에서이 함수는 사용자가 어떤 언어로 출력을 받아 들일 것인지를 나타내는 (최우선의) 언어 태그 목록을 반환합니다 (아마도 비어 있음). &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; 또는 &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; 처럼 :</target>
        </trans-unit>
        <trans-unit id="b8b769bcccabaec9629d49138a4947e089422ab4" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt;, like so:</source>
          <target state="translated">목록 컨텍스트 (일반적으로 원하는 것)에서이 함수는 사용자가 출력을 허용 할 언어를 나타내는 언어 태그 목록 (비어있을 수 있음)을 반환합니다. &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; 또는 &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="239ff52c002bacbd9ef8a650976d52e44cb1392b" translate="yes" xml:space="preserve">
          <source>In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.</source>
          <target state="translated">목록 컨텍스트에서 두 개의 요소 목록을 리턴합니다. 첫 번째 요소는 패턴을 포함하고 두 번째 요소는 패턴을 컴파일 할 때 사용 된 수정자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a8954af69f3e9417a81eb4843c66328678eb290e" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;//g&lt;/code&gt; 는 일치하는 그룹화 목록을 반환하거나 그룹화가없는 경우 전체 정규식과 일치하는 목록을 반환합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="4a59e7f9e300ced2156a7bfdcb5c2ed656175ffd" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;//g&lt;/code&gt; 는 일치하는 그룹화 목록을 반환하거나 그룹화가없는 경우 전체 정규 표현식과 일치하는 목록을 반환합니다. 단어 만 원한다면</target>
        </trans-unit>
        <trans-unit id="6e2b15caf8e0e18f5890e016db28894ce2475850" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;/g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;/g&lt;/code&gt; 는 일치하는 그룹 목록을 반환하거나 그룹이없는 경우 전체 정규식과 일치하는 목록을 반환합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="fa78ab0459f0c546f62a6ba44d40e5cfcd5ba381" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;/g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;/g&lt;/code&gt; 는 일치하는 그룹 목록을 반환하거나 그룹이없는 경우 전체 정규 표현식과 일치하는 목록을 반환합니다. 따라서 단어 만 원하면</target>
        </trans-unit>
        <trans-unit id="ce23af9639d689001f6ad6f1b438efaee509bdfe" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;extract_delimited&lt;/code&gt; returns a array of three elements, the extracted substring (</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;extract_delimited&lt;/code&gt; 는 추출 된 하위 문자열 (</target>
        </trans-unit>
        <trans-unit id="e472cb823d18651b8bfb2582f84acfb33002068c" translate="yes" xml:space="preserve">
          <source>In list context, F(0) and F(n) is the first and last number in the output, respectively. For example, if $n is 12, then &lt;code&gt;@F = $n-&amp;gt;bfib()&lt;/code&gt; returns the following values, F(0) to F(12):</source>
          <target state="translated">목록 컨텍스트에서 F (0) 및 F (n)은 각각 출력의 첫 번째 및 마지막 숫자입니다. 예를 들어, $ n이 12이면 &lt;code&gt;@F = $n-&amp;gt;bfib()&lt;/code&gt; 는 F (0)에서 F (12)까지 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5889fdbc3b684f4564d298e03582627a0f1d67cc" translate="yes" xml:space="preserve">
          <source>In list context, L(0) and L(n) is the first and last number in the output, respectively. For example, if $n is 12, then &lt;code&gt;@L = $n-&amp;gt;blucas()&lt;/code&gt; returns the following values, L(0) to L(12):</source>
          <target state="translated">목록 컨텍스트에서 L (0) 및 L (n)은 각각 출력의 첫 번째 및 마지막 숫자입니다. 예를 들어, $ n이 12이면 &lt;code&gt;@L = $n-&amp;gt;blucas()&lt;/code&gt; 는 L (0)에서 L (12)까지 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85fefe43cf3ce99aee8bf62db2fc923ea0e22144" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt; . So we could rewrite it as</source>
          <target state="translated">목록 컨텍스트에서 그룹화와 일치하는 &lt;code&gt;/regex/&lt;/code&gt; 는 일치하는 값 목록 &lt;code&gt;($1,$2,...)&lt;/code&gt; 을 반환합니다 . 그래서 우리는 그것을 다음과 같이 다시 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="939fd917e535aec01742cc126c0bd35df43aa502" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt;. So we could rewrite it as</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;/regex/&lt;/code&gt; 와 그룹화가 일치하면 일치하는 값 목록 &lt;code&gt;($1,$2,...)&lt;/code&gt; 이 반환됩니다 . 그래서 우리는 그것을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c008355e8673133191ef9e0d9724c780f81e596e" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned.</source>
          <target state="translated">목록 컨텍스트에서 남은 시간과 간격이 모두 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff8ef7b7f3933511d227abc0760c6958871615f" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt; .</source>
          <target state="translated">목록 컨텍스트에서 남은 시간과 간격이 모두 반환됩니다. 간격은 항상 &lt;code&gt;setitimer()&lt;/code&gt; 사용하여 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="bfe9012620873b36aaee603ca083e0f3f3500013" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt;.</source>
          <target state="translated">목록 컨텍스트에서 남은 시간과 간격이 모두 반환됩니다. 간격은 항상 &lt;code&gt;setitimer()&lt;/code&gt; 를 사용하여 입력 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1f52db4aa7cef4591f6ad21954e80ef3d1ce4ff3" translate="yes" xml:space="preserve">
          <source>In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.</source>
          <target state="translated">목록 컨텍스트에서 두 번째 매개 변수가 존재하고 TRUE를 평가하면이 메소드는 연관 배열을 리턴합니다. 연관 배열의 키는 BTREE에서 일치하는 값에 해당하며 배열의 값은 BTREE에서 특정 값이 발생한 횟수의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="611c9c24bc1f7655268ae0a922a1bafe9f75484e" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt; . Note that the values will be returned in an apparently random order.</source>
          <target state="translated">리스트 컨텍스트에서 &lt;code&gt;$key&lt;/code&gt; 와 일치하는 모든 값을 반환합니다 . 값은 명백하게 임의의 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ae580f37b964b097156f3a709cd209fec9b4b0f5" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt;. Note that the values will be returned in an apparently random order.</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;$key&lt;/code&gt; 와 일치하는 모든 값을 반환합니다 . 값은 명백하게 임의의 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e8a08a17d7e9ccb66ceef8551ab60c5578a3cb" translate="yes" xml:space="preserve">
          <source>In list context, it's just the list argument separator, and inserts both its arguments into the list. These arguments are also evaluated from left to right.</source>
          <target state="translated">목록 컨텍스트에서는 목록 인수 구분자 일 뿐이며 두 인수를 모두 목록에 삽입합니다. 이러한 주장은 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d53a53afd4d30e8bf9ee4f38d18899b7c7ca7c4f" translate="yes" xml:space="preserve">
          <source>In list context, returns a (possibly empty) list of filename expansions on the value of EXPR such as the standard Unix shell</source>
          <target state="translated">목록 컨텍스트에서 표준 Unix 쉘과 같은 EXPR 값에 대한 파일 이름 확장명 목록 (비어 있음)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f4ce95673df56dca54efc694ff26b54d19e3c4c" translate="yes" xml:space="preserve">
          <source>In list context, returns a list consisting of all the values of the named hash. In Perl 5.12 or later only, will also return a list of the values of an array; prior to that release, attempting to use an array argument will produce a syntax error. In scalar context, returns the number of values.</source>
          <target state="translated">목록 컨텍스트에서 명명 된 해시의 모든 값으로 구성된 목록을 반환합니다. Perl 5.12 이상에서만 배열 값 목록을 리턴합니다. 해당 릴리스 이전에 배열 인수를 사용하려고하면 구문 오류가 발생합니다. 스칼라 문맥에서 값의 개수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bcc561bb33b529c7d0fa7662daf305595924e45" translate="yes" xml:space="preserve">
          <source>In list context, returns a list value consisting of the elements of LIST in the opposite order. In scalar context, concatenates the elements of LIST and returns a string value with all characters in the opposite order.</source>
          <target state="translated">목록 컨텍스트에서 LIST의 요소로 구성된 목록 값을 반대 순서로 반환합니다. 스칼라 컨텍스트에서 LIST의 요소를 연결하고 모든 문자가 반대 순서로있는 문자열 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8b48751518b742e90690dec941b028dbd41c2485" translate="yes" xml:space="preserve">
          <source>In list context, returns the value or values deleted, or the last such element in scalar context. The return list's length always matches that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions.</source>
          <target state="translated">목록 컨텍스트에서 삭제 된 값 또는 스칼라 컨텍스트의 마지막 해당 요소를 리턴합니다. 반환 목록의 길이는 항상 인수 목록의 길이와 일치합니다. 존재하지 않는 요소를 삭제하면 정의되지 않은 값이 해당 위치에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a341489f824f6b17a2a55f993696ad829ad19868" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; is undefined.</source>
          <target state="translated">목록 컨텍스트에서 이것은 LIST를 정렬하고 정렬 된 목록 값을 반환합니다. 스칼라 컨텍스트에서 &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 동작 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14dda5a0315cd38b494f1396d6549e05a88ce769" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">목록 컨텍스트에서 LIST를 정렬하고 정렬 된 목록 값을 리턴합니다. 스칼라 문맥에서 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c275967193060ed0f99b2fe8baeb485ea49b9b81" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">목록 컨텍스트에서 LIST를 정렬하고 정렬 된 목록 값을 리턴합니다. 스칼라 문맥에서 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0c91abf023bc70153195871169298db2bcd959f" translate="yes" xml:space="preserve">
          <source>In list context, usually returns the value or values deleted, or the last such element in scalar context. The return list's length corresponds to that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions. When a &lt;a href=&quot;perldata#Key%2FValue-Hash-Slices&quot;&gt;key/value hash slice&lt;/a&gt; is passed to &lt;code&gt;delete&lt;/code&gt;, the return value is a list of key/value pairs (two elements for each item deleted from the hash).</source>
          <target state="translated">목록 컨텍스트에서 일반적으로 삭제 된 값 또는 스칼라 컨텍스트의 마지막 요소를 반환합니다. 반환 목록의 길이는 인수 목록의 길이에 해당합니다. 존재하지 않는 요소를 삭제하면 해당 위치에 정의되지 않은 값이 반환됩니다. 때 &lt;a href=&quot;perldata#Key%2FValue-Hash-Slices&quot;&gt;키 / 값 해시 조각이&lt;/a&gt; 전달되어 &lt;code&gt;delete&lt;/code&gt; , 반환 값은 키 / 값 쌍의 목록 (각 항목에 대한 두 가지 요소가 해시에서 삭제)입니다.</target>
        </trans-unit>
        <trans-unit id="f04d016b9064bf9bf9d2d6da3b96e6acf6fd1521" translate="yes" xml:space="preserve">
          <source>In literal patterns, the code is parsed at the same time as the surrounding code. While within the pattern, control is passed temporarily back to the perl parser, until the logically-balancing closing brace is encountered. This is similar to the way that an array index expression in a literal string is handled, for example</source>
          <target state="translated">리터럴 패턴에서 코드는 주변 코드와 동시에 구문 분석됩니다. 패턴 내에서 제어는 논리적 밸런싱 닫기 브레이스가 발생할 때까지 일시적으로 perl 파서로 다시 전달됩니다. 이는 리터럴 문자열의 배열 인덱스 표현식이 처리되는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="887e3136c0061f6a2d087f339773eb48207aff6c" translate="yes" xml:space="preserve">
          <source>In many applications it's wise to let Perl use Unicode for the strings it processes. Most of the interfaces Perl has to the outside world are still byte based. Programs therefore need to decode byte strings that enter the program from the outside and encode them again on the way out.</source>
          <target state="translated">많은 응용 프로그램에서 Perl이 처리하는 문자열에 유니 코드를 사용하도록하는 것이 현명합니다. Perl이 외부 세계에 대해 가지고있는 대부분의 인터페이스는 여전히 바이트 기반입니다. 따라서 프로그램은 외부에서 프로그램에 들어가는 바이트 문자열을 디코딩하고 나갈 때 다시 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a35afb8085f46becc13477af444009e4d377a40" translate="yes" xml:space="preserve">
          <source>In many cases, methods that are used to set the internal state of the object will return the object itself, so method calls can be conveniently chained together.</source>
          <target state="translated">대부분의 경우 객체의 내부 상태를 설정하는 데 사용되는 메서드는 객체 자체를 반환하므로 메서드 호출을 편리하게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe4577dec3e6223467649ed832dbc4e6a555dd0" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">많은 시스템에서 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그는 독점 모드로 파일을 여는 데 사용할 수 있습니다. 이것은 잠금 이 &lt;b&gt;아닙니다&lt;/b&gt; . 배타성은 파일이 이미 존재하는 경우 &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; 이 실패 함을 의미 합니다. &lt;code&gt;O_EXCL&lt;/code&gt; 은 네트워크 파일 시스템에서 작동하지 않을 수 있으며 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그도 설정 되지 않는 한 효과가 없습니다 . &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; 설정 하면 파일이 심볼릭 링크 인 경우 파일이 열리지 않습니다. 파일 경로의 심볼릭 링크로부터 보호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9b8eb0a3ccf1ee1e198f508015d1976e62c80e9" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, sysopen() fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">많은 시스템에서 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그는 독점 모드에서 파일을 여는 데 사용할 수 있습니다. 이것은 잠금 이 &lt;b&gt;아닙니다&lt;/b&gt; . 배타성은 파일이 이미 존재하면 sysopen ()이 실패 함을 의미합니다. &lt;code&gt;O_EXCL&lt;/code&gt; 은 네트워크 파일 시스템에서 작동하지 않을 수 있으며 &lt;code&gt;O_CREAT&lt;/code&gt; 플래그가 설정되어 있지 않으면 아무런 영향을 미치지 않습니다 . &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; 설정 하면 파일이 기호 링크 인 경우 파일이 열리지 않습니다. 파일 경로의 심볼릭 링크로부터 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8450d241305d74878facdc73fccc0a1c6ea4d3de" translate="yes" xml:space="preserve">
          <source>In module</source>
          <target state="translated">모듈에서</target>
        </trans-unit>
        <trans-unit id="286bdc943117014c33efb93a016a5d1869678221" translate="yes" xml:space="preserve">
          <source>In module filtering context, it can be used as Perl version filter.</source>
          <target state="translated">모듈 필터링 컨텍스트에서 Perl 버전 필터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a173a70aa245271ccb4f943a053fd8f7539c03d6" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , and &lt;code&gt;OUTPUT&lt;/code&gt; . An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">보다 실용적인 용어로, typemap은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 C 함수 매개 변수와 값을 Perl 값에 맵핑 하는 데 사용되는 코드 조각 모음입니다 . 타입 맵 파일은 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 으로 레이블이 지정된 3 개의 섹션으로 구성 될 수 있습니다 . 레이블이 지정되지 않은 초기 섹션은 &lt;code&gt;TYPEMAP&lt;/code&gt; 섹션으로 간주됩니다 . INPUT 섹션은 컴파일러에게 Perl 값을 특정 C 유형의 변수로 변환하는 방법을 알려줍니다. OUTPUT 섹션은 컴파일러에게 특정 C 유형의 값을 Perl이 이해할 수있는 값으로 변환하는 방법을 알려줍니다. TYPEMAP 섹션은 주어진 C 유형을 Perl 값에 맵핑하는 데 사용해야하는 INPUT 및 OUTPUT 코드 단편 중 어느 것을 컴파일러에 알려줍니다. 섹션 라벨 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 또는 &lt;code&gt;OUTPUT&lt;/code&gt; 은 행의 첫 번째 열에서 시작해야하며 대문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a2596ab70d131727b8db450d6439c8e749db46f7" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt;, &lt;code&gt;INPUT&lt;/code&gt;, and &lt;code&gt;OUTPUT&lt;/code&gt;. An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt;, &lt;code&gt;INPUT&lt;/code&gt;, or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">보다 실용적인 용어로, typemap은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 C 함수 매개 변수와 값을 Perl 값에 매핑 하는 데 사용하는 코드 조각 모음입니다 . typemap 파일은 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 레이블이 지정된 세 개의 섹션으로 구성 될 수 있습니다 . 레이블이없는 초기 섹션은 &lt;code&gt;TYPEMAP&lt;/code&gt; 섹션으로 간주됩니다 . INPUT 섹션은 Perl 값을 특정 C 유형의 변수로 변환하는 방법을 컴파일러에 알려줍니다. OUTPUT 섹션은 컴파일러에게 특정 C 유형의 값을 Perl이 이해할 수있는 값으로 변환하는 방법을 알려줍니다. TYPEMAP 섹션은 주어진 C 유형을 Perl 값에 매핑하는 데 사용해야하는 INPUT 및 OUTPUT 코드 조각을 컴파일러에 알려줍니다. 섹션 레이블 &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; 또는 &lt;code&gt;OUTPUT&lt;/code&gt; 은 행의 첫 번째 열에서 자체적으로 시작해야하며 대문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="fc3dbb912233fbf5258ce4b83a5eac5057d0b3f5" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for XS based extensions.</source>
          <target state="translated">대부분의 경우 사람들은 일반 모듈이든 XS 기반 확장이든 시스템의 / bin / make 프로그램보다 GNU make를 사용하여 더 나은 결과를보고했습니다.</target>
        </trans-unit>
        <trans-unit id="428ffc575a57b1bff79640b48a60fb8f688d9deb" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for xs based extensions.</source>
          <target state="translated">대부분의 경우 사람들은 일반 모듈이든 xs 기반 확장이든 시스템의 / bin / make 프로그램보다는 GNU make로 더 나은 결과를보고했습니다.</target>
        </trans-unit>
        <trans-unit id="ddebdad5fbd20cefe48a1c3287d455763963e1d8" translate="yes" xml:space="preserve">
          <source>In most cases you just need to load the desired IPC driver to make it work. You should load this driver as early as possible. A warning will be issued if you load it too late for it to be effective.</source>
          <target state="translated">대부분의 경우 원하는 IPC 드라이버를로드하기 만하면 작동합니다. 이 드라이버는 가능한 한 빨리로드해야합니다. 효과를보기에는 너무 늦게로드하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5afec4e8618986f557789f84e21b385879c2564" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &quot;binmode&quot; before you pass it as argument to the addfile() method.</source>
          <target state="translated">대부분의 경우 addio () 메소드에 인수로 전달하기 전에 $ io_handle이 &quot;binmode&quot;에 있는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c59025c8c8f5462c9fb0d9eec8118a96c3e872c2" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">대부분의 경우 addio () 메소드에 인수로 전달하기 전에 $ io_handle이 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 에 있는지 확인하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="295ff2e93e3edb18812fcf358a08839cc337a030" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;binmode&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">대부분의 경우 addfile () 메서드에 인수로 전달하기 전에 $ io_handle이 &lt;code&gt;binmode&lt;/code&gt; 에 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="525f40bb529483f51193d29f821ebe7da0a52cf3" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt; , which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt; , but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt; . Generally speaking, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 문서화되지 않은 시스템 서비스 &lt;code&gt;$SIGPRC&lt;/code&gt; 를 통해 구현되며 $ SIRCRC 와 동일한 호출 시퀀스를 &lt;code&gt;$FORCEX&lt;/code&gt; &lt;code&gt;$EXIT&lt;/code&gt; 호출을 강제로 실행하지 않고 대상 프로세스에서 예외를 발생시킵니다 . 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 CRTL의 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 함수 의 동작을 따르지만 해당 함수와 달리 신호 처리기 내에서 호출 할 수 있습니다. 또한 일부 버전의 CRTL에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 과 달리 Perl의 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은 전달 된 신호의 유효성을 확인하고 인식 할 수없는 신호를 보내려고 시도하지 않고 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df94ec9676af59ec6113f48e169109d0b6d9385f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;kill&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt;, which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt;, but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt;. Generally speaking, &lt;code&gt;kill&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;kill()&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;kill&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;kill&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">대부분의 경우, &lt;code&gt;kill&lt;/code&gt; 문서화되지 않은 시스템 서비스를 통해 구현됩니다 &lt;code&gt;$SIGPRC&lt;/code&gt; 같은 호출 순서가, &lt;code&gt;$FORCEX&lt;/code&gt; 하지만, 전화를 강제하기보다는 대상 프로세스에서 예외가 발생 &lt;code&gt;$EXIT&lt;/code&gt; . 일반적으로 &lt;code&gt;kill&lt;/code&gt; 은 CRTL의 &lt;code&gt;kill()&lt;/code&gt; 함수 의 동작을 따르지만 해당 함수와 달리 신호 처리기 내에서 호출 할 수 있습니다. 또한 일부 CRTL 버전의 &lt;code&gt;kill&lt;/code&gt; 과 달리 Perl의 &lt;code&gt;kill&lt;/code&gt; 은 전달 된 신호의 유효성을 확인하고 인식되지 않은 신호를 보내려고 시도하는 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eede988897716aa1422cf3adeb53444b2cab13f0" translate="yes" xml:space="preserve">
          <source>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</source>
          <target state="translated">대부분의 경우 단순히 문자열 연결을 사용하는 것이 더 쉬우 며 스칼라 컨텍스트를 강제 실행하기도합니다.</target>
        </trans-unit>
        <trans-unit id="ace8b1ddef61865f0aa48c02a6d220e56f6740dd" translate="yes" xml:space="preserve">
          <source>In most cases, patches to modules in</source>
          <target state="translated">대부분의 경우 모듈에 패치</target>
        </trans-unit>
        <trans-unit id="3d608639121073b361e23e425be9ba9c84646ab9" translate="yes" xml:space="preserve">
          <source>In most cases, you can just run it interactively from a command line without any special arguments and follow the prompts.</source>
          <target state="translated">대부분의 경우 특별한 인수없이 명령 행에서 대화식으로 실행하고 프롬프트를 따라갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1846566ce8422fbda676e86cc15846d05061a2" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;#round()&quot;&gt;round()&lt;/a&gt;, &lt;a href=&quot;#bround()&quot;&gt;bround()&lt;/a&gt; or &lt;a href=&quot;#bfround()&quot;&gt;bfround()&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#round()&quot;&gt;round ()&lt;/a&gt; , &lt;a href=&quot;#bround()&quot;&gt;bround ()&lt;/a&gt; 또는 &lt;a href=&quot;#bfround()&quot;&gt;bfround ()&lt;/a&gt; 중 하나를 사용 하거나 추가 정확도로 수학 연산에 원하는 정확도를 전달 하여 결과를 명시 적으로 반올림해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33cd688bb41635445ecc1419591038ede4e8360f" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;Math::BigInt#round%28%29&quot;&gt;&quot;round()&quot; in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigInt#bround%28%29&quot;&gt;&quot;bround()&quot; in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigInt#bfround%28%29&quot;&gt;&quot;bfround()&quot; in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;Math::BigInt#round%28%29&quot;&gt;Math :: BigInt&lt;/a&gt; 의 &quot;round ()&quot;, Math :: BigInt 의 &lt;a href=&quot;Math::BigInt#bround%28%29&quot;&gt;&quot;bround ()&quot;&lt;/a&gt; 또는 Math :: BigInt의 &lt;a href=&quot;Math::BigInt#bfround%28%29&quot;&gt;&quot;bfround ()&quot;중 하나를 사용&lt;/a&gt; 하거나 추가 매개 변수로 수학 연산에 원하는 정확도 :</target>
        </trans-unit>
        <trans-unit id="fbf91aec7f60195ab2e4c16d72de4bd0b0dad318" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;bigint#round()&quot;&gt;round() in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;bigint#bround()&quot;&gt;bround() in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;bigint#bfround()&quot;&gt;bfround() in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">대부분의 경우, 당신은 아마 라운드 결과는 명시 적 중 하나를 사용한다 &lt;a href=&quot;bigint#round()&quot;&gt;수학 ::에서 BigInt에서) (원형&lt;/a&gt; , &lt;a href=&quot;bigint#bround()&quot;&gt;수학에서 bround () :에서 BigInt&lt;/a&gt; 또는 &lt;a href=&quot;bigint#bfround()&quot;&gt;수학 ::에서 BigInt의를 bfround ()&lt;/a&gt; 또는 수학 연산에 원하는 정확성을 전달하여 추가 매개 변수로 :</target>
        </trans-unit>
        <trans-unit id="a42b298f707283d45326f409618401d12bc90d6e" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt;, you can use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 외부 모듈을 작성합니다. &quot;C와 Perl을 연결하는 방법에 대한 정보는 어디에서 얻을 수 있습니까? [h2xs, xsubpp]&quot;를 참조하십시오. 그러나 함수가 시스템 호출이고 시스템이 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt; 지원 하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 함수 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc로&lt;/a&gt; 문서화 됨)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65cdcdedc88950930966f20f06c6f6a1bc834c3d" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;syscall()&lt;/code&gt;, you can use the &lt;code&gt;syscall&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 외부 모듈을 작성합니다. &quot;C와 Perl을 연결하는 방법은 어디에서 배울 수 있습니까? [h2xs, xsubpp]&quot;에 대한 답변을 참조하십시오. 그러나 함수가 시스템 호출이고 시스템이 &lt;code&gt;syscall()&lt;/code&gt; 지원 하는 경우 &lt;code&gt;syscall&lt;/code&gt; 함수 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 문서화 됨)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f196207a99eece1cc9a419701bff50faa9e469c" translate="yes" xml:space="preserve">
          <source>In most instances, the function that discovers the issue sets the causal flag and returns failure immediately. &lt;a href=&quot;#Parsing-complications&quot;&gt;&quot;Parsing complications&quot;&lt;/a&gt; contains an explicit example of how this works. In other cases, such as a forward reference to a numbered parenthetical grouping, we need to finish the parse to know if that numbered grouping actually appears in the pattern. In those cases, the parse is just redone at the end, with the knowledge of how many groupings occur in it.</source>
          <target state="translated">대부분의 경우 문제를 발견하는 함수는 원인 플래그를 설정하고 즉시 실패를 반환합니다. &lt;a href=&quot;#Parsing-complications&quot;&gt;&quot;파싱 합병증&quot;&lt;/a&gt; 에는 이것이 어떻게 작동하는지에 대한 명시적인 예가 포함되어 있습니다. 번호가 매겨진 괄호 그룹에 대한 순방향 참조와 같은 다른 경우에는 번호가 매겨진 그룹이 실제로 패턴에 나타나는지 확인하기 위해 구문 분석을 완료해야합니다. 이러한 경우 구문 분석은 마지막에 몇 개의 그룹화가 발생하는지 알고있는 상태로 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d19f51a558abe46dfdc218b96bc734b3c276b079" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt; , one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt; , Mac OS uses &lt;code&gt;\015&lt;/code&gt; , and z/OS uses &lt;code&gt;\025&lt;/code&gt; .</source>
          <target state="translated">대부분의 운영 체제에서 파일의 줄은 줄 바꿈으로 끝납니다. 줄 바꿈으로 사용되는 것은 OS마다 다를 수 있습니다. 유닉스는 전통적으로 &lt;code&gt;\012&lt;/code&gt; 사용 하고 DOSish I / O 유형 중 하나는 &lt;code&gt;\015\012&lt;/code&gt; 하고 Mac OS는 &lt;code&gt;\015&lt;/code&gt; 를 사용하고 z / OS는 &lt;code&gt;\025&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f67379f4e94f10ca981b8e2ea0b0a789ca5f65aa" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt;, one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt;, Mac OS uses &lt;code&gt;\015&lt;/code&gt;, and z/OS uses &lt;code&gt;\025&lt;/code&gt;.</source>
          <target state="translated">대부분의 운영 체제에서 파일의 줄은 줄 바꿈으로 끝납니다. 개행 문자로 사용되는 것은 OS마다 다를 수 있습니다. 유닉스는 전통적으로 &lt;code&gt;\012&lt;/code&gt; 사용하고 , 한 유형의 DOSish I / O는 &lt;code&gt;\015\012&lt;/code&gt; , Mac OS는 &lt;code&gt;\015&lt;/code&gt; , z / OS는 &lt;code&gt;\025&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="59c4293bfbaf72968d51c71aab642ca2822c9579" translate="yes" xml:space="preserve">
          <source>In multithreaded scripts Perl coordinates the threads so that any thread may modify its copy of the &lt;code&gt;$0&lt;/code&gt; and the change becomes visible to ps(1) (assuming the operating system plays along). Note that the view of &lt;code&gt;$0&lt;/code&gt; the other threads have will not change since they have their own copies of it.</source>
          <target state="translated">다중 스레드 스크립트에서 Perl은 스레드가 &lt;code&gt;$0&lt;/code&gt; 의 사본을 수정할 수 있도록 변경을 수행하고 변경 사항이 ps (1)에 표시되도록합니다 (운영 체제가 작동한다고 가정). 다른 스레드 의 &lt;code&gt;$0&lt;/code&gt; 보기는 자체 사본이 있으므로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ff5aa25fe59ffebaa3d9b983e6ed41dcfbb4c10" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that either advertises a &lt;b&gt;service&lt;/b&gt; or just hangs around at a known location and waits for &lt;b&gt;clients&lt;/b&gt; who need service to get in touch with it.</source>
          <target state="translated">네트워킹에서 &lt;b&gt;서비스를&lt;/b&gt; 알리거나 알려진 위치에서 멈추고 서비스가 필요한 &lt;b&gt;클라이언트&lt;/b&gt; 가 서비스를 받기를 기다리는 &lt;b&gt;프로세스&lt;/b&gt; 입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe020f31c58d30517974e8b54ebe9cc4a8fb1397" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that initiates contact with a &lt;b&gt;server&lt;/b&gt; process in order to exchange data and perhaps receive a service.</source>
          <target state="translated">네트워킹에서 데이터를 교환하고 서비스를 받기 위해 &lt;b&gt;서버&lt;/b&gt; 프로세스 와의 연결을 시작 하는 &lt;b&gt;프로세스&lt;/b&gt; 입니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7faa009c2918d4804b660feca8b23ad35925a6e" translate="yes" xml:space="preserve">
          <source>In networking, an agreed-upon way of sending messages back and forth so that neither correspondent will get too confused.</source>
          <target state="translated">네트워킹에서, 상대방이 너무 혼동하지 않도록 합의하여 메시지를주고받는 방법.</target>
        </trans-unit>
        <trans-unit id="c0e4746f4dfd5f8f65267b46eb6ee2bd94d9dce3" translate="yes" xml:space="preserve">
          <source>In non-UTF-8 locales (hence single byte), code points above 0xFF are technically invalid. But if present, again starting in v5.26, they will collate to the same position as the highest valid code point does. This generally gives good results, but the collation order may be skewed if the valid code point gets special treatment when it forms particular sequences with other characters as defined by the locale. When two strings collate identically, the code point order is used as a tie breaker.</source>
          <target state="translated">비 UTF-8 로케일 (따라서 단일 바이트)에서 0xFF 이상의 코드 포인트는 기술적으로 유효하지 않습니다. 그러나 v5.26부터 다시 시작하면 유효한 가장 높은 코드 포인트와 동일한 위치에 정렬됩니다. 이것은 일반적으로 좋은 결과를 제공하지만 유효한 코드 포인트가 로케일에 정의 된대로 다른 문자로 특정 시퀀스를 형성 할 때 특별한 처리를 받으면 데이터 정렬 순서가 왜곡 될 수 있습니다. 두 문자열이 동일하게 조합되면 코드 포인트 순서가 타이 브레이커로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71b3fd1615492dc9bf230d9f033afbf83da86082" translate="yes" xml:space="preserve">
          <source>In normal &amp;ldquo;computerese&amp;rdquo;, the piece of data of the size most efficiently handled by your computer, typically 32 bits or so, give or take a few powers of 2. In Perl culture, it more often refers to an alphanumeric &lt;b&gt;identifier&lt;/b&gt; (including underscores), or to a string of nonwhitespace &lt;b&gt;characters&lt;/b&gt; bounded by whitespace or string boundaries.</source>
          <target state="translated">일반적인 &quot;컴퓨터&quot;에서 컴퓨터가 가장 효율적으로 처리하는 크기의 데이터 조각 (일반적으로 32 비트 정도)은 2의 거듭 제곱을 제공하거나 취합니다. Perl 문화권에서는 더 자주 영숫자 &lt;b&gt;식별자&lt;/b&gt; (밑줄 포함)를 나타냅니다. ) 또는 공백 또는 문자열 경계로 묶인 공백 이 아닌 &lt;b&gt;문자&lt;/b&gt; 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="2b1437a6901ce1f87cee7f4d6385fbba76b51c73" translate="yes" xml:space="preserve">
          <source>In object-oriented code, we often find that one object references another object. This is called &lt;b&gt;composition&lt;/b&gt;, or a &lt;b&gt;has-a&lt;/b&gt; relationship.</source>
          <target state="translated">객체 지향 코드에서는 종종 한 객체가 다른 객체를 참조한다는 것을 알 수 있습니다. 이것은 호출 &lt;b&gt;조성물&lt;/b&gt; , 또는이 &lt;b&gt;갖는-A&lt;/b&gt; 관계.</target>
        </trans-unit>
        <trans-unit id="0840885f4ae0e15a9e1a64e6e2f2e63bb6055bf6" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">예전 에는 전화 번호부와 같은 실제 색인에서 &lt;b&gt;키&lt;/b&gt; 를 찾는 행위 . 그러나 지금은 단지 해당 찾을 키 또는 위치의 어떤 종류를 사용하는 행위의 &lt;b&gt;값을&lt;/b&gt; 인덱스가 관여하지 않는 경우에도,. Perl의 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 함수가 단순히 한 문자열의 위치 (인덱스)를 다른 문자열로 찾는 지점까지 변질되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b754306ff2e4bb5b2e3f0917babd038de6c2bb80" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;index&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">옛날 에는 실제 색인 (예 : 전화 번호부)에서 &lt;b&gt;키&lt;/b&gt; 를 찾는 행위입니다 . 그러나 이제는 색인이 포함되어 있지 않더라도 해당 &lt;b&gt;값&lt;/b&gt; 을 찾기 위해 모든 종류의 키 또는 위치를 사용하는 행위 일뿐 입니다. Perl의 &lt;code&gt;index&lt;/code&gt; 기능이 단지 다른 문자열에서 한 문자열의 위치 (인덱스)를 찾는 지점까지 상황이 퇴화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8954164487b10a1a06bdaedbfbaa22faf258c328" translate="yes" xml:space="preserve">
          <source>In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see</source>
          <target state="translated">이전 유니 코드 버전에서는 적은 수의 문자 (모두 CJK 호환 표의 문자 임)가 잘못된 분해 매핑을 가질 수 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="25564a5fe1398dbc91939b7e3cb0a5bccfb1e2c1" translate="yes" xml:space="preserve">
          <source>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not &quot;characters&quot;, so converting &quot;data&quot; into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</source>
          <target state="translated">어떤 의미에서, 당신이 요구하는 것은 의미가 없습니다. 인코딩은 문자이고 이진 데이터는 &quot;문자&quot;가 아니므로 &quot;데이터&quot;를 어떤 인코딩으로 변환하는 것은 어떤 문자 세트와 인코딩을 알지 않는 한 의미가 없습니다 이진 데이터가 들어있는 경우 이진 데이터가 아니라 지금입니까?</target>
        </trans-unit>
        <trans-unit id="0665aadb9203e48ab11fdbdc61f426bdf069c8ef" translate="yes" xml:space="preserve">
          <source>In one's own MANIFEST.SKIP file, certain directives can be used to include the contents of other MANIFEST.SKIP files. At present two such directives are recognized.</source>
          <target state="translated">자신의 MANIFEST.SKIP 파일에서 특정 지시문을 사용하여 다른 MANIFEST.SKIP 파일의 내용을 포함 할 수 있습니다. 현재 두 가지 지침이 인정됩니다.</target>
        </trans-unit>
        <trans-unit id="775d518fe37c14b3f79041d34b5efaca033dd3ab" translate="yes" xml:space="preserve">
          <source>In one-liner form:</source>
          <target state="translated">한 줄짜리 형태로 :</target>
        </trans-unit>
        <trans-unit id="3a599813be17001915e0601602237bd798d15d3b" translate="yes" xml:space="preserve">
          <source>In one-shot mode this flag will be set to true if the Perl &lt;code&gt;-T&lt;/code&gt; operator thinks the file contains text.</source>
          <target state="translated">원샷 모드에서 Perl &lt;code&gt;-T&lt;/code&gt; 연산자가 파일에 텍스트가 있다고 생각하면 이 플래그가 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a387689b89f7b0ad51aa990a4b2c214ffa94375" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt; ). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;SYNOPSIS in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">메소드가 아직 정의되지 않은 경우에도 오브젝트 메소드 검색 및 / 또는 프로토 타입 검사가 올바르게 작동하려면 각 서브 루틴을 &quot;포워드 선언&quot;해야합니다 ( &lt;code&gt;sub NAME;&lt;/code&gt; ). &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsub의 시놉시스를&lt;/a&gt; 참조하십시오 . 이러한 순방향 선언은 코드가없는 자리 표시자인 &quot;서브 루틴 스텁&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="90345d24344bda0288805e106343fe2f95bd2679" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt;). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot; in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">메서드가 아직 정의되지 않은 경우에도 객체 메서드 조회 및 / 또는 프로토 타입 검사가 올바르게 작동하려면 각 서브 루틴을 &quot;포워드 선언&quot;해야합니다 (예 : &lt;code&gt;sub NAME;&lt;/code&gt; ). &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsub의 &quot;SYNOPSIS&quot;를&lt;/a&gt; 참조하십시오 . 이러한 포워드 선언은 코드가없는 자리 표시자인 &quot;서브 루틴 스텁&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0241ec9af4c551ca21dc35ad3b6791e44a33543" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use a plug-in library for core math routines. Any module which conforms to the API can be used by Math::BigInt by using this in your program:</source>
          <target state="translated">여러 개의 큰 정수 라이브러리를 허용하기 위해 Math :: BigInt가 핵심 수학 루틴에 플러그인 라이브러리를 사용하도록 다시 작성되었습니다. Math :: BigInt는 API를 따르는 모든 모듈을 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db68f3a19f1d4b1da9de666e4465352494a86e3b" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use library modules for core math routines. Any module which follows the same API as this can be used instead by using the following:</source>
          <target state="translated">여러 개의 큰 정수 라이브러리를 허용하기 위해 Math :: BigInt가 핵심 수학 루틴에 라이브러리 모듈을 사용하도록 다시 작성되었습니다. 다음과 같이 API와 동일한 API를 따르는 모든 모듈을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f9d107daff2d5afbf356c8809d8a77ed4fb993" translate="yes" xml:space="preserve">
          <source>In order to build your own version of Perl you will need 'make', which is part of Apple's developer tools - also known as Xcode. From Mac OS X 10.7 &quot;Lion&quot; onwards, it can be downloaded separately as the 'Command Line Tools' bundle directly from &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; (you will need a free account to log in), or as a part of the Xcode suite, freely available at the App Store. Xcode is a pretty big app, so unless you already have it or really want it, you are advised to get the 'Command Line Tools' bundle separately from the link above. If you want to do it from within Xcode, go to Xcode -&amp;gt; Preferences -&amp;gt; Downloads and select the 'Command Line Tools' option.</source>
          <target state="translated">자신 만의 버전의 Perl을 빌드하려면 Xcode라고도하는 Apple 개발자 도구의 일부인 'make'가 필요합니다. Mac OS X 10.7 &quot;Lion&quot;부터 &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; 에서 직접 'Command Line Tools'번들로 별도로 다운로드 하거나 (로그인하려면 무료 계정이 필요함) 또는 Xcode 제품군의 일부로 App Store에서 무료로 사용할 수 있습니다. Xcode는 꽤 큰 앱이므로 이미 가지고 있거나 실제로 원하지 않는 한 위의 링크와 별도로 'Command Line Tools'번들을 얻는 것이 좋습니다. Xcode 내에서 수행하려면 Xcode-&amp;gt; 환경 설정-&amp;gt; 다운로드로 이동하여 '명령 줄 도구'옵션을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a93cd8781d8e041e8355a0aefc4276597d7a98e8" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">문자열을 한 문자 집합에서 다른 문자 집합으로 변환하려면 위 표의 오른쪽 열과 같이 Perl의 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 연산자 와 함께 간단한 숫자 목록 만 있으면됩니다. 테이블의 데이터는 ASCII / Latin1 순서로되어 있으므로 EBCDIC 열은 사용하기 쉬운 ASCII / Latin1-EBCDIC 조작을 쉽게 역순으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2705e74e9648fc4b957e6b22cc815af6c67ac538" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;tr///&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">문자열을 한 문자 집합에서 다른 문자 집합으로 변환하려면 위 표의 오른쪽 열과 같이 Perl의 &lt;code&gt;tr///&lt;/code&gt; 연산자 와 함께 간단한 숫자 목록 만 있으면됩니다. 테이블의 데이터는 ASCII / Latin1 순서이므로 EBCDIC 열은 사용하기 쉬운 ASCII / Latin1 대 EBCDIC 연산을 제공하며 쉽게 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="614dd2adb3410a9f885520f92ddaaafdc83205d2" translate="yes" xml:space="preserve">
          <source>In order to facilitate this feature, the following code can be employed:</source>
          <target state="translated">이 기능을 용이하게하기 위해 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5fa67b20e8cfe8e347f59bf69babb07bc272aa" translate="yes" xml:space="preserve">
          <source>In order to install a new regexp handler, &lt;code&gt;$^H{regcomp}&lt;/code&gt; is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the &lt;code&gt;comp&lt;/code&gt; method is executed, and the resulting &lt;code&gt;regexp&lt;/code&gt; structure's engine field is expected to point back at the same structure.</source>
          <target state="translated">새로운 정규 표현식 핸들러를 설치하기 위해 &lt;code&gt;$^H{regcomp}&lt;/code&gt; 는 정수로 설정되어 (적절하게 캐스팅 된 경우) 이러한 구조 중 하나로 해석됩니다. 컴파일 할 때 &lt;code&gt;comp&lt;/code&gt; 메소드가 실행되고 결과 &lt;code&gt;regexp&lt;/code&gt; 구조의 엔진 필드는 동일한 구조로 되돌아 갈 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="437d80cea54e562ec941100e6a72df58383866f9" translate="yes" xml:space="preserve">
          <source>In order to keep lib.pm small and simple, it only works with Unix filepaths. This doesn't mean it only works on Unix, but non-Unix users must first translate their file paths to Unix conventions.</source>
          <target state="translated">lib.pm을 작고 단순하게 유지하기 위해 Unix 파일 경로에서만 작동합니다. 그렇다고 유닉스에서만 작동한다는 의미는 아니지만, 비 유닉스 사용자는 먼저 파일 경로를 유닉스 규칙으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="364bb5f6d99dcae74466742fdf303cf213f25184" translate="yes" xml:space="preserve">
          <source>In order to maintain maximum compatibility with earlier versions of Perl, this function will return either the floating point notation or the multiple dotted notation, depending on whether the original version contained 1 or more dots, respectively.</source>
          <target state="translated">이전 버전의 Perl과의 최대 호환성을 유지하기 위해이 함수는 원래 버전에 각각 1 개 이상의 도트가 포함되어 있는지 여부에 따라 부동 소수점 표기법 또는 다중 점 표기법을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff0a513e88ce791d6cb047a72ff030f3cd3db74e" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 MakeMaker에서 속성의 이식성을 유지하려면 &lt;code&gt;Makefile.PL&lt;/code&gt; 과 함께 &lt;a href=&quot;App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="381ea4e1bb108f2a93fb8d7c5edae34da5e15c66" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">이전 버전의 MakeMaker에서 속성의 이식성을 유지하기 위해 &lt;code&gt;Makefile.PL&lt;/code&gt; 과 함께 &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9248f937d9955a6043a592d635bc82f1867f0186" translate="yes" xml:space="preserve">
          <source>In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</source>
          <target state="translated">RECNO와 Perl의 호환성을 높이기 위해 모든 RECNO 어레이에 대한 어레이 오프셋은 Berkeley DB에서와 같이 1이 아니라 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a134e96e551361d71e9403326bccc706fc907e08" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;&quot;PERL_HASH_SEED&quot; in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;each&lt;/code&gt;.</source>
          <target state="translated">공격 키 세트를 생성 할 시드를 알 수 없도록하기 위해이 시드는 프로세스 시작시 무작위로 초기화됩니다. 이것은 PERL_HASH_SEED 환경 변수를 사용하여 재정의 될 수 있습니다 . &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;perlrun의 &quot;PERL_HASH_SEED&quot;를&lt;/a&gt; 참조하십시오 . 이 환경 변수는 항목이 &lt;code&gt;keys&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 및 &lt;code&gt;each&lt;/code&gt; 통해 표시되는 방식이 아니라 실제로 저장되는 방식을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f50d2afd74c2c616567dbb29c3d95a6bbbba68" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">공격 키 세트를 생성 할 시드를 알 수 없도록하기 위해이 시드는 프로세스 시작시 임의로 초기화됩니다. PERL_HASH_SEED 환경 변수를 사용하여이를 대체 할 수 있습니다 ( &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;perlrun의 PERL_HASH_SEED&lt;/a&gt; 참조) . 이 환경 변수는 항목이 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 통해 표시되는 방식이 아니라 실제로 저장되는 방식을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="0ee499e6bf85d10a6d431bac5ed2b0a2689595e9" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">Maketext와 모든 구성 요소가 어떻게 결합되는지 이해하려면 &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale :: Maketext :: TPJ13을 읽어야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1eda6692f2f4e28d3303c1b91852403d3cf17be" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">Maketext를 이해하고 모든 구성 요소가 어떻게 결합되는지 알아 보려면 &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="5ff6fc777d96f10921d74c27d5ed5e70b4334507" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt; , does just that.</source>
          <target state="translated">rot13 필터를 사용하려면 소스 파일을 rot13 형식으로 인코딩하는 방법이 필요합니다. 아래의 스크립트 인 &lt;code&gt;mkrot13&lt;/code&gt; 은 바로 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="e5ce5aaa659273d789866dcaf152404f645eca91" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt;, does just that.</source>
          <target state="translated">rot13 필터를 사용하려면 소스 파일을 rot13 형식으로 인코딩하는 방법이 필요합니다. 아래 스크립트 인 &lt;code&gt;mkrot13&lt;/code&gt; 은이 를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a7f6e1960069058479b2fc6d8a1c1c5f09a5d874" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;use 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt; below.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 Perl은 pragma &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt; 를 지정 하지 않는 한 전체 내부 유니 코드 지원을 설정하지 않습니다 . ( &lt;code&gt;use 5.012&lt;/code&gt; 이상 을 사용하는 경우 자동으로 선택됩니다 .) 이렇게하지 않으면 예기치 않은 놀라움이 발생할 수 있습니다. 아래의 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;&quot;유니 코드 버그 &quot;&quot;를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21d2fc600dcdd5c6cb297e557194c37b7f0f485a" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt; below.</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;사용 기능 'unicode_strings'&lt;/a&gt; 를 지정 하지 않으면 Perl은 전체 내부 유니 코드 지원을 설정하지 않습니다 . ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 경우 자동으로 선택됩니다 .) 이렇게하지 않으면 예기치 않은 놀라움이 발생할 수 있습니다. 아래 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;의 유니 코드 버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b671fb091ffbe602fd70383514c67045115109bc" translate="yes" xml:space="preserve">
          <source>In order to preserve the meaning of the processed version, the normalized representation will always contain at least three sub terms. In other words, the following is guaranteed to always be true:</source>
          <target state="translated">처리 된 버전의 의미를 보존하기 위해 정규화 된 표현에는 항상 최소 3 개의 하위 용어가 포함됩니다. 즉, 다음은 항상 참이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="fd47550c4a48b602de1804d810fabdd19f1a7062" translate="yes" xml:space="preserve">
          <source>In order to process interior sequences, subclasses implementations of this method will probably want to invoke either &lt;b&gt;interpolate()&lt;/b&gt; or &lt;b&gt;parse_text()&lt;/b&gt;, passing it the text block &lt;code&gt;$text&lt;/code&gt; , and the corresponding line number in &lt;code&gt;$line_num&lt;/code&gt; , and then perform any desired processing upon the returned result.</source>
          <target state="translated">내부 시퀀스를 처리하기 위해이 메소드의 서브 클래스 구현은 아마도 &lt;b&gt;interpolate ()&lt;/b&gt; 또는 &lt;b&gt;parse_text ()&lt;/b&gt; 를 호출 하여 텍스트 블록 &lt;code&gt;$text&lt;/code&gt; 및 해당 행 번호를 &lt;code&gt;$line_num&lt;/code&gt; 전달한 다음 원하는 처리를 수행 하려고합니다. 반환 된 결과</target>
        </trans-unit>
        <trans-unit id="c302db0fb7a3da4f6c22dd771e513397179c92f5" translate="yes" xml:space="preserve">
          <source>In order to specifically obtain the &quot;blocking connect then non-blocking send and receive&quot; behaviour of specifying this combination of options to &lt;code&gt;::INET&lt;/code&gt; when using &lt;code&gt;::IP&lt;/code&gt;, perform first a blocking connect, then afterwards turn the socket into nonblocking mode.</source>
          <target state="translated">&lt;code&gt;::IP&lt;/code&gt; 를 사용할 때 &lt;code&gt;::INET&lt;/code&gt; 에이 옵션 조합을 지정하는 &quot;차단 연결 후 비 차단 송수신&quot;동작을 얻으려면 먼저 차단 연결을 수행 한 다음 소켓을 비 차단 모드로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="96a9bbcaad8032f3708be9f9aad29a52e4a152b3" translate="yes" xml:space="preserve">
          <source>In order to test that our extension works, we now need to look at the file Mytest.t. This file is set up to imitate the same kind of testing structure that Perl itself has. Within the test script, you perform a number of tests to confirm the behavior of the extension, printing &quot;ok&quot; when the test is correct, &quot;not ok&quot; when it is not.</source>
          <target state="translated">확장 기능이 작동하는지 테스트하려면 Mytest.t 파일을 확인해야합니다. 이 파일은 Perl 자체와 동일한 종류의 테스트 구조를 모방하도록 설정되었습니다. 테스트 스크립트 내에서 확장의 동작을 확인하기 위해 여러 테스트를 수행하여 테스트가 올 바르면 &quot;확인&quot;을 인쇄하고 그렇지 않으면 &quot;확인하지 않음&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e8108d3bcd39eeb2141d68d5707c2daf6f01568e" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for details.</source>
          <target state="translated">Perl 객체를 이해하려면 먼저 Perl의 참조를 이해해야합니다. 자세한 내용은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27839c8923c39400f0c61162217f01b584f16173" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; for details.</source>
          <target state="translated">Perl 객체를 이해하려면 먼저 Perl의 참조를 이해해야합니다. 자세한 내용은 &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="769d36508232140bd94018f22812d43183fa9db1" translate="yes" xml:space="preserve">
          <source>In order to use &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD subroutine you</source>
          <target state="translated">사용하려면 &lt;b&gt;자동로드&lt;/b&gt; 의 AUTOLOAD 서브 루틴을 사용하면</target>
        </trans-unit>
        <trans-unit id="af99082b46921b802ae95263001ef07cb7aa2040" translate="yes" xml:space="preserve">
          <source>In ordinary paragraphs and in some command paragraphs, various formatting codes (a.k.a. &quot;interior sequences&quot;) can be used:</source>
          <target state="translated">일반적인 단락과 일부 명령 단락에서 다양한 형식화 코드 (일명 &quot;내부 시퀀스&quot;)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a0be2abf85a22324ace726b3f113f3ddb049b" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">다른 부울 컨텍스트에서, 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 테스트 또는 비교가 없는 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 경고 pragma 또는 &lt;b&gt;-w&lt;/b&gt; 명령 행 스위치 ( &lt;code&gt;$^W&lt;/code&gt; 변수)가 유효한 경우 경고를 유발합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db1110375e2390784483badecec61d64d1163ab0" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;defined&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">다른 부울 컨텍스트에서 명시 적으로 &lt;code&gt;defined&lt;/code&gt; 테스트 또는 비교가 없는 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;use warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 명령 줄 스위치 ( &lt;code&gt;$^W&lt;/code&gt; 변수)가 적용 되는 경우 경고 를 발생시킵니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b1fabb50ebfaee65dd88358116ce7e544578fdb" translate="yes" xml:space="preserve">
          <source>In other cases, it is the program's responsibility to transform characters into bytes using the API above before doing writes, and to transform the bytes read from a handle into characters before doing &quot;character operations&quot; (e.g. &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;/\W+/&lt;/code&gt;, ...).</source>
          <target state="translated">다른 경우에는 쓰기를 수행하기 전에 위의 API를 사용하여 문자를 바이트로 변환하고 &quot;문자 작업&quot;을 수행하기 전에 핸들에서 읽은 바이트를 문자로 변환하는 것은 프로그램의 책임입니다 (예 : &lt;code&gt;lc&lt;/code&gt; , &lt;code&gt;/\W+/&lt;/code&gt; , .. .).</target>
        </trans-unit>
        <trans-unit id="633c40ae3272eb641ed90a2b64f933bcfc1ab4fa" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. That will happen on the p5p list.</source>
          <target state="translated">다른 경우에는 패치에 더 많은 작업이나 토론이 필요합니다. 이는 p5p 목록에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c74f18e17145b68ed08eb57bab88ef99e0da3c9f" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">다른 경우에는 패치에 더 많은 작업이나 논의가 필요합니다. 토론에 참여하고 패치를 옹호하는 것이 좋습니다. 때때로 셔플에서 패치가 손실 될 수 있습니다. 한 달 동안 아무런 조치도 취하지 않은 경우 알림 이메일을 p5p로 보내는 것이 적절합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ Perl 5 개발자는 모두 자원 봉사자이며 예의 바르게 행동하십시오.</target>
        </trans-unit>
        <trans-unit id="7b3796099c87e59fc24644465a4e8f63a8bac8d4" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; 을 사용하려는 다른 파일에서 :</target>
        </trans-unit>
        <trans-unit id="3361910c0a44a8f06143bc3e2135d6b5df3e75a8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; 을 사용하려는 다른 파일에서 :</target>
        </trans-unit>
        <trans-unit id="3b8bb595443598bbfebd43734b72b246e5109db8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:</source>
          <target state="translated">모듈을 사용하려는 다른 파일에는 모듈을로드하고 심볼을 가져 오는 세 가지 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a62d5a9fb2b01aecc3f16e0f5d8dbd83913e66d" translate="yes" xml:space="preserve">
          <source>In other words this returns TRUE if &lt;code&gt;s&lt;/code&gt; points to a partial UTF-8-encoded code point.</source>
          <target state="translated">즉, &lt;code&gt;s&lt;/code&gt; 가 부분적인 UTF-8 인코딩 코드 포인트를 가리키는 경우 TRUE를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dac5b44cbcccec7c46874f1c0dae34c3e4179f83" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt; 's class hierarchy that resulted in the original call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉,에 대한 호출 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 의 깊이 우선, 왼쪽에서 오른쪽으로 검색 다시 시작 &lt;code&gt;$self&lt;/code&gt; 에 원래 통화 결과의 클래스 계층 구조 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="43077ef64c7bdb380f466e9ffbd60672fc125c18" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt;'s class hierarchy that resulted in the original call to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 에 대한 호출은 &lt;code&gt;m&lt;/code&gt; 에 대한 원래 호출이 발생한 &lt;code&gt;$self&lt;/code&gt; 의 클래스 계층 구조에 대한 깊이 우선 왼쪽에서 오른쪽 검색을 재개합니다 .</target>
        </trans-unit>
        <trans-unit id="fc23fa173938b1012fd5950a9ca473499f233be7" translate="yes" xml:space="preserve">
          <source>In other words, a phrasebook entry takes some values as parameters (the things that you fill in the blank or blanks), and provides a value based on these parameters, where the way you get that final value from the given values can, properly speaking, involve an arbitrarily complex series of operations. (In the case of Chinese, it'd be not at all complex, at least in cases like the examples at the beginning of this article; whereas in the case of Russian it'd be a rather complex series of operations. And in some languages, the complexity could be spread around differently: while the act of putting a number-expression in front of a noun phrase might not be complex by itself, it may change how you have to, for example, inflect a verb elsewhere in the sentence. This is what in syntax is called &quot;long-distance dependencies&quot;.)</source>
          <target state="translated">즉, 표현 집 항목은 일부 값을 매개 변수 (공백 또는 공백으로 채우는 것)로 취하고 이러한 매개 변수를 기반으로 값을 제공합니다. 여기서 주어진 값에서 최종 값을 얻는 방법은 적절하게 말할 수 있습니다. , 임의적으로 복잡한 일련의 작업이 포함됩니다. (중국어의 경우 적어도이 기사의 시작 부분에있는 예제와 같은 경우에는 전혀 복잡하지 않을 것입니다. 반면 러시아어의 경우에는 다소 복잡한 일련의 작업이 될 것입니다. 그리고 일부에서는 언어의 복잡성은 다르게 확산 될 수 있습니다. 명사구 앞에 숫자 표현을 넣는 행위는 그 자체로 복잡하지 않을 수 있지만, 예를 들어 문장의 다른 곳에서 동사를 활용하는 방법을 변경할 수 있습니다. . 이것은 구문에서 &quot;장거리 종속성&quot;이라고하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="a52dac3e16942362561bc185e3a6885901f3c2e9" translate="yes" xml:space="preserve">
          <source>In other words, do not &lt;code&gt;use encoding&lt;/code&gt; unless you are certain that the program will not deal with any raw, 8-bit binary data at all.</source>
          <target state="translated">즉, 프로그램이 원시 8 비트 이진 데이터를 전혀 처리하지 않는다는 확신이 없으면 &lt;code&gt;use encoding&lt;/code&gt; 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4828bb0cda42f406a7ca05570f3e0910c8f19571" translate="yes" xml:space="preserve">
          <source>In other words, each type of bracket specified as a delimiter must be balanced and correctly nested within the substring, and any other kind of (&quot;non-delimiter&quot;) bracket in the substring is ignored.</source>
          <target state="translated">다시 말해서, 분리 문자로 지정된 각 유형의 대괄호는 서브 스트링 내에 균형이 있고 올바르게 중첩되어야하며, 서브 스트링에있는 다른 종류의 ( &quot;비 구분자&quot;) 괄호는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="74fd5671e652ca312e8092bc1ce538f5b223a43a" translate="yes" xml:space="preserve">
          <source>In other words, if you try this:</source>
          <target state="translated">즉, 시도하면</target>
        </trans-unit>
        <trans-unit id="877ca893c0d0ee5563d6603bca839b1fc7617192" translate="yes" xml:space="preserve">
          <source>In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.</source>
          <target state="translated">즉, implicate_supers_strictly는 문자열 목록 (언어 태그 인 것으로 추정되며, 그렇지 않은 문자열은 무시 됨)을 취하고 주어진 전체 목록 뒤에 모든 주어진 태그의 빼기 형식을 삽입합니다. 입력 목록에 이미 표시된 태그</target>
        </trans-unit>
        <trans-unit id="25d319aebdebcd5625f4059cfe98447477589bac" translate="yes" xml:space="preserve">
          <source>In other words, in the &quot;C&quot; (or English) locale the above will probably print something like:</source>
          <target state="translated">즉, &quot;C&quot;(또는 영어) 로켈에서 위의 내용은 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="550ff39ed161b9edd0e84b02fed3dec9d30c2e67" translate="yes" xml:space="preserve">
          <source>In other words, it does not check the full recursion stack.</source>
          <target state="translated">즉, 전체 재귀 스택을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0fc4bff9ab6a124fdea1a036cef443002eab13f" translate="yes" xml:space="preserve">
          <source>In other words, it takes this:</source>
          <target state="translated">다시 말해, 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9c65668195992fe68f06679feb8eacf4cd2f8800" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">즉, 코드 포인트가 64 x 또는 대문자로 된 문자입니다. &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; 는 127이고 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 의 ord 는 64 이므로 &lt;code&gt;\c@&lt;/code&gt; 은 NULL 이므로 xor'ing 64 자체는 0을 생성하므로 ASCII 플랫폼에서 DELETE입니다 .</target>
        </trans-unit>
        <trans-unit id="3b1f13df18bf646ce1ea690c89b90d0f23fa7742" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;ord(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">즉, 코드 포인트가 대문자로 64 xor'd 된 문자입니다. &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;ord(&quot;?&quot;) ^ 64&lt;/code&gt; 는 127이고 &lt;code&gt;\c@&lt;/code&gt; 는 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 의 ord가 64 이기 때문에 ASCII 플랫폼에서 DELETE 이므로 xor'ing 64 자체는 0을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2b7ead3432ce6ef0a214c631da3fb65f28ad59d4" translate="yes" xml:space="preserve">
          <source>In other words, it's the projection of the vector onto the</source>
          <target state="translated">다시 말해 벡터가</target>
        </trans-unit>
        <trans-unit id="173982625284de4ecdaf57b42d11dd41503a3a62" translate="yes" xml:space="preserve">
          <source>In other words, once the &lt;code&gt;(*COMMIT)&lt;/code&gt; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</source>
          <target state="translated">다시 말해, 일단 &lt;code&gt;(*COMMIT)&lt;/code&gt; 이 입력되고 패턴이 일치하지 않으면 정규식 엔진은 나머지 문자열에서 더 이상 일치를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="080def995649dc7c78c927509a6265da0f050d82" translate="yes" xml:space="preserve">
          <source>In other words, text outside bracket groups is turned into string literals. Text in brackets is rather more complex, and currently follows these rules:</source>
          <target state="translated">즉, 대괄호 그룹 외부의 텍스트는 문자열 리터럴로 바뀝니다. 괄호 안의 텍스트는 다소 복잡하며 현재 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f68e3679fc5753d52f8311d0156c23ac089d43c6" translate="yes" xml:space="preserve">
          <source>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&amp;lt;use strict;&amp;gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&amp;lt;...&amp;gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</source>
          <target state="translated">즉, &quot;head1&quot;에 대한 포드 처리 핸들러는 &quot;&amp;lt;strict;&amp;gt;를 기억 했습니까?&quot;에 동일한 처리를 적용합니다. 일반 단락 (예 : &quot;C &amp;lt;...&amp;gt;&quot;와 같은 형식화 코드)에 대한 구문 분석 및 적절한 형식화가 가능하며 리터럴 공백 및 / 또는 탭 형식의 공백은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0443748797b84576038c7f78a4ac322e4d4dc07" translate="yes" xml:space="preserve">
          <source>In other words, the author of a module should be considered to have final say on modifications to their module whenever possible (bearing in mind that it's expected that everyone involved will work together and arrive at reasonable compromises when there are disagreements).</source>
          <target state="translated">다시 말해, 모듈 작성자는 가능할 때마다 모듈을 수정하는 것에 대해 최종적으로 언급하는 것으로 간주되어야합니다 (관련된 모든 사람들이 협력하여 의견 불일치가있을 경우 합리적인 타협에 도달 할 것이라는 점을 명심하십시오).</target>
        </trans-unit>
        <trans-unit id="585a94d48c61cb81b39fc84dfe81f19ca97413b7" translate="yes" xml:space="preserve">
          <source>In other words, the implementation of &lt;code&gt;extract_tagged&lt;/code&gt; is exactly equivalent to:</source>
          <target state="translated">다시 말해 &lt;code&gt;extract_tagged&lt;/code&gt; 의 구현 은 다음과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6437ac2d46829a1156ddedffd3475d352ba0e256" translate="yes" xml:space="preserve">
          <source>In other words, the previous example, would become:</source>
          <target state="translated">다시 말해, 앞의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb35ba757de61444a9e16187e2167074637a80ae" translate="yes" xml:space="preserve">
          <source>In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions: &lt;code&gt;/^$/&lt;/code&gt; matches only if you're at the beginning of the line AND the end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar. &lt;code&gt;/ab/&lt;/code&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.</source>
          <target state="translated">다시 말해, 내장 된 어설 션을 사용하는 것처럼 서로 옆에있는 두 개의 너비가 0 인 어설 션이 서로 AND 인 것처럼 작동합니다. &lt;code&gt;/^$/&lt;/code&gt; 는 시작 부분에있는 경우에만 일치합니다. 라인과 라인의 끝을 동시에. 더 근본적인 진실은 정규식에서 병치가 수직 막대를 사용하여 명시 적 OR을 작성할 때를 제외하고 항상 AND를 의미한다는 것입니다. &lt;code&gt;/ab/&lt;/code&gt; 는 &quot;a&quot;와 일치 한 다음 &quot;b&quot;와 일치하는 것을 의미하지만 &quot;a&quot;는 너비가 0이 아닌 너비가 1 개이므로 다른 위치에서 일치하는 항목이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="b22de3fc0445ea5201a62f3ef67fff0c1b919420" translate="yes" xml:space="preserve">
          <source>In other words, the version will be automatically parsed out of the string, and it will be quoted to preserve the meaning CVS normally carries for versions. The CVS $Revision$ increments differently from Decimal versions (i.e. 1.10 follows 1.9), so it must be handled as if it were a Dotted-Decimal Version.</source>
          <target state="translated">즉, 버전은 문자열에서 자동으로 구문 분석되고 CVS가 버전에 대해 일반적으로 전달하는 의미를 유지하기 위해 인용됩니다. CVS $ Revision $은 Decimal 버전과는 다르게 증가하므로 (즉, 1.10은 1.9에 이어짐) Dotted-Decimal 버전 인 것처럼 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="459d5640fff6f70049a1cb4e21dd9d95f811c50c" translate="yes" xml:space="preserve">
          <source>In other words, this is valid:</source>
          <target state="translated">다시 말해, 이것은 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="b1e37082db8f86fab9970e0f78a995b4a26a2a25" translate="yes" xml:space="preserve">
          <source>In other words, you can write:</source>
          <target state="translated">즉, 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aa186b5e0e574c2c9765bd09cdce944830c9ba2" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on binary data, like images, for example.</source>
          <target state="translated">즉, 플랫폼에 관계없이 이미지와 같은 이진 데이터에 &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="760e520ac926fbcbcf184f0f289efd734964ab6f" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use binmode() on binary data, like images, for example.</source>
          <target state="translated">즉, 플랫폼에 관계없이 이미지와 같이 이진 데이터에 binmode ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c34e83f6eab1310b3613a944eb5e27cd7e611dd" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt; , change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt; . Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt; ) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">즉 : 교체 할 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; 하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , 제거 &lt;code&gt;DynaLoader&lt;/code&gt; 에서 &lt;code&gt;@ISA&lt;/code&gt; 변경 &lt;code&gt;bootstrap&lt;/code&gt; 에 의해 &lt;code&gt;XSLoader::load&lt;/code&gt; . &lt;code&gt;XSLoader::load&lt;/code&gt; 행에서 패키지 이름을 인용 하고 인수 앞에 쉼표 ( &lt;code&gt;,&lt;/code&gt; )를 추가하십시오 ( 위의 &lt;code&gt;$VERSION&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b5c137fe49cb774422851c667c514342acdc0cc" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;require DynaLoader&lt;/code&gt; by &lt;code&gt;use XSLoader&lt;/code&gt;, remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt;, change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt;. Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt;) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">즉 : 대체 &lt;code&gt;require DynaLoader&lt;/code&gt; 에 의해 &lt;code&gt;use XSLoader&lt;/code&gt; , 제거 &lt;code&gt;DynaLoader&lt;/code&gt; 에서 &lt;code&gt;@ISA&lt;/code&gt; 변경 &lt;code&gt;bootstrap&lt;/code&gt; 에 의해 &lt;code&gt;XSLoader::load&lt;/code&gt; . &lt;code&gt;XSLoader::load&lt;/code&gt; 행에서 패키지 이름을 인용하는 것을 잊지 말고 인수 앞에 쉼표 ( &lt;code&gt;,&lt;/code&gt; )를 추가하십시오 ( 위의 &lt;code&gt;$VERSION&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc33d1c173d87ad8a862029ec4420d308b38832f" translate="yes" xml:space="preserve">
          <source>In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions. It then sets the &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; arrays and the &lt;code&gt;$VERSION&lt;/code&gt; scalar; finally it tells perl to bootstrap the module. Perl will call its dynamic loader routine (if there is one) and load the shared library.</source>
          <target state="translated">이 경우 Mytest.pm은 perl에게 Exporter 및 Dynamic Loader 확장이 필요하다고 알려줍니다. 그런 다음 &lt;code&gt;@ISA&lt;/code&gt; 및 &lt;code&gt;@EXPORT&lt;/code&gt; 배열과 &lt;code&gt;$VERSION&lt;/code&gt; 스칼라를 설정합니다. 마지막으로 펄에게 모듈을 부트 스트랩하도록 지시합니다. Perl은 동적 로더 루틴 (있는 경우)을 호출하고 공유 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="a50979678185f172c0b3a9e65775a69eef6dc7e9" translate="yes" xml:space="preserve">
          <source>In our example there is no reason to implement this method, so we leave it as a no-op. This method is only relevant to tied array implementations where there is the possibility of having the allocated size of the array be larger than is visible to a perl programmer inspecting the size of the array. Many tied array implementations will have no reason to implement it.</source>
          <target state="translated">이 예에서는이 메서드를 구현할 이유가 없으므로 no-op으로 남겨 둡니다. 이 방법은 배열의 크기를 검사하는 펄 프로그래머가 볼 수있는 것보다 배열의 할당 된 크기가 더 클 가능성이있는 연결 배열 구현에만 관련됩니다. 많은 묶인 배열 구현에는 구현할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="92b4893cf24b728e0fae1966639d9078e63fc3f7" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; :</source>
          <target state="translated">이 예에서는 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; 의해 참조되는 기본 해시에서 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb7cff901b6f0144e1ee9b6dc1a0e390ab74d831" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;scalar&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; 참조하는 기본 해시에서 &lt;code&gt;scalar&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1f779d9a34032474fc9a65f77cb8d2776cbce1" translate="yes" xml:space="preserve">
          <source>In our example we're going to create a shouting handle.</source>
          <target state="translated">이 예에서는 소리 핸들을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a13dbabebbc5437dccc50e5be8ddf3c33a642ee8" translate="yes" xml:space="preserve">
          <source>In our example, 'undef' is really an element containing &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces. Observe:</source>
          <target state="translated">이 예에서 'undef'는 실제로 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 개의 공백을 포함하는 요소 입니다. 관찰 :</target>
        </trans-unit>
        <trans-unit id="aabcb2149f4617fcf7efa6bbc92a17b687ef3353" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">이 예에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실제로 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 수의 공간이므로 여기에서 수행 할 작업이 조금 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="d967da8f9ad72b6996f76cb7869dbad1f32de0ee" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;undef&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">이 예에서 &lt;code&gt;undef&lt;/code&gt; 는 실제로 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 공간 수이므로 여기서 수행 할 작업이 조금 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1787ee08eebed75ede8020208e3ff9eccca1a6" translate="yes" xml:space="preserve">
          <source>In our example, a deleted item is &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces:</source>
          <target state="translated">이 예에서 삭제 된 항목은 &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 공백입니다.</target>
        </trans-unit>
        <trans-unit id="91424799b59a91080c214218f5e7f8c9b0b084d8" translate="yes" xml:space="preserve">
          <source>In our example, just to show you that you don't</source>
          <target state="translated">이 예에서는</target>
        </trans-unit>
        <trans-unit id="11b35d0e0b09647c243a787b95c24ae27233aecd" translate="yes" xml:space="preserve">
          <source>In our example, that would remove all the user's dot files! It's such a dangerous thing that they'll have to set CLOBBER to something higher than 1 to make it happen.</source>
          <target state="translated">이 예에서는 모든 사용자의 도트 파일을 제거합니다! CLOBBER를 1보다 큰 값으로 설정해야하는 것은 위험한 일입니다.</target>
        </trans-unit>
        <trans-unit id="8f92d427a1809586b396dc516bf348aaa08bbed7" translate="yes" xml:space="preserve">
          <source>In our example, we want to make sure there are no blank (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) entries, so &lt;code&gt;EXTEND&lt;/code&gt; will make use of &lt;code&gt;STORESIZE&lt;/code&gt; to fill elements as needed:</source>
          <target state="translated">이 예에서는 빈 ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 항목 이 없는지 확인하려고 하므로 &lt;code&gt;EXTEND&lt;/code&gt; 는 &lt;code&gt;STORESIZE&lt;/code&gt; 를 사용 하여 필요에 따라 요소를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="24d1f4e04fd957695cb0fc036193c59fca0468cd" translate="yes" xml:space="preserve">
          <source>In our example, we will determine that if an element consists of &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces only, it does not exist:</source>
          <target state="translated">이 예에서는 요소가 다음으로 구성되어 있는지 확인합니다. &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 공백으로 만 존재하지 않는 것으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9241072dd02f63704e06d0e4788fd47ef3eca294" translate="yes" xml:space="preserve">
          <source>In our example, we'll use a little shortcut if there is a</source>
          <target state="translated">이 예에서는</target>
        </trans-unit>
        <trans-unit id="6a2c73ee683cc447274fd115e41a8a6212c0860c" translate="yes" xml:space="preserve">
          <source>In our intranet, we have many modules for internal use. How can I integrate these modules with CPAN.pm but without uploading the modules to CPAN?</source>
          <target state="translated">인트라넷에는 내부 용으로 많은 모듈이 있습니다. CPAN.pm과 모듈을 CPAN에 업로드하지 않고 어떻게 통합 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e3d33b8a8cd9ee1cbb39097ccf83087f357647e8" translate="yes" xml:space="preserve">
          <source>In our tied hash DotFiles example, we use a regular hash for the object containing several important fields, of which only the &lt;code&gt;{LIST}&lt;/code&gt; field will be what the user thinks of as the real hash.</source>
          <target state="translated">우리의 공동 해시 DotFiles의 예에서 우리는 몇 가지 중요한 필드를 포함하는 개체에 대한 일반 해시를 사용하는 단지의 &lt;code&gt;{LIST}&lt;/code&gt; 필드 사용자가 실제 해시로 생각합니다.</target>
        </trans-unit>
        <trans-unit id="07709450f49a2785357dceda9bbcd6e033ef5380" translate="yes" xml:space="preserve">
          <source>In paragraphs where formatting codes (like E&amp;lt;...&amp;gt;, B&amp;lt;...&amp;gt;) are understood (i.e.,</source>
          <target state="translated">서식 코드 (예 : E &amp;lt;...&amp;gt;, B &amp;lt;...&amp;gt;)가 이해되는 단락에서 (즉,</target>
        </trans-unit>
        <trans-unit id="fb0742f46f732e81f9ef6b26f9dd077a50514538" translate="yes" xml:space="preserve">
          <source>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the &lt;code&gt;parse_text&lt;/code&gt; routine in Pod::Parser as an example of a correct implementation.</source>
          <target state="translated">포드를 파싱하는 데있어 까다로운 부분은 포맷팅 코드를 올바르게 파싱하는 것입니다. 구현 자는 올바른 구현의 예로 Pod :: Parser 의 &lt;code&gt;parse_text&lt;/code&gt; 루틴에 있는 코드를 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e44b2915e9ebcfa80eaf0cd0b8fc6a537b378a7a" translate="yes" xml:space="preserve">
          <source>In parsing an L&amp;lt;...&amp;gt; code, Pod parsers must distinguish at least four attributes:</source>
          <target state="translated">L &amp;lt;...&amp;gt; 코드를 구문 분석 할 때 포드 파서는 최소한 네 가지 속성을 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="173ae1b4c7abf280ed9de2a2e4233e82968c1ade" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt; . But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt; ) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt; ). Casing in this document is for improved legibility.</source>
          <target state="translated">이러한 구문을 구문 분석 할 때 Perl은 항상 {braces} 내의 모든 위치에서 대문자 / 소문자 차이를 무시합니다. 따라서 &lt;code&gt;\p{Greek}&lt;/code&gt; 은 &lt;code&gt;\p{greek}&lt;/code&gt; 와 같은 의미 입니다. 그러나 왼쪽 괄호 앞에 &lt;code&gt;&quot;p&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 의 대소 문자를 변경하면 구문의 의미가 &quot;match&quot;( &lt;code&gt;\p{}&lt;/code&gt; )에서 &quot;does n't match&quot;( &lt;code&gt;\P{}&lt;/code&gt; ). 이 문서의 케이스는 가독성을 향상시키기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="567197a99a2b6b0fd77102ccbee0d1f2509d1634" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt;. But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt;) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt;). Casing in this document is for improved legibility.</source>
          <target state="translated">이러한 구조를 구문 분석 할 때 Perl은 {braces} 내의 모든 곳에서 대문자 / 소문자 차이를 항상 무시합니다. 따라서 &lt;code&gt;\p{Greek}&lt;/code&gt; 은 &lt;code&gt;\p{greek}&lt;/code&gt; 와 같은 의미 입니다. 그러나 왼쪽 중괄호 앞 의 &lt;code&gt;&quot;p&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 대소 문자를 변경하면 구문의 의미가 &quot;일치&quot;( &lt;code&gt;\p{}&lt;/code&gt; )에서 &quot;일치하지 않음&quot;( &lt;code&gt;\P{}&lt;/code&gt; )으로 완전히 변경됩니다. } ). 이 문서의 대소 문자는 가독성을 높이기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9aaf8e25ca7ca9dd8d4b03a35ad6a47a7f371c04" translate="yes" xml:space="preserve">
          <source>In particular</source>
          <target state="translated">특히</target>
        </trans-unit>
        <trans-unit id="2f4b20effb603658d4594f20068f3202a019f207" translate="yes" xml:space="preserve">
          <source>In particular have a hunt around for the following:</source>
          <target state="translated">특히 다음을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="549a73d37bd647b3d02bdfb1ed4587a94e6c791c" translate="yes" xml:space="preserve">
          <source>In particular the following metacharacters have their standard</source>
          <target state="translated">특히 다음 메타 문자는 표준을 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="d9ca3d8c112df43cded72f31c7db395214aede20" translate="yes" xml:space="preserve">
          <source>In particular,</source>
          <target state="translated">특히,</target>
        </trans-unit>
        <trans-unit id="ef80eb5daee93a0d4fde8126fc49aefdc4e89c82" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Tie::File&lt;/code&gt; will</source>
          <target state="translated">특히, &lt;code&gt;Tie::File&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2db3c0671aba0d3ee80c31fffb1da43c83f4160e" translate="yes" xml:space="preserve">
          <source>In particular, braces do not need to be balanced:</source>
          <target state="translated">특히 중괄호는 균형을 맞출 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cbf0bbf93ed5b0e470ae4c77978f151618da6e4" translate="yes" xml:space="preserve">
          <source>In particular, follow these general guidelines for patching Perl sources:</source>
          <target state="translated">특히 Perl 소스 패치에 대한 다음 일반 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="588a69fc1734910196fa33dcc3398592c9c2b486" translate="yes" xml:space="preserve">
          <source>In particular, if you are using Info-Zip you need to have zip version 3.x or better to update a Zip64 archive and unzip version 6.x to read a zip64 archive.</source>
          <target state="translated">특히 Info-Zip을 사용하는 경우 Zip64 아카이브를 업데이트하려면 zip 버전 3.x 이상이 필요하고 zip64 아카이브를 읽으려면 버전 6.x의 압축을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b8504eca27d4d7dd980e055d06368ef344507bf5" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">특히 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; FH를 사용하여 파이프를 열면 &quot;|-&quot; 부모 프로세스에서 close ()를 사용하여 원치 않는 기록기를 닫을 수 없습니다. 이 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="617f0768594e1a999044d2a759bf8abcc2e11a58" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt;, then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">특히 &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt; 사용하여 파이프를 연 경우 부모 프로세스에서 close ()를 사용하여 원하지 않는 작성기를 닫을 수는 없습니다. 이 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="55f883bf0e56efd410000618d8c0d414be5f0032" translate="yes" xml:space="preserve">
          <source>In particular, it is not possible to write general-purpose classes in this technique, classes that can advertise themselves as &quot;Put me on your @ISA list and use my methods&quot;. If the other class has different ideas about how the object body is used, there is trouble.</source>
          <target state="translated">특히,이 기술에서 범용 클래스를 작성하는 것은 불가능합니다. &quot;@ISA 목록에 저를두고 내 방법을 사용하십시오&quot;라고 스스로 광고 할 수있는 클래스입니다. 다른 클래스가 객체 바디 사용 방법에 대해 다른 아이디어를 가지고 있다면 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03344b04b4c0d7615be3556f843e83b5fe66f49c" translate="yes" xml:space="preserve">
          <source>In particular, matches in the Block property have single forms defined by Perl that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt;, &lt;code&gt;&quot;Is_&lt;/code&gt;, or even with no prefix at all, Like all &lt;b&gt;DISCOURAGED&lt;/b&gt; forms, these are not stable. For example, &lt;code&gt;\p{Block=Deseret}&lt;/code&gt; can currently be written as &lt;code&gt;\p{In_Deseret}&lt;/code&gt;, &lt;code&gt;\p{Is_Deseret}&lt;/code&gt;, or &lt;code&gt;\p{Deseret}&lt;/code&gt;. But, a new Unicode version may come along that would force Perl to change the meaning of one or more of these, and your program would no longer be correct. Currently there are no such conflicts with the form that begins &lt;code&gt;&quot;In_&quot;&lt;/code&gt;, but there are many with the other two shortcuts, and Unicode continues to define new properties that begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt;, so it's quite possible that a conflict will occur in the future. The compound form is guaranteed to not become obsolete, and its meaning is clearer anyway. See &lt;a href=&quot;perlunicode#Blocks&quot;&gt;&quot;Blocks&quot; in perlunicode&lt;/a&gt; for more information about this.</source>
          <target state="translated">특히 Block 속성의 일치 항목에는 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; , &lt;code&gt;&quot;Is_&lt;/code&gt; 으로 시작하거나 접두사가 전혀없는 경우에도 Perl에 의해 정의 된 단일 형식 이 있습니다. 모든 &lt;b&gt;DISCOURAGED&lt;/b&gt; 형식 과 마찬가지로 이러한 형식은 안정적이지 않습니다. 예 : &lt;code&gt;\p{Block=Deseret}&lt;/code&gt; 은 현재 &lt;code&gt;\p{In_Deseret}&lt;/code&gt; , &lt;code&gt;\p{Is_Deseret}&lt;/code&gt; 또는 &lt;code&gt;\p{Deseret}&lt;/code&gt; 로 쓸 수 있습니다 .하지만 새로운 유니 코드 버전이 나오면 Perl이 이들 중 하나 이상의 의미를 변경해야합니다. 당신의 프로그램은 더 이상 정확하지 않을 것입니다. 현재 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 으로 시작하는 형태와는 그러한 충돌이 없지만 다른 두 개의 바로 가기에는 많은 충돌이 있으며 유니 코드는 다음으로 시작하는 새로운 속성을 계속 정의합니다. &lt;code&gt;&quot;In&quot;&lt;/code&gt; 이므로 향후 충돌이 발생할 가능성이 높습니다. 복합 형태는 구식이되지 않도록 보장되며 그 의미는 어쨌든 더 명확합니다. &lt;a href=&quot;perlunicode#Blocks&quot;&gt;이에&lt;/a&gt; 대한 자세한 내용은 perlunicode의 &quot;블록&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fd11e0201dc297df1cba370809db0d5939f0ec0" translate="yes" xml:space="preserve">
          <source>In particular, the extensions &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; and &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; are not supported under EBCDIC; likewise for the (now deprecated) &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma.</source>
          <target state="translated">특히 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: Collate&lt;/a&gt; 및 &lt;a href=&quot;unicode/normalize&quot;&gt;유니 코드 :: Normalize&lt;/a&gt; 확장 은 EBCDIC에서 지원되지 않습니다. (현재 사용되지 않는) &lt;a href=&quot;encoding&quot;&gt;인코딩&lt;/a&gt; pragma에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="b491336832fe24926f813912697f1c74d79ed48d" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt; , regardless of any &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">특히, 특수 &lt;code&gt;${^_XYZ}&lt;/code&gt; 변수는 현재 범위 내에 있는 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 선언에 관계없이 항상 패키지 &lt;code&gt;main&lt;/code&gt; 에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a1a5cc8fc75fe5ee962a5cf753fa9e49875cad8" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt;, regardless of any &lt;code&gt;package&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">특히, 특수 &lt;code&gt;${^_XYZ}&lt;/code&gt; 변수는 현재 범위 에있는 &lt;code&gt;package&lt;/code&gt; 선언에 관계없이 항상 &lt;code&gt;main&lt;/code&gt; 패키지에있는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="5adbc38d169db3c0edbc488274012a781b34d025" translate="yes" xml:space="preserve">
          <source>In particular, this API does &lt;b&gt;not&lt;/b&gt; provide the following functions:</source>
          <target state="translated">특히이 API는 다음 기능을 제공 하지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="26d259999f6bd5eabc0e32bc92fd018cffcba101" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">특히 아직 설치되지 않은 확장을 테스트하는 데 사용되는 &lt;code&gt;@INC&lt;/code&gt; 의 구조에 적용 할 수 있습니다. 제거 된 확장 기능을 실행하면 훨씬 더 많은 오버 헤드가 같은 확장을 실행하는 것보다 이후에있을 수 있음이 수단 &lt;code&gt;make install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aaa91f92ed68961c96b411d0f088a1a8511e37d" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">특히 아직 설치되지 않은 확장 프로그램을 테스트하는 데 사용되는 &lt;code&gt;@INC&lt;/code&gt; 구조에 적용 할 수 있습니다. 즉, 제거 된 확장을 실행하면 &lt;code&gt;make install&lt;/code&gt; 후에 동일한 확장을 실행하는 것보다 훨씬 더 많은 오버 헤드가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da2e58986eb4f3be556785c248e50c152e1a4485" translate="yes" xml:space="preserve">
          <source>In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:</source>
          <target state="translated">특히 이는 할당을 위해 두 집계 중에서 선택하기 위해 이것을 사용해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">특히:</target>
        </trans-unit>
        <trans-unit id="f7e08b6bdc00b0694ecd1bf1d445c34c08eeec2b" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">코드의 텍스트가 아니라 소스 코드 / 패턴에 그대로 나타나는 것보다 실행 시간 정보에서 파생 패턴 / 코드는 패턴이 컴파일과 동시에 컴파일 및 보안의 이유입니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 은 범위 내에 있어야합니다. 코드 스 니펫이 포함 된 사용자 제공 패턴이 실행되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e276d91a0e58a0322954e2290f2d425e6220be43" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;use re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">코드 텍스트가 소스 코드 / pattern /에 문자 그대로 표시되지 않고 런타임 정보에서 파생 된 패턴에서는 패턴이 컴파일되는 동시에 코드가 컴파일되며 보안상의 이유로 &lt;code&gt;use re 'eval'&lt;/code&gt; 이 범위 내에 있어야합니다. 이는 코드 조각이 포함 된 사용자 제공 패턴의 실행을 중지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ea88d26430c6d46158be27b80e4634d3a9d07c0" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE,EXPR&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14 이상에서 &lt;code&gt;fchdir&lt;/code&gt; C 함수를 지원하지 않는 Windows 이외의 시스템 에서는 디렉토리 핸들 ( &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE, EXPR&lt;/a&gt; 참조 )이 새 스레드로 복사되지 않습니다. &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; 에서 &lt;code&gt;d_fchdir&lt;/code&gt; 변수를 사용할 수 있습니다 하여 시스템이이를 지원하는지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75d927412f420eb0f10ead4e75910cbe7eab7430" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt;opendir&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14 이상에서 &lt;code&gt;fchdir&lt;/code&gt; C 기능을 지원하지 않는 Windows 이외의 시스템 에서는 디렉토리 핸들 ( &lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt;opendir&lt;/a&gt; 참조 )이 새 스레드에 복사되지 않습니다. &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; 의 &lt;code&gt;d_fchdir&lt;/code&gt; 변수를 사용 하여 시스템에서 지원하는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="978dbedfe97270c6d04770e8f1b09ed5adf8e8d1" translate="yes" xml:space="preserve">
          <source>In perl 5.8.0, &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; was also used to mark placeholders in restricted hashes. This caused such hash entries not to appear when iterating over the hash or when checking for the keys with the &lt;code&gt;hv_exists&lt;/code&gt; function.</source>
          <target state="translated">perl 5.8.0에서는 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용하여 제한된 해시에서 플레이스 홀더를 표시했습니다. 이로 인해 해시를 반복하거나 &lt;code&gt;hv_exists&lt;/code&gt; 함수로 키를 확인할 때 이러한 해시 항목이 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2d10ca79661f6cd0c4cfd21cf2e8aa0ee582a6a" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared amongst all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">perl 5.8.1 이상에서 Test :: Builder는 스레드로부터 안전합니다. 테스트 번호는 모든 스레드간에 공유됩니다. 이것은 하나의 스레드가 &lt;code&gt;current_test()&lt;/code&gt; 사용하여 테스트 번호를 설정하면 의미합니다 를 하면 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a5a7894f13b3108e48548883e8c5856a72ec473" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared by all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">Perl 5.8.1 이상에서 Test :: Builder는 스레드로부터 안전합니다. 테스트 번호는 모든 스레드에서 공유됩니다. 즉, 하나의 스레드가 &lt;code&gt;current_test()&lt;/code&gt; 를 사용하여 테스트 번호를 설정 하면 모두 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="eb8e3efeeef1db05dc1739fc816278f8bdf67e0a" translate="yes" xml:space="preserve">
          <source>In perl namespaces are called &quot;packages&quot; and the &lt;code&gt;package&lt;/code&gt; declaration tells the compiler which namespace to prefix to &lt;code&gt;our&lt;/code&gt; variables and unqualified dynamic names. This both protects against accidental stomping and provides an interface for deliberately clobbering global dynamic variables declared and used in other scopes or packages, when that is what you want to do.</source>
          <target state="translated">펄 네임 스페이스는 &quot;패키지&quot;라고하며에서는 &lt;code&gt;package&lt;/code&gt; 선언에있는 네임 스페이스 접두사 컴파일러를 알려줍니다 &lt;code&gt;our&lt;/code&gt; 변수와 비정규 동적 이름. 이것은 우발적 인 스톰 핑으로부터 보호하고, 다른 스코프 나 패키지에서 선언되고 사용되는 전역 동적 변수를 의도적으로 방해 할 수있는 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1269cc2ad1ea6f2d742e35bd480e05b3838a6225" translate="yes" xml:space="preserve">
          <source>In perl v5.8.0, you can work around this as follows;</source>
          <target state="translated">perl v5.8.0에서는 다음과 같이이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3903f5f9bb5ec2db6467ae7e05ade21cf24078e9" translate="yes" xml:space="preserve">
          <source>In perls older than 5.8.1, map suffers from this problem as well. But since 5.8.1, this has been fixed, and map is context aware - in void context, no lists are constructed.</source>
          <target state="translated">5.8.1 이전의 perls에서는 맵에서도이 문제가 발생합니다. 그러나 5.8.1 이후로이 문제는 해결되었으며지도는 상황을 인식합니다. 무효 상황에서는 목록이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea278e7090fabecd692fd4230b81818704c298d3" translate="yes" xml:space="preserve">
          <source>In perls without multi-thread locale support, some alien libraries, such as &lt;code&gt;Gtk&lt;/code&gt; change locales. This can cause problems for the Perl core and other modules. For these, before control is returned to perl, starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">다중 스레드 로케일 지원이없는 펄에서 &lt;code&gt;Gtk&lt;/code&gt; 와 같은 일부 외계 라이브러리는 로케일을 변경합니다. 이로 인해 Perl 코어 및 기타 모듈에 문제가 발생할 수 있습니다. 이를 위해 v5.20.1부터 perl로 제어가 반환되기 전에 XS에서 &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale ()&lt;/a&gt; 함수를 호출하면 대부분의 문제를 피할 수 있습니다. 이 전에 다음을 수행하는 순수한 Perl 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="201c993ba430d2b34780a5f6bce751f372ee2124" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill()&quot;&gt;kill()&lt;/a&gt;, above.</source>
          <target state="translated">이식 가능한 Perl 코드 에서 강제 종료 프로세스 에는 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; 해서는 안됩니다. 분기 프로세스를 종료하면 안전하지 않으며 예측할 수없는 결과가 나타납니다. 위의 &lt;a href=&quot;#kill()&quot;&gt;kill ()을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e83f0a235b98e42c7720cdbf4e5b9c914546580" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;kill(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill%28%29&quot;&gt;&quot;kill()&quot;&lt;/a&gt;, above.</source>
          <target state="translated">이식 가능한 Perl 코드에서 &lt;code&gt;kill(9, $child)&lt;/code&gt; 는 분기 된 프로세스에 사용되지 않아야합니다. 분기 된 프로세스를 종료하는 것은 안전하지 않으며 예측할 수없는 결과를 가져옵니다. 위의 &lt;a href=&quot;#kill%28%29&quot;&gt;&quot;kill ()&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87c591de97ad94e43f8f39a0a83433ac7e94d500" translate="yes" xml:space="preserve">
          <source>In practice people have come to depend on these over the years, despite being historically undocumented, so we will provide some level of forward compatibility for some time. Nevertheless you can assume that any routine documented here is experimental or deprecated and you should find alternatives to their use.</source>
          <target state="translated">실제로 사람들은 역사적으로 문서화되지 않았음에도 불구하고 수년에 걸쳐 이것에 의존하게 되었기 때문에 우리는 어느 정도 수준의 순방향 호환성을 제공 할 것입니다. 그럼에도 불구하고 여기에 문서화 된 루틴은 실험적이거나 더 이상 사용되지 않는다고 가정 할 수 있으며 사용에 대한 대안을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="47486744068ceb35eb15ff07d8adf80ccffc0917" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">실제로이 로직은 &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO :: Socket :: IP에서&lt;/a&gt; 더 잘 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="64e70c5c9f546a348d8be9f13ed9b3d5b217325e" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;io/socket/ip&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">실제로이 논리는 &lt;a href=&quot;io/socket/ip&quot;&gt;IO :: Socket :: IP에&lt;/a&gt; 의해 더 잘 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f10d5bbc85368eaaed58b49509d8d5537fcea2c6" translate="yes" xml:space="preserve">
          <source>In practice this makes seldom a difference as &lt;b&gt;parts and results&lt;/b&gt; of expressions will be truncated anyway, but this can, for instance, affect the return value of subroutines:</source>
          <target state="translated">실제로 이것은 표현식의 &lt;b&gt;부분과 결과&lt;/b&gt; 가 잘 리기 때문에 거의 차이 가 없지만, 예를 들어 서브 루틴의 리턴 값에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8bdda291d4d16e099108c0540471c243257c86" translate="yes" xml:space="preserve">
          <source>In practice, Perl scripts that call programs that return _POSIX_EXIT type status values will be expecting those values, and programs that call traditional VMS programs will either be expecting the previous behavior or just checking for a non-zero status.</source>
          <target state="translated">실제로, _POSIX_EXIT 유형 상태 값을 리턴하는 프로그램을 호출하는 Perl 스크립트는 해당 값을 예상하고 기존 VMS 프로그램을 호출하는 프로그램은 이전 동작을 예상하거나 0이 아닌 상태를 점검합니다.</target>
        </trans-unit>
        <trans-unit id="1a4189d0a08fe1510a9bb56d98f077ee7698c8fc" translate="yes" xml:space="preserve">
          <source>In practice, however, one can generally expect such prerequisites to be one of two things:</source>
          <target state="translated">그러나 실제로는 일반적으로 이러한 전제 조건이 다음 두 가지 중 하나 일 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed326b6d59e850419b57af366a49ca220934029" translate="yes" xml:space="preserve">
          <source>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</source>
          <target state="translated">실제로이 문자는 자주 사용되지 않지만 포맷터는이를 지원하거나 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ef0975bd5345aa7b1f7b096896a28cbd99bcab1" translate="yes" xml:space="preserve">
          <source>In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime() and clock_nanosleep() are emulated using the Mach timers; as a side effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.</source>
          <target state="translated">Sierra 이전 macOS (10.12 이전, OS X)에서 clock_getres (), clock_gettime () 및 clock_nanosleep ()은 Mach 타이머를 사용하여 에뮬레이션됩니다. 에뮬레이션되는 부작용으로 CLOCK_REALTIME 및 CLOCK_MONOTONIC은 동일한 타이머입니다.</target>
        </trans-unit>
        <trans-unit id="796550631a5df07b05a560a67d63d7ad67fdf7c5" translate="yes" xml:space="preserve">
          <source>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</source>
          <target state="translated">이전 섹션에서는 숫자와 문자열을 묶는 방법을 살펴 보았습니다. 그것이 몇 가지 걸림돌이 아니었다면 C 구조에는 다른 것이 포함되어 있지 않으므로이 섹션을 즉시 결론 지을 수 있습니다. 따라서 이미 모든 것을 알고 있습니다. 죄송합니다. 계속 읽어주세요.</target>
        </trans-unit>
        <trans-unit id="692b842adc759f56816c9c058cae643b8a51086a" translate="yes" xml:space="preserve">
          <source>In principle the unpack() command can be used to convert the bytes back to a number (if the underlying type is known to be a number).</source>
          <target state="translated">원칙적으로 unpack () 명령을 사용하여 바이트를 숫자로 다시 변환 할 수 있습니다 (기본 유형이 숫자라고 알려진 경우).</target>
        </trans-unit>
        <trans-unit id="1221515422031848620efe6d264c7054adcd4f04" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">이전 펄 버전에서는 디렉토리 핸들이 열려있는 스폰 스레드가 인터프리터와 충돌했습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[펄 # 75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e963293b700fb96161131daf0471b9f677f48564" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;https://rt.perl.org/rt3/Public/Bug/Display.html?id=75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">이전 펄 버전에서는 열린 디렉토리 핸들이있는 스레드를 생성하면 인터프리터가 충돌했습니다. &lt;a href=&quot;https://rt.perl.org/rt3/Public/Bug/Display.html?id=75154&quot;&gt;[펄 # 75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d807cc153636cb39c76e4cb0277ef6012694dae7" translate="yes" xml:space="preserve">
          <source>In programs:</source>
          <target state="translated">프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="48c74c56dfa96426cf79d4567af2599b0fde094e" translate="yes" xml:space="preserve">
          <source>In recent years, vendors have begun to supply systems free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">최근 몇 년 동안 공급 업체는 이러한 고유 보안 버그가없는 시스템을 공급하기 시작했습니다. 이러한 시스템에서 커널은 간섭을받는 경로 이름을 사용하지 않고 set-id 스크립트의 이름을 전달하여 인터프리터에 열면 대신 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fc7a0ac9fe9f163678a08865a8ae2ec22fbc06ff" translate="yes" xml:space="preserve">
          <source>In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;, meaning that it doesn't represent a character in the string, but a condition at a certain position.</source>
          <target state="translated">정규 표현식에서 단어 경계 (\ b)는 &quot;제로 폭 주장&quot;으로, 문자열의 문자를 나타내지 않고 특정 위치의 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b5ca67e58e909ea0b763b445166b0dc50f9fff9" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt; , for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt; . If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; , by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; .</source>
          <target state="translated">정규 표현식에서 배열 첨자와 문자 클래스를 명확하게하기 위해 &lt;code&gt;${foo[2]}&lt;/code&gt; 구문이 필요할 때가 있습니다. 예를 들어, &lt;code&gt;/$length[2345]/&lt;/code&gt; 는 &lt;code&gt;$length&lt;/code&gt; 뒤에 문자 클래스 &lt;code&gt;[2345]&lt;/code&gt; 로 해석됩니다 . 배열 첨자가 원하는 것이라면 &lt;code&gt;/${length[2345]}/&lt;/code&gt; 를보기 흉한 &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; 로 바꾸지 않고 배열의 이름을 일치하지 않는 것으로 바꾸면 경고를 피할 수 있습니다 내장 키워드를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 경고 를 끄는 것 ; .</target>
        </trans-unit>
        <trans-unit id="dd333dd1f620232f5d53f75438d1fbecd387c044" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt;, for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt;. If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt;, by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;no warnings 'ambiguous';&lt;/code&gt;.</source>
          <target state="translated">정규식에서 &lt;code&gt;${foo[2]}&lt;/code&gt; 구문은 때때로 배열 첨자와 문자 클래스를 명확하게하기 위해 필요합니다. &lt;code&gt;/$length[2345]/&lt;/code&gt; 는 &lt;code&gt;$length&lt;/code&gt; 다음에 문자 클래스 &lt;code&gt;[2345]&lt;/code&gt; 가 오는 것으로 해석됩니다 . 배열 첨자가 원하는 경우 배열 이름을 일치하지 않는 이름으로 변경하여 &lt;code&gt;/${length[2345]}/&lt;/code&gt; 를보기 흉한 &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; 로 변경하여 경고를 피할 수 있습니다 . 내장 키워드를 사용하거나 &lt;code&gt;no warnings 'ambiguous';&lt;/code&gt; 단순히 경고를 해제 합니다. .</target>
        </trans-unit>
        <trans-unit id="870f19d24df4b4eee6c062f874fd2afacdfc9f30" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">스칼라 컨텍스트에서는 내부에서 동일한 패턴 으로 원시 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 를 문자열화할 때 perl과 동일하게 리턴합니다 . 인수가 컴파일 된 참조가 아닌 경우이 루틴은 false를 리턴하지만 스칼라 컨텍스트로 정의되고 목록 컨텍스트의 빈 목록을 리턴합니다. 따라서 다음</target>
        </trans-unit>
        <trans-unit id="63b198727926386f9c90953cc658aa09102f11ba" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;qr//&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">스칼라 컨텍스트에서는 내부에 동일한 패턴을 사용하여 원시 &lt;code&gt;qr//&lt;/code&gt; 을 문자열화할 때 perl과 동일한 결과를 반환합니다 . 인수가 컴파일 된 참조가 아닌 경우이 루틴은 false를 반환하지만 스칼라 컨텍스트에서 정의되고 목록 컨텍스트에서 빈 목록을 반환합니다. 따라서 다음</target>
        </trans-unit>
        <trans-unit id="d798e2857dfe13a30f68c169a5217a15884e07bf" translate="yes" xml:space="preserve">
          <source>In scalar context returns the name of the Win32 operating system being used. In list context returns a two element list of the OS name and whatever edition information is known about the particular build (for Win9X boxes) and whatever service packs have been installed. The latter is roughly equivalent to the first item returned by GetOSVersion() in list context.</source>
          <target state="translated">스칼라 컨텍스트에서 사용중인 Win32 운영 체제의 이름을 반환합니다. 목록 컨텍스트에서 OS 이름의 두 요소 목록과 특정 빌드 (Win9X 상자의 경우) 및 설치된 서비스 팩에 대해 알려진 에디션 정보를 반환합니다. 후자는 목록 컨텍스트에서 GetOSVersion ()에 의해 반환 된 첫 번째 항목과 대략 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0a19f93e8a70aa3709a4c5eb5c497d67c74952ec" translate="yes" xml:space="preserve">
          <source>In scalar context will return just the IP address.</source>
          <target state="translated">스칼라 컨텍스트에서는 IP 주소 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1370034b95e83c1602601f8f2c93a5f4f13c28ad" translate="yes" xml:space="preserve">
          <source>In scalar context without arguments, this method returns the number of parsers aggregated. In list context without arguments, returns the parsers in the order they were added.</source>
          <target state="translated">인수가없는 스칼라 컨텍스트에서이 메소드는 집계 된 구문 분석기 수를 리턴합니다. 인수가없는 목록 컨텍스트에서 파서가 추가 된 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="408e422198127b367c2df3b98eea7ea06f9026b1" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; returns the &lt;a href=&quot;http://man.he.net/man3/ctime&quot;&gt;ctime(3)&lt;/a&gt; value:</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;http://man.he.net/man3/ctime&quot;&gt;ctime (3)&lt;/a&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ddd842934d85c69674953e0bf0440bc470724af8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 는 성공 또는 실패를 나타내는 부울 값을 반환하고, 성공하면 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 와 관련된 정보를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4062294e689c1833bcdae539d23c73d6b5a0887d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#times&quot;&gt;&lt;code&gt;times&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;$user&lt;/code&gt;.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;a href=&quot;#times&quot;&gt; &lt;code&gt;times&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;$user&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3e333b48f248d91366426a74dfbbc3da65c8ea7d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&quot;..&quot;&lt;/code&gt; returns a boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and various editors. Each &lt;code&gt;&quot;..&quot;&lt;/code&gt; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 는 부울 값을 반환합니다. 연산자는 플립 플롭처럼 쌍 안정하며 &lt;b&gt;sed&lt;/b&gt; , &lt;b&gt;awk&lt;/b&gt; 및 다양한 편집기 의 라인 범위 (쉼표) 연산자를 에뮬레이트합니다 . 각 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 연산자는이를 포함하는 서브 루틴에 대한 호출에서도 고유 한 부울 상태를 유지합니다. 왼쪽 피연산자가 false 인 한 false입니다. 왼쪽 피연산자가 true이면 오른쪽 피연산자가 true가 될 때까지 범위 연산자는 true를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4702696bd1a6606f8c00bfa48b7462e238b219f8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 ctime (3) 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50ab8480db61cacd9dd3820b8d1635a7c8fbf2e8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 는 성공 또는 실패를 나타내는 부울 값을 리턴하고 성공하면 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 연관된 정보를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d1818a475de168c2b1a7d2bb086c2af5a3f3a97b" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$user&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d16f2c8ac24f3fef816016a050127e8baea1e4f0" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 ctime (3) 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c038fe7af8fd4fba37237e821dee5726e03d9bcf" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 는 성공 또는 실패를 나타내는 부울 값을 리턴하고 성공하면 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 연관된 정보를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f361652bf48a4a2a1736272eaacbdbdece5ad741" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$user&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1674eb64be9587ce137d56ac70c490cdb01951f2" translate="yes" xml:space="preserve">
          <source>In scalar context, divides $x by $y and returns the result to the given or default accuracy/precision. In list context, does floored division (F-division), returning an integer $q and a remainder $r so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned by &lt;code&gt;$x-&amp;gt;bmod($y)&lt;/code&gt;.</source>
          <target state="translated">스칼라 컨텍스트에서 $ x를 $ y로 나누고 결과를 주어진 또는 기본 정확도 / 정밀도로 반환합니다. 목록 컨텍스트에서 내림 나누기 (F- 나누기)를 수행하여 $ x = $ q * $ y + $ r이되도록 정수 $ q 및 나머지 $ r을 반환합니다. 나머지 (모듈로)는 &lt;code&gt;$x-&amp;gt;bmod($y)&lt;/code&gt; 반환 된 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="907f0666cff82b9d0476cd5d474908eaefafe8db" translate="yes" xml:space="preserve">
          <source>In scalar context, divides $x by $y and returns the result. In list context, does floored division (F-division), returning an integer $q and a remainder $r so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned by &lt;code&gt;$x-&lt;/code&gt;bmod($y)&amp;gt;.</source>
          <target state="translated">스칼라 컨텍스트에서 $ x를 $ y로 나누고 결과를 반환합니다. 목록 컨텍스트에서 내림 나누기 (F- 나누기)를 수행하여 $ x = $ q * $ y + $ r이되도록 정수 $ q 및 나머지 $ r을 반환합니다. 나머지 (모듈로)는 &lt;code&gt;$x-&lt;/code&gt; bmod ($ y)&amp;gt;에서 반환 된 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="67f63380dd91d8509df2b85f67d144a31345d453" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function; see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">스칼라 컨텍스트에서 각 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 실행은 다음 일치를 찾아 일치하는 경우 true를 리턴하고 일치하지 않으면 false를 리턴합니다. 마지막 일치 이후의 위치는 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 읽거나 설정할 수 있습니다 . &lt;a href=&quot;functions/pos&quot;&gt;pos를&lt;/a&gt; 참조하십시오 . 실패한 일치는 일반적으로 검색 위치를 문자열의 시작으로 재설정하지만 &lt;code&gt;/c&lt;/code&gt; 수정자를 추가하여 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; )이를 피할 수 있습니다 . 대상 문자열을 수정하면 검색 위치도 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a6e0628ceeeb02c47448d71e6cf72d4e6e644eb" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;m//g&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;pos()&lt;/code&gt; function; see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;m//gc&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;m//g&lt;/code&gt; 실행할 때마다 다음 일치 항목을 찾아 일치하는 경우 true를 반환하고 더 이상 일치하는 항목이 없으면 false를 반환합니다. 마지막 일치 이후 위치는 &lt;code&gt;pos()&lt;/code&gt; 함수를 사용하여 읽거나 설정할 수 있습니다 . &lt;a href=&quot;perlfunc#pos&quot;&gt;perlfunc의 &quot;pos&quot;를&lt;/a&gt; 참조하십시오 . 실패한 일치는 일반적으로 검색 위치를 문자열의 시작으로 재설정하지만 &lt;code&gt;/c&lt;/code&gt; 수정자를 추가하여이를 방지 할 수 있습니다 (예 : &lt;code&gt;m//gc&lt;/code&gt; ). 대상 문자열을 수정하면 검색 위치도 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8800b54c59ca34fbb2fd00902e130cb43eb3acc5" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">스칼라 컨텍스트에서 꺾쇠 괄호로 파일 핸들을 평가하면 해당 파일에서 다음 줄 (있는 경우 새 줄 포함)이 생성되거나 파일 끝에서 또는 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 생성됩니다. 때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (때로는 파일 소리내어 먹는다 모드라고도 함)와 파일이 비어, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="03380a29fdbee6fa1870baa930432527d010a246" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;undef&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;undef&lt;/code&gt; subsequently.</source>
          <target state="translated">스칼라 컨텍스트에서 꺾쇠 괄호로 묶인 파일 핸들을 평가하면 해당 파일의 다음 행 (개행이 포함 된 경우 포함 된 경우) 또는 파일 끝 또는 오류시 &lt;code&gt;undef&lt;/code&gt; 가 생성됩니다. 때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;undef&lt;/code&gt; (때로는 파일 소리내어 먹는다 모드라고도 함)와 파일이 비어, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;undef&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="90d5e99280edc013a52bda47119a081391fd852e" translate="yes" xml:space="preserve">
          <source>In scalar context, just the filehandle is returned.</source>
          <target state="translated">스칼라 컨텍스트에서는 파일 핸들 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e8180b7134edf387de3ba20adf4f7b9e0d9a09d4" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a boolean indicating if SSL is available. In list context, returns the boolean and a (possibly multi-line) string of errors indicating why SSL isn't available.</source>
          <target state="translated">스칼라 컨텍스트에서 SSL을 사용할 수 있는지 여부를 나타내는 부울을 반환합니다. 목록 컨텍스트에서 SSL을 사용할 수없는 이유를 나타내는 부울 및 오류 (여러 줄로 된) 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e5c0aafd8e8839028ecc16b9e49ead2fb7551ce" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a single Fibonacci number. In list context, returns a list of Fibonacci numbers. The invocand is the last element in the output.</source>
          <target state="translated">스칼라 컨텍스트에서 단일 피보나치 수를 반환합니다. 목록 컨텍스트에서 피보나치 수 목록을 반환합니다. invocand는 출력의 마지막 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ae996766d8949391f4258a78d5552412d910e1ec" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a single Lucas number. In list context, returns a list of Lucas numbers. The invocand is the last element in the output.</source>
          <target state="translated">스칼라 컨텍스트에서 단일 Lucas 숫자를 반환합니다. 목록 컨텍스트에서 Lucas 번호 목록을 반환합니다. invocand는 출력의 마지막 요소입니다.</target>
        </trans-unit>
        <trans-unit id="3b41a148fc8880eed7038e400dbf7ebdd585912a" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the nth Fibonacci number: _fib(0) returns 0, _fib(1) returns 1, _fib(2) returns 1, _fib(3) returns 2 etc. In list context, returns the Fibonacci numbers from F(0) to F(n): 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</source>
          <target state="translated">스칼라 컨텍스트에서 n 번째 피보나치 수를 반환합니다. _fib (0)은 0을 반환하고, _fib (1)은 1을, _fib (2)는 1을, _fib (3)은 2를 반환합니다. 목록 컨텍스트에서는 F (에서 피보나치 수를 반환합니다. 0) ~ F (n) : 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</target>
        </trans-unit>
        <trans-unit id="e88b23f1542291b640449137479d5bbdeb5b3c4f" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the nth Lucas number: _lucas(0) returns 2, _lucas(1) returns 1, _lucas(2) returns 3, etc. In list context, returns the Lucas numbers from L(0) to L(n): 2, 1, 3, 4, 7, 11, 18, 29,47, 76, ...</source>
          <target state="translated">스칼라 컨텍스트에서 n 번째 Lucas 숫자를 반환합니다. _lucas (0)은 2를 반환하고, _lucas (1)은 1을, _lucas (2)는 3을 반환합니다. 목록 컨텍스트에서는 L (0)에서 L (n)까지의 Lucas 숫자를 반환합니다. ) : 2, 1, 3, 4, 7, 11, 18, 29,47, 76, ...</target>
        </trans-unit>
        <trans-unit id="5bc406c89894a3609e93b6be654bf8c26772c5a5" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the number of elements that would have been returned as a list.</source>
          <target state="translated">스칼라 컨텍스트에서 목록으로 반환되었을 요소의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="75fe50c921958ecaf606c5e87e67fc368c7bde2e" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the peer host and port, joined with a colon, or &lt;code&gt;undef&lt;/code&gt; (if no peer is connected). In list context, returns the peer host and port or an empty list (if no peer is connected).</source>
          <target state="translated">스칼라 컨텍스트에서 콜론 또는 &lt;code&gt;undef&lt;/code&gt; (연결된 피어가없는 경우)로 결합 된 피어 호스트 및 포트를 리턴합니다 . 목록 컨텍스트에서 피어 호스트 및 포트 또는 빈 목록을 반환합니다 (연결된 피어가없는 경우).</target>
        </trans-unit>
        <trans-unit id="7670efb624f43827626a2d7abe8ac56200cd57f1" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the quotient after dividing OBJ1 by OBJ2 and truncating the result to an integer. In list context, return the quotient and the remainder.</source>
          <target state="translated">스칼라 컨텍스트에서 OBJ1을 OBJ2로 나누고 결과를 정수로 자른 후 몫을 반환합니다. 목록 컨텍스트에서 몫과 나머지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26e7b891880cf2546cd4182b9d0f0a5ab5924094" translate="yes" xml:space="preserve">
          <source>In scalar context, the function returns the most preferred language tag (or undef if no preference was seen).</source>
          <target state="translated">스칼라 컨텍스트에서이 함수는 가장 선호하는 언어 태그를 반환합니다 (또는 기본 설정이 없으면 undef).</target>
        </trans-unit>
        <trans-unit id="b1d9f6c7ff92d9e4431c44fd49623f31abe26893" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time in the timer is returned.</source>
          <target state="translated">스칼라 컨텍스트에서 타이머의 남은 시간이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f286b508bea32b55376de76bb51800a879183e4c" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time is returned.</source>
          <target state="translated">스칼라 컨텍스트에서 남은 시간이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc032fde56245f910fbc6d13638ce22e45ea79e" translate="yes" xml:space="preserve">
          <source>In scalar context, you get the name, unless the function was a lookup by name, in which case you get the other thing, whatever it is. (If the entry doesn't exist you get the undefined value.) For example:</source>
          <target state="translated">스칼라 문맥에서 함수가 이름으로 조회하지 않는 한 이름을 얻습니다.이 경우 다른 것을 얻습니다. 항목이 존재하지 않으면 정의되지 않은 값을 얻습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="070ead24adcf97bbf0458e41cddfaf9060fd1c75" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , do not change their behavior with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 범위에서 ; 위의 거의 모든 연산자는 인수를 정수 형식으로 만들고 정수 결과를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 예외 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 정수 를 사용 하여 동작을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b6e91894f56bfff94294bd3277c1eafb159dcee4" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;use integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, do not change their behavior with &lt;code&gt;use integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer;&lt;/code&gt; 범위에서 ; 위에 나열된 거의 모든 연산자는 인수를 정수 형식으로 강제 적용하고 정수 결과를 반환합니다. 예외, &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 는 &lt;code&gt;use integer;&lt;/code&gt; 동작을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fd63b759e64d942882eb1c88a05afcfdaffadf" translate="yes" xml:space="preserve">
          <source>In searching for &lt;code&gt;/\bfoo\b/&lt;/code&gt; , only locations in &lt;code&gt;$_&lt;/code&gt; that contain &lt;code&gt;f&lt;/code&gt; will be looked at, because &lt;code&gt;f&lt;/code&gt; is rarer than &lt;code&gt;o&lt;/code&gt; . In general, this is a big win except in pathological cases. The only question is whether it saves you more time than it took to build the linked list in the first place.</source>
          <target state="translated">을 찾기 위해 &lt;code&gt;/\bfoo\b/&lt;/code&gt; 에 위치 만 &lt;code&gt;$_&lt;/code&gt; 포함 &lt;code&gt;f&lt;/code&gt; 있으므로 보았다한다 &lt;code&gt;f&lt;/code&gt; 보다 드물다 &lt;code&gt;o&lt;/code&gt; . 일반적으로 병리학 적 사례를 제외하고는 큰 승리입니다. 유일한 질문은 연결 목록을 작성하는 데 걸리는 시간보다 더 많은 시간을 절약 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d510b9d55974c5ad5785f6cfe4077983c695078d" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">요컨대, Perl 4는 Perl 5와 Perl 6의 부모입니다. Perl 5는 더 오래된 형제이며, 언어는 다르지만, 한 언어를 알고있는 사람은 다른 언어와 많은 유사점을 발견 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed75eeeb8979a82ac73d297c5e1f3634bea45872" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Raku (formerly known as Perl 6). Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">간단히 말해 Perl 4는 Perl 5와 Raku (이전에는 Perl 6으로 알려짐)의 부모입니다. Perl 5는 더 오래된 형제이며 언어는 다르지만 하나를 아는 사람은 다른 언어에서 많은 유사점을 발견 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="27c26dcc733ecda091da4a3f15918e2cc3eb4955" translate="yes" xml:space="preserve">
          <source>In short: If the module exports anything that should be run directly by a test script it should probably NOT go directly into &lt;code&gt;Test2::XXX&lt;/code&gt;.</source>
          <target state="translated">요컨대 : 모듈이 테스트 스크립트에 의해 직접 실행되어야하는 것을 내보내는 경우 &lt;code&gt;Test2::XXX&lt;/code&gt; 로 직접 이동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a022deee593194afb675e77892be1749073d500f" translate="yes" xml:space="preserve">
          <source>In simple cases, it is equivalent to:</source>
          <target state="translated">간단한 경우에는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffcc65b4ec59c10cd981321f645c18e2c2833005" translate="yes" xml:space="preserve">
          <source>In simple terms, this is what happens:</source>
          <target state="translated">간단히 말해서, 이것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="8d3443fd7f0c08a6561ba5f63f633adb2afde771" translate="yes" xml:space="preserve">
          <source>In situations where it doesn't make sense for a particular metacharacter to mean what it normally does, it automatically loses its metacharacter-ness and becomes an ordinary character that is to be matched literally. For example, the &lt;code&gt;'}'&lt;/code&gt; is a metacharacter only when it is the mate of a &lt;code&gt;'{'&lt;/code&gt; metacharacter. Otherwise it is treated as a literal RIGHT CURLY BRACKET. This may lead to unexpected results. &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt; can catch some of these.</source>
          <target state="translated">특정 메타 문자가 일반적으로하는 일을 의미하는 것이 의미가없는 상황에서는 자동으로 메타 문자를 잃고 문자 그대로 일치해야하는 일반 문자가됩니다. 예를 들어, &lt;code&gt;'}'&lt;/code&gt; 는 &lt;code&gt;'{'&lt;/code&gt; 메타 문자 의 메이트 인 경우에만 메타 문자입니다. 그렇지 않으면 리터럴 RIGHT CURLY BRACKET으로 처리됩니다. 이로 인해 예기치 않은 결과가 발생할 수 있습니다. &lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict'&lt;/code&gt; &lt;/a&gt; 는 이들 중 일부를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d121139946109160493990901ec9a05c62500b61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">당신이 사용하도록 설정해야 할 상황에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , 당신은 또한 더러운 검사를해야 사용 가능. 더 좋은 방법은 세이프 컴 파트먼트 내에서 신중하게 제한된 평가를 사용하십시오. 이 두 가지 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="890a195db1801db98e427898d4624b5cd0fd0e61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;use re 'eval'&lt;/code&gt;, you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">&lt;code&gt;use re 'eval'&lt;/code&gt; 을 사용 하여이를 활성화해야하는 상황에서는 오염 검사도 활성화해야합니다. 더 좋은 방법은 Safe 구획 내에서 신중하게 제한된 평가를 사용하는 것입니다. 이 두 메커니즘에 대한 자세한 내용은 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2046d35bd71cc3166ad97adddb890d2444c1f0f" translate="yes" xml:space="preserve">
          <source>In some cases (starting server processes, for instance) you'll want to completely dissociate the child process from the parent. This is often called daemonization. A well-behaved daemon will also chdir() to the root directory so it doesn't prevent unmounting the filesystem containing the directory from which it was launched, and redirect its standard file descriptors from and to</source>
          <target state="translated">경우에 따라 (예 : 서버 프로세스 시작) 하위 프로세스를 상위 프로세스와 완전히 분리해야 할 수도 있습니다. 이를 종종 데몬 화라고합니다. 잘 동작하는 데몬은 chdir ()을 루트 디렉토리로 보내서 시작된 디렉토리를 포함하는 파일 시스템을 마운트 해제하지 못하도록하고 표준 파일 디스크립터를이 디렉토리로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="a5b5fb7e89a60fc9793673e892211f18421217cb" translate="yes" xml:space="preserve">
          <source>In some cases an object may only have 1 or 2 attributes, in which case a hashref may be too verbose for your liking. In these cases you can pass in an arrayref with only values. The values will be assigned to attributes in the order the attributes were listed. When there is inheritance involved the attributes from parent classes will come before subclasses.</source>
          <target state="translated">어떤 경우에는 객체에 1 개 또는 2 개의 속성 만있을 수 있으며,이 경우 해시 참조가 원하는대로 너무 장황 할 수 있습니다. 이 경우 값만있는 arrayref를 전달할 수 있습니다. 값은 속성이 나열된 순서대로 속성에 지정됩니다. 상속이 관련된 경우 상위 클래스의 속성이 하위 클래스보다 먼저옵니다.</target>
        </trans-unit>
        <trans-unit id="c9396ca88545422246dd73162e905f2e472202a6" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless &lt;code&gt;POSIX::_exit()&lt;/code&gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">경우에 따라 File :: Temp에 의해 생성 된 파일이 END 블록 내에서 제거됩니다. 자식 프로세스가 종료 될 때 END 블록이 트리거되기 때문에 (하위가 &lt;code&gt;POSIX::_exit()&lt;/code&gt; 를 사용 하지 않는 한 ) File :: Temp는 특정 프로세스 ID에 의해 생성 된 임시 파일 만 제거합니다. 즉, 자식은 부모 프로세스에서 만든 임시 파일을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd4562e3425450ab12fc121ff9cd696fd05153a4" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless C&amp;lt;:_exit&amp;gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">경우에 따라 File :: Temp로 만든 파일이 END 블록 내에서 제거됩니다. 하위 프로세스가 종료 될 때 END 블록이 트리거되므로 (하위가 C &amp;lt;: _ exit&amp;gt;를 사용하지 않는 한) File :: Temp는 특정 프로세스 ID로 작성된 임시 파일 만 제거합니다. 이는 하위 프로세스가 상위 프로세스에서 작성된 임시 파일을 제거하려고 시도하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4cd284f272380bf09ca4f9468d05eb334cb95414" translate="yes" xml:space="preserve">
          <source>In some cases the 'application' can then be reduced to a small</source>
          <target state="translated">어떤 경우에는 '응용 프로그램'을 작은 것으로 줄일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="df381c2814bde8cd15795ab2d100f8c130800cb5" translate="yes" xml:space="preserve">
          <source>In some cases this</source>
          <target state="translated">경우에 따라</target>
        </trans-unit>
        <trans-unit id="cde62ba475df964750a3cdf495be48e1d052051b" translate="yes" xml:space="preserve">
          <source>In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</source>
          <target state="translated">경우에 따라 파일을 만들 때이 변수가 true 인 경우에만 파일이 유지됩니다. 즉, 임시 파일을 만들 수 없으며이 변수를 설정하고 프로그램이 종료 될 때 임시 파일이 계속 남아있을 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="833bad25b1c7e7dcf3b679328d88bdc7a807854c" translate="yes" xml:space="preserve">
          <source>In some cases, it doesn't make practical sense for elements to be supported earlier than they already are. For example, UTF-8 functionality isn't provided prior to the release where it was first introduced.</source>
          <target state="translated">어떤 경우에는 요소가 이미 지원되는 것보다 일찍 지원되는 것이 실제적으로 이치에 맞지 않습니다. 예를 들어 UTF-8 기능은 처음 도입 된 릴리스 이전에는 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="82de4f66144949e592925ee2402c722d415cd5ed" translate="yes" xml:space="preserve">
          <source>In some cases, there is the need for incremental parsing of JSON texts. While this module always has to keep both JSON text and resulting Perl data structure in memory at one time, it does allow you to parse a JSON stream incrementally. It does so by accumulating text until it has a full JSON object, which it then can decode. This process is similar to using &lt;code&gt;decode_prefix&lt;/code&gt; to see if a full JSON object is available, but is much more efficient (and can be implemented with a minimum of method calls).</source>
          <target state="translated">경우에 따라 JSON 텍스트의 증분 구문 분석이 필요합니다. 이 모듈은 항상 JSON 텍스트와 결과 Perl 데이터 구조를 한 번에 메모리에 보관해야하지만 JSON 스트림을 점진적으로 구문 분석 할 수 있습니다. 전체 JSON 객체를 가질 때까지 텍스트를 축적하여이를 디코딩 할 수 있습니다. 이 프로세스는 전체 JSON 개체를 사용할 수 있는지 확인하기 위해 &lt;code&gt;decode_prefix&lt;/code&gt; 를 사용하는 것과 비슷 하지만 훨씬 더 효율적입니다 (최소한의 메서드 호출로 구현할 수 있음).</target>
        </trans-unit>
        <trans-unit id="3905e6a37b63c12afc3763addc4e36a653fc636f" translate="yes" xml:space="preserve">
          <source>In some cases, using substr() or vec() to simulate arrays can be highly beneficial. For example, an array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one 125-byte bit vector--a considerable memory savings. The standard Tie::SubstrHash module can also help for certain types of data structure. If you're working with specialist data structures (matrices, for instance) modules that implement these in C may use less memory than equivalent Perl modules.</source>
          <target state="translated">경우에 따라 배열을 시뮬레이션하기 위해 substr () 또는 vec ()를 사용하는 것이 매우 유리할 수 있습니다. 예를 들어, 1,000 개의 부울 배열은 최소 20,000 바이트의 공간을 차지하지만 125 바이트 비트 벡터로 변환 할 수있어 상당한 메모리 절약 효과를 얻을 수 있습니다. 표준 Tie :: SubstrHash 모듈은 특정 유형의 데이터 구조에 도움이 될 수 있습니다. C에서 이러한 데이터를 구현하는 특수 데이터 구조 (예 : 매트릭스)로 작업하는 경우 동등한 Perl 모듈보다 적은 메모리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e84c8e00f2a5bb70e605cd2c69e1dd80d922f5" translate="yes" xml:space="preserve">
          <source>In some cases, yes. You can use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">어떤 경우에는 그렇습니다. &lt;code&gt;iter&lt;/code&gt; 클래스 메소드를 사용하여 메모리에서 모든 파일을 한 번에 읽지 않고 tarball의 파일을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da7c53f5c4edfd54be873e35b150cbb2e0f64102" translate="yes" xml:space="preserve">
          <source>In some cases, you may be able to make several patterns into a single regular expression. Beware of situations that require backtracking though.</source>
          <target state="translated">경우에 따라 여러 패턴을 단일 정규식으로 만들 수 있습니다. 역 추적이 필요한 상황에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="55ed1ae3a3af36b978490ace319abb286ca584e8" translate="yes" xml:space="preserve">
          <source>In some cases, you'll want to completely skip an entire testing script.</source>
          <target state="translated">경우에 따라 전체 테스트 스크립트를 완전히 건너 뛰고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="37bab3244974f03d4bcb3b02a30c6dfe56b096d6" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">일부 상황에서 백 슬래시 뒤에 2 개 또는 1 개의 8 진수가 8 진수 이스케이프로 해석 될 수 있으며, 때로는 경고와 함께 일부 버그로 인해 때로는 놀라운 결과가 나타납니다. 또한 함께 연결된 더 작은 스 니펫으로 정규식을 만들고 3 자리 미만을 사용하는 경우 한 스 니펫의 시작 부분은 앞의 스 니펫 끝에 숫자를 추가하는 것으로 해석 될 수 있습니다. 스 니펫 문제에 대한 자세한 설명과 예는 &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;절대 참조&quot;&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b444fb6bd755ce68abe6b0c45e2101b6fb938848" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">일부 상황에서, 백 슬래시 다음에 2 개 또는 1 개의 8 진수가 뒤 따르는 경우, 때때로 경고와 함께, 일부 버그로 인해 때로는 놀라운 결과가 나오는 8 진수 이스케이프로 해석 될 수 있습니다. 또한 작은 스 니펫을 함께 연결하여 정규 표현식을 작성하고 3 자리 미만을 사용하는 경우 하나의 스 니펫 시작 부분은 스 니펫 끝 부분에 숫자를 추가하는 것으로 해석 될 수 있습니다. 스 니펫 문제에 대한 자세한 설명 및 예제는 &lt;a href=&quot;#Absolute-referencing&quot;&gt;절대 참조&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="941b228759db0ad2f21515f9edebce99234327a5" translate="yes" xml:space="preserve">
          <source>In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</source>
          <target state="translated">향후 버전의 I18N :: LangTags에서는 RFC2482 스타일 언어 태그에 대한 지원을 포함 할 계획입니다. 기본적으로 ASCII 문자가 평면 14로 이동 된 일반 언어 태그입니다.</target>
        </trans-unit>
        <trans-unit id="b0260d31b907a523df71ffe831436a5256c0c0bb" translate="yes" xml:space="preserve">
          <source>In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.</source>
          <target state="translated">일부 문헌에서이 구축물을 &quot;원자 매칭&quot;또는 &quot;포지티브 매칭&quot;이라고한다.</target>
        </trans-unit>
        <trans-unit id="79419ef5fc7d87682a2736d33053a4e99ddcc17b" translate="yes" xml:space="preserve">
          <source>In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.</source>
          <target state="translated">일부 플랫폼에서는 1 초 미만의 해상도로 알람을받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6aef2a6b389cc51b9d270ade7d87dfa403f876dd" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt; . In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">일부 플랫폼에서는 &lt;code&gt;ps&lt;/code&gt; 로 표시된 수정 된 이름 뒤에 임의의 양의 패딩 (예 : 공백 문자)이있을 수 있습니다 . 일부 플랫폼에서이 패딩은 사용자가 무엇을하든 인수 영역의 원래 길이까지 확장 될 수 있습니다 (예 : Linux 2.2의 경우).</target>
        </trans-unit>
        <trans-unit id="7f1ea5fc2fd23321facda4d50fc1cbae08642e40" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt;. In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">일부 플랫폼에서는 &lt;code&gt;ps&lt;/code&gt; 로 표시된대로 수정 된 이름 뒤에 임의의 양의 패딩 (예 : 공백 문자)이있을 수 있습니다 . 일부 플랫폼에서는이 패딩이 사용자가 무엇을하든 인수 영역의 원래 길이까지 확장 될 수 있습니다 (예 : Linux 2.2의 경우).</target>
        </trans-unit>
        <trans-unit id="08216ba09095e01bafc1d8f5f89aaf1f507c0440" translate="yes" xml:space="preserve">
          <source>In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.</source>
          <target state="translated">경우에 따라 특정 심볼을 내 보내지 못하게 할 수도 있습니다. 일반적으로 이는 일부 시스템에는 없을 수있는 함수 나 상수가있는 확장에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e21d6f7b1ac2792e8d9bd0f52e8f29c7e8c027c" translate="yes" xml:space="preserve">
          <source>In some special cases, from_bytes() matches the conversion done by unpack():</source>
          <target state="translated">특별한 경우에 from_bytes ()는 unpack ()에 의해 수행 된 변환과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7d2b095943328b792355034f8226aaf120447210" translate="yes" xml:space="preserve">
          <source>In specific, version numbers initialized as &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt; will stringify as they were originally created (i.e. the same string that was passed to &lt;code&gt;new()&lt;/code&gt;. Version numbers initialized as &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt; will be stringified as &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt; 로 초기화 된 버전 번호 는 원래 생성 된대로 문자열 화됩니다 (즉, &lt;code&gt;new()&lt;/code&gt; 에 전달 된 동일한 문자열 . &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt; 로 초기화 된 버전 번호 는 &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; 으로 문자열 화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f0ffd2574e55bd73781b2f238993d92b6b53578" translate="yes" xml:space="preserve">
          <source>In spite of its name,</source>
          <target state="translated">그 이름에도 불구하고</target>
        </trans-unit>
        <trans-unit id="9dba8e2fdad7dbac2aaec75e6f6e84418a6299a9" translate="yes" xml:space="preserve">
          <source>In spite of the name, this macro gives the correct result if the input string from which &lt;code&gt;c&lt;/code&gt; comes is not encoded in UTF-8.</source>
          <target state="translated">이름에도 불구하고이 매크로는 &lt;code&gt;c&lt;/code&gt; 가 나오는 입력 문자열 이 UTF-8로 인코딩되지 않은 경우 올바른 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3a8cbd2876234fb0eafe4d9966f4f375e97df144" translate="yes" xml:space="preserve">
          <source>In such cases, to force an additional variable to be declared together with declarations of other variables, place the declaration into a PREINIT: section. The PREINIT: keyword may be used one or more times within an XSUB.</source>
          <target state="translated">이 경우 추가 변수를 다른 변수 선언과 함께 선언하려면 선언을 PREINIT : 섹션에 배치하십시오. PREINIT : 키워드는 XSUB 내에서 한 번 이상 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9198f5929b9dd8df4d3b09d9577116cbbad276" translate="yes" xml:space="preserve">
          <source>In such cases, you are advised to either split the test file into smaller ones, or use a reverse approach, doing &quot;normal&quot; (code) compares and triggering &lt;code&gt;fail()&lt;/code&gt; should anything go unexpected.</source>
          <target state="translated">이러한 경우 테스트 파일을 더 작은 파일로 분할하거나 역 접근 방식을 사용하여 &quot;정상&quot;(코드) 비교를 수행하고 예기치 않은 상황이 발생 &lt;code&gt;fail()&lt;/code&gt; 트리거하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a4b3a6172283064c4d2c38bcdfc1abf019578af1" translate="yes" xml:space="preserve">
          <source>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</source>
          <target state="translated">요약하면, Perl은 일반적으로 유니 코드가 아닌 코드 포인트를 정규 표현식 일치에 대한 일반적인 유니 코드 지정되지 않은 코드 포인트로 취급하여 결과가 무엇인지 논쟁 할 수있을 때만 경고를 발생시킵니다. 그러나이 경고가 치명적이면 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdfe847eef52d0f5e340cab498d8b20a1e1ac3a3" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt; . When the user types</source>
          <target state="translated">요약하면, 일부 foo의 경우 컴파일러 백엔드 모듈을 &quot;B :: Foo&quot;라고하고 해당 이름의 해당 디렉토리에 있어야합니다. &lt;code&gt;compile&lt;/code&gt; 이라는 함수를 정의해야합니다 . 사용자가 입력 할 때</target>
        </trans-unit>
        <trans-unit id="3b0a8b9a8c95f6fb4ee0c747c5c13c70148a1fb6" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt;. When the user types</source>
          <target state="translated">요약하면 컴파일러 백엔드 모듈은 일부 foo에 대해 &quot;B :: Foo&quot;라고 부르고 해당 이름에 적합한 디렉토리에 있어야합니다. &lt;code&gt;compile&lt;/code&gt; 이라는 함수를 정의해야합니다 . 사용자가 입력 할 때</target>
        </trans-unit>
        <trans-unit id="fc74db358d542b3438f19ea437ddcca2306a63f1" translate="yes" xml:space="preserve">
          <source>In summary, local() doesn't make what you think of as private, local variables. It gives a global variable a temporary value. my() is what you're looking for if you want private variables.</source>
          <target state="translated">요약하면 local ()은 개인 로컬 변수로 생각하지 않습니다. 전역 변수에 임시 값을 제공합니다. 개인 변수를 원한다면 my ()가 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="f27d5775b98cc1edc00b71d0a359c25acea44018" translate="yes" xml:space="preserve">
          <source>In telephony, the temporary electrical circuit between the caller&amp;rsquo;s and the callee&amp;rsquo;s phone. In networking, the same kind of temporary circuit between a &lt;b&gt;client&lt;/b&gt; and a &lt;b&gt;server&lt;/b&gt;.</source>
          <target state="translated">전화 통신에서 발신자와 수신자의 전화 사이의 임시 전기 회로. 네트워킹에서 &lt;b&gt;클라이언트&lt;/b&gt; 와 &lt;b&gt;서버&lt;/b&gt; 간의 동일한 종류의 임시 회로 .</target>
        </trans-unit>
        <trans-unit id="c823f59ff2dd302aca99cff2c9b13c16174b9151" translate="yes" xml:space="preserve">
          <source>In that case, the value of the</source>
          <target state="translated">이 경우</target>
        </trans-unit>
        <trans-unit id="8a961ce11a5972421c4f26b07fe69c91b0c3c7f5" translate="yes" xml:space="preserve">
          <source>In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file. We changed this to a relative path so that we could move the extension directory if we wanted to.</source>
          <target state="translated">.xs 파일에는 mylib.h 헤더 파일의 절대 경로가있는 #include 지시문이 있습니다. 원하는 경우 확장 디렉토리를 이동할 수 있도록 이것을 상대 경로로 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="f2ed93444f2e4f61ea8ed89fb84f5492a5e66658" translate="yes" xml:space="preserve">
          <source>In the 5.9.x development version of perl you can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="translated">perl의 5.9.x 개발 버전 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; 를 사용하여 구문 분석 프로세스에 대한 추적 정보를 볼 수 있습니다. 간단한 패턴부터 시작하여 더 복잡한 패턴을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="79df17d32e87b2b81dcedf27e568b372a500063c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;..&lt;/code&gt; or &lt;a href=&quot;perlop#Range-Operators&quot;&gt;range&lt;/a&gt; operator.</source>
          <target state="translated">에서 &lt;code&gt;..&lt;/code&gt; 또는 &lt;a href=&quot;perlop#Range-Operators&quot;&gt;범위&lt;/a&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="695cc6d82e9a098f429aaf4feaee8cd47933f5d7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">에서 &lt;code&gt;Encode&lt;/code&gt; 모듈, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 의 정식 이름 실제로 &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;8&quot;&lt;/code&gt; 사이의 하이픈 은 중요합니다. 그것없이, &lt;code&gt;Encode&lt;/code&gt; 는 &quot;자유&quot;적이며 (아마도 지나치게) 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="36d48d477c6e12e1ea532cffd25bfde82fe49f5d" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt;. That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">에서 &lt;code&gt;Encode&lt;/code&gt; 모듈, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 의 정식 이름 실제로 &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;8&quot;&lt;/code&gt; 사이의 하이픈 은 매우 중요합니다. 그것없이, &lt;code&gt;Encode&lt;/code&gt; 는 &quot;자유 주의적&quot;이고 (아마도 지나치게-) 허용 적입니다 :</target>
        </trans-unit>
        <trans-unit id="b4feedfc56c9ca92e3c18dcd179dd65dfefb5217" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SvPV&lt;/code&gt; macro, the length of the string returned is placed into the variable &lt;code&gt;len&lt;/code&gt; (this is a macro, so you do</source>
          <target state="translated">에서 &lt;code&gt;SvPV&lt;/code&gt; 의 매크로, 반환 된 문자열의 길이는 변수에 배치됩니다 &lt;code&gt;len&lt;/code&gt; 당신이 할 수 있도록,이 매크로입니다 (</target>
        </trans-unit>
        <trans-unit id="070901afbf1f09255274e8877eb8bc2c70b45164" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form,</source>
          <target state="translated">에서 &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 형태</target>
        </trans-unit>
        <trans-unit id="ee3da4d146e84bbefdc7f3a8d2819d53f2a9270e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;use VERSION&lt;/code&gt; form, VERSION may be either a v-string such as v5.24.1, which will be compared to &lt;a href=&quot;perlvar#%24%5EV&quot;&gt;&lt;code&gt;$^V&lt;/code&gt;&lt;/a&gt; (aka $PERL_VERSION), or a numeric argument of the form 5.024001, which will be compared to &lt;a href=&quot;perlvar#%24%5D&quot;&gt;&lt;code&gt;$]&lt;/code&gt;&lt;/a&gt;. An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;no VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">에서 &lt;code&gt;use VERSION&lt;/code&gt; 형태 버전 비교 이도록 v5.24.1 같은 V-문자열 이어도 &lt;a href=&quot;perlvar#%24%5EV&quot;&gt; &lt;code&gt;$^V&lt;/code&gt; &lt;/a&gt; (일명 $ PERL_VERSION) 또는 비교 될 5.024001 형태의 숫자 인자, &lt;a href=&quot;perlvar#%24%5D&quot;&gt; &lt;code&gt;$]&lt;/code&gt; &lt;/a&gt; . VERSION이 현재 Perl 인터프리터의 버전보다 크면 예외가 발생합니다. Perl은 나머지 파일을 구문 분석하지 않습니다. 런타임에 유사한 검사를 수행 할 수있는 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 . 대칭 적으로 &lt;code&gt;no VERSION&lt;/code&gt; 지정된 것보다 오래된 Perl 버전을 원하도록 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="95cc687da96e0b7f7623a95a00b37de925f9f2e9" translate="yes" xml:space="preserve">
          <source>In the C part of the XS file (above the first MODULE line) you have</source>
          <target state="translated">XS 파일의 C 부분 (첫 번째 MODULE 줄 위)에는</target>
        </trans-unit>
        <trans-unit id="9da81592ea409347d5f06bd8bb3e9dfa81794242" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt; , and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; . There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">설명을 위해 의도적으로 난독 화 된 위의 RE에서 구분 기호는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 이고 수정자는 &lt;code&gt;mx&lt;/code&gt; 이며 구분 기호 제거 후 RE는 &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; 합니다. 분리 문자를 영숫자가 아닌 공백이 아닌 선택으로 제한하도록 권장하는 이유는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cfa0dc8147e78f76fb03859acf432fb6d2aa234" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;m&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt;, and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt;. There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">설명을 위해 의도적으로 난독 화 된 위의 RE에서 구분 기호는 &lt;code&gt;m&lt;/code&gt; , 수정자는 &lt;code&gt;mx&lt;/code&gt; , 구분 기호 제거 후 RE는 &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; 합니다. 구분 기호를 영숫자가 아닌 공백이 아닌 선택으로 제한해야하는 이유는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e13a699e1847e4e4560a850a3ff6592656db6884" translate="yes" xml:space="preserve">
          <source>In the above &quot;TAP&quot;, the second and fourth lines will generate &quot;Unknown&quot; tokens.</source>
          <target state="translated">위의 &quot;TAP&quot;에서 두 번째 및 네 번째 줄은 &quot;알 수없는&quot;토큰을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="058e91307a10961fd993a819105cb638818d3bdd" translate="yes" xml:space="preserve">
          <source>In the above [A, C] example, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; hook could return:</source>
          <target state="translated">위의 [A, C] 예에서 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 후크는 다음을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb159de765838e35dcdde7356fd1bd005beb7684" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt; .)</source>
          <target state="translated">위의 스레드 객체는 스칼라 컨텍스트에서 상위 스레드로 반환되고 스레드의 진입 점 함수 &lt;code&gt;foo&lt;/code&gt; 는 목록 (배열) 컨텍스트에서 호출되어 상위 스레드가 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 에서 목록 (배열)을받을 수 있습니다. () 전화. ( &lt;code&gt;'array'&lt;/code&gt; 는 &lt;code&gt;'list'&lt;/code&gt; 와 동의어입니다 .)</target>
        </trans-unit>
        <trans-unit id="e897db5f465666236003f392b985996d3d9611d4" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt;.)</source>
          <target state="translated">위의 스레드 객체는 스칼라 컨텍스트의 부모 스레드로 반환되고 스레드의 진입 점 함수 &lt;code&gt;foo&lt;/code&gt; 는 부모 스레드가 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 에서 목록 (배열)을받을 수 있도록 목록 (배열) 컨텍스트에서 호출됩니다. () 전화. ( &lt;code&gt;'array'&lt;/code&gt; 는 &lt;code&gt;'list'&lt;/code&gt; 와 동의어입니다 .)</target>
        </trans-unit>
        <trans-unit id="9d73b10ae1520507352b424e24dd93e5f334c96c" translate="yes" xml:space="preserve">
          <source>In the above, your &lt;code&gt;frobnicate&lt;/code&gt; function has been changed to be made aware of whether or not it's dealing with UTF-8 data, so that it can handle the string appropriately.</source>
          <target state="translated">위의 &lt;code&gt;frobnicate&lt;/code&gt; 함수는 UTF-8 데이터를 처리하는지 여부를 인식하도록 변경되어 문자열을 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c7cb8befa26cf8853246bc9e4f9d7c53539559" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; 는 정렬 (정렬) 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 정렬 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="15ce031d9fce06ed575c3914c8c9ea6101622d1e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 과 &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6468a6eaf61ca1746bc5af34d7e2d7db949b3755" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; 는 통화 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 통화 서식 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="aa4035e23872d9d83606fa0ea98c9a044e6d0674" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">이 없을 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; 는 숫자 형식 로케일을 선택한다. 양쪽의 부재 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 는 숫자 형식을 선택한다.</target>
        </trans-unit>
        <trans-unit id="6ab8079d22785df117a0b766ea8b7c3baae6e9c3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; 은 날짜 및 시간 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 날짜와 시간 포맷 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="baa7ea095dc5ac2ae935e08f3403e4b2247a827b" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; 는 정렬 (정렬) 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 정렬 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="43ec2099f7545c8e9b202ce433f85529dedee2a2" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 과 &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 문자를 입력 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="17060ec8d669313b51e7970818eee9376316ad91" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; 는 통화 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 통화 서식 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f9caf17cd1367aa2fadeb5cf40ede5223f42444e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">이 없을 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; 는 숫자 형식 로케일을 선택한다. 양쪽의 부재 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 는 숫자 형식을 선택한다.</target>
        </trans-unit>
        <trans-unit id="da232ff7cb7add5ab8264508686db664433513b3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; 은 날짜 및 시간 서식 로케일을 선택합니다. 모두의 부재에서 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 은 날짜와 시간 포맷 로케일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="68e71f53c7f8acf89933bfc63a04da9641a2aa37" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">괄호가없는 경우 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 와 같은 목록 연산자의 우선 순위는 연산자 의 왼쪽 또는 오른쪽을보고 있는지에 따라 매우 높거나 매우 낮습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f77bc2d6be8faa985f9454517bf2c7fdaf4bd39e" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, or &lt;code&gt;chmod&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">괄호가 없으면 &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; 또는 &lt;code&gt;chmod&lt;/code&gt; 와 같은 목록 연산자의 우선 순위는 연산자 의 왼쪽 또는 오른쪽을보고 있는지 여부에 따라 매우 높거나 매우 낮습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8e8c77934a4391ccf6a1b211036cc4430a6aec4a" translate="yes" xml:space="preserve">
          <source>In the argument hashref,</source>
          <target state="translated">hashref 인수에서</target>
        </trans-unit>
        <trans-unit id="c8faecb0e00885cd9d3471fff022824b0e193793" translate="yes" xml:space="preserve">
          <source>In the beginning there was ASCII, the &quot;American Standard Code for Information Interchange&quot;, which works quite well for Americans with their English alphabet and dollar-denominated currency. But it doesn't work so well even for other English speakers, who may use different currencies, such as the pound sterling (as the symbol for that currency is not in ASCII); and it's hopelessly inadequate for many of the thousands of the world's other languages.</source>
          <target state="translated">처음에는 &quot;정보 교환을위한 미국 표준 코드&quot;인 ASCII가 있었는데, 이는 영어 알파벳과 달러 표시 통화로 미국인들에게 잘 작동합니다. 그러나 파운드 스털링과 같은 다른 통화를 사용하는 다른 영어 사용자들에게는 그다지 효과적이지 않습니다 (해당 통화의 기호가 ASCII가 아님). 그리고 세계의 수많은 다른 언어들에게는 절망적으로 부적절합니다.</target>
        </trans-unit>
        <trans-unit id="4d58fb76f14dae3b712c2d1ef16b33d41abd7aa5" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt; 및 &lt;b&gt;-m&lt;/b&gt; 의 경우 해당 옵션이 스크립트 내에서 사용되지 않기 때문에 이는 오류입니다. 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 대신 프라그를.</target>
        </trans-unit>
        <trans-unit id="aa2dc1d853a0888a9b4beead512f4c24741b70d4" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;use&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt; 및 &lt;b&gt;-m&lt;/b&gt; 의 경우 이러한 옵션은 스크립트 내에서 사용하기위한 것이 아니기 때문에 오류입니다. 대신 &lt;code&gt;use&lt;/code&gt; pragma를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="468d95254e2569de4c93c44e90ecaaab6e1c8a96" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">의 경우 &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , 임의의 정규화를 실시하지 않고, 조합 문자 불연속 수축이 수행된다. 따라서 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;이다&lt;/b&gt; 등가 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . 소스 문자열이 사전 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; 되어 있으면 (정규화 =&amp;gt; '사전 정규화') 정규화 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14cf0303bff15e63f1d4bb8fb829c422640cba4" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt;, any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt;. If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">의 경우 &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , 임의의 정규화를 실시하지 않고, 조합 문자 불연속 수축이 수행된다. 따라서 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt; &lt;b&gt;이다&lt;/b&gt; 등가 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . 소스 문자열이 미세하게 사전 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; 되면 (normalization =&amp;gt; 'prenormalized') 정규화 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5830f7641c2c9f00de57771005c708cf9a4d5c74" translate="yes" xml:space="preserve">
          <source>In the case of a perl test suite, typically</source>
          <target state="translated">펄 테스트 스위트의 경우 일반적으로</target>
        </trans-unit>
        <trans-unit id="93b5501796f0c8e106f09c3c3a171aba6b8b3835" translate="yes" xml:space="preserve">
          <source>In the case of a shared array, all the array's elements are shared, and for a shared hash, all the keys and values are shared. This places restrictions on what may be assigned to shared array and hash elements: only simple values or references to shared variables are allowed - this is so that a private variable can't accidentally become shared. A bad assignment will cause the thread to die. For example:</source>
          <target state="translated">공유 배열의 경우 모든 배열의 요소가 공유되고 공유 해시의 경우 모든 키와 값이 공유됩니다. 이것은 공유 배열과 해시 요소에 할당 될 수있는 것에 제한을 둡니다 : 공유 변수에 대한 간단한 값이나 참조 만 허용됩니다 &amp;ndash; 이것은 개인 변수가 실수로 공유 될 수 없도록하기위한 것입니다. 할당이 잘못되면 스레드가 죽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e771b6edcf0a67e48248188d99cc8c1ee77f6d9" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">문자열의 경우 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 는 파일을로드하려고한다고 가정합니다. 그러나 간단한 단어의 경우 모듈을 의미한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ac24b60f2e88b7aed91e2ca7c78a3affc1277034" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;require&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">문자열의 경우 &lt;code&gt;require&lt;/code&gt; 는 파일을로드하려고한다고 가정합니다. 그러나 베어 워드의 경우 모듈을 의미한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="92d133184cc1d94941d92f9ddbb74be254d7536c" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will be equivalent to</source>
          <target state="translated">무제한 해시의 경우 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c7996f6bbe611631e0062a5b0c8688fa0df75c4" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will return an empty list.</source>
          <target state="translated">무제한 해시의 경우 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bbcb89949ef30fa331653e26c292cc6bfd5402d5" translate="yes" xml:space="preserve">
          <source>In the case of branching constructs like the following:</source>
          <target state="translated">분기와 같은 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5299444f09060df2c8b59facc0396320022caaf" translate="yes" xml:space="preserve">
          <source>In the case of sharing phrases, consider that you have an interface already localized for American English (probably by having been written with that as the native locale, but that's incidental). Localizing it for UK English should, in practical terms, be just a matter of running it past a British person with the instructions to indicate what few phrases would benefit from a change in spelling or possibly minor rewording. In that case, you should be able to put in the UK English localization module</source>
          <target state="translated">구문을 공유하는 경우에는 이미 미국 영어 용으로 현지화 된 인터페이스가 있다고 생각하십시오 (아마도 네이티브 로케일로 작성되었으므로 이는 부수적입니다). 영국 영어로 현지화하는 것은 실질적인 용어로 영국인을 지나쳐서 철자 변경이나 사소한 단어 변경으로 어떤 문구가 이익을 얻을 수 있는지를 나타내는 지침과 함께 실행하는 문제 일뿐입니다. 이 경우 영국 영어 현지화 모듈에 넣을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="235ed9f8205c1cb0e0f0c89543ab0c301b45cc8b" translate="yes" xml:space="preserve">
          <source>In the case where bsd_glob() has found some matching paths, but is interrupted by an error, it will return a list of filenames &lt;b&gt;and&lt;/b&gt; set &amp;amp;File::Glob::ERROR.</source>
          <target state="translated">bsd_glob ()가 일부 일치하는 경로를 발견했다,하지만 오류에 의해 중단 된 경우, 파일 이름의 목록이 반환됩니다 &lt;b&gt;및&lt;/b&gt; 세트 및 파일 :: 글롭 :: ERROR를.</target>
        </trans-unit>
        <trans-unit id="ab44e54a843289d8fb48be15296e74831fd77123" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; . The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD, NFKD 및 FCD의 경우 답은 &lt;code&gt;YES&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; 여야합니다 . 대답은 &lt;code&gt;MAYBE&lt;/code&gt; NFC, NFKC 및 FCC의 경우에 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9290433a82e6cf3e26db0b835cf369ebaa80c05" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt;. The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD, NFKD 및 FCD의 경우 대답은 &lt;code&gt;YES&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; 여야합니다 . 대답은 &lt;code&gt;MAYBE&lt;/code&gt; NFC, NFKC 및 FCC의 경우에 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94e0ab2727afbd4185da2de81e38250408bd5cc4" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">아래 코드에서 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; 하면 &quot;void context에서 쓸모없는 xxx 사용&quot; 경고가 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83084455671be2342089bb45fada8c84af832860" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">아래 코드에서 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;join&lt;/code&gt; 을 모두 사용하면 &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; 경고가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fd1596cdd97dc35baf217614ea25fccb283e4de" translate="yes" xml:space="preserve">
          <source>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</source>
          <target state="translated">메모리 요구 사항에 대한 속도를 고려할 때 균형은 더 빠른 실행을 위해 기울어졌습니다. 이는 C 컴파일러가 구조를 위해 메모리를 할당하는 방식에 영향을 미쳤습니다. 16 비트 또는 32 비트 피연산자가 메모리의 위치 간 또는 CPU 레지스터 사이에서 짝수 또는 다중으로 정렬 된 경우 더 빠르게 이동할 수있는 아키텍처 4 개 또는 8 배의 주소에서 C 컴파일러는 구조에 여분의 바이트를 넣음으로써 이러한 속도 이점을 제공합니다. C 해안선을 넘지 않으면 큰 슬픔을 일으키지 않을 것입니다 (큰 데이터 구조를 디자인 할 때주의해야하거나 아키텍처간에 코드를 이식 할 수 있기를 원하지만 (그렇지 않으면 안됩니다) ?)).</target>
        </trans-unit>
        <trans-unit id="9d33a076ef77a2ea3c1cd018606852167138e6c8" translate="yes" xml:space="preserve">
          <source>In the context of the</source>
          <target state="translated">맥락에서</target>
        </trans-unit>
        <trans-unit id="36e06d755cd3fd5bf54637378805e22f4acd5720" translate="yes" xml:space="preserve">
          <source>In the course of hacking on the Perl core distribution, you may have occasion to configure, build and test perl at an old commit. Sometimes &lt;code&gt;make&lt;/code&gt; will fail during this process. If that happens, you may be able to salvage the situation by using the Devel::PatchPerl library from CPAN (not included in the core) to bring the source code at that commit to a buildable state.</source>
          <target state="translated">Perl 코어 배포판을 해킹하는 과정에서 이전 커밋에서 perl을 구성, 빌드 및 테스트 할 기회가있을 수 있습니다. 때때로이 과정에서 &lt;code&gt;make&lt;/code&gt; 가 실패합니다. 이 경우 CPAN (코어에 포함되지 않음)의 Devel :: PatchPerl 라이브러리를 사용하여 해당 커밋의 소스 코드를 빌드 가능한 상태로 가져옴으로써 상황을 구제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4abaa133201d3b086e220fd2a8825f9d8810e3d" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;Constant Functions&quot; in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">현재 구현에서 스칼라 상수는 실제로 인라인 가능한 서브 루틴입니다. Perl 버전 5.004부터는 적절한 스칼라 상수가 일부 서브 루틴 호출 대신 직접 삽입되므로 서브 루틴 호출의 오버 헤드를 줄일 수 있습니다. 이것이 발생하는 방법과시기에 대한 자세한 내용은 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;perlsub의 &quot;상수 함수&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d491c48b25f3ad65e82b4c5c2097be0b50a9588c" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">현재 구현에서 스칼라 상수는 실제로는 inlinable 서브 루틴입니다. Perl 5.004부터는 일부 서브 루틴 호출 대신 적절한 스칼라 상수가 직접 삽입되므로 서브 루틴 호출의 오버 헤드가 절약됩니다. 언제 어떻게 발생하는지에 대한 자세한 내용은 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0455a3b2b53d95f4e20ec0b4340a717b68f76c" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt; , magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; 에 명시 적으로 값이 할당되지 않은 경우 매직 자동 생성이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f523dc0714c247e84ee8251b5363ace685ef46" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt;, magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; 에 명시 적으로 값이 할당되지 않은 기본 경우 매직 자동 생성이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9458e90e2a5f3acd753b6153a03f2c183bb3d3dd" translate="yes" xml:space="preserve">
          <source>In the default case, the events corresponding to &lt;code&gt;=encoding&lt;/code&gt; directives are not emitted. They are emitted if &lt;code&gt;keep_encoding_directive&lt;/code&gt; is true. In that case they produce event structures like &lt;a href=&quot;#events-with-an-element_name-of-head1-..-head4&quot;&gt;&quot;events with an element_name of head1 .. head4&quot;&lt;/a&gt; above.</source>
          <target state="translated">기본적으로 &lt;code&gt;=encoding&lt;/code&gt; 지시문에 해당하는 이벤트 는 생성되지 않습니다. &lt;code&gt;keep_encoding_directive&lt;/code&gt; 가 true 인 경우 방출됩니다 . 이 경우 위의 &lt;a href=&quot;#events-with-an-element_name-of-head1-..-head4&quot;&gt;&quot;element_name이 head1 .. head4 인 이벤트&quot;와&lt;/a&gt; 같은 이벤트 구조를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="23054b89eefbfee4eec8f7b57971efe41724413f" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;&quot;Configuring Getopt::Long&quot;&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">기본 구성에서 옵션 이름은 고유성으로 축약 될 수 있으며 대소 문자는 중요하지 않으며 긴 옵션 이름의 경우에도 단일 대시로 충분합니다. 또한 옵션이 옵션이 아닌 인수 사이에 배치 될 수 있습니다. 참조 &lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;&quot;구성 것은, Getopt :: 롱&quot;을&lt;/a&gt; 것은, Getopt :: 롱을 구성하는 방법에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="9e4e78aa2b33a6d6dac51bbc3211d37de72733b0" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">기본 구성에서 옵션 이름은 고유성으로 축약 될 수 있으며 대소 문자는 중요하지 않으며 긴 옵션 이름의 경우에도 단일 대시로 충분합니다. 또한 옵션은 비 옵션 인수 사이에 배치 될 수 있습니다. &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Getopt :: Long&lt;/a&gt; 을 구성하는 방법에 대한 자세한 내용은 Getopt :: Long 구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e72101fd159fd0afaf983f558f5b87febb7113ce" translate="yes" xml:space="preserve">
          <source>In the description it is mentioned that</source>
          <target state="translated">설명에서 그것은 언급된다</target>
        </trans-unit>
        <trans-unit id="ef03d8c00322da2ed4dc98f0803a382ee30a4ed1" translate="yes" xml:space="preserve">
          <source>In the diagram, the further right you go the more deeply nested the scope is. It is only when control is back with perl on the extreme left of the diagram that you will have dropped back to the enclosing scope and any temporaries you have left hanging around will be freed.</source>
          <target state="translated">다이어그램에서 오른쪽으로 갈수록 범위가 더 깊게 중첩됩니다. 제어가 다이어그램의 가장 왼쪽에 perl로 돌아와서 둘러싸는 범위로 다시 떨어졌을 때만 매달려 있던 임시 공간이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a19348facef1eccdb0bfe0058ba391b435c7d989" translate="yes" xml:space="preserve">
          <source>In the directory where you unpacked the sources, issue the familiar commands:</source>
          <target state="translated">소스의 압축을 푼 디렉토리에서 익숙한 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6f416a980a416e375bc66bc2d4fa36e45d3dee04" translate="yes" xml:space="preserve">
          <source>In the event that your XS code may need the underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale, there are macros available to access this; see &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;Locale-related functions and macros in perlapi&lt;/a&gt;.</source>
          <target state="translated">XS 코드에 기본 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일 이 필요할 수있는 경우 여기에 액세스 할 수있는 매크로가 있습니다. &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;perlapi의 로케일 관련 함수 및 매크로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf76bf6bac3fdd00f94042b70f25cd2c0127da6a" translate="yes" xml:space="preserve">
          <source>In the example above $DB_HASH is actually a pre-defined reference to a hash object. &lt;b&gt;DB_File&lt;/b&gt; has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.</source>
          <target state="translated">위의 예에서 $ DB_HASH는 실제로 해시 객체에 대한 사전 정의 된 참조입니다. &lt;b&gt;DB_File&lt;/b&gt; 에는이 세 가지 사전 정의 된 참조가 있습니다. $ DB_HASH 외에도 $ DB_BTREE 및 $ DB_RECNO도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9fdb8bfd43fe6e2a44475d6d573995092816442" translate="yes" xml:space="preserve">
          <source>In the example above for &lt;code&gt;no_index&lt;/code&gt;, &lt;code&gt;My::Module::Sample::Foo&lt;/code&gt; would be ignored, but &lt;code&gt;My::Module::Sample&lt;/code&gt; would not.</source>
          <target state="translated">&lt;code&gt;no_index&lt;/code&gt; 에 대한 위의 예 에서 &lt;code&gt;My::Module::Sample::Foo&lt;/code&gt; 는 무시되지만 &lt;code&gt;My::Module::Sample&lt;/code&gt; 은 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="383bad82dbf36df5fcbc2607474fc2833874c49f" translate="yes" xml:space="preserve">
          <source>In the example above, no file in</source>
          <target state="translated">위의 예에서 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6fdb80f186445ea957d140c9ee93d85c7f7bc67" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 메서드는 스레드가 종료 되 자마자 반환합니다. 스레드가 완료 될 때까지 대기하고 스레드가 리턴 한 값을 수집하는 것 외에도 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; 은 스레드에 필요한 OS 정리도 수행합니다. 이러한 정리는 특히 많은 스레드를 생성하는 장기 실행 프로그램의 경우 중요 할 수 있습니다. 반환 값을 원하지 않고 스레드가 끝날 때까지 기다리지 않으려면 다음에 설명 된대로 &lt;code&gt;detach()&lt;/code&gt; 메서드를 대신 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95d3b55907325681c5f8c375c41d335ffa7d8ded" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;join()&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;join()&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">위의 예에서 &lt;code&gt;join()&lt;/code&gt; 메서드는 스레드가 종료되는 즉시 반환됩니다. 스레드가 완료 될 때까지 대기하고 스레드가 반환했을 수있는 값을 수집하는 것 외에도 &lt;code&gt;join()&lt;/code&gt; 은 스레드에 필요한 모든 OS 정리를 수행합니다. 그 정리는 특히 많은 스레드를 생성하는 장기 실행 프로그램의 경우 중요 할 수 있습니다. 반환 값을 원하지 않고 스레드가 완료 될 때까지 기다리지 않으려면 다음에 설명하는 것처럼 &lt;code&gt;detach()&lt;/code&gt; 메서드를 대신 호출해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c0aec8a73878fae65e2fc321ef79436b2e98a6ee" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the $writer filehandle, so it closes it. However, because $writer was opened using &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt;, it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;perlfunc#waitpid&quot;&gt;&quot;waitpid&quot; in perlfunc&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">위의 예에서 실제 부모는 $ writer 파일 핸들에 쓰기를 원하지 않으므로 닫습니다. 그러나 $ writer는 &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt; 사용하여 열렸 기 때문에 특별한 동작이 있습니다. 닫으면 하위 프로세스가 종료 될 때까지 기다리는 waitpid () ( &lt;a href=&quot;perlfunc#waitpid&quot;&gt;perlfunc의 &quot;waitpid&quot;&lt;/a&gt; 참조)를 호출합니다 . 자식 프로세스가 &quot;다른 작업 수행&quot;으로 표시된 섹션에서 어떤 일이 일어나기를 기다리게되면 교착 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fb9b67eb5a1d7e86fa97df408aad4ebc6c2e68" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the WRITER filehandle, so it closes it. However, because WRITER was opened using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">위의 예에서, 실제 부모는 WRITER 파일 핸들에 쓰고 싶지 않으므로 닫습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; 사용하여 WRITER를 열었으므로 특수한 동작이 있습니다.이를 닫으면 하위 프로세스가 종료 될 때까지 대기하는 waitpid () ( &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt; 참조)를 호출합니다 . 하위 프로세스가 &quot;다른 작업 수행&quot;으로 표시된 섹션에서 발생하는 작업을 기다리는 경우 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e18ac50c69f2e5daf082fad97b93479b32118e7a" translate="yes" xml:space="preserve">
          <source>In the example above, we've created a global variable to temporarily store the computed value of our eval'ed expression. It is also possible and in most cases a better strategy to fetch the return value from</source>
          <target state="translated">위의 예에서는 계산 된 계산 된 값을 계산 된 값으로 임시 저장하기위한 전역 변수를 만들었습니다. 또한 반환 값을 가져 오는 더 나은 전략이 가능하며 대부분의 경우</target>
        </trans-unit>
        <trans-unit id="215f011f187069670df6baefac97d219cfd4d544" translate="yes" xml:space="preserve">
          <source>In the example above, you can see that we passed &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; to &lt;code&gt;has()&lt;/code&gt; when creating our &lt;code&gt;is_on&lt;/code&gt; attribute. This tells &lt;code&gt;Moose&lt;/code&gt; that this attribute must be a boolean value. If we try to set it to an invalid value, our code will throw an error.</source>
          <target state="translated">위의 예에서 &lt;code&gt;is_on&lt;/code&gt; 속성을 만들 때 &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; 을 &lt;code&gt;has()&lt;/code&gt; 전달한 것을 볼 수 있습니다 . 이것은 &lt;code&gt;Moose&lt;/code&gt; 에게이 속성이 부울 값이어야 함을 알려줍니다 . 유효하지 않은 값으로 설정하려고하면 코드에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7091546bde153dd7889f18e20c48c8bc55eaa567" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt; ) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">예제 필터에서 객체 ( &lt;code&gt;$ref&lt;/code&gt; )는 다른 Perl 객체와 마찬가지로 축복을받습니다. 이 예에서는 익명 배열을 사용하지만 필수 사항은 아닙니다. 이 예제는 컨텍스트 정보를 저장할 필요가 없으므로 스칼라 또는 해시 참조도 사용할 수 있습니다. 다음 섹션에서는 컨텍스트 데이터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="21a83782fbb9be8126f7468757dd72bbc0bf6692" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt;) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">예제 필터에서 객체 ( &lt;code&gt;$ref&lt;/code&gt; )는 다른 Perl 객체와 마찬가지로 축복을받습니다. 이 예에서는 익명 배열을 사용하지만 필수 사항은 아닙니다. 이 예제는 컨텍스트 정보를 저장할 필요가 없기 때문에 스칼라 또는 해시 참조도 사용할 수 있습니다. 다음 섹션에서는 컨텍스트 데이터를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7cad79aaf9d1ce6eabd545156fa679d72897f6d5" translate="yes" xml:space="preserve">
          <source>In the example script below, the &lt;code&gt;match&lt;/code&gt; sub uses this feature to find and print the first matching key/value pair given a partial key.</source>
          <target state="translated">아래 예제 스크립트에서 &lt;code&gt;match&lt;/code&gt; 하위는이 기능을 사용하여 부분 키가 지정된 첫 번째 일치 키 / 값 쌍을 찾아 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="874b0ca5f6d74bc36f1a8bf750e4d758cb8b0d1e" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">위의 예제에서 파일 핸들을 사용하기 전에 스칼라 변수에 할당했습니다. 해시 나 배열의 표현식이나 첨자가 아닌 단순한 스칼라 변수 만 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 diamond 연산자 와 같은 내장 함수 와 함께 사용할 수 있기 때문 입니다. 간단한 스칼라 변수 이외의 것을 파일 핸들로 사용하는 것은 불법이며 컴파일되지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c7dfe54f4652ddbd0ee59dd84dc74edf8984d67" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">위의 예에서는 파일 핸들을 사용하기 전에 스칼라 변수에 할당했습니다. 해시 나 배열의 표현식이나 첨자가 아닌 단순한 스칼라 변수 만 &lt;code&gt;print&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; 또는 다이아몬드 연산자 와 같은 내장 기능과 함께 사용할 수 있기 때문 입니다. 단순한 스칼라 변수가 아닌 다른 것을 파일 핸들로 사용하는 것은 불법이며 컴파일도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d5cb1050428e1b3c39a6dbeac5fa82c4e3ee30c" translate="yes" xml:space="preserve">
          <source>In the examples given to date, any temporaries created in the callback (i.e., parameters passed on the stack to the</source>
          <target state="translated">현재까지 제공된 예에서, 콜백에서 생성 된 모든 임시 (즉, 스택에 전달 된 매개 변수는</target>
        </trans-unit>
        <trans-unit id="52df5ff09c57ff6bd4a65152023282e8e3fdf423" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt; , the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">확장 사용 양식에서 덤프 할 참조에 사용자 지정 이름을 지정할 수 있습니다. 이름이 &lt;code&gt;*&lt;/code&gt; 로 시작 하면 출력은 해시 및 배열에 대한 제공된 참조의 역 참조 된 유형과 코드 참조를 설명합니다. &lt;code&gt;Terse&lt;/code&gt; 플래그가 설정 되면 가능한 경우 이름의 출력을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be4e12f45149670637e90a3aa95e43448b1b2ae" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt;, the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">확장 사용 양식에서 덤프 할 참조에 사용자 지정 이름을 지정할 수 있습니다. 이름이 &lt;code&gt;*&lt;/code&gt; 로 시작 하면 출력은 해시와 배열, 코드 참조에 대해 제공된 참조의 역 참조 된 유형을 설명합니다. &lt;code&gt;Terse&lt;/code&gt; 플래그가 설정된 경우 가능한 경우 이름 출력이 방지 됩니다.</target>
        </trans-unit>
        <trans-unit id="1e093183cde30fbf5834bc8c2f2306668f0a93ab" translate="yes" xml:space="preserve">
          <source>In the eyes of the operating system, pseudo-processes created via the fork() emulation are simply threads in the same process. This means that any process-level limits imposed by the operating system apply to all pseudo-processes taken together. This includes any limits imposed by the operating system on the number of open file, directory and socket handles, limits on disk space usage, limits on memory size, limits on CPU utilization etc.</source>
          <target state="translated">운영 체제의 관점에서 fork () 에뮬레이션을 통해 생성 된 의사 프로세스는 단순히 동일한 프로세스의 스레드입니다. 이는 운영 체제에 의해 부과 된 모든 프로세스 수준 제한이 함께 모은 모든 의사 프로세스에 적용됨을 의미합니다. 여기에는 운영 체제가 열린 파일 수, 디렉토리 및 소켓 핸들 수, 디스크 공간 사용 제한, 메모리 크기 제한, CPU 사용 제한 등에 대한 제한이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c87855f737ebcf54612bd0d985e7951567552bdc" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; . (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">위의 마지막 예에서 첫 번째 ASCII 16 진수는 코드 포인트 48, 문자 &quot;0&quot;이며 57부터 57까지의 모든 코드 포인트 ( &quot;9&quot;)는 ASCII 16 진수입니다. 코드 포인트 58에서 64는 아니지만 65 ( &quot;A&quot;)에서 70 ( &quot;F&quot;)은 97 ( &quot;a&quot;)에서 102 ( &quot;f&quot;)입니다. 103은 ASCII 16 진수가 아닌 코드 포인트 범위를 시작합니다. 이 범위는 무한대로 확장되며 컴퓨터의 &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 변수에서 찾을 수 있습니다 . (이 변수는 Perl이 플랫폼에서 얻을 수있는 무한대에 가까우며 일부 작업이 작동하기에는 너무 높을 수 있으므로 목적에 따라 더 작은 수를 사용하고자 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="94e9a81f285a566a35b6b1d438008270601b9a19" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt;. (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">위의 마지막 예에서 첫 번째 ASCII 16 진수 숫자는 코드 포인트 48이고 문자 &quot;0&quot;이며 여기에서 57 ( &quot;9&quot;)까지의 모든 코드 포인트는 ASCII 16 진수 숫자입니다. 코드 포인트 58에서 64는 그렇지 않지만 65 ( &quot;A&quot;)에서 70 ( &quot;F&quot;)은 97 ( &quot;a&quot;)에서 102 ( &quot;f&quot;)까지입니다. 103은 ASCII 16 진수가 아닌 코드 포인트 범위를 시작합니다. 이 범위는 무한대로 확장되며 컴퓨터에서 &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 변수에서 찾을 수 있습니다 . (이 변수는 Perl이 플랫폼에서 얻을 수있는만큼 무한대에 가까우며 일부 작업이 작동하기에는 너무 높을 수 있습니다. 목적에 따라 더 작은 수를 사용하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="acc9782ed3f3e2b680013d144689804f90d54bf6" translate="yes" xml:space="preserve">
          <source>In the first example, an error handler, the flow of control could be as follows. You have created an interface to an external library. Control can reach the external library like this</source>
          <target state="translated">첫 번째 예인 오류 처리기에서 제어 흐름은 다음과 같습니다. 외부 라이브러리에 대한 인터페이스를 작성했습니다. 제어는 이와 같이 외부 라이브러리에 도달 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="837426c8f21e7781853f5f83912529e607900661" translate="yes" xml:space="preserve">
          <source>In the first form, often referred to as a &quot;string eval&quot;, the return value of EXPR is parsed and executed as if it were a little Perl program. The value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This means, that in particular, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">&quot;문자열 평가&quot;라고도하는 첫 번째 형식에서는 EXPR의 반환 값이 작은 Perl 프로그램 인 것처럼 구문 분석되고 실행됩니다. 식의 값 (스칼라 컨텍스트 내에서 자체 결정됨)이 먼저 구문 분석되고 오류가없는 경우 현재 Perl 프로그램의 어휘 컨텍스트 내에서 블록으로 실행됩니다. 즉, 특히 외부 어휘 변수를 볼 수 있으며 패키지 변수 설정 또는 서브 루틴 및 형식 정의는 계속 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="9907ef81620f333168bdff52969249681c5309f5" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt; . In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">첫 번째 양식에서 &lt;code&gt;id_2obj()&lt;/code&gt; 함수에 대해 작업 할 오브젝트를 등록하십시오 . 두 번째 형식에서는 가비지 수집을 위해 지정된 해시 참조를 추가로 표시합니다. 이는 객체가 범위를 벗어날 때 &lt;code&gt;id($obj)&lt;/code&gt; 키 아래에 주어진 해시의 모든 항목이 해시에서 삭제됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="82daad9f8422b91114fc168e8a72aa6a69bd4b7c" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt;. In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">첫 번째 양식에서는 &lt;code&gt;id_2obj()&lt;/code&gt; 함수에 대해 작업 할 객체를 등록합니다 . 두 번째 형식에서는 가비지 수집을 위해 지정된 해시 참조를 추가로 표시합니다. 즉, 개체가 범위를 벗어나면 &lt;code&gt;id($obj)&lt;/code&gt; 키 아래에 지정된 해시의 모든 항목이 해시에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="886a42840b4db0f0804225c4bdd1da338f8eaea4" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt; . In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">첫 번째 형태에서, 익명의 해시는 &lt;code&gt;$class&lt;/code&gt; 의 클래스에 축복을 받고 있습니다. 두 번째 형태에서는 익명 해시가 현재 패키지에 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="241819a9fd13f09ae7d3eb578ecbc5ee2d6a8a15" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt;. In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">첫 번째 형식에서 익명 해시는 &lt;code&gt;$class&lt;/code&gt; 의 클래스에 축복을 받고 있습니다. 두 번째 형식에서는 익명 해시가 현재 패키지에 축복됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba19d40237087370736921c2b055d0f9f4e8621" translate="yes" xml:space="preserve">
          <source>In the first two versions, the body of the subroutine is lexically in the main package,</source>
          <target state="translated">처음 두 버전에서 서브 루틴의 본문은 기본 패키지에 어휘 적으로 있습니다.</target>
        </trans-unit>
        <trans-unit id="78475acfd51fd678e0727a44ada7dcef5de0bc33" translate="yes" xml:space="preserve">
          <source>In the first version above, you let the appropriate encoding layer handle the conversion. In the second, you explicitly translate from one encoding to the other.</source>
          <target state="translated">위의 첫 번째 버전에서는 적절한 인코딩 계층이 변환을 처리하도록합니다. 두 번째에서는 한 인코딩에서 다른 인코딩으로 명시 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2414010bede2999a6fc168db89c621d8bb7bb77d" translate="yes" xml:space="preserve">
          <source>In the following all questions and explanations regarding config variables are collected.</source>
          <target state="translated">다음에는 구성 변수에 관한 모든 질문과 설명이 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="33eb6a227648440eaeed500f955607df47c5aa25" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;code&gt;$pad_len&lt;/code&gt; is the length to which you wish to pad the string, &lt;code&gt;$text&lt;/code&gt; or &lt;code&gt;$num&lt;/code&gt; contains the string to be padded, and &lt;code&gt;$pad_char&lt;/code&gt; contains the padding character. You can use a single character string constant instead of the &lt;code&gt;$pad_char&lt;/code&gt; variable if you know what it is in advance. And in the same way you can use an integer in place of &lt;code&gt;$pad_len&lt;/code&gt; if you know the pad length in advance.</source>
          <target state="translated">다음 예에서 &lt;code&gt;$pad_len&lt;/code&gt; 은 문자열을 채울 길이이며 &lt;code&gt;$text&lt;/code&gt; 또는 &lt;code&gt;$num&lt;/code&gt; 은 &lt;code&gt;$pad_char&lt;/code&gt; 문자열을 포함 하고 $ pad_char 는 채움 문자를 포함합니다. 사전에 &lt;code&gt;$pad_char&lt;/code&gt; 변수 대신 단일 문자열 상수를 사용할 수 있습니다 . 또한 패드 길이를 미리 알고 있다면 &lt;code&gt;$pad_len&lt;/code&gt; 대신 정수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc65931a92616454753f1a0ca267288397762366" translate="yes" xml:space="preserve">
          <source>In the following section, we use XML to represent the event structure associated with a particular construct. That is, an opening tag represents the element start, the attributes of that opening tag are the attributes given to the callback, and the closing tag represents the end element.</source>
          <target state="translated">다음 섹션에서는 XML을 사용하여 특정 구문과 관련된 이벤트 구조를 나타냅니다. 즉, 여는 태그는 요소 시작을 나타내며, 해당 여는 태그의 속성은 콜백에 지정된 속성이고, 닫는 태그는 끝 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a479078b9cedbc887640e0bba65b952ff07c579b" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in detail, in the same order in which they appear in the table above.</source>
          <target state="translated">다음 섹션에서는 이러한 연산자를 위의 표에 표시된 것과 동일한 순서로 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="76ac42f7d8b0a7d53378ec8bb6883cc947c8612a" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in precedence order.</source>
          <target state="translated">다음 섹션에서이 연산자는 우선 순위에 따라 다룹니다.</target>
        </trans-unit>
        <trans-unit id="4b178b275b86ca37ae6642cdcf850388ebe0add6" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt; ); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt; .</source>
          <target state="translated">다음 표에서 숫자는 우선 순위를 나타냅니다. 예를 들어, 아래 표는 &lt;code&gt;'!'&lt;/code&gt; 에 대한 구현이없는 경우 Perl은 &lt;code&gt;'bool'&lt;/code&gt; 을 사용하여 (즉, &lt;code&gt;'bool'&lt;/code&gt; 의 메소드가 리턴 한 값을 반전하여 ) 구현합니다. 부울 변환도 구현되지 않으면 Perl은 &lt;code&gt;'0+'&lt;/code&gt; 를 사용 하거나 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="3f242ec2577ee075f67a91be886c834c96f1626f" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt;); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt;.</source>
          <target state="translated">다음 표에서 숫자는 우선 순위를 나타냅니다. 예를 들어, 아래 표에는 &lt;code&gt;'!'&lt;/code&gt; 에 대한 구현이없는 경우 정의 된 다음 Perl은 &lt;code&gt;'bool'&lt;/code&gt; 을 사용하여이를 구현합니다 (즉, &lt;code&gt;'bool'&lt;/code&gt; 에 대한 메서드에서 반환 된 값을 반전하여 ). 부울 변환도 구현되지 않은 경우 Perl은 &lt;code&gt;'0+'&lt;/code&gt; 를 사용 하거나 실패하면 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f8a38bcdad9de0c83d52fd95f8565a94b07788e8" translate="yes" xml:space="preserve">
          <source>In the following tables:</source>
          <target state="translated">다음 표에서 :</target>
        </trans-unit>
        <trans-unit id="8d00c0473cd774a465a212e290a62a3d57987f7d" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">세 개 이상의 인수를 사용하는 파이프 열기 형식에서 LIST가 지정되면 (명령 이름 뒤에 추가 인수) LIST는 플랫폼이 지원하는 경우 호출 된 명령에 대한 인수가됩니다. 파이프가 아닌 모드에 대한 인수가 3 개 이상인 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 의 의미는 아직 정의되지 않았지만 실험적 &quot;계층&quot;은 추가 LIST 인수 의미를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="770598786b9fb05b86d05d808ab206b9dce08c07" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">LIST가 지정된 경우 (명령 이름 뒤에 추가 인수) 파이프가 열려있는 형식으로 세 개 이상의 인수를 사용하면 플랫폼에서 지원하는 경우 LIST가 호출 된 명령의 인수가됩니다. 비 파이프 모드에 대해 세 개 이상의 인수 로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 의미는 아직 정의되지 않았지만 실험적인 &quot;계층&quot;은 추가 LIST 인수를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351023ba55a42928810e8ea146d7f9a69c7e4007" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">LIST가 지정된 경우 (명령 이름 뒤에 추가 인수) 파이프가 열려있는 형식으로 세 개 이상의 인수를 사용하면 플랫폼에서 지원하는 경우 LIST가 호출 된 명령의 인수가됩니다. 비 파이프 모드에 대해 세 개 이상의 인수 로 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 의미는 아직 정의되지 않았지만 실험적인 &quot;계층&quot;은 추가 LIST 인수를 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c6eb4ba4d293106779dbeb28a115c48d149f15" translate="yes" xml:space="preserve">
          <source>In the function descriptions below the term</source>
          <target state="translated">용어 아래의 기능 설명에서</target>
        </trans-unit>
        <trans-unit id="0d9756e636c498fe9304eb168ab8f26e641d5c72" translate="yes" xml:space="preserve">
          <source>In the future, this module will likely use File::Spec for determining paths, as it does now for Mac OS (where Unix-style or Mac-style paths work, and Unix-style paths are converted properly to Mac-style paths before being added to @INC).</source>
          <target state="translated">앞으로이 모듈은 경로를 결정하기 위해 File :: Spec을 사용할 것입니다 (현재 Unix 스타일 또는 Mac 스타일 경로가 작동하는 Mac OS 및 Unix 스타일 경로가 이전에 Mac 스타일 경로로 올바르게 변환 됨) @INC에 추가).</target>
        </trans-unit>
        <trans-unit id="46cedf56be184729e0d91d65fc9c0d53cad92704" translate="yes" xml:space="preserve">
          <source>In the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">마지막 예에서 문자열의 끝은 단어 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6405a42cdbbb08be1356ae610a2c353a3021f6e3" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression, so we use &lt;code&gt;$1&lt;/code&gt; to replace the quoted string with just what was quoted. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regexp in the string:</source>
          <target state="translated">마지막 예에서는 전체 문자열이 일치했지만 작은 따옴표 안의 부분 만 그룹화되었습니다. 와 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자, 일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 우리가 사용하는, 그래서 등, 대체 표현의 사용을 즉시 사용할 수있는 &lt;code&gt;$1&lt;/code&gt; 인용되었다 단지 무엇을 함께 인용 문자열을 바꿀 수 있습니다. 전역 수정자를 사용하여 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 는 문자열에서 모든 정규 표현식을 검색하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="083adc541bcebeae1c40187264f802274bed10c9" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="translated">마지막 예에서는 전체 문자열이 일치했지만 작은 따옴표 안에있는 부분 만 그룹화되었습니다. 와 &lt;code&gt;s///&lt;/code&gt; 연산자 유사한 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="06c06ffd743a05cb45342ceadd66f34d1f6c47cc" translate="yes" xml:space="preserve">
          <source>In the last regex, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regex.</source>
          <target state="translated">마지막 정규 표현식에서 슬래시 &lt;code&gt;'/'&lt;/code&gt; 도 정규 표현식을 구분하는 데 사용되므로 백 슬래시입니다.</target>
        </trans-unit>
        <trans-unit id="11c4a29ccb7ab2ebd1eeaf108124208b060d0f4a" translate="yes" xml:space="preserve">
          <source>In the last regexp, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome), however, and it is often more readable to change delimiters.</source>
          <target state="translated">마지막 정규 표현식에서 슬래시 &lt;code&gt;'/'&lt;/code&gt; 도 정규 표현식을 구분하는 데 사용되므로 백 슬래시입니다. 그러나 이로 인해 LTS (leaning toothpick syndrome)가 발생할 수 있으며 구분 기호를 변경하는 것이 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3c351aa56c66843f422f8613ab5ba80764ad66e0" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, &lt;code&gt;'a'&lt;/code&gt; matches because the first character position in the string is the earliest point at which the regexp can match.</source>
          <target state="translated">마지막 문장에서 &lt;code&gt;'c'&lt;/code&gt; 가 클래스 의 첫 번째 문자이지만 문자열의 첫 번째 문자 위치가 정규 표현식과 일치 할 수있는 가장 빠른 지점이므로 &lt;code&gt;'a'&lt;/code&gt; 가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="eb7827ba059fba337cd380ecde1e864bd7488e84" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt; .</source>
          <target state="translated">마지막 문장에서 &lt;code&gt;'c'&lt;/code&gt; 가 클래스의 첫 번째 문자 이지만 정규식과 일치시킬 수있는 가장 빠른 지점은 &lt;code&gt;'a'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb0e131732b0d0f21b5019af566fe7f7ba1531a8" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">마지막 문에서 &lt;code&gt;'c'&lt;/code&gt; 가 클래스의 첫 번째 문자 이지만 정규식이 일치 할 수있는 가장 빠른 지점은 &lt;code&gt;'a'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9813d8232f26905286fe72c0fb88aaeece44db" translate="yes" xml:space="preserve">
          <source>In the latter case, characters that map to 0212 are first converted to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or 'geta mark') then fed to the decoding engine. U+FFFD is not used, in order to preserve text layout as much as possible.</source>
          <target state="translated">후자의 경우, 0212로 매핑되는 문자는 먼저 U + 3013 (EUC-JP에서 0xA2AE로 변환됩니다. '두부'또는 'geta 마크'라고도하는 흰색 사각형)은 디코딩 엔진에 공급됩니다. 텍스트 레이아웃을 최대한 유지하기 위해 U + FFFD가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8f8d594e47a7aed4b47d21c04c8b5fc5ac50b38" translate="yes" xml:space="preserve">
          <source>In the latter, foo.h is taken as</source>
          <target state="translated">후자에서 foo.h는</target>
        </trans-unit>
        <trans-unit id="9b81dfce26cb69eddfbb13b42d7a921ee8ba05af" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUB의 매개 변수 목록에서 하나에 의해 매개 변수 이름 앞에 수 있습니다 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 키워드. &lt;code&gt;IN&lt;/code&gt; 키워드가 기본값이고 다른 키워드는 Perl 인터페이스가 C 인터페이스와 어떻게 다른지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eaa86694f038fb390a6437b7cfb383ab6f33e503" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUB의 매개 변수 목록에서 하나에 의해 매개 변수 이름 앞에 수 있습니다 &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 키워드. &lt;code&gt;IN&lt;/code&gt; 키워드는 기본값이고 다른 키워드는 Perl 인터페이스가 C 인터페이스와 어떻게 달라야하는지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c32d4238ee6ff96fa8bb06b99ee3f8b0689422e" translate="yes" xml:space="preserve">
          <source>In the method descriptions below</source>
          <target state="translated">아래의 방법 설명에서</target>
        </trans-unit>
        <trans-unit id="1b237b2ec2e195bf52f7f15f0ad99e5a2c78e4b1" translate="yes" xml:space="preserve">
          <source>In the more general case, you can use the &lt;code&gt;/g&lt;/code&gt; modifier in a &lt;code&gt;while&lt;/code&gt; loop, keeping count of matches.</source>
          <target state="translated">보다 일반적인 경우 일치 횟수를 유지 &lt;code&gt;while&lt;/code&gt; 루프 에서 &lt;code&gt;/g&lt;/code&gt; 수정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4effaa0b6c8c5116ec13300ff6598d1e650296b0" translate="yes" xml:space="preserve">
          <source>In the most common case, the simple case of a L&amp;lt;podpage&amp;gt; code produces this event structure:</source>
          <target state="translated">가장 일반적인 경우 L &amp;lt;podpage&amp;gt; 코드의 간단한 경우는 다음과 같은 이벤트 구조를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="784f063825aaf77ec4d5f9b15d7c0e7efc2377c9" translate="yes" xml:space="preserve">
          <source>In the mylib directory, create a file mylib.h that looks like this:</source>
          <target state="translated">mylib 디렉토리에서 다음과 같은 mylib.h 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8fae5d3b394459ca514c1ba039cdb1ef56a38f82" translate="yes" xml:space="preserve">
          <source>In the next example, the expression is evaluated only once, and the tied scalar is fetched once as part of the operation within the expression. The result of that operation is fetched for each comparison, which normally doesn't matter unless that expression result is also magical due to operator overloading.</source>
          <target state="translated">다음 예에서 표현식은 한 번만 평가되고 묶인 스칼라는 표현식 내 연산의 일부로 한 번만 가져옵니다. 해당 연산의 결과는 각 비교에 대해 가져 오며, 연산자 오버로딩으로 인해 해당 표현식 결과도 마술 적이 지 않는 한 일반적으로 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79fbf0c13d713302225cff8f61abd9dd7ac74b43" translate="yes" xml:space="preserve">
          <source>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</source>
          <target state="translated">다음 단락에서는 여기에 사용 된 용어에 대한 간단한 설명이 이어집니다 (다른 사람이나 문서에서 사용하는 용어와 다를 수 있기 때문).</target>
        </trans-unit>
        <trans-unit id="5152e34177e8a3d4c184b97093704f88de6ca9db" translate="yes" xml:space="preserve">
          <source>In the notation discussed so far, the characters &quot;[&quot; and &quot;]&quot; are given special meaning, for opening and closing bracket groups, and &quot;,&quot; has a special meaning inside bracket groups, where it separates items in the group. This begs the question of how you'd express a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and how you'd express a literal comma inside a bracket group. For this purpose I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot; means a literal '[' character anywhere in Bracket Notation (i.e., regardless of whether you're in a bracket group or not), and ditto for &quot;~]&quot; meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho &quot;,&quot; means a literal comma outside of bracket groups -- it's only inside bracket groups that commas are special.)</source>
          <target state="translated">지금까지 설명한 표기법에서 &quot;[&quot;및 &quot;]&quot;문자는 대괄호 그룹을 열고 닫는 데 특별한 의미가 있으며 &quot;,&quot;는 대괄호 그룹 내부에 특별한 의미가 있으며 그룹에서 항목을 구분합니다. 이것은 대괄호 표기법 문자열에서 리터럴 &quot;[&quot;또는 &quot;]&quot;를 표현하는 방법과 대괄호 그룹 내에서 리터럴 쉼표를 표현하는 방법에 대한 의문을 제기합니다. 이 목적을 위해 &quot;~&quot;(물결표)를 이스케이프 문자로 채택했습니다. &quot;~ [&quot;는 대괄호 표기법의 임의의 위치에 리터럴 '['문자를 의미합니다 (즉, 대괄호 그룹에 있는지 여부에 관계없이), 리터럴 ']'을 의미하는 &quot;~]&quot;및 리터럴 쉼표를 의미하는 &quot;~&quot;를 의미합니다. (Altho &quot;,&quot;은 대괄호 그룹 외부의 리터럴 쉼표를 의미합니다.쉼표가 특수한 괄호 그룹 내부에만 있습니다.)</target>
        </trans-unit>
        <trans-unit id="9c42fcbdbf3cd24cfb1dac2e8ba1cbc829f18933" translate="yes" xml:space="preserve">
          <source>In the olden, less enlightened times, we all used to use ASCII. Most of us did, anyway. The big problem with ASCII is that it's American. Well, no, that's not actually the problem; the problem is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of it being a standard was lost.</source>
          <target state="translated">오래되고 깨달은 시대에는 모두 ASCII를 사용했습니다. 어쨌든 우리 대부분은 그렇게했습니다. ASCII의 큰 문제는 그것이 미국인이라는 것입니다. 글쎄요, 그건 사실 문제가 아닙니다. 문제는 로마 알파벳을 사용하지 않는 사람들에게는 특히 유용하지 않다는 것입니다. 예전에는 특정 언어가 128에서 255 사이의 시퀀스의 상위 범위에 자신의 알파벳을 붙이는 것이 었습니다. 물론 우리는 ASCII가 아닌 많은 변형과 그 전체 요점으로 끝났습니다. 표준이되는 것은 없어졌다.</target>
        </trans-unit>
        <trans-unit id="50b947f69a6b2d22a725a2d7ba0813fc1f66f21b" translate="yes" xml:space="preserve">
          <source>In the one case the code, which does exactly the same thing as far as outputting any debugging information is concerned, in other words nothing, takes 14 seconds, and in the other case the code takes one hundredth of a second. Looks fairly definitive. Use a &lt;code&gt;$DEBUG&lt;/code&gt; variable BEFORE you call the subroutine, rather than relying on the smart functionality inside it.</source>
          <target state="translated">어떤 경우에는 디버깅 정보를 출력하는 것과 정확히 똑같은 일을하는 코드, 즉 아무 것도 14 초가 걸리지 않으며 다른 경우에는 코드가 100 분의 1 초가 걸립니다. 상당히 결정적인 것으로 보입니다. 서브 루틴을 호출하기 전에 &lt;code&gt;$DEBUG&lt;/code&gt; 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cd2461949e5dab65a2af380d7f878aad8f12946" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">호출의 1 인수 및 2 인수 형태에서, 모드 및 파일 이름은 바람직하게는 공백으로 분리되어 연결되어야합니다 (순서대로). 해당 모드가 &lt;code&gt;&amp;lt;&lt;/code&gt; 일 때 이러한 형식으로 모드를 생략 할 수는 있지만 생략해서는 안됩니다 . filename 인수가 알려진 리터럴 인 경우에는 항상 2 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1895cc93a277f17a7d9aa8c8fca89d99b0c8a2" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">호출의 1 인수 및 2 인수 형태에서, 모드 및 파일 이름은 바람직하게는 공백으로 분리되어 연결되어야합니다 (순서대로). 해당 모드가 &lt;code&gt;&amp;lt;&lt;/code&gt; 일 때 이러한 형식으로 모드를 생략 할 수는 있지만 생략해서는 안됩니다 . filename 인수가 알려진 리터럴 인 경우에는 항상 2 인수 형식의 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 을 사용하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="ece5db37f09d793410ad6532c80d07a8dc5b931d" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt;. It is safe to use the two-argument form of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; if the filename argument is a known literal.</source>
          <target state="translated">1 인수 및 2 인수 호출 형식에서 모드와 파일 이름은 연결되어야하며 (순서대로), 가능하면 공백으로 구분해야합니다. 모드가 &lt;code&gt;&amp;lt;&lt;/code&gt; 인 경우 이러한 형식의 모드를 생략 할 수는 있지만 생략해서는 안됩니다 . 파일 이름 인수가 알려진 리터럴 인 경우 두 인수 형식의 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="9baa512a702be95a00f5cdfa9d3fa8d7a2a0b696" translate="yes" xml:space="preserve">
          <source>In the opposite way, to resolve a hostname to the IP address you can write this:</source>
          <target state="translated">반대로 호스트 이름을 IP 주소로 확인하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb2e91137fed6da0013b83630021f3d72198be0" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">옵션 스펙에서 옵션 이름 뒤에는 등호 &lt;code&gt;=&lt;/code&gt; 및 문자 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가옵니다 . 등호는이 옵션에 값이 필요함을 나타냅니다. 문자 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 는이 값이 임의의 문자열임을 나타냅니다. 다른 가능한 값 유형은 정수 값의 경우 &lt;code&gt;i&lt;/code&gt; , 부동 소수점 값의 경우 &lt;code&gt;f&lt;/code&gt; 입니다. 콜론을 사용하여 &lt;code&gt;:&lt;/code&gt; 등호 (=) 대신하면 옵션 값은 선택을 나타냅니다. 이 경우 적합한 값을 제공하지 않으면 문자열 값 옵션에 빈 문자열 &lt;code&gt;''&lt;/code&gt; 이 할당되고 숫자 옵션은 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2973e9ef2ea1b82ed03c1ee6b61fab3e0195c205" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;s&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;s&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">옵션 사양에서 옵션 이름 뒤에는 등호 &lt;code&gt;=&lt;/code&gt; 및 문자 &lt;code&gt;s&lt;/code&gt; 가옵니다 . 등호는이 옵션에 값이 필요함을 나타냅니다. 문자 &lt;code&gt;s&lt;/code&gt; 는이 값이 임의의 문자열임을 나타냅니다. 다른 가능한 값 유형은 정수 값의 경우 &lt;code&gt;i&lt;/code&gt; 이고 부동 소수점 값의 경우 &lt;code&gt;f&lt;/code&gt; 입니다. 콜론을 사용하여 &lt;code&gt;:&lt;/code&gt; 등호 (=) 대신하면 옵션 값은 선택을 나타냅니다. 이 경우 적절한 값이 제공되지 않으면 문자열 값 옵션에 빈 문자열 &lt;code&gt;''&lt;/code&gt; 이 할당되고 숫자 옵션은 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="53db56988ad2d32c572da0df498153024ad7a10e" translate="yes" xml:space="preserve">
          <source>In the past, the Perl community experimented with a technique called &quot;inside-out objects&quot;. An inside-out object stores its data outside of the object's reference, indexed on a unique property of the object, such as its memory address, rather than in the object itself. This has the advantage of enforcing the encapsulation of object attributes, since their data is not stored in the object itself.</source>
          <target state="translated">과거에 Perl 커뮤니티는 &quot;내부 객체&quot;라는 기술을 실험했습니다. 인사이드 아웃 객체는 객체 자체가 아닌 메모리 주소와 같은 객체의 고유 속성에 대해 색인화 된 객체 참조 외부에 데이터를 저장합니다. 이는 데이터가 객체 자체에 저장되지 않기 때문에 객체 속성의 캡슐화를 시행하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5906a56cbc722b4f6580ce6c1001f48ce79b661" translate="yes" xml:space="preserve">
          <source>In the past, the distribution metadata structure had been packed with distributions as</source>
          <target state="translated">과거에는 배포 메타 데이터 구조가 다음과 같은 배포로 가득 차있었습니다.</target>
        </trans-unit>
        <trans-unit id="8a3a725cb056826efb62b17fb21f5a5c69a3ce79" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">과거에는 주요 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 선택 사항이지만 생략하면 사용 중지 경고가 표시됩니다. v5.22.0부터는 생략하면 구문 오류가 발생합니다. 이전 코드 에서이 구문이 발생하면 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 만 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="6491315a7266db76aa8c4f0b2210eb7af26bbb35" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">과거에는 주요 &lt;code&gt;m&lt;/code&gt; 에서 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 선택 사항이지만 생략하면 지원 중단 경고가 생성됩니다. v5.22.0부터 생략하면 구문 오류가 발생합니다. 이전 코드에서이 구조를 발견하면 &lt;code&gt;m&lt;/code&gt; 을 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="3a63857af592db7e75d88e816c7c7a1180f9eb89" translate="yes" xml:space="preserve">
          <source>In the pathological case that a script is called via a relative path</source>
          <target state="translated">병리학 적 경우 상대 경로를 통해 스크립트가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b5cb98f00aa6aaa22eb71c271690cbb1ebc9df81" translate="yes" xml:space="preserve">
          <source>In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot; and after the &quot;m&quot;. These patterns match /\Bam\B/:</source>
          <target state="translated">/ \ Bam \ B / 패턴에서 &quot;a&quot;앞과 &quot;m&quot;뒤에 단어 문자가 있어야합니다. 이 패턴은 / \ Bam \ B /와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d454ee791b9ae0c5bbb81657f656033f3c0c5a24" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">특유의에서는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 형태 버전과 비교한다 포지티브 소수 부분과 같은 5.006, 이어도 &lt;code&gt;$]&lt;/code&gt; , 또는 비교 될 것이다 폼 v5.6.1의 V-문자열 &lt;code&gt;$^V&lt;/code&gt; ($ 일명 PERL_VERSION). VERSION이 현재 Perl 인터프리터 버전보다 큰 경우 예외가 발생합니다. Perl은 파일의 나머지 부분을 구문 분석하지 않습니다. 런타임시 유사한 검사를 수행 할 수있는 &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt; 와 비교하십시오 . 대칭 적으로 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용하면 지정된 버전보다 오래된 Perl 버전을 원하는 것으로 지정할 수 &lt;a href=&quot;functions/no&quot;&gt;없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74d3b7e92857ff92a78ee1a11cb1e6022b249cb3" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">특유의에서는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 형태 버전과 비교한다 포지티브 소수 부분과 같은 5.006, 이어도 &lt;code&gt;$]&lt;/code&gt; , 또는 비교 될 것이다 폼 v5.6.1의 V-문자열 &lt;code&gt;$^V&lt;/code&gt; ($ 일명 PERL_VERSION). VERSION이 현재 Perl 인터프리터 버전보다 큰 경우 예외가 발생합니다. Perl은 파일의 나머지 부분을 구문 분석하지 않습니다. 런타임시 유사한 검사를 수행 할 수있는 &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt; 와 비교하십시오 . 대칭 적으로 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용하면 지정된 버전보다 오래된 Perl 버전을 원하는 것으로 지정할 수 &lt;a href=&quot;no&quot;&gt;없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5da666074fc2ec75362b3b68f86858be734f6e9" translate="yes" xml:space="preserve">
          <source>In the presence of multiple classes it can be non-trivial to make sure that every relevant destructor is called for every object. Perl calls the first one it finds on the inheritance tree (if any) and that's it.</source>
          <target state="translated">여러 클래스가있는 경우 모든 관련 소멸자가 모든 객체에 대해 호출되도록하는 것이 쉽지 않을 수 있습니다. Perl은 상속 트리에서 찾은 첫 번째 것을 호출합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="cd34d34a3c68755abc29d11ed297638bd9fdb29d" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt; ). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt; ). It should also set &lt;code&gt;subcoffset&lt;/code&gt; , the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">의 존재에 &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; 의 플래그 만의 추가와 함께 &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 또는 &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; 플래그, 엔진은 (여전히 존재 그렇게해야하지만, 전체 버퍼를 복사하지 않도록 선택할 수 있습니다 &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; 또는 설정되는 관련 비트 &lt;code&gt;PL_sawampersand&lt;/code&gt; 를 ) . 이 경우, 버퍼의 논리적 시작에서 물리적 시작 (즉, &lt;code&gt;subbeg&lt;/code&gt; ) 까지의 바이트 수를 나타내도록 &lt;code&gt;suboffset&lt;/code&gt; 을 설정할 수 있습니다 . 또한 오프셋의 문자 &lt;code&gt;subcoffset&lt;/code&gt; 을 설정해야합니다 . 후자는 바이트가 아닌 문자로 작동하는 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 를 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e824f56cbef986827e73fc6c293b5f1b6c0ceaea" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt;). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt;). It should also set &lt;code&gt;subcoffset&lt;/code&gt;, the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">의 존재에 &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; 의 플래그 만의 추가와 함께 &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 또는 &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; 플래그, 엔진은 (여전히 존재 그렇게해야하지만, 전체 버퍼를 복사하지 않도록 선택할 수 있습니다 &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; 또는 설정되는 관련 비트 &lt;code&gt;PL_sawampersand&lt;/code&gt; 를 ) . 이 경우 버퍼의 논리적 시작에서 물리적 시작 (즉, &lt;code&gt;subbeg&lt;/code&gt; ) 까지의 바이트 수를 나타 내기 위해 &lt;code&gt;suboffset&lt;/code&gt; 을 설정할 수 있습니다 . 또한 오프셋의 문자 &lt;code&gt;subcoffset&lt;/code&gt; 을 설정해야합니다 . 후자는 바이트가 아닌 문자로 작동하는 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 를 지원하는 데 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="b073c0a34c41b3ba5f06418d694ba351020d4acc" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt; , and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">이전 예제에서 함수 전용 변수는 하나의 함수 만 참조를 기억했기 때문에 작성했습니다. 변수가 범위 내에있는 동안 여러 함수를 정의 할 수 있으며 각 함수는 &quot;개인&quot;변수를 공유 할 수 있습니다. 어휘 변수가 범위 내에있는 동안 함수 외부에서 액세스 할 수 있고 참조를 작성할 수 있기 때문에 실제로 &quot;정적&quot;이 아닙니다. 이 예에서 &lt;code&gt;increment_count&lt;/code&gt; 와 &lt;code&gt;return_count&lt;/code&gt; 는 변수를 공유합니다. 한 함수는 값에 추가하고 다른 함수는 단순히 값을 반환합니다. 둘 다 &lt;code&gt;$count&lt;/code&gt; 액세스 할 수 있으며 범위를 벗어 났으므로 액세스 할 수있는 다른 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2b9d6cad21d85345ac4d94d7af37ac664ad662a" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt;, and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">이전 예제에서는 하나의 함수 만 해당 참조를 기억했기 때문에 function-private 변수를 생성했습니다. 변수가 범위 내에있는 동안 여러 함수를 정의 할 수 있으며 각 함수는 &quot;개인&quot;변수를 공유 할 수 있습니다. 어휘 변수가 범위 내에있는 동안 함수 외부에서 액세스 할 수 있고 참조를 만들 수도 있기 때문에 실제로 &quot;정적&quot;이 아닙니다. 이 예에서 &lt;code&gt;increment_count&lt;/code&gt; 및 &lt;code&gt;return_count&lt;/code&gt; 는 변수를 공유합니다. 한 함수는 값에 추가되고 다른 함수는 단순히 값을 반환합니다. 둘 다 &lt;code&gt;$count&lt;/code&gt; 액세스 할 수 있으며 범위를 벗어 났으므로 액세스 할 다른 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d099eddc17fd02123a62f3b5a7b0e3fc3ac46d20" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt; . In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;{}&lt;/code&gt; 코드는 빈 익명 해시에 대한 참조를 만듭니다. 는 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 함수는 그 기준을 취하고있는 클래스 해쉬 연관 &lt;code&gt;$class&lt;/code&gt; . 가장 간단한 경우 &lt;code&gt;$class&lt;/code&gt; 변수는 문자열 &quot;File&quot;을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a5350392ddebfffc20c7f17feabf4ccae1793367" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;bless&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt;. In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;{}&lt;/code&gt; 코드는 빈 익명 해시에 대한 참조를 만듭니다. 는 &lt;code&gt;bless&lt;/code&gt; 함수는 그 기준을 취하고있는 클래스 해쉬 연관 &lt;code&gt;$class&lt;/code&gt; . 가장 간단한 경우 &lt;code&gt;$class&lt;/code&gt; 변수는 &quot;File&quot;문자열을 포함하게됩니다.</target>
        </trans-unit>
        <trans-unit id="c1001ba58ff0530a993f349b4836f78782ab43f8" translate="yes" xml:space="preserve">
          <source>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</source>
          <target state="translated">이전 섹션에서는 바이너리 메시지 길이를 실제 메시지 앞에 접두어로 구성한 네트워크 메시지를 보았습니다. 널 바이트가 데이터의 일부일 수있는 경우 널 바이트를 추가해도 작동하지 않으므로 길이 다음에 너무 많은 바이트의 데이터를 패킹하는 것이 자주 사용되는 레시피입니다. 다음은 두 기술을 모두 사용하는 예입니다. 소스 및 대상 주소가있는 두 개의 널 종료 문자열 후에 길이 바이트 후에 짧은 메시지 (휴대 전화로)가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="4d306b4b58fb980badf24b06473c4af8a30ac12e" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 를 사용하여 정수 또는 리틀 엔디안 바이트 순서로 정수를 패킹하고 언팩 하는 방법을 배웠습니다 . 이것은 훌륭하지만 64 비트 정수뿐만 아니라 모든 종류의 부호있는 정수를 제외하기 때문에 여전히 제한적입니다. 예를 들어, 플랫폼 독립적 인 방식으로 부호있는 big-endian 16 비트 정수 시퀀스를 풀려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c615499a4424a37edb78ee5b923ce59bdd024d2" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">이전 섹션에서 우리는 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 를 사용하여 빅 엔디안 또는 리틀 엔디안 바이트 순서로 정수를 압축 및 압축 해제 하는 방법을 배웠습니다 . 이것은 좋지만 64 비트 정수뿐만 아니라 모든 종류의 부호있는 정수를 제외하기 때문에 여전히 다소 제한적입니다. 예를 들어, 플랫폼 독립적 인 방식으로 부호있는 빅 엔디안 16 비트 정수 시퀀스를 압축 해제하려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bb18f0a7b082417093abe50cb091ae0ce9d7c1a" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt; . If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">드물게이 모듈을 통해 특정 상수가 선언되었는지 런타임에 감지해야하는 경우,이 함수를 사용하여 해시 &lt;code&gt;%constant::declared&lt;/code&gt; 를 검사 할 수 있습니다 . 주어진 상수 이름에 패키지 이름이 포함되어 있지 않으면 현재 패키지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a85e53a816aad498e6024b9d058168f37940833" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt;. If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">이 모듈을 통해 특정 상수가 선언되었는지 런타임에 발견해야하는 드문 경우에이 함수를 사용하여 해시 &lt;code&gt;%constant::declared&lt;/code&gt; 를 검사 할 수 있습니다 . 지정된 상수 이름에 패키지 이름이 포함되지 않은 경우 현재 패키지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3fa00fdc801acdaeaeaafa7c77b5e93974f8b30" translate="yes" xml:space="preserve">
          <source>In the rare case where the Pod document has code like L&amp;lt;</source>
          <target state="translated">드물게 Pod 문서에 L &amp;lt;과 같은 코드가있는 경우</target>
        </trans-unit>
        <trans-unit id="3b8dca1a84eab639eb1c11dec6ee3458c3d80e63" translate="yes" xml:space="preserve">
          <source>In the rare cases where a man page link has a section specified, that text appears in a</source>
          <target state="translated">매뉴얼 페이지 링크에 섹션이 지정된 드문 경우에 해당 텍스트는</target>
        </trans-unit>
        <trans-unit id="b3168d71bbd1d6362a03e87b3b6357cbc463ee97" translate="yes" xml:space="preserve">
          <source>In the scalar context, returns the modified collator (but it is &lt;b&gt;not&lt;/b&gt; a clone from the original).</source>
          <target state="translated">스칼라 컨텍스트에서 수정 된 콜 레이터를 리턴합니다 ( 원본의 복제본 은 &lt;b&gt;아님&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e123d33b9c36acd15c038a592d06bccf26e5a4c" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일 설정을 따릅니다 . 이것은 알파벳, 숫자, 문장 부호,</target>
        </trans-unit>
        <trans-unit id="ea3c9a616e33a3cad4631e8af654cde72ce4e1bd" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">데이터 정렬을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 환경 변수를 찾아 문자의 데이터 정렬 (순서 지정)에 대한 애플리케이션의 개념을 판별합니다. 예를 들어, &quot;b&quot;는 라틴 알파벳에서 &quot;a&quot;뒤에 있지만 &quot;&amp;aacute;&quot;와 &quot;&amp;aring;&quot;는 어디에 속합니까? &quot;color&quot;는 영어로 &quot;chocolate&quot;을 따르지만 전통적인 스페인어는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="42610118c4c59300a5cb5815d6a9dfee51cae833" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일 설정을 따릅니다 . 이것은 문자가 알파벳, 숫자, 구두점,</target>
        </trans-unit>
        <trans-unit id="8d056d856cee45cf14c89294fd2e1cd2905d97a0" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">조합을 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식 의 범위 에서 Perl은 &lt;code&gt;LC_COLLATE&lt;/code&gt; 환경 변수를 찾아 문자 조합 (순서)에 대한 애플리케이션의 개념을 판별합니다. 예를 들어, &quot;b&quot;는 라틴 알파벳에서 &quot;a&quot;다음에 나오지만 &quot;&amp;aacute;&quot;와 &quot;&amp;aring;&quot;는 어디에 속합니까? 그리고 &quot;색상&quot;은 영어로 &quot;초콜릿&quot;을 따르는 반면, 전통적인 스페인어에서는 어떨까요?</target>
        </trans-unit>
        <trans-unit id="85dc6b4df5881b7609167c49737d8fd061975bdc" translate="yes" xml:space="preserve">
          <source>In the second example, an event driven program, the flow of control will be more like this</source>
          <target state="translated">두 번째 예인 이벤트 중심 프로그램에서 제어 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0aec5f41df04fa608d73972b5b60d0e21665dd44" translate="yes" xml:space="preserve">
          <source>In the second example, however, we have stored another reference to the tied object in $x. That means that when untie() gets called there will still be a valid reference to the object in existence, so the destructor is not called at that time, and thus the file is not closed. The reason there is no output is because the file buffers have not been flushed to disk.</source>
          <target state="translated">그러나 두 번째 예에서는 묶인 객체에 대한 다른 참조를 $ x에 저장했습니다. 즉, untie ()가 호출 될 때 존재하는 객체에 대한 유효한 참조가 여전히 존재하므로 그 때 소멸자가 호출되지 않으므로 파일이 닫히지 않습니다. 출력이없는 이유는 파일 버퍼가 디스크로 플러시되지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="69631891c8053c89e0b6bca3447bddf1c255a6c7" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">두 번째 형태에서, BLOCK 내의 코드는 한 번만 구문 분석되며, 동시에 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체를 둘러싼 코드 는 구문 분석되고 현재 Perl 프로그램의 컨텍스트 내에서 실행됩니다. 이 형식은 일반적으로 첫 번째 (아래 참조)보다 예외를 더 효율적으로 잡는 데 사용되며 컴파일시 BLOCK 내에서 코드를 검사하는 이점도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a4b1f50ba31b2407de5a923935b79599705457e" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">두 번째 형태에서, BLOCK 내의 코드는 한 번만 구문 분석되며, 동시에 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체를 둘러싼 코드 는 구문 분석되고 현재 Perl 프로그램의 컨텍스트 내에서 실행됩니다. 이 형식은 일반적으로 첫 번째 (아래 참조)보다 예외를 더 효율적으로 잡는 데 사용되며 컴파일시 BLOCK 내에서 코드를 검사하는 이점도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1201aa9883bceff61ceee62acff043056d093395" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second &quot;the&quot;.</source>
          <target state="translated">두 번째 일치에서 &lt;code&gt;$`&lt;/code&gt; 는 &lt;code&gt;''&lt;/code&gt; 와 같습니다 . 정규 표현식이 문자열의 첫 번째 문자 위치에서 일치하고 중지 되었기 때문입니다. 두 번째 &quot;the&quot;를 본 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d9a2ff0446afe648b7cb9385c3e87c463ddf6fa" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second 'the'.</source>
          <target state="translated">두 번째 일치 에서 정규 표현식이 문자열의 첫 번째 문자 위치에서 일치하고 중지 되었기 때문에 &lt;code&gt;$`&lt;/code&gt; 는 &lt;code&gt;''&lt;/code&gt; 와 같습니다 . 그것은 두 번째 'the'를 보지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="37e9c3cdd59dd9ca84f70e11b37a63713067a365" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt; . This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">제 2 단계에서, 구현의 자유 상속성 (또는 그 부족)이 설명된다. 이를 위해 &lt;code&gt;Name&lt;/code&gt; 의 공통 서브 클래스 인 &lt;code&gt;NamedFile&lt;/code&gt; 이라는 클래스 와 표준 클래스 &lt;code&gt;IO::File&lt;/code&gt; 합니다. &lt;code&gt;IO::File&lt;/code&gt; 객체 때문에 테스트에 상속성을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="0af589bc3ee5e35834b2ae0ea25f9b4768b209d4" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt;. This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">두 번째 단계에서는 구현의 자유로운 상속 가능성 (또는 그 부족)이 입증됩니다. 이를 위해 &lt;code&gt;Name&lt;/code&gt; 과 표준 클래스 &lt;code&gt;IO::File&lt;/code&gt; 의 공통 하위 클래스 인 &lt;code&gt;NamedFile&lt;/code&gt; 이라는 클래스를 구성합니다 . 이것은 &lt;code&gt;IO::File&lt;/code&gt; 객체 때문에 상속성을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="979450caa584768989298a5e328245eeac253de3" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">엄밀히 말하면, 스크립트는 시작된 쉘과 다른 프로세스로 실행됩니다. 프로세스에 대한 변경 사항은 상위 항목에 반영되지 않으며 변경 후 생성 된 모든 하위 항목에만 반영됩니다. 쉘 에서 스크립트의 출력을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 함으로써 가짜로 만들 수있는 쉘 마술이 있습니다 . 자세한 내용은 comp.unix.questions FAQ를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="860fc9235e7c86163e85788bda311e6bc6c6ab87" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;eval()&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">가장 엄격한 의미에서이 작업은 수행 할 수 없습니다. 스크립트는 시작된 셸과 다른 프로세스로 실행됩니다. 프로세스에 대한 변경 사항은 부모에 반영되지 않고 변경 후에 생성 된 모든 자식에만 반영됩니다. 쉘 에서 스크립트의 출력을 &lt;code&gt;eval()&lt;/code&gt; 하여 가짜로 만들 수있는 쉘 마법이 있습니다 . 자세한 내용은 comp.unix.questions FAQ를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d5c6294b971049c13607515864de8d9b4202e94" translate="yes" xml:space="preserve">
          <source>In the symbian subdirectory there is</source>
          <target state="translated">symbian 서브 디렉토리에는</target>
        </trans-unit>
        <trans-unit id="a6664c3e7887f18c07bf996abcbf98da47057e7d" translate="yes" xml:space="preserve">
          <source>In the syntax descriptions that follow, list operators that expect a list (and provide list context for elements of the list) are shown with LIST as an argument. Such a list may consist of any combination of scalar arguments or list values; the list values will be included in the list as if each individual element were interpolated at that point in the list, forming a longer single-dimensional list value. Commas should separate literal elements of the LIST.</source>
          <target state="translated">다음 구문 설명에서 목록을 예상하고 목록의 요소에 대한 목록 컨텍스트를 제공하는 목록 연산자는 LIST를 인수로 사용하여 표시됩니다. 이러한 목록은 스칼라 인수 또는 목록 값의 조합으로 구성 될 수 있습니다. 각 개별 요소가 목록의 해당 지점에서 보간 된 것처럼 목록 값이 목록에 포함되어 더 긴 1 차원 목록 값을 형성합니다. 쉼표는 LIST의 리터럴 요소를 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe67245ac84887f626543e24a3e6a624b4a7332b" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt; . (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt; ) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie () 호출에서 &lt;code&gt;VARIABLE&lt;/code&gt; 은 매혹 될 변수의 이름입니다. &lt;code&gt;CLASSNAME&lt;/code&gt; 은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. &lt;code&gt;LIST&lt;/code&gt; 의 추가 인수는 해당 클래스에 적합한 생성자 메서드 (TIESCALAR (), TIEARRAY (), TIEHASH () 또는 TIEHANDLE ())에 전달됩니다. (일반적으로 이들은 C의 dbminit () 함수에 전달 될 수있는 인수입니다.) &quot;new&quot;메소드에 의해 리턴 된 오브젝트도 tie () 함수에 의해 리턴됩니다. 이는 다른 메소드에 액세스하려는 경우 유용합니다. 에 &lt;code&gt;CLASSNAME&lt;/code&gt; . (실제로 올바른 &quot;유형&quot;에 대한 참조를 반환 할 필요는 없습니다 (예 : HASH 또는 &lt;code&gt;CLASSNAME&lt;/code&gt; ) 제대로 축복 된 개체 인 한) tied () 함수를 사용하여 기본 개체에 대한 참조를 검색 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85e139a9d34793e56b9fe2b00c4a278f893619e" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt;. (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt;) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie () 호출에서 &lt;code&gt;VARIABLE&lt;/code&gt; 은 부여 할 변수의 이름입니다. &lt;code&gt;CLASSNAME&lt;/code&gt; 은 올바른 유형의 오브젝트를 구현하는 클래스 이름입니다. &lt;code&gt;LIST&lt;/code&gt; 의 추가 인수는 해당 클래스에 대한 적절한 생성자 메서드 (즉, TIESCALAR (), TIEARRAY (), TIEHASH () 또는 TIEHANDLE ())로 전달됩니다. (일반적으로 이들은 C의 dbminit () 함수에 전달 될 수있는 것과 같은 인수입니다.) &quot;new&quot;메소드에 의해 반환 된 객체는 tie () 함수에 의해 반환되기 때문에 다른 메서드에 액세스하려는 경우 유용합니다. 에 &lt;code&gt;CLASSNAME&lt;/code&gt; . (실제로 올바른 &quot;유형&quot;(예 : HASH 또는 &lt;code&gt;CLASSNAME&lt;/code&gt; )에 대한 참조를 반환 할 필요는 없습니다.) 제대로 축복받은 객체라면.) tied () 함수를 사용하여 기본 객체에 대한 참조를 검색 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e605f529d11854bba56a166fe10700b1dd88fb" translate="yes" xml:space="preserve">
          <source>In the two-argument (and one-argument) form, opening &lt;code&gt;&amp;lt;-&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; opens STDIN and opening &lt;code&gt;&amp;gt;-&lt;/code&gt; opens STDOUT.</source>
          <target state="translated">2 인수 (및 1 인수) 양식에서 &lt;code&gt;&amp;lt;-&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 열면 STDIN이 열리고 &lt;code&gt;&amp;gt;-&lt;/code&gt; 가 열리면 STDOUT이 열립니다.</target>
        </trans-unit>
        <trans-unit id="43780fa78aa7e37a1a813f3169ce3533b0cbb0cd" translate="yes" xml:space="preserve">
          <source>In the two-argument form of open(), a pipe open can be achieved by either appending or prepending a pipe symbol to the second argument:</source>
          <target state="translated">두 인수 형식의 open ()에서 두 번째 인수에 파이프 기호를 추가하거나 앞에 추가하여 파이프를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305b7a93b43681322f3469e0f0cb84a704ec6817" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt; ) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">좀 더 복잡한 초기화가 필요한 SV의 경우 newSV (len)를 사용하여 빈 SV를 만들 수 있습니다. 경우 &lt;code&gt;len&lt;/code&gt; 형 NULL의 빈 SV가 반환 0, 형 PV의 다른 SV에 함께 반환합니다 (1 + 렌 &lt;code&gt;NUL&lt;/code&gt; ) 할당 스토리지, SvPVX를 통해 액세스 할 수의 바이트. 두 경우 모두 SV에 undef 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7cf307c9a8a074b8b42ee12dd010c5730718073" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt;) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">좀 더 복잡한 초기화가 필요한 SV의 경우는 드물지만 newSV (len)를 사용하여 빈 SV를 만들 수 있습니다. 경우 &lt;code&gt;len&lt;/code&gt; 형 NULL의 빈 SV가 반환 0, 형 PV의 다른 SV에 함께 반환합니다 (1 + 렌 &lt;code&gt;NUL&lt;/code&gt; ) 할당 스토리지, SvPVX를 통해 액세스 할 수의 바이트. 두 경우 모두 SV에는 undef 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65702a5086ab6fd62074e14eca8df9ddcb2f9f3" translate="yes" xml:space="preserve">
          <source>In the unlikely situation that you need to tell the parser that you will accept additional directives (&quot;=foo&quot; things), you need to first set the parser to treat its content as data (i.e., not really processed at all), or as verbatim (mostly just expanding tabs), or as processed text (parsing formatting codes like B&amp;lt;...&amp;gt;).</source>
          <target state="translated">파서에게 추가 지시문 ( &quot;= foo&quot;항목)을 허용 할 것이라고 말해야하는 드문 상황에서 먼저 파서의 내용을 데이터 (즉, 전혀 처리되지 않음)로 처리하도록 설정해야합니다. 그대로 (대부분 확장 탭) 또는 처리 된 텍스트 (B &amp;lt;...&amp;gt;와 같은 형식화 코드 구문 분석)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e08f73822da4db28b0244d63be2806e6742a13f9" translate="yes" xml:space="preserve">
          <source>In the words of Chaim Frenkel: &quot;Perl's grammar can not be reduced to BNF. The work of parsing perl is distributed between yacc, the lexer, smoke and mirrors.&quot;</source>
          <target state="translated">Chaim Frenkel의 말에 따르면 : &quot;Perl의 문법은 BNF로 줄일 수 없습니다. perl을 파싱하는 작업은 yacc, 어휘 분석기, 연기 및 거울 사이에 배포됩니다.&quot;</target>
        </trans-unit>
        <trans-unit id="eea8935b77be896004ea3b86596d8c4b9f389127" translate="yes" xml:space="preserve">
          <source>In the work crew model, several threads are created that do essentially the same thing to different pieces of data. It closely mirrors classical parallel processing and vector processors, where a large array of processors do the exact same thing to many pieces of data.</source>
          <target state="translated">작업 승무원 모델에서는 다른 데이터 조각과 본질적으로 동일한 작업을 수행하는 여러 스레드가 생성됩니다. 그것은 고전적인 병렬 처리 및 벡터 프로세서를 밀접하게 반영합니다. 여기의 프로세서는 많은 데이터에 대해 똑같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="c55ef95af3c2d0a3702a06238a73d0da82b1e62b" translate="yes" xml:space="preserve">
          <source>In the year 2010 App::cpanminus was launched as a new approach to a cpan shell with a considerably smaller footprint. Very cool stuff.</source>
          <target state="translated">2010 년 App :: cpanminus는 설치 공간이 훨씬 작은 cpan 쉘에 대한 새로운 접근 방식으로 시작되었습니다. 아주 멋진 것들.</target>
        </trans-unit>
        <trans-unit id="113762dd3316218250364ac4d21aa3eda82fed63" translate="yes" xml:space="preserve">
          <source>In theory &lt;code&gt;Strtol&lt;/code&gt; and &lt;code&gt;Strtoul&lt;/code&gt; may not be defined if the machine perl is built on doesn't actually have strtol and strtoul. But as those 2 functions are part of the 1989 ANSI C spec we suspect you'll find them everywhere by now.</source>
          <target state="translated">이론적으로 &lt;code&gt;Strtol&lt;/code&gt; 과 &lt;code&gt;Strtoul&lt;/code&gt; 은 펄이 내장 된 머신에 실제로 strtol과 strtoul이없는 경우 정의되지 않을 수 있습니다. 그러나이 두 함수가 1989 ANSI C 사양의 일부이므로 지금은 어디에서나 찾을 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="04c962eb376205914b3738a1df3cdb3251c93666" translate="yes" xml:space="preserve">
          <source>In theory these routines were not and are not intended to be used outside of the perl core, and are subject to change and removal at any time.</source>
          <target state="translated">이론적으로 이러한 루틴은 Perl 코어 외부에서 사용되지 않았으며 의도되지 않았으며 언제든지 변경 및 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d524f396baff67e45d81dc7f8d13d5cf1e77d980" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">이론적으로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 은 -2 ** 63에서 2 ** 63-1까지 신뢰할 수 있습니다. 그러나 구현의 해결 방법은 부동 소수점 숫자를 사용하기 때문에 시간이 갈수록 정확하지 않습니다. 이것은 버그이며 향후 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="6b03e06382fed416572947e88ed120d6b2caf5ff" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;gmtime&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work-arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">이론적으로 &lt;code&gt;gmtime&lt;/code&gt; 은 -2 ** 63에서 2 ** 63-1까지 신뢰할 수 있습니다. 그러나 구현의 해결 방법은 부동 소수점 숫자를 사용하기 때문에 시간이 길어질수록 정확하지 않게됩니다. 이것은 버그이며 향후 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="cbe5df9e111a076eb83a7b1ca2b907e2c293b988" translate="yes" xml:space="preserve">
          <source>In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined. The defined test avoids problems where the line has a string value that would be treated as false by Perl; for example a &quot;&quot; or a &lt;code&gt;&quot;0&quot;&lt;/code&gt; with no trailing newline. If you really mean for such values to terminate the loop, they should be tested for explicitly:</source>
          <target state="translated">이러한 루프 구성에서 할당 된 값 (할당이 자동이든 명시 적이든)이 정의되었는지 여부를 테스트합니다. 정의 된 테스트는 행에 Perl에 의해 false로 처리되는 문자열 값이있는 문제를 피합니다. 예를 들어, 줄 바꿈이없는 &quot;&quot;또는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 입니다. 루프를 종료하기 위해 이러한 값을 실제로 의미하는 경우 명시 적으로 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e44b8059bd25cac80d7a80701ceeb87c0cc485a" translate="yes" xml:space="preserve">
          <source>In this -exec rendering, each opcode is executed in the order shown. The add opcode, marked with '*', is discussed in more detail.</source>
          <target state="translated">이 -exec 렌더링에서 각 opcode는 표시된 순서대로 실행됩니다. '*'로 표시된 추가 opcode에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fd1f4af2f36f22296f6e12cb734299d228fd203a" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt; . If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">이 대안에서는 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 앞에 &lt;code&gt;'\d+\.'&lt;/code&gt; \ d +' 를 두는 것이 중요합니다 . . 만약 &lt;code&gt;'\d+\.'&lt;/code&gt; 먼저 정규 표현식이 행복하게 일치하고 숫자의 소수 부분을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4d8fb7dabadcf5fdf3a7d10f33d4299f66b99d0d" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt;. If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">이 교대로 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 를 &lt;code&gt;'\d+\.'&lt;/code&gt; ' 앞에 두는 것이 중요합니다 . . 만약 &lt;code&gt;'\d+\.'&lt;/code&gt; 먼저 정규 표현식은이를 만족스럽게 일치시키고 숫자의 소수 부분을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c0e19afab75cca33f669db41034484d08b958820" translate="yes" xml:space="preserve">
          <source>In this call,</source>
          <target state="translated">이 전화에서</target>
        </trans-unit>
        <trans-unit id="4ecf4a828b4af8d398e7cb607aebb3e775eec012" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;entersubop&lt;/code&gt; is a pointer to the &lt;code&gt;entersub&lt;/code&gt; op, which may be replaced by the check function, and &lt;code&gt;namegv&lt;/code&gt; supplies the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">이 호출에 &lt;code&gt;entersubop&lt;/code&gt; 가 받는 포인터이다 &lt;code&gt;entersub&lt;/code&gt; 의 체크 기능으로 대체 될 수 연산은,과 &lt;code&gt;namegv&lt;/code&gt; 는 의 호 출처 참조하는 체크 기능에 의해 사용되어야하는 이름 공급 &lt;code&gt;entersub&lt;/code&gt; 의 그 어떤을 방출 할 필요가있는 경우 연산을 진단. 다른 서브 루틴 또는 메소드 호출에 대한 호출과 같은 비표준 상황에서 check 기능을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f085ed6c4e3052eb0bb052f156e9a4157a1fe5d" translate="yes" xml:space="preserve">
          <source>In this call, the two arrays will be populated as shown below (for Unicode 6.0):</source>
          <target state="translated">이 호출에서 두 배열은 아래와 같이 채워집니다 (유니 코드 6.0의 경우).</target>
        </trans-unit>
        <trans-unit id="9ebdd72fd702032acef9641f741ed417c8e827d9" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;IO::Compress::Zip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields.</source>
          <target state="translated">이 경우 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 은 &lt;code&gt;$rawdata&lt;/code&gt; 가 0 개 이상의 일치하는 하위 필드로 구성되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="7445390dec364c96fb636b6c3a3e08bbc004467f" translate="yes" xml:space="preserve">
          <source>In this case a possible way around this problem is to predefine a series of C functions to act as the interface to Perl, thus</source>
          <target state="translated">이 경우이 문제를 해결할 수있는 방법은 Perl의 인터페이스 역할을하는 일련의 C 함수를 미리 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e58eeb1fce65fa0151692bc12dbf74ccd83c8127" translate="yes" xml:space="preserve">
          <source>In this case it is possible to speed up the routine (often quite substantially) by using the lightweight callback API. The idea is that the calling context only needs to be created and destroyed once, and the sub can be called arbitrarily many times in between.</source>
          <target state="translated">이 경우 경량 콜백 API를 사용하여 루틴의 속도를 높일 수 있습니다 (종종 상당히 실질적으로). 아이디어는 호출 컨텍스트를 한 번만 작성하고 파괴하면되고 서브를 임의로 여러 번 호출 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="befe7f5d777ad4551126d4a3070f7f52a7093b40" translate="yes" xml:space="preserve">
          <source>In this case the extra input files will be passed to the program after the target file:</source>
          <target state="translated">이 경우 추가 입력 파일은 대상 파일 다음에 프로그램으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7a45b342cd0260187347347f25fa6f1ce0fc4500" translate="yes" xml:space="preserve">
          <source>In this case the flow of control can consist of only the repeated sequence</source>
          <target state="translated">이 경우 제어 흐름은 반복 된 시퀀스로만 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de52280d051bfe1e84ce26c045f4bd463f4ae0ee" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">이 경우 함수 &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; 및 &lt;code&gt;fn3&lt;/code&gt; 은 호출 할 Perl 서브 루틴을 기억하는 데 사용됩니다. 각 함수는 &lt;code&gt;Pcb&lt;/code&gt; 함수 에서 &lt;code&gt;Map&lt;/code&gt; 배열 에 액세스 하고 실제로 Perl 서브 루틴을 호출하는 데 사용되는 별도의 고정 배선 인덱스를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="a32656bde8fd76ba84b5248615b4f3d9ae23b187" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt;, &lt;code&gt;fn2&lt;/code&gt;, and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">이 경우 &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; 및 &lt;code&gt;fn3&lt;/code&gt; 함수 는 호출 할 Perl 서브 루틴을 기억하는 데 사용됩니다. 각 함수는 &lt;code&gt;Pcb&lt;/code&gt; 함수 에서 &lt;code&gt;Map&lt;/code&gt; 배열 에 액세스 하고 실제로 Perl 서브 루틴을 호출하는 데 사용되는 별도의 고정 연결 인덱스를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba717b73fce507fddc399244f240ef5b6f054dd" translate="yes" xml:space="preserve">
          <source>In this case the input fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; will be transformed into this Perl regular expression</source>
          <target state="translated">이 경우 입력 파일 글로브 &lt;code&gt;*.tar.gz&lt;/code&gt; 는이 Perl 정규식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="779676f9752f28e10579e10de2beca329de72fea" translate="yes" xml:space="preserve">
          <source>In this case the main point to note is that only the last item in the list is returned from the subroutine.</source>
          <target state="translated">이 경우 주목할 점은 목록의 마지막 항목 만 서브 루틴에서 반환된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="570da359699c43b4bafeef5621d77b9bbf97eae1" translate="yes" xml:space="preserve">
          <source>In this case the program will be run multiple times using each target file.</source>
          <target state="translated">이 경우 각 대상 파일을 사용하여 프로그램이 여러 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0f3bc0334984124b9519a2c06691727251a21f" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt; . We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">이 경우 문자열에 &lt;code&gt;foo&lt;/code&gt; 가 포함되어야하며 뒤에 &lt;code&gt;bar&lt;/code&gt; 가 있어야한다는 것을 알고 있습니다 . &lt;code&gt;fbm_instr()&lt;/code&gt; 에 구현 된 Fast Boyer-Moore 매칭을 사용 하여 이러한 문자열의 위치를 ​​찾을 수 있습니다. 그것들이 존재하지 않는다면 훨씬 비싼 정규식 엔진에 의지 할 필요가 없습니다. 더 좋은 점은 존재하는 경우 해당 위치를 사용하여 전체 패턴이 일치하는지 확인하기 위해 정규식 엔진이 다루어야하는 검색 공간을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f3e109a5f7360c04fda6b9c374a7b2aee30c55" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt;. We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">이 경우 우리는 문자열에 &lt;code&gt;foo&lt;/code&gt; 가 있어야하며 그 뒤에 &lt;code&gt;bar&lt;/code&gt; 가 있어야한다는 것을 알고 있습니다 . &lt;code&gt;fbm_instr()&lt;/code&gt; 에 구현 된 Fast Boyer-Moore 매칭을 사용 하여 이러한 문자열의 위치를 ​​찾을 수 있습니다. 존재하지 않는 경우 훨씬 더 비싼 정규식 엔진에 의존 할 필요가 없습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 더 좋은 점은 존재하는 경우 해당 위치를 사용하여 전체 패턴이 일치하는지 확인하기 위해 정규식 엔진이 처리해야하는 검색 공간을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7adf1e07cf7e2de470c351018728e0b1e6d507de" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 복제 할 항목으로 대체됩니다. 0으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="fd0174890e09efbb34e87a3b7a337a821e192e2c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;JSON::PP&lt;/code&gt; creates a tagged JSON value, using a nonstandard extension to the JSON syntax.</source>
          <target state="translated">이 경우 &lt;code&gt;JSON::PP&lt;/code&gt; 는 JSON 구문에 대한 비표준 확장을 사용하여 태그가 지정된 JSON 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8c3e63cc6861b8f9065b2614b3c8a800786d3119" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;undef&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">이 경우 복제 할 항목 이 &lt;code&gt;undef&lt;/code&gt; 로 대체됩니다. 0으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="6c66364cb0f3415ad0b76d2776349bcfcc95f50e" translate="yes" xml:space="preserve">
          <source>In this case, because the &lt;code&gt;JMPENV&lt;/code&gt; level recorded in the &lt;code&gt;CxEVAL&lt;/code&gt; differs from the current one, &lt;code&gt;docatch&lt;/code&gt; just does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; and the C stack unwinds to:</source>
          <target state="translated">때문에이 경우 &lt;code&gt;JMPENV&lt;/code&gt; 의 레벨이 기록 &lt;code&gt;CxEVAL&lt;/code&gt; 현재의 다르면 &lt;code&gt;docatch&lt;/code&gt; 단이 수행 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 와 C로 스택을 풀려 :</target>
        </trans-unit>
        <trans-unit id="38ba605349bb20448e174208a445c574b3bbbe89" translate="yes" xml:space="preserve">
          <source>In this case, if</source>
          <target state="translated">이 경우</target>
        </trans-unit>
        <trans-unit id="bb541d2c2f3bc8d3faf27ff1a86aae9a349b1c56" translate="yes" xml:space="preserve">
          <source>In this case, it finds a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File&lt;/code&gt; class. Note that the object passed to &lt;code&gt;save()&lt;/code&gt; in this case is still a &lt;code&gt;File::MP3&lt;/code&gt; object, even though the method is found in the &lt;code&gt;File&lt;/code&gt; class.</source>
          <target state="translated">이 경우 &lt;code&gt;File&lt;/code&gt; 클래스 에서 &lt;code&gt;save()&lt;/code&gt; 메서드를 찾습니다 . 이 경우 &lt;code&gt;save()&lt;/code&gt; 에 전달 된 객체 는 &lt;code&gt;File&lt;/code&gt; 클래스 에서 메서드를 찾더라도 여전히 &lt;code&gt;File::MP3&lt;/code&gt; 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="904227a42dd6a4688cfaf025d7e725bbdfcba9cb" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;TO_JSON&lt;/code&gt; method of the object is invoked in scalar context. It must return a single scalar that can be directly encoded into JSON. This scalar replaces the object in the JSON text.</source>
          <target state="translated">이 경우 개체 의 &lt;code&gt;TO_JSON&lt;/code&gt; 메서드는 스칼라 컨텍스트에서 호출됩니다. JSON으로 직접 인코딩 할 수있는 단일 스칼라를 반환해야합니다. 이 스칼라는 JSON 텍스트의 객체를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d9ed12158dee993299753ff9f1084ddd79644a4a" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt; s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">이 경우 BEGIN은 활성화 된 참조가 없기 때문에 실행 직후에 해제됩니다 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 하위 프로토 타입에는 클로저 가 아니기 때문에 CvWEAKOUTSIDE가 설정되어 있고 $ a는 동일한 CV를 가리 키므로 BEGIN에 기여하지 않습니다. refcount 중 하나. $ a가 실행될 때 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; 는 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 체인을 따르고 해제 된 BEGIN에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="2d6feeb3d0329a363666ad3d9cc4549891bf4b38" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;eval '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt;s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">이 경우 BEGIN은 활성 참조가 없기 때문에 실행 직후에 해제됩니다. anon 하위 프로토 타입에는 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 가 아니기 때문에 CvWEAKOUTSIDE가 설정되어 있고 $ a는 동일한 CV를 가리 키므로 BEGIN에 기여하지 않습니다. refcount 중 하나입니다. $ a가 실행되면 &lt;code&gt;eval '$x'&lt;/code&gt; 는 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 체인을 따르고 해제 된 BEGIN에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="a9a3c5178883306c2188aa48aea362372e427fd0" translate="yes" xml:space="preserve">
          <source>In this case, the behavior is problematic and is not so easily described. Here are two bugs that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">이 경우 동작은 문제가 있으며 쉽게 설명 할 수 없습니다. 다음은 기존 프로그램을 중단하지 않고는 쉽게 수정할 수없는 두 가지 버그입니다.</target>
        </trans-unit>
        <trans-unit id="445e238a2cf161c353789dd6ff6ac3c0dc14cd3f" translate="yes" xml:space="preserve">
          <source>In this case, the data flow from the pipeline can be represented as follows:</source>
          <target state="translated">이 경우 파이프 라인의 데이터 흐름은 다음과 같이 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ef174320084e5b9df3d70ddc86b3f46c5bccd4" translate="yes" xml:space="preserve">
          <source>In this case, the function will overload both of the three way comparison operators. For all overload operations using non-alpha characters, you must type the parameter without quoting, separating multiple overloads with whitespace. Note that &quot;&quot; (the stringify overload) should be entered as \&quot;\&quot; (i.e. escaped).</source>
          <target state="translated">이 경우이 함수는 3 방향 비교 연산자 모두에 과부하가 걸립니다. 알파벳이 아닌 문자를 사용하는 모든 과부하 작업의 경우 따옴표없이 여러 개의 과부하를 공백으로 구분하여 매개 변수를 입력해야합니다. &quot;&quot;(문자열 화 과부하)는 \ &quot;\&quot;(즉 이스케이프 처리)로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8364049e54a9d18ffd4855b1a0b1335cff126ce" translate="yes" xml:space="preserve">
          <source>In this case, the name (&lt;code&gt;http&lt;/code&gt;) will be tried first, but if the resolver does not understand it then the port number (&lt;code&gt;80&lt;/code&gt;) will be used instead.</source>
          <target state="translated">이 경우 이름 ( &lt;code&gt;http&lt;/code&gt; )이 먼저 시도되지만 해석기가 이해하지 못하면 포트 번호 ( &lt;code&gt;80&lt;/code&gt; )가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4b7be359855c6b427d300bbc65846d64f8cf9d" translate="yes" xml:space="preserve">
          <source>In this case, the reference count for the variables will never reach 0, and the references will never be garbage-collected. This can lead to memory leaks.</source>
          <target state="translated">이 경우 변수의 참조 횟수는 0에 도달하지 않으며 참조는 가비지 수집되지 않습니다. 메모리 누수가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6f51a2de8f8d888eeb99016141d99a3d195bd9" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details.</source>
          <target state="translated">이 경우, yes-pattern은 직접 실행되지 않으며 no-pattern은 허용되지 않습니다. 정신에는 변함이 &lt;code&gt;(?{0})&lt;/code&gt; 하지만 더 효율적입니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c85c8e55100a9206350f3d9de1af13e8521e9423" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details. Full syntax: &lt;code&gt;(?(DEFINE)&lt;i&gt;definitions&lt;/i&gt;...)&lt;/code&gt;</source>
          <target state="translated">이 경우 yes-pattern은 직접 실행되지 않으며 no-pattern은 허용되지 않습니다. 정신은 &lt;code&gt;(?{0})&lt;/code&gt; 비슷하지만 더 효율적입니다. 자세한 내용은 아래를 참조하십시오. 전체 구문 : &lt;code&gt;(?(DEFINE)&lt;i&gt;definitions&lt;/i&gt;...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18c031d44e01689714a7d1be31709243cd683ac5" translate="yes" xml:space="preserve">
          <source>In this case, there's not much to see, but of course normally there's pages of stuff to wade through, and 'l' can be very useful. To reset your view to the line we're about to execute, type a lone period '.':</source>
          <target state="translated">이 경우에는 볼 것이 많지 않지만 일반적으로 살펴볼 내용이 있으며 'l'은 매우 유용 할 수 있습니다. 실행하려는 행으로보기를 재설정하려면 고독 기간 '.'을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d6cf564bd8d8897a564d43efb035ccf8128bfa59" translate="yes" xml:space="preserve">
          <source>In this case, you cannot omit the first</source>
          <target state="translated">이 경우 첫 번째를 생략 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c6ff251bc24fa4db8e24130b2fd6042c3837352e" translate="yes" xml:space="preserve">
          <source>In this case, you use the &lt;code&gt;detach()&lt;/code&gt; method. Once a thread is detached, it'll run until it's finished; then Perl will clean up after it automatically.</source>
          <target state="translated">이 경우 &lt;code&gt;detach()&lt;/code&gt; 메서드 를 사용합니다 . 스레드가 분리되면 완료 될 때까지 실행됩니다. Perl은 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="f06a2a722f183edc4aa583848f94d04c7c5ace33" translate="yes" xml:space="preserve">
          <source>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn't do Y, it's against this specification, and should really be fixed. &quot;X should do Y&quot; means that it's recommended, but X may fail to do Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be</source>
          <target state="translated">이 문서에서 &quot;must&quot;/ &quot;must not&quot;, &quot;should&quot;/ &quot;should not&quot;및 &quot;may&quot;는 기존의 의미를 갖습니다 (RFC 2119 참조). &quot;X must do Y&quot;는 X가 그렇지 않으면 Y는이 사양에 위배되며 실제로 수정해야합니다. &quot;X는 Y를해야한다&quot;는 것이 권장된다는 것을 의미하지만, 정당한 이유가 있다면 X는 Y를하지 못할 수도 있습니다. &quot;X는 Y를 할 수있다&quot;는 단지 X는 Y를 자유롭게 할 수 있다는 점에 불과하다.</target>
        </trans-unit>
        <trans-unit id="f65b8f5200f2d0ab93731dfb5d397ad4f5889d0a" translate="yes" xml:space="preserve">
          <source>In this documentation, &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; on the first line of the program will stand in for whatever method works on your system. You are advised to use a specific path if you care about a specific version.</source>
          <target state="translated">이 문서 에서 프로그램의 첫 번째 줄에있는 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 은 시스템에서 작동하는 모든 방법에 적합합니다. 특정 버전에 관심이있는 경우 특정 경로를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="317bfd052c319e12e1dcc797f6ad498f8171149f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;--all&lt;/code&gt; will</source>
          <target state="translated">이 예에서 &lt;code&gt;--all&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="e92bf3ad9ffe37a0d52db0112f7aacb357e3a712" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt; , which can see the new &lt;code&gt;$x&lt;/code&gt; . A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt; .</source>
          <target state="translated">이 예에서, 새로운 &lt;code&gt;$x&lt;/code&gt; 는 &lt;code&gt;whatever&lt;/code&gt; 불릴 때 생성 되며 새로운 &lt;code&gt;inner&lt;/code&gt; 는 새로운 &lt;code&gt;$x&lt;/code&gt; 볼 수 있습니다 . &quot;state&quot;서브는 첫 번째 호출에서 &lt;code&gt;whatever&lt;/code&gt; 까지의 &lt;code&gt;$x&lt;/code&gt; 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03a782210b8b5b9d56172f6b6115f6aa3cd92695" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt;, which can see the new &lt;code&gt;$x&lt;/code&gt;. A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt;.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;whatever&lt;/code&gt; 호출 될 때 새로운 &lt;code&gt;$x&lt;/code&gt; 가 생성 되고 새로운 &lt;code&gt;$x&lt;/code&gt; 볼 수 있는 새로운 &lt;code&gt;inner&lt;/code&gt; 가 생성됩니다 . &quot;state&quot;서브는 첫 번째 호출에서 &lt;code&gt;$x&lt;/code&gt; 만 볼 &lt;code&gt;whatever&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd205d2b3e2dec6816acf70e5f088db6d1ebf4c2" translate="yes" xml:space="preserve">
          <source>In this example, only the first two assignments will be done immediately; after this, all the changes to the file will be deferred up to the user-specified memory limit.</source>
          <target state="translated">이 예에서는 처음 두 할당 만 즉시 수행됩니다. 그 후에 파일에 대한 모든 변경 사항은 사용자가 지정한 메모리 한도까지 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="5a4ab6947e272be82ce081150ade300e39621eac" translate="yes" xml:space="preserve">
          <source>In this example, the expression is evaluated only once, and the tied scalar (the result of the expression) is fetched for each comparison that uses it.</source>
          <target state="translated">이 예에서 표현식은 한 번만 평가되고이를 사용하는 각 비교에 대해 묶인 스칼라 (표현식의 결과)를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="19c920ce6f8f3e81b20912d17931330182ad0a53" translate="yes" xml:space="preserve">
          <source>In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes. This will demonstrate manipulation of complex Perl data types from an XSUB.</source>
          <target state="translated">이 예에서는 배열에 대한 참조를 입력 매개 변수로 사용하고 해시 배열에 대한 참조를 반환합니다. XSUB에서 복잡한 Perl 데이터 유형을 조작하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b22f4e4bd19dab41fd1e0219238248b0317aa35c" translate="yes" xml:space="preserve">
          <source>In this example, we will get the following output:</source>
          <target state="translated">이 예제에서는 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ee2620c9071c60e99d08be588513a407e9d8d25d" translate="yes" xml:space="preserve">
          <source>In this example, we'll do some more work with the argument stack. The previous examples have all returned only a single value. We'll now create an extension that returns an array.</source>
          <target state="translated">이 예에서는 인수 스택에 대해 더 많은 작업을 수행합니다. 이전 예제는 모두 단일 값만 반환했습니다. 이제 배열을 반환하는 확장을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bc42a21b3f25368390b359d2c6a1e02f5038d3de" translate="yes" xml:space="preserve">
          <source>In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries. To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us.</source>
          <target state="translated">이 예제에서는 이제 사전 정의 된 C 라이브러리와 상호 작용할 XSUB를 작성하기 시작합니다. 우선, 우리 자신의 작은 라이브러리를 구축 한 다음 h2xs가 .pm 및 .xs 파일을 작성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="955bf75951fa8c51c57a77cb9f4962e2f9fbe8e1" translate="yes" xml:space="preserve">
          <source>In this facet the &lt;code&gt;details&lt;/code&gt; field overrides the &quot;failed at test_file.t line 42.&quot; message provided on assertion failure.</source>
          <target state="translated">이 패싯에서 &lt;code&gt;details&lt;/code&gt; 필드는 &quot;failed at test_file.t line 42&quot;를 재정의합니다. 어설 션 실패시 제공되는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="ccfbfd9001b68d4bb9123e9a75f5be994042b170" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt; , so it could be factored out:</source>
          <target state="translated">이 형식에서는 교대를 단순화하는 방법을 쉽게 알 수 있습니다. 대안 1, 2 및 4는 모두 &lt;code&gt;\d+&lt;/code&gt; 시작 하므로 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8872fe0affc69c9606769a8a65343eca2f4676ad" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt;, so it could be factored out:</source>
          <target state="translated">이 형식에서는 번갈아 가며 단순화하는 방법을 보는 것이 더 쉽습니다. 대안 1, 2 및 4는 모두 &lt;code&gt;\d+&lt;/code&gt; 시작 하므로 다음과 같이 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b24fb7d07c9db355f07769493a9de293acc8111" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a category of functions and the value is a short description of that category.</source>
          <target state="translated">이 해시에서 각 키는 기능 범주를 나타내며 값은 해당 범주에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3f56d8b8bdb8c26426f0b6660b2be0710caeb9c2" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is a short description of that function.</source>
          <target state="translated">이 해시에서 각 키는 함수를 나타내고 값은 해당 함수에 대한 간단한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="4112ec477caea48107dc76ca327ecc26b9559568" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is the category. The category can be a comma separated list.</source>
          <target state="translated">이 해시에서 각 키는 함수를 나타내며 값은 범주입니다. 범주는 쉼표로 구분 된 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b991cc90d42bab8c037a6310ce95c7fd23aada4" translate="yes" xml:space="preserve">
          <source>In this instance the &quot;Store&quot; and &quot;Fetch&quot; methods are encapsulated inside a &quot;Filter&quot; method.</source>
          <target state="translated">이 경우 &quot;Store&quot;및 &quot;Fetch&quot;메소드는 &quot;Filter&quot;메소드 안에 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="d35ad5c2c0618e945079ac0ca929cf4d613d24d9" translate="yes" xml:space="preserve">
          <source>In this library, the numbers are represented in base B = 10**N, where N is the largest possible value that does not cause overflow in the intermediate computations. The base B elements are stored in an array, with the least significant element stored in array element zero. There are no leading zero elements, except a single zero element when the number is zero.</source>
          <target state="translated">이 라이브러리에서 숫자는 기본 B = 10 ** N으로 표시되며, 여기서 N은 중간 계산에서 오버플로를 발생시키지 않는 가능한 가장 큰 값입니다. 기본 B 요소는 배열에 저장되며 최하위 요소는 배열 요소 0에 저장됩니다. 숫자가 0 일 때 단일 0 요소를 제외하고 선행 0 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df68cfd3648ab58a91a7f368ccaceffbf7d1f325" translate="yes" xml:space="preserve">
          <source>In this particular case we don't have to call</source>
          <target state="translated">이 특별한 경우에 우리는 전화 할 필요가 없습니다</target>
        </trans-unit>
        <trans-unit id="dad6a924b2e38abcfe4b4ffded7acf8266a85c31" translate="yes" xml:space="preserve">
          <source>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</source>
          <target state="translated">이 패스에서 우리가 방출해야 할 각 regop에 필요한 공간의 양을 계산하기 위해 입력 패턴이 구문 분석됩니다. 이 크기는 또한 프로그램에서 멀리뛰기가 필요한지 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41f31a4be766288871cf075eb0ef8be8f75f8e7b" translate="yes" xml:space="preserve">
          <source>In this pod section each line obeys the format</source>
          <target state="translated">이 포드 섹션에서 각 줄은 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="64cfb9e395c018a6592c08f321f44ebdc6f304df" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;'^'&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">이 정규식에서 첫 번째 최소 수량 자 &lt;code&gt;.*?&lt;/code&gt; 단어의 시작과 일치하도록 &lt;code&gt;'^'&lt;/code&gt; 앵커에 의해 제한되지 않기 때문에 빈 문자열 과 일치합니다. 그러나 여기에는 원칙 0이 적용됩니다. 전체 정규 표현식이 문자열의 시작 부분과 일치 할 수 있기 때문에</target>
        </trans-unit>
        <trans-unit id="2a40391b3aa03b91dc32950cbb01e23eafc7a333" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;^&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">이 정규 표현식에서 첫 번째 최소 수량화를 기대할 수 있습니다 &lt;code&gt;.*?&lt;/code&gt; 빈 문자열 과 일치해야합니다. 단어의 시작과 일치하도록 &lt;code&gt;^&lt;/code&gt; 앵커로 제한되지 않기 때문입니다 . 그러나 원칙 0이 여기에 적용됩니다. 전체 정규 표현식이 문자열의 시작 부분에서 일치 할 수 있기 때문에</target>
        </trans-unit>
        <trans-unit id="1677ca4d68d5b3cd757901e02552a2ca6071fc8c" translate="yes" xml:space="preserve">
          <source>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the &lt;code&gt;/g&lt;/code&gt; flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the &lt;code&gt;\s+&lt;/code&gt;, and the &lt;code&gt;$&lt;/code&gt; anchor can match to the absolute end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the &lt;code&gt;^\s+&lt;/code&gt; would remove all by itself:</source>
          <target state="translated">이 정규식에서 앵커는 대체보다 우선 순위가 낮기 때문에 문자열의 시작 또는 끝에서 대체가 일치합니다. 으로 &lt;code&gt;/g&lt;/code&gt; 은 모두를 얻을 수 있도록 플래그, 대체 모든 가능한 일치한다. 후행 줄 바꿈은 &lt;code&gt;\s+&lt;/code&gt; 와 일치 하고 &lt;code&gt;$&lt;/code&gt; 앵커는 문자열의 절대 끝과 일치 할 수 있으므로 줄 바꿈도 사라집니다. 줄 바꿈을 출력에 추가하면 &lt;code&gt;^\s+&lt;/code&gt; 가 모두 자동으로 제거 하는 &quot;공백&quot;(공백으로 구성됨) 줄을 유지하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="77b676e373d337a1558a3681668f6ee37714295f" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. This idea has several variations.</source>
          <target state="translated">이 성명에서, &lt;code&gt;World&lt;/code&gt; 정규식과입니다 &lt;code&gt;//&lt;/code&gt; 둘러싸 &lt;code&gt;/World/&lt;/code&gt; 일치하는 문자열을 검색 할 펄을 알려줍니다. 연산자 &lt;code&gt;=~&lt;/code&gt; 는 문자열을 정규식 일치와 연결하고 정규식이 일치하면 true를, 정규식이 일치하지 않으면 false를 생성합니다. 이 경우 &lt;code&gt;World&lt;/code&gt; 는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 의 두 번째 단어와 일치 하므로 표현이 참입니다. 이 아이디어에는 몇 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb6960dd1a14a1f651e7be335db315d0fa175d1d" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. This idea has several variations.</source>
          <target state="translated">이 문에서 &lt;code&gt;World&lt;/code&gt; 는 정규식이고 &lt;code&gt;//&lt;/code&gt; 둘러싸는 &lt;code&gt;/World/&lt;/code&gt; 는 Perl에게 일치하는 문자열을 검색하도록 지시합니다. 연산자 &lt;code&gt;=~&lt;/code&gt; 는 문자열을 정규식 일치와 연결하고 정규식이 일치하면 true 값을 생성하고 정규식이 일치하지 않으면 false를 생성합니다. 이 경우 &lt;code&gt;World&lt;/code&gt; 는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 의 두 번째 단어와 일치 하므로 표현식이 참입니다. 이 아이디어에는 여러 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c818981124c0efd397c772e8c5a5bccf099d60f4" translate="yes" xml:space="preserve">
          <source>In this way (as for perl's scalars) a pointer to a PerlIOBuf can be treated as a pointer to a PerlIOl.</source>
          <target state="translated">이런 식으로 (perl의 스칼라에서와 같이) PerlIOBuf에 대한 포인터는 PerlIOl에 대한 포인터로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c607bae4c1c842072097188930b7f5e712b730" translate="yes" xml:space="preserve">
          <source>In those 8 cases above, the value of EXPR is used directly as a boolean, so no smartmatching is done. You may think of &lt;code&gt;when&lt;/code&gt; as a smartsmartmatch.</source>
          <target state="translated">위의 8 가지 경우에 EXPR 값은 부울로 직접 사용되므로 스마트 매칭이 수행되지 않습니다. &lt;code&gt;when&lt;/code&gt; 스마트 스마트 매크로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9186d74e76b80422b13adb44366ed78c8afac4f7" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">이러한 경우 Filter :: Simple을로드 하는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문에 필터링 서브 루틴 및 종료 자 스펙을 직접 추가하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="db9ccecefd39facec4b439c7bf015dafd9285f67" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;use&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">이러한 경우 Filter :: Simple을로드 하는 &lt;code&gt;use&lt;/code&gt; 문에 직접 필터링 서브 루틴 및 종결 자 사양을 추가하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="95167fe0e36a49f5080da73352ed44710a152f26" translate="yes" xml:space="preserve">
          <source>In those cases, you would turn off &lt;code&gt;strict 'refs'&lt;/code&gt; temporarily so you can play around with the symbol table. For example:</source>
          <target state="translated">이러한 경우에는 &lt;code&gt;strict 'refs'&lt;/code&gt; 일시적으로 해제 하여 기호 테이블을 가지고 놀 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6200c4c82d6daee49dcd17953c7919b7352b65f" translate="yes" xml:space="preserve">
          <source>In time-critical applications, it is worthwhile to avoid splitting into more fields than necessary. Thus, when assigning to a list, if LIMIT is omitted (or zero), then LIMIT is treated as though it were one larger than the number of variables in the list; for the following, LIMIT is implicitly 3:</source>
          <target state="translated">시간이 중요한 응용 분야에서는 필요 이상으로 더 많은 필드로 분할하지 않는 것이 좋습니다. 따라서리스트에 지정할 때 LIMIT가 생략 된 경우 (또는 0), LIMIT는리스트에있는 변수의 수보다 하나 더 큰 것으로 취급됩니다. 다음의 경우 LIMIT는 암시 적으로 3입니다.</target>
        </trans-unit>
        <trans-unit id="d371abf0abc6f35041f85b45c9387a28fef727f3" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into http://whatever/Foo%3a%3aBar, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;https://metacpan.org/pod/&quot;.</source>
          <target state="translated">닝 &lt;a href=&quot;Foo::Bar&quot;&gt;푸 :: 바&lt;/a&gt; HTTP로 : // 어떤 / 푸 % 3A % 3aBar은 &quot;푸 % 3A % 3aBar&quot;전에 넣어 것. 기본값은 &quot;https://metacpan.org/pod/&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="61aec1693f3cca77d878f9993860b197db04ab69" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http://whatever/Foo%3a%3aBar&lt;/a&gt;, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;?&quot;.</source>
          <target state="translated">회전 &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo :: Bar&lt;/a&gt; 로 &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;에 http : // 어떤 / 푸 % 3A % 3aBar&lt;/a&gt; 은 &quot;푸 % 3A % 3aBar&quot;전에 넣어 것. 기본값은 &quot; &lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt; ?&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2f2439be782d8b7a999e11dc7c3353fae2805425" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;a href=&quot;http://man.he.net/man5/crontab&quot;&gt;crontab(5)&lt;/a&gt;&lt;/code&gt; into http://whatever/man/1/crontab, what to put before the &quot;1/crontab&quot;. The default value is &quot;http://man.he.net/man&quot;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://man.he.net/man5/crontab&quot;&gt;crontab(5)&lt;/a&gt;&lt;/code&gt; 을 http : // whatever / man / 1 / crontab으로 바꿀 때 &quot;1 / crontab&quot;앞에 무엇을 넣을까요? 기본값은 &quot;http://man.he.net/man&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="fe66d5d405c8ef8a7eac08fc91eff0a843fd6e3f" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; into &lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http://whatever/man/1/crontab&lt;/a&gt;, what to put before the &quot;1/crontab&quot;. The default value is &quot;&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;&quot;.</source>
          <target state="translated">선회 &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; 에&lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt; // 어떤 / 사람 / 1 / crontab을 : HTTP&lt;/a&gt; 은 &quot;1 / crontab을&quot;전에 넣어 무엇을,. 기본값은 &quot; &lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="43281809d91fd31f1807b9436030386775e6651b" translate="yes" xml:space="preserve">
          <source>In typical VMS style, only the first letter of the value of this logical name is actually checked in a case insensitive mode, and it is considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</source>
          <target state="translated">일반적인 VMS 스타일에서는이 논리 이름 값의 첫 문자 만 실제로 대소 문자를 구분하지 않는 모드에서 검사되며 값이 &quot;T&quot;, &quot;1&quot;또는 &quot;E&quot;인 경우 활성화 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="573e7b50018345b4e76799c05af940dc27c74f2b" translate="yes" xml:space="preserve">
          <source>In ualarm() you tried to use number of microseconds or interval (also in microseconds) more than 1_000_000 and setitimer() is not available in your system to emulate that case.</source>
          <target state="translated">ualarm ()에서 1_000_000보다 큰 수의 마이크로 초 또는 간격 (마이크로 초)을 사용하려고 시도했으며 시스템에서 setitimer ()를 사용하여 해당 사례를 에뮬레이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f02423b74e4b6df478931aa6ac2f4633241db988" translate="yes" xml:space="preserve">
          <source>In verbose mode, a warning is printed if shadows are found (i.e., more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">상세 모드에서 그림자가 발견되면 경고가 인쇄됩니다 (예 : 동일한 POD 이름을 가진 둘 이상의 POD 파일이 발견되면</target>
        </trans-unit>
        <trans-unit id="8a3ebab20ae57eb43347721d9e5a409b1ce17a43" translate="yes" xml:space="preserve">
          <source>In version 2.37 the first argument to the callback function was changed from string to object. This was done to make room for extensions and more detailed control. The object stringifies to the option name so this change should not introduce compatibility problems.</source>
          <target state="translated">버전 2.37에서는 콜백 함수의 첫 번째 인수가 문자열에서 객체로 변경되었습니다. 이것은 확장 및 더 자세한 제어를위한 공간을 만들기 위해 수행되었습니다. 객체는 옵션 이름으로 문자열 화되므로이 변경으로 인해 호환성 문제가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="880a8be23ba2ee8779ff63078e49dfc5216b39eb" translate="yes" xml:space="preserve">
          <source>In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:</source>
          <target state="translated">버전 5.000 및 5.001에서는 위의 행을 사용하는 대신 다음 행을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1cc474b32c69cb459158c3dcaef8e4f4b651d874" translate="yes" xml:space="preserve">
          <source>In versions 5.6 and later, Perl won't recompile the regular expression if the variable hasn't changed, so you probably don't need the &lt;code&gt;/o&lt;/code&gt; option. It doesn't hurt, but it doesn't help either. If you want any version of Perl to compile the regular expression only once even if the variable changes (thus, only using its initial value), you still need the &lt;code&gt;/o&lt;/code&gt;.</source>
          <target state="translated">버전 5.6 이상에서 변수가 변경되지 않은 경우 Perl은 정규식을 다시 컴파일하지 않으므로 &lt;code&gt;/o&lt;/code&gt; 옵션이 필요하지 않습니다 . 아프지는 않지만 도움이되지 않습니다. 변수가 변경 되더라도 (따라서 초기 값만 사용하여) Perl 버전에서 정규 표현식을 한 번만 컴파일하도록하려면 &lt;code&gt;/o&lt;/code&gt; 가 여전히 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cb448bdd461c35050663768e40f737fb69d01266" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly. You need to change the &quot;use lib&quot; line to read:</source>
          <target state="translated">감마 버전 이전의 5.002 버전에서는 예제 1의 테스트 스크립트가 제대로 작동하지 않습니다. &quot;lib 사용&quot;줄을 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="47fb4d46b782f60712d6e476480e232acaeda83d" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs. This means that you cannot say &quot;make test&quot; to run the test script. You will need to add the following line before the &quot;use extension&quot; statement:</source>
          <target state="translated">5.002b1h 이전 5.002 버전에서는 test.pl 파일이 h2xs에 의해 자동으로 작성되지 않았습니다. 즉, 테스트 스크립트를 실행하기 위해 &quot;make test&quot;라고 말할 수 없습니다. &quot;확장자 사용&quot;문 앞에 다음 줄을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac1080be96df0c995d03afc96266140d8a96249c" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt; .</source>
          <target state="translated">5.004 이전의 Perl 버전에서는 &lt;code&gt;I18N::Collate&lt;/code&gt; 라이브러리 모듈을 사용하여 로케일 당 데이터 정렬이 가능했습니다 . 이 모듈은 이제 약간 더 이상 사용되지 않으며 새로운 응용 프로그램에서는 피해야합니다. &lt;code&gt;LC_COLLATE&lt;/code&gt; 의 기능은 이제 펄 핵심 언어에 통합되어 있습니다 : 하나는 완전히 일반적으로 로케일 고유의 스칼라 데이터를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , 그래서의 스칼라 참조와 저글링에 대한 필요가 더 이상 존재 &lt;code&gt;I18N::Collate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643eb53656f3778cf6551882e9802bdd3c4faa37" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;use locale&lt;/code&gt;, so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt;.</source>
          <target state="translated">5.004 이전의 Perl 버전에서는 &lt;code&gt;I18N::Collate&lt;/code&gt; 라이브러리 모듈을 사용하여 로케일 별 데이터 정렬이 가능했습니다 . 이 모듈은 이제 약간 구식이며 새 응용 프로그램에서는 사용하지 않아야합니다. &lt;code&gt;LC_COLLATE&lt;/code&gt; 의 기능은 이제 펄 핵심 언어에 통합되지 않은 : 하나는 완전히 일반적으로 로케일 고유의 스칼라 데이터를 사용할 수 있습니다 &lt;code&gt;use locale&lt;/code&gt; , 그래서의 스칼라 참조와 저글링에 대한 필요가 더 이상 존재 &lt;code&gt;I18N::Collate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0768c48f4e49e936d5436a0c1bb338303666576" translate="yes" xml:space="preserve">
          <source>In void context no args are returned, so it's more efficient to skip calling &lt;code&gt;leave_adjust_stacks()&lt;/code&gt;. Also in void context, a &lt;code&gt;nextstate&lt;/code&gt; op is likely to be imminently called which will do a &lt;code&gt;FREETMPS&lt;/code&gt;, so there's no need to do that either.</source>
          <target state="translated">void 컨텍스트에서는 인수가 반환되지 않으므로 &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; 호출을 건너 뛰는 것이 더 효율적 입니다. 또한 무효 컨텍스트에서 &lt;code&gt;nextstate&lt;/code&gt; 영업 이익은 가능성이 절박 할 것이다라고하는 것입니다 &lt;code&gt;FREETMPS&lt;/code&gt; 을 그래서 그 중 하나를 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48a813c6d738225545b449a151bcdc156058f932" translate="yes" xml:space="preserve">
          <source>In your XS code, when you define an argument with a C type or when you are using a &lt;code&gt;CODE:&lt;/code&gt; and an &lt;code&gt;OUTPUT:&lt;/code&gt; section together with a C return type of your XSUB, it'll be the typemapping mechanism that makes this easy.</source>
          <target state="translated">XS 코드에서 C 유형으로 인수를 정의하거나 &lt;code&gt;CODE:&lt;/code&gt; 사용하는 경우 : 및 &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션을 XSUB의 C 리턴 유형과 함께 사용하는 경우이를 용이하게하는 유형 맵핑 메커니즘이됩니다.</target>
        </trans-unit>
        <trans-unit id="9357861451f0b2f036dafa4da40d9ece429bcae6" translate="yes" xml:space="preserve">
          <source>In-line functions that are in headers that are accessible to XS code need to be able to compile without warnings with commonly used extra compilation flags, such as gcc's &lt;code&gt;-Wswitch-default&lt;/code&gt; which warns whenever a switch statement does not have a &quot;default&quot; case. The use of these extra flags is to catch potential problems in legal C code, and is often used by Perl aggregators, such as Linux distributors.</source>
          <target state="translated">XS 코드에 액세스 할 수있는 헤더에있는 인라인 함수는 gcc와 같이 일반적으로 사용되는 추가 컴파일 플래그를 사용하여 경고없이 컴파일 할 수 있어야합니다. &lt;code&gt;-Wswitch-default&lt;/code&gt; switch 문에 &quot;default&quot;가없는 경우 경고하는 를 . 이러한 추가 플래그를 사용하면 합법적 인 C 코드에서 잠재적 인 문제를 포착 할 수 있으며 Linux 배포자와 같은 Perl 어 그리 게이터가 종종 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fac261b8677bb294fa8e76c7f44d73a02d84ebb" translate="yes" xml:space="preserve">
          <source>In-memory IO, scalar IO</source>
          <target state="translated">인 메모리 IO, 스칼라 IO</target>
        </trans-unit>
        <trans-unit id="103334731df65dd74f84e4f87f0649c004460a4d" translate="yes" xml:space="preserve">
          <source>In-place sort an array of SV pointers with the given comparison routine, with various SORTf_* flag options.</source>
          <target state="translated">다양한 SORTf_ * 플래그 옵션을 사용하여 주어진 비교 루틴을 사용하여 SV 포인터 배열을 내부 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="5f2427ea8046d416f8b78bbc872c1a8336130b5f" translate="yes" xml:space="preserve">
          <source>In-place sort an array of SV pointers with the given comparison routine.</source>
          <target state="translated">주어진 비교 루틴을 사용하여 SV 포인터 배열을 내부 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="022b1dbe77251c047456c4feb5d0409e122d6848" translate="yes" xml:space="preserve">
          <source>In-place upgrade of the supplied SV to a version object.</source>
          <target state="translated">제공된 SV를 버전 객체로 전체 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="1930e5219f1534978185f9ba376df01339047154" translate="yes" xml:space="preserve">
          <source>Inappropriate documentation</source>
          <target state="translated">부적절한 문서</target>
        </trans-unit>
        <trans-unit id="72a5f6c42a6c39ea891ecb24d22128fd281d0e18" translate="yes" xml:space="preserve">
          <source>Inc</source>
          <target state="translated">Inc</target>
        </trans-unit>
        <trans-unit id="70b0bede26554e7ae42316f8d3fd932a7cdc066c" translate="yes" xml:space="preserve">
          <source>Incidentally, note that each class's &lt;code&gt;%Lexicon&lt;/code&gt; inherits-and-extends the lexicons in its superclasses. This is not because these are special hashes</source>
          <target state="translated">또한 각 클래스의 &lt;code&gt;%Lexicon&lt;/code&gt; 은 수퍼 클래스에서 상속하고 확장합니다. 이것은 특별한 해시이기 때문이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="56c1bcd0fe0c175606142de66e47a332c19454ad" translate="yes" xml:space="preserve">
          <source>Incidentally, note that there's no easy way to express a data paragraph starting with something that looks like a command. Consider:</source>
          <target state="translated">또한 명령처럼 보이는 것으로 시작하여 데이터 단락을 표현하는 쉬운 방법은 없습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="f4d888a4b6d2de9b573a52498056bdfd61c34932" translate="yes" xml:space="preserve">
          <source>Incidentally, note that we do not distinguish between these syntaxes:</source>
          <target state="translated">참고로 다음 구문을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af23144864617d68a82ad427e6d70d917f0fe977" translate="yes" xml:space="preserve">
          <source>Incidentally, note the variance in the result values between the two examples; this is typical of benchmarking. If this were a real benchmark, you would probably want to run a lot more iterations.</source>
          <target state="translated">또한 두 예제 사이의 결과 값의 차이에 유의하십시오. 이것은 벤치마킹의 전형입니다. 이것이 실제 벤치 마크라면 더 많은 반복을 실행하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="11c54a59d8a9668fa20146e40c46116f6e7acc35" translate="yes" xml:space="preserve">
          <source>Include</source>
          <target state="translated">Include</target>
        </trans-unit>
        <trans-unit id="7f36757a0ff9e21d096da46852dca59689517203" translate="yes" xml:space="preserve">
          <source>Include /usr/ccs/bin/ in your PATH.</source>
          <target state="translated">PATH에 / usr / ccs / bin /을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="5f7213221d8f17a14d6c7b8882fe3f1c79362499" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile (default behaviour).</source>
          <target state="translated">파일에 POD 오류가있는 경우 (기본 동작) 출력 파일에 &quot;POD ERRORS&quot;섹션을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1f63d3adcc78e2a751c9de88b5a592a5d6f05fed" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile. This section is included by default.</source>
          <target state="translated">파일에 POD 오류가있는 경우 출력 파일에 &quot;POD ERRORS&quot;섹션을 포함하십시오. 이 섹션은 기본적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1be836334b7992bf64bdd66feaf2cdd670e862a6" translate="yes" xml:space="preserve">
          <source>Include a single css source in the header:</source>
          <target state="translated">헤더에 단일 CSS 소스를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="82da13ca7b8da7d4d7bd6d25f32b5e4df5ab790d" translate="yes" xml:space="preserve">
          <source>Include a single javascript source:</source>
          <target state="translated">단일 자바 스크립트 소스를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="dacfcf246f0e94f511558260bbdd933b10ed8af6" translate="yes" xml:space="preserve">
          <source>Include any non-POD text from the input file in the output as well. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">입력 파일의 비 POD 텍스트도 출력에 포함하십시오. POD를 렌더링하고 코드를 그대로 유지 한 상태에서 POD 블록으로 문서화 된 코드를 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b3aefa9c8a28918cfdeb274cb63c2499f4f13ccf" translate="yes" xml:space="preserve">
          <source>Include code for safely storing static data in the .xs file. Extensions that do no make use of static data can ignore this option.</source>
          <target state="translated">정적 데이터를 .xs 파일에 안전하게 저장하기위한 코드를 포함합니다. 정적 데이터를 사용하지 않는 확장은이 옵션을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73830e720872f365cfd2f2dbd3697deb29a3d139" translate="yes" xml:space="preserve">
          <source>Include file dirs eg: &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</source>
          <target state="translated">파일 디렉토리 포함 예 : &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a46c6bf1682df8e2b9b455d4e2e63979aa173ed" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.17 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">&lt;a href=&quot;Module::Build&quot;&gt;모듈에&lt;/a&gt; 연결하는 대신 Module :: Build 0.17 의 유효한 라이선스 목록을 포함 하고 게시 당시 버전을 반영하는 텍스트 및 링크에 대한 사소한 업데이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="233868d9365dc18e1add2e1bf54ab892c2b257e4" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.18 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">&lt;a href=&quot;Module::Build&quot;&gt;모듈에&lt;/a&gt; 연결하는 대신 Module :: Build 0.18 의 유효한 라이선스 목록을 포함 하고, 게시 당시 버전을 반영하는 텍스트 및 링크에 대한 사소한 업데이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="40111b47c700ae2f5642d997d209744f7e18b0e6" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2611 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">&lt;a href=&quot;Module::Build&quot;&gt;모듈에&lt;/a&gt; 연결하는 대신 Module :: Build 0.2611 의 유효한 라이선스 목록을 포함 하고, 게시 당시 버전을 반영하는 텍스트 및 링크에 대한 사소한 업데이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="758b345104d352569d53c61623a248e076a8b20f" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2805 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">&lt;a href=&quot;Module::Build&quot;&gt;모듈에&lt;/a&gt; 연결하는 대신 Module :: Build 0.2805 의 유효한 라이선스 목록을 포함 하고, 발행 당시 버전을 반영하는 텍스트 및 링크에 대한 사소한 업데이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f157fc1eac4aa33c6e19320dad9c45ca1ddace2f" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2807 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">&lt;a href=&quot;Module::Build&quot;&gt;모듈에&lt;/a&gt; 연결하는 대신 Module :: Build 0.2807 의 유효한 라이선스 목록을 포함 하고, 게시 당시 버전을 반영하는 텍스트 및 링크에 대한 사소한 업데이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ca280b8dc9676e12b899416fb9b80aa66ff24f11" translate="yes" xml:space="preserve">
          <source>Include recommended modules?</source>
          <target state="translated">권장 모듈을 포함 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="1acbf3f254752a10abcbbc0af380ce1701ab1294" translate="yes" xml:space="preserve">
          <source>Include suggested modules?</source>
          <target state="translated">제안 된 모듈을 포함 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="bf7dea1bf3fcc056eca7b649b6605fbf3217e27a" translate="yes" xml:space="preserve">
          <source>Include tests with your module</source>
          <target state="translated">모듈에 테스트 포함</target>
        </trans-unit>
        <trans-unit id="44cae264b95e40204b6c9817100d817393044faa" translate="yes" xml:space="preserve">
          <source>Include the `nstore' option to have the &lt;code&gt;Storable&lt;/code&gt; database written in `network order'. (See &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; for more details about this.)</source>
          <target state="translated">은`nstore '를 가지고있는 옵션을 포함 &lt;code&gt;Storable&lt;/code&gt; `네트워크의 순서로 기입 데이터베이스를'. (참조 &lt;a href=&quot;storable&quot;&gt;저장 가능&lt;/a&gt; 이에 대한 자세한 내용은.)</target>
        </trans-unit>
        <trans-unit id="428c39cb578db360bfc5803c8ec5f4e60b61ea16" translate="yes" xml:space="preserve">
          <source>Include the code from the &lt;b&gt;.h&lt;/b&gt; file as a comment in the &lt;b&gt;.ph&lt;/b&gt; file. This is primarily used for debugging</source>
          <target state="translated">&lt;b&gt;.h&lt;/b&gt; 파일 의 코드를 &lt;b&gt;.ph&lt;/b&gt; 의 주석으로 포함&lt;b&gt;&lt;/b&gt; 파일 하십시오. 이것은 주로 디버깅에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="5318c44a39f5f77944d683ed2f0ae1a7ab04539f" translate="yes" xml:space="preserve">
          <source>Include the following line in the XS section of your XS file: (don't break the line)</source>
          <target state="translated">XS 파일의 XS 섹션에 다음 줄을 포함하십시오 : (줄을 끊지 마십시오)</target>
        </trans-unit>
        <trans-unit id="eb7645ad7831d7d6fd6181e27396b77155390482" translate="yes" xml:space="preserve">
          <source>Include the main program in the output, even if subroutines were also specified. This rendering is normally suppressed when a subroutine name or reference is given.</source>
          <target state="translated">서브 루틴도 지정된 경우에도 기본 프로그램을 출력에 포함하십시오. 서브 루틴 이름 또는 참조가 제공되면이 렌더링은 일반적으로 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="39d690d519d42e4c1222e708f1a7882603060ecf" translate="yes" xml:space="preserve">
          <source>Include verbose configuration data in the report.</source>
          <target state="translated">보고서에 자세한 구성 데이터를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="520eeda3e72b576dbaab99011b2e61a86a377e9b" translate="yes" xml:space="preserve">
          <source>Included 'name', 'version', 'license', 'distribution_type', 'requires', 'recommends', 'build_requires', 'conflicts', 'dynamic_config', 'generated_by'</source>
          <target state="translated">'name', 'version', 'license', 'distribution_type', 'requires', 'recommends', 'build_requires', 'conflicts', 'dynamic_config', 'generated_by'포함</target>
        </trans-unit>
        <trans-unit id="7af107d55e07795d28db937bc5e2e6b3d1acdce5" translate="yes" xml:space="preserve">
          <source>Included in the official Perl distribution, as in a standard module, a standard tool, or a standard Perl &lt;b&gt;manpage&lt;/b&gt;.</source>
          <target state="translated">표준 모듈, 표준 도구 또는 표준 Perl &lt;b&gt;맨 페이지&lt;/b&gt; 와 같이 공식 Perl 배포에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c36d5529b0434732ae50f5c4cfddc9ab638ebdc" translate="yes" xml:space="preserve">
          <source>Included recommended modules?</source>
          <target state="translated">권장 모듈이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="2d5cfde693773293f9c93c5da459379d1390e74a" translate="yes" xml:space="preserve">
          <source>Included suggested modules?</source>
          <target state="translated">제안 된 모듈이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="fd1eb7c27a0ef162dc3c74b06bcd124d36810aee" translate="yes" xml:space="preserve">
          <source>Included with the standard Cygwin netrelease is the inetutils package which includes libutil.a.</source>
          <target state="translated">표준 Cygwin netrelease에는 libutil.a를 포함하는 inetutils 패키지가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d99a8e54557c65faa85e976aa75857ac0de5775" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;FSCTL_SET_REPARSE_POINT&lt;/code&gt;, &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt;, &lt;code&gt;FSCTL_DELETE_REPARSE_POINT&lt;/code&gt;.</source>
          <target state="translated">포함 &lt;code&gt;FSCTL_SET_REPARSE_POINT&lt;/code&gt; , &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt; , &lt;code&gt;FSCTL_DELETE_REPARSE_POINT&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="5cb2c4473fcc6d850527caa45adfc81f1b873a15" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS_EX&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_DRIVE_GEOMETRY&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_DRIVE_LAYOUT&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_DATA&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_RESET&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_STRUCTURE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_IS_WRITABLE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_LOGGING&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_PERFORMANCE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REASSIGN_BLOCKS&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REQUEST_DATA&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REQUEST_STRUCTURE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt;, and &lt;code&gt;IOCTL_DISK_VERIFY&lt;/code&gt;.</source>
          <target state="translated">포함 &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS_EX&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_GET_DRIVE_GEOMETRY&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_GET_DRIVE_LAYOUT&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_HISTOGRAM_DATA&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_HISTOGRAM_RESET&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_HISTOGRAM_STRUCTURE&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_IS_WRITABLE&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_LOGGING&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_PERFORMANCE&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_REASSIGN_BLOCKS&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_REQUEST_DATA&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_REQUEST_STRUCTURE&lt;/code&gt; 는 , &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt; , &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; 및 &lt;code&gt;IOCTL_DISK_VERIFY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62deb9b6c9960c6cf27bcef72a0cb725d958b5ee" translate="yes" xml:space="preserve">
          <source>Includes the closing tag of &amp;lt;/title&amp;gt; and through the rest of the head till the opening of the body</source>
          <target state="translated">&amp;lt;/ title&amp;gt;의 닫는 태그를 포함하고 본문이 열릴 때까지 나머지 머리를 통해</target>
        </trans-unit>
        <trans-unit id="33e824f5c1da8228b52bc56b109b9797a650528d" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">라이브러리 모듈을 포함하는 것은 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 과 함께 더 잘 수행되며 연산자가 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 자동 오류 검사를 수행하고 문제가있는 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9abdbb8c9871ea5d015e2e60e10f71a6f7c5bffa" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">라이브러리 모듈의 포함은 더 잘 이루어집니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 도 자동 오류 검사를하고 문제가있을 경우 예외를 발생 연산자를.</target>
        </trans-unit>
        <trans-unit id="fc7468d33bdeb93695da594528f2501435fe4708" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">라이브러리 모듈의 포함은 더 잘 이루어집니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 도 자동 오류 검사를하고 문제가있을 경우 예외를 발생 연산자를.</target>
        </trans-unit>
        <trans-unit id="d536a03f0c3143f6e1f810634a3c64f1cee1463a" translate="yes" xml:space="preserve">
          <source>Incompatibility with AIX Toolbox lib gdbm</source>
          <target state="translated">AIX Toolbox lib gdbm과의 비 호환성</target>
        </trans-unit>
        <trans-unit id="e8ee16b208edc6448df6fc055ab0018eee84b8c5" translate="yes" xml:space="preserve">
          <source>Incomplete expression within '(?[ ])' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식의 '(? [])'내의 불완전한 표현; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="b53d2a95e2a16580ce48c32385151c299f727d6f" translate="yes" xml:space="preserve">
          <source>Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'</source>
          <target state="translated">클래스 '% s'의 C3 병합 중 계층이 일치하지 않습니다. 상위 '% s'에서 병합하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="e53b7251c10e4fb16639ff0eb74e48d3fdb255f3" translate="yes" xml:space="preserve">
          <source>Increment OBJ by one.</source>
          <target state="translated">OBJ를 하나씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a3b00269821fb57d8ea2de1fc824b0f5f9a60902" translate="yes" xml:space="preserve">
          <source>Increment an SV's reference count. Use the &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SV의 참조 카운트를 증가시킵니다. 사용 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 대신 랩퍼.</target>
        </trans-unit>
        <trans-unit id="0e74e496959812fcc073992ca705206317cb9544" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; . The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; 의 참조 횟수를 증가시킵니다 . &lt;code&gt;refcounted_he&lt;/code&gt; 에 대한 포인터 도 반환됩니다. 이 함수에 널 포인터를 전달하는 것이 안전합니다. 조치가 발생하지 않으며 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9858409e70adfac3f5375aa7bf5fb0c442d68e13" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt;. The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; 의 참조 횟수를 늘 립니다. &lt;code&gt;refcounted_he&lt;/code&gt; 에 대한 포인터 도 반환됩니다. 이 함수에 널 포인터를 전달하는 것이 안전합니다. 조치가 발생하지 않고 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e3802b6aa343742e73ae6047c081fca9075a08d1" translate="yes" xml:space="preserve">
          <source>Increment the version number for every change, no matter how small</source>
          <target state="translated">아무리 작아도 변경 될 때마다 버전 번호를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="2478eca32c2a75c27f5473c45c519262b31bc3ab" translate="yes" xml:space="preserve">
          <source>Increments $x by 1 and returns the result.</source>
          <target state="translated">$ x를 1 씩 증가시키고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c98c7bfa60bc9d7d9626649411d920868a3e57d" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt; , which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; 을 증가 시켜 모든 패키지에서 메소드 캐싱을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="bef0acad6c664dfddc6d4ee1b5ec03b4981c74c9" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt;, which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; 을 증가 시켜 모든 패키지에서 메소드 캐싱을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="3272c368109726f88d497737f134b46e95de8369" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the given SV, returning the SV.</source>
          <target state="translated">주어진 SV의 참조 카운트를 증가시켜 SV를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3fb59bb686d8260401f92a3aa6f2bbde8cfdc66" translate="yes" xml:space="preserve">
          <source>Indeed, a negative real number can be noted &lt;code&gt;[x,pi]&lt;/code&gt; (the modulus</source>
          <target state="translated">실제로 음의 실수는 &lt;code&gt;[x,pi]&lt;/code&gt; (모듈러스</target>
        </trans-unit>
        <trans-unit id="a04774d4b73d320e20f71b059e1b914a71747c31" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt; ), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">실제로주기를 종료하려면 $ cnt가 false가되어야합니다. 그러나 위조를 검사 하는 연산자 &lt;code&gt;bool&lt;/code&gt; 이 오버로드되고 (이번 오버로드 된 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 통해 ) 긴 문자열을 리턴하므로 &lt;code&gt;symbolic&lt;/code&gt; 유형의 모든 오브젝트 가 모두 참입니다. 이를 극복하려면 객체를 0과 비교할 수있는 방법이 필요합니다. 실제로 숫자 변환 루틴을 작성하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="35950a01017cb2dc9bdf8ca69f4b06c266fec7af" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt;), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">실제로주기를 종료하려면 $ cnt가 거짓이되어야합니다. 그러나 허위 확인을위한 &lt;code&gt;bool&lt;/code&gt; 연산자 는 오버로드되고 (이번에는 오버로드 된 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 통해 ) 긴 문자열을 반환하므로 &lt;code&gt;symbolic&lt;/code&gt; 유형의 모든 객체 가 참입니다. 이를 극복하려면 객체를 0과 비교하는 방법이 필요합니다. 사실 숫자 변환 루틴을 작성하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="62ba8e1b3397c92c36fc4b8d835f19b0c882946b" translate="yes" xml:space="preserve">
          <source>Indent lines by multiples of</source>
          <target state="translated">여러 줄로 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="af112fcfab59a5128ecdee5791e9c1c13e552da5" translate="yes" xml:space="preserve">
          <source>Indentation on line %d of here-doc doesn't match delimiter</source>
          <target state="translated">here-doc의 % d 행에있는 들여 쓰기가 구분 기호와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bc3818470788f955b725157028fb28b522ca6be" translate="yes" xml:space="preserve">
          <source>Indented Here-docs</source>
          <target state="translated">여기 들여 쓰기 문서</target>
        </trans-unit>
        <trans-unit id="62114f3245956b96ef644ac166335fb4a4e9a90b" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">해시 함수, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반환 항목에 해시 당 무작위 순서 로 사용되는 시드에 관계없이 . 삽입으로 해시를 수정하면 해당 해시의 반복 ​​순서가 변경됩니다. 이 동작은 &lt;a href=&quot;hash/util&quot;&gt;Hash :: Util의 &lt;/a&gt; &lt;code&gt;hash_traversal_mask()&lt;/code&gt; 를 사용하거나 PERL_PERTURB_KEYS 환경 변수 를 사용하여 재정의 할 수 있습니다 ( &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun의 PERL_PERTURB_KEYS&lt;/a&gt; 참조) . 이 기능은 저장된 실제 순서가 아니라 키의 &quot;표시&quot;순서를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e0d3b18e6e5a02cb47428995e30bd3cf0aea8164" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;each&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;Hash::Util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">해시 함수, &lt;code&gt;keys&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 및 &lt;code&gt;each&lt;/code&gt; 반환 항목에 사용되는 시드에 관계없이 해시 별 무작위 순서로 반환됩니다. 삽입하여 해시를 수정하면 해당 해시의 반복 ​​순서가 변경됩니다. 이 동작은 &lt;a href=&quot;Hash::Util&quot;&gt;Hash :: Util&lt;/a&gt; 에서 &lt;code&gt;hash_traversal_mask()&lt;/code&gt; 를 사용하거나 PERL_PERTURB_KEYS 환경 변수 를 사용하여 재정의 할 수 있습니다 . &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun의 &quot;PERL_PERTURB_KEYS&quot;를&lt;/a&gt; 참조하십시오 . 이 기능은 키가 저장된 실제 순서가 아니라 키의 &quot;표시되는&quot;순서를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="074fa110a121b41d1fc8547d15dc9f9c647ba94b" translate="yes" xml:space="preserve">
          <source>Independent subexpressions</source>
          <target state="translated">독립 하위 식</target>
        </trans-unit>
        <trans-unit id="af34ac32829575a31a5420b259a403615ce25ff8" translate="yes" xml:space="preserve">
          <source>Index.txt</source>
          <target state="translated">Index.txt</target>
        </trans-unit>
        <trans-unit id="f095033a2da35066ce69235bfd888bf108da82db" translate="yes" xml:space="preserve">
          <source>Index/Value Array Slices</source>
          <target state="translated">인덱스 / 값 배열 슬라이스</target>
        </trans-unit>
        <trans-unit id="ea194faeed183e57e74609dce9cd3c08f293d1f1" translate="yes" xml:space="preserve">
          <source>Indexing distributions a la PAUSE</source>
          <target state="translated">PAUSE로 배포 색인 생성</target>
        </trans-unit>
        <trans-unit id="967ce367d89dccc133d71049f1197d29561b3726" translate="yes" xml:space="preserve">
          <source>India</source>
          <target state="translated">India</target>
        </trans-unit>
        <trans-unit id="9376bb53130ade1b5bef94ae526efe4afa9ba571" translate="yes" xml:space="preserve">
          <source>India Pale Ale. Also the International Phonetic Alphabet, the standard alphabet used for phonetic notation worldwide. Draws heavily on Unicode, including many combining characters.</source>
          <target state="translated">인도 창백한 에일. 또한 전 세계의 음성 표기법에 사용되는 표준 알파벳 인 International Phonetic Alphabet도 있습니다. 많은 결합 문자를 포함하여 유니 코드를 많이 그립니다.</target>
        </trans-unit>
        <trans-unit id="5d00be2150a7a2970ecf83338644746fe69f68bc" translate="yes" xml:space="preserve">
          <source>Indiana</source>
          <target state="translated">Indiana</target>
        </trans-unit>
        <trans-unit id="7939b23cc59e5fecb713c284b9570bf5c06bc4a8" translate="yes" xml:space="preserve">
          <source>Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List :: Util이 C 컴파일러로 컴파일되었는지 표시</target>
        </trans-unit>
        <trans-unit id="257f1f56edc7d22d13ca3e932a232d7b1ce1cb6a" translate="yes" xml:space="preserve">
          <source>Indicates how many bits are produced by the function used to generate normalized random numbers.</source>
          <target state="translated">정규화 된 난수를 생성하는 데 사용되는 함수에 의해 생성 된 비트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f59dd948b843172b40aa09dfd5bd724d214b6e0d" translate="yes" xml:space="preserve">
          <source>Indicates if SSL support is available. When called as a class object, it checks for the correct version of &lt;a href=&quot;Net::SSLeay&quot;&gt;Net::SSLeay&lt;/a&gt; and &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;. When called as an object methods, if &lt;code&gt;SSL_verify&lt;/code&gt; is true or if &lt;code&gt;SSL_verify_mode&lt;/code&gt; is set in &lt;code&gt;SSL_options&lt;/code&gt;, it checks that a CA file is available.</source>
          <target state="translated">SSL 지원을 사용할 수 있는지 여부를 나타냅니다. 클래스 객체로 호출되면 &lt;a href=&quot;Net::SSLeay&quot;&gt;Net :: SSLeay&lt;/a&gt; 및 &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL&lt;/a&gt; 의 올바른 버전을 확인 합니다 . 객체 메서드로 호출 될 때 &lt;code&gt;SSL_verify&lt;/code&gt; 가 true이거나 &lt;code&gt;SSL_verify_mode&lt;/code&gt; 가 설정되어 &lt;code&gt;SSL_options&lt;/code&gt; CA 파일을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ecc34d4e90099631370d69b93d5e19f62c32c10d" translate="yes" xml:space="preserve">
          <source>Indicates if a connection to a peer is being kept alive, per the &lt;code&gt;keep_alive&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;keep_alive&lt;/code&gt; 옵션에 따라 피어에 대한 연결이 활성 상태인지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9e61b5d3c6d9951043a7c42ee4ac908615e6dda5" translate="yes" xml:space="preserve">
          <source>Indicates if the test suite is currently passing.</source>
          <target state="translated">테스트 스위트가 현재 통과 중인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef01c58c919f2b098417df7378a5f02c4c2d45a0" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;$sTargetPath&lt;/code&gt; will be a raw Windows NT object name. This usually means that &lt;code&gt;$sTargetPath&lt;/code&gt; starts with &lt;code&gt;&quot;\\Device\\&quot;&lt;/code&gt;. Note that you cannot use &lt;code&gt;&quot;/&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;\\&quot;&lt;/code&gt; in raw target path names.</source>
          <target state="translated">&lt;code&gt;$sTargetPath&lt;/code&gt; 가 원시 Windows NT 개체 이름 임을 나타냅니다 . 이는 일반적으로 &lt;code&gt;$sTargetPath&lt;/code&gt; 가 &lt;code&gt;&quot;\\Device\\&quot;&lt;/code&gt; 시작 함을 의미합니다 . 원시 대상 경로 이름에서 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4520cd78eb8d8cd3353abddf71f5cfdf3e0ea242" translate="yes" xml:space="preserve">
          <source>Indicates that Ctrl/U, Ctrl/R, and DELETE are not to be considered control commands on terminal input, but are to be passed to the application program.</source>
          <target state="translated">Ctrl / U, Ctrl / R 및 DELETE가 터미널 입력에서 제어 명령으로 간주되지 않고 응용 프로그램으로 전달됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89c8d4afc13dccaac0824429842e2b3486822df1" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. A single typemap may be specified as a string, or multiple typemaps can be specified in an array reference, with the last typemap having the highest precedence.</source>
          <target state="translated">사용자 제공 유형 맵이 기본 유형 맵보다 우선해야 함을 나타냅니다. 단일 유형 맵을 문자열로 지정하거나 배열 유형에 여러 유형 맵을 지정할 수 있으며 마지막 유형 맵이 가장 높은 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a07031906aeffe3119baa721e29202522fd91917" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. This option may be used multiple times, with the last typemap having the highest precedence.</source>
          <target state="translated">사용자 제공 유형 맵이 기본 유형 맵보다 우선해야 함을 나타냅니다. 이 옵션은 마지막 유형 맵이 가장 높은 우선 순위와 함께 여러 번 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6c6be6a26747d93fbb6c3ceadc3f2de48a2c99" translate="yes" xml:space="preserve">
          <source>Indicates that arguments returned from a callback should be discarded. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 반환 된 인수는 버려야 함을 나타냅니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0527e8a268302f8a5a261750f72fb958d828bf1d" translate="yes" xml:space="preserve">
          <source>Indicates that no arguments are being sent to a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에 인수가 전송되지 않음을 나타냅니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1a4d2b29fe4bc866080992a5b7a34bdbecb2aeb" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">호출자가 결과의 호스트 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 호스트 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="91d2892aa8952e09a191501575b51fbbf525086f" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;undef&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">호출자가 결과의 호스트 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;undef&lt;/code&gt; 는 호스트 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ec72841bfda828e77f110fabfe3b01a8c116ba" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">호출자가 결과의 서비스 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 서비스 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52065ec2a07be88eb3f6bb4c9b96986da981df93" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;undef&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">호출자가 결과의 서비스 이름에 관심이 없으므로 변환 할 필요가 없음을 나타냅니다. &lt;code&gt;undef&lt;/code&gt; 는 서비스 이름으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f532e8b4a0494e58b3d4e84b40bc705bd9387b6c" translate="yes" xml:space="preserve">
          <source>Indicates that the caller will pass a numeric address, rather than a hostname, and that getaddrinfo() must not perform a resolve operation on this name. This flag will prevent a possibly-slow network lookup operation, and instead return an error if a hostname is passed.</source>
          <target state="translated">호출자가 호스트 이름이 아닌 숫자 주소를 전달하고 getaddrinfo ()가이 이름에 대해 확인 작업을 수행하지 않아야 함을 나타냅니다. 이 플래그는 네트워크 조회 작업이 느리게 진행되는 것을 방지하고 대신 호스트 이름이 전달되면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3c8087750e8c32a23d6ccd2949d0b7dadc5ebeea" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt; ) field of the result to be filled in.</source>
          <target state="translated">호출자 가 결과 의 표준 호스트 이름 ( &lt;code&gt;canonname&lt;/code&gt; ) 필드를 채우길 원함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="765c5439c71bb5dd46ae2b457c3aebf852e2ce63" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt;) field of the result to be filled in.</source>
          <target state="translated">호출자 가 결과 의 정식 호스트 이름 ( &lt;code&gt;canonname&lt;/code&gt; ) 필드가 채워지기를 원함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0a02454d6f3918d6c495eef14a92688abca3837e" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a method. A subroutine so marked will not trigger the &quot;Ambiguous call resolved as CORE::%s&quot; warning.</source>
          <target state="translated">참조 된 서브 루틴이 메소드임을 나타냅니다. 이렇게 표시된 서브 루틴은 &quot;모호한 호출이 CORE :: % s로 해결되었습니다&quot;경고를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c805274f5974d7ec81414a21a79ac4005ac17f0" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a valid lvalue and can be assigned to. The subroutine must return a modifiable value such as a scalar variable, as described in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">참조 된 서브 루틴이 유효한 lvalue이며 할당 될 수 있음을 나타냅니다. 서브 루틴은 &lt;a href=&quot;perlsub&quot;&gt;perlsub에&lt;/a&gt; 설명 된대로 스칼라 변수와 같은 수정 가능한 값을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="945cc6067d92cdd88f1d4d49015ca5f672222998" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 및 &lt;a href=&quot;threads/shared&quot;&gt;스레드 :: 공유&lt;/a&gt; 모듈 과 함께 사용될 때 참조 된 변수가 다른 스레드에서 공유 될 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="11cf21dbf5fe03fde0078615e81d4953585daf83" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">참조 된 변수가 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 및 &lt;a href=&quot;threads::shared&quot;&gt;threads :: shared&lt;/a&gt; 모듈 과 함께 사용될 때 다른 스레드에서 공유 될 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f5dc796b3c6e09f2adbe1df261ece3a878874b6e" translate="yes" xml:space="preserve">
          <source>Indicates that the socket address relates to a &lt;code&gt;SOCK_DGRAM&lt;/code&gt; socket, for the services whose name differs between TCP and UDP protocols.</source>
          <target state="translated">TCP와 UDP 프로토콜간에 이름이 다른 서비스에 대해 소켓 주소가 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 소켓과 관련됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d2c743e25365a9bdf3ff9b009f1ca948b97e6afb" translate="yes" xml:space="preserve">
          <source>Indicates that this resolution is for a local bind() for a passive (i.e. listening) socket, rather than an active (i.e. connecting) socket.</source>
          <target state="translated">이 해결 방법은 활성 (예 : 연결) 소켓이 아닌 수동 (예 : 수신) 소켓에 대한 로컬 bind ()에 대한 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f10eaccf1b997cf7e5e0f8a8f4fab0ca55e7525" translate="yes" xml:space="preserve">
          <source>Indicates the macro to be used to generate normalized random numbers. Uses randfunc, often divided by (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits)) in order to normalize the result. In C programs, the macro &lt;code&gt;Drand01&lt;/code&gt; is mapped to drand01.</source>
          <target state="translated">정규화 된 난수를 생성하는 데 사용되는 매크로를 나타냅니다. 결과를 정규화하기 위해 종종 (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits))로 나눈 randfunc를 사용합니다. C 프로그램에서 매크로 &lt;code&gt;Drand01&lt;/code&gt; 은 drand01 에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="46fbaffe89877f1dd0586f026a063f6bfd1ece0d" translate="yes" xml:space="preserve">
          <source>Indicates the name of the random number function to use. Values include drand48, random, and rand. In C programs, the &lt;code&gt;Drand01&lt;/code&gt; macro is defined to generate uniformly distributed random numbers over the range [0., 1.[ (see drand01 and nrand).</source>
          <target state="translated">사용할 난수 함수의 이름을 나타냅니다. drand48, random 및 rand 값이 포함됩니다. C 프로그램에서 &lt;code&gt;Drand01&lt;/code&gt; 매크로는 [0., 1. [범위에 걸쳐 균일하게 분포 된 난수를 생성하도록 정의됩니다 (drand01 및 nrand 참조).</target>
        </trans-unit>
        <trans-unit id="0e9d38aea41337c4a340bd6ff37e0fceaaf530c7" translate="yes" xml:space="preserve">
          <source>Indicates the random number generating seed function. Values include srand48, srandom, and srand.</source>
          <target state="translated">난수 생성 시드 함수를 나타냅니다. 값은 srand48, srandom 및 srand를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cd655229f991b7aec42a78f98c296efa6aab20f6" translate="yes" xml:space="preserve">
          <source>Indicates the tool that was used to create this</source>
          <target state="translated">이것을 만드는 데 사용 된 도구를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="90e351cd851905a73031d78312feecb33ffe731a" translate="yes" xml:space="preserve">
          <source>Indicates the type of the argument of the seedfunc.</source>
          <target state="translated">seedfunc의 인수 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="157e831f2a32e9a34450598504f4e81bdfe93334" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">일이 너무 심하게 진행되고 있음을 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness에&lt;/a&gt; 나타냅니다 . 모든 테스트가 종료되어야합니다. 여기에는 추가 테스트 스크립트 실행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2261f14a4235af1795b8d1185c5372fb55826237" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 에게 모든 일이 심하게 진행되고 있음을 나타냅니다 . 여기에는 추가 테스트 스크립트 실행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe441aac507416c2ecf5fefc2720f5a5e7cc6991" translate="yes" xml:space="preserve">
          <source>Indicates to the harness that things are going so badly all testing should terminate. This includes the running of any additional test scripts.</source>
          <target state="translated">상황이 나 빠지고 있음을 하네스에 표시하여 모든 테스트를 종료해야합니다. 여기에는 추가 테스트 스크립트 실행이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bdde223b122eaee17c31cfd6ef76f52ec58ce6f0" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current item is a YAML block.</source>
          <target state="translated">현재 항목이 YAML 블록인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ac3f8f7cb3f69c816245189833fb5047e4be353" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current line could be parsed.</source>
          <target state="translated">현재 행을 구문 분석 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="765249e9b3e3ba66799eb3c3e692065e2ef4bdde" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a SKIP directive.</source>
          <target state="translated">주어진 결과에 SKIP 지시어가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e5feadbfd972a9ef3f2203c437baf1b81be3303" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO directive.</source>
          <target state="translated">주어진 결과에 TODO 지시문이 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5ae3ac2f7146f745d483818a88c053580ae4ad1e" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO or SKIP directive.</source>
          <target state="translated">주어진 결과에 TODO 또는 SKIP 지시문이 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33c1162df0e994c2dba92771958227447c3c8740" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a TAP version line.</source>
          <target state="translated">이 버전이 TAP 버전인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="82a274793f5ee26247829ddf91f4a9bd5a24bbd9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a YAML chunk.</source>
          <target state="translated">이것이 YAML 청크인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="551b037463cdc6d8ee7a155c709c206438a14ea9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment.</source>
          <target state="translated">이것이 주석인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fa47f2a4b95862bdf9eb043bb9b755ecb73bbd6f" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &lt;code&gt;merge&lt;/code&gt; option.</source>
          <target state="translated">이것이 주석인지 여부를 나타냅니다. STDERR이 STDOUT에 병합 된 경우 주석은 일반적으로 TAP 스트림에만 나타납니다. &lt;code&gt;merge&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5add899043fa2f2909dd47a1020e2ad33a37e66d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a pragma line.</source>
          <target state="translated">이것이 pragma 행인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7023aeaf089510f19833c997992b3c941c8dc92d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a test line.</source>
          <target state="translated">이것이 테스트 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f9b15b44f69cccc124e6789e9d93a4a06a7d51c" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is bailout line.</source>
          <target state="translated">이것이 구제 금융 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a3a5d84e52530eeac47fceba7db01f6e0dcbe22" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is the test plan line.</source>
          <target state="translated">이것이 테스트 계획 라인인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53a07ae6433afd9e304cca7c30208aa346f95b4e" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">렉서 버퍼 ( &lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt; linestr&quot;&lt;/a&gt; ) 의 옥텟 을 유니 코드 문자의 UTF-8 인코딩으로 해석 해야하는지 여부를 나타냅니다 . 그렇지 않은 경우 Latin-1 문자로 해석되어야합니다. 이것은 스칼라 에 대한 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="9010b0739ea277aa1257ee6d74e58336f2039de7" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">렉서 버퍼의 옥텟 ( &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; )을 유니 코드 문자의 UTF-8 인코딩으로 해석 해야하는지 여부를 나타냅니다 . 그렇지 않은 경우 라틴 -1 문자로 해석해야합니다. 스칼라 에 대한 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6add24acec866ad90335d7337161ba97a738a82e" translate="yes" xml:space="preserve">
          <source>Indicating the Film::Rating() method is broken.</source>
          <target state="translated">Film :: Rating () 메서드를 나타내는 것이 깨졌습니다.</target>
        </trans-unit>
        <trans-unit id="065a6d5ea3be3a587038269a904d146bb9a0a3c1" translate="yes" xml:space="preserve">
          <source>Indirect Object Syntax</source>
          <target state="translated">간접 객체 구문</target>
        </trans-unit>
        <trans-unit id="3fba9ca2a9139d262136aa9779aba86f7f14b1e8" translate="yes" xml:space="preserve">
          <source>Individual Results</source>
          <target state="translated">개별 결과</target>
        </trans-unit>
        <trans-unit id="9cee924720451366321a5d77a5bce661294a6372" translate="yes" xml:space="preserve">
          <source>Individual committers should create topic branches under &lt;b&gt;yourname&lt;/b&gt;/&lt;b&gt;some_descriptive_name&lt;/b&gt;:</source>
          <target state="translated">개별 커미터는 &lt;b&gt;yourname&lt;/b&gt; / &lt;b&gt;some_descriptive_name&lt;/b&gt; 아래에 주제 브랜치를 &lt;b&gt;만들어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cb52fbb620cf2997c4aa4b5107c331f4b77d2de2" translate="yes" xml:space="preserve">
          <source>Individual test results.</source>
          <target state="translated">개별 테스트 결과.</target>
        </trans-unit>
        <trans-unit id="a6118403aceb71cf86308ba3cff213cbc8856dc0" translate="yes" xml:space="preserve">
          <source>Individual test suite results.</source>
          <target state="translated">개별 테스트 스위트 결과.</target>
        </trans-unit>
        <trans-unit id="35536a41b209715d9e3ad440431fef2672f20bbe" translate="yes" xml:space="preserve">
          <source>Indonesia</source>
          <target state="translated">Indonesia</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="fcefc0b17d205c1c65f4c51d0fe902c4a064f2d7" translate="yes" xml:space="preserve">
          <source>Infinite recursion in regex</source>
          <target state="translated">정규식의 무한 재귀</target>
        </trans-unit>
        <trans-unit id="4367ace45c63bdb1f549a2a2f7dd6cdd72c8dfb1" translate="yes" xml:space="preserve">
          <source>Infinite recursion via empty pattern</source>
          <target state="translated">빈 패턴을 통한 무한 재귀</target>
        </trans-unit>
        <trans-unit id="68dcf262960464f7812ef1f6844ea3187d8ab76d" translate="yes" xml:space="preserve">
          <source>Infinity and Not a Number</source>
          <target state="translated">무한대와 숫자가 아님</target>
        </trans-unit>
        <trans-unit id="ec4c72e2c7996edd7fe98bac862051d171e8f331" translate="yes" xml:space="preserve">
          <source>Inflate Interface</source>
          <target state="translated">팽창 인터페이스</target>
        </trans-unit>
        <trans-unit id="ae8803342c993280c888b28837c9da6527d39370" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 전체 내용을 팽창시킵니다 . 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d9b46b317dca1e834a024c29757ee0f8a5e027e" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt;. The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 전체 내용을 확장 합니다 . 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beedaffabd6b03c265ffb648f984a13e030e2063" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; . The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 의 전체 내용을 압축하고 압축되지 않은 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 . &lt;code&gt;$input&lt;/code&gt; 및 &lt;code&gt;$output&lt;/code&gt; 매개 변수 중 하나 스칼라 또는 스칼라 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a474d8e337dea1030c8c9f1ba0d71abcee898bb" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt;. The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 의 전체 내용을 확장 하고 압축되지 않은 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 . &lt;code&gt;$input&lt;/code&gt; 및 &lt;code&gt;$output&lt;/code&gt; 매개 변수 중 하나 스칼라 또는 스칼라 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="424924a8af9c413db917d51e67110d95dea81788" translate="yes" xml:space="preserve">
          <source>Information about true color support in various terminal emulators and test programs you can run to check the true color support in your terminal emulator are available at &lt;a href=&quot;https://gist.github.com/XVilka/8346728&quot;&gt;https://gist.github.com/XVilka/8346728&lt;/a&gt;.</source>
          <target state="translated">터미널 에뮬레이터에서 트루 컬러 지원을 확인하기 위해 실행할 수있는 다양한 터미널 에뮬레이터 및 테스트 프로그램의 트루 컬러 지원에 대한 정보는 &lt;a href=&quot;https://gist.github.com/XVilka/8346728&quot;&gt;https://gist.github.com/XVilka/8346728&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75ddcc47830d9749b1f6958774d6b7383d928afa" translate="yes" xml:space="preserve">
          <source>Information on installing the Perl documentation in HTML format can be found in the</source>
          <target state="translated">HTML 형식으로 Perl 문서를 설치하는 것에 대한 정보는</target>
        </trans-unit>
        <trans-unit id="63a11938f1b7522fad4baac591e5655e30cc1a15" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt; . The variable is a structured string that looks something like this:</source>
          <target state="translated">현재 perl 바이너리가 컴파일 된 git commit에 대한 정보는 &lt;code&gt;$Config::Git_Data&lt;/code&gt; 변수에서 찾을 수 있습니다 . 변수는 다음과 같은 구조화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a0e7d716e288cb7e639286453bea0a95db3d58e1" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt;. The variable is a structured string that looks something like this:</source>
          <target state="translated">현재 펄 바이너리가 컴파일 된 git 커밋에 대한 정보는 &lt;code&gt;$Config::Git_Data&lt;/code&gt; 변수에서 찾을 수 있습니다 . 변수는 다음과 같은 구조화 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4fa18069a4aed5716a8df64d9e082aca15aa5195" translate="yes" xml:space="preserve">
          <source>Informative call that array is likely to grow to have</source>
          <target state="translated">배열이 성장할 가능성이 높은 정보 호출</target>
        </trans-unit>
        <trans-unit id="4002d66fcc252c8f943869f47b18239871e5a38c" translate="yes" xml:space="preserve">
          <source>Informative names</source>
          <target state="translated">유익한 이름</target>
        </trans-unit>
        <trans-unit id="6c1c216b5b3374ee549f4e7ce25195c9cfb38752" translate="yes" xml:space="preserve">
          <source>Ingy's suggestions</source>
          <target state="translated">Ingy의 제안</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fdd8dbf1164cff77c53c1fcf6f05a5248f3597e3" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt; :</source>
          <target state="translated">상속은 두 클래스가 코드를 공유 할 수있게합니다. 기본적으로 부모 클래스의 모든 메서드는 자식에서도 사용할 수 있습니다. 자식은 부모의 메서드를 명시 적으로 &lt;b&gt;재정 의하여&lt;/b&gt; 자체 구현을 제공 할 수 있습니다. 우리는이 예를 들어, &lt;code&gt;File::MP3&lt;/code&gt; 객체를, 그것은이 &lt;code&gt;print_info()&lt;/code&gt; 에서 방법 &lt;code&gt;File&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fbc39f4531ecbce98b377fac6454c84ec2034707" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt;:</source>
          <target state="translated">상속을 통해 두 클래스가 코드를 공유 할 수 있습니다. 기본적으로 부모 클래스의 모든 메서드는 자식에서도 사용할 수 있습니다. 자식은 부모의 메서드를 명시 적으로 &lt;b&gt;재정 의하여&lt;/b&gt; 자체 구현을 제공 할 수 있습니다. 우리는이 예를 들어, &lt;code&gt;File::MP3&lt;/code&gt; 객체를, 그것은이 &lt;code&gt;print_info()&lt;/code&gt; 에서 방법 &lt;code&gt;File&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbc41c48400edb2d66f46abd2eeeb9f193aa61fe" translate="yes" xml:space="preserve">
          <source>Inheritance and Overloading</source>
          <target state="translated">상속과 오버로딩</target>
        </trans-unit>
        <trans-unit id="73b13d6576dee61ad6c9a67be3c5fd56748eb8f1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; which allows you to change the trace.</source>
          <target state="translated">추적을 변경할 수있는 &lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ae06620429d483baf3958f6460d3cab1b8f1403" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;, overridden to also vivify/mutate the 'about' facet.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속되며 'about'패싯도 활성화 / 변형하도록 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa5c47bbe5bffb87fdc63768d24cbdd7ac233292" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. This can be used to add 'amnesty' facets to an existing event. Each new item is added to the &lt;b&gt;END&lt;/b&gt; of the list.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속됩니다 . 기존 이벤트에 '사면'패싯을 추가하는 데 사용할 수 있습니다. 각각의 새 항목이 목록 &lt;b&gt;끝에&lt;/b&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="19c5f1d372c49633a5f800879863d9084768bf54" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. This is used by hubs to stamp events as they pass through. New items are added to the &lt;b&gt;START&lt;/b&gt; of the list.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속됩니다 . 이것은 이벤트가 통과 할 때 이벤트를 스탬프 처리하기 위해 허브에서 사용됩니다. 새 항목이 목록 의 &lt;b&gt;시작&lt;/b&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4102e1cbc70e34f207d4b05daf2f7d154eb2cce" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::ExtraHash*</source>
          <target state="translated">* Tie :: ExtraHash *에서 상속</target>
        </trans-unit>
        <trans-unit id="07845e4fa81351b41e3aca0473590f0745f203e3" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::Memoize*</source>
          <target state="translated">* Tie :: Memoize *에서 상속</target>
        </trans-unit>
        <trans-unit id="c5a788b89ced595ecbe83baf444c015d5af4ed62" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::StdHash*</source>
          <target state="translated">* Tie :: StdHash *에서 상속</target>
        </trans-unit>
        <trans-unit id="2af015f1a7a88588d2bedaaf274af7c154500941" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ee435be5e637cbc759b674414f3dfaaeaa6a310" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::Memoize&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: Memoize&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0942164c538c56917cf82fee8d95de867370af98" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::StdHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: StdHash&lt;/b&gt; 에서 상속&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48240d94f1e40cb4a0ce31e0d0412d7b8f4b76ab" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::ExtraHash</source>
          <target state="translated">Tie :: ExtraHash에서 상속</target>
        </trans-unit>
        <trans-unit id="6eb8e208cadd5346ff9c4a40511d1dbe6081d340" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::Memoize</source>
          <target state="translated">Tie :: Memoize에서 상속</target>
        </trans-unit>
        <trans-unit id="fa6d1eeae612ef4f96a499b488d3c738fd7b2bd5" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::StdHash</source>
          <target state="translated">Tie :: StdHash에서 상속</target>
        </trans-unit>
        <trans-unit id="f87f7c07fa0f8ea9a950efcf13bc372319f2a9a4" translate="yes" xml:space="preserve">
          <source>Inherits from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. Also defines:</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt; 에서 상속합니다 . 또한 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="12b78aab8730ee025153421cab4a6381c4215485" translate="yes" xml:space="preserve">
          <source>Inherits some evil code from &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 에서 악의적 인 코드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="697bba69426638bf8ad3245a38ff2084b17b3805" translate="yes" xml:space="preserve">
          <source>Init methods</source>
          <target state="translated">초기화 방법</target>
        </trans-unit>
        <trans-unit id="469d92ba331e1f193a058b9d59b36d9c2695f1be" translate="yes" xml:space="preserve">
          <source>Init.U</source>
          <target state="translated">Init.U</target>
        </trans-unit>
        <trans-unit id="188fedc6f79203e40eb5a91d186ec6c30916e7f9" translate="yes" xml:space="preserve">
          <source>Initial discussion of the ability to modify IO streams behaviour used the term &quot;discipline&quot; for the entities which were added. This came (I believe) from the use of the term in &quot;sfio&quot;, which in turn borrowed it from &quot;line disciplines&quot; on Unix terminals. However, this document (and the C code) uses the term &quot;layer&quot;.</source>
          <target state="translated">IO 스트림 동작을 수정하는 기능에 대한 초기 논의는 추가 된 엔티티에 대해 &quot;징계&quot;라는 용어를 사용했습니다. 이것은 &quot;sfio&quot;라는 용어의 사용에서 비롯된 것으로, Unix 터미널의 &quot;라인 규칙&quot;에서 차용되었습니다. 그러나이 문서 (및 C 코드)에는 &quot;계층&quot;이라는 용어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af26189aae099c8b0074103f2d4d6fbc19c70e2f" translate="yes" xml:space="preserve">
          <source>Initial port of perl to WinCE. It was performed in separate directory named</source>
          <target state="translated">WinCE에 대한 perl의 초기 포트. 별도의 디렉토리에서 수행되었습니다</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="64a1cc8196dec5ffb0b6abf423df9a7b0c6e0219" translate="yes" xml:space="preserve">
          <source>Initial version (GSAR 20-FEB-97)</source>
          <target state="translated">초기 버전 (GSAR 20-FEB-97)</target>
        </trans-unit>
        <trans-unit id="681e3458dd2b1a02b6b17850e74b7b6f830be8ea" translate="yes" xml:space="preserve">
          <source>Initialisation in &lt;code&gt;pregcomp()&lt;/code&gt; mostly involves the creation and data-filling of a special structure, &lt;code&gt;RExC_state_t&lt;/code&gt; (defined in</source>
          <target state="translated">&lt;code&gt;pregcomp()&lt;/code&gt; 초기화는 대부분 특수 구조 인 &lt;code&gt;RExC_state_t&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="c7a9076545ffc08af19383275c9bb0a670aaa64a" translate="yes" xml:space="preserve">
          <source>Initialises a deflation object.</source>
          <target state="translated">수축 오브젝트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b36a0f0079e64fa2a033c629779d3f623a057d8c" translate="yes" xml:space="preserve">
          <source>Initialises a deflation stream.</source>
          <target state="translated">수축 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6050c58e3e77b97a8c7a9c2f34e629bf70ca3f1a" translate="yes" xml:space="preserve">
          <source>Initialises an inflation object.</source>
          <target state="translated">인플레이션 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d6dc7f91e03e45468b8ef5863382d6fe3515a834" translate="yes" xml:space="preserve">
          <source>Initialises an inflation stream.</source>
          <target state="translated">인플레이션 스트림을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="925a3411c38d467154e067193b51fb11192479d2" translate="yes" xml:space="preserve">
          <source>Initialization of certain non-subroutine variables in ExtUtils::ParseXS and some of its supporting packages has been moved into this package so that those values can be defined exactly once and then re-used in any package.</source>
          <target state="translated">ExtUtils :: ParseXS 및 일부 지원 패키지에서 특정 비-서브 루틴 변수의 초기화가이 패키지로 이동되어 해당 값을 정확히 한 번 정의한 다음 모든 패키지에서 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f93bcd9e79c47792da25c51c98403872611fece" translate="yes" xml:space="preserve">
          <source>Initialization of state variables in list currently forbidden</source>
          <target state="translated">현재 금지 된 목록의 상태 변수 초기화</target>
        </trans-unit>
        <trans-unit id="a08fb78f0ee25d9e540249a9eb4c3ec2aebf86f6" translate="yes" xml:space="preserve">
          <source>Initialization values for some globals</source>
          <target state="translated">일부 글로벌의 초기화 값</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
