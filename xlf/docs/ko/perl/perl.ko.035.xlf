<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8f7ab85a46c82118f02884a07c3492a612ad0bc1" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, detects what kind of source it is and returns</source>
          <target state="translated">&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source가&lt;/a&gt; 주어지면 소스의 종류를 감지하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b116ea0f536335d3865a0d04bc8e08d1c2acb6e8" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, finds the most suitable &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; to use to create a &lt;a href=&quot;iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; (see &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;). Dies on error.</source>
          <target state="translated">&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source가&lt;/a&gt; 주어지면 &lt;a href=&quot;iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt; 를 작성하는 데 가장 적합한 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 찾습니다 ( &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; 참조 ). 오류로 사망합니다.</target>
        </trans-unit>
        <trans-unit id="2fa07acc92ca3a34b050a1779c443de025ad8957" translate="yes" xml:space="preserve">
          <source>Given a Perl subroutine prototype, return a list of invocation specifications. Each specification is a listref, where the first member is the (minimum) number of arguments for this invocation specification. The remaining arguments are a string representation of how to pass the arguments correctly to a sub with the given prototype, when called with the given number of arguments.</source>
          <target state="translated">Perl 서브 루틴 프로토 타입이 주어지면 호출 스펙 목록을 리턴하십시오. 각 사양은 listref이며, 첫 번째 멤버는이 호출 사양에 대한 (최소) 인수 수입니다. 나머지 인수는 지정된 수의 인수로 호출 될 때 지정된 프로토 타입을 사용하여 하위에 인수를 올바르게 전달하는 방법을 나타내는 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="b30c1dfc72170a71448f9b395e9b03e816f03b3d" translate="yes" xml:space="preserve">
          <source>Given a PerlIO * create a 'native' FILE * suitable for passing to code expecting to be compiled and linked with ANSI C</source>
          <target state="translated">PerlIO가 주어지면 * '네이티브'파일을 생성하십시오 * ANSI C와 컴파일되고 링크 될 것으로 예상되는 코드로 전달하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="34f965aed65d5f567330c1f887c60f3d7277e8d9" translate="yes" xml:space="preserve">
          <source>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</source>
          <target state="translated">메모리 덩어리가 주어지면 경기장 목록의 헤드에 연결하고 사용 가능한 SV 목록으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="ea0db9ec916b80f6d45682cc0643494437b81c63" translate="yes" xml:space="preserve">
          <source>Given a function argument and the corresponding function value, store them into the cache.</source>
          <target state="translated">함수 인수와 해당 함수 값이 주어지면이를 캐시에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="368b29d6322d5568fa6515033d024e6d8d044278" translate="yes" xml:space="preserve">
          <source>Given a function argument, is the corresponding function value in the cache, and if so, is it fresh enough to use?</source>
          <target state="translated">함수 인수가 주어지면 캐시에 해당 함수 값이 있습니까? 그렇다면 사용하기에 충분합니까?</target>
        </trans-unit>
        <trans-unit id="f996cfe932df1fdf5f95873d9c8a6b9f9b2d54ff" translate="yes" xml:space="preserve">
          <source>Given a function argument, look up the corresponding function value in the cache and return it.</source>
          <target state="translated">함수 인수가 주어지면 캐시에서 해당 함수 값을 찾아서 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="c3509e606900720895e02d9e89cbafec46d210bc" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt; ) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">키 ( &lt;code&gt;$key&lt;/code&gt; )가 주어지면 이 메소드는 데이터베이스에서 키 와 연관된 값을 읽습니다. 데이터베이스에서 읽은 값은 &lt;code&gt;$value&lt;/code&gt; 매개 변수에 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a67beacc3582ff6ab21ef53a13b990116854b74" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt;) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">키 ( &lt;code&gt;$key&lt;/code&gt; )가 주어지면 이 메소드는 데이터베이스에서 연관된 값을 읽습니다. 데이터베이스에서 읽은 값은 &lt;code&gt;$value&lt;/code&gt; 매개 변수에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7f4f0181b47fc4d73d9cd3bbfb5acee403880eb" translate="yes" xml:space="preserve">
          <source>Given a list of args get the names of tests that should run</source>
          <target state="translated">인수 목록이 주어지면 실행해야 할 테스트 이름을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="16258c75193474948085fd76ec96dab72f546f03" translate="yes" xml:space="preserve">
          <source>Given a list of file names, strip out those that refer to a parent directory. (Does not strip symlinks, only '.', '..', and equivalents.)</source>
          <target state="translated">파일 이름 목록이 제공되면 상위 디렉토리를 참조하는 파일 이름을 제거하십시오. 심볼릭 링크를 제거하지 않고 '.', '..'및 동등한 항목 만 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9ef7fd99b0e4a8aa29f6aa6041cd8f8921cd8d25" translate="yes" xml:space="preserve">
          <source>Given a list of files in a directory (such as from &lt;code&gt;readdir()&lt;/code&gt;), strip out &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt;.</source>
          <target state="translated">디렉토리에있는 파일 목록 (예 : from &lt;code&gt;readdir()&lt;/code&gt; )이 주어지면 &lt;code&gt;'.'&lt;/code&gt; 을 제거하십시오 . 및 &lt;code&gt;'..'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3018b6ffb20dcac62489facac809bddacf5bfb4" translate="yes" xml:space="preserve">
          <source>Given a list of identifiers, &lt;code&gt;embeddable_typemap&lt;/code&gt; tries to load typemaps from a file of the given name(s), or from a module that is an &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; subclass.</source>
          <target state="translated">식별자 목록이 주어지면 &lt;code&gt;embeddable_typemap&lt;/code&gt; 은 지정된 이름의 파일 또는 &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 하위 클래스 인 모듈에서 typemap 을로드하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="3f60dd44db71eb2a881f946f782f7b4489542b29" translate="yes" xml:space="preserve">
          <source>Given a list of scalars or reference variables, writes out their contents in perl syntax. The references can also be objects. The content of each variable is output in a single Perl statement. Handles self-referential structures correctly.</source>
          <target state="translated">스칼라 또는 참조 변수 목록이 제공되면 해당 컨텐츠를 perl 구문으로 작성하십시오. 참조는 객체 일 수도 있습니다. 각 변수의 내용은 단일 Perl 문으로 출력됩니다. 자기 참조 구조를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3e530c4f306640476d631e5c36d6a2f051774865" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름 또는 숫자가 주어지면 이것이 나타내는 유니 코드 문자의 수를 반환합니다. 예를 들어, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; 및 &lt;code&gt;e2char('057')&lt;/code&gt; 모두 47을 반환합니다. &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 및 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 은 모두 유니 코드 번호가 47 인 &quot;/&quot;를 의미합니다. 이름에 알려진 값이 없거나 이름이 &quot;qacute&quot;인 경우 또는 구문 상 유효하지 않은 경우 (이름이 &quot;1/4 인 경우&quot; &quot;), undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af20a3b02e35b18386f4530792c069877997ab32" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt;, &lt;code&gt;e2char('47')&lt;/code&gt;, &lt;code&gt;e2char('0x2F')&lt;/code&gt;, and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt;, and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt;, all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름이나 숫자가 주어지면 이것이 나타내는 유니 코드 문자의 번호를 반환합니다. 예를 들어 &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , &lt;code&gt;e2char('057')&lt;/code&gt; 모두 47을 반환하므로 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 은 모두 &quot;/&quot;를 의미하며 유니 코드 번호는 47입니다. 이름에 알려진 값이 없거나 ( &quot;qacute&quot;이름과 같음) 구문 상 유효하지 않은 경우 (이름 &quot;1/4&quot;) &quot;), 이것은 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2023da106c6aa26bd0acc5076b02991c20277361" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름 또는 숫자가 주어지면 해당 문자열이 반환됩니다. 예를 들어, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; 및 &lt;code&gt;e2char('057')&lt;/code&gt; 의 모든 창 &quot;/&quot;때문에 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 모두 평균 &quot;/&quot;. 이름에 알려진 값이 없거나 (이름이 &quot;qacute&quot;인 경우) 구문 상 유효하지 않은 경우 (이름이 &quot;1/4&quot;인 경우) undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6238b6c70a7beedaa2b47d1c70942578995fe2d" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt;, &lt;code&gt;e2char('47')&lt;/code&gt;, &lt;code&gt;e2char('0x2F')&lt;/code&gt;, and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt;, and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt;, all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 시퀀스에 나타날 수있는 이름이나 번호가 주어지면 해당 문자열을 반환합니다. 예를 들어 &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; 및 &lt;code&gt;e2char('057')&lt;/code&gt; 모두 &quot;/&quot;를 반환합니다. &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 및 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 은 모두 &quot;/&quot;를 의미합니다. 이름에 알려진 값이 없거나 (이름이 &quot;qacute&quot;인 경우) 구문 적으로 유효하지 않은 경우 (이름이 &quot;1/4&quot;인 경우) undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8fab49b7e67f8e8512bb770d5fecfb47a79348d" translate="yes" xml:space="preserve">
          <source>Given a package name and a hashref mapping names to a subroutine reference (or &lt;code&gt;undef&lt;/code&gt;), this subroutine will install said subroutines on their given name in that module. If a name mapes to &lt;code&gt;undef&lt;/code&gt;, any subroutine with that name in the target module will be remove (possibly &quot;unshadowing&quot; a CORE sub of same name).</source>
          <target state="translated">패키지 이름과 서브 루틴 참조 (또는 &lt;code&gt;undef&lt;/code&gt; )에 대한 해시 참조 매핑 이름이 주어지면 이 서브 루틴은 해당 모듈의 주어진 이름에 해당 서브 루틴을 설치합니다. 이름이 &lt;code&gt;undef&lt;/code&gt; 에 매핑 되면 대상 모듈에서 해당 이름을 가진 모든 서브 루틴이 제거됩니다 (동일한 이름의 CORE 하위를 &quot;언 섀도 잉&quot;할 수 있음).</target>
        </trans-unit>
        <trans-unit id="68ff8a7e4af810b7a363c9f43756d64a041cba7a" translate="yes" xml:space="preserve">
          <source>Given a packed socket address (such as from getsockname(), getpeername(), or returned by getaddrinfo() in a &lt;code&gt;addr&lt;/code&gt; field), returns the hostname and symbolic service name it represents. $flags may be a bitmask of &lt;code&gt;NI_*&lt;/code&gt; constants, or defaults to 0 if unspecified.</source>
          <target state="translated">압축 된 소켓 주소 (예 : getsockname (), getpeername () 또는 &lt;code&gt;addr&lt;/code&gt; 필드의 getaddrinfo ()에 의해 리턴 됨)에서 호스트 이름과 그것이 나타내는 기호 서비스 이름을 리턴합니다. $ flags는 &lt;code&gt;NI_*&lt;/code&gt; 상수 의 비트 마스크 이거나 지정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="51657afc8f82d4e3d689a9ad42ae81c82da15acf" translate="yes" xml:space="preserve">
          <source>Given a pathname to a file containing metadata, this deserializes the file according to its file suffix and constructs a new &lt;code&gt;CPAN::Meta&lt;/code&gt; object, just like &lt;code&gt;new()&lt;/code&gt;. It will die if the deserialized version fails to validate against its stated specification version.</source>
          <target state="translated">메타 데이터를 포함하는 파일의 경로 이름이 주어지면 파일 접미사에 따라 파일을 역 직렬화하고 &lt;code&gt;new()&lt;/code&gt; 와 마찬가지로 새 &lt;code&gt;CPAN::Meta&lt;/code&gt; 객체를 생성합니다 . 역 직렬화 된 버전이 명시된 사양 버전에 대해 유효성을 검사하지 못하면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="b3ab833b08cd320284ae184893dbedaee3a8efff" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대한 포인터 와 &lt;code&gt;=~&lt;/code&gt; 연산 (예 : &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt; )에 대한 대치가 주어지면, replace ()는 연산에 따라 &lt;code&gt;SV&lt;/code&gt; 내에서 문자열을 수정하고 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="dde32d4642dd76d6903ddcba2cd4f3588999395c" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;s/bob/robert/g&lt;/code&gt; or &lt;code&gt;tr[A-Z][a-z]&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대한 포인터 와 &lt;code&gt;=~&lt;/code&gt; 연산 (예 : &lt;code&gt;s/bob/robert/g&lt;/code&gt; 또는 &lt;code&gt;tr[A-Z][a-z]&lt;/code&gt; )이 주어지면 replacement ()는 연산에 따라 &lt;code&gt;SV&lt;/code&gt; 내의 문자열을 수정 하여 개수를 반환합니다. 대체가 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="7df1b1c7c83c78e200c9f9cd553763264fc01f76" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt; , which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">문자열과 패턴 (예 : &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;/\b\w*\b/&lt;/code&gt; , C 프로그램에서 &quot;/ \\ b \\ w * \\ b /&quot;로 표시 될 수 있음)이 있으면 match ( )는 문자열이 패턴과 일치하면 1을 반환하고 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c421180a417152f6c0674618188b29d3743dbc39" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;m/clasp/&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt;, which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">주어진 문자열과 패턴 (예 : &lt;code&gt;m/clasp/&lt;/code&gt; 또는 &lt;code&gt;/\b\w*\b/&lt;/code&gt; , C 프로그램에서 &quot;/ \\ b \\ w * \\ b /&quot;로 나타날 수 있음), match ( )는 문자열이 패턴과 일치하면 1을 반환하고 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8f74abc4a59a56ab26c7b6afd4629bc292ce127" translate="yes" xml:space="preserve">
          <source>Given a string, a base, and an optional collation sequence, interpret the string as a number in the given base. The collation sequence describes the value of each character in the string.</source>
          <target state="translated">문자열, 기본 및 선택적 데이터 정렬 시퀀스가 ​​주어지면 문자열을 지정된 기본의 숫자로 해석합니다. 데이터 정렬 순서는 문자열의 각 문자 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cb2d005ca978881d5ba03242206b93769db89d30" translate="yes" xml:space="preserve">
          <source>Given a template, returns a filehandle to the temporary file and the name of the file.</source>
          <target state="translated">템플릿이 주어지면 파일 핸들을 임시 파일과 파일 이름으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3247eafd3bd6b87dad8bb050e03ecb6550fab7f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt; , a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt; , matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">감안할 때 &lt;code&gt;SV&lt;/code&gt; , 패턴 및 빈에 대한 포인터 &lt;code&gt;AV&lt;/code&gt; 를 , 일치 () 평가 &lt;code&gt;$string =~ $pattern&lt;/code&gt; 리스트 문맥, 그리고 채우기에</target>
        </trans-unit>
        <trans-unit id="34e4f6e5dbaf1b34751d051563b1ed427ee41229" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt;, a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt;, matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; , 패턴 및 빈 &lt;code&gt;AV&lt;/code&gt; 에 대한 포인터가 주어지면 matches () 는 목록 컨텍스트에서 &lt;code&gt;$string =~ $pattern&lt;/code&gt; 을 평가 하고 다음을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="30244b464969efb78e9259f1691d48f7c1b175b6" translate="yes" xml:space="preserve">
          <source>Given an OS type and OS name, returns true or false if the OS name is of the given type. As with &lt;code&gt;os_type&lt;/code&gt;, it will use the current operating system as a default if no OS name is provided.</source>
          <target state="translated">OS 유형과 OS 이름이 주어지면 OS 이름이 주어진 유형 인 경우 true 또는 false를 반환합니다. &lt;code&gt;os_type&lt;/code&gt; 과 마찬가지로 OS 이름이 제공되지 않으면 현재 운영 체제를 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d73be34ecb8afbc83a1abc326b027cd0e5ff7367" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element of a hash, returns true if the specified element in the hash has ever been initialized, even if the corresponding value is undefined.</source>
          <target state="translated">해시의 요소를 지정하는 표현식이 주어지면 해당 값이 정의되지 않은 경우에도 해시의 지정된 요소가 초기화 된 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7378726c80d5aab2e860c98baf7c2cd0aceca44a" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;a href=&quot;#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; deletes the specified elements from that hash so that &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 또는 해시 조각을 지정하는 표현식이 주어지면 &lt;a href=&quot;#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 는 해당 요소에 &lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 하는 지정된 요소가 더 이상 true를 반환하지 않도록 해당 해시에서 지정된 요소를 삭제 합니다. 해시 요소를 정의되지 않은 값으로 설정하면 키가 제거되지 않지만 삭제하면 제거됩니다. &lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3860c44bdd22a4566d9e655bb9fabca95c5a3818" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">해시의 요소 또는 슬라이스를 지정하는 표현식이 주어지면 &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 는 해당 해시에서 지정된 요소를 삭제하여 해당 요소의 exist ()가 더 이상 true를 리턴하지 않도록합니다. 해시 요소를 정의되지 않은 값으로 설정하면 키가 제거되지 않지만 삭제하면 키가 제거됩니다. &lt;a href=&quot;exists&quot;&gt;존재&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c148d1ff0a7aebcb28822b3e1311889c861ad3aa" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">해시의 요소 또는 슬라이스를 지정하는 표현식이 주어지면 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 는 해당 해시에서 지정된 요소를 삭제하여 해당 요소의 exist ()가 더 이상 true를 리턴하지 않도록합니다. 해시 요소를 정의되지 않은 값으로 설정하면 키가 제거되지 않지만 삭제하면 키가 제거됩니다. &lt;a href=&quot;#exists&quot;&gt;존재&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="b769dfb6b889a385d12cb35d230597545507bff1" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 이름을 지정하는 표현식이 제공되면, 지정된 서브 루틴이 정의되지 않았더라도 선언 된 경우 true를 리턴합니다. 존재하거나 정의 된 서브 루틴 이름을 언급하는 것으로 선언하는 것으로 간주되지 않습니다. 존재하지 않는 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다. AUTOLOAD 메소드는 처음 호출 될 때 존재하게합니다. &lt;a href=&quot;../perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e2f23a5798654b28edd73d121507fc1d6cf61ce" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 이름을 지정하는 표현식이 제공되면, 지정된 서브 루틴이 정의되지 않았더라도 선언 된 경우 true를 리턴합니다. 존재하거나 정의 된 서브 루틴 이름을 언급하는 것으로 선언하는 것으로 간주되지 않습니다. 존재하지 않는 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다. AUTOLOAD 메소드는 처음 호출 될 때 존재하게합니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6382657811b5dffd947e094b3c4ab1d16ffe89f3" translate="yes" xml:space="preserve">
          <source>Given an module and version, this method returns true if the version specification for the module accepts the provided version. In other words, given:</source>
          <target state="translated">모듈과 버전이 주어지면이 메서드는 모듈의 버전 사양이 제공된 버전을 수락하는 경우 true를 반환합니다. 즉, 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec3e095107124a6ef85e395cac4af42d46355e9a" translate="yes" xml:space="preserve">
          <source>Given an object, return a Perl scalar number (int/float) representing this number.</source>
          <target state="translated">객체가 주어지면이 숫자를 나타내는 Perl 스칼라 숫자 (int / float)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="870f76963fd88871e6f7f23d8316a36c5a9dba60" translate="yes" xml:space="preserve">
          <source>Given an op, determine what type of struct it has been allocated as. Returns one of the OPclass enums, such as OPclass_LISTOP.</source>
          <target state="translated">연산이 주어지면 할당 된 구조체 유형을 결정합니다. OPclass_LISTOP와 같은 OPclass 열거 형 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="798afe5be4d4f8caba61172a6204d0e7a4433382" translate="yes" xml:space="preserve">
          <source>Given an open filehandle and the associated filename, make a safe unlink. This is achieved by first checking that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by stat() are compared). Then the filename is unlinked and the filehandle checked once again to verify that the number of links on that file is now 0. This is the closest you can come to making sure that the filename unlinked was the same as the file whose descriptor you hold.</source>
          <target state="translated">열린 파일 핸들과 관련 파일 이름이 주어지면 안전하게 연결 해제하십시오. 파일 이름과 파일 핸들이 처음에 동일한 파일을 가리키고 파일에 대한 링크 수가 1인지 확인하여 (stat ()에서 반환 한 모든 필드를 비교) 확인합니다. 그런 다음 파일 이름이 연결 해제되고 파일 핸들이 다시 한 번 확인되어 해당 파일의 링크 수가 0인지 확인합니다. 연결되지 않은 파일 이름이 설명자가 보유한 파일과 동일한 지 확인하는 가장 가까운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7c8d7de16830e305c76870f7520f278ced8e53b9" translate="yes" xml:space="preserve">
          <source>Given both a hostname and service name, this function attempts to resolve the host name into a list of network addresses, and the service name into a protocol and port number, and then returns a list of address structures suitable to connect() to it.</source>
          <target state="translated">호스트 이름과 서비스 이름이 모두 주어지면이 함수는 호스트 이름을 네트워크 주소 목록으로, 서비스 이름을 프로토콜 및 포트 번호로 확인한 다음 connect ()에 적합한 주소 구조 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef7becd595d52be668be1e1f52b6edfa071be390" translate="yes" xml:space="preserve">
          <source>Given just a host name, this function attempts to resolve it to a list of network addresses, and then returns a list of address structures giving these addresses.</source>
          <target state="translated">호스트 이름 만 지정하면이 함수는 호스트 이름을 네트워크 주소 목록으로 확인한 다음 해당 주소를 제공하는 주소 구조 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="df00cd802473947a22a033a5fee10eaeb326c652" translate="yes" xml:space="preserve">
          <source>Given just a service name, this function attempts to resolve it to a protocol and port number, and then returns a list of address structures that represent it suitable to bind() to. This use should be combined with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag; see below.</source>
          <target state="translated">서비스 이름 만 지정하면이 함수는 해당 서비스를 프로토콜 및 포트 번호로 확인한 다음 bind ()에 적합한 주소 구조 목록을 리턴합니다. 이 사용은 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 플래그 와 결합되어야합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47c398084bf96dcff46eefda9cdadf3fedccfe90" translate="yes" xml:space="preserve">
          <source>Given neither name, it generates an error.</source>
          <target state="translated">이름이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f45002ae2a4c5c351051e308f1722b6d19c35a8d" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;IO::Socket&lt;/code&gt; doesn't have attributes in the traditional sense, the following arguments, rather than attributes, can be passed into the constructor.</source>
          <target state="translated">&lt;code&gt;IO::Socket&lt;/code&gt; 에 전통적인 의미의 속성이 없다는 점을 감안할 때 속성이 아닌 다음 인수를 생성자에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4946a614ce699917e8a48264ad588e74a71edfe3" translate="yes" xml:space="preserve">
          <source>Given that the file glob is just a cut-down regular expression and that it has already done a lot of the hard work in pattern matching the filenames, wouldn't it be handy to be able to use the patterns in the fileglob to drive the new filename?</source>
          <target state="translated">파일 glob은 단순한 정규 표현식이며 파일 이름과 일치하는 패턴에서 많은 노력을 이미했다는 것을 감안할 때 fileglob의 패턴을 사용하여 새로운 파일명?</target>
        </trans-unit>
        <trans-unit id="1a0688e5deb209d4898cf79e8c4e93da364593b3" translate="yes" xml:space="preserve">
          <source>Given that we failed to load &lt;code&gt;Compress::Zlib&lt;/code&gt; and that the use of an external</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; 를로드하지 못하고 외부 사용을 가정 한 경우</target>
        </trans-unit>
        <trans-unit id="5ce5ab9c8a60a3017b27b9d131c486b0a52e2973" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;TAP::Parser::Scheduler::Job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">테스트의 파일 이름과 설명이 스칼라로 주어지면 새로운 &lt;a href=&quot;TAP::Parser::Scheduler::Job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="25d0946db041e6b8ec000e3934554230eea3d997" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">테스트의 파일 이름과 설명이 스칼라로 주어지면 새 &lt;a href=&quot;job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8321e912ffb7fc1712a163f5114b8b8cfc71ea6c" translate="yes" xml:space="preserve">
          <source>Given the following module, PerlIO::via::Hex :</source>
          <target state="translated">다음 모듈이 주어지면 PerlIO :: via :: Hex :</target>
        </trans-unit>
        <trans-unit id="b1732b671f9a08843781c433880de7a9be2cae19" translate="yes" xml:space="preserve">
          <source>Given the following notations:</source>
          <target state="translated">다음과 같은 표기법이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="d2cba25d77a3267a4c7e81b67be7cfba4a549ed5" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad.</source>
          <target state="translated">어휘 변수의 이름이 주어지면 현재 컴파일중인 패드에서 해당 위치를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ddfa3d7772a86897b1ef912922a5efcc3e61e15d" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad. &lt;code&gt;namepv&lt;/code&gt;/&lt;code&gt;namelen&lt;/code&gt; specify the variable's name, including leading sigil. &lt;code&gt;flags&lt;/code&gt; is reserved and must be zero. If it is not in the current pad but appears in the pad of any lexically enclosing scope, then a pseudo-entry for it is added in the current pad. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if no such lexical is in scope.</source>
          <target state="translated">어휘 변수의 이름이 주어지면 현재 컴파일하는 패드에서 해당 위치를 찾습니다. &lt;code&gt;namepv&lt;/code&gt; / &lt;code&gt;namelen&lt;/code&gt; 은 선행시길을 포함하여 변수의 이름을 지정합니다. &lt;code&gt;flags&lt;/code&gt; 는 예약되어 있으며 0이어야합니다. 현재 패드에는 없지만 어휘로 둘러싸는 범위의 패드에 나타나면 해당 가상 항목이 현재 패드에 추가됩니다. 현재 패드의 오프셋을 반환하거나 해당 어휘가 범위에없는 경우 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e332da4ace4bc5d01c9ceda2ce9f67dcc253135" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set,</source>
          <target state="translated">optree의 루트가 주어지면 &lt;code&gt;op_next&lt;/code&gt; 포인터를 사용하여 실행 순서대로 트리를 연결하고 실행 된 첫 번째 op를 반환하십시오. 이 작업이 이미 완료된 경우 다시 실행되지 않으며 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 가 반환됩니다. 경우 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 이미 설정되어 있지 않은,</target>
        </trans-unit>
        <trans-unit id="97fc21e2d92a8ed7b6cc7a68fbab927d533b3225" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set, &lt;code&gt;o&lt;/code&gt; should be at least an &lt;code&gt;UNOP&lt;/code&gt;.</source>
          <target state="translated">optree의 루트가 주어지면 &lt;code&gt;op_next&lt;/code&gt; 포인터를 사용하여 실행 순서대로 트리를 연결하고 실행 된 첫 번째 작업을 반환합니다. 이 작업이 이미 수행 된 경우 다시 수행되지 않고 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 가 반환됩니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 경우 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 아직 설정되어 있지 않은, &lt;code&gt;o&lt;/code&gt; 적어도되어야 &lt;code&gt;UNOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="084725aa23e7fe3c0d543b97b1c7320210101746" translate="yes" xml:space="preserve">
          <source>Given the sheer volume of Perl documentation, this isn't a trivial undertaking, but if you can point to documentation that suggests the behaviour you're seeing is</source>
          <target state="translated">펄 문서의 많은 양을 감안할 때 이것은 사소한 일이 아니지만보고있는 행동을 암시하는 문서를 가리킬 수 있다면</target>
        </trans-unit>
        <trans-unit id="a51193d192cf9332f4f5d4257e036cab9b0cff3c" translate="yes" xml:space="preserve">
          <source>Given this as an input string in a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; would correctly return the string &quot;&amp;lt;&amp;lt;'EOMSG'\nThis is the message.\nEOMSG&quot;, leaving the string &quot; || die;\nexit;&quot; in the original variable. In other words, the two separate pieces of the here document are successfully extracted and concatenated.</source>
          <target state="translated">이를 스칼라 컨텍스트에서 입력 문자열로 지정하면 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 문자열 &quot;&amp;lt;&amp;lt; 'EOMSG'\ n이 메시지입니다. \ nEOMSG&quot;를 반환하고 문자열 &quot;|| die; \ nexit;&quot; 원래 변수에서. 다시 말해, 여기 문서의 두 개의 분리 된 조각이 성공적으로 추출되고 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a8255eb67db18215cafd66b8bf6854ff058e58c2" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; , giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">두 개의 perl 버전이 주어지면 코어 모듈 내용의 변경 사항을 설명하는 쌍 목록을 반환합니다. 이 목록은 해시에 저장하기에 적합합니다. 키는 라이브러리 이름이고 값은 해시 참조입니다. 각 해시 참조에는 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 중 하나 또는 둘 다에 대한 항목이 있으며 각 왼쪽 및 오른쪽 perl 분포의 라이브러리 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5524306bde34808c7bf3694140f34edc02ea15fa" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;, giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">두 개의 perl 버전이 주어지면 두 버전 사이의 핵심 모듈 콘텐츠 변경 사항을 설명하는 쌍 목록이 반환됩니다. 이 목록은 해시에 저장하는 데 적합합니다. 키는 라이브러리 이름이고 값은 해시 참조입니다. 각 해시 참조에는 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 중 하나 또는 둘 모두에 대한 항목이 있으며 각 왼쪽 및 오른쪽 펄 배포판의 라이브러리 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3e8e0d7ce171e4fc80eeb08f47d5a4cc76a6ae2" translate="yes" xml:space="preserve">
          <source>Given two versions of perl, this prints a human-readable table of all module changes between the two. The output format may change in the future, and is meant for</source>
          <target state="translated">두 가지 버전의 perl이 주어지면 두 모듈 사이의 모든 모듈 변경 사항을 사람이 읽을 수있는 표로 인쇄합니다. 출력 형식은 향후 변경 될 수 있으며</target>
        </trans-unit>
        <trans-unit id="d8e6036259b26c2d9989b981df7306264ca46f69" translate="yes" xml:space="preserve">
          <source>Gives a description of each test prior to performing it.</source>
          <target state="translated">수행하기 전에 각 테스트에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="95e8be14901e94fb491dfdf5b70ee1b95c0f63d7" translate="yes" xml:space="preserve">
          <source>Gives more detailed information about each test, after it has been performed. Note that any failed tests ought to print out some extra information whether or not -v is thrown.</source>
          <target state="translated">각 테스트가 수행 된 후 각 테스트에 대한 자세한 정보를 제공합니다. 실패한 테스트는 -v의 발생 여부에 관계없이 몇 가지 추가 정보를 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cd5accb9bbe824d3f2172984bdf0c7f749a0330" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt; . The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">&lt;code&gt;&amp;amp;xsub&lt;/code&gt; 에 의해 바인드 된 C 함수를 포함하는 DLL 또는 Perl DLL에 대한 정보를 제공합니다 . &lt;code&gt;how&lt;/code&gt; 의 의미 : 기본 (2) : 이름; 0 : 핸들; 1 : 모듈 이름.</target>
        </trans-unit>
        <trans-unit id="1bcbcfb87cf34f833fbb8de6ef0d85359b318960" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt;. The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">&lt;code&gt;&amp;amp;xsub&lt;/code&gt; 에 의해 바인딩 된 C 함수를 포함하는 Perl DLL 또는 DLL에 대한 정보를 제공합니다 . &lt;code&gt;how&lt;/code&gt; 의 의미 는 다음과 같습니다. 기본값 (2) : 전체 이름; 0 : 핸들; 1 : 모듈 이름.</target>
        </trans-unit>
        <trans-unit id="9ce00937b225bda0f6de7705049c711ca2d0c0b1" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; , which is faster.</source>
          <target state="translated">stringify 과부하가 없을 때와 같이 &lt;code&gt;arg&lt;/code&gt; 의 문자열 값을 제공합니다 . 이것을 사용하여 참조 주소를 가져 오는 경우 (두 참조가 같은 것을 가리키는 지 확인하는 데 유용) &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="775ccd199d054693bedf24e4232707e8971068ab" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;, which is faster.</source>
          <target state="translated">stringify 오버로딩이 없을 때 &lt;code&gt;arg&lt;/code&gt; 의 문자열 값을 제공합니다 . 이것을 사용하여 참조의 주소를 얻는 경우 (두 참조가 동일한 것을 가리키는 지 확인하는 데 유용함) &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 을 사용하는 것이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe98f7aeaa456c4237c94f0fd4653d71593c9bc" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt; .</source>
          <target state="translated">이전 답변에 사용 된 힌트 유형을 제공합니다. &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; 또는 &lt;code&gt;previous&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d2e6ac68dbbd284c2f353cd0f92f42c6bd450f0" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt;.</source>
          <target state="translated">이전 답변에 사용 된 힌트 유형을 제공합니다. &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; 또는 &lt;code&gt;previous&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d71dccbe06d617b4160092d77a20fffa36b965b4" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt; .</source>
          <target state="translated">구조체에 클래스 타입 인 구조체 요소를 제공하는 것은 구조체가 중첩되는 방법입니다. 여기서 &lt;code&gt;Timeval&lt;/code&gt; 은 시간 (초 및 마이크로 초)을 &lt;code&gt;Rusage&lt;/code&gt; 에는 두 가지 요소가 있으며 각 요소는 &lt;code&gt;Timeval&lt;/code&gt; 유형 입니다 .</target>
        </trans-unit>
        <trans-unit id="c05c0b34dc6bfd6214a8b97afd38b066294f5abb" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt;.</source>
          <target state="translated">구조체 요소에 구조체 인 클래스 유형을 제공하는 것은 구조체가 중첩되는 방식입니다. 여기서 &lt;code&gt;Timeval&lt;/code&gt; 은 시간 (초 및 마이크로 초)을 &lt;code&gt;Rusage&lt;/code&gt; 에는 각각 &lt;code&gt;Timeval&lt;/code&gt; 유형의 두 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d166f9da4bac6d857f7dc131be5d65de1b02def6" translate="yes" xml:space="preserve">
          <source>Giving additional meanings to a symbol or construct. Actually, all languages do overloading to one extent or another, since people are good at figuring out things from &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">심볼이나 구성에 추가적인 의미를 부여합니다. 사실, 사람들은 &lt;b&gt;문맥&lt;/b&gt; 으로부터 사물을 파악하는 데 능숙하기 때문에 모든 언어가 어느 정도 오버로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8b8f975ca429de01bb46828d5e9ad364deeb90c" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">에 대한 잘못된 값주기 &lt;code&gt;$sock_type&lt;/code&gt; 것 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10109e20d3ef4e69e4ba1f7e5c674f9df95fc01e" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="translated">에 대한 잘못된 값주기 &lt;code&gt;$sock_type&lt;/code&gt; 것 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f57f0ea36677c92cf9afe99cb8959d03cc0961e" translate="yes" xml:space="preserve">
          <source>Giving up control</source>
          <target state="translated">통제권 부여</target>
        </trans-unit>
        <trans-unit id="ac34b82dc93bde9b29a5a3004c3ddbeef7e257a6" translate="yes" xml:space="preserve">
          <source>Glob elements can be extracted through the postfix dereferencing feature:</source>
          <target state="translated">접미사 역 참조 기능을 통해 전역 요소를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6641c458cc0583d3613a6a86e40173a73aab142" translate="yes" xml:space="preserve">
          <source>Glob not terminated</source>
          <target state="translated">Glob이 종료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a2bba5393d5751445bbbac73e8d2d26ee97a6c53" translate="yes" xml:space="preserve">
          <source>Glob-style pattern matching for rules</source>
          <target state="translated">규칙에 대한 전역 스타일 패턴 일치</target>
        </trans-unit>
        <trans-unit id="586c371162ed972fff02dbee194ab54579306095" translate="yes" xml:space="preserve">
          <source>Global DLLs</source>
          <target state="translated">글로벌 DLL</target>
        </trans-unit>
        <trans-unit id="f4853985ae8961c644b701f3a4211e427659afca" translate="yes" xml:space="preserve">
          <source>Global Destruction</source>
          <target state="translated">글로벌 파괴</target>
        </trans-unit>
        <trans-unit id="d4326c5fc3d6b26143e4368742fe314ae01c47ca" translate="yes" xml:space="preserve">
          <source>Global Overriding</source>
          <target state="translated">글로벌 재정의</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="2cbdcda340ba1e2e7ca0ffb07cf96cf77ae074ef" translate="yes" xml:space="preserve">
          <source>Global buffers requested for the file</source>
          <target state="translated">파일에 대해 요청 된 전역 버퍼</target>
        </trans-unit>
        <trans-unit id="c74b56bb1057578230abe272aa56e202301adbc0" translate="yes" xml:space="preserve">
          <source>Global destruction.</source>
          <target state="translated">세계적인 파괴.</target>
        </trans-unit>
        <trans-unit id="e7f5c9eb53159b83da104e3bda376cd7346692a8" translate="yes" xml:space="preserve">
          <source>Global matching</source>
          <target state="translated">글로벌 매칭</target>
        </trans-unit>
        <trans-unit id="a872e74ca2223071a991a7dc6c5ea6db791004e6" translate="yes" xml:space="preserve">
          <source>Global state maintained by XSUBs</source>
          <target state="translated">XSUB에 의해 유지되는 글로벌 상태</target>
        </trans-unit>
        <trans-unit id="4e13a92f72eb76d8c508c2dc21b04feb11b16eff" translate="yes" xml:space="preserve">
          <source>Global symbol &quot;%s&quot; requires explicit package name (did you forget to declare &quot;my %s&quot;?)</source>
          <target state="translated">전역 기호 &quot;% s&quot;에는 명시적인 패키지 이름이 필요합니다 ( &quot;my % s&quot;선언을 잊었습니까?)</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="3650821866c81f2ac2894b41d87da9c715e1e8ce" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">저장 가능한 AnyDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="4909b3a46d83dbbf52b8710b4dc26c66ca78944e" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">저장 가능 사용을 위해 NDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="d57f000cec87f12e43b8b27b36323279bd6bf351" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">저장 가능 사용을 위해 SDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="1ef566e266fcd5938f2e20f4951576b582c8951b" translate="yes" xml:space="preserve">
          <source>Go and write your program. Everywhere in your program where you would say:</source>
          <target state="translated">가서 프로그램을 작성하십시오. 프로그램의 모든 곳에서 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="17a5012f10d8e9cdb0ba165e243a06151fb8f234" translate="yes" xml:space="preserve">
          <source>Go into the newly-created directory and type:</source>
          <target state="translated">새로 작성된 디렉토리로 이동하여 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="bb969927295c4c8629a766337faf9d2987763158" translate="yes" xml:space="preserve">
          <source>Goal #1:</source>
          <target state="translated">목표 # 1 :</target>
        </trans-unit>
        <trans-unit id="efa364708854c41e2aaf01b89a8ca544d0591051" translate="yes" xml:space="preserve">
          <source>Goal #2:</source>
          <target state="translated">목표 # 2 :</target>
        </trans-unit>
        <trans-unit id="05beafe9dca70a4a92356525cf080da1fcabd65d" translate="yes" xml:space="preserve">
          <source>Goal #3:</source>
          <target state="translated">목표 # 3 :</target>
        </trans-unit>
        <trans-unit id="ba9eecdd12afc7f1400662096cf586f7f0a2f8e4" translate="yes" xml:space="preserve">
          <source>Goal #4:</source>
          <target state="translated">목표 # 4 :</target>
        </trans-unit>
        <trans-unit id="e84961568f47f9182f766681bff3b6dd90dcc10a" translate="yes" xml:space="preserve">
          <source>Going forward, specification version numbers will be integers and decimal portions will correspond to a release date for the CPAN::Meta library.</source>
          <target state="translated">앞으로 사양 버전 번호는 정수이고 소수점은 CPAN :: Meta 라이브러리의 출시 날짜에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="29c6ec10417b35abc144d3f4a0729c76abf5e284" translate="yes" xml:space="preserve">
          <source>Going past the 70th column in a verbatim block might be ungracefully wrapped by some formatters.</source>
          <target state="translated">축약 형 블록에서 70 번째 열을지나 가면 일부 포매터가 비정상적으로 랩핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">좋은 습관</target>
        </trans-unit>
        <trans-unit id="7d80a18b9b9c68e6a7c1c8a8d0dbf303700b7763" translate="yes" xml:space="preserve">
          <source>Good example:</source>
          <target state="translated">좋은 예 :</target>
        </trans-unit>
        <trans-unit id="4143405b286941b2e4ea2b9f669d260327d04f9b" translate="yes" xml:space="preserve">
          <source>Good for tracking down why things don't work with your particular setup.</source>
          <target state="translated">특정 설정에서 작동하지 않는 이유를 추적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f73c69efaf3df1b92a97b27aa347eb13fea306c3" translate="yes" xml:space="preserve">
          <source>Good patches (tight code, complete, correct) stand more chance of going in. Sloppy or incorrect patches might be placed on the back burner until the pumpking has time to fix, or might be discarded altogether without further notice.</source>
          <target state="translated">좋은 패치 (긴밀한 코드, 완전하고 정확한)는 들어갈 가능성이 더 높습니다. 호박이 고칠 시간이되거나 더 이상 예고없이 폐기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e99dfa2e51dca66243d416a2cf4eff66499d06" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; and &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">기존 모듈을 찾기에 좋은 곳은 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 및 &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org를&lt;/a&gt; 포함 하고 &lt;code&gt;module-authors@perl.org&lt;/code&gt; ( &lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list&lt;/a&gt; 에 문의)를 포함합니다 . /module-authors.html ).</target>
        </trans-unit>
        <trans-unit id="2204cbb75fbcc2f7a7c3bd131ef1fc6ce9423848" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;https://metacpan.org&quot;&gt;MetaCPAN&lt;/a&gt; and &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">기존 모듈을 찾을 수있는 좋은 장소로는 &lt;a href=&quot;https://metacpan.org&quot;&gt;MetaCPAN&lt;/a&gt; 및 &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN이&lt;/a&gt; 있으며 &lt;code&gt;module-authors@perl.org&lt;/code&gt; ( &lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt; ) 에 문의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1707029b59612c93d147b82e0c5b435886ce180c" translate="yes" xml:space="preserve">
          <source>Gory details of parsing quoted constructs</source>
          <target state="translated">인용 된 구문 분석 구문 분석 세부 사항</target>
        </trans-unit>
        <trans-unit id="bbd8ec1cd2d79b0a075cc6f6de1b4a7f725a4726" translate="yes" xml:space="preserve">
          <source>Got an error from DosAllocMem</source>
          <target state="translated">DosAllocMem에서 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="23f16c19388eabd103562554c9bfa091b6dac302" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; .</source>
          <target state="translated">알았어? Perl 5.8.7에서 &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; 은 현재 의미에서 UTF-8을 의미하며, 이는 보수적이고 엄격하며 보안을 &lt;b&gt;중요시합니다. &quot;utf8&quot;&lt;/b&gt; 은 이전 의미에서 자유롭고 느슨한 UTF-8을 의미합니다. lax. 따라서 버전 2.10 이상을 &lt;code&gt;Encode&lt;/code&gt; 하면 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 미묘하지만 중요한 차이점이 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="90ebaa561920aa9c2dc9e089697bca34ce37bae3" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;.</source>
          <target state="translated">알았어? Perl 5.8.7에서 &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; 은 보수적이고 엄격하며 보안에 민감한 현재 의미에서 UTF-8을 의미하는 반면 &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; 은 이전 의미에서 자유롭고 느슨했던 UTF-8을 의미합니다. 느슨하다. &lt;code&gt;Encode&lt;/code&gt; 버전 2.10 이상은 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 사이의 미묘하지만 매우 중요한 차이를 더욱 심화시킵니다 .</target>
        </trans-unit>
        <trans-unit id="0b4fc0a0d78b25de463f95089769282373893971" translate="yes" xml:space="preserve">
          <source>Got that? Larry is always right, even when he was wrong. It's rare to see either Rule exercised, but they are often alluded to.</source>
          <target state="translated">알았어? 래리는 그가 틀렸을 때에도 항상 옳습니다. 어느 규칙도 행사되는 것을보기는 쉽지 않지만 종종 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="ca69ac23523fe10118230a18e01d42c76c8abcda" translate="yes" xml:space="preserve">
          <source>Goto celib-palm-3.0\inc\cewin32.h, search for</source>
          <target state="translated">celib-palm-3.0 \ inc \ cewin32.h로 이동하여</target>
        </trans-unit>
        <trans-unit id="a85e9c5d6dac87806ef2eaf1d93698fc48760a76" translate="yes" xml:space="preserve">
          <source>Goto undefined subroutine%s</source>
          <target state="translated">정의되지 않은 서브 루틴 % s로 이동</target>
        </trans-unit>
        <trans-unit id="5890e910925d55654694f7ac1d42c03b68abbff2" translate="yes" xml:space="preserve">
          <source>Gotta have a plan!</source>
          <target state="translated">계획이있어!</target>
        </trans-unit>
        <trans-unit id="df8da02e8026798b67902a6787a5e32f5d1a8e68" translate="yes" xml:space="preserve">
          <source>Gprof Profiling</source>
          <target state="translated">Gprof 프로파일 링</target>
        </trans-unit>
        <trans-unit id="55ce61dea540285b5729c947a17f82efa2f6d1fa" translate="yes" xml:space="preserve">
          <source>Grafts</source>
          <target state="translated">Grafts</target>
        </trans-unit>
        <trans-unit id="3259bccd5547a6fb8f77a4aaea022a14a41cb136" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;</source>
          <target state="translated">그레이엄 바 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42879164d6188855410d722427bd053e05e54ab7" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">그레이엄 바 &amp;lt;gbarr@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3732fa7e665009645e9e3e4379dd15edc1deb872" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04f7ed11e65f8179b2c21de31c70c0e5a2b54f2f" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7820aa7c6db183e706a7e84c2116e052f42811c0" translate="yes" xml:space="preserve">
          <source>Graham Barr, the original Configure script of libnet.</source>
          <target state="translated">libnet의 원래 구성 스크립트 인 Graham Barr</target>
        </trans-unit>
        <trans-unit id="6433e49daadbc911a68d39c3c194d36d03e3dce3" translate="yes" xml:space="preserve">
          <source>Graham Barr. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">그레이엄 바. 현재 Perl Porter가 관리합니다. 모든 버그를 &amp;lt;perlbug@perl.org&amp;gt;에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="87a1ea2f5e9ab380ccaeb3b75aeec67585ecc358" translate="yes" xml:space="preserve">
          <source>Graham Barr. atmark() by Lincoln Stein. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">그레이엄 바. Lincoln Stein의 atmark (). 현재 Perl Porter가 관리합니다. 모든 버그를 &amp;lt;perlbug@perl.org&amp;gt;에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="851fd61fa3fb1f5808ef8c8f9dd236974160fdad" translate="yes" xml:space="preserve">
          <source>Graham Knop &amp;lt;haarg@haarg.org&amp;gt;</source>
          <target state="translated">그레이엄 노브 &amp;lt;haarg@haarg.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb9ba6977c2fe4e9f6adc9a0ece5aa2b87ae637" translate="yes" xml:space="preserve">
          <source>Graham Ollis &amp;lt;plicease@cpan.org&amp;gt;</source>
          <target state="translated">그레이엄 올리 스 &amp;lt;plicease@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="ca8c988917ca583e838e2647bffdc0dd152b9fb8" translate="yes" xml:space="preserve">
          <source>Grammatical note on local()</source>
          <target state="translated">local ()에 대한 문법 노트</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="844b43fd71cbef7f18e867fe292f5c5684e1ab12" translate="yes" xml:space="preserve">
          <source>Great care is necessary when defining the command if quoting needs to be done. For instance, you would need to say:</source>
          <target state="translated">인용이 필요한 경우 명령을 정의 할 때 각별한주의가 필요합니다. 예를 들어, 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="4902a456caa9a4eab463ce526c9df0f6180be184" translate="yes" xml:space="preserve">
          <source>Greece</source>
          <target state="translated">Greece</target>
        </trans-unit>
        <trans-unit id="aacdfd21674e83c3c0b99f5359b19144d7666c82" translate="yes" xml:space="preserve">
          <source>Gregor Hermann &amp;lt;gregoa@debian.org&amp;gt;</source>
          <target state="translated">그레고르 헤르만 &amp;lt;gregoa@debian.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8c5e7d8a89c7b18aac43a9485b1546ac5b284f75" translate="yes" xml:space="preserve">
          <source>Group ID&amp;mdash;in Unix, the numeric group ID that the &lt;b&gt;operating system&lt;/b&gt; uses to identify you and members of your &lt;b&gt;group&lt;/b&gt;.</source>
          <target state="translated">그룹 ID&amp;mdash;Unix에서 &lt;b&gt;운영 체제&lt;/b&gt; 가 사용자와 &lt;b&gt;그룹&lt;/b&gt; 구성원을 식별하는 데 사용 하는 숫자 그룹 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="16a718e915556d62f893e87ee82787d36995c7e4" translate="yes" xml:space="preserve">
          <source>Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">그룹 Perl의 기능은 la perlfunc.pod</target>
        </trans-unit>
        <trans-unit id="893d792c6d1b1a9f4d49b51e99c5345d804a3939" translate="yes" xml:space="preserve">
          <source>Group name must start with a non-digit word character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">그룹 이름은 정규식에서 숫자가 아닌 단어 문자로 시작해야합니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="ba2d2b2b97d3fc7cff00f1012c3e7d17c04c2768" translate="yes" xml:space="preserve">
          <source>Group of languages collectively called &quot;Otom&amp;iacute;&quot;.</source>
          <target state="translated">&quot;Otom&amp;iacute;&quot;로 통칭 된 언어 그룹.</target>
        </trans-unit>
        <trans-unit id="2bfcba6c579bd2ce1f3564ea422bb81f6281834e" translate="yes" xml:space="preserve">
          <source>Group ownership of directories that already exist will not be changed.</source>
          <target state="translated">이미 존재하는 디렉토리의 그룹 소유권은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb77c777665eaa5c9fc03cd1712f2d2993483948" translate="yes" xml:space="preserve">
          <source>Group ownwership of directories that already exist will not be changed.</source>
          <target state="translated">이미 존재하는 디렉토리의 그룹 소유권은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc00408fdf05ce5150089b75b75b23c46962261d" translate="yes" xml:space="preserve">
          <source>Grouping things and hierarchical matching</source>
          <target state="translated">사물 그룹화 및 계층 적 일치</target>
        </trans-unit>
        <trans-unit id="fee5f710c9ba7310f55f4c68e3911ad898f334f8" translate="yes" xml:space="preserve">
          <source>Growing Your Own</source>
          <target state="translated">자신의 성장</target>
        </trans-unit>
        <trans-unit id="fe293b21525de44a2e12eb8c0027d2290b7e1a71" translate="yes" xml:space="preserve">
          <source>Gtk and Gtk2</source>
          <target state="translated">Gtk 및 Gtk2</target>
        </trans-unit>
        <trans-unit id="7864c5c65bb01ac0a14a3115852b7c02219c584f" translate="yes" xml:space="preserve">
          <source>Guaran&amp;iacute;</source>
          <target state="translated">Guaran&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="23ca9988de5733d8c8247a3e4e4982df4f209ed4" translate="yes" xml:space="preserve">
          <source>Guess the name of this package by examining the working directory's name. MakeMaker calls this only if the developer has not supplied a NAME attribute.</source>
          <target state="translated">작업 디렉토리의 이름을 조사하여이 패키지의 이름을 추측하십시오. MakeMaker는 개발자가 NAME 속성을 제공하지 않은 경우에만이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="07aa51a012723e8368dc093b343c1ff642baa052" translate="yes" xml:space="preserve">
          <source>Guess.U</source>
          <target state="translated">Guess.U</target>
        </trans-unit>
        <trans-unit id="b6684e2eba17124bde1d0355e24c5684aef1bed6" translate="yes" xml:space="preserve">
          <source>Guesses encoding from data</source>
          <target state="translated">데이터에서 인코딩을 추측</target>
        </trans-unit>
        <trans-unit id="73b139c37c0097cfe3599d3082c96b0c2aee8d6a" translate="yes" xml:space="preserve">
          <source>Guidelines for Converting Perl 4 Library Scripts into Modules</source>
          <target state="translated">Perl 4 라이브러리 스크립트를 모듈로 변환하기위한 지침</target>
        </trans-unit>
        <trans-unit id="c758bdbdcf1ca454825428e4f69546fbfdaf18d9" translate="yes" xml:space="preserve">
          <source>Guidelines for Module Creation</source>
          <target state="translated">모듈 생성 지침</target>
        </trans-unit>
        <trans-unit id="5fc6aecec704586c9198ddc6d24910690ea4c4e4" translate="yes" xml:space="preserve">
          <source>Guidelines for Reusing Application Code</source>
          <target state="translated">응용 프로그램 코드 재사용 지침</target>
        </trans-unit>
        <trans-unit id="b1f36e56060bf112e405cf82b761c5b4b96e7caf" translate="yes" xml:space="preserve">
          <source>Guillem Jover &amp;lt;guillem@hadrons.org&amp;gt;</source>
          <target state="translated">Guillem Jover &amp;lt;guillem@hadrons.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9f22068b470b55c5659b24a529d486d165efe1e8" translate="yes" xml:space="preserve">
          <source>Gulliver's Travels</source>
          <target state="translated">걸리버 여행기</target>
        </trans-unit>
        <trans-unit id="d3d42475682a0666adb5abe77243023160ef0a45" translate="yes" xml:space="preserve">
          <source>Gunzip/gzip for OS/390 is discussed at:</source>
          <target state="translated">OS / 390 용 Gunzip / gzip은 다음에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="93a0fe097041b93e0be65ee154daffc6b1381bc9" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</source>
          <target state="translated">구루 사미 사라 티 &amp;lt;gsar@activestate.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d960951b2cdfc9f9204beae43f12a4a11b295b41" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy gsar@activestate.com</source>
          <target state="translated">Gurusamy Sarathy gsar@activestate.com</target>
        </trans-unit>
        <trans-unit id="7c88e96e80542c5ab8c25d94ba78c38a9434f36e" translate="yes" xml:space="preserve">
          <source>GvAV</source>
          <target state="translated">GvAV</target>
        </trans-unit>
        <trans-unit id="93e9014719ba7dd6bd9c9a5946fe1b93538edf1f" translate="yes" xml:space="preserve">
          <source>GvCV</source>
          <target state="translated">GvCV</target>
        </trans-unit>
        <trans-unit id="aafef8d6561e3651edafc5890e67e14dff424872" translate="yes" xml:space="preserve">
          <source>GvHV</source>
          <target state="translated">GvHV</target>
        </trans-unit>
        <trans-unit id="f991fe9870fc45fa7b0143b9ae1b6bc1ca3392d4" translate="yes" xml:space="preserve">
          <source>GvREFCNT</source>
          <target state="translated">GvREFCNT</target>
        </trans-unit>
        <trans-unit id="f6f249bdd6a51ddf7f142e9b9a80faa131f6974a" translate="yes" xml:space="preserve">
          <source>GvSV</source>
          <target state="translated">GvSV</target>
        </trans-unit>
        <trans-unit id="ddf1c563576d03de876ebbb0aae2f006c136dc9f" translate="yes" xml:space="preserve">
          <source>Gv_AMupdate</source>
          <target state="translated">Gv_AMupdate</target>
        </trans-unit>
        <trans-unit id="5351767f64737ac06c8bff705b0350e3b12bf9fe" translate="yes" xml:space="preserve">
          <source>Gzip Resources</source>
          <target state="translated">Gzip 리소스</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="db954ca5c29d07dccf4b2cd89bd036d330b99ae8" translate="yes" xml:space="preserve">
          <source>H -number</source>
          <target state="translated">H 번호</target>
        </trans-unit>
        <trans-unit id="c6779059ab26129a6e380e0ef513d4df3cbdbef7" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="translated">H.Merijn 브랜드 &amp;lt;hmbrand@xs4all.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="58edf605e14f939b5061c16becc3c237b2cf3c47" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</source>
          <target state="translated">H.Merijn 브랜드 &amp;lt;hmbrand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="47ce9e7227c5c88413414b245a64737d1d7aa032" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;autoflush( EXPR )</source>
          <target state="translated">핸들-&amp;gt; 자동 플러시 (EXPR)</target>
        </trans-unit>
        <trans-unit id="e39692187e35b8d86da8462f683967a48317dea2" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_left(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_left(EXPR)</target>
        </trans-unit>
        <trans-unit id="209a918918c25cd99d83f2f0dbbc4f467dc693f1" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_per_page(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_per_page(EXPR)</target>
        </trans-unit>
        <trans-unit id="f1d2f9361bebc33157aeedef49dc5f8e73598847" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="0c9bdf53fa0c2bc01c5c44ec8066b07d741898ab" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_page_number(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_page_number(EXPR)</target>
        </trans-unit>
        <trans-unit id="7462f62c1d1e40bafc8b07b413de84a660ada74e" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_top_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_top_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="69f09f09d96a3982a3608cf0a03c946ae72aee61" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;input_line_number( EXPR )</source>
          <target state="translated">핸들-&amp;gt; 입력 _ 라인 _ 번호 (EXPR)</target>
        </trans-unit>
        <trans-unit id="db41c0239e45c0e3b7059c151c4adb6338795f77" translate="yes" xml:space="preserve">
          <source>HANDLE_FLAG_INHERIT</source>
          <target state="translated">HANDLE_FLAG_INHERIT</target>
        </trans-unit>
        <trans-unit id="c8a128a1c9ef12c12e3c9fff40e91e634c10d778" translate="yes" xml:space="preserve">
          <source>HANDLE_FLAG_PROTECT_FROM_CLOSE</source>
          <target state="translated">HANDLE_FLAG_PROTECT_FROM_CLOSE</target>
        </trans-unit>
        <trans-unit id="f8435efca06ef2ecdd8e0b507cc5cef4ba204c42" translate="yes" xml:space="preserve">
          <source>HARDLINK</source>
          <target state="translated">HARDLINK</target>
        </trans-unit>
        <trans-unit id="789c59b41e5418de142d321c95b023de4bdfe79e" translate="yes" xml:space="preserve">
          <source>HASHES OF ARRAYS</source>
          <target state="translated">배열의 해시</target>
        </trans-unit>
        <trans-unit id="530c7188bb0935938e3b58577815f4334a49e6ef" translate="yes" xml:space="preserve">
          <source>HASHES OF HASHES</source>
          <target state="translated">해시 해시</target>
        </trans-unit>
        <trans-unit id="d3053d5db9cc8cb93b26db3c26c76bdfdff06ace" translate="yes" xml:space="preserve">
          <source>HEADER</source>
          <target state="translated">HEADER</target>
        </trans-unit>
        <trans-unit id="a880c390a6cf41f70f9a43af2b194442bbe8c615" translate="yes" xml:space="preserve">
          <source>HEY</source>
          <target state="translated">HEY</target>
        </trans-unit>
        <trans-unit id="b9cd18c768bfd2083a9ac760b8041edbaa72c7c4" translate="yes" xml:space="preserve">
          <source>HEf_SVKEY</source>
          <target state="translated">HEf_SVKEY</target>
        </trans-unit>
        <trans-unit id="fc5d4b9117ba9e87388174aee4f4970bdfe8d066" translate="yes" xml:space="preserve">
          <source>HH</source>
          <target state="translated">HH</target>
        </trans-unit>
        <trans-unit id="5b8cce18efcb259ac8ee29e1cd21dcc198081fdb" translate="yes" xml:space="preserve">
          <source>HHHH</source>
          <target state="translated">HHHH</target>
        </trans-unit>
        <trans-unit id="d77d0b27955f008358918e195742c4c8208699e1" translate="yes" xml:space="preserve">
          <source>HIGH</source>
          <target state="translated">HIGH</target>
        </trans-unit>
        <trans-unit id="9c2ea135ec1db4f446c806f7895ae6f2c302104a" translate="yes" xml:space="preserve">
          <source>HINTS AND TIPS</source>
          <target state="translated">힌트와 팁</target>
        </trans-unit>
        <trans-unit id="f6dc58f5e8036353a7ac15516c30ac562e23dc26" translate="yes" xml:space="preserve">
          <source>HISTORY</source>
          <target state="translated">HISTORY</target>
        </trans-unit>
        <trans-unit id="d0e8f9a5a2dbdd8722af6ec7f2972e1375fb801e" translate="yes" xml:space="preserve">
          <source>HMAC-SHA-1/224/256/384/512</source>
          <target state="translated">HMAC-SHA-1/224/256/384/512</target>
        </trans-unit>
        <trans-unit id="7731962fb19e09fff22c1be46abc4b02e9ff78eb" translate="yes" xml:space="preserve">
          <source>HOME</source>
          <target state="translated">HOME</target>
        </trans-unit>
        <trans-unit id="687695890e9e2ec947fdeb9bf817e5fc0911f2bf" translate="yes" xml:space="preserve">
          <source>HOOKS</source>
          <target state="translated">HOOKS</target>
        </trans-unit>
        <trans-unit id="a76f8ee2872265eb6fe359928ee6904e71dc9d05" translate="yes" xml:space="preserve">
          <source>HOW IT WORKS</source>
          <target state="translated">작동 방식</target>
        </trans-unit>
        <trans-unit id="e600c98fe8777fa43cea8c7f053ad797f5be4db6" translate="yes" xml:space="preserve">
          <source>HOW TO USE (THE EASY WAY)</source>
          <target state="translated">사용 방법 (쉬운 방법)</target>
        </trans-unit>
        <trans-unit id="cc39d7b9b79bc6d75414a8ad9ee6ee875828738b" translate="yes" xml:space="preserve">
          <source>HOW TO USE (THE HARD WAY)</source>
          <target state="translated">사용 방법 (어려운 방법)</target>
        </trans-unit>
        <trans-unit id="eab9f433c21086a197b4e1c36ca01d70a2e0dffa" translate="yes" xml:space="preserve">
          <source>HOW TO USE MAKETEXT</source>
          <target state="translated">메이크 텍스트를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="6ab52b908787e3ae467e585a2243118089d23d99" translate="yes" xml:space="preserve">
          <source>HP Itanium 2 systems are usually referred to with model description &quot;HP Integrity&quot;.</source>
          <target state="translated">HP Itanium 2 시스템은 일반적으로 &quot;HP Integrity&quot;모델 설명과 함께 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="a35088083875e2de4dedaf2dca0ae84350b5e92b" translate="yes" xml:space="preserve">
          <source>HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ended as shown in the following table:</source>
          <target state="translated">HP PA-RISC 시스템은 일반적으로 모델 설명 &quot;HP 9000&quot;으로 참조됩니다. 이 시리즈의 마지막 CPU는 PA-8900입니다. PA-RISC 아키텍처 시스템에 대한 지원은 다음 표와 같이 공식적으로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e3417f4faadcebc07bb9497031485b632cc05e1" translate="yes" xml:space="preserve">
          <source>HP also ships servers with the 128-bit Itanium processor(s). The cx26x0 is told to have Madison 6. As of the date of this document's last update, the following systems contain Itanium or Itanium 2 chips (this is likely to be out of date):</source>
          <target state="translated">HP는 또한 서버에 128 비트 Itanium 프로세서를 제공합니다. cx26x0에는 Madison 6이 설치되어 있습니다.이 문서의 마지막 업데이트 날짜를 기준으로 다음 시스템에는 Itanium 또는 Itanium 2 칩이 포함되어 있습니다 (오래되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="8d4391f0427fa0cb914bda064998c9b6cf7d23d3" translate="yes" xml:space="preserve">
          <source>HP has a C/C++ static analyzer product for HP-UX caller Code Advisor. (Link not given here because the URL is horribly long and seems horribly unstable; use the search engine of your choice to find it.) The use of the &lt;code&gt;cadvise_cc&lt;/code&gt; recipe with &lt;code&gt;Configure ... -Dcc=./cadvise_cc&lt;/code&gt; (see cadvise &quot;User Guide&quot;) is recommended; as is the use of &lt;code&gt;+wall&lt;/code&gt;.</source>
          <target state="translated">HP에는 HP-UX 호출자 Code Advisor 용 C / C ++ 정적 분석기 제품이 있습니다. (URL이 너무 길고 불안정 해 보이기 때문에 여기에 링크가 제공되지 않았습니다. 원하는 검색 엔진을 사용하여 찾으십시오.) &lt;code&gt;Configure ... -Dcc=./cadvise_cc&lt;/code&gt; 와 함께 &lt;code&gt;cadvise_cc&lt;/code&gt; 레시피 사용 (cadvise &quot;User 가이드 &quot;)가 권장됩니다. &lt;code&gt;+wall&lt;/code&gt; 의 사용과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2d0a2c854fdfe25037f6f2462163a3677a8c0d9a" translate="yes" xml:space="preserve">
          <source>HP has asked the porting centre to move Open Source binaries from /opt to /usr/local, so binaries produced since the start of July 2002 are located in /usr/local.</source>
          <target state="translated">HP는 포팅 센터에 오픈 소스 바이너리를 / opt에서 / usr / local로 이동하도록 요청했으며, 2002 년 7 월 시작 이후 생성 된 바이너리는 / usr / local에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a764a39116b67d584d0e922398f34d8a6157ce49" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing only perl-5.10.1 was available (with 5.16.3 being the latest stable release from the porters point of view).</source>
          <target state="translated">HP 포팅 센터는 고객 요구에 부응하고 오픈 소스 커뮤니티의 업데이트를 릴리스하려고합니다. &quot;최신&quot;은 상대적이지만 사전 컴파일 된 Perl 바이너리를 사용할 수 있다는 것은 명백합니다. 현재로서는 perl-5.10.1 만 사용 가능했습니다 (포터의 관점에서 5.16.3이 가장 안정적인 릴리스 임).</target>
        </trans-unit>
        <trans-unit id="add793b4cd90e315447341dd87e2674b6f6bf947" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing perl-5.10.1 and 5.28.0 were available.</source>
          <target state="translated">HP 포팅 센터는 고객의 요구에 부응하고 오픈 소스 커뮤니티의 업데이트를 릴리스하려고합니다. 사전 컴파일 된 Perl 바이너리를 사용할 수 있다는 것은 분명하지만 &quot;최신&quot;은 상대적입니다. 작성 시점에 perl-5.10.1 및 5.28.0을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbd2af4559edefe4dd19c07c7c19b95825a0430" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset.</source>
          <target state="translated">HP의 HP9000 Unix 시스템은 HP의 자체 정밀 아키텍처 (PA-RISC) 칩에서 실행됩니다. HP-UX는 Motorola MC68000 칩 제품군에서 실행되었지만이 칩이 장착 된 시스템은 더 이상 사용되지 않으며이 문서는 Motorola 칩셋에서 Perl을 컴파일하는 문제를 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="880e3ff3e606f859fc4dde60cd558255e131f001" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset. Even though PA-RISC hardware is not sold anymore, a lot of machines still running on these CPU's can be found in the wild.</source>
          <target state="translated">HP의 HP9000 Unix 시스템은 HP의 자체 정밀 아키텍처 (PA-RISC) 칩에서 실행됩니다. HP-UX는 Motorola MC68000 칩 제품군에서 실행 되곤했지만이 칩이 포함 된 모든 컴퓨터는 상당히 구식이며이 문서에서는 Motorola 칩셋에서 Perl을 컴파일하는 문제를 해결하지 않습니다. PA-RISC 하드웨어는 더 이상 판매되지 않지만 이러한 CPU에서 여전히 실행중인 많은 머신을 야생에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c305ce22fa1ddad5ff6a9a241e6067a9f35cad67" translate="yes" xml:space="preserve">
          <source>HP-UX</source>
          <target state="translated">HP-UX</target>
        </trans-unit>
        <trans-unit id="5d006886dc4fd65e0adca5c8c02c5767eb4d1359" translate="yes" xml:space="preserve">
          <source>HP-UX 11 Y2K patch &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 Patch Bundle&quot; has been reported to break the io/fs test #18 which tests whether utime() can change timestamps. The Y2K patch seems to break utime() so that over NFS the timestamps do not get changed (on local filesystems utime() still works). This has probably been fixed on your system by now.</source>
          <target state="translated">HP-UX 11 Y2K 패치 &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 패치 번들&quot;은 utime ()이 타임 스탬프를 변경할 수 있는지 테스트하는 io / fs 테스트 # 18을 위반하는 것으로보고되었습니다. Y2K 패치는 NFS를 통해 타임 스탬프가 변경되지 않도록 utime ()을 중단하는 것처럼 보입니다 (로컬 파일 시스템에서 utime ()은 여전히 ​​작동 함). 이것은 아마도 지금까지 시스템에서 수정되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="97187cfde6c75a8b8deebd75a13a60ae1c81f420" translate="yes" xml:space="preserve">
          <source>HP-UX 11i documentation on syslog, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 HP-UX 11i 설명서, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed2a9bb260e4ae72bbe1af113a3b7bdf4f05246c" translate="yes" xml:space="preserve">
          <source>HP-UX Kernel Parameters (maxdsiz) for Compiling Perl</source>
          <target state="translated">Perl 컴파일을위한 HP-UX 커널 매개 변수 (maxdsiz)</target>
        </trans-unit>
        <trans-unit id="83019d5a780dd0ff3c9db7fabc3a90c74127c6c2" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the new Itanium processor. This requires the use of a different version of HP-UX (currently 11.23 or 11i v2), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX는 새로운 Itanium 프로세서에서도 실행됩니다. 이를 위해서는 다른 버전의 HP-UX (현재 11.23 또는 11i v2)를 사용해야하며 아래 및 이후 섹션에서 자세히 설명하는 몇 가지 차이점을 제외하고 Perl은 아무런 문제없이 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d125d82d143012eb929f6160766c96e578f0298" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the newer Itanium processor. This requires the use of HP-UX version 11.23 (11i v2) or 11.31 (11i v3), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX는 최신 Itanium 프로세서에서도 실행됩니다. 이를 위해서는 HP-UX 버전 11.23 (11i v2) 또는 11.31 (11i v3)을 사용해야하며 아래 및 이후 섹션에서 자세히 설명하는 몇 가지 차이점을 제외하고 Perl은 문제없이 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fc19e78ac072e943aed407c41f2503cdb482688" translate="yes" xml:space="preserve">
          <source>HP-UX cadvise (Code Advisor)</source>
          <target state="translated">HP-UX cadvise (Code Advisor)</target>
        </trans-unit>
        <trans-unit id="6054c4b79943ef67e4dcb28eb588b66781f366f6" translate="yes" xml:space="preserve">
          <source>HP-UX supports dynamically loadable libraries (shared libraries). Shared libraries end with the suffix .sl. On Itanium systems, they end with the suffix .so.</source>
          <target state="translated">HP-UX는 동적으로로드 가능한 라이브러리 (공유 라이브러리)를 지원합니다. 공유 라이브러리는 접미사 .sl로 끝납니다. Itanium 시스템에서는 접미사 .so로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="b4319bb42f0da477a0906018447c3096d305eb37" translate="yes" xml:space="preserve">
          <source>HP-UX versions</source>
          <target state="translated">HP-UX 버전</target>
        </trans-unit>
        <trans-unit id="0c355dad6ecf8b6970623574fcecedac49554b22" translate="yes" xml:space="preserve">
          <source>HP-UX versions before 10.30 require a separate installation of a POSIX threads library package. Two examples are the HP DCE package, available on &quot;HP-UX Hardware Extensions 3.0, Install and Core OS, Release 10.20, April 1999 (B3920-13941)&quot; or the Freely available PTH package, available on H.Merijn's site (&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt;). The use of PTH will be unsupported in perl-5.12 and up and is rather buggy in 5.11.x.</source>
          <target state="translated">10.30 이전의 HP-UX 버전에는 POSIX 스레드 라이브러리 패키지를 별도로 설치해야합니다. 두 가지 예는 &quot;HP-UX Hardware Extensions 3.0, 설치 및 코어 OS, 1999 년 4 월 10.20 (B3920-13941)&quot;에서 제공되는 HP DCE 패키지 또는 H.Merijn 사이트 ( &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http : //mirrors.develooper.com/hpux/&lt;/a&gt; ). PTH 사용은 perl-5.12 이상에서 지원되지 않으며 5.11.x에서는 다소 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6300aa55afa8bf02e973bd6a558a179a30e1f585" translate="yes" xml:space="preserve">
          <source>HPFS</source>
          <target state="translated">HPFS</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="ae70bc50ce534eb0105058b7b1522f4597dc620f" translate="yes" xml:space="preserve">
          <source>HTML charref mode (</source>
          <target state="translated">HTML charref 모드 (</target>
        </trans-unit>
        <trans-unit id="fb2be72b2d469286542425f84d15023962183962" translate="yes" xml:space="preserve">
          <source>HTML_string</source>
          <target state="translated">HTML_string</target>
        </trans-unit>
        <trans-unit id="64e75e01631bde6e4c66cc0848e48e0e81e21b3e" translate="yes" xml:space="preserve">
          <source>HTTP &amp;amp; NETWORK</source>
          <target state="translated">HTTP 및 네트워크</target>
        </trans-unit>
        <trans-unit id="b9d1305b7d421bfab1c584e1b3a7cf4b5ad6100e" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny</source>
          <target state="translated">HTTP::Tiny</target>
        </trans-unit>
        <trans-unit id="1593daf90ee92997798e7c9ba64487e429248ed3" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny - A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">HTTP :: Tiny-작고 간단하며 올바른 HTTP / 1.1 클라이언트</target>
        </trans-unit>
        <trans-unit id="6de96c82ab1c9cdb371d5db2534e8dba3e300f4b" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny can proxy both &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt; requests. Only Basic proxy authorization is supported and it must be provided as part of the proxy URL: &lt;code&gt;http://user:pass@proxy.example.com/&lt;/code&gt;.</source>
          <target state="translated">HTTP :: Tiny는 &lt;code&gt;http&lt;/code&gt; 및 &lt;code&gt;https&lt;/code&gt; 요청을 모두 프록시 할 수 있습니다 . 기본 프록시 인증 만 지원되며 프록시 URL &lt;code&gt;http://user:pass@proxy.example.com/&lt;/code&gt; 의 일부로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb7c104dfa49bc8b7e9fbf8a2bf935e253a788eb" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny focuses on correct transport. Users are responsible for ensuring that user-defined headers and content are compliant with the HTTP/1.1 specification.</source>
          <target state="translated">HTTP :: Tiny는 올바른 전송에 중점을 둡니다. 사용자는 사용자 정의 헤더 및 콘텐츠가 HTTP / 1.1 사양을 준수하는지 확인할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b38d4dd8a81a735c3930f7b6f2dc55fa797343ae" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny is</source>
          <target state="translated">HTTP :: Tiny는</target>
        </trans-unit>
        <trans-unit id="fb10b64b6b7cee3af9f574696e99543d15e2129d" translate="yes" xml:space="preserve">
          <source>HTTP::Tiny supports the following proxy environment variables:</source>
          <target state="translated">HTTP :: Tiny는 다음 프록시 환경 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2af40fad62df82d3c206edc7b46390ba49959a8f" translate="yes" xml:space="preserve">
          <source>HV</source>
          <target state="translated">HV</target>
        </trans-unit>
        <trans-unit id="9386c18987cda4e4b47eab3b2d462dd758250ce8" translate="yes" xml:space="preserve">
          <source>Ha! Try that with your garden variety regexp package...</source>
          <target state="translated">하아! 귀하의 정원 다양성 정규식 패키지로 시도하십시오 ...</target>
        </trans-unit>
        <trans-unit id="d88e3f220c919ffbf868396a7d774a5334f737c8" translate="yes" xml:space="preserve">
          <source>Hack, hack, hack. Keep in mind that Perl runs on many different platforms, with different operating systems that have different capabilities, different filesystem organizations, and even different character sets. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; gives advice on this.</source>
          <target state="translated">해킹, 해킹, 해킹 Perl은 기능이 다른 운영 체제, 파일 시스템 구성 및 문자 집합이 다른 여러 플랫폼에서 실행됩니다. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; 가 이에 대한 조언을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa83b6b9d8de018c03b6e14834f7dbb735668abf" translate="yes" xml:space="preserve">
          <source>Hackathons</source>
          <target state="translated">Hackathons</target>
        </trans-unit>
        <trans-unit id="70b5ad218deb587375e9d9ea493155e8eea890e8" translate="yes" xml:space="preserve">
          <source>Hackathons are a very different kind of gathering where Perl hackers gather to do just that, hack nonstop for an extended (several day) period on a specific project or projects. Information about hackathons can be located in the same place as information about &lt;a href=&quot;#Workshops&quot;&gt;workshops&lt;/a&gt; as well as in &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;.</source>
          <target state="translated">해커 톤은 Perl 해커가 특정 프로젝트 또는 프로젝트에서 장기간 (몇 일) 동안 논스톱 해킹을하기 위해 수집하는 매우 다른 종류의 모임입니다. 해커 &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;톤&lt;/a&gt; 에 대한 정보는 &lt;a href=&quot;#Workshops&quot;&gt;워크샵&lt;/a&gt; 에 대한 정보와 같은 장소와 irc : //irc.perl.org/#perl에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b2f425b8ec6dc0f52bcfb2fe8c13331b8f6480" translate="yes" xml:space="preserve">
          <source>Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</source>
          <target state="translated">이전 유니 코드 버전에서 작동하기 위해 Perl 해킹 (매우 심각한 해커 전용)</target>
        </trans-unit>
        <trans-unit id="c241df4cb37e7ba32f33cd5ab23a83488a78b7ae" translate="yes" xml:space="preserve">
          <source>Hacking tools and documentation</source>
          <target state="translated">해킹 툴 및 문서</target>
        </trans-unit>
        <trans-unit id="602beba2438c01897c485451edb2f2cc86633c34" translate="yes" xml:space="preserve">
          <source>Had to create %s unexpectedly</source>
          <target state="translated">예기치 않게 % s을 (를) 만들어야했습니다.</target>
        </trans-unit>
        <trans-unit id="86df64465c5e97b2cf5ef681688c0680e733d5cf" translate="yes" xml:space="preserve">
          <source>Haiku</source>
          <target state="translated">Haiku</target>
        </trans-unit>
        <trans-unit id="2cd3bee34e1e2aafe8cc6f8bcda061ef9d49610f" translate="yes" xml:space="preserve">
          <source>Half a &lt;b&gt;byte&lt;/b&gt;, equivalent to one &lt;b&gt;hexadecimal&lt;/b&gt; digit, and worth four &lt;b&gt;bits&lt;/b&gt;.</source>
          <target state="translated">1 &lt;b&gt;바이트의 &lt;/b&gt;&lt;b&gt;16 진수에&lt;/b&gt; 해당하며 4 &lt;b&gt;비트에&lt;/b&gt; 해당하는 반 &lt;b&gt;바이트&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6d8ab5e201dd91380811a77b55a7a931f3d5eee4" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt; . This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">의 중간 &lt;code&gt;ok()&lt;/code&gt; 와 &lt;code&gt;is()&lt;/code&gt; 거짓말 &lt;code&gt;cmp_ok()&lt;/code&gt; . 이진 펄 연산자를 사용하여 두 개의 인수를 비교할 수 있습니다. 비교가 참이면 테스트가 통과되고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cfee9331a26c8019adee0d29a9ba050dd1ac3641" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt;. This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">의 중간 &lt;code&gt;ok()&lt;/code&gt; 와 &lt;code&gt;is()&lt;/code&gt; 거짓말 &lt;code&gt;cmp_ok()&lt;/code&gt; . 이를 통해 바이너리 펄 연산자를 사용하여 두 인수를 비교할 수 있습니다. 비교가 참이면 테스트는 통과하고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="86179df6c35646296ecd922e347bf8fb4cdc3c6c" translate="yes" xml:space="preserve">
          <source>Hand-editing</source>
          <target state="translated">Hand-editing</target>
        </trans-unit>
        <trans-unit id="2243466296e92364f7bf27ac345ae2a71eab76a8" translate="yes" xml:space="preserve">
          <source>Handle is open.</source>
          <target state="translated">핸들이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb0ae5137688cc1b8e62808a86d332a61061726" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt; .</source>
          <target state="translated">컴파일 타임 범위 항목을 처리합니다. 블록 종료시 힌트를 복원하고 어휘 변수 범위를 올바르게 만들기 위해 패드 시퀀스 번호를 처리합니다. 함께 사용할 수있는 savestack 인덱스를 돌려줍니다 &lt;code&gt;block_end&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ab1b19f04bb1317fba3f910449270efd5565be88" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt;.</source>
          <target state="translated">컴파일 타임 범위 항목을 처리합니다. 블록 종료시 복원 할 힌트를 정렬하고 어휘 변수 범위를 올바르게 만들기 위해 패드 시퀀스 번호도 처리합니다. 함께 사용할 수있는 savestack 인덱스를 돌려줍니다 &lt;code&gt;block_end&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="aadca6115d853e86175413031bcfebcbec35442a" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit.</source>
          <target state="translated">컴파일 타임 범위 종료를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8e7e0dd257d42c19a22d84dd680aab03b4645ae7" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit. &lt;code&gt;floor&lt;/code&gt; is the savestack index returned by &lt;code&gt;block_start&lt;/code&gt;, and &lt;code&gt;seq&lt;/code&gt; is the body of the block. Returns the block, possibly modified.</source>
          <target state="translated">컴파일 타임 범위 종료를 처리합니다. &lt;code&gt;floor&lt;/code&gt; 에 의해 반환 savestack 인덱스이다 &lt;code&gt;block_start&lt;/code&gt; 및 &lt;code&gt;seq&lt;/code&gt; 블록 본체이다. 수정 된 블록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbbfa1a57fe1955a23aba6a4d759ffdeff314724" translate="yes" xml:space="preserve">
          <source>Handles copying &lt;code&gt;$(MYEXTLIB)&lt;/code&gt; as starter for final static library that then gets added to.</source>
          <target state="translated">&lt;code&gt;$(MYEXTLIB)&lt;/code&gt; 복사 를 마지막 정적 라이브러리에 대한 시작으로 처리 한 다음 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a78a213e08f22079d0727d65ee7cd82040828af3" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">쓰기 전용으로 열린 핸들은 작동하지 않습니다. 읽기 전용으로 열린 핸들은 배열을 수정하려고 시도하지 않는 한 작동합니다. 검색 가능한 데이터 소스에 핸들을 부착해야합니다. 즉 파이프 나 소켓이 없다는 의미입니다. 경우 &lt;code&gt;Tie::File&lt;/code&gt; 가 아닌 시크 핸들을 공급 것을 감지 할 수 있으며, &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 예외가 발생합니다. (유닉스 시스템에서는이를 감지 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5f2455dc72c01e04f7cb2a120d3caf4c7e83b89d" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;tie&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">쓰기 전용으로 열린 핸들은 작동하지 않습니다. 읽기 전용으로 열린 핸들은 배열을 수정하지 않는 한 작동합니다. 핸들은 검색 가능한 데이터 소스에 연결되어야합니다. 즉, 파이프 나 소켓이 없음을 의미합니다. 경우 &lt;code&gt;Tie::File&lt;/code&gt; 가 아닌 시크 핸들을 공급 것을 감지 할 수 있으며, &lt;code&gt;tie&lt;/code&gt; 호출 예외가 발생합니다. (Unix 시스템에서는이를 감지 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3dca08a90c7ec673523c972aeb9655cc6ba04e87" translate="yes" xml:space="preserve">
          <source>Handles the installing and uninstalling of perl modules, scripts, man pages, etc...</source>
          <target state="translated">perl 모듈, 스크립트, 매뉴얼 페이지 등의 설치 및 제거를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="caa1714db5e5ddfa607afe3449dc66f6283180d0" translate="yes" xml:space="preserve">
          <source>Handling Duplicate Keys</source>
          <target state="translated">중복 키 처리</target>
        </trans-unit>
        <trans-unit id="0f01c504507d7832a1cac719e698e1e7e8a378a8" translate="yes" xml:space="preserve">
          <source>Handling Malformed Data</source>
          <target state="translated">잘못된 데이터 처리</target>
        </trans-unit>
        <trans-unit id="f0f0fc76a1e441991cde68774fcefb6a0861fb18" translate="yes" xml:space="preserve">
          <source>Handling Unicode</source>
          <target state="translated">유니 코드 처리</target>
        </trans-unit>
        <trans-unit id="5c331b1b1b146d85b0798abcb652f4dbd9cc2a65" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">유니 코드 처리는 대부분 투명합니다. 평소와 같이 문자열을 사용하십시오. &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 과 같은 함수 는 유니 코드 문자에서 작동합니다. 정규식은 유니 코드 문자에서 작동합니다 ( &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 및 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b53b68423a2d10312f79c4e7788b10fc80971e39" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;index()&lt;/code&gt;, &lt;code&gt;length()&lt;/code&gt;, and &lt;code&gt;substr()&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">유니 코드 처리는 대부분 투명합니다. 평소처럼 문자열을 사용하면됩니다. &lt;code&gt;index()&lt;/code&gt; , &lt;code&gt;length()&lt;/code&gt; 및 &lt;code&gt;substr()&lt;/code&gt; 과 같은 함수 는 유니 코드 문자에서 작동합니다. 정규식은 유니 코드 문자에서 작동합니다 ( &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 및 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="88d69acff614c1d827ede2f260f6a46a48647c42" translate="yes" xml:space="preserve">
          <source>Handling simple options is straightforward:</source>
          <target state="translated">간단한 옵션 처리는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8e71d792bc3c7ca46b9ebe6e4e08dc39ffe6877b" translate="yes" xml:space="preserve">
          <source>Handling the SIGHUP Signal in Daemons</source>
          <target state="translated">데몬에서 SIGHUP 신호 처리</target>
        </trans-unit>
        <trans-unit id="6e120aed62a343cea2462c78b0c345bd93d57340" translate="yes" xml:space="preserve">
          <source>Handy Values</source>
          <target state="translated">편리한 가치</target>
        </trans-unit>
        <trans-unit id="049503c569a7548e0e0aaf7ff650cdb7e260c634" translate="yes" xml:space="preserve">
          <source>Handy for putting in notes which might be useful for debugging, but don't indicate a problem.</source>
          <target state="translated">디버깅에 유용 할 수있는 메모를 작성하는 데 유용하지만 문제를 나타내지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57d70b3a1b3e8f06b27f21ad6f5e77255bd44b1f" translate="yes" xml:space="preserve">
          <source>Handy for things like...</source>
          <target state="translated">다음과 같은 것들에 편리합니다 ...</target>
        </trans-unit>
        <trans-unit id="04a45a64a65bd1462cbe3b6ef2c3619b7fc7d816" translate="yes" xml:space="preserve">
          <source>Handy for this sort of thing:</source>
          <target state="translated">이런 종류의 일에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="eb631afbbf9621a14aebc98eacec8ff594f19f3b" translate="yes" xml:space="preserve">
          <source>Handy tip: put &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; in your</source>
          <target state="translated">핸디 팁 : 넣어 &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="506eecb432a2c8fe45656c023dac6e502795db55" translate="yes" xml:space="preserve">
          <source>Hangul Syllable Type</source>
          <target state="translated">한글 음절 유형</target>
        </trans-unit>
        <trans-unit id="951499a6cfa4736aa7a1d36a7019e79078429a7e" translate="yes" xml:space="preserve">
          <source>HangulSyllableType.txt</source>
          <target state="translated">HangulSyllableType.txt</target>
        </trans-unit>
        <trans-unit id="7cf3612d90dc653542fad94e9962eab0afe4c4ac" translate="yes" xml:space="preserve">
          <source>Hans Dieter Pearcey &lt;code&gt;hdp@cpan.org&lt;/code&gt;</source>
          <target state="translated">Hans Dieter &lt;code&gt;hdp@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc5f45cb92e25fd3e9f4ed85dddd70a19341bbf4" translate="yes" xml:space="preserve">
          <source>Hard and symbolic (&quot;soft&quot;) links; linkname should specify target.</source>
          <target state="translated">단단하고 상징적 인 ( &quot;소프트&quot;) 링크; linkname은 target을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdae1ec5d05114509a53fe67f0320c6eadea6400" translate="yes" xml:space="preserve">
          <source>Hard links are implemented on Win32 under NTFS only. They are natively supported on Windows 2000 and later. On Windows NT they are implemented using the Windows POSIX subsystem support and the Perl process will need Administrator or Backup Operator privileges to create hard links.</source>
          <target state="translated">하드 링크는 NTFS에서만 Win32에 구현됩니다. Windows 2000 이상에서 기본적으로 지원됩니다. Windows NT에서는 Windows POSIX 서브 시스템 지원을 사용하여 구현되며 Perl 프로세스는 하드 링크를 작성하려면 관리자 또는 백업 운영자 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fd756d3e871622cf9bdef94fc2aa35729d65f76a" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;&quot;Circular References&quot;&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">하드 참조는 스마트합니다. 사용자를 위해 참조 횟수를 추적하여 참조 횟수가 0이되면 참조 된 항목을 자동으로 해제합니다. (자기 참조 또는 순환 데이터 구조의 값에 대한 참조 카운트는 약간의 도움 없이는 0이되지 않을 수 있습니다 . 자세한 설명 은 &lt;a href=&quot;#Circular-References&quot;&gt;&quot;순환 참조&quot;&lt;/a&gt; 를 참조 하십시오 .) 그 일이 객체 인 경우 객체가 파괴됩니다. 객체에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 . (어떤 의미에서 Perl의 모든 것은 객체이지만 일반적으로 클래스 패키지에 공식적으로 &quot;축복 된&quot;객체에 대한 참조를 위해 단어를 예약합니다.)</target>
        </trans-unit>
        <trans-unit id="7cec0c304aaf210bfe25cbb78814c09191b199ee" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;Circular References&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">하드 참조는 영리합니다. 참조 카운트를 추적하여 참조 카운트가 0이 될 때 참조되는 것을 자동으로 해제합니다. (자기 참조 또는 순환 데이터 구조의 값에 대한 참조 수는 약간의 도움 없이는 0이되지 않을 수 있습니다 . 자세한 설명 은 &lt;a href=&quot;#Circular-References&quot;&gt;순환 참조&lt;/a&gt; 를 참조 하십시오 .) 해당 항목이 오브젝트 인 경우 오브젝트가 파괴됩니다. 오브젝트에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 . 어떤 의미에서 Perl의 모든 것은 객체이지만, 우리는 일반적으로 클래스 패키지에 공식적으로 &quot;축복 된&quot;객체에 대한 단어를 예약합니다.</target>
        </trans-unit>
        <trans-unit id="66e944742ea0249f6f2a6fd52c3e9e415e65aaeb" translate="yes" xml:space="preserve">
          <source>Harness output delegate for default console output</source>
          <target state="translated">기본 콘솔 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="2dd2c2e596e19cb5f6f12eac61588cccdf06ec03" translate="yes" xml:space="preserve">
          <source>Harness output delegate for file output</source>
          <target state="translated">파일 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="363bd8bca1592722722a3ac3fe8ee3189add2d7b" translate="yes" xml:space="preserve">
          <source>Harness output delegate for parallel console output</source>
          <target state="translated">병렬 콘솔 출력을위한 하네스 출력 델리게이트</target>
        </trans-unit>
        <trans-unit id="ba951792ddfec9b17fd8944b4026a028108c3aa1" translate="yes" xml:space="preserve">
          <source>Has already been</source>
          <target state="translated">이미되었습니다</target>
        </trans-unit>
        <trans-unit id="d8861f9d9089d32f3fb836f33024a00d9824a27b" translate="yes" xml:space="preserve">
          <source>Has global effect, persists after the application exits.</source>
          <target state="translated">전역 효과가 있으며 응용 프로그램이 종료 된 후에도 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="d791fc07c3f03c0d15e5cd282a309f1887be4bb0" translate="yes" xml:space="preserve">
          <source>Has it been done before?</source>
          <target state="translated">전에 한 적이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2929382f580bfdd31a77bfbbda12fefbb2e9c2b6" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; ,&lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , or &lt;code&gt;\F&lt;/code&gt; .</source>
          <target state="translated">일치 연산자와 동일한 동작을합니다. 또한 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 양식이 적용되는 경우 이전 피연산자 에서 언급 된 것 중 하나를 포함하는 정규식 일치를 기반으로 한 대체 결과로 수정 된 경우 왼쪽 피연산자 &lt;code&gt;=~&lt;/code&gt; 가 오염됩니다. 같은 -mapping &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b06c2eb9bde536e47408d65b8dbc18da216062" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;,&lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, or &lt;code&gt;\F&lt;/code&gt;.</source>
          <target state="translated">일치 연산자와 동일한 동작을합니다. 또한, &lt;code&gt;=~&lt;/code&gt; 의 왼쪽 피연산자 는 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;use locale&lt;/code&gt; 양식이 유효 할 때 , 이전 항목에서 언급 된 항목 또는 case와 관련된 정규식 일치를 기반으로 한 대체의 결과로 수정 된 경우 오염됩니다. -매핑 (예 : &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd8a4f5a97ed6a865ef03c82bac1954b46e0a68" translate="yes" xml:space="preserve">
          <source>Hash (&lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;)</source>
          <target state="translated">해시 ( &lt;code&gt;'%'&lt;/code&gt; 또는 &lt;code&gt;'*%'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2e911d125c069efa7d913b344e0f08f8969421a" translate="yes" xml:space="preserve">
          <source>Hash API Extensions</source>
          <target state="translated">해시 API 확장</target>
        </trans-unit>
        <trans-unit id="ffc5f6e94a276eeaf94de20a0e4f426d64a6723d" translate="yes" xml:space="preserve">
          <source>Hash Algorithm - Hash algorithms like the one used in Perl are well known to be vulnerable to collision attacks on their hash function. Such attacks involve constructing a set of keys which collide into the same bucket producing inefficient behavior. Such attacks often depend on discovering the seed of the hash function used to map the keys to buckets. That seed is then used to brute-force a key set which can be used to mount a denial of service attack. In Perl 5.8.1 changes were introduced to harden Perl to such attacks, and then later in Perl 5.18.0 these features were enhanced and additional protections added.</source>
          <target state="translated">해시 알고리즘-Perl에서 사용되는 것과 같은 해시 알고리즘은 해시 함수에 대한 충돌 공격에 취약한 것으로 잘 알려져 있습니다. 이러한 공격에는 비효율적 인 동작을 생성하는 동일한 버킷에 충돌하는 일련의 키 구성이 포함됩니다. 이러한 공격은 종종 키를 버킷에 매핑하는 데 사용되는 해시 함수의 시드를 찾는 데 달려 있습니다. 그런 다음이 시드는 서비스 거부 공격을 마운트하는 데 사용할 수있는 키 세트를 무차별 화하는 데 사용됩니다. Perl 5.8.1에서는 Perl을 이러한 공격으로 강화하기 위해 변경 사항이 도입되었으며 나중에 Perl 5.18.0에서 이러한 기능이 향상되었으며 추가 보호 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f61062d96868959d8bad3f3f9d8706be2a8eb3f6" translate="yes" xml:space="preserve">
          <source>Hash Manipulation Functions</source>
          <target state="translated">해시 조작 함수</target>
        </trans-unit>
        <trans-unit id="722f31dda86bb5212ab7b2c1afdf8b00513530ac" translate="yes" xml:space="preserve">
          <source>Hash Seed Randomization</source>
          <target state="translated">해시 시드 무작위 화</target>
        </trans-unit>
        <trans-unit id="7a28810109f74274cf74cf5b33143c35d878dd91" translate="yes" xml:space="preserve">
          <source>Hash Traversal Randomization</source>
          <target state="translated">해시 순회 무작위 화</target>
        </trans-unit>
        <trans-unit id="eacc32410490d8f503c47a016128793f41b30f3f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">해시 항목은 명백하게 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에서 정확히 동일한 일련의 작업을 수행하면 각 해시의 순서가 다를 수 있습니다. 해시에 삽입하면 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 단, &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 의해 반환 된 가장 최근의 키 는 순서를 변경하지 않고 삭제 될 수 있습니다. 주어진 해시가 수정되지 않는 한 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 &quot;알고리즘 복잡성 공격&quot;을&lt;/a&gt; 참조하십시오.해시 순서가 무작위로 지정되는 이유에 대한 자세한 내용은 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서의 정확한 세부 사항은 Perl 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="431e8961d246bf31774f7d0fd18486a3592113ae" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">해시 항목은 명백하게 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에서 정확히 동일한 일련의 작업을 수행하면 각 해시의 순서가 다를 수 있습니다. 해시에 삽입하면 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 단, &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; 의해 반환 된 가장 최근의 키 는 순서를 변경하지 않고 삭제 될 수 있습니다. 주어진 해시가 수정되지 않는 한 &lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다. &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 &quot;알고리즘 복잡성 공격&quot;을&lt;/a&gt; 참조하십시오.해시 순서가 무작위로 지정되는 이유에 대한 자세한 내용은 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서의 정확한 세부 사항은 Perl 릴리스에서 변경 될 수 있습니다. 묶인 해시는 항목 삽입 및 삭제 순서 변경과 관련하여 Perl의 해시와 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305905caf9fb73ce326146ab6da346f5a44d3d5e" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 의존 할 수 있습니다 , , &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 동일한 순서를 반복적으로 반환 할 수 있습니다. 보다&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt; perlsec의 알고리즘 복잡성 공격&lt;/a&gt;해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38990845f56b0504f14a42e264d2e90a4529057f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다.&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt; perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다. 묶음 해시는 항목 삽입 및 삭제 순서의 변경과 관련하여 Perl의 해시와 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c5186b59e1d86cc131a1fce52452e4e4a1c3b7" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다.&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt; perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ca36bf1a5daf8ef9f034a1d277717a3712e5c2" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">해시 항목은 분명히 임의의 순서로 반환됩니다. 실제 임의 순서는 주어진 해시에 따라 다릅니다. 두 해시에 대한 동일한 일련의 연산은 각 해시에 대해 다른 순서로 나타날 수 있습니다. 해시에 삽입하면 순서가 변경 되지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 키 가 반환 한 최신 키를 제외하고 삭제와 마찬가지로 순서가 변경 될 수 있습니다. 주어진 해시가 수정되지 않는 한 , &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 에 의존하여 서로 동일한 순서를 반복적으로 반환 할 수 있습니다.&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt; perlsec의 알고리즘 복잡성 공격&lt;/a&gt; 참조해시 순서가 무작위 인 이유에 대한 자세한 내용. 여기에 제공된 보증 외에도 Perl의 해시 알고리즘 및 해시 순회 순서에 대한 정확한 세부 사항은 Perl의 모든 릴리스에서 변경 될 수 있습니다. 묶음 해시는 항목 삽입 및 삭제 순서의 변경과 관련하여 Perl의 해시와 다르게 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="450c7d18d41b71db86a014ec4874cb370e9139cb" translate="yes" xml:space="preserve">
          <source>Hash keys are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">해시 키는 오염 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb008d092d1635eab043a4b8199104071bf333" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">해시 키는 문자열이므로 실제로 참조를 키로 사용할 수 없습니다. 그렇게하려고 시도하면 perl은 참조를 문자열 형식으로 바꿉니다 (예 : &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). 거기에서 최소한 자체적으로 추가 작업을 수행하지 않으면 문자열 형식의 참조를 다시 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="256656f318911c4b99b0f0616a83baa9886ad936" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt;). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">해시 키는 문자열이므로 실제로 참조를 키로 사용할 수 없습니다. 그렇게하려고하면 perl은 참조를 문자열 형식으로 변환합니다 (예 : &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). 거기에서 최소한 자신의 추가 작업을 수행하지 않고는 문자열 형식에서 참조를 다시 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81c6d3b1e20fc06f0ae8fafd3e33b459483ea84f" translate="yes" xml:space="preserve">
          <source>Hash lookup of which core extensions were built.</source>
          <target state="translated">핵심 확장이 빌드 된 해시 조회입니다.</target>
        </trans-unit>
        <trans-unit id="a78b3989df5bd5b4bee3a8e811b9eb95d6fd1010" translate="yes" xml:space="preserve">
          <source>Hash refs</source>
          <target state="translated">해시 참조</target>
        </trans-unit>
        <trans-unit id="28bd740a5fed92f4652182fc91352eb825ae6b82" translate="yes" xml:space="preserve">
          <source>Hash subscripts are similar, only instead of square brackets curly brackets are used. For example:</source>
          <target state="translated">해시 첨자는 비슷하지만 대괄호 대신 중괄호가 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f05d6e4a748b9c8f33a3dd349b88ed9bc020a76" translate="yes" xml:space="preserve">
          <source>Hash values do not spring into existence upon mere reference.</source>
          <target state="translated">해시 값은 단순한 참조로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="060e2951a35019d6292c77892149e6ae4655ab4b" translate="yes" xml:space="preserve">
          <source>Hash::Util</source>
          <target state="translated">Hash::Util</target>
        </trans-unit>
        <trans-unit id="6df60ce76a6dd2245295b960eb619bae5a40a333" translate="yes" xml:space="preserve">
          <source>Hash::Util - A selection of general-utility hash subroutines</source>
          <target state="translated">Hash :: Util-일반 유틸리티 해시 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="fc6dfd7516cd148dfcfbc9b4b53977f84b109b02" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash</source>
          <target state="translated">Hash::Util::FieldHash</target>
        </trans-unit>
        <trans-unit id="2761eb764ac1f31cb8db8bfca9f4810ccd72d904" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash - Support for Inside-Out Classes</source>
          <target state="translated">Hash :: Util :: FieldHash-인사이드 아웃 클래스 지원</target>
        </trans-unit>
        <trans-unit id="7586bfa5dab5c10b087765f9a931752b869fef56" translate="yes" xml:space="preserve">
          <source>HashBase will not export &lt;code&gt;new()&lt;/code&gt; if there is already a &lt;code&gt;new()&lt;/code&gt; method in your packages inheritance chain.</source>
          <target state="translated">패키지 상속 체인에 이미 &lt;code&gt;new()&lt;/code&gt; 메서드가 있는 경우 HashBase는 &lt;code&gt;new()&lt;/code&gt; 내 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="5003cfd9a645097d80f1b1984336d3badcf5c150" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) being in the hash.</source>
          <target state="translated">해시는 스칼라 쌍을 포함합니다. 첫 번째는 키이고 두 번째는 값입니다. 키는 문자열로 강제 변환되지만 값은 문자열, 숫자 또는 참조의 모든 종류의 스칼라 일 수 있습니다. 키 &lt;code&gt;$key&lt;/code&gt; 가 % hash에 있으면 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; 가 true를 반환합니다. 주어진 키에 대한 값은 다음과 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 있는 경우, &lt;code&gt;$hash{$key}&lt;/code&gt; 될 것 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; true를 돌려줍니다. 이것은 해시에있는 ( &lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ed15845c84e91acb212b68d97fc5cccfa145f86e" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;exists($hash{$key})&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;undef&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;undef&lt;/code&gt; while &lt;code&gt;exists $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt;, &lt;code&gt;undef&lt;/code&gt;) being in the hash.</source>
          <target state="translated">해시는 스칼라 쌍을 포함합니다. 첫 번째는 키이고 두 번째는 값입니다. 값은 문자열, 숫자 또는 참조와 같은 모든 종류의 스칼라 일 수 있지만 키는 문자열로 강제 변환됩니다. 키 &lt;code&gt;$key&lt;/code&gt; 가 % hash에 있으면 &lt;code&gt;exists($hash{$key})&lt;/code&gt; 는 true를 리턴합니다. 주어진 키에 대한 값은 다음과 &lt;code&gt;undef&lt;/code&gt; 있는 경우, &lt;code&gt;$hash{$key}&lt;/code&gt; 될 것 &lt;code&gt;undef&lt;/code&gt; 동안 &lt;code&gt;exists $hash{$key}&lt;/code&gt; true를 돌려줍니다. 이것은 해시에있는 ( &lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;undef&lt;/code&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a5674cfb04f68937d23325c6f7c4d9203e5e6faf" translate="yes" xml:space="preserve">
          <source>Hashes have no particular internal order, though you can sort the keys and loop through them.</source>
          <target state="translated">해시는 특정 내부 순서가 없지만 키를 정렬하고 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d64fa5d0ff2f867536af648f416f1c5edf27d3" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context, and in 5.28 onwards, by &lt;code&gt;keys&lt;/code&gt; in boolean context. UNTIE is called when &lt;code&gt;untie&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">해시는 연결될 최초의 Perl 데이터 유형이었습니다 (dbmopen () 참조). 연결 해시를 구현하는 클래스는 다음 메서드를 정의해야합니다. TIEHASH는 생성자입니다. FETCH 및 STORE는 키 및 값 쌍에 액세스합니다. EXISTS는 키가 해시에 있는지 여부를보고하고 DELETE는 키를 삭제합니다. CLEAR는 모든 키 및 값 쌍을 삭제하여 해시를 비 웁니다. FIRSTKEY 및 NEXTKEY는 모든 키를 반복하기 위해 keys () 및 each () 함수를 구현합니다. SCALAR는 연결된 해시가 스칼라 컨텍스트에서 평가되고 5.28 이후 에는 부울 컨텍스트의 &lt;code&gt;keys&lt;/code&gt; 평가 될 때 트리거됩니다 . UNTIE는 &lt;code&gt;untie&lt;/code&gt; 가 발생할 때 호출 되고 DESTROY는 묶인 변수가 가비지 수집 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="11a5b7f57189106155ae1686164009308c7fb48e" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context. UNTIE is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">해시는 연결될 첫 번째 Perl 데이터 유형입니다 (dbmopen () 참조). 연결 해시를 구현하는 클래스는 다음 메소드를 정의해야합니다. TIEHASH는 생성자입니다. FETCH 및 STORE는 키 및 값 쌍에 액세스합니다. EXISTS는 키가 해시에 있는지 여부를보고하고 DELETE는 키를 삭제합니다. CLEAR는 모든 키와 값 쌍을 삭제하여 해시를 비 웁니다. FIRSTKEY 및 NEXTKEY는 모든 키를 반복하기 위해 keys () 및 each () 함수를 구현합니다. 스칼라 컨텍스트에서 연결된 해시가 평가되면 SCALAR가 트리거됩니다. &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 가 발생 하면 UNTIE가 호출 되고, 묶인 변수가 가비지 수집 될 때 DESTROY가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="00ee967aadbfebd86b3235daf9d26b53205682c3" translate="yes" xml:space="preserve">
          <source>Hashing order and checksums</source>
          <target state="translated">해싱 순서 및 체크섬</target>
        </trans-unit>
        <trans-unit id="3f4d761db68098a751847d9083882bbf309c01a1" translate="yes" xml:space="preserve">
          <source>Hashref of .pm files and *.pl files to be installed. e.g.</source>
          <target state="translated">.pm 파일 및 * .pl 파일의 Hashref가 설치됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e654482e1464037d016cd8389b44c8067b3f7edd" translate="yes" xml:space="preserve">
          <source>Hashref of .xs files. MakeMaker will default this. e.g.</source>
          <target state="translated">.xs 파일의 해시 참조 MakeMaker가이를 기본값으로 설정합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="54306e4b7a73d064c3f0a92d38a328cc3c6fc248" translate="yes" xml:space="preserve">
          <source>Hashref of pod-containing files. MakeMaker will default this to all EXE_FILES files that include POD directives. The files listed here will be converted to man pages and installed as was requested at Configure time.</source>
          <target state="translated">포드 포함 파일의 해시 참조 MakeMaker는이를 기본적으로 POD 지시문이 포함 된 모든 EXE_FILES 파일로 설정합니다. 여기에 나열된 파일은 구성 페이지에서 요청한대로 매뉴얼 페이지로 변환되어 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="e03929c9c89c518c1a46f519dc21b0db453de58a" translate="yes" xml:space="preserve">
          <source>Hashref of symbol names for routines to be made available as universal symbols. Each key/value pair consists of the package name and an array of routine names in that package. Used only under AIX, OS/2, VMS and Win32 at present. The routine names supplied will be expanded in the same way as XSUB names are expanded by the XS() macro. Defaults to</source>
          <target state="translated">루틴에 대한 기호 이름의 Hashref는 범용 기호로 사용 가능합니다. 각 키 / 값 쌍은 패키지 이름과 해당 패키지의 루틴 이름 배열로 구성됩니다. 현재 AIX, OS / 2, VMS 및 Win32에서만 사용됩니다. 제공된 루틴 이름은 XSUB 이름이 XS () 매크로에 의해 확장되는 것과 같은 방식으로 확장됩니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="0e5b1d03af67cbc5ad483521c6061ce63fe7c5e2" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">맨 페이지를 작성할 파일을 * .pm 및 * .pod 파일에 할당하는 Hashref MakeMaker는 POD 지시문에 대한 모든 * .pod 및 * .pm 파일을 구문 분석합니다. POD를 포함하는 파일은 MAN3PODS hashref의 기본 키입니다. 그런 다음 &lt;code&gt;make&lt;/code&gt; 동안 make 페이지로 변환되고 &lt;code&gt;make install&lt;/code&gt; 중에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="e298a85cf0430820689a9fd4666229176cc4269d" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">* .pm 및 * .pod 파일에 맨 페이지가 기록 될 파일을 할당하는 Hashref. MakeMaker는 POD 지시문에 대한 모든 * .pod 및 * .pm 파일을 구문 분석합니다. POD를 포함하는 파일은 MAN3PODS 해시 참조의 기본 키가됩니다. 이것들은 &lt;code&gt;make&lt;/code&gt; 동안 man 페이지로 변환 될 것이고 &lt;code&gt;make install&lt;/code&gt; 동안 설치 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a765c84d56e0aa5f774648e2602400523cde1aca" translate="yes" xml:space="preserve">
          <source>Hashref with options controlling the operation of &lt;code&gt;XSMULTI&lt;/code&gt;:</source>
          <target state="translated">XSMULTI의 작동을 제어하는 ​​옵션이있는 &lt;code&gt;XSMULTI&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7c40a20db4b296ec67dfa94b908457cfde4c540" translate="yes" xml:space="preserve">
          <source>Have a .ucm file ready. You can get it from somewhere or you can write your own from scratch or you can grab one from the Encode distribution and customize it. For the UCM format, see the next Chapter. In the example below, I'll call my theoretical encoding myascii, defined in</source>
          <target state="translated">.ucm 파일을 준비하십시오. 어딘가에서 가져 오거나 처음부터 직접 작성하거나 Encode 배포판에서 가져 와서 사용자 정의 할 수 있습니다. UCM 형식에 대해서는 다음 장을 참조하십시오. 아래 예제에서는 이론적 인코딩 myascii를</target>
        </trans-unit>
        <trans-unit id="7e1aafb3365aa620ad71622b6d9e66ff51332860" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;code&gt;look&lt;/code&gt; (!) command.</source>
          <target state="translated">상기 모습이 &lt;code&gt;look&lt;/code&gt; (!) 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d27c15838302800e87f5a9ade00864fd9b117bc" translate="yes" xml:space="preserve">
          <source>Have a look at the CPAN::Site module.</source>
          <target state="translated">CPAN :: Site 모듈을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="2682f428ec2cd20e9cdf6753b7db50d45fa0c287" translate="yes" xml:space="preserve">
          <source>Have you got it right?</source>
          <target state="translated">맞습니까?</target>
        </trans-unit>
        <trans-unit id="60004c6dbf1e8f9315ee254f18d4e8b2a9fce3c6" translate="yes" xml:space="preserve">
          <source>Have you included all relevant information?</source>
          <target state="translated">모든 관련 정보를 포함 했습니까?</target>
        </trans-unit>
        <trans-unit id="3d1c0002422cc934d4f43ea061dac2a317b36bcc" translate="yes" xml:space="preserve">
          <source>Have you looked at CPAN (see &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;)? The chances are that someone has already written a module that can solve your problem. Have you read the appropriate manpages? Here's a brief index:</source>
          <target state="translated">CPAN을 살펴 보셨습니까 ( &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 참조 )? 누군가가 이미 문제를 해결할 수있는 모듈을 작성했을 가능성이 있습니다. 적절한 맨 페이지를 읽었습니까? 다음은 간단한 색인입니다.</target>
        </trans-unit>
        <trans-unit id="4732d1c70c9c00b316d946047ce44e3469a4a557" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others.</source>
          <target state="translated">Sort라고 불리는 57 개의 모듈을 모두 가지고 있다고해서 누구나 쉽게 살 수있는 것은 아닙니다. 다른 많은 사람들과 함께 모듈을 설치하려고하는 누군가를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="fea81edd1a4ca564780d9031bb647dc99cf58fa7" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others. If in any doubt ask for suggestions in comp.lang.perl.misc.</source>
          <target state="translated">Sort라는 57 개의 모듈을 모두 가지고 있어도 누구나 쉽게 사용할 수 없습니다 (Sort :: Quick이라는 23 개의 모듈을 사용하는 것이 약간 나아질 것입니다 :-). 다른 사람과 함께 모듈을 설치하려고하는 사람을 상상해보십시오. 의심스러운 경우 comp.lang.perl.misc에 제안을 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c3a74f90c179abbbb2a8aabfd9df58154dbdba" translate="yes" xml:space="preserve">
          <source>Having PERLDOCDEBUG set to a positive integer will make perldoc emit even more descriptive output than the &lt;code&gt;-D&lt;/code&gt; switch does; the higher the number, the more it emits.</source>
          <target state="translated">PERLDOCDEBUG를 양의 정수로 설정하면 perldoc이 &lt;code&gt;-D&lt;/code&gt; 스위치 보다 더 설명적인 출력을 방출합니다 . 숫자가 높을수록 더 많이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="475dd7f4c80bb5dca06b4bee66ecdd1370715023" translate="yes" xml:space="preserve">
          <source>Having RSX and the latest</source>
          <target state="translated">RSX 및 최신</target>
        </trans-unit>
        <trans-unit id="831389895e5cb7d92cb0b30b5f20a040e5b28ad0" translate="yes" xml:space="preserve">
          <source>Having a comma after the last element of an enum list</source>
          <target state="translated">열거 목록의 마지막 요소 다음에 쉼표가있는 경우</target>
        </trans-unit>
        <trans-unit id="eb3a777ac79c8871a640c69bcf5b76d7b538148e" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">의미가 있습니다. Perl은 사람들이하려고하는 일 중 일부는 의미가 없다고 생각합니다. 특히, &lt;b&gt;값을&lt;/b&gt; 지정하지 않은 변수를 사용 하고 존재하지 않는 데이터에 대해 특정 작업을 수행합니다. 예를 들어, 파일 끝을 지나서 데이터를 읽으려고 시도하면 Perl이 정의되지 않은 값을 전달합니다. Camel 챕터 27,&amp;ldquo;기능&amp;rdquo;의 &lt;b&gt;거짓&lt;/b&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d814a7a08cc6adb5ea05a2df41a45594d3bcb67b" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;defined&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">의미가 있습니다. Perl은 사람들이하려는 일 중 일부는 의미가 없다고 생각합니다. 특히 &lt;b&gt;값&lt;/b&gt; 이 부여되지 않은 변수를 사용 하고 거기에없는 데이터에 대해 특정 작업을 수행합니다. 예를 들어, 파일의 끝을 지나서 데이터를 읽으려고하면 Perl은 정의되지 않은 값을 반환합니다. &lt;b&gt;false&lt;/b&gt; 및 Camel 27 장 &quot;기능&quot; 의 &lt;code&gt;defined&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf9f1d17b3780ae4ae6a7c92cd0343417040db2e" translate="yes" xml:space="preserve">
          <source>Having done your bit, please be prepared to wait, to be told the bug is in your code, or possibly to get no reply at all. The volunteers who maintain Perl are busy folks, so if your problem is an obvious bug in your own code, is difficult to understand or is a duplicate of an existing report, you may not receive a personal reply.</source>
          <target state="translated">비트를 마친 후에는 코드에 버그가 있거나 응답이 전혀 없을 때까지 기다리십시오. Perl을 유지 관리하는 자원 봉사자들은 바쁜 사람들이므로 문제가 자신의 코드에서 명백한 버그이거나 이해하기 어렵거나 기존 보고서의 복제본 인 경우 개인 응답을받지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61dfbdc92422646f02edc5b064d4a445a5156276" translate="yes" xml:space="preserve">
          <source>Having multiple DBM implementations makes it trivial to copy database formats:</source>
          <target state="translated">여러 DBM 구현이 있으면 데이터베이스 형식을 복사하는 것이 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a36716594c37d5edd82c337ce9f21f289c12c13" translate="yes" xml:space="preserve">
          <source>Having pseudo-process IDs be negative integers breaks down for the integer &lt;code&gt;-1&lt;/code&gt; because the wait() and waitpid() functions treat this number as being special. The tacit assumption in the current implementation is that the system never allocates a thread ID of &lt;code&gt;1&lt;/code&gt; for user threads. A better representation for pseudo-process IDs will be implemented in future.</source>
          <target state="translated">의사 프로세스 ID를 음수로 설정 하면 wait () 및 waitpid () 함수가이 숫자를 특수한 것으로 간주하므로 정수 &lt;code&gt;-1&lt;/code&gt; 에 대해 정수가 분해됩니다 . 현재 구현에서 암묵적인 가정은 시스템 이 사용자 스레드에 대해 스레드 ID &lt;code&gt;1&lt;/code&gt; 을 할당하지 않는다는 것 입니다. 의사 프로세스 ID에 대한 더 나은 표현은 향후에 구현 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fff5183df30472b7e88394295e20e9d8990e8e07" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt; . If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 를 읽으면 아마도 &lt;code&gt;$X&lt;/code&gt; 저장된 묶인 객체의 여분의 사본으로 인해 오류가 발생했을 것입니다 . 그렇지 않으면 &lt;b&gt;DB_File&lt;/b&gt; 소멸자 DESTROY가 호출 될 때까지 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c1e2b19d7b5e00f5d0c88fd12f5698cccf89784" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt;. If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">읽으면서 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 아마 당신은 이미 오류에 저장된 연결 개체의 추가 사본에 의해 발생되는 것을 추측 할 것이다 &lt;code&gt;$X&lt;/code&gt; . 그렇지 않은 경우 문제는 &lt;b&gt;DB_File&lt;/b&gt; 소멸자 DESTROY가 호출 될 때까지 호출되지 않는다는 사실로 귀결됩니다.</target>
        </trans-unit>
        <trans-unit id="690025fd44237769b46324cf68642f14ae190ff2" translate="yes" xml:space="preserve">
          <source>Having the SDK installed also means that you need to have either the Metrowerks CodeWarrior installed (2.8 and 3.0 were used in testing) or the Microsoft Visual C++ 6.0 installed (SP3 minimum, SP5 recommended).</source>
          <target state="translated">SDK를 설치한다는 것은 Metrowerks CodeWarrior (테스트에 2.8 및 3.0이 사용됨) 또는 Microsoft Visual C ++ 6.0 (최소 SP3, SP5 권장)을 설치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="893bf15d4ad790d3a646d05f171a2db30641c0d1" translate="yes" xml:space="preserve">
          <source>Having threads support requires all of Perl and all of the XS modules in the Perl installation to be rebuilt; it is not just a question of adding the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module (i.e., threaded and non-threaded Perls are binary incompatible).</source>
          <target state="translated">스레드를 지원하려면 Perl 설치의 모든 Perl 및 모든 XS 모듈을 다시 빌드해야합니다. &lt;a href=&quot;threads&quot;&gt;쓰레드&lt;/a&gt; 모듈 을 추가하는 것의 문제가 아닙니다 (즉, 쓰레드와 쓰레드가 아닌 Perls는 바이너리 호환되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="123977c7eddfac195115408ec1d6b6b93c199204" translate="yes" xml:space="preserve">
          <source>Having to do with numbers represented in base 2. That means there&amp;rsquo;s basically two numbers: 0 and 1. Also used to describe a file of &amp;ldquo;nontext&amp;rdquo;, presumably because such a file makes full use of all the binary bits in its bytes. With the advent of &lt;b&gt;Unicode&lt;/b&gt;, this distinction, already suspect, loses even more of its meaning.</source>
          <target state="translated">기본 2에 표시된 숫자와 관련이 있습니다. 이는 기본적으로 0과 1의 두 숫자가 있음을 의미합니다.&amp;ldquo;비 텍스트&amp;rdquo;파일을 설명하는 데에도 사용됩니다. 아마도 이러한 파일은 바이트의 모든 이진 비트를 완전히 사용하기 때문입니다. &lt;b&gt;유니 코드&lt;/b&gt; 의 출현으로 , 이미 의심되는이 구별은 그 의미를 훨씬 더 많이 상실합니다.</target>
        </trans-unit>
        <trans-unit id="2a50b726078402c27e07b8c0e368389163cec09c" translate="yes" xml:space="preserve">
          <source>Having to even think about the &lt;code&gt;$^S&lt;/code&gt; variable in your exception handlers is simply wrong. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; as currently implemented invites grievous and difficult to track down errors. Avoid it and use an &lt;code&gt;END{}&lt;/code&gt; or CORE::GLOBAL::die override instead.</source>
          <target state="translated">예외 처리기에서 &lt;code&gt;$^S&lt;/code&gt; 변수에 대해 생각 해야하는 것은 단순히 잘못된 것입니다. 현재 구현 된 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 은 슬프고 어려운 오류를 추적합니다. 이를 피하고 대신 &lt;code&gt;END{}&lt;/code&gt; 또는 CORE :: GLOBAL :: die 대체를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1824af5feb4f3df315f45b16c88c9796572c2341" translate="yes" xml:space="preserve">
          <source>Having zero modifiers makes this a no-op (so why did you specify it, unless it's generated code), and starting in v5.30, warns under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수정자가 0이면이 작업이 작동하지 않으며 (생성 된 코드가 아니라면 왜 지정 했습니까?) v5.30부터는 &lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict'&lt;/code&gt; &lt;/a&gt; 경고가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dd5e433024c5701e895446816548ab95da2bc1b" translate="yes" xml:space="preserve">
          <source>Hawai'ian</source>
          <target state="translated">Hawai'ian</target>
        </trans-unit>
        <trans-unit id="172ba6a86380c5b6896beb3518c06339ca0edf94" translate="yes" xml:space="preserve">
          <source>He elaborates: In &quot;I scanned %g directories&quot;, you'd</source>
          <target state="translated">그는 다음과 같이 설명합니다. &quot;내가 % g 개의 디렉토리를 스캔했습니다.&quot;에서</target>
        </trans-unit>
        <trans-unit id="b9670c78ad31649495cc9999c8a7211c06bd1e87" translate="yes" xml:space="preserve">
          <source>HeHASH</source>
          <target state="translated">HeHASH</target>
        </trans-unit>
        <trans-unit id="c5e6018dcb2cae886c9d1c47690a4c54c44362c1" translate="yes" xml:space="preserve">
          <source>HeKEY</source>
          <target state="translated">HeKEY</target>
        </trans-unit>
        <trans-unit id="9b0c456032d23a1f8428e404c8fc000632b68f15" translate="yes" xml:space="preserve">
          <source>HeKLEN</source>
          <target state="translated">HeKLEN</target>
        </trans-unit>
        <trans-unit id="381f36fe8447fe95ed079c250bb4b4ea3d7e634b" translate="yes" xml:space="preserve">
          <source>HePV</source>
          <target state="translated">HePV</target>
        </trans-unit>
        <trans-unit id="fdb5f6488be2e53e093eac0872e26f417981c939" translate="yes" xml:space="preserve">
          <source>HeSVKEY</source>
          <target state="translated">HeSVKEY</target>
        </trans-unit>
        <trans-unit id="447de7df6f86d340b3c07a2481291e089c189a73" translate="yes" xml:space="preserve">
          <source>HeSVKEY_force</source>
          <target state="translated">HeSVKEY_force</target>
        </trans-unit>
        <trans-unit id="4dfba14a02b68cc98a5e87bdeb926ccb87da936c" translate="yes" xml:space="preserve">
          <source>HeSVKEY_set</source>
          <target state="translated">HeSVKEY_set</target>
        </trans-unit>
        <trans-unit id="4067c20911f4da7e02f3110fa44de6d983420d3a" translate="yes" xml:space="preserve">
          <source>HeUTF8</source>
          <target state="translated">HeUTF8</target>
        </trans-unit>
        <trans-unit id="9335e04810db397c2e35f214a69df586b346125d" translate="yes" xml:space="preserve">
          <source>HeVAL</source>
          <target state="translated">HeVAL</target>
        </trans-unit>
        <trans-unit id="fec5f9830205e3861054b7879046770547986753" translate="yes" xml:space="preserve">
          <source>Head.U</source>
          <target state="translated">Head.U</target>
        </trans-unit>
        <trans-unit id="0c0e898a8ae956ef15e057a684b77851cb08216e" translate="yes" xml:space="preserve">
          <source>Head1 through head4 produce headings, head1 being the highest level. The text in the rest of this paragraph is the content of the heading. For example:</source>
          <target state="translated">Head1에서 head4까지는 표제를 생성하며 head1은 최상위 레벨입니다. 이 단락의 나머지 부분에있는 텍스트는 제목의 내용입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a96c65c60dd2beb6caf0aeaa3157c363f099df86" translate="yes" xml:space="preserve">
          <source>Headers mentioned in the RFCs and some other, well-known headers are generated with their canonical case. Other headers are sent in the case provided by the user. Except for control headers (which are sent first), headers are sent in arbitrary order.</source>
          <target state="translated">RFC 및 기타 잘 알려진 헤더에 언급 된 헤더는 표준 케이스로 생성됩니다. 다른 헤더는 사용자가 제공 한 경우에 전송됩니다. 제어 헤더 (먼저 전송 됨)를 제외하고 헤더는 임의의 순서로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="967ca9215da8ba98cad45c97fab5f98884cce72e" translate="yes" xml:space="preserve">
          <source>Heading Content&quot; command or to a &quot;=item Item Content&quot; command. This specification does not specify what behavior should be in the case of a given document having several things all seeming to produce the same</source>
          <target state="translated">제목 내용 &quot;명령 또는&quot;= 항목 항목 내용 &quot;명령.이 사양에서는 여러 문서가 모두 동일한 것으로 보이는 특정 문서의 경우 어떤 동작을 수행해야하는지 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a7c06f07a69ec449fd37c3b79a4e6409f1c6971" translate="yes" xml:space="preserve">
          <source>Hearing the word &quot;in&quot; is an</source>
          <target state="translated">&quot;에&quot;라는 단어를 듣는 것은</target>
        </trans-unit>
        <trans-unit id="7801d25365100494fe3fa68254035e723fdad847" translate="yes" xml:space="preserve">
          <source>Hebrew; now it doesn't.</source>
          <target state="translated">헤브라이 사람; 지금은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84135281bd9f7278283b58aab96226bf3b6fa87a" translate="yes" xml:space="preserve">
          <source>Heed the moderators.</source>
          <target state="translated">중재자에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="a675c00310a9bb5810f1eb379886d21c46bbc50c" translate="yes" xml:space="preserve">
          <source>Help save the world! Share your code in a form that makes it easy to reuse.</source>
          <target state="translated">세상을 구하십시오! 재사용하기 쉬운 형태로 코드를 공유하십시오.</target>
        </trans-unit>
        <trans-unit id="72b65259063cf5501bdb369bad55680bb3e05273" translate="yes" xml:space="preserve">
          <source>Help testing test modules built with Test::Builder</source>
          <target state="translated">Test :: Builder로 빌드 한 테스트 모듈 테스트 지원</target>
        </trans-unit>
        <trans-unit id="dfa0352ee0b635278bac396dced255cafcd73368" translate="yes" xml:space="preserve">
          <source>HelpMessage</source>
          <target state="translated">HelpMessage</target>
        </trans-unit>
        <trans-unit id="b604e9e00b8aff400d6b282c4559d7681123e27e" translate="yes" xml:space="preserve">
          <source>Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">Perl에서 구현 된 PerlIO 레이어를위한 헬퍼 클래스</target>
        </trans-unit>
        <trans-unit id="d26b8b46f8f2af4fb8c967fdcb3034722b09bfec" translate="yes" xml:space="preserve">
          <source>Helper for &lt;code&gt;grok_number()&lt;/code&gt;, accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">&lt;code&gt;grok_number()&lt;/code&gt; 대한 도우미는 &quot;무한&quot;또는 &quot;숫자가 아님&quot;을 철자하는 다양한 방법을 허용하고 다음 플래그 조합 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4057a75cb8ff5877d986e9f1a93f90da05a4393c" translate="yes" xml:space="preserve">
          <source>Helper for grok_number(), accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">grok_number ()의 헬퍼는 &quot;무한대&quot;또는 &quot;숫자가 아님&quot;의 다양한 철자법을 허용하며 다음 플래그 조합 중 하나를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d886854c3e45c23f2a67ad8886bba6332d21933" translate="yes" xml:space="preserve">
          <source>Helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils :: Constant의 도우미 함수</target>
        </trans-unit>
        <trans-unit id="2ec89dcb4b12d932844486071240245216868013" translate="yes" xml:space="preserve">
          <source>Helper routine for &lt;a href=&quot;ExtUtils::MM_Unix#fixin&quot;&gt;MM-&amp;gt;fixin()&lt;/a&gt;, overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">&lt;a href=&quot;ExtUtils::MM_Unix#fixin&quot;&gt;MM-&amp;gt; fixin ()에&lt;/a&gt; 대한 도우미 루틴 , 셸에서 해석 할 실제 shebang 줄과 같은 것이 없기 때문에 재정의되었으므로 $ Config {startperl} 앞에 추가하고 포함 할 수있는 모든 스위치에 대해 shebang 줄 인수를 유지합니다. .</target>
        </trans-unit>
        <trans-unit id="537e8e5aa520f3bdee23b191d8b4efb107769f00" translate="yes" xml:space="preserve">
          <source>Helper routine for MM-&amp;gt;fixin(), overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">쉘에 의해 해석 될 실제 shebang 행이 없기 때문에 MM-&amp;gt; fixin ()의 헬퍼 루틴이 재정의되므로 $ Config {startperl} 앞에 추가하고 포함 할 수있는 모든 스위치에 대해 shebang 행 인수를 보존합니다 .</target>
        </trans-unit>
        <trans-unit id="754ebef25d2322da9a737d155f7bf715f1ba74eb" translate="yes" xml:space="preserve">
          <source>Helper subroutine for subdirs</source>
          <target state="translated">서브 디렉토리에 대한 헬퍼 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8a7149426bc5c4ad71c933b4d1d21cfffd9c3bea" translate="yes" xml:space="preserve">
          <source>Helpers for POD parsing and conversion</source>
          <target state="translated">POD 파싱 및 변환을위한 도우미</target>
        </trans-unit>
        <trans-unit id="a1d186be4c77271bc365d307a5b69f017e030f41" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;unimport&lt;/code&gt; 루틴에서 호출되는 &lt;b&gt;컴파일시&lt;/b&gt; 사용자의 코드.</target>
        </trans-unit>
        <trans-unit id="e2cc4b7767688df7b44bdf876b726e44848c3c3c" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">따라서 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;unimport&lt;/code&gt; 루틴에서 호출되는 &lt;b&gt;컴파일시&lt;/b&gt; 사용자의 코드.</target>
        </trans-unit>
        <trans-unit id="1698c95c1d69a8153fa73a579994fee537ea27f4" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt; .</source>
          <target state="translated">따라서 당신은 그것을 추상화하기 위해 다음과 같은 간단한 함수를 도출합니다. 주어진 두 정수 사이의 임의의 정수를 선택합니다 (포함). 예를 들어 &lt;code&gt;random_int_between(50,120)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4370860a4cda36f4a61b51bfe47376529e7c3d64" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt;.</source>
          <target state="translated">따라서 당신은 그것을 추상화하기 위해 다음과 같은 간단한 함수를 유도합니다. 주어진 두 정수 (포함) 사이에서 임의의 정수를 선택합니다. 예 : &lt;code&gt;random_int_between(50,120)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc265d279911dd3bbb1e57f33ddb7cc94242a04f" translate="yes" xml:space="preserve">
          <source>Hence, at this point, the start of the buffer that we allocated lives at &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; in memory and the PV pointer is pointing into the middle of this allocated storage.</source>
          <target state="translated">따라서이 시점에서 우리가 할당 한 버퍼의 시작은 메모리의 &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; 에 있고 PV 포인터는이 할당 된 스토리지의 중간을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="045ed35d9ead65236dd53e0cae88ac0c2f700143" translate="yes" xml:space="preserve">
          <source>Hence, checking &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; is the best way to see whether something is a scalar.</source>
          <target state="translated">따라서 &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; 를 확인하는 것이 스칼라인지 확인하는 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="556105a47e879b5cd197003b03f2c9d9168ed783" translate="yes" xml:space="preserve">
          <source>Hence, if you load this module on Perl 5.26.0, you will get one warning that the module is no longer supported; and the module will do nothing thereafter.</source>
          <target state="translated">따라서이 모듈을 Perl 5.26.0에로드하면 해당 모듈이 더 이상 지원되지 않는다는 경고가 표시됩니다. 그 이후에는 모듈이 아무 작업도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb8da77ebcbcb4587ef2329234538c69cccafa62" translate="yes" xml:space="preserve">
          <source>Hence, on Mac OS, both</source>
          <target state="translated">따라서 Mac OS에서는 둘 다</target>
        </trans-unit>
        <trans-unit id="28d05e677bb92a81e181eb6f8a5252850baf1f6f" translate="yes" xml:space="preserve">
          <source>Hence, putting it all together:</source>
          <target state="translated">따라서 모든 것을 종합하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78ae19820d96f656888a032f8938f666eaec4599" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">따라서 목록 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 을 호출하는 목적은 지정된 각 추출기를 반복하는 나머지 문자열에 적용하여 처리 된 문자열을 가능한 많은 겹치지 않는 필드로 분할하는 것입니다. 따라서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 Perl의 &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 서브 루틴 의 일반화 된 형태입니다 .</target>
        </trans-unit>
        <trans-unit id="0323aa4fd2151904fef4f800f370657ab5f29a7a" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;split&lt;/code&gt; subroutine.</source>
          <target state="translated">따라서 목록 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 을 호출하는 목적은 지정된 각 추출기를 문자열의 나머지 부분에 반복적으로 적용하여 처리 된 문자열을 가능한 한 많은 비 중첩 필드로 분할하는 것입니다. 따라서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 Perl의 &lt;code&gt;split&lt;/code&gt; 서브 루틴 의 일반화 된 형태입니다 .</target>
        </trans-unit>
        <trans-unit id="6e76b82b230d1b216ea5fc74faa050d88bd7bb1a" translate="yes" xml:space="preserve">
          <source>Henk P. Penning maintains a site that collects data about CPAN sites:</source>
          <target state="translated">Henk P. Penning은 CPAN 사이트에 대한 데이터를 수집하는 사이트를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7f6138ce4b63e599ea6c8a23a9a9d862a811b01c" translate="yes" xml:space="preserve">
          <source>Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt; - for the suggestion of creating directories recursively.</source>
          <target state="translated">Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt;-디렉토리를 재귀 적으로 생성 할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="7a134925882ae538ad42b93b5979387207fbfb32" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#state-VARLIST&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$ARTICLE&lt;/code&gt; 은 전역 (패키지) 스칼라 변수 여야합니다 . &lt;a href=&quot;#my-VARLIST&quot;&gt; &lt;code&gt;my&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#state-VARLIST&quot;&gt; &lt;code&gt;state&lt;/code&gt; 로&lt;/a&gt; 선언 된 변수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1f2206fdca717cfb115864c58cfc1242ec1e8f30" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$ARTICLE&lt;/code&gt; 은 전역 (패키지) 스칼라 변수 여야합니다 . &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8ff0824227f04d195446a9ca4c80c3a2f4841adc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$ARTICLE&lt;/code&gt; 은 전역 (패키지) 스칼라 변수 여야합니다 . &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="7adfbace1a84aad46b6dc65bb49ec212586f4854" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt; , but with opposite values.</source>
          <target state="translated">여기서 &lt;code&gt;--verbose&lt;/code&gt; 및 &lt;code&gt;--quiet&lt;/code&gt; 은 동일한 변수 &lt;code&gt;$verbose&lt;/code&gt; 제어 하지만 반대 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d3f64a7bd9317a944a7376aabb90068d62d19a13" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt;, but with opposite values.</source>
          <target state="translated">여기서 &lt;code&gt;--verbose&lt;/code&gt; 및 &lt;code&gt;--quiet&lt;/code&gt; 는 동일한 변수 &lt;code&gt;$verbose&lt;/code&gt; 제어 하지만 값은 반대입니다.</target>
        </trans-unit>
        <trans-unit id="869e9b788a94b86ab899941e02856974518155a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a 'tag team' handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">여기 &lt;code&gt;//g&lt;/code&gt; 및 &lt;code&gt;\G&lt;/code&gt; 한 정규 표현식에서 다른 문자열의 '태그 팀'핸드 오프를 만들 수 있습니다. 독립 하위 표현식이있는 정규 표현식은 문자열을 독립 하위 표현식으로 핸드 오프하고 문자열을 엔 클로징 정규 표현식으로 다시 핸드 오프하는 방식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="71e7bd7e0715889b83b0e1df6c21eb89086431d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a &quot;tag team&quot; handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">여기서 &lt;code&gt;/g&lt;/code&gt; 와 &lt;code&gt;\G&lt;/code&gt; 는 한 정규 표현식에서 다른 정규 표현식으로 문자열의 &quot;태그 팀&quot;핸드 오프를 만듭니다. 독립 하위 표현식이있는 정규 표현식은 이와 유사합니다. 문자열을 독립 하위 표현식으로 전달하고 문자열을 다시 둘러싸는 정규 표현식으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="4b495cc26b10b4cfa7edd523e971b1223bc39631" translate="yes" xml:space="preserve">
          <source>Here again Perl works just like the shell in that the &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; clobbers an existing file.</source>
          <target state="translated">여기서 다시 Perl은 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 가 기존 파일을 클로버 한다는 점에서 쉘처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="0b249e3305de27f4ee7d8f5a9ef3f95983593269" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place.</source>
          <target state="translated">다음은 Perl의 기능 (일부 키워드 및 명명 된 연산자와 같은 기능처럼 보이는 기능 포함)을 범주별로 정렬 한 것입니다. 일부 기능은 둘 이상의 위치에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ce8540faf1c5c6c5be2f416cad08509fdda29d23" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place. Any warnings, including those produced by keywords, are described in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">다음은 Perl의 함수 (일부 키워드 및 명명 된 연산자와 같이 함수처럼 보이는 것 포함)를 범주별로 정렬 한 것입니다. 일부 기능은 둘 이상의 위치에 나타납니다. 키워드에 의해 생산을 포함하여 모든 경고,에 설명 된 &lt;a href=&quot;perldiag&quot;&gt;것은 perldiag&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86585cb3324adc532f3c4c9a1e007eedd102a2eb" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 유용한 통조림 레시피 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="6b2a8b8e88687652afd4febd5437e6847aab7c6e" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;pack&lt;/code&gt; 및 &lt;code&gt;unpack&lt;/code&gt; 유용한 (아마도) 유용한 통조림 레시피 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="213525a9716fa0289377679cccd7e684d87732e5" translate="yes" xml:space="preserve">
          <source>Here are a couple of possibilities:</source>
          <target state="translated">몇 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc67517efb30f9fba9421a6919635fb13eb305fb" translate="yes" xml:space="preserve">
          <source>Here are a few example that show the capabilities of the module.</source>
          <target state="translated">다음은 모듈의 기능을 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="de690581aef8b0c61e87b43058be3d94a077aff4" translate="yes" xml:space="preserve">
          <source>Here are a few examples to demonstrate usage of Perl's benchmarking tools.</source>
          <target state="translated">다음은 Perl 벤치마킹 도구의 사용법을 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a8331c63f719d3fa459c3be0fc4500f91a2bc542" translate="yes" xml:space="preserve">
          <source>Here are a few examples which illustrate the key concepts - as such most of them are of little practical use.</source>
          <target state="translated">다음은 핵심 개념을 보여주는 몇 가지 예입니다. 대부분의 개념은 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d45496eb99d38ab7ab859d9d23312ec9997a265" translate="yes" xml:space="preserve">
          <source>Here are a few hints for creating high-quality patches:</source>
          <target state="translated">다음은 고품질 패치를 생성하기위한 몇 가지 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="ee5bae63f174379946589f4804bf6cb746e57ff8" translate="yes" xml:space="preserve">
          <source>Here are a few notes on the C function</source>
          <target state="translated">C 함수에 대한 몇 가지 참고 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cf9a82c924ee686ad6e561bd6e1b0affa2a2991" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">다음은 몇 가지 간단한 예입니다. 먼저 여러 배열을 함수에 전달하고 모든 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 표시하여 이전의 모든 마지막 요소의 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07bc756b4525b03a743a457897293bde8f42d28d" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;pop&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">다음은 몇 가지 간단한 예입니다. 먼저, 여러 배열을 함수에 전달하고 모든 것을 &lt;code&gt;pop&lt;/code&gt; 하여 이전의 모든 마지막 요소의 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="778c5e77d32e09526eea8078cdc25093f593316e" translate="yes" xml:space="preserve">
          <source>Here are a few ways, all painful, to deal with it:</source>
          <target state="translated">여기에 대처하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d368f7513a7890d1d9530618552892450a6a185" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at</source>
          <target state="translated">다음은 Berkeley DB FAQ에서 가져온 몇 가지 단어입니다.</target>
        </trans-unit>
        <trans-unit id="dbcbf329948c2249a19622b8073b1367ff9cb194" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;) regarding the license:</source>
          <target state="translated">다음은 라이센스와 관련하여 Berkeley DB FAQ ( &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt; ) 에서 발췌 한 몇 가지 단어입니다 .</target>
        </trans-unit>
        <trans-unit id="3de0d7b44e720bda0c9a25fbb58e38764c2a5fa0" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; in action:</source>
          <target state="translated">다음은 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="019f88f2ee6b0e36fd2598271f5d4aac4291dbff" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; in action:</source>
          <target state="translated">다음은 작동중인 &lt;code&gt;/s&lt;/code&gt; 및 &lt;code&gt;/m&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b13167d0662ec600bc247b1050d48340c5a1f9fa" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">다음은 여러 종류의 파일 열기 예입니다. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 을 사용하는 사람들은 모두 &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 에서 상수를 가져 왔다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="285c2ac838211f7ab63456da8593b46a7ba8d4ec" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;sysopen&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">다음은 여러 종류의 파일 열기 예입니다. &lt;code&gt;sysopen&lt;/code&gt; 을 사용하는 사람들은 모두 &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 에서 상수를 가져 왔다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b269a27d981a83ad06f7f43ed4b5271ebb95e10" translate="yes" xml:space="preserve">
          <source>Here are examples of the constructors and the valid options available for DB_HASH, DB_BTREE and DB_RECNO respectively.</source>
          <target state="translated">다음은 각각 DB_HASH, DB_BTREE 및 DB_RECNO에 사용 가능한 생성자와 유효한 옵션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="feffd8fe1a5cbaddbff753bfdc84e56b03609303" translate="yes" xml:space="preserve">
          <source>Here are some code samples showing a possible usage of Storable:</source>
          <target state="translated">다음은 Storable의 가능한 사용법을 보여주는 코드 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="b97373427a9280cf0da7790f9dd7dc5b0d29339d" translate="yes" xml:space="preserve">
          <source>Here are some concerns to keep in mind when using an endianness modifier:</source>
          <target state="translated">엔디안 수정자를 사용할 때 명심해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c18e94a9efc11f05f3d5f2b6edc571204b41c5d4" translate="yes" xml:space="preserve">
          <source>Here are some examples of how that works on an ASCII platform:</source>
          <target state="translated">다음은 ASCII 플랫폼에서 작동하는 방법에 대한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca06cec84a9ef5e9ca766f7b0195777a639a43ed" translate="yes" xml:space="preserve">
          <source>Here are some examples of how to use these:</source>
          <target state="translated">사용 방법에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84bd37d6cce9f50a387d161b1db1876dd2e66de5" translate="yes" xml:space="preserve">
          <source>Here are some examples of that:</source>
          <target state="translated">그 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb016178c05ee24cc48ff8dddc178e709d61edd0" translate="yes" xml:space="preserve">
          <source>Here are some examples of usage of the &quot;cmd&quot; shell:</source>
          <target state="translated">&quot;cmd&quot;쉘 사용법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b17211739968de398ac6cabe7b5c9c6e7b2ffe53" translate="yes" xml:space="preserve">
          <source>Here are some examples that explain the reasons why certain results occur while handling infinity:</source>
          <target state="translated">다음은 무한대를 처리하는 동안 특정 결과가 발생하는 이유를 설명하는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="5a87004d684b1273adb1c5dad1a3b884a901f693" translate="yes" xml:space="preserve">
          <source>Here are some examples that you should be able to type into your command shell:</source>
          <target state="translated">다음은 명령 셸에 입력 할 수있는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="1ffece14922bda83136b1a5ca004aee395c4815b" translate="yes" xml:space="preserve">
          <source>Here are some further observations based on experiments: The C runtime breaks arguments at spaces and passes them to programs in argc/argv. Double quotes can be used to prevent arguments with spaces in them from being split up. You can put a double quote in an argument by escaping it with a backslash and enclosing the whole argument within double quotes. The backslash and the pair of double quotes surrounding the argument will be stripped by the C runtime.</source>
          <target state="translated">다음은 실험을 기반으로 한 추가 관찰입니다. C 런타임은 공백에서 인수를 중단하고 argc / argv의 프로그램으로 전달합니다. 공백이있는 인수가 분리되지 않도록 큰 따옴표를 사용할 수 있습니다. 백 슬래시로 이스케이프 처리하고 큰 인수로 전체 인수를 묶으면 인수에 큰 따옴표를 넣을 수 있습니다. 인수를 둘러싼 백 슬래시와 큰 따옴표 쌍은 C 런타임에 의해 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a4980f1bbd2b4cd245b8c8043825f0a0babf7335" translate="yes" xml:space="preserve">
          <source>Here are some more examples</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0b595570315b5625b2174cdd7459401aaf7451f5" translate="yes" xml:space="preserve">
          <source>Here are some more examples; be aware that when using an explicit index, the &lt;code&gt;$&lt;/code&gt; may need escaping:</source>
          <target state="translated">다음은 몇 가지 예입니다. 명시 적 인덱스를 사용할 때 &lt;code&gt;$&lt;/code&gt; 는 이스케이프해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c694403eaca658591930c8c7c2bb34296f84a099" translate="yes" xml:space="preserve">
          <source>Here are some notable values:</source>
          <target state="translated">다음은 주목할만한 값입니다.</target>
        </trans-unit>
        <trans-unit id="cc7e40e86aef57a83594c5dfdd7f8a1c23f71b5f" translate="yes" xml:space="preserve">
          <source>Here are some other examples:</source>
          <target state="translated">다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5552dd4aff82cc5a2b99f42ba7a6d2949d5c6e2e" translate="yes" xml:space="preserve">
          <source>Here are some other functions:</source>
          <target state="translated">다른 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79024a11d0139db04c2facf9ae0e8d93da4c05aa" translate="yes" xml:space="preserve">
          <source>Here are some other more substantive style issues to think about:</source>
          <target state="translated">고려해야 할 다른 실질적인 스타일 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8de6ff6be7dbb16b2f90d46db02214f1b31982a4" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">다음은 구문 상 유효한 선언의 일부 샘플이며, perl에 의해 내부적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 호출 로 해석되는 방법에 대한 주석이 있습니다. 이 예제는 주로 패키지 정의 속성의 가능한 메소드 조회에 대해 &quot;적절한 패키지&quot;가 발견되는 방법을 보는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f09c78fd713d777b16d7b0dc7451ff268dfc7da3" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;use attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">다음은 구문 적으로 유효한 선언의 몇 가지 샘플이며, 내부적으로 perl에 의한 &lt;code&gt;use attributes&lt;/code&gt; 호출 로 해석되는 방법에 대한 주석이 있습니다. 이러한 예제는 패키지 정의 속성에 대한 가능한 메서드 조회에 대해 &quot;적절한 패키지&quot;를 찾는 방법을 확인하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ef6c8462426b25783d9f2c73bd41688e54925d5" translate="yes" xml:space="preserve">
          <source>Here are some variants, most of which don't work:</source>
          <target state="translated">다음은 일부 변형이며 대부분 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0361977099d002d67600facecf96ac617d8167ef" translate="yes" xml:space="preserve">
          <source>Here are the current possible types, with short descriptions:</source>
          <target state="translated">간단한 설명과 함께 현재 가능한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67895007dd0c6840199574bcaf648ce79505acd6" translate="yes" xml:space="preserve">
          <source>Here are the methods for the DotFiles tied hash.</source>
          <target state="translated">다음은 DotFiles 연결 해시의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bdd9e497208f79834038783c1e02aab82a664f8b" translate="yes" xml:space="preserve">
          <source>Here are the methods:</source>
          <target state="translated">방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="308b3fd3c823fd8f4a8be7a1c05819c0bdbe51b4" translate="yes" xml:space="preserve">
          <source>Here are the places where Perl will assume &lt;code&gt;$_&lt;/code&gt; even if you don't use it:</source>
          <target state="translated">사용하지 않더라도 Perl이 &lt;code&gt;$_&lt;/code&gt; 가정하는 장소는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0a9a64ecb96bf415307190a704ba59f675ea62cc" translate="yes" xml:space="preserve">
          <source>Here are the possible keys for the hash:</source>
          <target state="translated">해시에 사용할 수있는 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="133a7307c88c0ca94d0fd77ce650ab97042a4831" translate="yes" xml:space="preserve">
          <source>Here are the quote-like operators that apply to pattern matching and related activities.</source>
          <target state="translated">패턴 일치 및 관련 활동에 적용되는 따옴표와 같은 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c59988c08aece7bd08debf7ada77c7366bd57099" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt; ; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 에서 사용되는 규칙은 다음과 같습니다 . 우리는 유닉스와 최대한 호환되도록 노력합니다.</target>
        </trans-unit>
        <trans-unit id="3ed36fd5ffaf22cc0a28878706f0e8bf6dac1f65" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt;; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">다음은 &lt;code&gt;catdir()&lt;/code&gt; 에서 사용되는 규칙입니다 . 가능한 한 Unix와 호환되도록 노력합니다.</target>
        </trans-unit>
        <trans-unit id="4aa7fef747fea48e4e4795cd9eaeefa09930bbdb" translate="yes" xml:space="preserve">
          <source>Here are the short and long forms of the values the &lt;code&gt;General Category&lt;/code&gt; property can have:</source>
          <target state="translated">다음은 &lt;code&gt;General Category&lt;/code&gt; 속성이 가질 수있는 짧고 긴 형식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="420394a2a2618e29901a0ab672922a30d23423d8" translate="yes" xml:space="preserve">
          <source>Here are the statistics for Perl 5.005_62 on my system:</source>
          <target state="translated">내 시스템의 Perl 5.005_62에 대한 통계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd03473c869638bd902e9d6b0f20d91be736706a" translate="yes" xml:space="preserve">
          <source>Here are the suggested ways of modifying your include path, including environment variables, run-time switches, and in-code statements:</source>
          <target state="translated">환경 변수, 런타임 스위치 및 코드 내 명령문을 포함하여 포함 경로를 수정하는 제안 된 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c09b558fc05cb8053f5a3187154e8896a601ad3a" translate="yes" xml:space="preserve">
          <source>Here are the ways that Perl knows that a string should be treated as Unicode:</source>
          <target state="translated">문자열을 유니 코드로 처리해야한다는 것을 Perl이 알고있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4358e9bb262d19ae65de17de5c9b7a341e07eea3" translate="yes" xml:space="preserve">
          <source>Here are what those parameters to the new() constructor mean:</source>
          <target state="translated">new () 생성자에 대한 매개 변수의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3c80c52da3a7596fb4bd95e7f557fcc03ea2102" translate="yes" xml:space="preserve">
          <source>Here documents are found in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. Check for these three things:</source>
          <target state="translated">여기서 문서는 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 에서 찾을 수 있습니다. 다음 세 가지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="484c5007fac2b871f4ec1de41d18168107149ae5" translate="yes" xml:space="preserve">
          <source>Here in our DotFiles example, we'll be careful not to let them try to overwrite the file unless they've called the clobber() method on the original object reference returned by tie().</source>
          <target state="translated">여기서는 DotFiles 예제에서 tie ()에 의해 반환 된 원래 객체 참조에서 clobber () 메서드를 호출하지 않는 한 파일을 덮어 쓰지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="47c02f53e38b9b0fb6a0ae2769d47d0a5b5b6556" translate="yes" xml:space="preserve">
          <source>Here is a DBM Filter that does it:</source>
          <target state="translated">이를 수행하는 DBM 필터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f525e8a25cabfe7d14de3785ff13475d1795d58b" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine which prints whatever parameters are passed to it.</source>
          <target state="translated">다음은 전달 된 매개 변수를 인쇄하는 Perl 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="45cd387e7d7083c724152df763a18216115c4120" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine,</source>
          <target state="translated">Perl 서브 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="badb362bb0ad7ef4caa28ee99b671c9b8a6d2d3a" translate="yes" xml:space="preserve">
          <source>Here is a brief checklist on how to use Maketext to localize applications:</source>
          <target state="translated">다음은 Maketext를 사용하여 응용 프로그램을 지역화하는 방법에 대한 간단한 점검 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e180555a648403b54c19cc98b95102cc9c7da450" translate="yes" xml:space="preserve">
          <source>Here is a code snippet to tell what &quot;word&quot; characters are in the current locale, in that locale's order:</source>
          <target state="translated">다음은 현재 로케일에있는 &quot;워드&quot;문자를 해당 로케일 순서로 알려주는 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="1d9d16b43d949b27c929aa01a0989059daef7367" translate="yes" xml:space="preserve">
          <source>Here is a crude diagram of how filehandle, PerlIO, and Encode interact.</source>
          <target state="translated">다음은 filehandle, PerlIO 및 Encode가 상호 작용하는 방식에 대한 대략적인 다이어그램입니다.</target>
        </trans-unit>
        <trans-unit id="8cd600b00d9b275c1b848cf418f2f3dc7bc149f6" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface available:</source>
          <target state="translated">사용 가능한 인터페이스의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ffd58769a04701c527d60f25ae6cee8c3577aa1" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface:</source>
          <target state="translated">인터페이스 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86773bb3e419f5d3ec6cdc84464ead386b08f646" translate="yes" xml:space="preserve">
          <source>Here is a filter which a variation of the &lt;code&gt;Joe2Jim&lt;/code&gt; filter. As well as substituting all occurrences of &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; it keeps a count of the number of substitutions made in the context object.</source>
          <target state="translated">다음은 &lt;code&gt;Joe2Jim&lt;/code&gt; 필터 의 변형 된 필터입니다. &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 의 모든 발생 을 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 으로 대체 할뿐만 아니라 컨텍스트 오브젝트에서 작성된 대체 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4d0499c68821327c798829729804b1a0bcda02ab" translate="yes" xml:space="preserve">
          <source>Here is a formula to ensurrogate a Unicode character \x{10000} and above;</source>
          <target state="translated">다음은 유니 코드 문자 \ x {10000} 이상을 포괄하는 공식입니다.</target>
        </trans-unit>
        <trans-unit id="5e13ad2f9de57b9ee78127b86f1be789cace5f69" translate="yes" xml:space="preserve">
          <source>Here is a less often used example:</source>
          <target state="translated">덜 자주 사용되는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8615e06af1883810bfc6afe31e15071d09d0a5c7" translate="yes" xml:space="preserve">
          <source>Here is a list of additional methods:</source>
          <target state="translated">다음은 추가 방법 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0815879d63f4c647e36f2a3e53c2a854eb38d7a9" translate="yes" xml:space="preserve">
          <source>Here is a list of facet types by package. The packages are not used internally, but are where the documentation for each type is kept.</source>
          <target state="translated">다음은 패키지 별 패싯 유형 목록입니다. 패키지는 내부적으로 사용되지 않지만 각 유형에 대한 문서가 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f9d3fd360afdcd3acc8bec172ad26a0315b6d8" translate="yes" xml:space="preserve">
          <source>Here is a list of the common features of the anonymous sub and the &lt;code&gt;filter()&lt;/code&gt; method.</source>
          <target state="translated">다음은 익명 서브와 &lt;code&gt;filter()&lt;/code&gt; 메소드 의 공통 기능 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="1832b72be8a1d9f95753e5f4c415597ea4ff02d1" translate="yes" xml:space="preserve">
          <source>Here is a list of the valid options:</source>
          <target state="translated">유효한 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8914294fa8d99540ed79b9d165dee16297f1d6a9" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt; :</source>
          <target state="translated">다음은 &lt;code&gt;given&lt;/code&gt; 더 긴 예입니다 .</target>
        </trans-unit>
        <trans-unit id="770b47b87a22658ce1106c32715d366b237fafe0" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;given&lt;/code&gt; 더 긴 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b951146917555dc2bff07eaf853fe90ebe90da08" translate="yes" xml:space="preserve">
          <source>Here is a more complete description of how &lt;code&gt;carp&lt;/code&gt; and &lt;code&gt;croak&lt;/code&gt; work. What they do is search the call-stack for a function call stack where they have not been told that there shouldn't be an error. If every call is marked safe, they give up and give a full stack backtrace instead. In other words they presume that the first likely looking potential suspect is guilty. Their rules for telling whether a call shouldn't generate errors work as follows:</source>
          <target state="translated">&lt;code&gt;carp&lt;/code&gt; 와 &lt;code&gt;croak&lt;/code&gt; 작동 방식에 대한 자세한 설명은 다음과 같습니다 . 그들이하는 일은 오류가 없어야한다는 말을하지 않은 함수 호출 스택을 호출 스택에서 검색하는 것입니다. 모든 통화가 안전하다고 표시되면 포기하고 전체 스택 역 추적을 제공합니다. 다시 말해 그들은 잠재적으로 보이는 첫 번째 용의자가 유죄라고 추정합니다. 호출이 오류를 발생시키지 않아야 하는지를 알려주는 규칙은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="faf8b9ff2265f8681cbbc8e12a3625240f11fc4d" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt;).</source>
          <target state="translated">다음은 위에서 설명한 방법 중 일부를 사용하는보다 완전한 예입니다. 또한 API 인터페이스를 직접 사용합니다 ( &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;API 인터페이스&quot;참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9d5f1ad420c45c5ca7b8cd720763979928a0e80" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;).</source>
          <target state="translated">다음은 위에서 설명한 일부 방법을 사용하는보다 완전한 예입니다. 또한 직접 API 인터페이스를 사용 (참조하게 &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;는 API 인터페이스&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="481b0824c1ad273d7763f1ffdf818909caa88617" translate="yes" xml:space="preserve">
          <source>Here is a possible workaround: create a toplevel</source>
          <target state="translated">가능한 해결 방법은 다음과 같습니다. 최상위 수준을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aac02f3544d72b59392576f2e2d1edbb502cf904" translate="yes" xml:space="preserve">
          <source>Here is a real example. Netscape 2.0 keeps a record of the locations you visit along with the time you last visited them in a DB_HASH database. This is usually stored in the file</source>
          <target state="translated">다음은 실제 예입니다. Netscape 2.0은 사용자가 방문한 위치와 마지막으로 방문한 시간을 DB_HASH 데이터베이스에 기록합니다. 이것은 일반적으로 파일에 저장됩니다</target>
        </trans-unit>
        <trans-unit id="645c6ed6c5edc9279cd1369bce1c3b76531901ff" translate="yes" xml:space="preserve">
          <source>Here is a sample chunk of code to break up and put back together again some fixed-format input lines, in this case from the output of a normal, Berkeley-style ps:</source>
          <target state="translated">다음은 일반적인 버클리 스타일 ps의 출력에서 ​​일부 고정 형식 입력 행을 분리하고 다시 결합하는 샘플 코드입니다.</target>
        </trans-unit>
        <trans-unit id="38eab965034c311c9ba1e3fb718a8ef1f540a4a4" translate="yes" xml:space="preserve">
          <source>Here is a script that saves, redirects, and restores &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; using various methods:</source>
          <target state="translated">다음은 다양한 방법을 사용하여 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 을 저장, 리디렉션 및 복원하는 스크립트입니다 .</target>
        </trans-unit>
        <trans-unit id="bf170b2ef98b6313890763a8318d77c620c61ec2" translate="yes" xml:space="preserve">
          <source>Here is a script which uses it:</source>
          <target state="translated">이를 사용하는 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d109e8133d36be8ec27bcf8a10b412b1b37621e9" translate="yes" xml:space="preserve">
          <source>Here is a short breakdown of perl's operation:</source>
          <target state="translated">다음은 펄 운영에 대한 간단한 분석입니다.</target>
        </trans-unit>
        <trans-unit id="b641d2582f209503d29beece571a8e6d76517863" translate="yes" xml:space="preserve">
          <source>Here is a short example which shows how &lt;code&gt;IO::Select&lt;/code&gt; could be used to write a server which communicates with several sockets while also listening for more connections on a listen socket</source>
          <target state="translated">다음은 &lt;code&gt;IO::Select&lt;/code&gt; 사용하여 여러 소켓과 통신하는 서버를 작성하고 청취 소켓에서 더 많은 연결을 수신 하는 방법을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f42a88335a66627a85ff6a9bee66b1f0bc358b5d" translate="yes" xml:space="preserve">
          <source>Here is a short, but incomplete summary:</source>
          <target state="translated">짧지 만 불완전한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="120acde3518e6786e0d2c79e05b71648be345e7b" translate="yes" xml:space="preserve">
          <source>Here is a simple XSUB which illustrates the mechanics of calling both the &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; methods from C.</source>
          <target state="translated">다음은 C에서 &lt;code&gt;PrintID&lt;/code&gt; 및 &lt;code&gt;Display&lt;/code&gt; 메소드를 호출하는 메커니즘을 보여주는 간단한 XSUB입니다 .</target>
        </trans-unit>
        <trans-unit id="fe479990bde1cedb7827b08a0b51384331185af7" translate="yes" xml:space="preserve">
          <source>Here is a simple constructor:</source>
          <target state="translated">다음은 간단한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="8cf9fcb79a6528df89e621ddbe45b24482b8eaf2" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how to add a new target to the generated Makefile:</source>
          <target state="translated">다음은 생성 된 Makefile에 새 대상을 추가하는 방법에 대한 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="68aa8a40a88c99ac15d963facbd3494dfdead354" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">다음은 &lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt; 코어 모듈을 사용하는 기술의 간단한 예입니다 . 이 모듈은 인사이드 아웃 객체 구현을 지원하기 위해 코어에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="40cda83fc05639dd468f5eab757cfe3f54097a29" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">다음은 &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt; 코어 모듈을 사용하는 간단한 기술 예입니다 . 이 모듈은 내부 객체 구현을 지원하기 위해 코어에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="559816aad9ae4c16103f091e70123c0b683add53" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;&quot;Extra RECNO Methods&quot;&lt;/a&gt; for a workaround).</source>
          <target state="translated">다음은 RECNO를 사용하는 간단한 예제입니다 (5.004_57 이전 버전의 Perl을 사용하는 경우이 예제는 작동하지 않습니다 . 해결 &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;방법&lt;/a&gt; 은 &quot;추가 RECNO 방법&quot; 참조 ).</target>
        </trans-unit>
        <trans-unit id="126689dd133c61c2158a4c313ed301c9a4876c96" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;Extra RECNO Methods&lt;/a&gt; for a workaround).</source>
          <target state="translated">다음은 RECNO를 사용하는 간단한 예입니다 (5.004_57 이전의 Perl 버전을 사용하는 경우이 예는 작동하지 않습니다 . 임시 해결책 은 &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;추가 RECNO 메소드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="319b9d58a92f86f8037b1f0bce75684db1494b7b" translate="yes" xml:space="preserve">
          <source>Here is a skeleton for the</source>
          <target state="translated">여기에 대한 골격이 있습니다</target>
        </trans-unit>
        <trans-unit id="550484c98d2783ef867d760a633e2f2132a4d47b" translate="yes" xml:space="preserve">
          <source>Here is a snippet of XSUB which defines</source>
          <target state="translated">다음은 XSUB의 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="002abcfd840947931c322494ad132e91e82ebd0f" translate="yes" xml:space="preserve">
          <source>Here is a snippet of code that is loosely based on Tom Christiansen's</source>
          <target state="translated">Tom Christiansen의 느슨한 코드를 기반으로 한 코드 스 니펫은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45cde31767fc2f9538502554458696cb23085fa9" translate="yes" xml:space="preserve">
          <source>Here is a trivial XSUB which prints the context in which it is currently executing.</source>
          <target state="translated">다음은 현재 실행중인 컨텍스트를 인쇄하는 간단한 XSUB입니다.</target>
        </trans-unit>
        <trans-unit id="10eee1483a3720a88b88f2a6e6f0dd7de0f97165" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt; . It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">다음은 &lt;code&gt;deflate&lt;/code&gt; 사용의 간단한 예입니다 . 단순히 표준 입력을 읽고 수축시켜 표준 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="c80454242f7e359341fe858a8036d1c91f6e349e" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt;. It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">다음은 &lt;code&gt;deflate&lt;/code&gt; 사용의 간단한 예입니다 . 단순히 표준 입력을 읽고 수축 한 다음 표준 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="41ea711e9831279932d6165629ca443cfabce37a" translate="yes" xml:space="preserve">
          <source>Here is a typical example of context popping, as found in &lt;code&gt;pp_leavesub&lt;/code&gt; (simplified slightly):</source>
          <target state="translated">다음은 &lt;code&gt;pp_leavesub&lt;/code&gt; (약간 단순화 됨) 에서 볼 수있는 일반적인 컨텍스트 팝핑의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1868baee762e5828998b63475228ea8991afb128" translate="yes" xml:space="preserve">
          <source>Here is a very brief example of a policy module that expires each cache item after ten seconds.</source>
          <target state="translated">다음은 10 초 후에 각 캐시 항목을 만료시키는 정책 모듈의 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7f88bfdf5db7c3c03b6f8f2495da889972cfe524" translate="yes" xml:space="preserve">
          <source>Here is a very spartan uudecoder that will work on EBCDIC:</source>
          <target state="translated">다음은 EBCDIC에서 작동하는 스파르타 우 데코더입니다.</target>
        </trans-unit>
        <trans-unit id="d946c977086b5be12c98dcb6ff1ce5c76b228d28" translate="yes" xml:space="preserve">
          <source>Here is an efficient way to delete all files that haven't been modified for at least a week:</source>
          <target state="translated">적어도 일주일 동안 수정되지 않은 모든 파일을 삭제하는 효율적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70fccfa6b6af36450513847e29399b60a48adeac" translate="yes" xml:space="preserve">
          <source>Here is an example from big5-eten.</source>
          <target state="translated">다음은 big5-eten의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e9c9019a4b9d1c2c747c162dad5a190290c7d35f" translate="yes" xml:space="preserve">
          <source>Here is an example of backtracking: Let's say you want to find the word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</source>
          <target state="translated">역 추적의 예는 다음과 같습니다. &quot;Food is the foo table&quot;문자열에서 &quot;foo&quot;뒤에 나오는 단어를 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="ea40af6afb8d235271ee69af60576e5fd7626d85" translate="yes" xml:space="preserve">
          <source>Here is an example of how to access the option name and value from within a subroutine:</source>
          <target state="translated">다음은 서브 루틴 내에서 옵션 이름과 값에 액세스하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="205e5e253d5e8d9713777fb82bdd5445436cb1b6" translate="yes" xml:space="preserve">
          <source>Here is an example of how your own code can go broken:</source>
          <target state="translated">다음은 자신의 코드가 어떻게 손상 될 수 있는지에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="748768cc7486ba197e2bf8648f0ea7277ae15d72" translate="yes" xml:space="preserve">
          <source>Here is an example of the script which &quot;calculates&quot; the side of circumscribed octagon using the above package:</source>
          <target state="translated">위 패키지를 사용하여 외접 팔각형의면을 &quot;계산&quot;하는 스크립트의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="404268aa749a8cb74398fcef4885ddfb5e393936" translate="yes" xml:space="preserve">
          <source>Here is an example of these principles in action:</source>
          <target state="translated">다음은 이러한 원칙의 실제 예입니다.</target>
        </trans-unit>
        <trans-unit id="d36af1892ac909ba4b83e53e087863bb90d56692" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;NVtime&lt;/code&gt; from C:</source>
          <target state="translated">다음은 C에서 &lt;code&gt;NVtime&lt;/code&gt; 을 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="7c9994bdad12e2f359f710fa2f6ef403d1effd52" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt; .</source>
          <target state="translated">다음은 &lt;code&gt;inflate&lt;/code&gt; 를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="db70c2ba72c1ebe893c3bd333e0df1b322d0b57a" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;inflate&lt;/code&gt; 사용의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e2da397e1c17983df2e6041276a4e28620f94d" translate="yes" xml:space="preserve">
          <source>Here is an example of using an optional parameter to override the default buffer size.</source>
          <target state="translated">다음은 선택적 버퍼를 사용하여 기본 버퍼 크기를 재정의하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8f3c57546ccedafc9770a8f0efa81f37adc91294" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">다음은 &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; 선택적 매개 변수 목록을 사용하여 기본 버퍼 크기와 압축 수준을 재정의하는 예입니다. 다른 모든 옵션은 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87545ecf0b6e7815b60232cfb74673f436cd6fe1" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;deflateInit&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">다음은 &lt;code&gt;deflateInit&lt;/code&gt; 선택적 매개 변수 목록을 사용하여 기본 버퍼 크기 및 압축 레벨을 대체 하는 예입니다 . 다른 모든 옵션은 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="09d05a4a26dea0db21fa2d5b84da51786c319d41" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;inflateInit&lt;/code&gt; optional parameter to override the default buffer size.</source>
          <target state="translated">다음은 &lt;code&gt;inflateInit&lt;/code&gt; 선택적 매개 변수를 사용 하여 기본 버퍼 크기를 대체 하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c7cbd7a5ef78ce531e711de3f32a263a9851ff1b" translate="yes" xml:space="preserve">
          <source>Here is an example of using the filter:</source>
          <target state="translated">필터를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4ff3e36580b38b61c7a227d4955c81060aeb814" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Filter::sh&lt;/code&gt; 를 사용하는 예제 스크립트는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="626be57a73915f6479e3b15d4d6386f5b48c7020" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Filter::sh&lt;/code&gt; 를 사용하는 예제 스크립트입니다 .</target>
        </trans-unit>
        <trans-unit id="012645975f14da1f34bb102f202aaf2953a30bc6" translate="yes" xml:space="preserve">
          <source>Here is an example script which uses the interface. It implements a</source>
          <target state="translated">다음은 인터페이스를 사용하는 스크립트 예입니다. 그것은 구현</target>
        </trans-unit>
        <trans-unit id="1cbf7c7be1c22fad45e3015eadd538010d85816f" translate="yes" xml:space="preserve">
          <source>Here is an example that makes use of this tie:</source>
          <target state="translated">이 넥타이를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8ff5767311ec468cc89661ca51ca82e04f18ab9" translate="yes" xml:space="preserve">
          <source>Here is an example that renames all c files to cpp.</source>
          <target state="translated">다음은 모든 c 파일의 이름을 cpp로 바꾸는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="80e0e9e4bb3140e634ddeaa722387560a0149a79" translate="yes" xml:space="preserve">
          <source>Here is an example to illustrate how the bits actually fall in place:</source>
          <target state="translated">다음은 비트가 실제로 어떻게 배치되는지 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d0e29b3fe9551af38ec63a152fe4f4ef139ee92e" translate="yes" xml:space="preserve">
          <source>Here is an example where a string containing blank-separated words, numbers and single dashes is to be split into its components. Using &lt;code&gt;/\s+/&lt;/code&gt; alone won't work, because spaces are not required between dashes, or a word or a dash. Additional places for a split are established by looking ahead and behind:</source>
          <target state="translated">다음은 공백으로 분리 된 단어, 숫자 및 단일 대시를 포함하는 문자열을 해당 구성 요소로 분할하는 예입니다. 사용 &lt;code&gt;/\s+/&lt;/code&gt; 혼자하지 않습니다 작업 공간은 대시 또는 단어 나 대시 사이에 필요하지 않기 때문에. 분할을위한 추가 장소는 앞뒤로보고 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b737180e2561bd5a0699f794a8b8783a4667057" translate="yes" xml:space="preserve">
          <source>Here is an example which illustrates the problem from a &lt;b&gt;DB_File&lt;/b&gt; perspective:</source>
          <target state="translated">다음은 &lt;b&gt;DB_File&lt;/b&gt; 관점 에서 문제점을 설명하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f644e6370d9a6fe28106ff279c08d32f76b322b7" translate="yes" xml:space="preserve">
          <source>Here is an extreme example. Consider the Fibonacci sequence, defined by the following function:</source>
          <target state="translated">다음은 극단적 인 예입니다. 다음 함수로 정의 된 피보나치 시퀀스를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="87cc084321780edd34384cbc3149445fe191a094" translate="yes" xml:space="preserve">
          <source>Here is an interesting idea that doesn't involve the Debug filter. Currently Perl subroutines have fairly limited support for formal parameter lists. You can specify the number of parameters and their type, but you still have to manually take them out of the &lt;code&gt;@_&lt;/code&gt; array yourself. Write a source filter that allows you to have a named parameter list. Such a filter would turn this:</source>
          <target state="translated">다음은 디버그 필터와 관련이없는 흥미로운 아이디어입니다. 현재 Perl 서브 루틴은 공식 매개 변수 목록에 대한 지원이 상당히 제한되어 있습니다. 매개 변수의 수와 유형을 지정할 수 있지만 여전히 수동으로 &lt;code&gt;@_&lt;/code&gt; 배열에서 직접 가져와야 합니다. 명명 된 매개 변수 목록을 가질 수있는 소스 필터를 작성하십시오. 그러한 필터는 이것을 돌릴 것입니다 :</target>
        </trans-unit>
        <trans-unit id="cdf048c5ea517c38dde03f3aa3ec4c135c3bd31b" translate="yes" xml:space="preserve">
          <source>Here is another real-life example. By default, whenever Perl writes to a DBM database it always writes the key and value as strings. So when you use this:</source>
          <target state="translated">또 다른 실제 예가 있습니다. 기본적으로 Perl은 DBM 데이터베이스에 쓸 때마다 항상 키와 값을 문자열로 기록합니다. 따라서 이것을 사용할 때 :</target>
        </trans-unit>
        <trans-unit id="25d95fcca3eab15fb28653dc8409bb9ada80176a" translate="yes" xml:space="preserve">
          <source>Here is how &lt;code&gt;Encode&lt;/code&gt; handles the UTF8 flag.</source>
          <target state="translated">다음은 &lt;code&gt;Encode&lt;/code&gt; 가 UTF8 플래그를 처리하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="a3b1ac2677b1b9f8b57e877bf8d52ae893a26dd3" translate="yes" xml:space="preserve">
          <source>Here is how the blind poet would modernise the encoding:</source>
          <target state="translated">맹인 시인이 인코딩을 현대화하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89e87986f55aa1d049d1fc43e956c467b865ddf7" translate="yes" xml:space="preserve">
          <source>Here is how to query the database for the &lt;b&gt;de&lt;/b&gt; (Deutsch or German) locale.</source>
          <target state="translated">다음은 &lt;b&gt;de&lt;/b&gt; (Deutsch 또는 German) 로캘에 대한 데이터베이스를 쿼리하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="b74dc5032afa362c898993b212d8c65907cee21d" translate="yes" xml:space="preserve">
          <source>Here is how to use this module.</source>
          <target state="translated">이 모듈을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e417973919b13f8ed343cc33d50cf8bf18dd96fb" translate="yes" xml:space="preserve">
          <source>Here is how to write your native data out using UTF-8 (or UTF-EBCDIC) and then read it back in.</source>
          <target state="translated">다음은 UTF-8 (또는 UTF-EBCDIC)을 사용하여 기본 데이터를 작성한 후 다시 읽는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e23347f9a27415c41076a210002eea6fcec860f7" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 를 사용하는 &lt;code&gt;File&lt;/code&gt; 클래스 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9495aaee55fb80cc67d19bf52eb6559a4bfcab26" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 를 사용하는 &lt;code&gt;File&lt;/code&gt; 클래스 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd300984a980fc559dc1a1ab348f5e54e30db5c" translate="yes" xml:space="preserve">
          <source>Here is same snippet of code rewritten using &lt;code&gt;globmap&lt;/code&gt;</source>
          <target state="translated">다음은 &lt;code&gt;globmap&lt;/code&gt; 을 사용하여 다시 작성된 동일한 코드 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="9d1d9e97293f2045a09f6d838c3b2ec8fb4c6f77" translate="yes" xml:space="preserve">
          <source>Here is some explanation of that format:</source>
          <target state="translated">그 형식에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6967e582bf81d06472d4e74fa87d3738c79e15a" translate="yes" xml:space="preserve">
          <source>Here is the Perl subroutine</source>
          <target state="translated">여기 Perl 서브 루틴이 있습니다</target>
        </trans-unit>
        <trans-unit id="c14eb5e60796cb8513e72c1a3dc8468ba095c078" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; . Overloaded arithmetic operators</source>
          <target state="translated">여기에 대한 답이 있습니다 : str ()의 경우, 과부하 이후 명시적인 재귀가 필요하지 않습니다 &lt;code&gt;.&lt;/code&gt; -operator는 기존 오버로드 된 연산자 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 대체됩니다 . 오버로드 된 산술 연산자</target>
        </trans-unit>
        <trans-unit id="859c0d277a95c300a54069c3c3fa1998c806c07c" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt;. Overloaded arithmetic operators</source>
          <target state="translated">실습에 대한 답은 다음과 같습니다. str ()의 경우 오버로드 된 이후 명시적인 재귀가 필요하지 않습니다 &lt;code&gt;.&lt;/code&gt; -operator는 기존의 오버로드 된 연산자 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 대체됩니다 . 오버로드 된 산술 연산자</target>
        </trans-unit>
        <trans-unit id="0490d051b62ee770784e189641a4237c3b3f3c05" translate="yes" xml:space="preserve">
          <source>Here is the complete Debug filter:</source>
          <target state="translated">다음은 완전한 디버그 필터입니다.</target>
        </trans-unit>
        <trans-unit id="1389bf6f29596689df97762593fe5eec3e652d54" translate="yes" xml:space="preserve">
          <source>Here is the complete list of POP macros available, along with the types they return.</source>
          <target state="translated">다음은 사용 가능한 전체 POP 매크로 목록과 반환되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="41758a39c9a7b172d40507117ebc8d6513b795ee" translate="yes" xml:space="preserve">
          <source>Here is the crux of the problem. A side-effect of opening the &lt;b&gt;DB_File&lt;/b&gt; database in step 2 is that an initial block from the database will get read from disk and cached in memory.</source>
          <target state="translated">다음은 문제의 요점입니다. 2 단계 에서 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스 를 여는 부작용은 데이터베이스의 초기 블록을 디스크에서 읽고 메모리에 캐시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c51e4961cb27feed1f60a5e6765893809aef1e36" translate="yes" xml:space="preserve">
          <source>Here is the hooking interface:</source>
          <target state="translated">후킹 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a16851851d330cec48f9b8e9d6adc8c31c07b46b" translate="yes" xml:space="preserve">
          <source>Here is the list of options. Some options can be in short format (-f) or long (--from) one.</source>
          <target state="translated">다음은 옵션 목록입니다. 일부 옵션은 짧은 형식 (-f) 또는 긴 (--from) 옵션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a0c7a2e7021b69e05a0894a3173e1357ec31a3" translate="yes" xml:space="preserve">
          <source>Here is the list of things which may be &quot;broken&quot; on EMX (from EMX docs):</source>
          <target state="translated">EMX 문서에서 EMX에서 &quot;깨질 수있는&quot;항목의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ff240e57cd35b4f33c424da68af14cbdadb7f0a" translate="yes" xml:space="preserve">
          <source>Here is the module.</source>
          <target state="translated">다음은 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="1061d133b7ebfd4153ef09e5ea8f0d70a6682093" translate="yes" xml:space="preserve">
          <source>Here is the output (split into several lines):</source>
          <target state="translated">다음은 출력입니다 (여러 줄로 분리).</target>
        </trans-unit>
        <trans-unit id="8d77260497f2dd38213b4c5d12c82639b7bb64d8" translate="yes" xml:space="preserve">
          <source>Here is the output from the code above.</source>
          <target state="translated">위 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afa8a8a3c0bd9e2f5b6e60996a561b236f9c8638" translate="yes" xml:space="preserve">
          <source>Here is the output from the script:</source>
          <target state="translated">다음은 스크립트의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="3165612e15dd81d081ad2ea3bdee303a0e8cef7a" translate="yes" xml:space="preserve">
          <source>Here is the output:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc7f872b555210687127240090558fcc03c8212f" translate="yes" xml:space="preserve">
          <source>Here is the relevant quote from the dbopen man page where it defines the use of the R_CURSOR flag with seq:</source>
          <target state="translated">다음은 dbopen 매뉴얼 페이지에서 seq와 함께 R_CURSOR 플래그의 사용을 정의하는 관련 인용문입니다.</target>
        </trans-unit>
        <trans-unit id="2219210520e554129a1633cb7206210581ad4e0f" translate="yes" xml:space="preserve">
          <source>Here is the sample C file:</source>
          <target state="translated">샘플 C 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b7d8db184d6d571b8ca9a214519cc03ef4c5e4a" translate="yes" xml:space="preserve">
          <source>Here is the script above rewritten using the &lt;code&gt;seq&lt;/code&gt; API method.</source>
          <target state="translated">다음은 &lt;code&gt;seq&lt;/code&gt; API 메소드를 사용하여 다시 작성된 위의 스크립트 입니다.</target>
        </trans-unit>
        <trans-unit id="2e67d178bb0da6449165979cec1cd5461e419a26" translate="yes" xml:space="preserve">
          <source>Here is the text of</source>
          <target state="translated">여기에 텍스트가 있습니다</target>
        </trans-unit>
        <trans-unit id="ff1b450e27d60fd1ad40e7bb902cfa0aa22a3e80" translate="yes" xml:space="preserve">
          <source>Here is what C has that Perl doesn't:</source>
          <target state="translated">펄이 가지고 있지 않은 C는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16fc2b68835145e65475f1bb3c3809808bf7eb3b" translate="yes" xml:space="preserve">
          <source>Here is yet another way to print your environment:</source>
          <target state="translated">환경을 인쇄하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9c1621c9657e20cbf24cd9acf9471928604302c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;TAP::Parser::Scheduler#Rules-data-structure&quot;&gt;&quot;Rules data structure&quot; in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">여기에 몇 가지 간단한 예가 있습니다. 데이터 구조 및 관련 glob 스타일 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;TAP::Parser::Scheduler#Rules-data-structure&quot;&gt;은 TAP :: Parser :: Scheduler의 &quot;규칙 데이터 구조&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8ed8a023e586883874c39ef49b4107598cdc9c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;Rules data structure in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">여기 간단한 예가 있습니다. 데이터 구조 및 관련 glob 스타일 패턴 일치에 대한 자세한 내용 &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;은 TAP :: Parser :: Scheduler의 규칙 데이터 구조를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c82546a7315fbf02695dbf5d467040f6b1a876b8" translate="yes" xml:space="preserve">
          <source>Here the actual architecture of the Synology system matters. You have to find out where the gcc libraries have been installed. Look in /opt for a directory similar to arm-none-linux-gnueab or powerpc-linux-gnuspe. In the instructions below I'll use powerpc-linux-gnuspe as an example.</source>
          <target state="translated">여기서 Synology 시스템의 실제 아키텍처가 중요합니다. gcc 라이브러리가 설치된 위치를 찾아야합니다. arm-none-linux-gnueab 또는 powerpc-linux-gnuspe와 유사한 디렉토리를 / opt에서 찾으십시오. 아래 지침에서는 powerpc-linux-gnuspe를 예로 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="8ac9540016a9d087f8c1a19391a980dab40c0a80" translate="yes" xml:space="preserve">
          <source>Here the first call caches the list (1,2,3,4,5,6,7). The second call does not really make sense. &lt;code&gt;Memoize&lt;/code&gt; cannot guess what behavior &lt;code&gt;iota&lt;/code&gt; should have in scalar context without actually calling it in scalar context. Normally &lt;code&gt;Memoize&lt;/code&gt;</source>
          <target state="translated">여기서 첫 번째 호출은 목록 (1,2,3,4,5,6,7)을 캐시합니다. 두 번째 전화는 실제로 의미가 없습니다. &lt;code&gt;Memoize&lt;/code&gt; 는 실제로 스칼라 컨텍스트에서 호출하지 않고 스칼라 컨텍스트에서 &lt;code&gt;iota&lt;/code&gt; 의 동작을 추측 할 수 없습니다 . 일반적으로 &lt;code&gt;Memoize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9449cd01fe2c1ad3593def47ef2650f44e48880d" translate="yes" xml:space="preserve">
          <source>Here the first line will load &lt;code&gt;Carp&lt;/code&gt;</source>
          <target state="translated">여기 첫 줄은 &lt;code&gt;Carp&lt;/code&gt; 를로드합니다</target>
        </trans-unit>
        <trans-unit id="5ec7a9d65cd4bf61cf8b315b7aa4990f3fbae6e4" translate="yes" xml:space="preserve">
          <source>Here the generated XS function returns nothing on success, and will die() with a meaningful error message on error.</source>
          <target state="translated">여기서 생성 된 XS 함수는 성공시 아무 것도 반환하지 않으며 오류시 의미있는 오류 메시지와 함께 die ()가됩니다.</target>
        </trans-unit>
        <trans-unit id="083a79c03137ba3c061edc8bbcb5ea85ceb9fdd1" translate="yes" xml:space="preserve">
          <source>Here the multi-argument form of pipe open() is preferred because the pattern and indeed even the filenames themselves might hold metacharacters.</source>
          <target state="translated">여기서는 파이프 인수 open ()의 다중 인수 형식이 선호됩니다. 패턴과 파일 이름 자체에도 메타 문자가 포함될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="84ce6346e023cfe513980b15261a23a5e8073bce" translate="yes" xml:space="preserve">
          <source>Here the number of bytes chopped off (1) is shown next as the OFFSET. The portion of the string between the &quot;real&quot; and the &quot;fake&quot; beginnings is shown in parentheses, and the values of &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; reflect the fake beginning, not the real one. (The first character of the string buffer happens to have changed to &quot;\1&quot; here, not &quot;1&quot;, because the current implementation stores the offset count in the string buffer. This is subject to change.)</source>
          <target state="translated">여기서 잘린 바이트 수 (1)가 다음에 오프셋으로 표시됩니다. &quot;실제&quot;와 &quot;가짜&quot;시작 사이의 문자열 부분은 괄호 안에 표시되며 &lt;code&gt;SvCUR&lt;/code&gt; 및 &lt;code&gt;SvLEN&lt;/code&gt; 의 값은 실제 시작이 아닌 가짜 시작을 반영합니다. 현재 구현에서는 문자열 버퍼에 오프셋 수를 저장하기 때문에 문자열 버퍼의 첫 번째 문자는 &quot;1&quot;이 아니라 &quot;\ 1&quot;로 변경되었습니다. 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f2e253f1bb4668aac3cfa34c16cf32f5c7d557" translate="yes" xml:space="preserve">
          <source>Here translator() is a subroutine which takes</source>
          <target state="translated">여기서 translator ()는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="5ec73b17b809ba7add1fdfcfb1b37379d0947f01" translate="yes" xml:space="preserve">
          <source>Here we are assuming &lt;code&gt;My::I18N::en&lt;/code&gt; to own the main lexicon.</source>
          <target state="translated">여기서 우리는 &lt;code&gt;My::I18N::en&lt;/code&gt; 이 메인 어휘집을 소유 한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="69ad459c54b1acfe7be7330c75e06154ad271928" translate="yes" xml:space="preserve">
          <source>Here we can see a much more complex program, with various optimisations in play. At regnode 10 we see an example where a character class with only one character in it was turned into an &lt;code&gt;EXACT&lt;/code&gt; node. We can also see where an entire alternation was turned into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; node. As a consequence, some of the regnodes have been marked as optimised away. We can see that the &lt;code&gt;$&lt;/code&gt; symbol has been converted into an &lt;code&gt;EOL&lt;/code&gt; regop, a special piece of code that looks for &lt;code&gt;\n&lt;/code&gt; or the end of the string.</source>
          <target state="translated">여기서 우리는 다양한 최적화가 진행되는 훨씬 더 복잡한 프로그램을 볼 수 있습니다. regnode 10에서 문자가 하나만있는 문자 클래스가 &lt;code&gt;EXACT&lt;/code&gt; 노드 로 바뀌는 예를 볼 수 있습니다. 또한 전체 교대가 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 노드 로 전환 된 위치를 확인할 수 있습니다 . 결과적으로 일부 regnode는 최적화 된 것으로 표시되었습니다. &lt;code&gt;$&lt;/code&gt; 기호가 &lt;code&gt;\n&lt;/code&gt; 또는 문자열의 끝 을 찾는 특수 코드 인 &lt;code&gt;EOL&lt;/code&gt; regop 으로 변환되었음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e88298fdbd00bad0c423ba34b385ffbc4d523ec" translate="yes" xml:space="preserve">
          <source>Here we describe the internal form your code is converted to by Perl. Start with a simple example:</source>
          <target state="translated">여기에서는 코드가 Perl에 의해 변환되는 내부 양식에 대해 설명합니다. 간단한 예부터 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a54d30dda627090722af6ca7619feef7f811fd" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under AmigaOS.</source>
          <target state="translated">여기에서는 AmigaOS에서 Perl을 빌드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5a948596d25d15dea7b9635c0bba86ef5734411f" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under OS/2.</source>
          <target state="translated">여기서는 OS / 2에서 Perl을 빌드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0ac29b536b198edfced84637724dab1c5327400" translate="yes" xml:space="preserve">
          <source>Here we document the backslash sequences that don't fall in one of the categories above. These are:</source>
          <target state="translated">여기서 우리는 위의 범주 중 하나에 속하지 않는 백 슬래시 시퀀스를 문서화합니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="78599b796151b0cc81f36fe73ffc3c8ea3b46215" translate="yes" xml:space="preserve">
          <source>Here we list environment variables with are either OS/2- and DOS- and Win*-specific, or are more important under OS/2 than under other OSes.</source>
          <target state="translated">여기에 OS / 2 및 DOS 및 Win *에 특정한 환경 변수가 나열되어 있거나 OS / 2에서는 다른 OS보다 더 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2d28d2754acd9ac1365a8c90a3604a80ec81bb16" translate="yes" xml:space="preserve">
          <source>Here we list major changes which could make you by surprise.</source>
          <target state="translated">여기 놀라움으로 만들 수있는 주요 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa194969d86c572c4f360d304be10a58d841a2b" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt; . After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">여기서는 RETVAL을 처리 할 때 INPUT : 섹션에서 &lt;code&gt;MyObject&lt;/code&gt; 로 변환하고 MyObject 에서 변환 하면 전역 변수 &lt;code&gt;global_state&lt;/code&gt; 가 수정 된다고 가정합니다 . 이러한 변환이 수행 된 후 이전 값을 복원합니다 &lt;code&gt;global_state&lt;/code&gt; 메모리 누수를 방지하기 위해 global_state .</target>
        </trans-unit>
        <trans-unit id="c12f8daf742cd0e2e4cefb5aa95001afa9ec6004" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt;. After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">여기서는 INPUT : 섹션과 RETVAL을 처리 할 때 &lt;code&gt;MyObject&lt;/code&gt; 에서 MyObject 로 변환 하면 전역 변수 &lt;code&gt;global_state&lt;/code&gt; 가 수정 된다고 가정합니다 . 이러한 변환이 수행 된 후에 는 예를 들어 메모리 누수를 방지하기 위해 &lt;code&gt;global_state&lt;/code&gt; 의 이전 값을 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ed5c8e65b6eb8ae2e55830259cac345b514bb1" translate="yes" xml:space="preserve">
          <source>Here we'll create some files that will generate a test library. These will include a C source file and a header file. We'll also create a Makefile.PL in this directory. Then we'll make sure that running make at the Mytest2 level will automatically run this Makefile.PL file and the resulting Makefile.</source>
          <target state="translated">여기에서는 테스트 라이브러리를 생성 할 파일을 만듭니다. 여기에는 C 소스 파일과 헤더 파일이 포함됩니다. 이 디렉토리에 Makefile.PL도 작성합니다. 그런 다음 Mytest2 수준에서 make를 실행하면이 Makefile.PL 파일과 결과 Makefile이 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="930cec360a8de0d300404f1ae97c04e5862e5b86" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">여기에서는 typeglobs를 사용하여 심볼 테이블 앨리어싱을 수행합니다. 그것은 당신이 사용하고 있지 작동하는 경우도 있지만, 조금 미묘한, 그리고 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; (심지어 위장에서만 전역 있기 때문에, 변수를 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 들)은 심볼 테이블에 있습니다.</target>
        </trans-unit>
        <trans-unit id="06be2ecbc25fb96dbb599240b486ce47b84ed17c" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;my&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;local&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">여기서는 typeglobs를 사용하여 심볼 테이블 앨리어싱을 수행합니다. 그래도 약간 미묘하고 &lt;code&gt;my&lt;/code&gt; 변수를 사용하는 경우에도 작동하지 않습니다 . 왜냐하면 전역 ( &lt;code&gt;local&lt;/code&gt; 로 위장한 경우에도 ) 기호 테이블에 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="5ca4ef30e473f35ac20ca9ad8e996a139eaf86fb" translate="yes" xml:space="preserve">
          <source>Here we've created a reference to an anonymous array of three elements whose final element is itself a reference to another anonymous array of three elements. (The multidimensional syntax described later can be used to access this. For example, after the above, &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; would have the value &quot;b&quot;.)</source>
          <target state="translated">여기에서는 최종 요소 자체가 3 개의 요소로 구성된 익명의 다른 배열에 대한 참조 인 3 개의 요소로 구성된 익명의 배열에 대한 참조를 만들었습니다. (나중에 설명 된 다차원 구문을 사용하여이를 액세스 할 수 있습니다. 예를 들어, 위의 &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; 값은 &quot;b&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="977db011c41d89278867b065d331c7d420016e2c" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt; , or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">다음은 Perl의 시스템 추상화의 예입니다. 나중에 볼 수 있습니다. &lt;code&gt;PerlMem_malloc&lt;/code&gt; 은 시스템의 &lt;code&gt;malloc&lt;/code&gt; 또는 Perl의 자체 &lt;code&gt;malloc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b64b714460c7f17586b097330025e123e22543a5" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt;, or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">여기에서 Perl의 시스템 추상화의 예를 볼 수 있습니다. 나중에 살펴 보겠습니다. &lt;code&gt;PerlMem_malloc&lt;/code&gt; 은 시스템의 &lt;code&gt;malloc&lt;/code&gt; 이거나 다음에 정의 된 Perl의 고유 한 &lt;code&gt;malloc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="afea48b05d5e51f5f1638375ce5b0e27610663a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a full program showing how to make use of locale-sensitive sorting, Unicode casing, and managing print widths when some of the characters take up zero or two columns, not just one column each time. When run, the following program produces this nicely aligned output:</source>
          <target state="translated">다음은 로케일 구분 정렬, 유니 코드 케이싱 및 인쇄 문자 관리 방법을 보여주는 전체 프로그램입니다. 매번 한 열이 아닌 일부 문자가 0 개 또는 2 개의 열을 차지할 때입니다. 실행될 때 다음 프로그램은 이처럼 잘 정렬 된 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a19b2363612bc52e7e1f472c3c8e257075049a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how to implicitly manage the translation; all encoding and decoding is done automatically, just as with streams that have a particular encoding attached to them:</source>
          <target state="translated">번역을 암시 적으로 관리하는 방법은 다음과 같습니다. 모든 인코딩 및 디코딩은 특정 인코딩이 첨부 된 스트림과 마찬가지로 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c2be9aec08f68310e7254caae4389bbea07c40" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt; , a little utility to cleanly remove an installed module.</source>
          <target state="translated">여기의 &lt;code&gt;modrm&lt;/code&gt; , 약간의 유틸리티는 정상적으로 설치된 모듈을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="07ce2ba300c1f805c13e04282fb9bd9b4aef88e6" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt;, a little utility to cleanly remove an installed module.</source>
          <target state="translated">다음 은 설치된 모듈을 깨끗하게 제거하는 작은 유틸리티 인 &lt;code&gt;modrm&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acb297651ed81fb994c8862e1324045de85e7420" translate="yes" xml:space="preserve">
          <source>Here's a UDP program similar to the sample Internet TCP client given earlier. However, instead of checking one host at a time, the UDP version will check many of them asynchronously by simulating a multicast and then using select() to do a timed-out wait for I/O. To do something similar with TCP, you'd have to use a different socket handle for each host.</source>
          <target state="translated">다음은 앞서 제공된 샘플 인터넷 TCP 클라이언트와 유사한 UDP 프로그램입니다. 그러나 UDP 버전은 한 번에 하나의 호스트를 확인하는 대신 멀티 캐스트를 시뮬레이션 한 다음 select ()를 사용하여 I / O에 대한 시간 초과 대기를 수행하여 많은 호스트를 비동기식으로 확인합니다. TCP와 비슷한 작업을 수행하려면 각 호스트마다 다른 소켓 핸들을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f4b45b7c3f776b4fbc38fc3bb7e907362d3ca50" translate="yes" xml:space="preserve">
          <source>Here's a brief lead of how to upgrade the compiler to the latest level. Of course this is subject to changes. You can only upgrade versions from ftp-available updates if the first three digit groups are the same (in where you can skip intermediate unlike the patches in the developer snapshots of Perl), or to one version up where the &quot;base&quot; is available. In other words, the AIX compiler patches are cumulative.</source>
          <target state="translated">다음은 컴파일러를 최신 수준으로 업그레이드하는 방법에 대한 간단한 설명입니다. 물론 이것은 변경 될 수 있습니다. 처음 세 자리 그룹이 동일하거나 (Perl 개발자 스냅 샷의 패치와 달리 중간 단계를 건너 뛸 수있는 경우) &quot;base&quot;를 사용할 수있는 한 버전으로 업그레이드 할 경우 ftp 사용 가능한 업데이트에서 버전 만 업그레이드 할 수 있습니다. 다시 말해, AIX 컴파일러 패치는 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="9083bbfd93bc36a0ba2fe1e425a822a01dff192a" translate="yes" xml:space="preserve">
          <source>Here's a brief recap of the options we covered:</source>
          <target state="translated">다음은 우리가 다룬 옵션에 대한 간략한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="b70c746e9664f4a89ae78b4bc44345a9debc8745" translate="yes" xml:space="preserve">
          <source>Here's a classic non-closure function-generating function:</source>
          <target state="translated">고전적인 비 폐쇄 함수 생성 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="737671b9935a9677418172be58d93041b2c042de" translate="yes" xml:space="preserve">
          <source>Here's a client that creates a TCP connection to the &quot;daytime&quot; service at port 13 of the host name &quot;localhost&quot; and prints out everything that the server there cares to provide.</source>
          <target state="translated">다음은 호스트 이름 &quot;localhost&quot;의 포트 13에서 &quot;daytime&quot;서비스에 대한 TCP 연결을 작성하고 서버가 제공하는 모든 것을 인쇄하는 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="a5f63dc35eae9c630d6e8946bcdd1e57d0bacb18" translate="yes" xml:space="preserve">
          <source>Here's a complete example of matching IPV4 internet protocol addresses in any (single) script</source>
          <target state="translated">다음은 모든 (단일) 스크립트에서 IPV4 인터넷 프로토콜 주소를 일치시키는 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="b9872b20edef13d184c9e33e7e54f0406f2852dd" translate="yes" xml:space="preserve">
          <source>Here's a diversion: copy &quot;runperl.bat&quot; to &quot;runperl&quot;, and type &quot;runperl&quot;. Explain the observed behavior, or lack thereof. :) Hint: .gnidnats llits er'uoy fi ,&quot;lrepnur&quot; eteled :tniH</source>
          <target state="translated">전환은 다음과 같습니다. &quot;runperl.bat&quot;를 &quot;runperl&quot;로 복사하고 &quot;runperl&quot;을 입력하십시오. 관찰 된 행동 또는 그 부족을 설명하십시오. :) 힌트 : .gnidnats ll'er'uoy fi, &quot;lrepnur&quot;eteled : tniH</target>
        </trans-unit>
        <trans-unit id="cf12c485957b201d4ea57553686d7cb0039dde88" translate="yes" xml:space="preserve">
          <source>Here's a list of the backslash sequences that are character classes. They are discussed in more detail below. (For the backslash sequences that aren't character classes, see &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.)</source>
          <target state="translated">다음은 문자 클래스 인 백 슬래시 시퀀스 목록입니다. 이에 대해서는 아래에서 더 자세히 설명합니다. 문자 클래스가 아닌 백 슬래시 시퀀스는 &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ab128180a319c2d07a98a10caf6a07254c0f651" translate="yes" xml:space="preserve">
          <source>Here's a list of the currently unsupported API, and also the version of Perl below which it is unsupported:</source>
          <target state="translated">현재 지원되지 않는 API 목록과 지원되지 않는 Perl 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33b154fc2c3c454de669961df32cf81dfe425d93" translate="yes" xml:space="preserve">
          <source>Here's a little program that generates all permutations of all the words on each line of input. The algorithm embodied in the &lt;code&gt;permute()&lt;/code&gt; function is discussed in Volume 4 (still unpublished) of Knuth's</source>
          <target state="translated">다음은 각 입력 줄에 모든 단어의 순열을 생성하는 작은 프로그램입니다. &lt;code&gt;permute()&lt;/code&gt; 함수에 구현 된 알고리즘 은 Knuth 's Volume 4 (여전히 게시되지 않음)에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac1edab256d838d310d923b4a7442c76a785939d" translate="yes" xml:space="preserve">
          <source>Here's a little program that's somewhat like fmt(1):</source>
          <target state="translated">다음은 fmt (1)과 비슷한 작은 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="fd6a03a6db0cc55634b2b495ac28f42a4ed52934" translate="yes" xml:space="preserve">
          <source>Here's a lovely Perlish solution by Larry Rosler. It exploits properties of bitwise xor on ASCII strings.</source>
          <target state="translated">Larry Rosler의 멋진 Perlish 솔루션입니다. ASCII 문자열에서 비트 xor의 속성을 이용합니다.</target>
        </trans-unit>
        <trans-unit id="c5fae574ad1367dcbd0544744e45226bb907e0c9" translate="yes" xml:space="preserve">
          <source>Here's a mailbox appender for BSD systems.</source>
          <target state="translated">다음은 BSD 시스템 용 메일 박스 어 펜더입니다.</target>
        </trans-unit>
        <trans-unit id="39554d786a12cee063a370b311126f557d404cc0" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt; . One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">보다 복잡한 예는 다음과 같습니다. &lt;code&gt;struct netconfig&lt;/code&gt; 가 클래스 &lt;code&gt;Net::Config&lt;/code&gt; 축복 되기를 원한다고 가정합니다 . 이를 수행하는 한 가지 방법은 밑줄 (_)을 사용하여 다음과 같이 패키지 이름을 구분하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40fb940b270cba1c2d6bdc833bd631f4a1ae5a33" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt;. One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">다음은 좀 더 복잡한 예입니다. &lt;code&gt;struct netconfig&lt;/code&gt; 를 &lt;code&gt;Net::Config&lt;/code&gt; 클래스로 축복하기 를 원한다고 가정합니다 . 이를 수행하는 한 가지 방법은 다음과 같이 밑줄 (_)을 사용하여 패키지 이름을 구분하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef76926490bf6bc7991a173108bb3e76598bbc43" translate="yes" xml:space="preserve">
          <source>Here's a more extensive illustration using vec():</source>
          <target state="translated">다음은 vec ()를 사용하는보다 광범위한 그림입니다.</target>
        </trans-unit>
        <trans-unit id="9b21353c7b746d6125b0bd9ccdf2d5f6e32ae7e7" translate="yes" xml:space="preserve">
          <source>Here's a more sophisticated example of using %Config:</source>
          <target state="translated">% Config를 사용하는보다 정교한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79fc5a3fa5bc2df2e735e49c28e40c308b498181" translate="yes" xml:space="preserve">
          <source>Here's a much better web-page hit counter:</source>
          <target state="translated">훨씬 더 나은 웹 페이지 조회수 카운터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d392ab49a010fb0ac59f9f0078cb125cae17692b" translate="yes" xml:space="preserve">
          <source>Here's a partial table of features the different packages offer:</source>
          <target state="translated">다음은 다양한 패키지가 제공하는 기능의 일부 표입니다.</target>
        </trans-unit>
        <trans-unit id="41a14f9ddca1a8bfb40a30abc5c0f1b2c1f62eef" translate="yes" xml:space="preserve">
          <source>Here's a quick mapping for the utilities/modules, and their names for the $BLACKLIST, $METHOD_FAIL and other internal functions.</source>
          <target state="translated">다음은 유틸리티 / 모듈과 $ BLACKLIST, $ METHOD_FAIL 및 기타 내부 함수의 이름에 대한 빠른 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="65dd6cf38c10a9b90787d2bbbbe67a89618fa22e" translate="yes" xml:space="preserve">
          <source>Here's a real world example, taken from work done to resolve &lt;a href=&quot;https://github.com/Perl/perl5/issues/10118&quot;&gt;perl #10118&lt;/a&gt;. Use of</source>
          <target state="translated">다음은 &lt;a href=&quot;https://github.com/Perl/perl5/issues/10118&quot;&gt;perl # 10118&lt;/a&gt; 을 해결하기 위해 수행 한 작업에서 가져온 실제 사례 입니다. 사용</target>
        </trans-unit>
        <trans-unit id="cda00e934fa6376dbf363c4a7973b5685c850503" translate="yes" xml:space="preserve">
          <source>Here's a reservoir-sampling algorithm from the Camel Book:</source>
          <target state="translated">Camel Book의 저수지 샘플링 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e206bb004fc82d9ef3fcc3d4b1c49d6f3d42ac3" translate="yes" xml:space="preserve">
          <source>Here's a safe backtick or pipe open for read:</source>
          <target state="translated">다음은 읽을 수있는 안전한 백틱 또는 파이프입니다.</target>
        </trans-unit>
        <trans-unit id="a7cce3c8a9d58b666d239193afb2494a20bba3a2" translate="yes" xml:space="preserve">
          <source>Here's a sample TCP client using Internet-domain sockets:</source>
          <target state="translated">인터넷 도메인 소켓을 사용하는 샘플 TCP 클라이언트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c9e5f5e52c5d8da22662f4567979deb732ae0a9" translate="yes" xml:space="preserve">
          <source>Here's a sample Unix-domain client:</source>
          <target state="translated">다음은 샘플 Unix 도메인 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="d1aee0a8129cd8627dd813843d4743d6011f0d62" translate="yes" xml:space="preserve">
          <source>Here's a sample plugin, for your reference:</source>
          <target state="translated">다음은 참조 용 샘플 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="bee38889229a5c9d4ff45e0c3ab7e676e43a251f" translate="yes" xml:space="preserve">
          <source>Here's a sample program,</source>
          <target state="translated">다음은 샘플 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="705113e6af32ce6049ec614b7bd8ea0f06bc826f" translate="yes" xml:space="preserve">
          <source>Here's a sample showing how to create and use a record whose fields are of many different sorts:</source>
          <target state="translated">다음은 다양한 종류의 필드를 가진 레코드를 만들고 사용하는 방법을 보여주는 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="16fbac9b09446fb7fa1607fa6cbcd3cd579323e7" translate="yes" xml:space="preserve">
          <source>Here's a sample:</source>
          <target state="translated">샘플은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d48d2b1ee87d318b2f88933c600ad433cc38ac05" translate="yes" xml:space="preserve">
          <source>Here's a short bibliography courtesy of J&amp;uuml;rgen Christoffel:</source>
          <target state="translated">J&amp;uuml;rgen Christoffel의 짧은 참고 문헌은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b6db8c67bc1492d1475adb966fe40db79852b40" translate="yes" xml:space="preserve">
          <source>Here's a simple client that takes a remote host to fetch a document from, and then a list of files to get from that host. This is a more interesting client than the previous one because it first sends something to the server before fetching the server's response.</source>
          <target state="translated">다음은 원격 호스트가 문서를 가져오고 해당 호스트에서 가져올 파일 목록을 가져 오는 간단한 클라이언트입니다. 서버의 응답을 가져 오기 전에 먼저 서버로 무언가를 보내기 때문에 이전 클라이언트보다 더 흥미로운 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="6d6b6f3994774d06d8f1e409ff389cf7bc440169" translate="yes" xml:space="preserve">
          <source>Here's a simple example of a switch based on pattern matching, lined up in a way to make it look more like a switch statement. We'll do a multiway conditional based on the type of reference stored in $whatchamacallit:</source>
          <target state="translated">다음은 패턴 일치를 기반으로하는 스위치의 간단한 예입니다. 스위치 문처럼 보이도록 정렬되어 있습니다. $ whatchamacallit에 저장된 참조 유형에 따라 다 방향 조건부를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="adf661fec1c7ed224422528dd69c23adb6998e67" translate="yes" xml:space="preserve">
          <source>Here's a simple example to illustrate the difference between the two range operators:</source>
          <target state="translated">다음은 두 범위 연산자의 차이점을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="24f0b23833358ef065f35cfbec9242ef09ccac71" translate="yes" xml:space="preserve">
          <source>Here's a simple program which converts between Celsius and Fahrenheit, it too has a problem:</source>
          <target state="translated">다음은 섭씨와 화씨를 변환하는 간단한 프로그램입니다. 문제도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0837b2c8d138afbded4f97677c64e44b344b5f56" translate="yes" xml:space="preserve">
          <source>Here's a simple-minded example program that rewrites its command-line parameters as integers correctly formatted in the current locale:</source>
          <target state="translated">다음은 명령 행 매개 변수를 현재 로케일에서 올바르게 형식화 된 정수로 다시 작성하는 간단한 예제 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f4b1ca0d619e6e130110c613ca994de9ad0679d7" translate="yes" xml:space="preserve">
          <source>Here's a small example showing shared memory usage.</source>
          <target state="translated">다음은 공유 메모리 사용량을 보여주는 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca0b16455dba662fbcb02846342b83e69dabc681" translate="yes" xml:space="preserve">
          <source>Here's a summary of the possible predicates:</source>
          <target state="translated">가능한 술어에 대한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58dc9ec13109b06fde34d79108b2ec3645eaf897" translate="yes" xml:space="preserve">
          <source>Here's a test to make sure that the data contains nothing but &quot;word&quot; characters (alphabetics, numerics, and underscores), a hyphen, an at sign, or a dot.</source>
          <target state="translated">데이터에 &quot;단어&quot;문자 (알파벳, 숫자 및 밑줄), 하이픈, at 부호 또는 점만 포함되어 있는지 확인하는 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="759693dd6cb991ad225a2379fc23020ea66b9451" translate="yes" xml:space="preserve">
          <source>Here's a trick for interpolating a subroutine call into a string:</source>
          <target state="translated">서브 루틴 호출을 문자열로 보간하는 요령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="566b3956738219763456c200fc999f82ae79bed2" translate="yes" xml:space="preserve">
          <source>Here's a truly obscure example:</source>
          <target state="translated">다음은 실제로 모호한 예입니다.</target>
        </trans-unit>
        <trans-unit id="673e00298dcf732578c132c6f7ebc33b00f2f5a5" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">백틱을 합리적으로 안전하게 수행하는 방법이 있습니다. 쉘이 확장 할 수있는 문자열로 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 가 어떻게 호출되지 않는지 주목하십시오 . 이것은 쉘 이스케이프 될 수있는 것을 호출하는 가장 좋은 방법입니다. 쉘을 전혀 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d9c7cd5d68bc715c0bc2090946109f25a3884bfa" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;exec&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">백틱을 합리적으로 안전하게 수행하는 방법이 있습니다. 쉘이 확장 할 수있는 문자열로 &lt;code&gt;exec&lt;/code&gt; 가 어떻게 호출되지 않는지 주목하십시오 . 이것은 쉘 이스케이프의 대상이 될 수있는 것을 호출하는 가장 좋은 방법입니다. 쉘을 전혀 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="eaaae86ddf2180ef145c4679eb81721d464c8d5e" translate="yes" xml:space="preserve">
          <source>Here's an even simpler example: I wrote a simple ray tracer; the program would look in a certain direction, figure out what it was looking at, and then convert the `color' value (typically a string like `red') of that object to a red, green, and blue pixel value, like this:</source>
          <target state="translated">더 간단한 예는 다음과 같습니다. 간단한 광선 추적기를 작성했습니다. 프로그램은 특정 방향으로보고,보고있는 것을 파악한 다음 해당 객체의`color '값 (일반적으로`red'와 같은 문자열)을 빨강, 녹색 및 파랑 픽셀 값으로 변환합니다. :</target>
        </trans-unit>
        <trans-unit id="eb7f2b2a1f46da14792dc92fada7de16651b64e3" translate="yes" xml:space="preserve">
          <source>Here's an example of a module as a blessed scalar:</source>
          <target state="translated">다음은 축복 스칼라 인 모듈의 예입니다.</target>
        </trans-unit>
        <trans-unit id="433e4046c8d4a59acb27a1b8715b8d822849f3f4" translate="yes" xml:space="preserve">
          <source>Here's an example of a semaphore:</source>
          <target state="translated">세마포어의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5da5564566886484e5f1909e68561f2893fc59f" translate="yes" xml:space="preserve">
          <source>Here's an example of a simple .t file for the fictional Film module.</source>
          <target state="translated">허구 영화 모듈을위한 간단한 .t 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00e3c595287e645175478199893dcfbab0d3f383" translate="yes" xml:space="preserve">
          <source>Here's an example of a somewhat interesting tied hash class: it gives you a hash representing a particular user's dot files. You index into the hash with the name of the file (minus the dot) and you get back that dot file's contents. For example:</source>
          <target state="translated">다음은 다소 흥미로운 연결 해시 클래스의 예입니다. 특정 사용자의 도트 파일을 나타내는 해시를 제공합니다. 파일 이름 (점에서 빼기)으로 해시에 색인을 작성하고 해당 점 파일의 내용을 다시 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44172aa24b9ebcb09c3ac7dacdd0f49ad41ffcca" translate="yes" xml:space="preserve">
          <source>Here's an example of how to copy a binary file:</source>
          <target state="translated">이진 파일을 복사하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db4ebf9573581d82c8cc95cd18272cd15b08d992" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">다음은 일치하는 문자열과 정규식을 전달하는 방법의 예입니다. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 연산자를 사용하여 패턴을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="99a411d8c049e8f5d02a926ffc1bf596e0d48187" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;qr//&lt;/code&gt; operator:</source>
          <target state="translated">다음은 일치 할 문자열과 정규식을 전달하는 방법의 예입니다. &lt;code&gt;qr//&lt;/code&gt; 연산자를 사용하여 패턴을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="637519bbaa8687d335368b0791bb0e149bbe34ba" translate="yes" xml:space="preserve">
          <source>Here's an example of running that program, which we'll call</source>
          <target state="translated">다음은 그 프로그램을 실행하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="36af409f70db85a39900fd4afda6942fc83aa2ef" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;$REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; on your own, though.</source>
          <target state="translated">다음 은 시스템 수준에서 차단되지 않도록 &lt;code&gt;$REMOTE&lt;/code&gt; 라는 파일 핸들을 설정하는 예입니다 . &lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt; 협상해야합니다. 하지만 스스로.</target>
        </trans-unit>
        <trans-unit id="f582133574110a3518036c490af80a6f46ec43be" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;code&gt;$|&lt;/code&gt; on your own, though.</source>
          <target state="translated">다음 은 시스템 레벨에서 &lt;code&gt;REMOTE&lt;/code&gt; 라는 파일 핸들 을 비 블로킹 으로 설정하는 예입니다 . 당신은 &lt;code&gt;$|&lt;/code&gt; 를 협상해야합니다 | 그래도</target>
        </trans-unit>
        <trans-unit id="5747af8299e3ce8766cc1e6c9250f3bd0c64b9fc" translate="yes" xml:space="preserve">
          <source>Here's an example of using open2():</source>
          <target state="translated">다음은 open2 ()를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="52ee3997caaa83f241ead3aa88bc5b3a35f1e445" translate="yes" xml:space="preserve">
          <source>Here's an example of using the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 변수 를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="244af372fc1dc3d578b9e7b6c1576ec36ffa9ff8" translate="yes" xml:space="preserve">
          <source>Here's an example of what a stack backtrace via &lt;code&gt;T&lt;/code&gt; command might look like:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 명령을 통한 스택 역 추적의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e488d97af419d58ca23b439a55505523edbe2e65" translate="yes" xml:space="preserve">
          <source>Here's an example of what you need for a simple module:</source>
          <target state="translated">간단한 모듈에 필요한 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="daccc2549e31545d57fdedfeee9273ddd1b0ff86" translate="yes" xml:space="preserve">
          <source>Here's an example script file:</source>
          <target state="translated">예제 스크립트 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acda0e1d4c96684fdc356f00d807ddf1f623f6ae" translate="yes" xml:space="preserve">
          <source>Here's an example that looks up nonnumeric uids in the passwd file:</source>
          <target state="translated">다음은 passwd 파일에서 숫자가 아닌 uid를 찾는 예입니다.</target>
        </trans-unit>
        <trans-unit id="5c0f7a1e07a375e4333db5cd9cca105a10ea230a" translate="yes" xml:space="preserve">
          <source>Here's an example that makes sure that whoever runs this program knows their password:</source>
          <target state="translated">다음은이 프로그램을 실행하는 사람이 자신의 비밀번호를 알고 있는지 확인하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2ba3dad78e5e2c46821c06eb650b17001a0a2ef6" translate="yes" xml:space="preserve">
          <source>Here's an example to test whether Nagle's algorithm is enabled on a socket:</source>
          <target state="translated">다음은 소켓에서 Nagle 알고리즘이 활성화되어 있는지 테스트하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d274e7c0c009a3ac1b895b776347d105b0d85baa" translate="yes" xml:space="preserve">
          <source>Here's an example using a recursive regular expression. The goal is to capture all of the text within angle brackets, including the text in nested angle brackets. This sample text has two &quot;major&quot; groups: a group with one level of nesting and a group with two levels of nesting. There are five total groups in angle brackets:</source>
          <target state="translated">다음은 재귀 정규 표현식을 사용하는 예입니다. 목표는 중첩 꺾쇠 괄호 안의 텍스트를 포함하여 꺾쇠 괄호 안의 모든 텍스트를 캡처하는 것입니다. 이 샘플 텍스트에는 두 가지 &quot;주요&quot;그룹이 있습니다. 하나의 중첩 수준을 가진 그룹과 두 수준의 중첩을 가진 그룹입니다. 꺾쇠 괄호에는 총 5 개의 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f04271f847d0c8988094c50219a148be404036" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="translated">다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="af1afc0eb692136e51fe1f2de2eb325d93796576" translate="yes" xml:space="preserve">
          <source>Here's an example. It used to be a common paradigm, for decades, in the perl core to use &lt;code&gt;strchr(&quot;list&quot;, c)&lt;/code&gt; to see if the character &lt;code&gt;c&lt;/code&gt; is any of the ones given in &lt;code&gt;&quot;list&quot;&lt;/code&gt;, a double-quote-enclosed string of the set of characters that we are seeing if &lt;code&gt;c&lt;/code&gt; is one of. As long as &lt;code&gt;c&lt;/code&gt; isn't a &lt;code&gt;NUL&lt;/code&gt;, it works. But when &lt;code&gt;c&lt;/code&gt; is a &lt;code&gt;NUL&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt; returns a pointer to the terminating &lt;code&gt;NUL&lt;/code&gt; in &lt;code&gt;&quot;list&quot;&lt;/code&gt;. This likely will result in a segfault or a security issue when the caller uses that end pointer as the starting point to read from.</source>
          <target state="translated">여기에 예가 있습니다. 수십 년 동안 펄 코어에서 &lt;code&gt;strchr(&quot;list&quot;, c)&lt;/code&gt; 를 사용 하여 문자 &lt;code&gt;c&lt;/code&gt; 가 큰 따옴표로 묶인 문자열 인 &lt;code&gt;&quot;list&quot;&lt;/code&gt; 에 제공된 문자인지 확인하는 것은 일반적인 패러다임 이었습니다. &lt;code&gt;c&lt;/code&gt; 가 다음 중 하나 인 경우 표시되는 문자 집합 입니다. 만큼 &lt;code&gt;c&lt;/code&gt; 하지 않은 것입니다 &lt;code&gt;NUL&lt;/code&gt; , 그것을 작동합니다. 그러나 &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;NUL&lt;/code&gt; 이면 &lt;code&gt;strchr&lt;/code&gt; 은 &lt;code&gt;&quot;list&quot;&lt;/code&gt; 에서 종료 &lt;code&gt;NUL&lt;/code&gt; 에 대한 포인터를 반환합니다 . 이로 인해 호출자가 해당 끝 포인터를 읽을 시작점으로 사용할 때 segfault 또는 보안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea18952ce84912806a08117b90f220eff293cf76" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt; :</source>
          <target state="translated">다음은 &lt;code&gt;..&lt;/code&gt; 를 사용하는 또 다른 예입니다 .</target>
        </trans-unit>
        <trans-unit id="15ed5c05afc05681027a67404fe0661073a709bb" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; 사용의 또 다른 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="43b272b51e8dfc98c92e4358c6ca3238363075ae" translate="yes" xml:space="preserve">
          <source>Here's another example. Let's say you'd like to match a number at the end of a string, and you also want to keep the preceding part of the match. So you write this:</source>
          <target state="translated">또 다른 예가 있습니다. 문자열 끝에서 숫자를 일치시키고 일치하는 부분을 유지하려고한다고 가정 해 봅시다. 그래서 당신은 이것을 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="6d394fbb45cdbc9850e3f0051e919676f4c5a2f8" translate="yes" xml:space="preserve">
          <source>Here's another interesting wanted function. It will find all symbolic links that don't resolve:</source>
          <target state="translated">또 다른 흥미로운 기능이 있습니다. 해결되지 않은 모든 심볼릭 링크를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dabe892652409d7baaf4ea9766517a9552179bd" translate="yes" xml:space="preserve">
          <source>Here's another simplistic example that illustrates the use of thread signalling in conjunction with a semaphore to provide rudimentary</source>
          <target state="translated">다음은 초보를 제공하기 위해 세마포어와 함께 스레드 신호 사용을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="de1305ff8bab2aad6bcd989ab04908e0dc517958" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">또 다른 전략은 다음과 같습니다. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; 사용하여 파이프를 열고 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ) 항상 STDOUT 대신 MYSELF에 write ()하십시오. 아이가 STDIN을 마사지하여 머리글과 바닥 글을 원하는대로 재 배열하도록하십시오. 매우 편리하지는 않지만 실행 가능합니다.</target>
        </trans-unit>
        <trans-unit id="89e8986edeec6b98232eb3810b91a1ddd6bfcc03" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;open(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">여기에 또 다른 전략이 있습니다. &lt;code&gt;open(MYSELF, &quot;|-&quot;)&lt;/code&gt; ( &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;&lt;/a&gt; 참조 )을 사용하여 자신에게 파이프를 열고 항상 STDOUT 대신 MYSELF에 write ()하십시오. 자녀 프로세스가 STDIN을 마사지하여 원하는대로 머리글과 바닥 글을 재정렬하도록하십시오. 별로 편리하지는 않지만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5ac230c93491a8097772635d05027ee087235965" translate="yes" xml:space="preserve">
          <source>Here's another way to check for sentences in a paragraph:</source>
          <target state="translated">단락에서 문장을 확인하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="273a17fa15878be17fe206b05c8584be04a69acf" translate="yes" xml:space="preserve">
          <source>Here's another, slightly less painful, way to do it from Benjamin Goldberg, who uses a zero-width negative look-behind assertion.</source>
          <target state="translated">너비가 0 인 음수 비하인드 어설 션을 사용하는 Benjamin Goldberg의 약간 덜 고통스러운 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cddef9286505d532aaa041e36320e67de4b2c80" translate="yes" xml:space="preserve">
          <source>Here's another; let's compute spherical volumes:</source>
          <target state="translated">여기 또 다른 것이 있습니다. 구형 볼륨을 계산해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="15dc729f18ba699bddbeda2935fed34db64f6cdb" translate="yes" xml:space="preserve">
          <source>Here's code that finds everything between START and END in a paragraph:</source>
          <target state="translated">단락에서 START와 END 사이의 모든 것을 찾는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26eff15275e0bc723eda9623b566a21d7d660ee9" translate="yes" xml:space="preserve">
          <source>Here's how a C programmer might code up a particular algorithm in Perl:</source>
          <target state="translated">C 프로그래머가 Perl에서 특정 알고리즘을 코딩하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f53c4c5c95494b6983dc9580a97d651bc52209f4" translate="yes" xml:space="preserve">
          <source>Here's how it really works:</source>
          <target state="translated">실제로 작동하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5725ea72516798e0e59187e116804b3012dacd34" translate="yes" xml:space="preserve">
          <source>Here's how that might look:</source>
          <target state="translated">다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c646f07c7dfa6ee86de30d8e7226eba37cb787f8" translate="yes" xml:space="preserve">
          <source>Here's how to do one operation using a loop. We'll assume an @AoA variable as before.</source>
          <target state="translated">루프를 사용하여 하나의 작업을 수행하는 방법은 다음과 같습니다. 이전과 같이 @AoA 변수를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="268a5d49f5ba74b653796a536ebf6253b796189f" translate="yes" xml:space="preserve">
          <source>Here's how to perform each step for each operating system. This is &amp;lt;not&amp;gt; a substitute for reading the README and INSTALL files that might have come with your module!</source>
          <target state="translated">각 운영 체제에 대해 각 단계를 수행하는 방법은 다음과 같습니다. 이것은 모듈과 함께 제공 될 수있는 README 및 INSTALL 파일을 대신하는 &amp;lt;not&amp;gt;입니다!</target>
        </trans-unit>
        <trans-unit id="f61d7cd6d889dcf489e482c04dbdd66a13cc2eb1" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 를 사용하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="26c1023a9e6ac89e64f8047581df9767933e6cd7" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;m//gc&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 와 함께 &lt;code&gt;m//gc&lt;/code&gt; 를 사용하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="72b07fa8c9ee5cfa969d3c94936ee2dff05c5e76" translate="yes" xml:space="preserve">
          <source>Here's how to use our little example:</source>
          <target state="translated">작은 예제를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9a1c6d8d1b1e5ebc9092a952afe3520c4d3df94" translate="yes" xml:space="preserve">
          <source>Here's how we can make the first example safer:</source>
          <target state="translated">첫 번째 예제를보다 안전하게 만드는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3c6addf8c05cad39d9f725c53d0c79d67cc1b7" translate="yes" xml:space="preserve">
          <source>Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:</source>
          <target state="translated">전달 된 모든 해시에서 발생하는 키 목록을 반환하는 함수를 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4247da91d20e93ce8300b57f7c386a920c116cb0" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;&quot;Adding a Perl interpreter to your C program&quot;&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">다음 섹션의 &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;&quot;C 프로그램에 Perl 인터프리터 추가&quot;&lt;/a&gt; 의 예제를 Linux 상자 에서 컴파일하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae2023d3bcf8a706017206316be16158eb0a8503" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;Adding a Perl interpreter to your C program&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">다음은 리눅스 상자에서 &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;C 프로그램에 Perl 인터프리터 추가&lt;/a&gt; 섹션의 예제를 컴파일하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="3c91b848d807e7b04b1ab06ec49ea4392d7ec7d3" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt; , you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">&lt;code&gt;$vec&lt;/code&gt; 의 벡터가 주어지면 &lt;code&gt;@ints&lt;/code&gt; 배열에 해당 비트를 얻는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="05e823e1939b1a8d4b1e60b3d1cc0a6d9b92d2ab" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt;, you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">&lt;code&gt;$vec&lt;/code&gt; 의 벡터가 주어지면 해당 비트를 &lt;code&gt;@ints&lt;/code&gt; 배열 로 가져올 수있는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="22975b2012514ff308ba25754da36c22aeb6ce2b" translate="yes" xml:space="preserve">
          <source>Here's one strategy: If you have a fixed-size footer, you can get footers by checking $FORMAT_LINES_LEFT before each write() and print the footer yourself if necessary.</source>
          <target state="translated">한 가지 전략이 있습니다. 고정 크기 바닥 글이있는 경우 각 write () 전에 $ FORMAT_LINES_LEFT를 확인하여 바닥 글을 가져와 필요한 경우 바닥 글을 직접 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525e3062fa27a1689f30b9419dfa2b5e57815b15" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class once more:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 클래스는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b1783e928a570b5dc6d74dafaff14364959e7e0f" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 클래스는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="327f9e2f42a9d97334b0e6c830bc13c66b0647cf" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 클래스는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="95130bd2aff1326444cc7bcdc6d685db2ff09cc5" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/a&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt;, &lt;code&gt;027&lt;/code&gt;, or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt;. Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">다음은 몇 가지 조언입니다. 일반 파일 ( &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; ) 에 &lt;code&gt;0666&lt;/code&gt; 생성 모드를 제공하고 디렉토리 ( &lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt; &lt;code&gt;mkdir&lt;/code&gt; &lt;/a&gt; ) 및 실행 파일 에 &lt;code&gt;0777&lt;/code&gt; 중 하나를 제공 하십시오. 이것은 사용자에게 선택의 자유를 제공합니다. 보호 된 파일을 원하는 경우 &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; 의 프로세스 umask 또는 &lt;code&gt;077&lt;/code&gt; 의 반사회적 마스크를 선택할 수 있습니다 . 프로그램은 정책 결정을 더 잘 내릴 경우 거의 사용자에게 맡겨서는 안됩니다. 이에 대한 예외는 비공개로 유지해야하는 파일을 작성할 때입니다 : 메일 파일, 웹 브라우저 쿠키,</target>
        </trans-unit>
        <trans-unit id="57354b9e0e2f7e59368dea0a84947b0e2a0827cd" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">다음은 몇 가지 조언입니다. 일반 파일 ( &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ) 의 경우 &lt;code&gt;0666&lt;/code&gt; , 디렉토리 ( &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; ) 및 실행 파일 의 경우 &lt;code&gt;0777&lt;/code&gt; 중 하나를 작성 하십시오. 따라서 보호 된 파일을 원할 경우 프로세스 umask &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; 또는 특히 반사회적 마스크 &lt;code&gt;077&lt;/code&gt; 을 선택할 수 있습니다 . 정책 결정을 사용자에게 더 잘 맡기는 경우가 거의 없습니다. 단, 비공개로 유지해야하는 파일 (메일 파일, 웹 브라우저 쿠키,</target>
        </trans-unit>
        <trans-unit id="e2752daa5f028f44257bc9623ea0f7f9230b9d85" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">다음은 몇 가지 조언입니다. 일반 파일 ( &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ) 의 경우 &lt;code&gt;0666&lt;/code&gt; , 디렉토리 ( &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; ) 및 실행 파일 의 경우 &lt;code&gt;0777&lt;/code&gt; 중 하나를 작성 하십시오. 따라서 보호 된 파일을 원할 경우 프로세스 umask &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; 또는 특히 반사회적 마스크 &lt;code&gt;077&lt;/code&gt; 을 선택할 수 있습니다 . 정책 결정을 사용자에게 더 잘 맡기는 경우가 거의 없습니다. 단, 비공개로 유지해야하는 파일 (메일 파일, 웹 브라우저 쿠키,</target>
        </trans-unit>
        <trans-unit id="4ed39bdc449f7cf4b3c38e3ffdf7cd70fa08f940" translate="yes" xml:space="preserve">
          <source>Here's some code that finds sentences that begin with &quot;From &quot; (which would be mangled by many mailers):</source>
          <target state="translated">다음은 &quot;보낸 사람&quot;으로 시작하는 문장을 찾는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="aa42825d4fc178008e13f884fd63afc0d6bcd50d" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt; .</source>
          <target state="translated">다음은 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 형식의 &quot; Nv&quot;속성 출력 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="79efac09c122b4a103329f6db97a15af7c7c6205" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 형식을 가진 &quot;Nv&quot;속성 출력의 일부 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="983afceb3200f14ad7cf769e6f457a540b745124" translate="yes" xml:space="preserve">
          <source>Here's some more recommendations</source>
          <target state="translated">몇 가지 권장 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="425356b04c5e4659def26c3afe717def29a81e4c" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, (for example, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">Larry가 제안한 내용은 다음과 같습니다. &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 동안 첫 번째 활성 형식 인 경우 (예 : &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) 결과 문자열은 UTF-8 인코딩으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4378597a87d2aa3b47f60334936696fad7b403c9" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;pack&lt;/code&gt;, (for example, &lt;code&gt;pack &quot;U3C8&quot;, @stuff&lt;/code&gt;) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">Larry가 제안한 내용은 다음과 같습니다. &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;pack&lt;/code&gt; 동안 첫 번째 활성 형식 인 경우 (예 : &lt;code&gt;pack &quot;U3C8&quot;, @stuff&lt;/code&gt; ) 결과 문자열은 UTF-8 인코딩으로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b314a6f828aa6ba79d336b2bc1f9e451bb9826c7" translate="yes" xml:space="preserve">
          <source>Here's that program; tested on v5.14.</source>
          <target state="translated">그 프로그램은 다음과 같습니다. v5.14에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce077bf1b8dbc3882bb449e22e472c33bd6126e0" translate="yes" xml:space="preserve">
          <source>Here's the Apache configuration entry you'll need to make use of it. Once set it will result in everything in the /compressed directory will be compressed automagically.</source>
          <target state="translated">다음은이를 사용하는 데 필요한 Apache 구성 항목입니다. 일단 설정되면 / compressed 디렉토리의 모든 것이 자동으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1fe856f88363dd186e2e7ada6054be89d9b374" translate="yes" xml:space="preserve">
          <source>Here's the answer to the problem I posed earlier, of reformatting a file of city and country names.</source>
          <target state="translated">여기에 도시 및 국가 이름 파일을 다시 포맷하는 문제에 대한 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2064253b0b50a2575cd193f528ea54b5bba134" translate="yes" xml:space="preserve">
          <source>Here's the case of taking a reference to the same memory location again and again:</source>
          <target state="translated">동일한 메모리 위치를 반복해서 참조하는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a750afb60c3b3c5f05dc778fe8f81eda212eb4a1" translate="yes" xml:space="preserve">
          <source>Here's the code.</source>
          <target state="translated">여기에 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="687ec9bc2da6b7d16d8a23c230dfb7c1307404b0" translate="yes" xml:space="preserve">
          <source>Here's the code. We'll</source>
          <target state="translated">코드는 다음과 같습니다. 잘</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faf00dc9cd5933c3e758b3e429588f852416f9ff" translate="yes" xml:space="preserve">
          <source>Here's the comprehensive list of values you can expect as</source>
          <target state="translated">다음은 예상 할 수있는 포괄적 인 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="92d590121c2fc19f8a6623b373db411150058833" translate="yes" xml:space="preserve">
          <source>Here's the constructor:</source>
          <target state="translated">생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67de0300ad7e657a8db469b4cb89cf11ed0c9b15" translate="yes" xml:space="preserve">
          <source>Here's the fetch for our DotFiles example.</source>
          <target state="translated">다음은 DotFiles 예제의 페치입니다.</target>
        </trans-unit>
        <trans-unit id="ea37c8a435a5d1ae861daa3601c34204e044ad1a" translate="yes" xml:space="preserve">
          <source>Here's the general rule: When you approach a task commonly done using a whole range of platforms, think about writing portable code. That way, you don't sacrifice much by way of the implementation choices you can avail yourself of, and at the same time you can give your users lots of platform choices. On the other hand, when you have to take advantage of some unique feature of a particular platform, as is often the case with systems programming (whether for Unix, Windows, VMS, etc.), consider writing platform-specific code.</source>
          <target state="translated">일반적인 규칙은 다음과 같습니다. 광범위한 플랫폼을 사용하여 일반적으로 수행되는 작업에 접근 할 때 이식 가능한 코드 작성을 고려하십시오. 그렇게하면, 당신이 이용할 수있는 구현 선택에 의해 많은 것을 희생하지 않으며, 동시에 사용자에게 많은 플랫폼 선택을 줄 수 있습니다. 반면, 시스템 프로그래밍 (유닉스, Windows, VMS 등)의 경우와 같이 특정 플랫폼의 고유 한 기능을 활용해야하는 경우 플랫폼 별 코드 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9c681da90263d542164ba3d2f3ec45d3fa28748f" translate="yes" xml:space="preserve">
          <source>Here's the most basic test program.</source>
          <target state="translated">다음은 가장 기본적인 테스트 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b5763f4294d53b8fde1e0d145ff3e1ebda9932aa" translate="yes" xml:space="preserve">
          <source>Here's the start of</source>
          <target state="translated">여기에 시작입니다</target>
        </trans-unit>
        <trans-unit id="62dfcd0f3177b39de6db7b0fd66738d0abd59908" translate="yes" xml:space="preserve">
          <source>Here's two outputs (or 'renderings'), using the -exec and -basic (i.e. default) formatting conventions on the same code snippet.</source>
          <target state="translated">다음은 동일한 코드 스 니펫에서 -exec 및 -basic (예 : 기본) 형식 지정 규칙을 사용하는 두 가지 출력 (또는 '렌더링')입니다.</target>
        </trans-unit>
        <trans-unit id="b7e6198c27f03baf5a7cf4c101c7cbf2083f6919" translate="yes" xml:space="preserve">
          <source>Here's what happens: when Perl reads in a string literal, it sticks to 8 bit encoding as long as it can. (But perhaps originally it was internally encoded as UTF-8, when you dumped it.) When it has to give that up because other characters are added to the text string, it silently upgrades the string to UTF-8.</source>
          <target state="translated">Perl이 문자열 리터럴을 읽을 때 가능한 한 8 비트 인코딩을 고수합니다. (그러나 원래는 덤프했을 때 내부적으로 UTF-8로 인코딩되었습니다.) 다른 문자가 텍스트 문자열에 추가되어 포기하면 문자열을 UTF-8로 자동 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="3d080817ae211b70ffb8548327b1435f255163a6" translate="yes" xml:space="preserve">
          <source>Here,</source>
          <target state="translated">Here,</target>
        </trans-unit>
        <trans-unit id="664fb069ea88b967ad1512f692644a45d6f7de10" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. &quot;</source>
          <target state="translated">여기서 &quot;= head1 Foo&quot;와 &quot;= cut&quot;은 각각의 첫 번째 줄이 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 와 일치하기 때문에 명령 단락입니다. 입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="6e880e78238dbe97c5e8b6a05af56ed349c5a146" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;. &quot;</source>
          <target state="translated">여기에서 &quot;= head1 Foo&quot;및 &quot;= cut&quot;은 각 첫 번째 줄이 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 와 일치하기 때문에 명령 단락 입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="0b2d91e5d5873ea3e50cabcf6bf495277d88e43b" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">여기서 $ subroutine은 호출자가 포함 된 함수가 아니라 호출자가 호출 한 함수입니다. 주 $ 서브 루틴이 될 수 있음 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 프레임이 서브 루틴 호출하지만,없는 경우 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 이러한 경우 $ evaltext 및 &lt;code&gt;$is_require&lt;/code&gt; 요소가 추가 로 설정됩니다. &lt;code&gt;$is_require&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 프레임을 만들면 true 이고 $ evaltext는 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; 문의 텍스트를 포함합니다 . 특히 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 문의 경우 $ subroutine은 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 이지만 $ evaltext는 정의되어 있지 않습니다. (또한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement 는 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR 프레임 내에 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임을 만듭니다 .) 이 특정 서브 루틴이 심볼 테이블에서 삭제 된 경우 $ subroutine도 &lt;code&gt;(unknown)&lt;/code&gt; . &lt;code&gt;$hasargs&lt;/code&gt; 는 새 인스턴스 인 &lt;code&gt;@_&lt;/code&gt; 있으면 참 와 &lt;code&gt;$bitmask&lt;/code&gt; 는 호출자가 컴파일 한 실용적인 힌트를 포함합니다. &lt;code&gt;$hints&lt;/code&gt; 는 &lt;code&gt;$^H&lt;/code&gt; 에 해당 하고 &lt;code&gt;$bitmask&lt;/code&gt; 는 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 해당합니다 . &lt;code&gt;$hints&lt;/code&gt; 와 값은 펄 버전 간의 변경 될 수 있으며, 외부에는 적합하지 않습니다.프레임에 설정되었습니다. &lt;code&gt;$hints&lt;/code&gt; &lt;code&gt;$bitmask&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cf857d30373eeccb44d9f659b21b0118b696cbc" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">여기서 $ subroutine은 호출자가 포함 된 함수가 아니라 호출자가 호출 한 함수입니다. 주 $ 서브 루틴이 될 수 있음 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 프레임이 서브 루틴 호출하지만,없는 경우 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 이러한 경우 $ evaltext 및 &lt;code&gt;$is_require&lt;/code&gt; 요소가 추가 로 설정됩니다. &lt;code&gt;$is_require&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 프레임을 만들면 true 이고 $ evaltext는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; 문의 텍스트를 포함합니다 . 특히 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 문의 경우 $ subroutine은 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 이지만 $ evaltext는 정의되어 있지 않습니다. (또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement 는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR 프레임 내에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임을 만듭니다 .) 이 특정 서브 루틴이 심볼 테이블에서 삭제 된 경우 $ subroutine도 &lt;code&gt;(unknown)&lt;/code&gt; . &lt;code&gt;$bitmask&lt;/code&gt; 는 호출자가 컴파일 한 실용적인 힌트를 포함합니다. &lt;code&gt;$hints&lt;/code&gt; 는 &lt;code&gt;$^H&lt;/code&gt; 에 해당 하고 &lt;code&gt;$bitmask&lt;/code&gt; 는 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 해당합니다 . &lt;code&gt;$hints&lt;/code&gt; 와 값은 펄 버전 간의 변경 될 수 있으며, 외부에는 적합하지 않습니다. &lt;code&gt;$hasargs&lt;/code&gt; 의 새로운 인스턴스 마찬가지입니다 &lt;code&gt;@_&lt;/code&gt; 이 프레임에 설정되었다. &lt;code&gt;$hints&lt;/code&gt; 와 &lt;code&gt;$bitmask&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3735e4f7cd84efb99098edde43ca86112a7452e" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(eval)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statement, $evaltext contains the text of the &lt;code&gt;eval EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;eval BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(eval)&lt;/code&gt;, but $evaltext is undefined. (Note also that each &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; statement creates a &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; frame inside an &lt;code&gt;eval EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;a href=&quot;perlvar#%24%5EH&quot;&gt;&lt;code&gt;$^H&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;a href=&quot;perlvar#%24%7B%5EWARNING_BITS%7D&quot;&gt;&lt;code&gt;${^WARNING_BITS}&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">여기서 $ subroutine은 호출자가 호출 한 함수입니다 (호출자를 포함하는 함수가 아님). 주 $ 서브 루틴이 될 수 있음 &lt;code&gt;(eval)&lt;/code&gt; 프레임이 서브 루틴 호출하지만,없는 경우 &lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; . 이러한 경우 추가 요소 $ evaltext 및 &lt;code&gt;$is_require&lt;/code&gt; 가 설정됩니다. &lt;code&gt;$is_require&lt;/code&gt; 는 프레임이 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 문에 의해 생성 된 경우 true 이고 $ evaltext에는 &lt;code&gt;eval EXPR&lt;/code&gt; 문의 텍스트가 포함 됩니다. 특히 &lt;code&gt;eval BLOCK&lt;/code&gt; 문의 경우 $ subroutine은 &lt;code&gt;(eval)&lt;/code&gt; 이지만 $ evaltext는 정의되어 있지 않습니다. (또한 각 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 문은 내부에 &lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 프레임을 만듭니다. &lt;code&gt;eval EXPR&lt;/code&gt; 프레임.) $ subroutine 은이 특정 서브 루틴이 기호 테이블에서 삭제 된 경우 &lt;code&gt;(unknown)&lt;/code&gt; 일 수도 있습니다 . 프레임 에 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 의 새 인스턴스 가 설정된 경우 &lt;code&gt;$hasargs&lt;/code&gt; 는 참 입니다. &lt;code&gt;$hints&lt;/code&gt; 및 &lt;code&gt;$bitmask&lt;/code&gt; 에는 호출자가 컴파일 된 실용적인 힌트가 포함되어 있습니다. &lt;code&gt;$hints&lt;/code&gt; 는 &lt;a href=&quot;perlvar#%24%5EH&quot;&gt; &lt;code&gt;$^H&lt;/code&gt; &lt;/a&gt; 에 해당 하고 &lt;code&gt;$bitmask&lt;/code&gt; 는 &lt;a href=&quot;perlvar#%24%7B%5EWARNING_BITS%7D&quot;&gt; &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; &lt;/a&gt; 해당합니다 . &lt;code&gt;$hints&lt;/code&gt; 및 &lt;code&gt;$bitmask&lt;/code&gt; 값은 펄 버전 간의 변경 될 수 있으며, 외부에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="caa26f85e260be75edcd0346a364ee2896d298ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; breaks the degeneracy of string partitioning by gobbling up as much of the string as possible and keeping it. Then match failures fail much more quickly.</source>
          <target state="translated">여기에서 &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; 는 가능한 한 많은 문자열을 가져 와서 유지함으로써 문자열 분할의 축 퇴성을 깨뜨립니다. 그러면 일치 실패가 훨씬 빨리 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a1b989b57eb518dccad89ad922a4fe2c3b8290b8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; , leaving &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; the opportunity to match both &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;'s. Finally,</source>
          <target state="translated">여기 &lt;code&gt;.?&lt;/code&gt; 문자열에서 가능한 가장 빠른 위치에서 최대 한 문자를 먹습니다. &lt;code&gt;'a'&lt;/code&gt; 에서 &lt;code&gt;programming&lt;/code&gt; , 떠나 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 모두 일치 할 수있는 기회 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 의합니다. 드디어,</target>
        </trans-unit>
        <trans-unit id="6940871278768e0d3843403746506dfab5014fac" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;, leaving &lt;code&gt;m{1,2}&lt;/code&gt; the opportunity to match both &lt;code&gt;'m'&lt;/code&gt;'s. Finally,</source>
          <target state="translated">여기, &lt;code&gt;.?&lt;/code&gt; &lt;code&gt;programming&lt;/code&gt; 에서 &lt;code&gt;'a'&lt;/code&gt; 문자열의 가능한 가장 빠른 위치에서 최대 한 문자를 먹고 &lt;code&gt;m{1,2}&lt;/code&gt; 은 두 &lt;code&gt;'m'&lt;/code&gt; 과 일치 할 수있는 기회를 남깁니다 . 드디어,</target>
        </trans-unit>
        <trans-unit id="a4a0735ee9beb6f441c46c7bd92351e785038614" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt; .</source>
          <target state="translated">가장 빠른 시합은 처음입니다 &lt;code&gt;'m'&lt;/code&gt; &lt;code&gt;programming&lt;/code&gt; 'm' 입니다 . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 는 첫 번째 수량 자이므로 최대 &lt;code&gt;mm&lt;/code&gt; 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="aadfcc9f4e36a1550c20bdeb59b13a55d871dfc7" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;. &lt;code&gt;m{1,2}&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt;.</source>
          <target state="translated">여기서 가능한 가장 빠른 일치는 &lt;code&gt;programming&lt;/code&gt; 의 첫 번째 &lt;code&gt;'m'&lt;/code&gt; 입니다 . &lt;code&gt;m{1,2}&lt;/code&gt; 은 첫 번째 수량 자이므로 최대 &lt;code&gt;mm&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3716a6d294692219d3cd1801d8d99a5dbba94e08" translate="yes" xml:space="preserve">
          <source>Here, all the alternatives match at the first string position, so the first alternative is the one that matches. If some of the alternatives are truncations of the others, put the longest ones first to give them a chance to match.</source>
          <target state="translated">여기에서 모든 대안은 첫 번째 문자열 위치에서 일치하므로 첫 번째 대안은 일치하는 대안입니다. 일부 대안이 다른 대안보다 잘린 경우 가장 긴 대안을 먼저 배치하여 일치시킬 수있는 기회를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="689480ae64fc1f47a0a934be3391ff1dd20b6f51" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt; .</source>
          <target state="translated">여기에는 현재 연결된 모든 확장에 대한 코드와 &lt;code&gt;DBI&lt;/code&gt; 및 &lt;code&gt;DBD::Oracle&lt;/code&gt; 코드가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e1da21ea3d3d0f4b406cb9d4b1c545dbb154ce6" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;DBI&lt;/code&gt; 및 &lt;code&gt;DBD::Oracle&lt;/code&gt; 대한 코드와 함께 현재 연결된 모든 확장에 대한 코드가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aaaa9a188728345ceda0023a2930141166a0d68" translate="yes" xml:space="preserve">
          <source>Here, the code points 0x964 and 0x965 are both used in Bengali, Devanagari, Gurmukhi, and Oriya, but no other scripts.</source>
          <target state="translated">여기서 코드 포인트 0x964 및 0x965는 모두 벵골어, 데바 나가리, 구르 무키 및 오리 야에서 사용되지만 다른 스크립트는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6406af5e03eb4f4938f3da32dd26a4c74c548ed" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 정규 표현식은 문자열의 시작 부분과 일치합니다. 첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 가능한 한 많이 잡아 단일 &lt;code&gt;'m'&lt;/code&gt; 두 번째 수량 자 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 대해 'm' .</target>
        </trans-unit>
        <trans-unit id="9bd5106d8c958bc219ebcb6fcaec8723192083e1" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;m{1,2}&lt;/code&gt;.</source>
          <target state="translated">여기서 정규 표현식은 문자열의 시작 부분과 일치합니다. 첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 가능한 한 많이 잡아 두 번째 수량 자 &lt;code&gt;m{1,2}&lt;/code&gt; 대해 &lt;code&gt;'m'&lt;/code&gt; 하나만 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="c10eb1d2f1c36813ee26854f2e1241cc9e1fd565" translate="yes" xml:space="preserve">
          <source>Here, we use a second &lt;code&gt;open&lt;/code&gt; argument of &lt;code&gt;&quot;|-&quot;&lt;/code&gt;, signifying that the filehandle assigned to &lt;code&gt;$cat_fh&lt;/code&gt; should be a write-pipe. We can then use it just as we would a write-only ordinary filehandle, including the basic function of &lt;code&gt;print&lt;/code&gt;-ing data to it.</source>
          <target state="translated">여기서는 &lt;code&gt;$cat_fh&lt;/code&gt; 할당 된 파일 핸들 이 write-pipe 여야 함을 나타내는 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 의 두 번째 &lt;code&gt;open&lt;/code&gt; 인수를 사용합니다 . 그런 다음 데이터를 &lt;code&gt;print&lt;/code&gt; 하는 기본 기능을 포함하여 쓰기 전용 일반 파일 핸들처럼 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d40285a9c3c8ccdbd6762112a10bef59352519d" translate="yes" xml:space="preserve">
          <source>Here, when the '$a' in the eval is being compiled, f() is not currently being executed, so its $a is not available for capture.</source>
          <target state="translated">여기서 eval의 '$ a'를 컴파일 할 때 f ()가 현재 실행되고 있지 않으므로 $ a를 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd7c1c3b995f345fd62ac66cfeb3e09d91946309" translate="yes" xml:space="preserve">
          <source>Here, when the '\&amp;amp;a' in the eval is being compiled, f() is not currently being executed, so its &amp;amp;a is not available for capture.</source>
          <target state="translated">여기서 eval의 '\ &amp;amp; a'를 컴파일 할 때 f ()가 현재 실행되고 있지 않으므로 &amp;amp; a를 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ede19d3c74e6b3a68c4bd3de5c03f1c72f2ba22c" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">16 진 문자열은 정수만 나타낼 수 있습니다. 정수 오버 플로우를 유발하는 문자열은 경고를 트리거합니다. oct ()와 달리 선행 공백은 제거되지 않습니다. 16 진수로 표현하려면 &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt; , &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt; 및&lt;a href=&quot;#unpack&quot;&gt; unpack을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ab04b2f53a36bbb2dc5c2deb103b3c069c62c2" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">16 진 문자열은 정수만 나타낼 수 있습니다. 정수 오버 플로우를 유발하는 문자열은 경고를 트리거합니다. oct ()와 달리 선행 공백은 제거되지 않습니다. 16 진수로 표현하려면 &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt; , &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt; 및&lt;a href=&quot;unpack&quot;&gt; unpack을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f63676066d11c05b5d8b9b8be78e1e17f582eed6" translate="yes" xml:space="preserve">
          <source>Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal numbers are not recognized by new(), so the following will print &quot;123&quot;:</source>
          <target state="translated">16 진수 ( &quot;0x&quot;접두사)와 2 진수 ( &quot;0b&quot;접두사)도 사용할 수 있습니다. 8 진수는 new ()로 인식되지 않으므로 다음은 &quot;123&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2486d235457d8e2812e9f4481543bdfa3dc85c5e" translate="yes" xml:space="preserve">
          <source>Hexadecimal Notation</source>
          <target state="translated">16 진법</target>
        </trans-unit>
        <trans-unit id="d754dce244e30fbc42722c0d0d3408fc0e8b5ff5" translate="yes" xml:space="preserve">
          <source>Hexadecimal escapes</source>
          <target state="translated">16 진수 탈출</target>
        </trans-unit>
        <trans-unit id="ceb4c2b4da9935612f806f0eaf63dea44928d37a" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: exponent overflow</source>
          <target state="translated">16 진수 부동 : 지수 오버플로</target>
        </trans-unit>
        <trans-unit id="6787bb9bded584a1ccebdd178acfcd973639f3f7" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: exponent underflow</source>
          <target state="translated">16 진수 부동 : 지수 언더 플로</target>
        </trans-unit>
        <trans-unit id="48201f76ddff073fa44d07df4a8baaecc78c6e0e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: internal error (%s)</source>
          <target state="translated">16 진수 부동 : 내부 오류 (% s)</target>
        </trans-unit>
        <trans-unit id="71fdf425e37a4288160c1066f4c9ea378b81d48e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: mantissa overflow</source>
          <target state="translated">16 진수 부동 : 가수 오버플로</target>
        </trans-unit>
        <trans-unit id="08fee2dcc28bb2107c935539547a0cafdbf2783a" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: precision loss</source>
          <target state="translated">16 진수 부동 : 정밀도 손실</target>
        </trans-unit>
        <trans-unit id="4f362cd2180b7cce0594c6133e6481cd125bcf0e" translate="yes" xml:space="preserve">
          <source>Hexadecimal float: unsupported long double format</source>
          <target state="translated">16 진수 부동 : 지원되지 않는 long double 형식</target>
        </trans-unit>
        <trans-unit id="0055aac53ab95723749bf6b5bb8f9b5857c75d3e" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt; , an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">16 진 부동 소수점은 16 진 리터럴처럼 시작할 수 있으며 선택적 16 진 16 진 부분이 올 수 있지만 &lt;code&gt;p&lt;/code&gt; 뒤에는 선택적 부호와 2의 거듭 제곱이 와야합니다 . 이 형식은 부동 소수점 값을 정확하게 표시하고 십진 부동 소수점으로 또는 소수 부동 소수점으로의 변환을 피하여 가능한 정밀도 손실을 피하는 데 유용합니다. 대부분의 최신 플랫폼은 64 비트 IEEE 754 부동 소수점을 사용하지만 모든 플랫폼을 사용하는 것은 아닙니다. (낮은 순서의) 차이점의 또 다른 잠재적 원인은 부동 소수점 반올림 모드로, CPU, 운영 체제 및 컴파일러마다 다를 수 있으며 Perl이 제어하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6538253332ea41555b76df01c0a9eb4e30e75f6d" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt;, an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">16 진수 부동 소수점은 16 진수 리터럴처럼 시작할 수 있으며 그 뒤에 선택적 분수 16 진수 부분이 올 수 있지만 그 뒤에는 &lt;code&gt;p&lt;/code&gt; , 선택적 부호 및 2의 거듭 제곱이 와야합니다 . 이 형식은 부동 소수점 값을 정확하게 표시하고 10 진수 부동 소수점과의 변환을 방지하여 정밀도 손실을 방지하는 데 유용합니다. 대부분의 최신 플랫폼은 64 비트 IEEE 754 부동 소수점을 사용하지만 모든 플랫폼이 사용하는 것은 아닙니다. (하위) 차이의 또 다른 잠재적 원인은 CPU, 운영 체제 및 컴파일러간에 다를 수 있고 Perl이 제어하지 않는 부동 소수점 반올림 모드입니다.</target>
        </trans-unit>
        <trans-unit id="8905655ccfc1958b445b80fef0232ecf74e57bc8" translate="yes" xml:space="preserve">
          <source>Hexadecimal number &amp;gt; 0xffffffff non-portable</source>
          <target state="translated">16 진수&amp;gt; 0xffffffff 이동 불가능</target>
        </trans-unit>
        <trans-unit id="c5f839007ffa6c33e78ea32b2edbfe75db988fef" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt; and &lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt; for more details.</source>
          <target state="translated">문자열 리터럴의 16 진, 8 진 또는 2 진 표현 (예 : '0xff')은 정수 표현으로 자동 변환되지 않습니다. hex () 및 oct () 함수는 이러한 변환을 수행합니다. &lt;a href=&quot;functions/hex&quot;&gt;16 진수&lt;/a&gt; 및 &lt;a href=&quot;functions/oct&quot;&gt;10 &lt;/a&gt;진수 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="394f3535ef6619d95b226f10b0fb91749452cd92" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;perlfunc#hex&quot;&gt;&quot;hex&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#oct&quot;&gt;&quot;oct&quot; in perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">문자열 리터럴 (예 : '0xff')의 16 진수, 8 진수 또는 이진 표현은 자동으로 정수 표현으로 변환되지 않습니다. hex () 및 oct () 함수는 이러한 변환을 수행합니다. 보기 &lt;a href=&quot;perlfunc#hex&quot;&gt;을 perlfunc의 '진수'&lt;/a&gt; 와 &lt;a href=&quot;perlfunc#oct&quot;&gt;을 perlfunc에서 &quot;10월&quot;&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="af0d47fb48d369e779ea66f99b77ac3ba09d56e3" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이봐, 펄은 이런 종류의 일을 쉬워야하지 않니? 올바른 도구를 사용하면 좋습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 위와 같은 고정 너비 데이터를 처리 할 때 도움이되도록 설계되었습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 솔루션을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="07a002a323d2c31a9141607bc892ee1574aeebbd" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">이봐, Perl이 이런 일을 쉽게해주어야하지 않니? 글쎄요, 당신이 올바른 도구를 사용한다면 그렇습니다. &lt;code&gt;pack&lt;/code&gt; 및 &lt;code&gt;unpack&lt;/code&gt; 은 위와 같은 고정 너비 데이터를 처리 할 때 도움이되도록 설계되었습니다. &lt;code&gt;unpack&lt;/code&gt; 을 사용하여 솔루션을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="38419124bd7b06ea4fc82f2ec5707cd4239617e6" translate="yes" xml:space="preserve">
          <source>Hiding Perl_</source>
          <target state="translated">Perl_ 숨기기</target>
        </trans-unit>
        <trans-unit id="1428b1718a9c369e65d9d918143e0a1d8ca542e9" translate="yes" xml:space="preserve">
          <source>Hiding or invalidating some other definition of the same name. (Not to be confused with &lt;b&gt;overloading&lt;/b&gt;, which adds definitions that must be disambiguated some other way.) To confuse the issue further, we use the word with two overloaded definitions: to describe how you can define your own &lt;b&gt;subroutine&lt;/b&gt; to hide a built-in &lt;b&gt;function&lt;/b&gt; of the same name (see the section &amp;ldquo;Overriding Built-in Functions&amp;rdquo; in Camel chapter 11, &amp;ldquo;Modules&amp;rdquo;), and to describe how you can define a replacement &lt;b&gt;method&lt;/b&gt; in a &lt;b&gt;derived class&lt;/b&gt; to hide a &lt;b&gt;base class&lt;/b&gt;&amp;rsquo;s method of the same name (see Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;).</source>
          <target state="translated">동일한 이름의 다른 정의를 숨기거나 무효화합니다. (와 혼동되지 않기 &lt;b&gt;오버로드&lt;/b&gt; . 다른 방법으로 명확해야 정의를 추가) 문제를 더 혼란, 우리는 두 개의 오버로드 정의와 단어를 사용하려면 : 당신이 당신의 자신을 정의하는 방법을 설명하는 &lt;b&gt;서브 루틴을&lt;/b&gt; 숨길 내장 &lt;b&gt;기능&lt;/b&gt; 이 대체 정의 할 수있는 방법을 같은 이름의, 그리고 설명하기 위해 ( &quot;내장 함수 재정의&quot;낙타 제 11 장에서, &quot;모듈&quot;섹션 참조) &lt;b&gt;방법&lt;/b&gt; A의 &lt;b&gt;파생 클래스&lt;/b&gt; 숨기기 위해 &lt;b&gt;기본 클래스&lt;/b&gt; 의의 방법을 같은 이름 (카멜 12 장 &quot;객체&quot;참조).</target>
        </trans-unit>
        <trans-unit id="c470287cb379da96c293a62fb8664cf2247d2b55" translate="yes" xml:space="preserve">
          <source>High Level</source>
          <target state="translated">높은 레벨</target>
        </trans-unit>
        <trans-unit id="ad6c175822059b79229ebfc786ac972d1cc9dd61" translate="yes" xml:space="preserve">
          <source>High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">고해상도 알람, 수면, gettimeofday, 간격 타이머</target>
        </trans-unit>
        <trans-unit id="06ec56d2d4a59020901e32260159cfaa9fcc9ac8" translate="yes" xml:space="preserve">
          <source>High-level commands do such initializations automatically.</source>
          <target state="translated">고급 명령은 이러한 초기화를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e29ea1646e3ae3268842b4efea0250df490ad525" translate="yes" xml:space="preserve">
          <source>Higher-Order Perl</source>
          <target state="translated">더 높은 순서의 Perl</target>
        </trans-unit>
        <trans-unit id="2f40e6c9a09885ca0cf7997c2375c0fe1fb31d9f" translate="yes" xml:space="preserve">
          <source>Hint: The &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; tutorial covers the T_INOUT, T_IN, and T_OUT XS types nicely.</source>
          <target state="translated">힌트 : &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 튜토리얼은 T_INOUT, T_IN 및 T_OUT XS 유형을 잘 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e3d4d7c7e48bee9d90099bb119b39917c09def77" translate="yes" xml:space="preserve">
          <source>Hint: sometimes appending &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; to your message will cause it to make better sense when the string &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; is appended. Suppose you are running script &quot;canasta&quot;.</source>
          <target state="translated">힌트 : 메시지에 &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; 을 추가 하면 &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; 문자열 이 추가 될 때 더 잘 이해 될 수 있습니다 . &quot;canasta&quot;스크립트를 실행한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="eef8e89aeb708a408921fec1b9e87c4d04faaced" translate="yes" xml:space="preserve">
          <source>Hints</source>
          <target state="translated">Hints</target>
        </trans-unit>
        <trans-unit id="4d29825148796b94b3706b9469ee384bc5c32604" translate="yes" xml:space="preserve">
          <source>Hints can be provided for both scalar and list contexts. Note that an autodying subroutine will never see a void context, as &lt;code&gt;autodie&lt;/code&gt; always needs to capture the return value for examination. Autodying subroutines called in void context act as if they're called in a scalar context, but their return value is discarded after it has been checked.</source>
          <target state="translated">스칼라 및 목록 컨텍스트 모두에 대해 힌트를 제공 할 수 있습니다. &lt;code&gt;autodie&lt;/code&gt; 는 항상 검사를 위해 반환 값을 캡처해야 하므로 autodying 서브 루틴은 void 컨텍스트를 볼 수 없습니다 . void 컨텍스트에서 호출 된 Autodying 서브 루틴은 스칼라 컨텍스트에서 호출 된 것처럼 작동하지만 반환 값은 확인 된 후에 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2e7ad51592f12093f07f504091e6b4574d36b5ff" translate="yes" xml:space="preserve">
          <source>Hints for Writing Pod</source>
          <target state="translated">포드 작성을위한 힌트</target>
        </trans-unit>
        <trans-unit id="b645eb28e32b28c0363e14b822198d8bf042449d" translate="yes" xml:space="preserve">
          <source>Hints may consist of subroutine references, objects overloading smart-match, regular expressions, and depending on Perl version possibly other things. You can specify different hints for how failure should be identified in scalar and list contexts.</source>
          <target state="translated">힌트는 서브 루틴 참조, 스마트 매치를 오버로딩하는 객체, 정규식 및 Perl 버전에 따라 다른 것들로 구성 될 수 있습니다. 스칼라 및 목록 컨텍스트에서 실패를 식별하는 방법에 대해 다른 힌트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd94510567b2e65da4d128c15c97d4b8bf6c814e" translate="yes" xml:space="preserve">
          <source>Hintsfile support</source>
          <target state="translated">힌트 파일 지원</target>
        </trans-unit>
        <trans-unit id="57ec96f40e52a96bf96bf4e1bcab6928fd860e76" translate="yes" xml:space="preserve">
          <source>Historical note: A few older Pod processors would not see a &quot;&amp;gt;&quot; as closing a &quot;C&amp;lt;&quot; code, if the &quot;&amp;gt;&quot; was immediately preceded by a &quot;-&quot;. This was so that this:</source>
          <target state="translated">기록 참고 : &quot;&amp;gt;&quot;바로 앞에 &quot;-&quot;가 있으면 일부 이전 포드 프로세서는 &quot;&amp;gt;&quot;를 &quot;C &amp;lt;&quot;코드를 닫는 것으로 볼 수 없습니다. 이것은 이렇게 :</target>
        </trans-unit>
        <trans-unit id="456da061b07638f2efc60c23c53fa3c2c51535e7" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt; . Now, 'wrap' is the default value.</source>
          <target state="translated">역사적 메모 : 'die'는 기본값 &lt;code&gt;$huge&lt;/code&gt; 였습니다. 이제 'wrap'이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="19ea8843c58830508eaf140dfecf76c53f9de3a3" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt;. Now, 'wrap' is the default value.</source>
          <target state="translated">역사적 메모 : 'die'는 &lt;code&gt;$huge&lt;/code&gt; 의 기본값이었습니다 . 이제 'wrap'이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3e800c8fc87d99008c1563976a3e7822cfaf0d87" translate="yes" xml:space="preserve">
          <source>Historically Perl has been a refcounted language. This means that each variable tracks how many things reference it, and when the variable is no longer referenced it will automatically free itself. In theory Perl code should not have to care about this, and in a future version Perl might change to some other strategy, although in practice this is unlikely.</source>
          <target state="translated">역사적으로 Perl은 refcounted 언어였습니다. 즉, 각 변수는 자신을 참조하는 항목의 수를 추적하고 변수가 더 이상 참조되지 않으면 자동으로 해제됩니다. 이론상 Perl 코드는 이에 대해 신경 쓸 필요가 없으며, 향후 버전에서는 Perl이 다른 전략으로 변경 될 수 있지만 실제로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b09a13158d2d1c843704dc0085426732de965d7" translate="yes" xml:space="preserve">
          <source>Historically Perl has varied in whether sorting is stable by default. If stability matters, it can be controlled explicitly by using the &lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; pragma.</source>
          <target state="translated">역사적으로 Perl은 정렬이 기본적으로 안정적인지 여부가 다양했습니다. 안정성이 중요한 경우 &lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; pragma 를 사용하여 명시 적으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4bea0d3c8dc12ea86900e60a2460f211b081d43" translate="yes" xml:space="preserve">
          <source>Historically, any software that you give away, particularly if you make the source code available as well. Now often called &lt;b&gt;open source software&lt;/b&gt;. Recently there has been a trend to use the term in contradistinction to &lt;b&gt;open source software&lt;/b&gt;, to refer only to free software released under the Free Software Foundation&amp;rsquo;s GPL (General Public License), but this is difficult to justify etymologically.</source>
          <target state="translated">역사적으로, 특히 소스 코드를 사용할 수있게하는 경우 제공하는 모든 소프트웨어. 이제는 종종 &lt;b&gt;오픈 소스 소프트웨어&lt;/b&gt; 라고 &lt;b&gt;합니다&lt;/b&gt; . 최근 에 자유 소프트웨어 재단의 GPL (General Public License)에 따라 공개 된 자유 소프트웨어만을 언급 하기 위해 &lt;b&gt;오픈 소스 소프트웨어&lt;/b&gt; 에 대립하는 용어를 사용하는 경향 이 있었지만 이는 어원 적으로 정당화하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="97391b474b93a4ff5ad2004bc1c3d103a9fb4d4e" translate="yes" xml:space="preserve">
          <source>Historically, only the pumpking cherry-picked changes from bleadperl into maintperl. This has scaling problems. At the same time, maintenance branches of stable versions of Perl need to be treated with great care. To that end, as of Perl 5.12, we have a new process for maint branches.</source>
          <target state="translated">역사적으로 호박 벚나무 따기 만 bleadperl에서 maintperl로 바뀝니다. 스케일링 문제가 있습니다. 동시에, 안정적인 버전의 Perl의 유지 관리 지점은 세심한주의를 기울여야합니다. 이를 위해 Perl 5.12부터 maint 브랜치를위한 새로운 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70077bc9082a3c8ea160dc01f918a3a65a6e212" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt; , which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">역사적으로, 이들은 표준 perl 분포의 일부인 &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; 도구에 의해 생성되었습니다 . 이 프로그램 은 C 헤더 파일의 &lt;code&gt;cpp(1)&lt;/code&gt; 지시문을 &lt;code&gt;SYS_getitimer()&lt;/code&gt; 와 같은 서브 루틴 정의가 포함 된 파일 로 변환 하여 함수의 인수로 사용할 수 있습니다. 완벽하게 작동하지는 않지만 일반적으로 대부분의 작업이 완료됩니다. 간단한 파일</target>
        </trans-unit>
        <trans-unit id="63c14478e9043824d23cc2298dab27f2d02eeb16" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt;, which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">역사적으로 이것들은 표준 펄 배포판의 일부인 &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; 도구에 의해 생성되었습니다 . 이 프로그램 은 C 헤더 파일의 &lt;code&gt;cpp(1)&lt;/code&gt; 지시문을 함수에 대한 인수로 사용할 수있는 &lt;code&gt;SYS_getitimer()&lt;/code&gt; 와 같은 서브 루틴 정의를 포함하는 파일 로 변환 합니다. 완벽하게 작동하지는 않지만 일반적으로 대부분의 작업을 수행합니다. 다음과 같은 간단한 파일</target>
        </trans-unit>
        <trans-unit id="723525aec4e05b078bfa1f7212775fddba5a19b2" translate="yes" xml:space="preserve">
          <source>Historically, we've held ourselves to a far higher standard than backward-compatibility -- bugward-compatibility. Any accident of implementation or unintentional side-effect of running some bit of code has been considered to be a feature of the language to be defended with the same zeal as any other feature or functionality. No matter how frustrating these unintentional features may be to us as we continue to improve Perl, these unintentional features often deserve our protection. It is very important that existing software written in Perl continue to work correctly. If end-user developers have adopted a bug as a feature, we need to treat it as such.</source>
          <target state="translated">역사적으로 우리는 이전 버전과의 호환성 (버그와의 호환성)보다 훨씬 더 높은 표준을 유지해 왔습니다. 구현 실수 또는 일부 비트 코드 실행으로 인한 의도하지 않은 부작용은 다른 특징 또는 기능과 동일한 열정으로 방어 할 언어의 특징으로 간주되었습니다. Perl을 계속 개선함에 따라 이러한 의도하지 않은 기능이 얼마나 실망 스러울지라도 이러한 의도하지 않은 기능은 종종 보호받을 가치가 있습니다. Perl로 작성된 기존 소프트웨어가 계속 올바르게 작동하는 것이 매우 중요합니다. 최종 사용자 개발자가 버그를 기능으로 채택한 경우이를 버그로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="2e6d74e94851d72f49d2c6b59183be96d60c8e34" translate="yes" xml:space="preserve">
          <source>History and Background</source>
          <target state="translated">역사와 배경</target>
        </trans-unit>
        <trans-unit id="ace535b09698d3ae2888504e132d0829ba6b4d7d" translate="yes" xml:space="preserve">
          <source>History of CPAN Meta Spec changes</source>
          <target state="translated">CPAN 메타 사양 변경 내역</target>
        </trans-unit>
        <trans-unit id="3e8e120f18fdbffd8b9be5d8fa532f5e8e03fa02" translate="yes" xml:space="preserve">
          <source>History of Middle Earth</source>
          <target state="translated">중간계의 역사</target>
        </trans-unit>
        <trans-unit id="9d34c3581dd43beee5ddd060d0bab25f439fd94b" translate="yes" xml:space="preserve">
          <source>History of WinCE port</source>
          <target state="translated">WinCE 포트의 역사</target>
        </trans-unit>
        <trans-unit id="e73e3de4102afafe13d5b9177c279b777279e4aa" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;'d'&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">흠. 여기 뭔 일 있었 니? 따라 해보 셨다면 위의 패턴이 마지막 패턴과 효과적으로 (거의) 동일해야한다는 것을 알고 계실 것입니다. 문자 클래스에서 &lt;code&gt;'d'&lt;/code&gt; 를 묶어 도 일치하는 항목이 변경되지 않습니다. 그렇다면 첫 번째는 인쇄되지 않고 두 번째는 인쇄되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9733ac081a67789bdb91140dbb2aaf4de5c5ec7b" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;d&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">흠. 여기 뭔 일 있었 니? 당신이 따라왔다면, 위의 패턴은 마지막 패턴과 실질적으로 (거의) 동일해야합니다. 문자 클래스에서 &lt;code&gt;d&lt;/code&gt; 를 묶어 도 일치하는 것을 변경하지 않습니다. 그렇다면 왜 첫 번째는 인쇄하지 않고 두 번째는 인쇄하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="821ac8e428a38ddcf25e2027bc128ec6e743a489" translate="yes" xml:space="preserve">
          <source>Hmm... that's still a bit ugly. How about this:</source>
          <target state="translated">흠 ... 그건 여전히 못 생겼다. 이건 어때요:</target>
        </trans-unit>
        <trans-unit id="511721548acc73e7ad2a7122ec29970e3c6188d3" translate="yes" xml:space="preserve">
          <source>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</source>
          <target state="translated">패턴 시작에서 고정 오프셋에서 발생해야하는 가장 긴 문자열과 패턴 시작에서 부동 오프셋에서 발생해야하는 가장 긴 문자열에 대한 정보를 보유합니다. 문자열에서 Fast-Boyer-Moore 검색을 수행하여 정규식 엔진을 사용할 가치가 있는지 여부와 문자열에서 검색 할 위치를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="959988c98232c3eb8b17616f91948b459e04946f" translate="yes" xml:space="preserve">
          <source>Holds some explanation in the case of an error.</source>
          <target state="translated">에러가 발생했을 경우에 대한 설명을 담고 있습니다.</target>
        </trans-unit>
        <trans-unit id="01443708f436be923f0aee8880549437dad1a448" translate="yes" xml:space="preserve">
          <source>Holds the last reported error. Kept for historical reasons, but its use is very much discouraged. Use the &lt;code&gt;error()&lt;/code&gt; method instead:</source>
          <target state="translated">마지막으로보고 된 오류를 보유합니다. 역사적인 이유로 유지되었지만 사용이 매우 권장되지 않습니다. &lt;code&gt;error()&lt;/code&gt; 메소드를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c95db6ed76758307edcf864f1a4ab2acb112562d" translate="yes" xml:space="preserve">
          <source>Holds the output of the &lt;code&gt;date&lt;/code&gt; command when the configuration file was produced. This is used to tag both</source>
          <target state="translated">구성 파일이 생성 될 때 &lt;code&gt;date&lt;/code&gt; 명령 의 출력을 보유합니다 . 둘 다 태그하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="739c29f4f6f84e7a7eaff9a32fa3671bc3d08941" translate="yes" xml:space="preserve">
          <source>Holds the private path used by Configure to find out the libraries. Its value is prepend to libpth. This variable takes care of special machines, like the mips. Usually, it should be empty.</source>
          <target state="translated">라이브러리가 찾기 위해 Configure에서 사용하는 개인 경로를 보유합니다. 그 값은 libpth 앞에 붙습니다. 이 변수는 밉과 같은 특수 기계를 처리합니다. 일반적으로 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="582b824400c82cf0f40f9f7c604827d48ea750f5" translate="yes" xml:space="preserve">
          <source>Holds the standard error of the executed command (or empty string if there was no STDERR output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 오류를 보유합니다 (또는 STDERR 출력이 없거나 &lt;code&gt;discard_output&lt;/code&gt; _ 출력 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="7c3e4c3ddb7125c1c1e75cedd0d2a9c28f53291d" translate="yes" xml:space="preserve">
          <source>Holds the standard output and error of the executed command merged into one stream (or empty string if there was no output at all or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 출력 및 오류를 하나의 스트림으로 병합합니다 (또는 출력이 전혀 없거나 &lt;code&gt;discard_output&lt;/code&gt; 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="5f9c8ab4b280eb2c610d191400d239df37776272" translate="yes" xml:space="preserve">
          <source>Holds the standard output of the executed command (or empty string if there was no STDOUT output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 출력을 보유합니다 (또는 STDOUT 출력이 없거나 &lt;code&gt;discard_output&lt;/code&gt; _ 출력 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="1f43fffdbf7b0c05af0b8fc8fcc67b1c8be39947" translate="yes" xml:space="preserve">
          <source>Home page for ISO 15924.</source>
          <target state="translated">ISO 15924 홈페이지.</target>
        </trans-unit>
        <trans-unit id="1ba2fa3de9992cda18c006a91b37960fee16b9e0" translate="yes" xml:space="preserve">
          <source>Hook manipulation</source>
          <target state="translated">후크 조작</target>
        </trans-unit>
        <trans-unit id="5027e8d0e915f65d00ad88208e35669396121f09" translate="yes" xml:space="preserve">
          <source>Hook stack for managing scopes via %^H</source>
          <target state="translated">% ^ H를 통해 범위를 관리하기위한 후크 스택</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4b09a3b7ef7178d5866c8b4122a3b1b80e280cb2" translate="yes" xml:space="preserve">
          <source>Hopefully the contents of each of the filters should be self-explanatory. Both &quot;fetch&quot; filters remove the terminating NULL, and both &quot;store&quot; filters add a terminating NULL.</source>
          <target state="translated">각 필터의 ​​내용이 자명해야합니다. 두 &quot;fetch&quot;필터는 종료 NULL을 제거하고 두 &quot;store&quot;필터는 종료 NULL을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1a684169a4210a05fab1617879fe368df08034f1" translate="yes" xml:space="preserve">
          <source>HostName</source>
          <target state="translated">HostName</target>
        </trans-unit>
        <trans-unit id="5a0c43672840e7d1029ec4aa340b54209da75c4a" translate="yes" xml:space="preserve">
          <source>Hostname and service name for the local address to &lt;code&gt;bind()&lt;/code&gt; to.</source>
          <target state="translated">&lt;code&gt;bind()&lt;/code&gt; 할 로컬 주소의 호스트 이름 및 서비스 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3159cb6d83d75fcd994ddd9e9c2b1dcf0d071ae6" translate="yes" xml:space="preserve">
          <source>Hostname and service name for the peer to &lt;code&gt;connect()&lt;/code&gt; to. The service name may be given as a port number, as a decimal string.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 할 피어의 호스트 이름 및 서비스 이름입니다 . 서비스 이름은 10 진수 문자열로 포트 번호로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c81abc87bdc5538df96766fcae6d44438449d0a" translate="yes" xml:space="preserve">
          <source>How</source>
          <target state="translated">How</target>
        </trans-unit>
        <trans-unit id="b28755c4371822ab05bbd3edfbd84f8ae5c44516" translate="yes" xml:space="preserve">
          <source>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</source>
          <target state="translated">이진 데이터를 특정 인코딩으로 변환하거나 그 반대로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="5ec153ad02980479ddc59f23ab37e27027e62588" translate="yes" xml:space="preserve">
          <source>How Do I Detect Data That's Not Valid In a Particular Encoding?</source>
          <target state="translated">특정 인코딩에서 유효하지 않은 데이터를 어떻게 탐지합니까?</target>
        </trans-unit>
        <trans-unit id="83daa5c8b58e95efd16e89c69000aaf2de146549" translate="yes" xml:space="preserve">
          <source>How Do I Display Unicode? How Do I Input Unicode?</source>
          <target state="translated">유니 코드를 어떻게 표시합니까? 유니 코드는 어떻게 입력합니까?</target>
        </trans-unit>
        <trans-unit id="eed7b35ef6f59f0cb6c635063802f8b69563cf7e" translate="yes" xml:space="preserve">
          <source>How Do I Find Out What Encoding a File Has?</source>
          <target state="translated">파일 인코딩이 무엇인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="87e4752c70fc96666a27cf0847bc95f48c8b5c9c" translate="yes" xml:space="preserve">
          <source>How Do I Know Whether My String Is In Unicode?</source>
          <target state="translated">내 문자열이 유니 코드인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9a4dab32f52f3d5fb8384770ca50058013424c08" translate="yes" xml:space="preserve">
          <source>How Do I Make My Scripts Work With Unicode?</source>
          <target state="translated">스크립트가 유니 코드로 작동하게하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="aa967413382158f18536864c2c5f2d495ed0e167" translate="yes" xml:space="preserve">
          <source>How Does Unicode Work With Traditional Locales?</source>
          <target state="translated">유니 코드는 전통적인 로켈과 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ed7d6cb8e007f613e72e9f2c9f88a4738718ec79" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt; :</source>
          <target state="translated">어휘 경고가 &lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 와 상호 작용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="0ba774a79f5bdd71460b672473718c53cdc18568" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt;:</source>
          <target state="translated">어휘 경고가 &lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 와 상호 작용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="d1d502798bd5bd5bfc80ae2ff245f8510eaa3465" translate="yes" xml:space="preserve">
          <source>How Perl Chooses an Operator Implementation</source>
          <target state="translated">Perl이 운영자 구현을 선택하는 방법</target>
        </trans-unit>
        <trans-unit id="9d0dbe99bf0e202fd46e73a61d85e7d37d314d99" translate="yes" xml:space="preserve">
          <source>How PerlIO_apply_layera fits in, where its docs, was it made public?</source>
          <target state="translated">PerlIO_apply_layera는 어떻게 문서에 공개 되었습니까?</target>
        </trans-unit>
        <trans-unit id="c8ce23a97419be4cb95d062b610a07bbe22ce84e" translate="yes" xml:space="preserve">
          <source>How Plugins work?</source>
          <target state="translated">플러그인은 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="d5c739c2b8daeba650fc90008192e941caa8ca99" translate="yes" xml:space="preserve">
          <source>How SUPER is Resolved</source>
          <target state="translated">SUPER가 해결되는 방법</target>
        </trans-unit>
        <trans-unit id="30ea041c36c78a4bf2e3a15655945d87e8d2b703" translate="yes" xml:space="preserve">
          <source>How To Write A Makefile.PL</source>
          <target state="translated">Makefile.PL 작성 방법</target>
        </trans-unit>
        <trans-unit id="4a252fc6f68b2a5fddacedeb60aa9691abebcc2a" translate="yes" xml:space="preserve">
          <source>How a piece of code actually goes about doing its job. Users of the code should not count on implementation details staying the same unless they are part of the published &lt;b&gt;interface&lt;/b&gt;.</source>
          <target state="translated">실제로 코드 작업이 수행되는 방식 코드 사용자는 게시 된 &lt;b&gt;인터페이스의&lt;/b&gt; 일부가 아닌 한 동일하게 유지되는 구현 세부 정보에 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2e38e1473acd589790c55670049e3a998855b25" translate="yes" xml:space="preserve">
          <source>How are you supposed to know what flavour of Make a Makefile has been generated for if you didn't specify a value explicitly? Search the generated Makefile for the definition of the MAKE variable, which is used to recursively invoke the Make utility. That will tell you what Make you're supposed to invoke the Makefile with.</source>
          <target state="translated">명시 적으로 값을 지정하지 않은 경우 Makefile의 어떤 풍미가 생성되었는지 어떻게 알 수 있습니까? 생성 된 Makefile에서 MAKE 변수의 정의를 검색하십시오. 이는 Make 변수를 재귀 적으로 호출하는 데 사용됩니다. Makefile을 호출 할 Make를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="411ad64f6dc4be13b3049742bd05bd21505c6bc7" translate="yes" xml:space="preserve">
          <source>How big is it?</source>
          <target state="translated">얼마나 큽니까?</target>
        </trans-unit>
        <trans-unit id="27c74f66aeb35e0636195d822a7e3464616e6fc2" translate="yes" xml:space="preserve">
          <source>How can I access a dynamic variable while a similarly named lexical is in scope?</source>
          <target state="translated">비슷한 이름의 어휘가 범위 내에있는 동안 동적 변수에 어떻게 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a4335b4f09781554b24ada06ac33e99c54ce3d7c" translate="yes" xml:space="preserve">
          <source>How can I access or change N characters of a string?</source>
          <target state="translated">문자열의 N 문자를 어떻게 액세스하거나 변경할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5371ca66bd4ba8690a33a1384214275dda640111" translate="yes" xml:space="preserve">
          <source>How can I always keep my hash sorted?</source>
          <target state="translated">항상 해시를 정렬하여 유지하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8584960f36ac9f047e34a3eda935743347b5f7f6" translate="yes" xml:space="preserve">
          <source>How can I call backticks without shell processing?</source>
          <target state="translated">쉘 처리없이 백틱을 어떻게 호출 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cd430257f97dbf507a96e7339aa72325a34a2ee9" translate="yes" xml:space="preserve">
          <source>How can I call my system's unique C functions from Perl?</source>
          <target state="translated">Perl에서 시스템 고유의 C 함수를 어떻게 호출 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="90f43bbd8d5db22db1ec788113816dce3fba1fdc" translate="yes" xml:space="preserve">
          <source>How can I capture STDERR from an external command?</source>
          <target state="translated">외부 명령에서 STDERR을 어떻게 캡처 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="84907121b70e047be5c9daea9434199430d20e18" translate="yes" xml:space="preserve">
          <source>How can I catch accesses to undefined variables, functions, or methods?</source>
          <target state="translated">정의되지 않은 변수, 함수 또는 메소드에 대한 액세스를 어떻게 포착 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c73810cc9a224a5b0753f3ce02b7769672b7dc50" translate="yes" xml:space="preserve">
          <source>How can I change the permissions of a file on a remote server ?</source>
          <target state="translated">원격 서버에있는 파일의 권한을 어떻게 변경할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e13761e1cadfb4e6d275a8cd44df7f322009226b" translate="yes" xml:space="preserve">
          <source>How can I check if a key exists in a multilevel hash?</source>
          <target state="translated">다중 레벨 해시에 키가 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="9501d5027299df90931400bb41c70210a1c7aacf" translate="yes" xml:space="preserve">
          <source>How can I comment out a large block of Perl code?</source>
          <target state="translated">큰 Perl 코드 블록을 주석 처리하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="639138b8959cf833940b74db28e00ac3d078eb9d" translate="yes" xml:space="preserve">
          <source>How can I compare two dates and find the difference?</source>
          <target state="translated">두 날짜를 비교하고 차이점을 찾으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="92731d0a16ed8941afe35ab6fae1c71e5ff73d63" translate="yes" xml:space="preserve">
          <source>How can I compile my Perl program into byte code or C?</source>
          <target state="translated">Perl 프로그램을 바이트 코드 또는 C로 컴파일하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="f297bf1c9610312e098c5eff2eb10783e881e05c" translate="yes" xml:space="preserve">
          <source>How can I convert my shell script to perl?</source>
          <target state="translated">쉘 스크립트를 펄로 변환하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="fc9934bcfd8649f3922c04fc5693703b33981e29" translate="yes" xml:space="preserve">
          <source>How can I convince others to use Perl?</source>
          <target state="translated">다른 사람들에게 Perl을 사용하도록 설득하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="61781e6bf9642bee00811fb1e34ef7698e18ae20" translate="yes" xml:space="preserve">
          <source>How can I copy a file?</source>
          <target state="translated">파일을 어떻게 복사 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="62ee42141b7c95a311d0f8cb97c8e383832868b4" translate="yes" xml:space="preserve">
          <source>How can I count the number of occurrences of a substring within a string?</source>
          <target state="translated">문자열 내에서 하위 문자열의 발생 횟수를 어떻게 계산할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e426c21b9ed422b544529af4c9449106fd8175dd" translate="yes" xml:space="preserve">
          <source>How can I debug my scripts that use Net::* modules ?</source>
          <target state="translated">Net :: * 모듈을 사용하는 스크립트를 어떻게 디버깅 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f0aa6516dbefab9dd5eb5222f4701f9c5f218b7c" translate="yes" xml:space="preserve">
          <source>How can I determine if a string is a text string or a binary string?</source>
          <target state="translated">문자열이 텍스트 문자열인지 이진 문자열인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="218779f6e2b4819e8fa691d46344a18cc62cfb76" translate="yes" xml:space="preserve">
          <source>How can I do RPC in Perl?</source>
          <target state="translated">Perl에서 RPC를 어떻게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="67ea1bb995fcd1fc57c8e9b92a095f41d9b7834f" translate="yes" xml:space="preserve">
          <source>How can I do an atexit() or setjmp()/longjmp()? (Exception handling)</source>
          <target state="translated">atexit () 또는 setjmp () / longjmp ()를 어떻게 할 수 있습니까? (예외 처리)</target>
        </trans-unit>
        <trans-unit id="5af190bbb735548d1facf32f768401f6d294971f" translate="yes" xml:space="preserve">
          <source>How can I do approximate matching?</source>
          <target state="translated">근사 일치는 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="570f18a5d24dc2e398fe91082824106830a64146" translate="yes" xml:space="preserve">
          <source>How can I expand variables in text strings?</source>
          <target state="translated">텍스트 문자열에서 변수를 어떻게 확장 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="79199189d2f681d40463922bceb5338164a11bf3" translate="yes" xml:space="preserve">
          <source>How can I find out my current or calling package?</source>
          <target state="translated">현재 또는 통화중인 패키지를 어떻게 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2174489b130a993ef91515d9a1c4f01f1df7d31d" translate="yes" xml:space="preserve">
          <source>How can I find the Julian Day?</source>
          <target state="translated">줄리안 데이는 어떻게 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b9735d79cbde5c76c3fddd9a7f2ea2d91841d1f1" translate="yes" xml:space="preserve">
          <source>How can I free an array or hash so my program shrinks?</source>
          <target state="translated">프로그램이 축소되도록 배열 또는 해시를 해제하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a65a81dcfe85675764c8fa953a5501143a7a4d4c" translate="yes" xml:space="preserve">
          <source>How can I get #!perl to work on [MS-DOS,NT,...]?</source>
          <target state="translated">#! perl을 [MS-DOS, NT, ...]에서 어떻게 작동시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bf6b38eb1c743c27901f724e241bc103f6e22f1a" translate="yes" xml:space="preserve">
          <source>How can I get &lt;code&gt;#!perl&lt;/code&gt; to work on [MS-DOS,NT,...]?</source>
          <target state="translated">&lt;code&gt;#!perl&lt;/code&gt; 을 [MS-DOS, NT, ...]에서 어떻게 작동 시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="402e6fe7ce516fa4af09165ec04abd0ecfff56b0" translate="yes" xml:space="preserve">
          <source>How can I get a binary version of Perl?</source>
          <target state="translated">바이너리 버전의 Perl을 어떻게 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="70a068e99378aace39b694de85966e9dee8710b7" translate="yes" xml:space="preserve">
          <source>How can I get the modification time of a file on a remote FTP server ?</source>
          <target state="translated">원격 FTP 서버에있는 파일의 수정 시간을 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2da1a103ebf1acd1fb34a8083f53578de0506ba8" translate="yes" xml:space="preserve">
          <source>How can I get the size of a file on a remote FTP server ?</source>
          <target state="translated">원격 FTP 서버에있는 파일의 크기를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f01d20dc05214c47d4b244f669680dc5511e26c5" translate="yes" xml:space="preserve">
          <source>How can I get the unique keys from two hashes?</source>
          <target state="translated">두 개의 해시에서 고유 키를 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c41c416bf1bb0f25b4ae1ae9fd568032d02685fd" translate="yes" xml:space="preserve">
          <source>How can I hide the source for my Perl program?</source>
          <target state="translated">Perl 프로그램의 소스를 숨기려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="6c1e3d2428ca43719e62fc8b4685854b671a4efe" translate="yes" xml:space="preserve">
          <source>How can I hope to use regular expressions without creating illegible and unmaintainable code?</source>
          <target state="translated">읽을 수없고 유지 관리 할 수없는 코드를 만들지 않고 정규식을 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="b41e3d8caca6f525dc73482358563647f9033bf1" translate="yes" xml:space="preserve">
          <source>How can I know how many entries are in a hash?</source>
          <target state="translated">해시에 몇 개의 항목이 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="91090b21439190b378705149c5300b111d7f99b3" translate="yes" xml:space="preserve">
          <source>How can I lock a file?</source>
          <target state="translated">파일을 어떻게 잠글 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2b525e6fbe8d4f65916593a6d6f3bcc00b55e5ee" translate="yes" xml:space="preserve">
          <source>How can I make &lt;code&gt;\w&lt;/code&gt; match national character sets?</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 자국 문자 세트와 일치 시키 려면 어떻게 해야합니까?</target>
        </trans-unit>
        <trans-unit id="493e8171097525007801a396579dca3fc0ae7646" translate="yes" xml:space="preserve">
          <source>How can I make \w match national character sets?</source>
          <target state="translated">\ w를 자국 문자 세트와 일치 시키려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8efd8bb825816036c83b0bc4f4bc86a0e0087ba8" translate="yes" xml:space="preserve">
          <source>How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?</source>
          <target state="translated">서브 루틴에 파일 핸들을 로컬로 만들려면 어떻게해야합니까? 서브 루틴간에 파일 핸들을 어떻게 전달합니까? 파일 핸들 배열을 만들려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="225121f6ad8826944237905943573b1a1ad7146a" translate="yes" xml:space="preserve">
          <source>How can I make my CGI script more efficient?</source>
          <target state="translated">CGI 스크립트를보다 효율적으로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="aa449d7fc61d0c5f65c319dcdaf3c309d5a861d5" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program run faster?</source>
          <target state="translated">Perl 프로그램을 더 빨리 실행하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="da8314c9a027c83b1de3d8a02639e8b7fd488456" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program take less memory?</source>
          <target state="translated">Perl 프로그램의 메모리를 줄이려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="ab79906bd54ede65c9167982f83df39910ca41eb" translate="yes" xml:space="preserve">
          <source>How can I make my hash remember the order I put elements into it?</source>
          <target state="translated">요소를 넣은 순서를 해시로 기억 시키려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="eff3ee7a75a95b7dc6ebbcab6cdc87f62eaed0b6" translate="yes" xml:space="preserve">
          <source>How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?</source>
          <target state="translated">Perl을 C 구조 / C ++ 클래스 / 해시 또는 해시 또는 어레이 배열과 동등하게 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="313eaa4ceba4000008228fa89da4dfffac4883cb" translate="yes" xml:space="preserve">
          <source>How can I manipulate fixed-record-length files?</source>
          <target state="translated">고정 레코드 길이 파일을 어떻게 조작 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e9c4cf85e44267039f73e90a4005aa7e0fbde93f" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of /[a-zA-Z]/?</source>
          <target state="translated">로케일 스마트 버전의 / [a-zA-Z] /를 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a09d0b29b89d8c572780ffdaa75b2f1b8df250c7" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; ?</source>
          <target state="translated">로케일 스마트 버전의 &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 를 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="46f9f4e17442c3dcf3475bc074cd33f2cbbe23ef" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 의 로케일 스마트 버전을 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="acc211b194ec96e0a9f39c2fc3c9760c5684f182" translate="yes" xml:space="preserve">
          <source>How can I match strings with multibyte characters?</source>
          <target state="translated">멀티 바이트 문자로 문자열을 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="77dcf6b0c4c91ea96666741c5ba2af5b17f44eab" translate="yes" xml:space="preserve">
          <source>How can I measure time under a second?</source>
          <target state="translated">1 초 이내에 시간을 어떻게 측정 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fc57917cedb17fe47cbb1a1fb4694f4b806c4a38" translate="yes" xml:space="preserve">
          <source>How can I open a file named with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">선행 &quot;&amp;gt;&quot;또는 후행 공백이있는 파일을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3db0de0b51e68209069c4bcced248be111e64bf1" translate="yes" xml:space="preserve">
          <source>How can I open a file with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">선행 &quot;&amp;gt;&quot;또는 후행 공백이있는 파일을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2e27cd7875437a1d5b58c674aa20e1a1f445ed2f" translate="yes" xml:space="preserve">
          <source>How can I open a filehandle to a string?</source>
          <target state="translated">문자열로 파일 핸들을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="66bdbd7c5e5fc4cc3882f787c23fdf9783890787" translate="yes" xml:space="preserve">
          <source>How can I open a pipe both to and from a command?</source>
          <target state="translated">명령과 파이프를 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="01291b9947177ee6a9867efb46ea11fb8dc4a814" translate="yes" xml:space="preserve">
          <source>How can I organize tests into subdirectories and have them run?</source>
          <target state="translated">테스트를 하위 디렉터리로 구성하고 실행하도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="cc95647ff06623df9f3fe7b151e5174f6d8d433a" translate="yes" xml:space="preserve">
          <source>How can I output Roman numerals?</source>
          <target state="translated">로마 숫자를 어떻게 출력 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e415a2ec1d5bacc294697e39127dad698ce08519" translate="yes" xml:space="preserve">
          <source>How can I output my numbers with commas added?</source>
          <target state="translated">쉼표를 추가하여 숫자를 어떻게 출력 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="71d9df292afc1f28ab8d43537f9b2fc5e1d5e39d" translate="yes" xml:space="preserve">
          <source>How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?</source>
          <target state="translated">{함수, FileHandle, 배열, 해시, 메소드, 정규식}을 전달 / 반환하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="607da88807131fb0d75ed3b744e20b136c3c6945" translate="yes" xml:space="preserve">
          <source>How can I prevent addition of unwanted keys into a hash?</source>
          <target state="translated">원치 않는 키가 해시에 추가되지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="132c95be002620b77b84199839203d3bbecd265f" translate="yes" xml:space="preserve">
          <source>How can I print out a word-frequency or line-frequency summary?</source>
          <target state="translated">단어 빈도 또는 라인 빈도 요약을 인쇄하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="9b8afbc5c9adfffb10eaf9f9e73e6a5dd9a33727" translate="yes" xml:space="preserve">
          <source>How can I pull out lines between two patterns that are themselves on different lines?</source>
          <target state="translated">서로 다른 선에있는 두 패턴 사이의 선을 어떻게 뽑을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="aa09f1e8ecf9751a8e601635407b1b85b484a991" translate="yes" xml:space="preserve">
          <source>How can I quote a variable to use in a regex?</source>
          <target state="translated">정규식에서 사용할 변수를 어떻게 인용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5048ee292d54dc738c8b2e4a4e9d40ed88661804" translate="yes" xml:space="preserve">
          <source>How can I read a single character from a file? From the keyboard?</source>
          <target state="translated">파일에서 단일 문자를 읽으려면 어떻게해야합니까? 키보드에서?</target>
        </trans-unit>
        <trans-unit id="bd4bea532194d27e8f4c0167b3ea139fc3e738e8" translate="yes" xml:space="preserve">
          <source>How can I read in a file by paragraphs?</source>
          <target state="translated">단락별로 파일을 어떻게 읽을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d86b23e0a7033694a41285ad01891788240ba487" translate="yes" xml:space="preserve">
          <source>How can I read in an entire file all at once?</source>
          <target state="translated">전체 파일을 한 번에 읽을 수있는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="be068faf9cf22c97ef84fb173f7722fe689af084" translate="yes" xml:space="preserve">
          <source>How can I recognise a UTF-8 string?</source>
          <target state="translated">UTF-8 문자열을 어떻게 인식합니까?</target>
        </trans-unit>
        <trans-unit id="28052c84845f30a6d5db733cf8047009c5a791db" translate="yes" xml:space="preserve">
          <source>How can I reliably rename a file?</source>
          <target state="translated">파일 이름을 안정적으로 바꾸려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8a768c48e2e0b2fc34f88cb4e753c4bb5f8f926e" translate="yes" xml:space="preserve">
          <source>How can I remove duplicate elements from a list or array?</source>
          <target state="translated">목록이나 배열에서 중복 요소를 제거하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="daff1cd30b2b776eb20a1e8ba332328966a941c8" translate="yes" xml:space="preserve">
          <source>How can I set up a footer format to be used with write()?</source>
          <target state="translated">write ()와 함께 사용할 바닥 글 형식을 설정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="e1d8eb9609efe77a17044341626f5d092fb4352d" translate="yes" xml:space="preserve">
          <source>How can I sleep() or alarm() for under a second?</source>
          <target state="translated">잠깐 동안 잠을 자려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2e588f9010bcd10392f7edf040ae56a945189e99" translate="yes" xml:space="preserve">
          <source>How can I split a [character]-delimited string except when inside [character]?</source>
          <target state="translated">[문자] 내부를 제외하고 [문자]로 구분 된 문자열을 어떻게 분할 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="043a45581bbf861e01b6d8df458229f88cd7fe73" translate="yes" xml:space="preserve">
          <source>How can I store a multidimensional array in a DBM file?</source>
          <target state="translated">다차원 배열을 DBM 파일에 저장하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="3e3f15708830cd90fcc2e8ed11e6fc04c0345d66" translate="yes" xml:space="preserve">
          <source>How can I take a string and turn it into epoch seconds?</source>
          <target state="translated">현을 가져 와서 에포크 초로 바꾸려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="279887cb82cd1ebda6c6c1a0b09fc6f0014cb878" translate="yes" xml:space="preserve">
          <source>How can I tell if a variable is tainted?</source>
          <target state="translated">변수가 오염되었는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="58516c6da782669b8d9c7cfc7d02262b3e4bb1bb" translate="yes" xml:space="preserve">
          <source>How can I tell whether a certain element is contained in a list or array?</source>
          <target state="translated">특정 요소가 목록 또는 배열에 포함되어 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a5d5b57593f0038532f9a469856b028182200632" translate="yes" xml:space="preserve">
          <source>How can I tell whether my encoding fully supports PerlIO ?</source>
          <target state="translated">내 인코딩이 PerlIO를 완전히 지원하는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="81aaf6c4723167313d15ab1c5f7e5b530f8557ce" translate="yes" xml:space="preserve">
          <source>How can I tell whether there's a character waiting on a filehandle?</source>
          <target state="translated">파일 핸들을 기다리는 캐릭터가 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b2fcf8739ca319f39af63e3ce5170d91f44f77f2" translate="yes" xml:space="preserve">
          <source>How can I translate tildes (~) in a filename?</source>
          <target state="translated">파일 이름에서 물결표 (~)를 어떻게 번역 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="881f014c19a83fce123198524d0af95f5abeddf7" translate="yes" xml:space="preserve">
          <source>How can I use Perl interactively?</source>
          <target state="translated">Perl을 대화식으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4822820e0cebd48f928eec2f020bfeb1c6c58fcc" translate="yes" xml:space="preserve">
          <source>How can I use Perl's -i option from within a program?</source>
          <target state="translated">프로그램 내에서 Perl의 -i 옵션을 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b59721a4c76a7fca29f80e903b0f2dded9b41579" translate="yes" xml:space="preserve">
          <source>How can I use Perl's &lt;code&gt;-i&lt;/code&gt; option from within a program?</source>
          <target state="translated">프로그램 내에서 Perl의 &lt;code&gt;-i&lt;/code&gt; 옵션을 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a0b830d488369e5b57f08961ae54b6541e391fcb" translate="yes" xml:space="preserve">
          <source>How can I use a filehandle indirectly?</source>
          <target state="translated">파일 핸들을 간접적으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2954afefc188233ca0982e40813f35aedafa9c02" translate="yes" xml:space="preserve">
          <source>How can I use a reference as a hash key?</source>
          <target state="translated">참조를 해시 키로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="1cd3f90234d9f2d28d7f7859571cd8142dbcb6f4" translate="yes" xml:space="preserve">
          <source>How can I use a variable as a variable name?</source>
          <target state="translated">변수를 변수 이름으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0c905d4e5eee64ffc80c2808116d673741258304" translate="yes" xml:space="preserve">
          <source>How can I use curses with Perl?</source>
          <target state="translated">Perl에서 저주를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="50c6bbc4fb82176bf9d1327a643a764fb7e991f8" translate="yes" xml:space="preserve">
          <source>How can I write a GUI (X, Tk, Gtk, etc.) in Perl?</source>
          <target state="translated">Perl에서 GUI (X, Tk, Gtk 등)를 작성하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="81e8482ca19f1c03f3246a06ec608fbebf4e5f7c" translate="yes" xml:space="preserve">
          <source>How can I write expect in Perl?</source>
          <target state="translated">Perl에서 어떻게 expect를 쓸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1ed0197c720cb0aff97775cc40d6071cc2ec1d85" translate="yes" xml:space="preserve">
          <source>How can I write() into a string?</source>
          <target state="translated">문자열에 어떻게 write () 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ebe948a96ce8ed3fcef25d460b5826d6e46a03f1" translate="yes" xml:space="preserve">
          <source>How can you figure out what to add? Assuming your Perl is post-5.001, execute a &lt;code&gt;perl -V&lt;/code&gt; command and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot; information.</source>
          <target state="translated">추가 할 내용을 어떻게 알 수 있습니까? Perl이 5.001 이후라고 가정하면 &lt;code&gt;perl -V&lt;/code&gt; 명령을 실행 하고 &quot;cc&quot;및 &quot;ccflags&quot;정보에 특별한주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="7839a80cf8d473225aea7a22d12034d28e88fd87" translate="yes" xml:space="preserve">
          <source>How can you tell the difference between a non-zero status that is the result of a VMS native error status or an encoded Unix status? You can not unless you look at the ${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value and check the severity bits. If the severity bits are equal to 1, then if the numeric value for &lt;code&gt;$?&lt;/code&gt; is between 2 and 255 or 0, then &lt;code&gt;$?&lt;/code&gt; accurately reflects a value passed back from a Unix application. If &lt;code&gt;$?&lt;/code&gt; is 1, and the severity bits indicate a VMS error (2), then &lt;code&gt;$?&lt;/code&gt; is from a Unix application exit value.</source>
          <target state="translated">VMS 기본 오류 상태 또는 인코딩 된 Unix 상태의 결과 인 0이 아닌 상태의 차이점을 어떻게 알 수 있습니까? $ {^ CHILD_ERROR_NATIVE} 값을 보지 않으면 안됩니다. $ {^ CHILD_ERROR_NATIVE} 값은 실제 VMS 상태 값을 반환하고 심각도 비트를 확인합니다. 심각도 비트가 1과 같으면 &lt;code&gt;$?&lt;/code&gt; 2에서 255 또는 0 사이이고 &lt;code&gt;$?&lt;/code&gt; Unix 응용 프로그램에서 전달 된 값을 정확하게 반영합니다. 만약 &lt;code&gt;$?&lt;/code&gt; 1이고 심각도 비트는 VMS 오류 (2)를 나타내고 &lt;code&gt;$?&lt;/code&gt; Unix 응용 프로그램 종료 값에서옵니다.</target>
        </trans-unit>
        <trans-unit id="10e8b70e261dbd1684433d0e38a377a1e6c6f1bf" translate="yes" xml:space="preserve">
          <source>How come exec() doesn't return?</source>
          <target state="translated">exec ()가 어떻게 반환되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="642d4ca1dadf5e67b2382dbc957dee2d26101ca3" translate="yes" xml:space="preserve">
          <source>How come when I open a file read-write it wipes it out?</source>
          <target state="translated">파일을 읽고 쓸 때 어떻게 지워지나요?</target>
        </trans-unit>
        <trans-unit id="120ce3c4d0d569cc353775c742050f216df78c10" translate="yes" xml:space="preserve">
          <source>How come? Because once upon a time, the argument to push() had to be a real array, not just a reference to one. That's no longer true. In fact, the line marked &quot;implicit deref&quot; above works just fine--in this instance--to do what the one that says explicit deref did.</source>
          <target state="translated">어떻게 오세요? 옛날 옛적에 push ()에 대한 인수는 단지 하나의 참조가 아니라 실제 배열이어야했기 때문입니다. 더 이상 사실이 아닙니다. 사실, 위의 &quot;암시 적 역 참조&quot;라고 표시된 줄은 명시 적 역 참조라고하는 것을 수행하기 위해 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1a8c1eab260cee26d9dd30d8d1f6ad51a65f4aa2" translate="yes" xml:space="preserve">
          <source>How deeply nested the event is.</source>
          <target state="translated">이벤트의 중첩 정도입니다.</target>
        </trans-unit>
        <trans-unit id="2e345122aff9e67ed09307eafafa850438366608" translate="yes" xml:space="preserve">
          <source>How deeply nested the hub was.</source>
          <target state="translated">허브가 얼마나 깊이 중첩되었는지.</target>
        </trans-unit>
        <trans-unit id="c4a52c2fce0f47a3f02d91b4d141841b4a0759aa" translate="yes" xml:space="preserve">
          <source>How do I access .tar.Z files?</source>
          <target state="translated">.tar.Z 파일에 어떻게 액세스합니까?</target>
        </trans-unit>
        <trans-unit id="35cd8e41b71c05362e2e05b8fea674b5b9428071" translate="yes" xml:space="preserve">
          <source>How do I add a directory to my include path (@INC) at runtime?</source>
          <target state="translated">런타임에 포함 경로 (@INC)에 디렉토리를 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="a8c4b858302cc359dbd26e7a94330185357e2027" translate="yes" xml:space="preserve">
          <source>How do I add the directory my program lives in to the module/library search path?</source>
          <target state="translated">프로그램이있는 디렉토리를 모듈 / 라이브러리 검색 경로에 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="3767a07fd4ca1c10dc3a53f806060f350ef02ac9" translate="yes" xml:space="preserve">
          <source>How do I adopt or take over a module already on CPAN?</source>
          <target state="translated">CPAN에서 이미 모듈을 채택하거나 인계하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2b820f99468b1968d2885fc455211ce9aab00b68" translate="yes" xml:space="preserve">
          <source>How do I ask the user for a password?</source>
          <target state="translated">사용자에게 비밀번호를 요청하는 방법</target>
        </trans-unit>
        <trans-unit id="203a77501794721d243b497cab58f25f10122bf4" translate="yes" xml:space="preserve">
          <source>How do I automate an HTML form submission?</source>
          <target state="translated">HTML 양식 제출을 자동화하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="b9487e21fcb84b27b564a1a52da3c445074087f9" translate="yes" xml:space="preserve">
          <source>How do I avoid zombies on a Unix system?</source>
          <target state="translated">유닉스 시스템에서 좀비를 피하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="f3a92921961d16b06b6e90c94b5e844a5163c8ba" translate="yes" xml:space="preserve">
          <source>How do I capitalize all the words on one line?</source>
          <target state="translated">한 줄에 모든 단어를 대문자로 쓰려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="4bb5fa72780a70fbcd38ea05720abb4024270f79" translate="yes" xml:space="preserve">
          <source>How do I change the Nth occurrence of something?</source>
          <target state="translated">N 번째 항목을 어떻게 변경합니까?</target>
        </trans-unit>
        <trans-unit id="bbe71d73de3e4f641a5e48b9cabe7daee1df1bb9" translate="yes" xml:space="preserve">
          <source>How do I change, delete, or insert a line in a file, or append to the beginning of a file?</source>
          <target state="translated">파일에서 행을 변경, 삭제 또는 삽입하거나 파일의 시작 부분에 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="26ebac281176cc167fc28682837fc8035f2df7f9" translate="yes" xml:space="preserve">
          <source>How do I check a valid mail address?</source>
          <target state="translated">유효한 메일 주소는 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="a6d4bc02f449734d8d38a8c79be0738d1807657b" translate="yes" xml:space="preserve">
          <source>How do I check whether input is ready on the keyboard?</source>
          <target state="translated">키보드에서 입력이 준비되었는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="e9d5289c1b2381a4bfc799f6d79379a45148a056" translate="yes" xml:space="preserve">
          <source>How do I clear a package?</source>
          <target state="translated">패키지를 지우려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="da64d3ab23e8dfda8ada8eca869e3e4304053e10" translate="yes" xml:space="preserve">
          <source>How do I clear the screen?</source>
          <target state="translated">화면을 지우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="dc7b6aff1b04d81838ccfc000e127a9b49e09b59" translate="yes" xml:space="preserve">
          <source>How do I close a file descriptor by number?</source>
          <target state="translated">번호로 파일 디스크립터를 닫으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2102c2d58d3c697659db6f147f9c7750ead5e836" translate="yes" xml:space="preserve">
          <source>How do I close a process's filehandle without waiting for it to complete?</source>
          <target state="translated">프로세스가 완료되기를 기다리지 않고 프로세스의 파일 핸들을 닫으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="82c4851509fc2188559dfc3bbd26e54406e86a76" translate="yes" xml:space="preserve">
          <source>How do I compare strings?</source>
          <target state="translated">문자열을 어떻게 비교합니까?</target>
        </trans-unit>
        <trans-unit id="a5014833338499c76ba684cef2ad05a8939c7509" translate="yes" xml:space="preserve">
          <source>How do I compute the difference of two arrays? How do I compute the intersection of two arrays?</source>
          <target state="translated">두 배열의 차이를 어떻게 계산합니까? 두 배열의 교집합을 어떻게 계산합니까?</target>
        </trans-unit>
        <trans-unit id="28baf17ec2f9a6ff5d6d17753e8bf70e57ef541a" translate="yes" xml:space="preserve">
          <source>How do I convert a string to UTF-8?</source>
          <target state="translated">문자열을 UTF-8로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="a1ff2698b449bb489c981be9b3dd682dc2dd11e3" translate="yes" xml:space="preserve">
          <source>How do I convert between numeric representations/bases/radixes?</source>
          <target state="translated">숫자 표현 /베이스 / 기수를 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="0506850f7d31bd4782eb7c2ff13183ae7d6e27bb" translate="yes" xml:space="preserve">
          <source>How do I convert from binary to decimal</source>
          <target state="translated">이진수에서 십진수로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="6763571be4b24365fdbf47562a891c2c2a4061df" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to binary</source>
          <target state="translated">십진수에서 이진수로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="135991f8dae083c523ec58906bfcb69cccb0578d" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to hexadecimal</source>
          <target state="translated">10 진수에서 16 진수로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="36fe51b125b1634217406cabccf1c4ca07f98c99" translate="yes" xml:space="preserve">
          <source>How do I convert from decimal to octal</source>
          <target state="translated">10 진수에서 8 진수로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="0e154b3973b3e38c40dce2887c701eeb759ba7d9" translate="yes" xml:space="preserve">
          <source>How do I convert from encoding FOO to encoding BAR?</source>
          <target state="translated">인코딩 FOO에서 인코딩 BAR로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="4b920c4f62d053fb6ad8f68f4bc740e16585148f" translate="yes" xml:space="preserve">
          <source>How do I convert from octal to decimal</source>
          <target state="translated">8 진수에서 10 진수로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="8274dd7834392a793f979a76735c021fd05ed705" translate="yes" xml:space="preserve">
          <source>How do I convert hexadecimal into decimal</source>
          <target state="translated">16 진수를 10 진수로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="f9aa83752cb5484c41a1a794b8c3e92b85b90232" translate="yes" xml:space="preserve">
          <source>How do I copy an entire directory?</source>
          <target state="translated">전체 디렉토리를 어떻게 복사합니까?</target>
        </trans-unit>
        <trans-unit id="878e0980aa72aa1b56f3382c08eb0ae977818037" translate="yes" xml:space="preserve">
          <source>How do I count the number of lines in a file?</source>
          <target state="translated">파일의 줄 수는 어떻게 계산합니까?</target>
        </trans-unit>
        <trans-unit id="86a1974c296e30057e2194a7ef2242b7c1cfd98c" translate="yes" xml:space="preserve">
          <source>How do I create a Module::Build based Build.PL derived from an ExtUtils::MakeMaker focused Makefile.PL?</source>
          <target state="translated">ExtUtils :: MakeMaker 중심의 Makefile.PL에서 파생 된 Module :: Build 기반 Build.PL을 어떻게 작성합니까?</target>
        </trans-unit>
        <trans-unit id="aa6bdbe546fadef34a6ec8c386dc99a9b330832e" translate="yes" xml:space="preserve">
          <source>How do I create a class?</source>
          <target state="translated">수업은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="4d74113d708c10f061b26ff7fcdab35341dbf82e" translate="yes" xml:space="preserve">
          <source>How do I create a module?</source>
          <target state="translated">모듈은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="236c38bf7065e57bd631c8a83a8f5bfc130478e7" translate="yes" xml:space="preserve">
          <source>How do I create a static variable?</source>
          <target state="translated">정적 변수는 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="b74b37fe4636da83763c3e9df557c6184ae8c0f0" translate="yes" xml:space="preserve">
          <source>How do I create a switch or case statement?</source>
          <target state="translated">switch 또는 case 문을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="87e0957c61f867da042ce74af89ed18af7f653b6" translate="yes" xml:space="preserve">
          <source>How do I cross-reference my Perl programs?</source>
          <target state="translated">Perl 프로그램을 상호 참조하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="70f54b8026aba3fe0b07c960855d5b7aab7bb809" translate="yes" xml:space="preserve">
          <source>How do I debug my Perl programs?</source>
          <target state="translated">Perl 프로그램을 어떻게 디버깅합니까?</target>
        </trans-unit>
        <trans-unit id="97378d9d3fe8991aaac89412355467232d0a4c27" translate="yes" xml:space="preserve">
          <source>How do I declare/create a structure?</source>
          <target state="translated">구조를 선언 / 만드는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2f51e7bb07a2328659ee4f97c52bb6f158f54842" translate="yes" xml:space="preserve">
          <source>How do I decode a MIME/BASE64 string?</source>
          <target state="translated">MIME / BASE64 문자열을 어떻게 디코딩합니까?</target>
        </trans-unit>
        <trans-unit id="2cd19e271c87d62d106f8fec30b522eacf831c74" translate="yes" xml:space="preserve">
          <source>How do I decode encrypted password files?</source>
          <target state="translated">암호화 된 비밀번호 파일을 어떻게 디코딩합니까?</target>
        </trans-unit>
        <trans-unit id="23d494744b67cf68faa6ba521e0dbfb0f945c204" translate="yes" xml:space="preserve">
          <source>How do I decode or create those %-encodings on the web?</source>
          <target state="translated">웹에서 이러한 % 인코딩을 어떻게 디코딩하거나 생성합니까?</target>
        </trans-unit>
        <trans-unit id="ee2564195c16e10af1a2a54e803a2d5eaa4bba4a" translate="yes" xml:space="preserve">
          <source>How do I define methods for every class/object?</source>
          <target state="translated">모든 클래스 / 객체에 대한 메소드를 어떻게 정의합니까?</target>
        </trans-unit>
        <trans-unit id="65a1e2e0843b152e3e957dda320e2bd68a2d232e" translate="yes" xml:space="preserve">
          <source>How do I delete a directory tree?</source>
          <target state="translated">디렉토리 트리를 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="39ddaeab66eebefd8e49abf20a3ac9b4d117bd4d" translate="yes" xml:space="preserve">
          <source>How do I delete everything not in my</source>
          <target state="translated">내 계정에없는 모든 항목을 삭제하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="c6598461e8184a71f0045d1091c9275b621efb6c" translate="yes" xml:space="preserve">
          <source>How do I delete the last N lines from a file?</source>
          <target state="translated">파일에서 마지막 N 줄을 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="82c2c49b1820b2e4b306f272a2091aeedd8bf680" translate="yes" xml:space="preserve">
          <source>How do I determine whether a scalar is a number/whole/integer/float?</source>
          <target state="translated">스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f65b76741f09d6f8756a10de0d88399c941d8dbe" translate="yes" xml:space="preserve">
          <source>How do I do (anything)?</source>
          <target state="translated">어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="5a3899f947a018efe1a69e369cf5894457670072" translate="yes" xml:space="preserve">
          <source>How do I do a &lt;code&gt;tail -f&lt;/code&gt; in perl?</source>
          <target state="translated">Perl에서 &lt;code&gt;tail -f&lt;/code&gt; 를 어떻게 수행 합니까?</target>
        </trans-unit>
        <trans-unit id="08d06a078c58ebbf0c5a4ee81c3c6214665f0e66" translate="yes" xml:space="preserve">
          <source>How do I do a tail -f in perl?</source>
          <target state="translated">Perl에서 tail -f를 어떻게 수행합니까?</target>
        </trans-unit>
        <trans-unit id="8a1d6beddae75cca1e0c47c227a5ded3e3a37f2c" translate="yes" xml:space="preserve">
          <source>How do I do fancy stuff with the keyboard/screen/mouse?</source>
          <target state="translated">키보드 / 스크린 / 마우스로 어떻게 멋진 일을합니까?</target>
        </trans-unit>
        <trans-unit id="4adc2a7ad5bba352a704cf7278066f75dfdb1320" translate="yes" xml:space="preserve">
          <source>How do I download files from an FTP server ?</source>
          <target state="translated">FTP 서버에서 파일을 다운로드하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="beaabf13bf44c3d2a6f003d0da1ad9d016f78129" translate="yes" xml:space="preserve">
          <source>How do I dup() a filehandle in Perl?</source>
          <target state="translated">Perl에서 파일 핸들을 어떻게 dup ()합니까?</target>
        </trans-unit>
        <trans-unit id="c99c99752028698e07bd697c4f55f10aeb2574b2" translate="yes" xml:space="preserve">
          <source>How do I efficiently match many regular expressions at once?</source>
          <target state="translated">한 번에 여러 정규식을 효율적으로 일치시키는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d8501dfb7a286a0bc3e79d726ff0aa33a83b4611" translate="yes" xml:space="preserve">
          <source>How do I expand function calls in a string?</source>
          <target state="translated">문자열에서 함수 호출을 어떻게 확장합니까?</target>
        </trans-unit>
        <trans-unit id="40ad9f6ac9837b05501210a465bcfa76304dce6b" translate="yes" xml:space="preserve">
          <source>How do I expand tabs in a string?</source>
          <target state="translated">문자열에서 탭을 어떻게 확장합니까?</target>
        </trans-unit>
        <trans-unit id="1794d4b7480b0f45fea6bded5c811dbf977507ba" translate="yes" xml:space="preserve">
          <source>How do I extract URLs?</source>
          <target state="translated">URL은 어떻게 추출합니까?</target>
        </trans-unit>
        <trans-unit id="e7089a10dfdd460d912e93d4c4488293420a3931" translate="yes" xml:space="preserve">
          <source>How do I extract only files that have property X from an archive?</source>
          <target state="translated">아카이브에서 속성 X가있는 파일 만 추출하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="4490e28bfd20b3131d4a6a9a43d5708c9217af3c" translate="yes" xml:space="preserve">
          <source>How do I extract selected columns from a string?</source>
          <target state="translated">문자열에서 선택한 열을 어떻게 추출합니까?</target>
        </trans-unit>
        <trans-unit id="5e9ce3143a0232dce445afb94a4cd2cbabc5866a" translate="yes" xml:space="preserve">
          <source>How do I fetch an HTML file?</source>
          <target state="translated">HTML 파일을 가져 오려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="5874d66493051782bd5b330106175c43ebb7b6dd" translate="yes" xml:space="preserve">
          <source>How do I fetch/put an (S)FTP file?</source>
          <target state="translated">(S) FTP 파일을 어떻게 가져 오거나 넣습니까?</target>
        </trans-unit>
        <trans-unit id="930fdbc050be8c4df7c4e53dd8aa59f284368264" translate="yes" xml:space="preserve">
          <source>How do I find matching/nesting anything?</source>
          <target state="translated">일치하는 항목을 찾는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bc8fb538829e6c584fa0187f483d1bbaba9e7351" translate="yes" xml:space="preserve">
          <source>How do I find out if I'm running interactively or not?</source>
          <target state="translated">대화식으로 실행 중인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="67eefe0342c38d62f056273caef773f2b1d22382" translate="yes" xml:space="preserve">
          <source>How do I find out my hostname, domainname, or IP address?</source>
          <target state="translated">호스트 이름, 도메인 이름 또는 IP 주소를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b35cce5c620df3c5213a5b63c9524655cbb9d4b9" translate="yes" xml:space="preserve">
          <source>How do I find out which operating system I'm running under?</source>
          <target state="translated">어떤 운영 체제를 실행하고 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="01907eb2e6a268c88ab9c2c3bfb59105a7c7e3c4" translate="yes" xml:space="preserve">
          <source>How do I find the current century or millennium?</source>
          <target state="translated">현재 세기 나 밀레니엄은 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="3463510f64a1c5a49fcc37902eead9f9ac95605b" translate="yes" xml:space="preserve">
          <source>How do I find the day or week of the year?</source>
          <target state="translated">일 또는 주를 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="982d40212fc998a0686d78df9c4ba26898354f0e" translate="yes" xml:space="preserve">
          <source>How do I find the first array element for which a condition is true?</source>
          <target state="translated">조건이 참인 첫 번째 배열 요소를 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="74e25e9ffe5b922252ebf9163105b704200cdbaf" translate="yes" xml:space="preserve">
          <source>How do I find the soundex value of a string?</source>
          <target state="translated">문자열의 soundex 값을 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="d5fb344779130b34177124faae9f510c7450c0be" translate="yes" xml:space="preserve">
          <source>How do I find the user's mail address?</source>
          <target state="translated">사용자의 메일 주소는 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="9b5f48590c3589b927773b9f4489ef3e2df19ab7" translate="yes" xml:space="preserve">
          <source>How do I find which modules are installed on my system?</source>
          <target state="translated">시스템에 어떤 모듈이 설치되어 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="db22bcad0e65ee82eb15cee813db7ad1bc862f74" translate="yes" xml:space="preserve">
          <source>How do I find yesterday's date?</source>
          <target state="translated">어제 날짜는 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="f14d19d9f33ebecf97e59acd91f7a3e35d168a35" translate="yes" xml:space="preserve">
          <source>How do I flush/unbuffer an output filehandle? Why must I do this?</source>
          <target state="translated">출력 파일 핸들을 플러시 / 버퍼 해제하려면 어떻게해야합니까? 왜 이렇게해야합니까?</target>
        </trans-unit>
        <trans-unit id="50ced00e1da5731e9f081395bef33daf71015cca" translate="yes" xml:space="preserve">
          <source>How do I fork a daemon process?</source>
          <target state="translated">데몬 프로세스를 어떻게 포크합니까?</target>
        </trans-unit>
        <trans-unit id="b5197890f13966fd4c7d88cf82096a37fc11915e" translate="yes" xml:space="preserve">
          <source>How do I get MakeMaker and Module::Build to install to the same place?</source>
          <target state="translated">MakeMaker와 Module :: Build를 동일한 위치에 설치하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="fb4fad4fa61c86e768baf3c503d80347718f36c7" translate="yes" xml:space="preserve">
          <source>How do I get a directory listing from an FTP server ?</source>
          <target state="translated">FTP 서버에서 디렉토리 목록을 얻으려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="af1e555b8ad44f5ee09984b301d45f763b3ab693" translate="yes" xml:space="preserve">
          <source>How do I get a file's timestamp in perl?</source>
          <target state="translated">펄에서 파일의 타임 스탬프를 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="f416b305fcb8113d5bc19886df8b83bac5c89fb3" translate="yes" xml:space="preserve">
          <source>How do I get a random number between X and Y?</source>
          <target state="translated">X와 Y 사이의 난수를 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="0f092c3cc9246e7de03f0d8e8c730fbe8df49215" translate="yes" xml:space="preserve">
          <source>How do I get the screen size?</source>
          <target state="translated">화면 크기는 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="d2945107e7da57555f0937b6495cd275527b10d0" translate="yes" xml:space="preserve">
          <source>How do I handle Unicode strings?</source>
          <target state="translated">유니 코드 문자열은 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="c3313630d3f982060a390f5f1946717a57153c40" translate="yes" xml:space="preserve">
          <source>How do I handle binary data correctly?</source>
          <target state="translated">이진 데이터를 올바르게 처리하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="3d9eeab5302abcd051b9c7c58a10262f71b93d0d" translate="yes" xml:space="preserve">
          <source>How do I handle circular lists?</source>
          <target state="translated">순환 목록을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="25bc3d27f1f1d3400779cec866f02e11e267bcde" translate="yes" xml:space="preserve">
          <source>How do I handle linked lists?</source>
          <target state="translated">링크 된 목록을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="22ab3c17d49644f7643e768f33f866efb0521ae5" translate="yes" xml:space="preserve">
          <source>How do I install a &quot;DEVELOPER RELEASE&quot; of a module?</source>
          <target state="translated">모듈의 &quot;DEVELOPER RELEASE&quot;를 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="51ca5bd4b613176b7121cb512580f3d074cc9e12" translate="yes" xml:space="preserve">
          <source>How do I install a module and all its dependencies from the commandline, without being prompted for anything, despite my CPAN configuration (or lack thereof)?</source>
          <target state="translated">CPAN 구성 (또는 부족)에도 불구하고 아무 프롬프트없이 모듈과 모듈의 모든 종속성을 명령 줄에서 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="332f266fa06f1a0ab802b1da5c10c6890675f4de" translate="yes" xml:space="preserve">
          <source>How do I install a module from CPAN?</source>
          <target state="translated">CPAN에서 모듈을 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="125fb980d7aaa7ca2242befa5648bc32166dc7e6" translate="yes" xml:space="preserve">
          <source>How do I install a module into my home directory?</source>
          <target state="translated">내 홈 디렉토리에 모듈을 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="d861f5b4b26ce38782c487c2b8f360184457002f" translate="yes" xml:space="preserve">
          <source>How do I keep from installing man pages?</source>
          <target state="translated">매뉴얼 페이지를 설치하지 않으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="63d92a5148bd9660c144884977d59745697a0930" translate="yes" xml:space="preserve">
          <source>How do I keep my $VERSION up to date without resetting it manually?</source>
          <target state="translated">$ VERSION을 수동으로 재설정하지 않고 최신 상태로 유지하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="779b60119e9ac89f1b4bb8ccca7aa17790f78529" translate="yes" xml:space="preserve">
          <source>How do I keep my own module/library directory?</source>
          <target state="translated">자체 모듈 / 라이브러리 디렉토리를 유지하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="712ff90db628f146b683448ab9a743ea57d1a8f1" translate="yes" xml:space="preserve">
          <source>How do I keep persistent data across program calls?</source>
          <target state="translated">프로그램 호출에서 지속적인 데이터를 유지하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="a20b09e11bad429f8e02c602624e45b441c22369" translate="yes" xml:space="preserve">
          <source>How do I look up a hash element by value?</source>
          <target state="translated">값으로 해시 요소를 어떻게 조회합니까?</target>
        </trans-unit>
        <trans-unit id="fc81f211ace7f04a35490b5be3fe4452ee1626e9" translate="yes" xml:space="preserve">
          <source>How do I make a system() exit on control-C?</source>
          <target state="translated">control-C에서 system ()을 어떻게 종료합니까?</target>
        </trans-unit>
        <trans-unit id="58c641789837b76dd9abee18041837a328da4bf8" translate="yes" xml:space="preserve">
          <source>How do I make a temporary file name?</source>
          <target state="translated">임시 파일 이름은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="f0fab6b039e898671e7205067775272f3896476e" translate="yes" xml:space="preserve">
          <source>How do I make sure users can't enter values into a form that causes my CGI script to do bad things?</source>
          <target state="translated">사용자가 CGI 스크립트가 나쁜 일을하게하는 양식에 값을 입력 할 수 없도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="717678bc544dca5a8699132ee02462800aee62d3" translate="yes" xml:space="preserve">
          <source>How do I make two or more XS files coexist in the same directory?</source>
          <target state="translated">두 개 이상의 XS 파일이 같은 디렉토리에 공존하도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="9e83c97b2d0052618a071494ce58ad0aa5de46bd" translate="yes" xml:space="preserve">
          <source>How do I manipulate arrays of bits?</source>
          <target state="translated">비트 배열을 어떻게 조작합니까?</target>
        </trans-unit>
        <trans-unit id="f91d0deef997d3bfa3ece796fb840e0045a0792b" translate="yes" xml:space="preserve">
          <source>How do I match XML, HTML, or other nasty, ugly things with a regex?</source>
          <target state="translated">XML, HTML 또는 다른 불쾌한 추악한 것들을 정규식과 어떻게 일치 시키는가?</target>
        </trans-unit>
        <trans-unit id="9e10d6b9fcc0dce9241e02f9e3f41bcdabf8cf6b" translate="yes" xml:space="preserve">
          <source>How do I match a regular expression that's in a variable?</source>
          <target state="translated">변수에있는 정규식과 어떻게 일치합니까?</target>
        </trans-unit>
        <trans-unit id="5d4e304caa9da74ae39c7e0f1bc8a660a934e36b" translate="yes" xml:space="preserve">
          <source>How do I merge two hashes?</source>
          <target state="translated">두 개의 해시를 어떻게 병합합니까?</target>
        </trans-unit>
        <trans-unit id="e98a867a19e12d012764c76bf6e04f0613af63d6" translate="yes" xml:space="preserve">
          <source>How do I modify the shadow password file on a Unix system?</source>
          <target state="translated">유닉스 시스템에서 섀도 패스워드 파일을 어떻게 수정합니까?</target>
        </trans-unit>
        <trans-unit id="c7095e8729e8a7f2287429c858bc0e6162426248" translate="yes" xml:space="preserve">
          <source>How do I multiply matrices?</source>
          <target state="translated">행렬을 어떻게 곱합니까?</target>
        </trans-unit>
        <trans-unit id="9460689c66cd7c2602f152fc7b62b5a75f54acdd" translate="yes" xml:space="preserve">
          <source>How do I open a file without blocking?</source>
          <target state="translated">차단하지 않고 파일을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9724c57d7e62b1229f27e461cfe00d869c775e7e" translate="yes" xml:space="preserve">
          <source>How do I pack arrays of doubles or floats for XS code?</source>
          <target state="translated">XS 코드를 위해 double 또는 float 배열을 어떻게 포장합니까?</target>
        </trans-unit>
        <trans-unit id="4400dc02ad15b6fc00f373b7446035015d4ee6bf" translate="yes" xml:space="preserve">
          <source>How do I pad a string with blanks or pad a number with zeroes?</source>
          <target state="translated">공백으로 문자열을 채우거나 0으로 숫자를 채우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="d0e3e8a036359d14fc456cf2c14236b5f608bd62" translate="yes" xml:space="preserve">
          <source>How do I parse a mail header?</source>
          <target state="translated">메일 헤더를 어떻게 파싱합니까?</target>
        </trans-unit>
        <trans-unit id="9e0cafd923d528d129dae6e8757b0045ebfe45d2" translate="yes" xml:space="preserve">
          <source>How do I perform an operation on a series of integers?</source>
          <target state="translated">일련의 정수에서 작업을 수행하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0ea5e302520f6bb39c41ab5c626ec6b77bff9c77" translate="yes" xml:space="preserve">
          <source>How do I permute N elements of a list?</source>
          <target state="translated">목록의 N 개 요소를 치환하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2bb4f19e6e2b56ae1fd37e0d6e014e129c77c2b4" translate="yes" xml:space="preserve">
          <source>How do I prevent &quot;object version X.XX does not match bootstrap parameter Y.YY&quot; errors?</source>
          <target state="translated">&quot;개체 버전 X.XX가 부트 스트랩 매개 변수 Y.YY와 일치하지 않음&quot;오류를 방지하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="5b942fa715d105d63d048d010625e34a4e15cc06" translate="yes" xml:space="preserve">
          <source>How do I print out or copy a recursive data structure?</source>
          <target state="translated">재귀 데이터 구조를 인쇄하거나 복사하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0cee12c0d629b76061795de4e8ea8e8aad20c9a2" translate="yes" xml:space="preserve">
          <source>How do I print something out in color?</source>
          <target state="translated">컬러로 인쇄하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8c5e011ff87e317620443254f20726209e4d5142" translate="yes" xml:space="preserve">
          <source>How do I print to more than one file at once?</source>
          <target state="translated">한 번에 여러 파일로 인쇄하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8e6e30c99d7d46a63b6dd2a8de7f090b5c3b78f8" translate="yes" xml:space="preserve">
          <source>How do I process an entire hash?</source>
          <target state="translated">전체 해시를 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="271b9d3d652ec230aba0c388cad00cfb6ec4cadb" translate="yes" xml:space="preserve">
          <source>How do I process each word on each line?</source>
          <target state="translated">각 줄에서 각 단어를 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="067d5b88bfca3ed1b6b7d97cd252f5dd16cbb5b2" translate="yes" xml:space="preserve">
          <source>How do I process/modify each element of an array?</source>
          <target state="translated">배열의 각 요소를 어떻게 처리 / 수정합니까?</target>
        </trans-unit>
        <trans-unit id="4b013be3c59b874a12db528d39cfb66ea2b4d285" translate="yes" xml:space="preserve">
          <source>How do I profile my Perl programs?</source>
          <target state="translated">Perl 프로그램을 어떻게 프로파일합니까?</target>
        </trans-unit>
        <trans-unit id="907ce6af6f55d655a78f0e8c0ae363954d37ba4f" translate="yes" xml:space="preserve">
          <source>How do I put a &quot;-?&quot; option into a Getopt::Long?</source>
          <target state="translated">&quot;-&quot;를 어떻게 넣습니까? 옵션을 Getopt :: Long?</target>
        </trans-unit>
        <trans-unit id="c7fe97c54150572fb4431657021f14d59fd4861f" translate="yes" xml:space="preserve">
          <source>How do I put a password on my web pages?</source>
          <target state="translated">웹 페이지에 비밀번호를 어떻게 입력합니까?</target>
        </trans-unit>
        <trans-unit id="aabceca15e4a4d5d9ca824c2b010057c5ffb938d" translate="yes" xml:space="preserve">
          <source>How do I randomly update a binary file?</source>
          <target state="translated">이진 파일을 무작위로 어떻게 업데이트합니까?</target>
        </trans-unit>
        <trans-unit id="be52f21f6d10d6ab8f3f91d7f9754bf001810264" translate="yes" xml:space="preserve">
          <source>How do I read and write the serial port?</source>
          <target state="translated">직렬 포트를 읽고 쓰는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="88cf95522fd81b968df3c101e350990093c3aa09" translate="yes" xml:space="preserve">
          <source>How do I read email?</source>
          <target state="translated">이메일은 어떻게 읽습니까?</target>
        </trans-unit>
        <trans-unit id="f7f8ec70d59120dd78e53b84aba791742e9edd1e" translate="yes" xml:space="preserve">
          <source>How do I read just one key without waiting for a return key?</source>
          <target state="translated">리턴 키를 기다리지 않고 하나의 키를 어떻게 읽습니까?</target>
        </trans-unit>
        <trans-unit id="b3ea24ef99830bfeddb0edd113b634795cbe4cbc" translate="yes" xml:space="preserve">
          <source>How do I recompress using a different compression?</source>
          <target state="translated">다른 압축을 사용하여 어떻게 다시 압축합니까?</target>
        </trans-unit>
        <trans-unit id="90d36808740d961fdd3bc4db24c2ee814f31ee7c" translate="yes" xml:space="preserve">
          <source>How do I redefine a builtin function, operator, or method?</source>
          <target state="translated">내장 함수, 연산자 또는 메소드를 어떻게 재정의합니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
