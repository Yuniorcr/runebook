<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="27da418dc7160824d1f1cea0c0a27285c46f89f4" translate="yes" xml:space="preserve">
          <source>Looks like this:</source>
          <target state="translated">다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="3ccb11078ce15c4dd0a5f138c01c353d8c2f4351" translate="yes" xml:space="preserve">
          <source>Looks up ACCOUNT on SYSTEM and returns the domain name the SID and the SID type.</source>
          <target state="translated">SYSTEM에서 ACCOUNT를 찾고 도메인 이름, SID 및 SID 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f3ed7a3dfb53ef1d6f3759b748f942473d585fb" translate="yes" xml:space="preserve">
          <source>Looks up SID on SYSTEM and returns the account name, domain name, and the SID type.</source>
          <target state="translated">SYSTEM에서 SID를 조회하고 계정 이름, 도메인 이름 및 SID 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4835cdf08a9f25eb81b07f89910dd3550584f529" translate="yes" xml:space="preserve">
          <source>Looks up the definition of a given &quot;DOS&quot; device name, yielding the active Windows NT native device name along with any currently dormant definitions.</source>
          <target state="translated">주어진 &quot;DOS&quot;장치 이름의 정의를 검색하여 현재 휴면 정의와 함께 활성 Windows NT 기본 장치 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="150d86722bc6a43c75ceadbe33863f7ae1a8f8cf" translate="yes" xml:space="preserve">
          <source>Looks up the type of the lexical variable at position</source>
          <target state="translated">위치에서 어휘 변수의 유형을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="998c8ddbb7e6740fa96f3b9ca124537de52289c1" translate="yes" xml:space="preserve">
          <source>Looks up the type of the lexical variable at position &lt;code&gt;po&lt;/code&gt; in the currently-compiling pad. If the variable is typed, the stash of the class to which it is typed is returned. If not, &lt;code&gt;NULL&lt;/code&gt; is returned.</source>
          <target state="translated">현재 컴파일하는 패드의 &lt;code&gt;po&lt;/code&gt; 위치에서 어휘 변수의 유형을 찾습니다 . 변수를 입력하면 해당 변수가 입력 된 클래스의 숨김이 반환됩니다. 그렇지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7dba7dbb2ccc77afc11256e6171420abb3f68326" translate="yes" xml:space="preserve">
          <source>Lookup and return a reference to the entry for &lt;code&gt;MACHINE&lt;/code&gt; . If &lt;code&gt;LOGIN&lt;/code&gt; is given then the entry returned will have the given login. If &lt;code&gt;LOGIN&lt;/code&gt; is not given then the first entry in the .netrc file for &lt;code&gt;MACHINE&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;MACHINE&lt;/code&gt; 항목에 대한 참조를 조회하고 리턴하십시오 . &lt;code&gt;LOGIN&lt;/code&gt; 이 제공 되면 리턴 된 항목에 지정된 로그인이 있습니다. 경우 &lt;code&gt;LOGIN&lt;/code&gt; 후 이용하실 수 있습니다에 대한하면 .netrc 파일의 첫 번째 항목 &lt;code&gt;MACHINE&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65d5fef357946c73156ad1815637c8d7d629904a" translate="yes" xml:space="preserve">
          <source>Lookup and return a reference to the entry for &lt;code&gt;MACHINE&lt;/code&gt;. If &lt;code&gt;LOGIN&lt;/code&gt; is given then the entry returned will have the given login. If &lt;code&gt;LOGIN&lt;/code&gt; is not given then the first entry in the .netrc file for &lt;code&gt;MACHINE&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;MACHINE&lt;/code&gt; 항목에 대한 참조를 조회하고 반환합니다 . 경우 &lt;code&gt;LOGIN&lt;/code&gt; 지정되고있는 항목은 주어진 로그인을해야합니다 돌아왔다. 경우 &lt;code&gt;LOGIN&lt;/code&gt; 후 이용하실 수 있습니다에 대한하면 .netrc 파일의 첫 번째 항목 &lt;code&gt;MACHINE&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e27af5395111fe3fb113c2e3d566816c9450bb06" translate="yes" xml:space="preserve">
          <source>Lookup for connect()</source>
          <target state="translated">connect () 찾기</target>
        </trans-unit>
        <trans-unit id="cfef537fd2855cc3dbc568fc189f69bf8fa670d8" translate="yes" xml:space="preserve">
          <source>Loop Control</source>
          <target state="translated">루프 제어</target>
        </trans-unit>
        <trans-unit id="4394b7785cf8e6687ab901e849d752a278fd046b" translate="yes" xml:space="preserve">
          <source>Loop control statements don't work in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; , since they aren't loops. You can double the braces to make them such, though.</source>
          <target state="translated">루프 제어 문은 작동하지 않는 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;unless&lt;/code&gt; 그들이 루프를하지 않기 때문에. 그래도 중괄호를 두 배로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c6bd9b37d87812f90fc0d2ca6f3d53c5a09810" translate="yes" xml:space="preserve">
          <source>Loop control statements don't work in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt;, since they aren't loops. You can double the braces to make them such, though.</source>
          <target state="translated">루프 제어 문은 루프가 아니기 때문에 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;unless&lt;/code&gt; 에서 작동하지 않습니다 . 그래도 중괄호를 두 배로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee5406a6fab87283992041afaf3d98b63358ce87" translate="yes" xml:space="preserve">
          <source>Losing Overloading</source>
          <target state="translated">과부하 상실</target>
        </trans-unit>
        <trans-unit id="255b929d8a79cd2d34f3195e7105f962e8ff4cfe" translate="yes" xml:space="preserve">
          <source>Loss of information</source>
          <target state="translated">정보 손실</target>
        </trans-unit>
        <trans-unit id="0af71f661f40a0d4f6c6a167f0b101bbfc974cb4" translate="yes" xml:space="preserve">
          <source>Lost precision when %s %f by 1</source>
          <target state="translated">% s % f가 1 일 때 정밀도를 잃었습니다.</target>
        </trans-unit>
        <trans-unit id="cfc0d37079134dcffb425a52ede17bc5bc48e470" translate="yes" xml:space="preserve">
          <source>Lots of junk will go past as gdb reads in the relevant source files and libraries, and then:</source>
          <target state="translated">gdb가 관련 소스 파일 및 라이브러리에서 읽을 때 많은 정크가지나갑니다.</target>
        </trans-unit>
        <trans-unit id="cbf5af644412cf3c7e29c07a134f4f07b457d268" translate="yes" xml:space="preserve">
          <source>Lots of this documentation is duplicated from &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">이 문서의 많은 부분이 &lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man&lt;/a&gt; 에서 복제되었습니다 .</target>
        </trans-unit>
        <trans-unit id="085dc9408c5b1c58693c372e333c4354a4cec51f" translate="yes" xml:space="preserve">
          <source>Lots of this documentation is duplicated from &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">이 설명서의 많은 부분이 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man과&lt;/a&gt; 중복됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab1f1ddd535328223bedffdfeaa44f30147b00a6" translate="yes" xml:space="preserve">
          <source>Lots. See</source>
          <target state="translated">많이. 보다</target>
        </trans-unit>
        <trans-unit id="05699eeb34507ef8b7729483cad54f68e5da82dd" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to bzip2 compression library</source>
          <target state="translated">bzip2 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="daa6640df64c8d3fd04d48a86e9c6104202745fc" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to zlib compression library</source>
          <target state="translated">zlib 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="a0c4ed2cdac85f3556324d12104692afb5867488" translate="yes" xml:space="preserve">
          <source>Low-level File Opens via sysopen</source>
          <target state="translated">sysopen을 통해 저수준 파일 열기</target>
        </trans-unit>
        <trans-unit id="bbbd1cb27a00deeb8c66f6ae061bb29e0862f1bd" translate="yes" xml:space="preserve">
          <source>Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">파일 / 디렉토리에 대한 Win32 시스템 API 호출에 대한 저수준 액세스.</target>
        </trans-unit>
        <trans-unit id="e8c85a684a62b80d06983e6e12e35335310bc09b" translate="yes" xml:space="preserve">
          <source>Low-level layer that calls &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt; , etc.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lseek&lt;/code&gt; 등 을 호출하는 저수준 계층</target>
        </trans-unit>
        <trans-unit id="7f89e9304454a9ca27d4f058ae1ff5cae7d7d44b" translate="yes" xml:space="preserve">
          <source>Low-level layer that calls &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;lseek&lt;/code&gt; 등 을 호출하는 저수준 계층 .</target>
        </trans-unit>
        <trans-unit id="55c868659706d4acf0f9a3d5d20af059cb10c22a" translate="yes" xml:space="preserve">
          <source>Low-level socket functions</source>
          <target state="translated">저수준 소켓 기능</target>
        </trans-unit>
        <trans-unit id="abf8ce4a5f4a2b06b346bb8ef9b168681a52fab2" translate="yes" xml:space="preserve">
          <source>Lowercase_Letter</source>
          <target state="translated">Lowercase_Letter</target>
        </trans-unit>
        <trans-unit id="a99d83c11e02cb19d312201ee35e6930d1ab9ee1" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name list.</source>
          <target state="translated">패드 이름 목록의 참조 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1b905a464c50eff889d1fabd4387275f0c86db4f" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name.</source>
          <target state="translated">패드 이름의 참조 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="64d41b1df2cdae534f1fdacc800338a809f214c6" translate="yes" xml:space="preserve">
          <source>Lowest level layer which provides basic PerlIO operations in terms of UNIX/POSIX numeric file descriptor calls (open(), read(), write(), lseek(), close()).</source>
          <target state="translated">UNIX / POSIX 숫자 파일 디스크립터 호출 (open (), read (), write (), lseek (), close ()) 측면에서 기본적인 PerlIO 조작을 제공하는 최하위 레벨 계층.</target>
        </trans-unit>
        <trans-unit id="46baacdecc30fd8131a5c1a06a482d538e74c4c5" translate="yes" xml:space="preserve">
          <source>Lowest level layer which provides basic PerlIO operations in terms of UNIX/POSIX numeric file descriptor calls (open(), read(), write(), lseek(), close()). It is used even on non-Unix architectures, and most other layers operate on top of it.</source>
          <target state="translated">UNIX / POSIX 숫자 파일 설명자 호출 (open (), read (), write (), lseek (), close ()) 측면에서 기본 PerlIO 작업을 제공하는 최하위 계층입니다. 비 유닉스 아키텍처에서도 사용되며 대부분의 다른 계층이 그 위에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8f76153b489235de1b7ba0a13f749867749dbd1e" translate="yes" xml:space="preserve">
          <source>Lukas Eklund &amp;lt;leklund@gmail.com&amp;gt;</source>
          <target state="translated">Lukas Eklund &amp;lt;leklund@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16b73d35c25cb2d87aaa9bb21b4aedfa85686027" translate="yes" xml:space="preserve">
          <source>Luther Huffman, lutherh@stratcom.com, Strategic Computer Solutions, Inc.</source>
          <target state="translated">Luther Huffman, lutherh@stratcom.com, Strategic Computer Solutions, Inc.</target>
        </trans-unit>
        <trans-unit id="992354f36023a64134d9045affe474e73e18db31" translate="yes" xml:space="preserve">
          <source>Luvverly! and to fix this we declare all variables explicitly and now our script looks like this:</source>
          <target state="translated">Luvverly! 이 문제를 해결하기 위해 모든 변수를 명시 적으로 선언하면 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc6aa5975bc24ec633f5fcc8f9ccf2766d7ad7e9" translate="yes" xml:space="preserve">
          <source>Lvalue casts</source>
          <target state="translated">Lvalue 캐스트</target>
        </trans-unit>
        <trans-unit id="c819825aaf49d2c99e8f8f2add24599bfbddb1a0" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines</source>
          <target state="translated">Lvalue 서브 루틴</target>
        </trans-unit>
        <trans-unit id="a77fcba977d5eb923b72725f6d5dc4fe49dee064" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines are convenient, but you have to keep in mind that, when used with objects, they may violate encapsulation. A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine cannot. If you require any special processing when storing and retrieving the values, consider using the CPAN module Sentinel or something similar.</source>
          <target state="translated">Lvalue 서브 루틴은 편리하지만 객체와 함께 사용하면 캡슐화를 위반할 수 있음을 명심해야합니다. 일반 뮤 테이터는 보호하고있는 속성을 설정하기 전에 제공된 인수를 확인할 수 있습니다. lvalue 서브 루틴은 불가능합니다. 값을 저장하고 검색 할 때 특수 처리가 필요한 경우 CPAN 모듈 Sentinel 또는 이와 유사한 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01157c3907a273e426b801b96bad325cfefca606" translate="yes" xml:space="preserve">
          <source>Lzma (method 14)</source>
          <target state="translated">Lzma (방법 14)</target>
        </trans-unit>
        <trans-unit id="53448a46968767fc3dc24857326ec00bf716b8a2" translate="yes" xml:space="preserve">
          <source>Lzma Compression Options</source>
          <target state="translated">Lzma 압축 옵션</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="c716084845f60944f0ccfd3046e9665113c093b0" translate="yes" xml:space="preserve">
          <source>MAGIC</source>
          <target state="translated">MAGIC</target>
        </trans-unit>
        <trans-unit id="9bc0ed9c361a62773b779bac20ca83bc337097db" translate="yes" xml:space="preserve">
          <source>MAGICXS</source>
          <target state="translated">MAGICXS</target>
        </trans-unit>
        <trans-unit id="15c8cbe6eb1479a64e132c9d7a73db9ce6a8aab3" translate="yes" xml:space="preserve">
          <source>MAILING LIST</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="b3b45a6a598ee27528bae4158cd460e7b0cab066" translate="yes" xml:space="preserve">
          <source>MAIN API EXPORTS</source>
          <target state="translated">주요 API 수출</target>
        </trans-unit>
        <trans-unit id="f672ec1a25cdbb81af49b4e2e09eb665a197b037" translate="yes" xml:space="preserve">
          <source>MAIN METHODS</source>
          <target state="translated">주요 방법</target>
        </trans-unit>
        <trans-unit id="7bee61cc4b2ff6ceaa5bf2c847f0465ac92786f6" translate="yes" xml:space="preserve">
          <source>MAIN SEARCH METHODS</source>
          <target state="translated">주요 검색 방법</target>
        </trans-unit>
        <trans-unit id="b2bcf80339bb8c2f5b627482d7224ef03323abc9" translate="yes" xml:space="preserve">
          <source>MAINTAINER</source>
          <target state="translated">MAINTAINER</target>
        </trans-unit>
        <trans-unit id="572378cf179c50ade4591b0f42a539fe3de5c4ba" translate="yes" xml:space="preserve">
          <source>MAINTAINERS</source>
          <target state="translated">MAINTAINERS</target>
        </trans-unit>
        <trans-unit id="a573378dd124c5aff03b74a9a4dee3c0207dd14a" translate="yes" xml:space="preserve">
          <source>MAINTENANCE AND SUPPORT</source>
          <target state="translated">유지 관리 및 지원</target>
        </trans-unit>
        <trans-unit id="381f8b8847a78b52a5c355f7a396ec94cdfb3fe2" translate="yes" xml:space="preserve">
          <source>MAINTENANCE BRANCHES</source>
          <target state="translated">유지 보수 지점</target>
        </trans-unit>
        <trans-unit id="5f4395a75c71fe04b6156d6290da65a27f17e138" translate="yes" xml:space="preserve">
          <source>MAKE</source>
          <target state="translated">MAKE</target>
        </trans-unit>
        <trans-unit id="0124d424fb4888dc5f53bb1ef59aaa8406bebab8" translate="yes" xml:space="preserve">
          <source>MAKE ASSERTIONS -&amp;gt; SEND EVENTS</source>
          <target state="translated">주장하기-&amp;gt; 이벤트 보내기</target>
        </trans-unit>
        <trans-unit id="c8c08604e5e552ec9e9c63c71fc8f4ef53453d1a" translate="yes" xml:space="preserve">
          <source>MAKE ON CYGWIN</source>
          <target state="translated">싸이 윈 만들기</target>
        </trans-unit>
        <trans-unit id="1f0292102c8114ed4accdb4b3187dd3355fe606e" translate="yes" xml:space="preserve">
          <source>MAKE PROBLEMS.</source>
          <target state="translated">문제를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="606cfc5f8f22b0f666e90c16494ce8cfe5172b45" translate="yes" xml:space="preserve">
          <source>MAKE TEST</source>
          <target state="translated">테스트하기</target>
        </trans-unit>
        <trans-unit id="4197ed452e3e67bf334841bde4210f984cf23e44" translate="yes" xml:space="preserve">
          <source>MAKEAPERL</source>
          <target state="translated">MAKEAPERL</target>
        </trans-unit>
        <trans-unit id="df6262932ccb109dce90e30936b4e6b9e6d0d4c2" translate="yes" xml:space="preserve">
          <source>MAKEFILE_OLD</source>
          <target state="translated">MAKEFILE_OLD</target>
        </trans-unit>
        <trans-unit id="d33b61e914eef018d44c2af2392dd8a8bb3f0814" translate="yes" xml:space="preserve">
          <source>MAKEMAKER: path to the MakeMaker module.</source>
          <target state="translated">MAKEMAKER : MakeMaker 모듈의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="fba0fd0dd60434c9d108881cdd60c2cfbd09f893" translate="yes" xml:space="preserve">
          <source>MAN PAGES</source>
          <target state="translated">맨 페이지</target>
        </trans-unit>
        <trans-unit id="c64d5c48751d39c885c4bcdfb24a588e7e222136" translate="yes" xml:space="preserve">
          <source>MAN1PODS</source>
          <target state="translated">MAN1PODS</target>
        </trans-unit>
        <trans-unit id="c7fb89700825cc5dfcebfd44326a8eec88015a73" translate="yes" xml:space="preserve">
          <source>MAN3PODS</source>
          <target state="translated">MAN3PODS</target>
        </trans-unit>
        <trans-unit id="41d43d8ceb08d1444c2cfb5b56c19af1bc2840bf" translate="yes" xml:space="preserve">
          <source>MANAGING FORMATTERS</source>
          <target state="translated">포맷터 관리</target>
        </trans-unit>
        <trans-unit id="9ae61f13c66eb261147f9d4b1d89a27b5c697890" translate="yes" xml:space="preserve">
          <source>MANIFEST</source>
          <target state="translated">MANIFEST</target>
        </trans-unit>
        <trans-unit id="ee43e9094077d72c1da72a9a91b89d3593977bf3" translate="yes" xml:space="preserve">
          <source>MANIFEST ON CYGWIN</source>
          <target state="translated">CYGWIN의 매니페스트</target>
        </trans-unit>
        <trans-unit id="99aec53b52aee7fd41e057b43112a2b07b20b1fa" translate="yes" xml:space="preserve">
          <source>MANIFEST.SKIP</source>
          <target state="translated">MANIFEST.SKIP</target>
        </trans-unit>
        <trans-unit id="93ba9a2acb7ece879d6eae4b3780b55ff65e53c6" translate="yes" xml:space="preserve">
          <source>MANIFEST.bak</source>
          <target state="translated">MANIFEST.bak</target>
        </trans-unit>
        <trans-unit id="71154a1d58b708083b1b8a9a53cc03dfaac27380" translate="yes" xml:space="preserve">
          <source>MAP DATA</source>
          <target state="translated">지도 데이터</target>
        </trans-unit>
        <trans-unit id="b315cd523ae2ef826dbad53529ba6c9c2ad21ff1" translate="yes" xml:space="preserve">
          <source>MAPPING</source>
          <target state="translated">MAPPING</target>
        </trans-unit>
        <trans-unit id="209ca025362fc9c148579a1bf701af6d3fbee6d2" translate="yes" xml:space="preserve">
          <source>MAP_TARGET</source>
          <target state="translated">MAP_TARGET</target>
        </trans-unit>
        <trans-unit id="20b7a63446bb07c65998bdd386758cc1d4e47490" translate="yes" xml:space="preserve">
          <source>MARK</source>
          <target state="translated">MARK</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="34a4dfce34585d297b90edd353506556851a5017" translate="yes" xml:space="preserve">
          <source>MATH</source>
          <target state="translated">MATH</target>
        </trans-unit>
        <trans-unit id="72a965b84fe5d8bf2c44aadc341ef716b1bb9f90" translate="yes" xml:space="preserve">
          <source>MATH LIBRARY</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="7b186e235f284107df6b4dbe6060d2b6a5d9f1e5" translate="yes" xml:space="preserve">
          <source>MAX</source>
          <target state="translated">MAX</target>
        </trans-unit>
        <trans-unit id="792fd2692b3061f3e55fd6e6d06b2216b2041c0f" translate="yes" xml:space="preserve">
          <source>MAXCOMPLEN is the maximum length of a filename component (the part between two backslashes) on this file system.</source>
          <target state="translated">MAXCOMPLEN은이 파일 시스템에있는 파일 이름 구성 요소 (두 백 슬래시 사이의 부분)의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="f68525ad751f8a1d932458c4c58a214bdf0b30e9" translate="yes" xml:space="preserve">
          <source>MEDIUM</source>
          <target state="translated">MEDIUM</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="cdf5b879eba064baae0d94237dbf7820fdcbb018" translate="yes" xml:space="preserve">
          <source>MEMORY DEBUGGERS</source>
          <target state="translated">메모리 디버거</target>
        </trans-unit>
        <trans-unit id="e31b925235cc3be7fd5e0670fdc195273a9cff6f" translate="yes" xml:space="preserve">
          <source>MEMORY STORE</source>
          <target state="translated">메모리 저장</target>
        </trans-unit>
        <trans-unit id="4c1e46b92295867a7e3aedb69823f567f1577697" translate="yes" xml:space="preserve">
          <source>MERGE STRATEGIES</source>
          <target state="translated">병합 전략</target>
        </trans-unit>
        <trans-unit id="af3e8367fd77b35795f6a4515a82e2821f81990d" translate="yes" xml:space="preserve">
          <source>MESSAGE-SPEC</source>
          <target state="translated">MESSAGE-SPEC</target>
        </trans-unit>
        <trans-unit id="c459b150dd079f2662d2dc95f57ad127cc7aa8df" translate="yes" xml:space="preserve">
          <source>META CHARACTERS</source>
          <target state="translated">메타 문자</target>
        </trans-unit>
        <trans-unit id="e3b3cae38e87b40132568c5a00d9fdb4dbf0d028" translate="yes" xml:space="preserve">
          <source>META Concerns</source>
          <target state="translated">META 우려</target>
        </trans-unit>
        <trans-unit id="a0396a803e296b3603471fd9fe995f4d3b469448" translate="yes" xml:space="preserve">
          <source>META-KEY RESTRICTIONS</source>
          <target state="translated">메타 키 제한</target>
        </trans-unit>
        <trans-unit id="4a6da301633ce81aa21cac64ffb95d87c6894995" translate="yes" xml:space="preserve">
          <source>META.json</source>
          <target state="translated">META.json</target>
        </trans-unit>
        <trans-unit id="3b7f8f92275828b66b32cb6c6aeb61e73c1d7587" translate="yes" xml:space="preserve">
          <source>META.yml</source>
          <target state="translated">META.yml</target>
        </trans-unit>
        <trans-unit id="b763622141e2fabeb07a88720f777618ff14ff8f" translate="yes" xml:space="preserve">
          <source>META_ADD</source>
          <target state="translated">META_ADD</target>
        </trans-unit>
        <trans-unit id="ffea654c220d2875e7a864f30439535466d152eb" translate="yes" xml:space="preserve">
          <source>META_MERGE</source>
          <target state="translated">META_MERGE</target>
        </trans-unit>
        <trans-unit id="296be0aba5c6db10945a86505a9c35adbc0a5da7" translate="yes" xml:space="preserve">
          <source>METHOD CALLING</source>
          <target state="translated">메서드 호출</target>
        </trans-unit>
        <trans-unit id="7541f2ddbea83515621139a06393c2c41632b2df" translate="yes" xml:space="preserve">
          <source>METHODS</source>
          <target state="translated">METHODS</target>
        </trans-unit>
        <trans-unit id="7347dda2b461e7f991ef3bb4cbeac4cccce22688" translate="yes" xml:space="preserve">
          <source>METHODS AND FIELDS</source>
          <target state="translated">방법 및 분야</target>
        </trans-unit>
        <trans-unit id="3cb215be859943e6d7b15dec190189887d7849cd" translate="yes" xml:space="preserve">
          <source>METHODS FOR PARSING AND PROCESSING</source>
          <target state="translated">껍질을 벗기고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="e6e31389588ce3a302e9399908d50ba1bc9b2ff6" translate="yes" xml:space="preserve">
          <source>METHODS SUBCLASSES MAY IMPLEMENT OR OVERRIDE</source>
          <target state="translated">메서드 하위 클래스가 구현되거나 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab46e61362be7095bd0ecea299cf9afde867e32c" translate="yes" xml:space="preserve">
          <source>METHODS SUBCLASSES MUST IMPLEMENT</source>
          <target state="translated">메서드 하위 클래스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="bac1668d54ba3469d07436c3cb4d6c63921e8439" translate="yes" xml:space="preserve">
          <source>MILLIONS OF MACROS</source>
          <target state="translated">수백만의 매크로</target>
        </trans-unit>
        <trans-unit id="8c54fa1663ec8e58feaa0f76d0ad16806f96497d" translate="yes" xml:space="preserve">
          <source>MIME 'B' and 'Q' header encoding</source>
          <target state="translated">MIME 'B'및 'Q'헤더 인코딩</target>
        </trans-unit>
        <trans-unit id="f0186eb413ae0fe1b04a58826d46062c8207cd98" translate="yes" xml:space="preserve">
          <source>MIME (Multipurpose Internet Mail Extensions)</source>
          <target state="translated">MIME (다목적 인터넷 메일 확장)</target>
        </trans-unit>
        <trans-unit id="448dc4536185fa521763a707f1aaa251c78a81e2" translate="yes" xml:space="preserve">
          <source>MIME encoding for an unstructured email header</source>
          <target state="translated">구조화되지 않은 이메일 헤더에 대한 MIME 인코딩</target>
        </trans-unit>
        <trans-unit id="ced61424802296ffb38430fa8f0fab4da3883207" translate="yes" xml:space="preserve">
          <source>MIME::Base64</source>
          <target state="translated">MIME::Base64</target>
        </trans-unit>
        <trans-unit id="7fe3ea65bc04a88102c03df5c340d4e7c1520d18" translate="yes" xml:space="preserve">
          <source>MIME::Base64 - Encoding and decoding of base64 strings</source>
          <target state="translated">MIME :: Base64-base64 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="7ffae17f904a8de9b8c01b15e74d1504ffbc2043" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint</source>
          <target state="translated">MIME::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="65095920906e9bf0fe024eb72fdfbbe098341dd5" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint - Encoding and decoding of quoted-printable strings</source>
          <target state="translated">MIME :: QuotedPrint-인용 인쇄 가능한 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="7f1f9a719a9f150e508497c923f92b8123e37935" translate="yes" xml:space="preserve">
          <source>MIME_ENCODING</source>
          <target state="translated">MIME_ENCODING</target>
        </trans-unit>
        <trans-unit id="79b8daea186e0e9dd2d8665c8e357ddbbf0a21c4" translate="yes" xml:space="preserve">
          <source>MIN_PERL_VERSION</source>
          <target state="translated">MIN_PERL_VERSION</target>
        </trans-unit>
        <trans-unit id="8d9cb354f1b92318e37511c8328e0bfc3a396a31" translate="yes" xml:space="preserve">
          <source>MISC</source>
          <target state="translated">MISC</target>
        </trans-unit>
        <trans-unit id="fbc28147d7dae55d07ef20379522673d2cd4aff7" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS</source>
          <target state="translated">MISCELLANEOUS</target>
        </trans-unit>
        <trans-unit id="0e2957d871def6ecf380e593a975af27f56d18ea" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS TRICKS</source>
          <target state="translated">기타 트릭</target>
        </trans-unit>
        <trans-unit id="8727bad0374de5d99b1e6473dee31baa8ae41493" translate="yes" xml:space="preserve">
          <source>MKTEMP FUNCTIONS</source>
          <target state="translated">MKTEMP 기능</target>
        </trans-unit>
        <trans-unit id="38de91e68bd653a65240e9601577373f8b2878b4" translate="yes" xml:space="preserve">
          <source>MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards compat)</source>
          <target state="translated">MM_REVISION : ExtUtils :: MakeMaker 버전 관리 개정판 (후방 호환)</target>
        </trans-unit>
        <trans-unit id="065dc1eef187bb989bef804cda0869075be856b3" translate="yes" xml:space="preserve">
          <source>MM_VERSION: ExtUtils::MakeMaker Version</source>
          <target state="translated">MM_VERSION : ExtUtils :: MakeMaker 버전</target>
        </trans-unit>
        <trans-unit id="b630876e2ee4a66e53ca42c0024ca639bccd9170" translate="yes" xml:space="preserve">
          <source>MM_VMS_REVISION is for backwards compatibility before MM_VMS had a $VERSION.</source>
          <target state="translated">MM_VMS_REVISION은 MM_VMS가 $ VERSION을 갖기 전에 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a5019b6901ec4e0159788b99019a468b1278f03" translate="yes" xml:space="preserve">
          <source>MODE</source>
          <target state="translated">MODE</target>
        </trans-unit>
        <trans-unit id="11d727b07a2ef2f226c24b7b3ca7ffbcc8a440f3" translate="yes" xml:space="preserve">
          <source>MODIFICATION HISTORY</source>
          <target state="translated">수정 이력</target>
        </trans-unit>
        <trans-unit id="3506eba054bea9f2aa92527050cd8aa61b12595f" translate="yes" xml:space="preserve">
          <source>MODIFY_</source>
          <target state="translated">MODIFY_</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="a3e25a142bc9338d99e21ddb92754631acdb233f" translate="yes" xml:space="preserve">
          <source>MODULENAME is the Perl module name, e.g. Devel::SelfStubber, NOT 'Devel/SelfStubber' or 'Devel/SelfStubber.pm'.</source>
          <target state="translated">MODULENAME은 Perl 모듈 이름입니다 (예 : Devel :: SelfStubber, NOT 'Devel / SelfStubber'또는 'Devel / SelfStubber.pm').</target>
        </trans-unit>
        <trans-unit id="479396de59be987e42108d35e44f4b59dc1b4a9e" translate="yes" xml:space="preserve">
          <source>MODULES</source>
          <target state="translated">MODULES</target>
        </trans-unit>
        <trans-unit id="630e8cd715da84adcb106243940c860db346e2eb" translate="yes" xml:space="preserve">
          <source>MODULES USED</source>
          <target state="translated">사용되는 모듈</target>
        </trans-unit>
        <trans-unit id="b3c85e8affa5446d487b201bbc63d337d6d7f54d" translate="yes" xml:space="preserve">
          <source>MOD[=bar,baz]</source>
          <target state="translated">MOD[=bar,baz]</target>
        </trans-unit>
        <trans-unit id="c47b9589ffc380689e211aa66dac2ba8473cc24a" translate="yes" xml:space="preserve">
          <source>MONO CASE then sort data (for non-digits, non-underscore)</source>
          <target state="translated">MONO CASE 그런 다음 데이터를 정렬합니다 (숫자가 아닌 경우, 밑줄이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="b537891a9c0b5c8f4e6ee16a9ec71caca75f6730" translate="yes" xml:space="preserve">
          <source>MORAL</source>
          <target state="translated">MORAL</target>
        </trans-unit>
        <trans-unit id="2c624e5265a05c5d2c6e21783801e9896aa0132f" translate="yes" xml:space="preserve">
          <source>MORE</source>
          <target state="translated">MORE</target>
        </trans-unit>
        <trans-unit id="bc4fc594140fde77e059ad4498ad554e3cbee3e9" translate="yes" xml:space="preserve">
          <source>MORE ELABORATE RECORDS</source>
          <target state="translated">더 우아한 기록</target>
        </trans-unit>
        <trans-unit id="64bf6c143dc817670181bbd264688b3acbcd5d5a" translate="yes" xml:space="preserve">
          <source>MORE EXAMPLES</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="9ad9881a7f17afaec8c4ae609d85b1187596ee5b" translate="yes" xml:space="preserve">
          <source>MORE INFORMATION</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="76991e71012a76451fe2a0cc0849f44f697181ec" translate="yes" xml:space="preserve">
          <source>MORE READING FOR GUTS HACKERS</source>
          <target state="translated">건트 해커를위한 더 많은 독서</target>
        </trans-unit>
        <trans-unit id="e7fd50abbfbafe75448c31d50672233d0a7980c6" translate="yes" xml:space="preserve">
          <source>MOREMAGIC</source>
          <target state="translated">MOREMAGIC</target>
        </trans-unit>
        <trans-unit id="abdd28bdcd2ff588ed4391e2849b71273a64ab04" translate="yes" xml:space="preserve">
          <source>MRO Functions</source>
          <target state="translated">MRO 기능</target>
        </trans-unit>
        <trans-unit id="b105d95acedcd0df5c653c0e1be8aac0aa3534a5" translate="yes" xml:space="preserve">
          <source>MS-DOS</source>
          <target state="translated">MS-DOS</target>
        </trans-unit>
        <trans-unit id="304ff724cf80bd1102c4a52a83e37a5a11d51edf" translate="yes" xml:space="preserve">
          <source>MSG_BCAST, MSG_OOB, MSG_TRUNC, ...</source>
          <target state="translated">MSG_BCAST, MSG_OOB, MSG_TRUNC, ...</target>
        </trans-unit>
        <trans-unit id="95ed316aead6f0a90227220b98ed2c6a72173129" translate="yes" xml:space="preserve">
          <source>MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem. See &lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&lt;/a&gt; Default: 1</source>
          <target state="translated">MSWin32 대 / 소문자 허용 여부는 GetVolumeInformation () $ ouFsFlags == FS_CASE_SENSITIVE에 따라 달라지며 파일 사양을 비교할 때 대소 문자의 중요성을 나타냅니다. XP FS_CASE_SENSITIVE는 NT 서브 시스템에 대해 효과적으로 사용 불가능하기 때문에. &lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html을&lt;/a&gt; 참조하십시오 . 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="46b420891abbe816108b89b151663fa05cb3b237" translate="yes" xml:space="preserve">
          <source>MULTI-OCTET CHARACTER SETS</source>
          <target state="translated">멀티 옥셋 캐릭터 세트</target>
        </trans-unit>
        <trans-unit id="1157801a76643907eaa464d8d8b432b909f3f592" translate="yes" xml:space="preserve">
          <source>MULTICALL</source>
          <target state="translated">MULTICALL</target>
        </trans-unit>
        <trans-unit id="410655851813ae42e29a8af5e0c4bbe60816fe96" translate="yes" xml:space="preserve">
          <source>MULTITHREADED APPLICATIONS</source>
          <target state="translated">다중 스레드 애플리케이션</target>
        </trans-unit>
        <trans-unit id="112f1bc5464cbf86ad8abc28805d58542d252dc7" translate="yes" xml:space="preserve">
          <source>MUST decode</source>
          <target state="translated">반드시 디코딩해야합니다</target>
        </trans-unit>
        <trans-unit id="f3f97d4e65bbf8e05b9d2003dabed48039672a9b" translate="yes" xml:space="preserve">
          <source>MUST return the octet sequence representing</source>
          <target state="translated">다음을 나타내는 8 진수 시퀀스를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f37495c410f3672ad3b7e5f75ff69fe1801eda14" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the IANA charset name of the encoding.</source>
          <target state="translated">인코딩의 IANA 문자셋 이름을 나타내는 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="df44e8bf9f5bb85b1c861873578524b02eaca16a" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the canonical name of the encoding.</source>
          <target state="translated">인코딩의 표준 이름을 나타내는 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6d2a5fac9fc009e8ef2c66dccfa9c0e7765210" translate="yes" xml:space="preserve">
          <source>MUST return the string that</source>
          <target state="translated">그 문자열을 반환해야합니다</target>
        </trans-unit>
        <trans-unit id="d2008ef579d429eb9f21f1dee25cb60d820de1c0" translate="yes" xml:space="preserve">
          <source>MUTATION</source>
          <target state="translated">MUTATION</target>
        </trans-unit>
        <trans-unit id="bcbdfcff47f36a4bd295e8dcb4203d07f1343372" translate="yes" xml:space="preserve">
          <source>MYEXTLIB</source>
          <target state="translated">MYEXTLIB</target>
        </trans-unit>
        <trans-unit id="8a1a4fa060cab0b9420887b26bf1330d0275e0dd" translate="yes" xml:space="preserve">
          <source>MYMETA.json</source>
          <target state="translated">MYMETA.json</target>
        </trans-unit>
        <trans-unit id="2f5e6a42d1d484cbbde0efe806d130305e765ea2" translate="yes" xml:space="preserve">
          <source>MYMETA.yml</source>
          <target state="translated">MYMETA.yml</target>
        </trans-unit>
        <trans-unit id="c83e0148da9329e1a74fae48edd72325f87db2ab" translate="yes" xml:space="preserve">
          <source>MY_CXT</source>
          <target state="translated">MY_CXT</target>
        </trans-unit>
        <trans-unit id="c92b11ff7ab5a4c5fd081db7883c7b3a71c6ef70" translate="yes" xml:space="preserve">
          <source>MY_CXT REFERENCE</source>
          <target state="translated">MY_CXT 참조</target>
        </trans-unit>
        <trans-unit id="71c4b4f77dd6aa81ae33d939a92a8e29b5de3e34" translate="yes" xml:space="preserve">
          <source>MY_CXT_CLONE</source>
          <target state="translated">MY_CXT_CLONE</target>
        </trans-unit>
        <trans-unit id="8f9145c9f6a580d204ffb3a2156f8854c633e0db" translate="yes" xml:space="preserve">
          <source>MY_CXT_INIT</source>
          <target state="translated">MY_CXT_INIT</target>
        </trans-unit>
        <trans-unit id="b0c38180ec37e61376fb7d95221d9077a44d5cc9" translate="yes" xml:space="preserve">
          <source>MY_CXT_INIT_INTERP(my_perl)</source>
          <target state="translated">MY_CXT_INIT_INTERP(my_perl)</target>
        </trans-unit>
        <trans-unit id="8d47e1fdc3a026db13eae6a6b125df6ba8c7928c" translate="yes" xml:space="preserve">
          <source>MY_CXT_KEY</source>
          <target state="translated">MY_CXT_KEY</target>
        </trans-unit>
        <trans-unit id="61ad4287cd41e2e97ad96a7d5cba5a661af2c472" translate="yes" xml:space="preserve">
          <source>MY_LIB_DIR defaults to '.' if not present.</source>
          <target state="translated">MY_LIB_DIR의 기본값은 '.'입니다. 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="9790a85a1a9e58a2ddd68bd085adb9c931b1b046" translate="yes" xml:space="preserve">
          <source>Mac OS 9 and earlier used &lt;code&gt;:&lt;/code&gt; as a path separator instead of &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">맥 OS 9 및 앞서 사용 &lt;code&gt;:&lt;/code&gt; 대신 경로 구분자 &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b48af28979910507a72300805b16b39786c09205" translate="yes" xml:space="preserve">
          <source>Mac OS X</source>
          <target state="translated">맥 OS X</target>
        </trans-unit>
        <trans-unit id="9208982d7e71273ee9421bf88e0b53b6ad837f35" translate="yes" xml:space="preserve">
          <source>Mac OS X 10.5 &quot;Leopard&quot; and above do not require the 'u' variant.</source>
          <target state="translated">Mac OS X 10.5 &quot;Leopard&quot;이상에는 'u'변형이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27e0400e4107eec8c9b3ecfab19987f0725198d4" translate="yes" xml:space="preserve">
          <source>Mac OS X documentation on syslog, &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 Mac OS X 설명서, &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4c0bf3f7dab7b087f55de5614ca5cbaddeea9b9" translate="yes" xml:space="preserve">
          <source>Mac OS X ships with a dynamically-loaded libperl, but the default for this release is to compile a static libperl. The reason for this is pre-binding. Dynamic libraries can be pre-bound to a specific address in memory in order to decrease load time. To do this, one needs to be aware of the location and size of all previously-loaded libraries. Apple collects this information as part of their overall OS build process, and thus has easy access to it when building Perl, but ordinary users would need to go to a great deal of effort to obtain the information needed for pre-binding.</source>
          <target state="translated">Mac OS X은 동적으로로드 된 libperl과 함께 제공되지만이 릴리스의 기본값은 정적 libperl을 컴파일하는 것입니다. 그 이유는 사전 바인딩입니다. 로드 시간을 줄이기 위해 메모리의 특정 주소에 동적 라이브러리를 사전 바인딩 할 수 있습니다. 이를 위해서는 이전에로드 된 모든 라이브러리의 위치와 크기를 알고 있어야합니다. Apple은 전체 OS 빌드 프로세스의 일부로이 정보를 수집하므로 Perl을 빌드 할 때 쉽게 액세스 할 수 있지만 일반 사용자는 사전 바인딩에 필요한 정보를 얻기 위해 많은 노력을 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0343b2a40016db738fa670b19df9f47fc227d16f" translate="yes" xml:space="preserve">
          <source>Mac OS X.</source>
          <target state="translated">맥 OS X.</target>
        </trans-unit>
        <trans-unit id="05365d617a6f81e5ccef6d039b61942e2b328dfe" translate="yes" xml:space="preserve">
          <source>MacOS's epoch is midnight January 1st, 1904. VMS's is midnight, November 17th, 1858, but vmsperl emulates the Unix epoch so it's not a problem.</source>
          <target state="translated">MacOS 시대는 1904 년 1 월 1 일 자정입니다. VMS는 1858 년 11 월 17 일 자정이지만 vmsperl은 Unix 시대를 에뮬레이트하므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="546928a146336cd7f40c7bb8263ae0c9584726db" translate="yes" xml:space="preserve">
          <source>Macintosh encodings don't seem to be registered in such entities as IANA. &quot;Canonical&quot; names in Encode are based upon Apple's Tech Note 1150. See &lt;a href=&quot;http://developer.apple.com/technotes/tn/tn1150.html&quot;&gt;http://developer.apple.com/technotes/tn/tn1150.html&lt;/a&gt; for details.</source>
          <target state="translated">Macintosh 인코딩은 IANA와 같은 엔티티에 등록되지 않은 것 같습니다. Encode의 &quot;표준&quot;이름은 Apple의 Tech Note 1150을 기반으로합니다 . 자세한 내용 은 &lt;a href=&quot;http://developer.apple.com/technotes/tn/tn1150.html&quot;&gt;http://developer.apple.com/technotes/tn/tn1150.html&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e813bad999ce5a75f4490c8ed14ec07ab9d63a2d" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list explicitly exporting the symbols.</source>
          <target state="translated">XSUB 및 해당 C 매개 변수 목록을 선언하여 심볼을 명시 적으로 내보내는 매크로</target>
        </trans-unit>
        <trans-unit id="3f0040307b52caa52d747905fa724ed6b830cee4" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list without exporting the symbols. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; and generally preferable over exporting the XSUB symbols unnecessarily.</source>
          <target state="translated">심볼을 내 보내지 않고 XSUB 및 해당 C 매개 변수 목록을 선언하는 매크로 이것은 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리되며 일반적으로 XSUB 심볼을 불필요하게 내보내는 것보다 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="1376083aeef8a0b2b3a5461de74e71c6974c467b" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; . It is the same as using the more explicit XS_EXTERNAL macro.</source>
          <target state="translated">XSUB 및 해당 C 매개 변수 목록을 선언하는 매크로 이것은 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 보다 명확한 XS_EXTERNAL 매크로를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e18a81f50de73a3bc24953bde393f35d1ef8d9ce" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list. This is handled by &lt;code&gt;xsubpp&lt;/code&gt;. It is the same as using the more explicit &lt;code&gt;XS_EXTERNAL&lt;/code&gt; macro.</source>
          <target state="translated">XSUB 및 해당 C 매개 변수 목록을 선언하는 매크로입니다. 이것은 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 보다 명시적인 &lt;code&gt;XS_EXTERNAL&lt;/code&gt; 매크로 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7aea32d1102862e7b6b0c8089588079d1bf46bd9" translate="yes" xml:space="preserve">
          <source>Macro to verify that a PM module's $VERSION variable matches the XS module's &lt;code&gt;XS_VERSION&lt;/code&gt; variable. This is usually handled automatically by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;The VERSIONCHECK: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">PM 모듈의 $ VERSION 변수가 XS 모듈의 &lt;code&gt;XS_VERSION&lt;/code&gt; 변수 와 일치하는지 확인하기위한 매크로 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 자동으로 처리됩니다 . &lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;VERSIONCHECK : perlxs의 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7597f0d069d4377113f05c6161af543ea57a3c7" translate="yes" xml:space="preserve">
          <source>Macro to verify that a PM module's &lt;code&gt;$VERSION&lt;/code&gt; variable matches the XS module's &lt;code&gt;XS_VERSION&lt;/code&gt; variable. This is usually handled automatically by &lt;code&gt;xsubpp&lt;/code&gt;. See &lt;a href=&quot;perlxs#The-VERSIONCHECK%3A-Keyword&quot;&gt;&quot;The VERSIONCHECK: Keyword&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">PM 모듈의 &lt;code&gt;$VERSION&lt;/code&gt; 변수가 XS 모듈의 &lt;code&gt;XS_VERSION&lt;/code&gt; 변수 와 일치 하는지 확인하는 매크로 입니다. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 자동으로 처리됩니다 . &lt;a href=&quot;perlxs#The-VERSIONCHECK%3A-Keyword&quot;&gt;perlxs의 &quot;VERSIONCHECK : 키워드&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66fb64fe6d247cc13c8ba2ecc02f6b2d75c4b93f" translate="yes" xml:space="preserve">
          <source>Macro to verify that the perl api version an XS module has been compiled against matches the api version of the perl interpreter it's being loaded into.</source>
          <target state="translated">XS 모듈이 컴파일 된 perl api 버전이로드되는 perl 인터프리터의 api 버전과 일치하는지 확인하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="8f66f4521e615face2c94f9f782a4b88e0deefae" translate="yes" xml:space="preserve">
          <source>Macros that have string constants and their arguments as substrings of the string constants</source>
          <target state="translated">문자열 상수와 해당 인수가 문자열 상수의 하위 문자열 인 매크로</target>
        </trans-unit>
        <trans-unit id="25a3c890eb4b69b9115b7b04758963775564c7b0" translate="yes" xml:space="preserve">
          <source>Made 'dynamic_config' mandatory to reduce confusion</source>
          <target state="translated">혼란을 줄이기 위해 'dynamic_config'를 필수로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="696a489ce86f443d3bd7f260f57fe68b0f5e0740" translate="yes" xml:space="preserve">
          <source>Magic Autogeneration</source>
          <target state="translated">마술 자동 생성</target>
        </trans-unit>
        <trans-unit id="5b951438b2b5824d83645ebbc34942743d54e18e" translate="yes" xml:space="preserve">
          <source>Magic Variables</source>
          <target state="translated">마법 변수</target>
        </trans-unit>
        <trans-unit id="88fd65fe2e12d0229bfa9aa8c0f337c8c7a34525" translate="yes" xml:space="preserve">
          <source>Magic Virtual Tables</source>
          <target state="translated">매직 가상 테이블</target>
        </trans-unit>
        <trans-unit id="2de64b7079eac3534ed35bf9a982a56cf8fb08a0" translate="yes" xml:space="preserve">
          <source>Magic autogeneration increases the potential for inadvertently creating self-referential structures. Currently Perl will not free self-referential structures until cycles are explicitly broken. For example,</source>
          <target state="translated">매직 자동 생성 기능은 실수로 자기 참조 구조를 생성 할 가능성을 높입니다. 현재 Perl은주기가 명시 적으로 중단 될 때까지 자체 참조 구조를 해제하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2e0ebd98fa5e6d797bebdd2c2d2dbacb085a7bcb" translate="yes" xml:space="preserve">
          <source>Magic constants</source>
          <target state="translated">마법 상수</target>
        </trans-unit>
        <trans-unit id="9331d05bb9a05caf542c2c62dec84da956dc266b" translate="yes" xml:space="preserve">
          <source>Magical Functions</source>
          <target state="translated">마법의 기능</target>
        </trans-unit>
        <trans-unit id="680b5ac69f610dca4407e4b841e7311dee05c4d1" translate="yes" xml:space="preserve">
          <source>Magical list constants are not supported</source>
          <target state="translated">마법 목록 상수는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bc605047ccd6740cec0a34132f6861a236ee5db" translate="yes" xml:space="preserve">
          <source>Magical values and references can be made into constants at compile time, allowing for way cool stuff like this. (These error numbers aren't totally portable, alas.)</source>
          <target state="translated">컴파일 할 때 마법의 값과 참조를 상수로 만들 수 있으므로 이와 같은 멋진 기능을 사용할 수 있습니다. (이러한 오류 번호는 완전히 이식 가능하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="df66650e348a506121860cd76f075780d1c6aedd" translate="yes" xml:space="preserve">
          <source>Mail and Usenet News</source>
          <target state="translated">메일 및 유즈넷 뉴스</target>
        </trans-unit>
        <trans-unit id="c9124b10840a3572bd767d51874576c37a45a513" translate="yes" xml:space="preserve">
          <source>MailList.U</source>
          <target state="translated">MailList.U</target>
        </trans-unit>
        <trans-unit id="56482927c5fda76aa41942ba11941327d4620c99" translate="yes" xml:space="preserve">
          <source>Mailing Lists and Newsgroups</source>
          <target state="translated">메일 링리스트 및 뉴스 그룹</target>
        </trans-unit>
        <trans-unit id="d2a1123e6461654a07e49c2ea0e3f5b116e7bf06" translate="yes" xml:space="preserve">
          <source>Mailing list</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="d50c2a333e418a4af64720c969c0846d34975a97" translate="yes" xml:space="preserve">
          <source>Mailing list for Perl on OS/390</source>
          <target state="translated">OS / 390의 Perl 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="8422598c648ad701facadb193807fe8a68e5374e" translate="yes" xml:space="preserve">
          <source>Mailing list: cpan-testers-discuss@perl.org</source>
          <target state="translated">메일 링리스트 : cpan-testers-discuss@perl.org</target>
        </trans-unit>
        <trans-unit id="34f27bf89d43b27b257ba6f69d1461ec437f5745" translate="yes" xml:space="preserve">
          <source>Main Perl library</source>
          <target state="translated">메인 Perl 라이브러리</target>
        </trans-unit>
        <trans-unit id="e42a6ff891c095b97c9c8d1876b99ab388267a2b" translate="yes" xml:space="preserve">
          <source>Mainly listed here to shut up the pitiful screams of the pod coverage tests. They keep me awake at night.</source>
          <target state="translated">포드 커버리지 테스트의 불쾌한 비명을 없애기 위해 주로 여기에 나열됩니다. 그들은 밤에 깨어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb034a4bb66b7bb5137187d878df13fb04beae4" translate="yes" xml:space="preserve">
          <source>Mainly used to exclude version control administrative directories and base-level</source>
          <target state="translated">주로 버전 제어 관리 디렉토리 및 기본 수준을 제외하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a025894cae9180557ea2537add4f6943dbc4f8b" translate="yes" xml:space="preserve">
          <source>Mainly used to exclude version control administrative directories from installation.</source>
          <target state="translated">버전 제어 관리 디렉토리를 설치에서 제외하는 데 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af2040fc4cdf263d0853758e669e36927b733e94" translate="yes" xml:space="preserve">
          <source>Maintain Round Trip Integrity</source>
          <target state="translated">왕복 무결성 유지</target>
        </trans-unit>
        <trans-unit id="6cc92c03b00f2d20d0dd8de351bcdf848cd97ae9" translate="yes" xml:space="preserve">
          <source>Maintained by Ken Williams &amp;lt;KWILLIAMS@cpan.org&amp;gt;</source>
          <target state="translated">Ken Williams가 관리함 &amp;lt;KWILLIAMS@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="809e72cee268c819612dba25360f847662fc4877" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern</source>
          <target state="translated">Michael G Schwern이 관리</target>
        </trans-unit>
        <trans-unit id="3d8d67b0bc713d08e1431289fef2c4da24e0a6d9" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; within the ExtUtils-MakeMaker package and, as a separate CPAN package, by Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; .</source>
          <target state="translated">ExtUtils-MakeMaker 패키지 내에서 Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; 및 별도의 CPAN 패키지로 Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; 에서 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="d8d07256ae5a012857da9cd78f0221bd4cddaeb8" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; within the ExtUtils-MakeMaker package and, as a separate CPAN package, by Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt;.</source>
          <target state="translated">ExtUtils-MakeMaker 패키지 내에서 Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; 이 관리 하고 별도의 CPAN 패키지로 Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; 에서 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="7fabc766fc2d9f0543a1727cc606d915b6b064d9" translate="yes" xml:space="preserve">
          <source>Maintained by Peter John Acklam &amp;lt;pjacklam@gmail.com&amp;lt;gt&amp;gt;, 2014-.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@gmail.com &amp;lt;gt&amp;gt;, 2014-에 의해 관리 됨.</target>
        </trans-unit>
        <trans-unit id="471bc1c750a06353374af1e53ce3ea6cd2e96c5b" translate="yes" xml:space="preserve">
          <source>Maintained by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2011-</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2011-</target>
        </trans-unit>
        <trans-unit id="66e8214c4bf741c76a84a61b0611d2148c0182fd" translate="yes" xml:space="preserve">
          <source>Maintained by:</source>
          <target state="translated">유지 관리 :</target>
        </trans-unit>
        <trans-unit id="0fb7ae643e6e22eda1f0c20766a595198d76696b" translate="yes" xml:space="preserve">
          <source>Maintained since 1996 by The Perl Porters &amp;lt;</source>
          <target state="translated">1996 년부터 Perl Porters가 유지 보수 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="643bbd5f57059016b08fdfc7624d83297d263211" translate="yes" xml:space="preserve">
          <source>Maintainer note:</source>
          <target state="translated">관리자 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="8a3300746df857e116a8c0e1c6dce416561209ca" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;. Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN 릴리스의 관리자는 Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;입니다. CPAN 모듈의 포장과 관련하여 기술적 인 어려움이있는 경우에는 해당 담당자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="430b90ac2c360a8a68d16871970bc138c6d2cbdd" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller (smueller@cpan.org). Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN 릴리스의 관리자는 Steffen Mueller (smueller@cpan.org)입니다. CPAN 모듈의 포장과 관련하여 기술적 인 어려움이있는 경우에는 해당 담당자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="b4afb7f985f5bfec03da261851d526768b0a7bd1" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release: Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">CPAN 릴리스 관리자 : Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="53ca95cbad19caeb958b071a4ed842e8b82f2816" translate="yes" xml:space="preserve">
          <source>Maintainer: Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;.</source>
          <target state="translated">관리자 : Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="619bd6770e2cd62e7bc43b49020d0710c816e356" translate="yes" xml:space="preserve">
          <source>Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">관리자 : Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5ce563e21b8be07e4d9e4006d6894792ae6105a5" translate="yes" xml:space="preserve">
          <source>Maintainers</source>
          <target state="translated">Maintainers</target>
        </trans-unit>
        <trans-unit id="2a2a346bb89ad48931388628d64c4379a03e9c7a" translate="yes" xml:space="preserve">
          <source>Maintainers.pl</source>
          <target state="translated">Maintainers.pl</target>
        </trans-unit>
        <trans-unit id="82aa676cb87f65983d0f9f426c9258e2f5ab0e48" translate="yes" xml:space="preserve">
          <source>Maintainers.pm</source>
          <target state="translated">Maintainers.pm</target>
        </trans-unit>
        <trans-unit id="9c61980ffa7774c0d3835c4f170771e00a8354d6" translate="yes" xml:space="preserve">
          <source>Maintaining a bundle definition file means keeping track of two things: dependencies and interactivity. CPAN.pm sometimes fails on calculating dependencies because not all modules define all MakeMaker attributes correctly, so a bundle definition file should specify prerequisites as early as possible. On the other hand, it's annoying that so many distributions need some interactive configuring. So what you can try to accomplish in your private bundle file is to have the packages that need to be configured early in the file and the gentle ones later, so you can go out for coffee after a few minutes and leave CPAN.pm to churn away unattended.</source>
          <target state="translated">번들 정의 파일을 유지 관리한다는 것은 종속성과 상호 작용이라는 두 가지 사항을 추적하는 것을 의미합니다. 모든 모듈이 모든 MakeMaker 속성을 올바르게 정의하지는 않기 때문에 CPAN.pm이 종속성 계산에 실패하는 경우가 있으므로 번들 정의 파일은 사전 요구 사항을 가능한 빨리 지정해야합니다. 반면에, 많은 배포판에 대화식 구성이 필요한 것은 성가신 일입니다. 따라서 개인 번들 파일에서 달성하려고 할 수있는 것은 파일의 초기에 구성해야하는 패키지와 나중에 부드러운 패키지를 갖는 것입니다. 따라서 몇 분 후에 커피를 마시고 CPAN.pm을 이탈 할 수 있습니다. 무인 상태로.</target>
        </trans-unit>
        <trans-unit id="683b0250521f89ab5a7d8609ffca71e78293a058" translate="yes" xml:space="preserve">
          <source>Maintaining a persistent interpreter</source>
          <target state="translated">지속적인 통역사 유지</target>
        </trans-unit>
        <trans-unit id="e88a9990f5d2ac06c40799dcdbc0bd3efadf5b36" translate="yes" xml:space="preserve">
          <source>Maintaining multiple interpreter instances</source>
          <target state="translated">여러 개의 인터프리터 인스턴스 유지</target>
        </trans-unit>
        <trans-unit id="b029f6d7dda6875610cf345a0d379a80456960cd" translate="yes" xml:space="preserve">
          <source>Maintaining the urllist parameter</source>
          <target state="translated">urllist 매개 변수 유지 보수</target>
        </trans-unit>
        <trans-unit id="6f70b10eb8a3bbc7f2d0b2c546e6531ac6d2bbc3" translate="yes" xml:space="preserve">
          <source>Maintenance is now done by cperl &lt;a href=&quot;http://perl11.org/cperl&quot;&gt;http://perl11.org/cperl&lt;/a&gt;</source>
          <target state="translated">유지 관리는 이제 cperl &lt;a href=&quot;http://perl11.org/cperl&quot;&gt;http://perl11.org/cperl에&lt;/a&gt; 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb8b463e1c71f307f7fc72628792a15f4e1bd31" translate="yes" xml:space="preserve">
          <source>Maintenance is now done by the perl5-porters</source>
          <target state="translated">perl5 포터가 유지 보수를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="181c04cdf23fecb3236b336490e5b2cafa1a0b7f" translate="yes" xml:space="preserve">
          <source>Maintenance versions should only be altered to add critical bug fixes, see &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;.</source>
          <target state="translated">유지 보수 버전은 중요한 버그 수정을 추가하기 위해서만 변경되어야합니다 . &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ed12a7152f7b0abf838c20d65d39c62ba0a8766" translate="yes" xml:space="preserve">
          <source>Makamaka Hannyaharamitu, &amp;lt;makamaka[at]cpan.org&amp;gt;</source>
          <target state="translated">Makamaka Hannyaharamitu, &amp;lt;makamaka[at]cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a94431ee22f05f141107f9355ed3127d0f0c4d5a" translate="yes" xml:space="preserve">
          <source>Make</source>
          <target state="translated">Make</target>
        </trans-unit>
        <trans-unit id="890209e34ccf3fc03b7d07817868a97cdbfea649" translate="yes" xml:space="preserve">
          <source>Make Rule 1</source>
          <target state="translated">규칙 1 만들기</target>
        </trans-unit>
        <trans-unit id="c7128fd2836e77abc7fc2fd97115996dd6b6b258" translate="yes" xml:space="preserve">
          <source>Make Rule 2</source>
          <target state="translated">규칙 2 만들기</target>
        </trans-unit>
        <trans-unit id="04eff5d74d7ffc64b3c7d9b1b09aff266f1e0a57" translate="yes" xml:space="preserve">
          <source>Make a bootstrap file for use by DynaLoader</source>
          <target state="translated">DynaLoader에서 사용할 부트 스트랩 파일 만들기</target>
        </trans-unit>
        <trans-unit id="1b789b62a7dc7a41add071dab3e403c719b4a9f2" translate="yes" xml:space="preserve">
          <source>Make a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을 만드십시오. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 &quot;경량 콜백&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a9fad7783334940c292ba0169f35e46fcaae627" translate="yes" xml:space="preserve">
          <source>Make a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을 만드십시오. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cb6efc54c38064ba236700f9dcc12b0629e07ff" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새 &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 객체를 만들고 반환합니다. 주어진 모든 인수를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="f15e6a07de5aec5f1e96a02e428c35fecd418678" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;TAP::Parser::IteratorFactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새 &lt;a href=&quot;TAP::Parser::IteratorFactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt; 객체를 만들고 반환합니다. 주어진 모든 인수를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="ea4827e6585683095f4c0885205596b5426a5ef3" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object using the parser's &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;, and return it. Passes through any arguments given.</source>
          <target state="translated">파서의 &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP :: Parser :: ResultFactory를&lt;/a&gt; 사용하여 새 &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 객체를 만들고 반환합니다. 주어진 모든 인수를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="2b212bd484216f27062e119a0984e12eb2f1ca4b" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새로운 &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="d5ad132f57df20c380d03727edf6efc89d530812" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새로운 &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="fa28fa8c90cb86c9b3f8c83899652b5dd29ba4e0" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object using the parser's &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;, and return it. Passes through any arguments given.</source>
          <target state="translated">파서의 &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory를&lt;/a&gt; 사용하여 새로운 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="3a0cb5edb690cd6db709e001b8158abfba90d3f9" translate="yes" xml:space="preserve">
          <source>Make a new parser and display formatter session. Typically used and/or overridden in subclasses.</source>
          <target state="translated">새로운 파서 및 디스플레이 포맷터 세션을 만듭니다. 일반적으로 서브 클래스에서 사용 및 / 또는 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f4f6bf31d70d3b5261f262791889974009fba962" translate="yes" xml:space="preserve">
          <source>Make and return a complete copy of the cop hints hash</source>
          <target state="translated">경찰 힌트 해시의 전체 사본을 만들어 반환</target>
        </trans-unit>
        <trans-unit id="ad04abc96b9c23f58bf05411355a885d67609d70" translate="yes" xml:space="preserve">
          <source>Make and return a complete copy of the cop hints hash &lt;code&gt;cophh&lt;/code&gt;.</source>
          <target state="translated">경찰 힌트 해시 &lt;code&gt;cophh&lt;/code&gt; 의 완전한 사본을 만들고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b886b01d91d82d72977b5c37dc6c5f47e7167a8" translate="yes" xml:space="preserve">
          <source>Make bsd_glob() return an error (GLOB_NOSPACE) when the pattern expands to a size bigger than the system constant &lt;code&gt;ARG_MAX&lt;/code&gt; (usually found in limits.h). If your system does not define this constant, bsd_glob() uses &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; or &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; where available (in that order). You can inspect these values using the standard &lt;code&gt;POSIX&lt;/code&gt; extension.</source>
          <target state="translated">패턴이 시스템 상수 &lt;code&gt;ARG_MAX&lt;/code&gt; (보통 limits.h에 있음) 보다 큰 크기로 확장 될 때 bsd_glob ()가 오류 (GLOB_NOSPACE)를 리턴하게하십시오 . 시스템이이 상수를 정의하지 않으면 bsd_glob ()는 사용 가능한 경우 (순서대로) &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; 또는 &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; 를 사용합니다. 표준 &lt;code&gt;POSIX&lt;/code&gt; 확장을 사용하여이 값을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08523af5b76fef9eaed2b77615eb4a213597d67b" translate="yes" xml:space="preserve">
          <source>Make functions faster by trading space for time</source>
          <target state="translated">시간을위한 공간을 거래하여 더 빠른 기능</target>
        </trans-unit>
        <trans-unit id="6103567e9e837abb5d1943da6a6814ed98577b8b" translate="yes" xml:space="preserve">
          <source>Make pattern matching case-insensitive.</source>
          <target state="translated">패턴 일치를 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b434c4028abbf501b87f9ee8429bc6772c12c60" translate="yes" xml:space="preserve">
          <source>Make perl executable and create a symlink for libperl:</source>
          <target state="translated">perl을 실행 가능하게하고 libperl에 대한 symlink를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cb00e29cd519edaa5436add62cd37675b6854ffa" translate="yes" xml:space="preserve">
          <source>Make some changes, build perl and test your changes, then commit them to your local branch. Then push your local branch to a remote smoke-me branch:</source>
          <target state="translated">몇 가지 변경을 수행하고 펄을 빌드하고 변경 사항을 테스트 한 다음 로컬 브랜치에 커밋합니다. 그런 다음 로컬 브랜치를 원격 smoke-me 브랜치로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="c9c4fd59ea8eb511f1da67cfee226b250f7a4749" translate="yes" xml:space="preserve">
          <source>Make sure &lt;a href=&quot;#gethostbyname-NAME&quot;&gt;&lt;code&gt;gethostbyname&lt;/code&gt;&lt;/a&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">&lt;a href=&quot;#gethostbyname-NAME&quot;&gt; &lt;code&gt;gethostbyname&lt;/code&gt; &lt;/a&gt; 이 SCALAR 컨텍스트에서 호출되고 리턴 값이 정의 되었는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="631c39697ec2fc47f9fdac3b73868b5eac8535e4" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">확인 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; 스칼라 문맥에서 그 리턴 값이 definedness을 위해 선택되어 있는지이라고합니다.</target>
        </trans-unit>
        <trans-unit id="1af92bfd9067c908f166333d8740f6095af6a588" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">확인 &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; 스칼라 문맥에서 그 리턴 값이 definedness을 위해 선택되어 있는지이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9aee806c3df793514446c4364ffe009cca7c0176" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;CPAN.pm&lt;/code&gt; can download files from CPAN. If not, you may need to manually install &lt;code&gt;Net::FTP&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 이 CPAN에서 파일을 다운로드 할 수 있는지 확인하십시오 . 그렇지 않은 경우 &lt;code&gt;Net::FTP&lt;/code&gt; 를 수동으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ab54a8b3ec25f60b45ddf50dac5e3bb5f61317d" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;CPAN.pm&lt;/code&gt; can download files from CPAN. If not, you may need to manually install &lt;code&gt;Net::FTP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 이 CPAN에서 파일을 다운로드 할 수 있는지 확인하십시오 . 그렇지 않은 경우 &lt;code&gt;Net::FTP&lt;/code&gt; 를 수동으로 설치해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d90bf5e032808a1790937eefc282a0216577eb91" translate="yes" xml:space="preserve">
          <source>Make sure that the directory &lt;b&gt;above&lt;/b&gt; the directory with manpages is on our &lt;code&gt;MANPATH&lt;/code&gt; , like this</source>
          <target state="translated">디렉토리에 있는지 확인하십시오 &lt;b&gt;위의&lt;/b&gt; 맨 페이지와 디렉토리가 우리에 &lt;code&gt;MANPATH&lt;/code&gt; 같이,</target>
        </trans-unit>
        <trans-unit id="a8decd758e6ca0f6998ca613347958cb822b733d" translate="yes" xml:space="preserve">
          <source>Make sure that the directory &lt;b&gt;above&lt;/b&gt; the directory with manpages is on our &lt;code&gt;MANPATH&lt;/code&gt;, like this</source>
          <target state="translated">맨 페이지가 있는 디렉토리 &lt;b&gt;위&lt;/b&gt; 의 디렉토리가 다음과 같이 &lt;code&gt;MANPATH&lt;/code&gt; 에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6d62a68cc52f846e8b7cd7e34bad20513f656424" translate="yes" xml:space="preserve">
          <source>Make sure that the installed modules are actually installed in the location of the new Perl, and are not inherited from entries of @INC given for inheritance from the older versions of Perl: set &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; to redirect the new version of Perl to a new location, and copy the installed files to this new location. Redo the tests to make sure that the versions of modules inherited from older versions of Perl are not needed.</source>
          <target state="translated">설치된 모듈이 실제로 새 Perl의 위치에 설치되어 있고 이전 버전의 Perl에서 상속하도록 제공된 @INC 항목에서 상속되지 않았는지 확인하십시오. Perl 의 새 버전을 새 위치로 경로 재 지정하려면 &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; 를 설정 하십시오 . 설치된 파일을이 새 위치로 복사하십시오. 테스트를 다시 실행하여 이전 버전의 Perl에서 상속 된 모듈 버전이 필요하지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8e40ae3a79feffa50f9360f35cfc29b12c2563ad" translate="yes" xml:space="preserve">
          <source>Make sure that you &lt;code&gt;make realclean&lt;/code&gt; in your copy of Perl to remove any build artifacts, or you may get a confusing result.</source>
          <target state="translated">빌드 아티팩트를 제거하기 위해 Perl 사본을 실제로 &lt;code&gt;make realclean&lt;/code&gt; 하십시오 . 그렇지 않으면 혼란스러운 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48620eee0813f53db06b1d13fb05c7d0b30ec92" translate="yes" xml:space="preserve">
          <source>Make sure that your module has a license, and that the full text of it is included in the distribution (unless it's a common one and the terms of the license don't require you to include it).</source>
          <target state="translated">모듈에 라이센스가 있는지 확인하고 배포에 포함 된 전체 텍스트가 배포에 포함되어 있는지 확인하십시오 (일반적인 라이센스 조건에 포함하지 않아도 됨).</target>
        </trans-unit>
        <trans-unit id="b4b22689c7f11757036113b227d7cdc8128156e0" translate="yes" xml:space="preserve">
          <source>Make sure the commit message describes your change in a single sentence. For example, &quot;Fixed spelling errors in perlhack.pod&quot;.</source>
          <target state="translated">커밋 메시지가 한 문장으로 변경 사항을 설명하는지 확인하십시오. 예를 들어 &quot;perlhack.pod의 맞춤법 오류가 수정되었습니다.&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="31c004e759b68f9d5539083901242f08c624a89b" translate="yes" xml:space="preserve">
          <source>Make sure the newlines for the modules are in Mac format, not Unix format. If they are not then you might have decompressed them incorrectly. Check your decompression and unpacking utilities settings to make sure they are translating text files properly.</source>
          <target state="translated">모듈의 줄 바꿈이 Unix 형식이 아닌 Mac 형식인지 확인하십시오. 그렇지 않은 경우 압축이 제대로 풀리지 않았을 수 있습니다. 압축 해제 및 포장 풀기 유틸리티 설정이 텍스트 파일을 올바르게 번역하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0da095bfcf60a5da0d5078d4fb200d212838fa47" translate="yes" xml:space="preserve">
          <source>Make sure the patch is not reversed (the first argument to diff is typically the original file, the second argument your changed file). Make sure you test your patch by applying it with &lt;code&gt;git am&lt;/code&gt; or the &lt;code&gt;patch&lt;/code&gt; program before you send it on its way. Try to follow the same style as the code you are trying to patch. Make sure your patch really does work (&lt;code&gt;make test&lt;/code&gt; , if the thing you're patching is covered by Perl's test suite).</source>
          <target state="translated">패치가 반전되지 않았는지 확인하십시오 (diff의 첫 번째 인수는 일반적으로 원본 파일이고 두 번째 인수는 변경된 파일입니다). 패치를 적용하여 패치를 테스트하십시오 &lt;code&gt;git am&lt;/code&gt; 또는 &lt;code&gt;patch&lt;/code&gt; 프로그램 하여 패치 를 보내기 전에 . 패치하려는 코드와 동일한 스타일을 따르십시오. 반드시 여러분의 패치 진짜로 일 (확인 &lt;code&gt;make test&lt;/code&gt; , 것은 당신이있는 거 패치가 펄의 테스트 스위트에 포함되어있는 경우)를.</target>
        </trans-unit>
        <trans-unit id="bda29a86fe66e1909a0c4600719933cf688a2cb2" translate="yes" xml:space="preserve">
          <source>Make sure the patch is not reversed (the first argument to diff is typically the original file, the second argument your changed file). Make sure you test your patch by applying it with &lt;code&gt;git am&lt;/code&gt; or the &lt;code&gt;patch&lt;/code&gt; program before you send it on its way. Try to follow the same style as the code you are trying to patch. Make sure your patch really does work (&lt;code&gt;make test&lt;/code&gt;, if the thing you're patching is covered by Perl's test suite).</source>
          <target state="translated">패치가 반전되지 않았는지 확인하십시오 (diff의 첫 번째 인수는 일반적으로 원본 파일이고 두 번째 인수는 변경된 파일 임). &lt;code&gt;patch&lt;/code&gt; 를 보내기 전에 &lt;code&gt;git am&lt;/code&gt; 또는 패치 프로그램 을 사용하여 패치를 적용하여 테스트했는지 확인하십시오 . 패치하려는 코드와 동일한 스타일을 따르십시오. 패치가 실제로 작동하는지 확인하십시오 (패치 하는 것이 Perl의 테스트 스위트에 포함되는 경우 &lt;code&gt;make test&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fe3ef49c50e09399f8e7e0ae50f650120ed9ba3" translate="yes" xml:space="preserve">
          <source>Make sure the path to the build directory does not contain spaces. The build usually works in this circumstance, but some tests will fail.</source>
          <target state="translated">빌드 디렉토리 경로에 공백이 없는지 확인하십시오. 빌드는 일반적으로이 상황에서 작동하지만 일부 테스트는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b12b8debe1b2db03630198cf21bf4b854e3bc2a9" translate="yes" xml:space="preserve">
          <source>Make sure to read about creating modules in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; and the perils of indirect objects in &lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;&quot;Method Invocation&quot; in perlobj&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 에서 모듈을 만드는 &lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;방법과 perlobj의 &quot;Method Invocation&quot;에서&lt;/a&gt; 간접 객체의 위험에 대해 읽어보세요 .</target>
        </trans-unit>
        <trans-unit id="b25e9d6769a32bda0cb16adea51fc9a9577bd44e" translate="yes" xml:space="preserve">
          <source>Make sure to read about creating modules in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; and the perils of indirect objects in &lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;Method Invocation in perlobj&lt;/a&gt;.</source>
          <target state="translated">에 모듈 만들기에 대해 읽어보십시오 &lt;a href=&quot;perlmod&quot;&gt;&lt;/a&gt;&lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;perlobj의 메소드 호출에서 &lt;/a&gt;perlmod 및 간접 오브젝트의 위험에 .</target>
        </trans-unit>
        <trans-unit id="83ed513e31fceec21b34e65bf0ccb8e2f135bfc2" translate="yes" xml:space="preserve">
          <source>Make sure you are in the &quot;win32&quot; subdirectory under the perl toplevel. This directory contains a &quot;Makefile&quot; that will work with versions of nmake that come with Visual C++ or the Windows SDK, and a GNU make &quot;GNUmakefile&quot; or dmake &quot;makefile.mk&quot; that will work for all supported compilers. The defaults in the gmake and dmake makefile are setup to build using MinGW/gcc.</source>
          <target state="translated">Perl 최상위 아래의 &quot;win32&quot;하위 디렉토리에 있는지 확인하십시오. 이 디렉토리에는 Visual C ++ 또는 Windows SDK와 함께 제공되는 nmake 버전에서 작동하는 &quot;Makefile&quot;과 지원되는 모든 컴파일러에서 작동하는 GNU make &quot;GNUmakefile&quot;또는 dmake &quot;makefile.mk&quot;가 포함되어 있습니다. gmake 및 dmake makefile의 기본값은 MinGW / gcc를 사용하여 빌드하도록 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bbcc12fd16263e19bc5318e960269249316b2e" translate="yes" xml:space="preserve">
          <source>Make sure you are in the &quot;win32&quot; subdirectory under the perl toplevel. This directory contains a &quot;Makefile&quot; that will work with versions of nmake that come with Visual C++ or the Windows SDK, and a dmake &quot;makefile.mk&quot; that will work for all supported compilers. The defaults in the dmake makefile are setup to build using MinGW/gcc.</source>
          <target state="translated">perl 최상위 레벨의 &quot;win32&quot;서브 디렉토리에 있는지 확인하십시오. 이 디렉토리에는 Visual C ++ 또는 Windows SDK와 함께 제공되는 nmake 버전과 작동하는 &quot;Makefile&quot;및 지원되는 모든 컴파일러에서 작동하는 dmake &quot;makefile.mk&quot;가 포함되어 있습니다. dmake makefile의 기본값은 MinGW / gcc를 사용하여 빌드하도록 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b578a0bba566a5e009cf7a1e8f93afb16265f4fa" translate="yes" xml:space="preserve">
          <source>Make sure you choose an appropriate name for your module early on. This will help people find and remember your module, and make programming with your module more intuitive.</source>
          <target state="translated">초기에 모듈에 적절한 이름을 선택하십시오. 이를 통해 사람들은 모듈을 찾고 기억하며 모듈을 사용하여 프로그래밍을보다 직관적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8dca7eb87954059e67d6baf9d117854dccfc284" translate="yes" xml:space="preserve">
          <source>Make sure you have MMS (from Digital) or the freeware MMK ( available from MadGoat at &lt;a href=&quot;http://www.madgoat.com&quot;&gt;http://www.madgoat.com&lt;/a&gt; ). Then type this to create the DESCRIP.MMS for the module:</source>
          <target state="translated">MMS (디지털) 또는 프리웨어 MMK (MadGoat ( &lt;a href=&quot;http://www.madgoat.com&quot;&gt;http://www.madgoat.com)&lt;/a&gt; 에서 제공)가 있는지 확인하십시오 . ) . 그런 다음 이것을 입력하여 모듈에 대한 DESCRIP.MMS를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="41203b5dff78423d936ef4a4e1c0f8291555b765" translate="yes" xml:space="preserve">
          <source>Make sure you have a good commit message. See &lt;a href=&quot;perlhack#Commit-message&quot;&gt;&quot;Commit message&quot; in perlhack&lt;/a&gt; for details.</source>
          <target state="translated">좋은 커밋 메시지가 있는지 확인하십시오. 자세한 내용 &lt;a href=&quot;perlhack#Commit-message&quot;&gt;은 perlhack의 &quot;커밋 메시지&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45bcb550cc19143c5e8dd91291c0c6d1da90642e" translate="yes" xml:space="preserve">
          <source>Make sure you have the appropriate permissions to install the module in your Perl 5 library directory. Often, you'll need to be root.</source>
          <target state="translated">Perl 5 라이브러리 디렉토리에 모듈을 설치할 수있는 적절한 권한이 있는지 확인하십시오. 종종 루트가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c6288609b67d4900e3a7acdb0708c647b7ddea0" translate="yes" xml:space="preserve">
          <source>Make sure you use a tab and not spaces on the lines beginning with &quot;$(AR)&quot; and &quot;$(RANLIB)&quot;. Make will not function properly if you use spaces. It has also been reported that the &quot;cr&quot; argument to $(AR) is unnecessary on Win32 systems.</source>
          <target state="translated">&quot;$ (AR)&quot;및 &quot;$ (RANLIB)&quot;로 시작하는 줄에는 공백이 아닌 탭을 사용해야합니다. 공백을 사용하면 Make가 제대로 작동하지 않습니다. 또한 Win32 시스템에서 $ (AR)에 대한 &quot;cr&quot;인수가 필요하지 않다고보고되었습니다.</target>
        </trans-unit>
        <trans-unit id="6aa0752b0b4c6627413012df0488bf1ad6b435f3" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes the compiler (/opt/SUNWspro/bin/ if you're using Sun's compiler) as well as /usr/ccs/bin/ to pick up the other development tools (such as make, ar, as, and ld). Make sure your path either doesn't include /usr/ucb or that it includes it after the compiler and compiler tools and other standard Solaris directories. You definitely don't want /usr/ucb/cc.</source>
          <target state="translated">PATH에 다른 개발 도구 (예 : make, ar, as 및 ld). 경로에 / usr / ucb가 포함되어 있지 않거나 컴파일러 및 컴파일러 도구 및 기타 표준 Solaris 디렉토리 다음에 경로가 포함되어 있는지 확인하십시오. / usr / ucb / cc를 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da98ff8151fcc7f9259493c3bc630b4f6abd18b6" translate="yes" xml:space="preserve">
          <source>Make sure your gcc is good for &lt;code&gt;-Zomf&lt;/code&gt; linking: run &lt;code&gt;omflibs&lt;/code&gt; script in</source>
          <target state="translated">gcc가 &lt;code&gt;-Zomf&lt;/code&gt; 연결에 적합한 지 확인 : &lt;code&gt;omflibs&lt;/code&gt; 실행 스크립트에</target>
        </trans-unit>
        <trans-unit id="a248163580a9e29ef4a7312495856815f271337b" translate="yes" xml:space="preserve">
          <source>Make the first argument a copy of the second, then delete the original. The target SV physically takes over ownership of the body of the source SV and inherits its flags; however, the target keeps any magic it owns, and any magic in the source is discarded. Note that this is a rather specialist SV copying operation; most of the time you'll want to use &lt;code&gt;sv_setsv&lt;/code&gt; or one of its many macro front-ends.</source>
          <target state="translated">첫 번째 인수를 두 번째 인수로 복사 한 다음 원본을 삭제하십시오. 대상 SV는 물리적으로 소스 SV 본문의 소유권을 인수하고 해당 플래그를 상속합니다. 그러나 대상은 자신이 소유 한 마법을 유지하고 소스의 마법은 버립니다. 이것은 다소 전문적인 SV 복사 작업입니다. 대부분의 경우 &lt;code&gt;sv_setsv&lt;/code&gt; 또는 많은 매크로 프론트 엔드 중 하나 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="f4bb5d8584647cb5cbfe371da2ee93cc6742e08f" translate="yes" xml:space="preserve">
          <source>Make the most of the opportunity.</source>
          <target state="translated">기회를 최대한 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="0aff0a17d7bda6c607f6b94065807887a26ea78b" translate="yes" xml:space="preserve">
          <source>Make the specified modules.</source>
          <target state="translated">지정된 모듈을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="87a3a748935c5363a3cfdc69fbfc39c4592f4900" translate="yes" xml:space="preserve">
          <source>Make the string $content be the content for the file named $file.</source>
          <target state="translated">문자열 $ content를 $ file이라는 파일의 내용으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b14a5a45500c708bfc2adecf45938f8ddfc95c0a" translate="yes" xml:space="preserve">
          <source>Make updating the '1..42' string unnecessary. Or make sure that you update it.</source>
          <target state="translated">'1..42'문자열을 업데이트하지 않아도됩니다. 또는 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="fec86bec8c09394515f33cb2e0c1c11e1bbbc3fc" translate="yes" xml:space="preserve">
          <source>Make your change</source>
          <target state="translated">당신의 변화를</target>
        </trans-unit>
        <trans-unit id="596d9cf2b55f30476a38bd041bc47cf1626a134d" translate="yes" xml:space="preserve">
          <source>Make your module use the Test::Tester::Capture object instead of the Test::Builder one. How to do this depends on your module but assuming that your module holds the Test::Builder object in $Test and that all your test routines access it through $Test then providing a function something like this</source>
          <target state="translated">모듈에서 Test :: Builder 대신 Test :: Tester :: Capture 개체를 사용하도록합니다. 이를 수행하는 방법은 모듈에 따라 다르지만 모듈이 $ Test의 Test :: Builder 객체를 보유하고 모든 테스트 루틴이 $ Test를 통해 액세스하고 다음과 같은 함수를 제공한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="951e86d639f2ed613d02f1c077ce05396f017abb" translate="yes" xml:space="preserve">
          <source>MakeMaker (as of 6.31) and Module::Build (as of 0.28) both can install to the same locations using the &quot;install_base&quot; concept. See &lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;INSTALL_BASE in ExtUtils::MakeMaker&lt;/a&gt; for details. To get MM and MB to install to the same location simply set INSTALL_BASE in MM and &lt;code&gt;--install_base&lt;/code&gt; in MB to the same location.</source>
          <target state="translated">MakeMaker (6.31 현재) 및 Module :: Build (0.28 현재)는 &quot;install_base&quot;개념을 사용하여 동일한 위치에 설치할 수 있습니다. 자세한 내용 &lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;은 ExtUtils :: MakeMaker의 INSTALL_BASE를&lt;/a&gt; 참조 하십시오. MM과 MB를 같은 위치에 설치하려면 MM의 INSTALL_BASE와 MB의 &lt;code&gt;--install_base&lt;/code&gt; 를 같은 위치로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5c9d90bcb0e3741266cfc2e63ed8d7436fe1c84f" translate="yes" xml:space="preserve">
          <source>MakeMaker (as of 6.31) and Module::Build (as of 0.28) both can install to the same locations using the &quot;install_base&quot; concept. See &lt;a href=&quot;ExtUtils::MakeMaker#INSTALL_BASE&quot;&gt;&quot;INSTALL_BASE&quot; in ExtUtils::MakeMaker&lt;/a&gt; for details. To get MM and MB to install to the same location simply set INSTALL_BASE in MM and &lt;code&gt;--install_base&lt;/code&gt; in MB to the same location.</source>
          <target state="translated">MakeMaker (6.31부터) 및 Module :: Build (0.28부터)는 모두 &quot;install_base&quot;개념을 사용하여 동일한 위치에 설치할 수 있습니다. 자세한 내용 &lt;a href=&quot;ExtUtils::MakeMaker#INSTALL_BASE&quot;&gt;은 ExtUtils :: MakeMaker의 &quot;INSTALL_BASE&quot;&lt;/a&gt; 를 참조하십시오. MM과 MB를 동일한 위치에 설치하려면 MM의 INSTALL_BASE와 MB의 &lt;code&gt;--install_base&lt;/code&gt; 를 동일한 위치로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f57976a42f4d4f108960d3047b05d9b0bd7410ad" translate="yes" xml:space="preserve">
          <source>MakeMaker also checks for any files matching glob(&quot;t/*.t&quot;). It will execute all matching files in alphabetical order via the &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; module with the &lt;code&gt;-I&lt;/code&gt; switches set correctly.</source>
          <target state="translated">MakeMaker는 glob ( &quot;t / *. t&quot;)와 일치하는 파일도 확인합니다. &lt;code&gt;-I&lt;/code&gt; 스위치가 올바르게 설정된 &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 모듈을 통해 일치하는 모든 파일을 알파벳 순서로 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="181073f157ed87afd7d4a36cdc4890d3df65a53c" translate="yes" xml:space="preserve">
          <source>MakeMaker also checks for any files matching glob(&quot;t/*.t&quot;). It will execute all matching files in alphabetical order via the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; module with the &lt;code&gt;-I&lt;/code&gt; switches set correctly.</source>
          <target state="translated">MakeMaker는 glob ( &quot;t / *. t&quot;)와 일치하는 파일도 확인합니다. &lt;code&gt;-I&lt;/code&gt; 스위치가 올바르게 설정된 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 모듈을 통해 일치하는 모든 파일을 알파벳순으로 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="ea4d9ecb21fe83e2ef44aa02cc6eba3ee3c63cf7" translate="yes" xml:space="preserve">
          <source>MakeMaker also honors the MAKE environment variable. This parameter takes precedence.</source>
          <target state="translated">MakeMaker는 또한 MAKE 환경 변수를 존중합니다. 이 매개 변수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="6ce95146fa946e6764eac19b0f7702edb2af3abd" translate="yes" xml:space="preserve">
          <source>MakeMaker can run programs to generate files for you at build time. By default any file named *.PL (except Makefile.PL and Build.PL) in the top level directory will be assumed to be a Perl program and run passing its own basename in as an argument. For example...</source>
          <target state="translated">MakeMaker는 빌드시 프로그램을 실행하여 파일을 생성 할 수 있습니다. 기본적으로 최상위 레벨 디렉토리에 * .PL이라는 이름의 파일 (Makefile.PL 및 Build.PL 제외)은 Perl 프로그램으로 간주되며 자체 기본 이름을 인수로 전달하여 실행됩니다. 예를 들어 ...</target>
        </trans-unit>
        <trans-unit id="0b27f17fb6be8902dd15dc474df4292373ebba16" translate="yes" xml:space="preserve">
          <source>MakeMaker can run programs to generate files for you at build time. By default any file named *.PL (except Makefile.PL and Build.PL) in the top level directory will be assumed to be a Perl program and run passing its own basename in as an argument. This basename is actually a build target, and there is an intention, but not a requirement, that the *.PL file make the file passed to to as an argument. For example...</source>
          <target state="translated">MakeMaker는 빌드시 파일을 생성하는 프로그램을 실행할 수 있습니다. 기본적으로 최상위 디렉토리에있는 * .PL (Makefile.PL 및 Build.PL 제외)이라는 이름의 파일은 Perl 프로그램으로 간주되며 자체 기본 이름을 인수로 전달하여 실행됩니다. 이 기본 이름은 실제로 빌드 대상이며 * .PL 파일이 파일을 인수로 전달하도록하는 의도가 있지만 요구 사항은 아닙니다. 예를 들면 ...</target>
        </trans-unit>
        <trans-unit id="f4a59e2381035838e81553acd07a6dbd71a643d2" translate="yes" xml:space="preserve">
          <source>MakeMaker checks for the existence of a file named</source>
          <target state="translated">MakeMaker는 이름이 지정된 파일이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7e46986c8cad84d029006573feccd2e12b58af53" translate="yes" xml:space="preserve">
          <source>MakeMaker comes with a default MANIFEST.SKIP to avoid things like version control directories and backup files. Specifying your own will override this default.</source>
          <target state="translated">버전 관리 디렉토리 및 백업 파일과 같은 것을 피하기 위해 MakeMaker에는 기본 MANIFEST.SKIP가 제공됩니다. 자신을 지정하면이 기본값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9177c899e90b4ecb1a9e016234bba13b638eedd6" translate="yes" xml:space="preserve">
          <source>MakeMaker gives you much more freedom than needed to configure internal variables and get different results. It is worth mentioning that make(1) also lets you configure most of the variables that are used in the Makefile. But in the majority of situations this will not be necessary, and should only be done if the author of a package recommends it (or you know what you're doing).</source>
          <target state="translated">MakeMaker는 내부 변수를 구성하고 다른 결과를 얻는 데 필요한 것보다 훨씬 많은 자유를 제공합니다. make (1)을 사용하면 Makefile에 사용되는 대부분의 변수를 구성 할 수 있습니다. 그러나 대부분의 상황에서 이것은 필요하지 않으며 패키지 작성자가 권장하는 경우에만 수행해야합니다 (또는 사용자가 수행중인 작업을 알고 있음).</target>
        </trans-unit>
        <trans-unit id="666dfa9a2df2803aca52ee89b75129726d38981a" translate="yes" xml:space="preserve">
          <source>MakeMaker modules are installed using this simple mantra</source>
          <target state="translated">이 간단한 만트라를 사용하여 MakeMaker 모듈이 설치됩니다</target>
        </trans-unit>
        <trans-unit id="6eebe1cd37eee2ec321b36b14411ecc5f97674e6" translate="yes" xml:space="preserve">
          <source>MakeMaker needs to know, or to guess, where certain things are located. Especially INST_LIB and INST_ARCHLIB (where to put the files during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read existing modules from), and PERL_INC (header files and &lt;code&gt;libperl*.*&lt;/code&gt;).</source>
          <target state="translated">MakeMaker는 특정 물건의 위치를 ​​알고 있거나 추측해야합니다. 특히 INST_LIB 및 INST_ARCHLIB (make (1) 실행 중에 파일을 넣을 위치), PERL_LIB 및 PERL_ARCHLIB (기존 모듈을 읽을 위치) 및 PERL_INC (헤더 파일 및 &lt;code&gt;libperl*.*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1794fe2317715149406a57e4edb43a113c75b0e3" translate="yes" xml:space="preserve">
          <source>MakeMaker object hierarchy (real)</source>
          <target state="translated">MakeMaker 개체 계층 (실제)</target>
        </trans-unit>
        <trans-unit id="5c459908262333c218dd37bde4b33c42a42bd948" translate="yes" xml:space="preserve">
          <source>MakeMaker object hierarchy (simplified)</source>
          <target state="translated">MakeMaker 개체 계층 (단순화)</target>
        </trans-unit>
        <trans-unit id="955e1b765c6718c7db11e68ac1240b76cf36838e" translate="yes" xml:space="preserve">
          <source>MakeMaker will figure out if an extension contains linkable code anywhere down the directory tree, and will set this variable accordingly, but you can speed it up a very little bit if you define this boolean variable yourself.</source>
          <target state="translated">MakeMaker는 디렉토리 트리 아래에 링크 가능한 코드가 확장에 포함되어 있는지 확인하고 그에 따라이 변수를 설정하지만이 부울 변수를 직접 정의하면 속도를 약간 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bbacb6ac277a541e0abc4615218907895ae391a" translate="yes" xml:space="preserve">
          <source>MakeMaker will turn it into an array with one element.</source>
          <target state="translated">MakeMaker는 하나의 요소를 가진 배열로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e6de50a7c31889077966d7620ec5db61a68c67cc" translate="yes" xml:space="preserve">
          <source>MakeMaker.pm uses the architecture-specific information from Config.pm. In addition it evaluates architecture specific hints files in a &lt;code&gt;hints/&lt;/code&gt; directory. The hints files are expected to be named like their counterparts in &lt;code&gt;PERL_SRC/hints&lt;/code&gt; , but with an &lt;code&gt;.pl&lt;/code&gt; file name extension (eg. &lt;code&gt;next_3_2.pl&lt;/code&gt; ). They are simply &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed by MakeMaker within the WriteMakefile() subroutine, and can be used to execute commands as well as to include special variables. The rules which hintsfile is chosen are the same as in Configure.</source>
          <target state="translated">MakeMaker.pm은 Config.pm의 아키텍처 별 정보를 사용합니다. 또한 &lt;code&gt;hints/&lt;/code&gt; 디렉토리 에서 아키텍처 별 힌트 파일을 평가 합니다. 힌트 파일은 &lt;code&gt;PERL_SRC/hints&lt;/code&gt; 의 해당 파일 과 비슷하지만 파일 이름 확장자 는 &lt;code&gt;.pl&lt;/code&gt; (예 : &lt;code&gt;next_3_2.pl&lt;/code&gt; )입니다. MakeMaker는 WriteMakefile () 서브 루틴 내에서 간단하게 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 되며 특수 변수를 포함 할뿐 아니라 명령을 실행하는 데 사용될 수 있습니다. 힌트 파일을 선택하는 규칙은 구성에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="85ffcac06be8bba3c10e447c47204872c6672f8a" translate="yes" xml:space="preserve">
          <source>MakeMaker.pm uses the architecture-specific information from Config.pm. In addition it evaluates architecture specific hints files in a &lt;code&gt;hints/&lt;/code&gt; directory. The hints files are expected to be named like their counterparts in &lt;code&gt;PERL_SRC/hints&lt;/code&gt;, but with an &lt;code&gt;.pl&lt;/code&gt; file name extension (eg. &lt;code&gt;next_3_2.pl&lt;/code&gt;). They are simply &lt;code&gt;eval&lt;/code&gt;ed by MakeMaker within the WriteMakefile() subroutine, and can be used to execute commands as well as to include special variables. The rules which hintsfile is chosen are the same as in Configure.</source>
          <target state="translated">MakeMaker.pm은 Config.pm의 아키텍처 별 정보를 사용합니다. 또한 &lt;code&gt;hints/&lt;/code&gt; 디렉토리 에서 아키텍처 특정 힌트 파일을 평가 합니다. 힌트 파일의 이름은 &lt;code&gt;PERL_SRC/hints&lt;/code&gt; 의 해당 파일 과 비슷하지만 &lt;code&gt;.pl&lt;/code&gt; 파일 이름 확장명 (예 : &lt;code&gt;next_3_2.pl&lt;/code&gt; )을 사용합니다. 이들은 WriteMakefile () 서브 루틴 내에서 MakeMaker에 의해 간단히 &lt;code&gt;eval&lt;/code&gt; 되며 명령을 실행하고 특수 변수를 포함하는 데 사용할 수 있습니다. hintsfile이 선택되는 규칙은 구성에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="836efb6e25a091dcb4ff8e1dbb2f0be6a5cbf14c" translate="yes" xml:space="preserve">
          <source>Makefile</source>
          <target state="translated">Makefile</target>
        </trans-unit>
        <trans-unit id="a6a4139b0f32af1594c237ebe008acaf8217f505" translate="yes" xml:space="preserve">
          <source>Makefile.PL</source>
          <target state="translated">Makefile.PL</target>
        </trans-unit>
        <trans-unit id="7b63f64a9d58c97e157e981bc21fc3592f84d63a" translate="yes" xml:space="preserve">
          <source>Makefile.SH</source>
          <target state="translated">Makefile.SH</target>
        </trans-unit>
        <trans-unit id="7703506e8273da38efd2a8cfe539dd5151c3f507" translate="yes" xml:space="preserve">
          <source>Makefile.aperl</source>
          <target state="translated">Makefile.aperl</target>
        </trans-unit>
        <trans-unit id="c9fdff62ddc7b582d9333af8bb3618798e22507b" translate="yes" xml:space="preserve">
          <source>Makefile.ce</source>
          <target state="translated">Makefile.ce</target>
        </trans-unit>
        <trans-unit id="f59062c8b44c1bb393273cea0b6483c724adc359" translate="yes" xml:space="preserve">
          <source>Makes LZMA compression a lot slower, but a small compression gain.</source>
          <target state="translated">LZMA 압축 속도는 느리지 만 압축 게인은 작습니다.</target>
        </trans-unit>
        <trans-unit id="42141d0e6f7cf55bf1aa53a30a2f72e384ff774e" translate="yes" xml:space="preserve">
          <source>Makes a deep copy of the object.</source>
          <target state="translated">개체의 깊은 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1ff909c4c06b83ac514fd30202e92170c2be88e6" translate="yes" xml:space="preserve">
          <source>Makes a distdir first, and runs a &lt;code&gt;perl Makefile.PL&lt;/code&gt; , a make, and a make test in that directory.</source>
          <target state="translated">distdir을 먼저 만들고 해당 디렉토리에서 &lt;code&gt;perl Makefile.PL&lt;/code&gt; , make 및 make 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8128104f9c2607926a021874ef102e7bc1c7d502" translate="yes" xml:space="preserve">
          <source>Makes a distdir first, and runs a &lt;code&gt;perl Makefile.PL&lt;/code&gt;, a make, and a make test in that directory.</source>
          <target state="translated">먼저 distdir을 만들고 해당 디렉토리에서 &lt;code&gt;perl Makefile.PL&lt;/code&gt; , make 및 make 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0126aa7337111c40fd3d8ee768267099e88c4e18" translate="yes" xml:space="preserve">
          <source>Makes an idhash from the argument, which must be a hash.</source>
          <target state="translated">인수에서 idhash를 작성합니다. 이는 해시 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2559af9d3a61aae60ee275b6a01f1105ed29e6" translate="yes" xml:space="preserve">
          <source>Makes files exist, with current timestamp</source>
          <target state="translated">현재 타임 스탬프와 함께 파일을 존재하게합니다.</target>
        </trans-unit>
        <trans-unit id="277c90e53937992c5799a554ef17ea6240ac0378" translate="yes" xml:space="preserve">
          <source>Makes sure at run time that the object file (derived from the &lt;code&gt;.xs&lt;/code&gt; file) and the &lt;code&gt;.pm&lt;/code&gt; files have the same version number. Default is true.</source>
          <target state="translated">런타임시 오브젝트 파일 ( &lt;code&gt;.xs&lt;/code&gt; 파일 에서 파생 됨 )과 &lt;code&gt;.pm&lt;/code&gt; 파일의 버전 번호가 동일해야합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="53d81221f3002a7a58139dee2348d32bcaf0b4e5" translate="yes" xml:space="preserve">
          <source>Makes the entry in the table completely ignorable; i.e. as if the weights were zero at all level.</source>
          <target state="translated">테이블의 항목을 완전히 무시할 수있게합니다. 즉, 모든 수준에서 가중치가 0 인 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="6ce592c7c5a83ac8509be2294340cdf6b4e97842" translate="yes" xml:space="preserve">
          <source>Makes the thread unjoinable, and causes any eventual return value to be discarded. When the program exits, any detached threads that are still running are silently terminated.</source>
          <target state="translated">스레드를 결합 할 수 없게 만들고 최종 리턴 값을 버립니다. 프로그램이 종료되면 여전히 실행중인 분리 된 스레드가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6eb05f63da2ef0fda20fc271a95dd2522c3f73" translate="yes" xml:space="preserve">
          <source>Maketext and gettext have a notable difference: gettext is in C, accessible thru C library calls, whereas Maketext is in Perl, and really can't work without a Perl interpreter (although I suppose something like it could be written for C). Accidents of history (and not necessarily lucky ones) have made C++ the most common language for the implementation of applications like word processors, Web browsers, and even many in-house applications like custom query systems. Current conditions make it somewhat unlikely that the next one of any of these kinds of applications will be written in Perl, albeit clearly more for reasons of custom and inertia than out of consideration of what is the right tool for the job.</source>
          <target state="translated">Maketext와 gettext에는 눈에 띄는 차이가 있습니다. 역사의 사고 (그리고 반드시 운이 좋은 것은 아님)로 인해 C ++는 워드 프로세서, 웹 브라우저와 같은 응용 프로그램, 심지어 사용자 지정 쿼리 시스템과 같은 많은 사내 응용 프로그램을 구현하는 데 가장 일반적인 언어가되었습니다. 현재 상황으로 인해 이러한 종류의 응용 프로그램 중 다음 응용 프로그램이 Perl로 작성 될 가능성은 다소 낮습니다. 물론 작업에 적합한 도구가 무엇인지 고려하는 것보다 사용자 지정 및 관성 때문에 더 명확하게 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f1346f72588900d324cb2f158adbed7a88d53077" translate="yes" xml:space="preserve">
          <source>Making</source>
          <target state="translated">Making</target>
        </trans-unit>
        <trans-unit id="c20d8b723d9ceaa1b7e38a56a86d1d8e27a837d5" translate="yes" xml:space="preserve">
          <source>Making Perl on AmigaOS</source>
          <target state="translated">AmigaOS에서 펄 만들기</target>
        </trans-unit>
        <trans-unit id="4fbad71d4049f75dae54b6a49e4082e7c3867bbe" translate="yes" xml:space="preserve">
          <source>Making References</source>
          <target state="translated">참조하기</target>
        </trans-unit>
        <trans-unit id="b3d460b24ff971356f57aa8043b7e5b49b73273b" translate="yes" xml:space="preserve">
          <source>Making a human-readable string out of an address</source>
          <target state="translated">주소에서 사람이 읽을 수있는 문자열 만들기</target>
        </trans-unit>
        <trans-unit id="ec8a39930df65d8d70bb72152bc2ebfcb5ef6f12" translate="yes" xml:space="preserve">
          <source>Making a system call for each byte you want to read is not very efficient (to put it mildly) but is the simplest to explain and works reasonably well.</source>
          <target state="translated">읽고 자하는 각 바이트에 대해 시스템 호출을하는 것은 그리 효율적이지 않지만 (가벼워서) 설명하기가 가장 쉽고 합리적으로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6bc23e8c3bea5e39366cc40e690baa6e822bc4b0" translate="yes" xml:space="preserve">
          <source>Making executables with a custom collection of statically loaded extensions</source>
          <target state="translated">정적으로로드 된 확장 프로그램의 사용자 정의 모음으로 실행 파일 만들기</target>
        </trans-unit>
        <trans-unit id="cebf6e10212157e6416340db92e3bf9d920a30bf" translate="yes" xml:space="preserve">
          <source>Making executables with a custom search-paths</source>
          <target state="translated">사용자 정의 검색 경로로 실행 파일 만들기</target>
        </trans-unit>
        <trans-unit id="a0f26bb1828a797c6495fc430a1532f4f3524259" translate="yes" xml:space="preserve">
          <source>Making things worse is that UTF-8 support was a later addition to the regex engine (as it was to perl) and this necessarily made things a lot more complicated. Obviously it is easier to design a regex engine with Unicode support in mind from the beginning than it is to retrofit it to one that wasn't.</source>
          <target state="translated">설상가상으로 UTF-8 지원은 나중에 정규식 엔진에 추가되었으므로 (펄과 마찬가지로) 훨씬 더 복잡해졌습니다. 분명히 유니 코드 지원을 염두에두고 정규식 엔진을 그렇지 않은 엔진에 맞게 개조하는 것보다 처음부터 염두에 두는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a78f322195b8416c4ac155ecbbc78299380d03d5" translate="yes" xml:space="preserve">
          <source>Making up your own directives breaks compatibility with other Pod formatters, in a way that using &quot;=for</source>
          <target state="translated">직접 지시문을 작성하면 &quot;= for&quot;를 사용하는 방식으로 다른 포드 포맷터와의 호환성이 깨집니다.</target>
        </trans-unit>
        <trans-unit id="bf00c544b1ffc6b4c5073f7dd35eacd07c2aa8d1" translate="yes" xml:space="preserve">
          <source>Making your module threadsafe</source>
          <target state="translated">모듈을 스레드로부터 안전하게 만들기</target>
        </trans-unit>
        <trans-unit id="24e9d209d23730e356bf6cdf6439fa711205639d" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</source>
          <target state="translated">말콤 비티, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b41df4a623efa0a4562a894886ab9c56b063a3e" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</source>
          <target state="translated">Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19631f035a3084a6fe635dc5c4bba7828f7afbd3" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, mbeattie@sable.ox.ac.uk.</source>
          <target state="translated">말콤 비티, mbeattie@sable.ox.ac.uk.</target>
        </trans-unit>
        <trans-unit id="a0e351e0c684eaf1740f72fcfc804df5ea2bda20" translate="yes" xml:space="preserve">
          <source>Malformed PERLLIB_PREFIX</source>
          <target state="translated">잘못된 PERLLIB_PREFIX</target>
        </trans-unit>
        <trans-unit id="95bfcc7f20890119ba5507d8e4b227db1bf7b616" translate="yes" xml:space="preserve">
          <source>Malformed UTF-16 surrogate</source>
          <target state="translated">잘못된 UTF-16 대리</target>
        </trans-unit>
        <trans-unit id="76d7492febbbbb102be4a6084b9574c6324cf62a" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8</source>
          <target state="translated">잘못된 UTF-8</target>
        </trans-unit>
        <trans-unit id="840809324950f1542de4d0696f6aa6d5b081a4b2" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 character%s</source>
          <target state="translated">잘못된 UTF-8 문자 % s</target>
        </trans-unit>
        <trans-unit id="f86646a5e724c4c0935d99ba9fa1363951791303" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 returned by \N{%s} immediately after '%s'</source>
          <target state="translated">'% s'바로 뒤에 \ N {% s}에서 잘못된 형식의 UTF-8을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="3629da68a2c9e61eb2ed5a9305a630d15d03a5fd" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 string in &quot;%s&quot;</source>
          <target state="translated">&quot;% s&quot;에 잘못된 UTF-8 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c75c74bdc6a4b14a7b5100d51b32e10dbf5f347" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 string in '%c' format in unpack</source>
          <target state="translated">압축 해제시 '% c'형식의 잘못된 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="88cc49e1e61c18146c03f559c55b4b5ca3c7443d" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 string in pack</source>
          <target state="translated">팩의 잘못된 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="ebe2537af48af16788aae98b0417a1713098f07e" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 string in unpack</source>
          <target state="translated">압축 해제시 잘못된 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="eceeeccb5dcd41d822277f4b9a9a892eb9541d0a" translate="yes" xml:space="preserve">
          <source>Malformed integer in [] in pack</source>
          <target state="translated">팩의 []에 잘못된 정수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="791860e6c4e8eb2c20a1be93f5c34476ec1a52b9" translate="yes" xml:space="preserve">
          <source>Malformed integer in [] in unpack</source>
          <target state="translated">압축 풀기의 []에 잘못된 정수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b8c467b1ea34859e334a2f3c6542838d86881fb" translate="yes" xml:space="preserve">
          <source>Malformed prototype for %s: %s</source>
          <target state="translated">% s에 대한 잘못된 프로토 타입 : % s</target>
        </trans-unit>
        <trans-unit id="1c0e8bc778fcc6e629304edc324bee00f7f54935" translate="yes" xml:space="preserve">
          <source>Malloc Issues with perl on Solaris.</source>
          <target state="translated">Solaris에서 perl과 관련된 Malloc 문제</target>
        </trans-unit>
        <trans-unit id="118d45651d8f268c43f0d79ab0bbae66d29235b4" translate="yes" xml:space="preserve">
          <source>Malloc in Irix</source>
          <target state="translated">Irix의 Malloc</target>
        </trans-unit>
        <trans-unit id="25b61228c020a688cfd6c5a06fa24fca08bfdf7b" translate="yes" xml:space="preserve">
          <source>Manage .packlist files</source>
          <target state="translated">.packlist 파일 관리</target>
        </trans-unit>
        <trans-unit id="35931f68fb7263b16c5ab46a487b802fec9cd2f9" translate="yes" xml:space="preserve">
          <source>Managing Unknown Symbols</source>
          <target state="translated">알 수없는 기호 관리</target>
        </trans-unit>
        <trans-unit id="a55abc0bd6c1b774adb064c2106381d9bf863837" translate="yes" xml:space="preserve">
          <source>Mandatory named arguments: Either &lt;code&gt;typemap =&amp;gt; $another_typemap_obj&lt;/code&gt; or &lt;code&gt;file =&amp;gt; $path_to_typemap_file&lt;/code&gt; but not both.</source>
          <target state="translated">필수 명명 된 인수 : &lt;code&gt;typemap =&amp;gt; $another_typemap_obj&lt;/code&gt; 또는 &lt;code&gt;file =&amp;gt; $path_to_typemap_file&lt;/code&gt; 하나이지만 둘다는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ce16d065fa0516da01a691954a3b7eedd61a0753" translate="yes" xml:space="preserve">
          <source>Mandatory named arguments: The &lt;code&gt;ctype&lt;/code&gt; of the entry.</source>
          <target state="translated">필수 명명 된 인수 : 항목 의 &lt;code&gt;ctype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58aaf34da96668087981ecd9c92610d9f0dca398" translate="yes" xml:space="preserve">
          <source>Mandatory named arguments: The &lt;code&gt;xstype&lt;/code&gt; of the entry or the &lt;code&gt;ctype&lt;/code&gt; of the typemap that can be used to find the &lt;code&gt;xstype&lt;/code&gt;. To wit, the following pieces of code are equivalent:</source>
          <target state="translated">필수 명명 된 인수 : 항목 의 &lt;code&gt;xstype&lt;/code&gt; 또는 &lt;code&gt;xstype&lt;/code&gt; 을 찾는 데 사용할 수있는 typemap 의 &lt;code&gt;ctype&lt;/code&gt; 입니다 . 즉, 다음 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a99b477f4c3ec9d1fec66aced41b9bbadd1b95f7" translate="yes" xml:space="preserve">
          <source>Mandatory named arguments: The &lt;code&gt;xstype&lt;/code&gt; of the entry or the &lt;code&gt;ctype&lt;/code&gt; of the typemap that can be used to resolve the &lt;code&gt;xstype&lt;/code&gt;. (See above for an example.)</source>
          <target state="translated">필수 명명 된 인수 다음 &lt;code&gt;xstype&lt;/code&gt; 항목 또는의 &lt;code&gt;ctype&lt;/code&gt; 결심하는 데 사용할 수있는 타입 맵의 &lt;code&gt;xstype&lt;/code&gt; 을 . (예는 위를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="94f5d715eb57168bf68f55ea9554b6cf192f682a" translate="yes" xml:space="preserve">
          <source>Mandatory parameter follows optional parameter</source>
          <target state="translated">필수 매개 변수는 선택적 매개 변수 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="04f195c5450e541e2f347f3f01dadb29f21cee9c" translate="yes" xml:space="preserve">
          <source>Mandatory section; should be a comma-separated list of programs or functions documented by this POD page, such as:</source>
          <target state="translated">필수 섹션; 다음과 같이이 POD 페이지에서 문서화 한 쉼표로 구분 된 프로그램 또는 기능 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="95b5420abf959d7eeb8c5172873e22e522cf809a" translate="yes" xml:space="preserve">
          <source>Manipulate @INC at compile time</source>
          <target state="translated">컴파일 타임에 @INC 조작</target>
        </trans-unit>
        <trans-unit id="95363fed4c5c92c85bfefb937ad574a5059a5ae7" translate="yes" xml:space="preserve">
          <source>Manipulate Perl symbols and their names</source>
          <target state="translated">Perl 기호 및 이름 조작</target>
        </trans-unit>
        <trans-unit id="a8c36443cbda2a6067ad5c937b50ce063c2df504" translate="yes" xml:space="preserve">
          <source>Manipulate threads in Perl (for old code only)</source>
          <target state="translated">Perl에서 스레드 조작 (이전 코드에만 해당)</target>
        </trans-unit>
        <trans-unit id="8a33f921aa98603ac2e48c7701dc159e3e29d6c1" translate="yes" xml:space="preserve">
          <source>Manipulating Opsets</source>
          <target state="translated">옵셋 조작</target>
        </trans-unit>
        <trans-unit id="2b13545245f98ef36404c536b49d9995e39a33e1" translate="yes" xml:space="preserve">
          <source>Manpages</source>
          <target state="translated">Manpages</target>
        </trans-unit>
        <trans-unit id="9f704bb02675db15a09798f0c1baac9cf37ee338" translate="yes" xml:space="preserve">
          <source>Manpages for Perl and utilities</source>
          <target state="translated">Perl 및 유틸리티에 대한 맨 페이지</target>
        </trans-unit>
        <trans-unit id="c6b4a6c33e94dc77d759627b76f10310db491611" translate="yes" xml:space="preserve">
          <source>Manpages for Perl modules</source>
          <target state="translated">Perl 모듈의 맨 페이지</target>
        </trans-unit>
        <trans-unit id="2c5bfd7444f7b80d647fb722cd55c67b0650aba4" translate="yes" xml:space="preserve">
          <source>Manpages for Perl on AmigaOS</source>
          <target state="translated">AmigaOS의 Perl 맨 페이지</target>
        </trans-unit>
        <trans-unit id="d013bfb63d4447b01e40780ba1cecae093576e1b" translate="yes" xml:space="preserve">
          <source>Manual Pages</source>
          <target state="translated">매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="9cec485eab07667ef580f14404756c7cdf469fd8" translate="yes" xml:space="preserve">
          <source>Manual binary installation</source>
          <target state="translated">수동 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="572276926686cc7cc3f5283d7ffd30b0fe5dbb1a" translate="yes" xml:space="preserve">
          <source>Manual page indexers are often extremely picky about the format of this section, so don't put anything in it except this line. Every program or function documented by this POD page should be listed, separated by a comma and a space. For a Perl module, just give the module name. A single dash, and only a single dash, should separate the list of programs or functions from the description. Do not use any markup such as C&amp;lt;&amp;gt; or B&amp;lt;&amp;gt; anywhere in this line. Functions should not be qualified with &lt;code&gt;()&lt;/code&gt; or the like. The description should ideally fit on a single line, even if a man program replaces the dash with a few tabs.</source>
          <target state="translated">매뉴얼 페이지 인덱서는 종종이 섹션의 형식에 대해 매우 까다롭기 때문에이 행을 제외하고는 아무것도 넣지 마십시오. 이 POD 페이지에 기록 된 모든 프로그램 또는 기능은 쉼표와 공백으로 구분하여 나열해야합니다. Perl 모듈의 경우 모듈 이름 만 지정하십시오. 단일 대시와 단일 대시 만 프로그램 또는 기능 목록을 설명과 분리해야합니다. 이 줄에서 C &amp;lt;&amp;gt; 또는 B &amp;lt;&amp;gt;와 같은 마크 업을 사용하지 마십시오. 함수는 &lt;code&gt;()&lt;/code&gt; 등 으로 한정되어서는 안됩니다 . man 프로그램이 대시를 몇 개의 탭으로 대체하더라도 설명은 단일 행에 이상적으로 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="00b4c0e2070e1a2565707d57c993afbbae4c0c2e" translate="yes" xml:space="preserve">
          <source>Manual: FAQs</source>
          <target state="translated">매뉴얼 : FAQ</target>
        </trans-unit>
        <trans-unit id="db75f57bcc4f9ed3d56d92896abd677a771bded6" translate="yes" xml:space="preserve">
          <source>Manual: Overview</source>
          <target state="translated">매뉴얼 : 개요</target>
        </trans-unit>
        <trans-unit id="950d94e419183f62360b7a18d309980db9dca27b" translate="yes" xml:space="preserve">
          <source>Manual: Tutorials</source>
          <target state="translated">매뉴얼 : 튜토리얼</target>
        </trans-unit>
        <trans-unit id="ac0e5ddc596dea92cba4c0e2c3555f39d4f7c5f0" translate="yes" xml:space="preserve">
          <source>Manually put</source>
          <target state="translated">수동으로 넣어</target>
        </trans-unit>
        <trans-unit id="4fddc764751f961b3d597ce52116c4021c09dadd" translate="yes" xml:space="preserve">
          <source>Manually setting hints from within your program</source>
          <target state="translated">프로그램 내에서 수동으로 힌트 설정</target>
        </trans-unit>
        <trans-unit id="c84207b4c45d8ef84a1d774f5c8bf8efd5fcd50a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;AUTOLOAD&lt;/code&gt; routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine without a trace. (See the source to the standard module documented in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;, for example.) But an &lt;code&gt;AUTOLOAD&lt;/code&gt; routine can also just emulate the routine and never define it. For example, let's pretend that a function that wasn't defined should just invoke &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; with those arguments. All you'd do is:</source>
          <target state="translated">많은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴은 eval ()을 사용하여 요청 된 서브 루틴에 대한 정의에로드 한 다음 추적없이 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴 의 스택 프레임을 지우는 특수 형식의 goto ()를 사용하여 해당 서브 루틴을 실행합니다 . ( 예를 들어 &lt;a href=&quot;autoloader&quot;&gt;AutoLoader에&lt;/a&gt; 문서화 된 표준 모듈의 소스를 참조하십시오 .) 그러나 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴은 루틴을 에뮬레이트하고 정의 할 수 없습니다. 예를 들어, 정의되지 않은 함수는 이러한 인수로 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 을 호출해야한다고 가정 해 봅시다 . 당신이 할 일은 :</target>
        </trans-unit>
        <trans-unit id="1a7290a6ed663a7c77bc4c6109fa00f035bb42d3" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;AUTOLOAD&lt;/code&gt; routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine without a trace. (See the source to the standard module documented in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;, for example.) But an &lt;code&gt;AUTOLOAD&lt;/code&gt; routine can also just emulate the routine and never define it. For example, let's pretend that a function that wasn't defined should just invoke &lt;code&gt;system&lt;/code&gt; with those arguments. All you'd do is:</source>
          <target state="translated">많은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴이 eval ()을 사용하여 요청 된 서브 루틴에 대한 정의를로드 한 다음 추적없이 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴 의 스택 프레임을 지우는 특수한 형태의 goto ()를 사용하여 해당 서브 루틴을 실행합니다 . ( 예를 들어 &lt;a href=&quot;autoloader&quot;&gt;AutoLoader에&lt;/a&gt; 문서화 된 표준 모듈에 대한 소스를 참조하십시오 .) 그러나 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴은 루틴을 에뮬레이트하고 정의하지 않을 수도 있습니다. 예를 들어 정의되지 않은 함수가 해당 인수로 &lt;code&gt;system&lt;/code&gt; 을 호출해야한다고 가정 해 보겠습니다 . 당신이 할 일은 :</target>
        </trans-unit>
        <trans-unit id="077443aca86ab6f4e2738e61b48baa6af4d5929a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;TAP::*&lt;/code&gt; classes have a</source>
          <target state="translated">많은 &lt;code&gt;TAP::*&lt;/code&gt; 클래스에는</target>
        </trans-unit>
        <trans-unit id="ff6afc71dae16e6a2fa7c473b44e2b45df859fad" translate="yes" xml:space="preserve">
          <source>Many Test2 developers and users lurk on &lt;a href=&quot;irc://irc.perl.org/#perl-qa&quot;&gt;irc://irc.perl.org/#perl-qa&lt;/a&gt; and &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;irc://irc.perl.org/#toolchain&lt;/a&gt;. We also have a slack team that can be joined by anyone with an &lt;code&gt;@cpan.org&lt;/code&gt; email address &lt;a href=&quot;https://perl-test2.slack.com/&quot;&gt;https://perl-test2.slack.com/&lt;/a&gt; If you do not have an &lt;code&gt;@cpan.org&lt;/code&gt; email you can ask for a slack invite by emailing Chad Granum &amp;lt;exodist@cpan.org&amp;gt;.</source>
          <target state="translated">많은 Test2 개발자와 사용자가 &lt;a href=&quot;irc://irc.perl.org/#perl-qa&quot;&gt;irc : //irc.perl.org/#perl-qa&lt;/a&gt; 및 &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;irc : //irc.perl.org/#toolchain에 숨어&lt;/a&gt; 있습니다. 우리는 또한으로 누구나 가입 할 수있는 여유 팀이 &lt;code&gt;@cpan.org&lt;/code&gt; 이메일 주소 &lt;a href=&quot;https://perl-test2.slack.com/&quot;&gt;https://perl-test2.slack.com/를&lt;/a&gt; 당신이 가지고 있지 않은 경우 &lt;code&gt;@cpan.org&lt;/code&gt; 당신이 여유를 요청할 수 있습니다 된 이메일 것은 초대 Chad Granum &amp;lt;exodist@cpan.org&amp;gt;로 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="7697e7d09f9c98694e67e6f7f7b568fc62b09264" translate="yes" xml:space="preserve">
          <source>Many Unicode properties have more than one name (or alias). &lt;code&gt;prop_invmap&lt;/code&gt; understands all of these, including Perl extensions to them. Ambiguities are resolved as described above for &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt; (except if a property has both a complete mapping, and a binary &lt;code&gt;Y&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt; mapping, then specifying the property name prefixed by &lt;code&gt;&quot;is&quot;&lt;/code&gt; causes the binary one to be returned). The Perl internal property &quot;Perl_Decimal_Digit, described below, is also accepted. An empty list is returned if the property name is unknown. See &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;&quot;Properties accessible through Unicode::UCD&quot; in perluniprops&lt;/a&gt; for the properties acceptable as inputs to this function.</source>
          <target state="translated">많은 유니 코드 속성에는 둘 이상의 이름 (또는 별칭)이 있습니다. &lt;code&gt;prop_invmap&lt;/code&gt; 은 Perl 확장을 포함 하여이 모든 것을 이해합니다. 모호성은 &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases ()&quot;에&lt;/a&gt; 대해 위에서 설명한대로 해결됩니다 (속성에 완전한 매핑과 이진 &lt;code&gt;Y&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; 매핑 이 모두있는 경우를 제외하고 &lt;code&gt;&quot;is&quot;&lt;/code&gt; 접두사가 붙은 특성 이름을 지정 하면 이진 이름 이 반환됩니다). 아래에 설명 된 Perl 내부 등록 정보 &quot;Perl_Decimal_Digit도 허용됩니다. 등록 정보 이름을 알 수없는 경우 빈 목록이 반환됩니다. 이 함수에 대한 입력으로 허용되는 등록 정보 &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;는 perluniprops의&quot;Unicode :: UCD를 통해 액세스 할 수있는 등록 정보 &quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7a6d0011c1051ce0333abc0265080896a481453" translate="yes" xml:space="preserve">
          <source>Many Unicode properties have more than one name (or alias). &lt;code&gt;prop_invmap&lt;/code&gt; understands all of these, including Perl extensions to them. Ambiguities are resolved as described above for &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;. The Perl internal property &quot;Perl_Decimal_Digit, described below, is also accepted. An empty list is returned if the property name is unknown. See &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; for the properties acceptable as inputs to this function.</source>
          <target state="translated">많은 유니 코드 속성에는 둘 이상의 이름 (또는 별칭)이 있습니다. &lt;code&gt;prop_invmap&lt;/code&gt; 은 Perl 확장을 포함 하여이 모든 것을 이해합니다. &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()에&lt;/a&gt; 대해 위에서 설명한대로 모호성이 해결됩니다 . 아래에 설명 된 Perl 내부 특성 &quot;Perl_Decimal_Digit&quot;도 승인됩니다. 특성 이름을 알 수 없으면 빈 목록이 리턴됩니다. 이 함수에 대한 입력으로 허용 가능한 특성 &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;은 perluniprops에서 Unicode :: UCD를 통해 액세스 가능한 특성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33c4abda8cada5094d54134f3094015df454f077" translate="yes" xml:space="preserve">
          <source>Many applications contain some Perl code that could be reused.</source>
          <target state="translated">많은 응용 프로그램에는 재사용 할 수있는 일부 Perl 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c7aff02ac4959c101106add7455533fff396df" translate="yes" xml:space="preserve">
          <source>Many built-in functions may be overridden, though this should be tried only occasionally and for good reason. Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.</source>
          <target state="translated">많은 내장 함수가 재정의 될 수 있지만, 가끔 그리고 합당한 이유로 시도해야합니다. 일반적으로 이는 비 유닉스 시스템에서 누락 된 내장 기능을 에뮬레이트하려는 패키지에 의해 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294c60617a28cb2d00c28e138e9bdc873720df06" translate="yes" xml:space="preserve">
          <source>Many cases of using &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in a conditional can be written using &lt;code&gt;any&lt;/code&gt; instead, as it can short-circuit after the first true result.</source>
          <target state="translated">사용 많은 경우 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 조건으로 사용하여 기록 될 수 &lt;code&gt;any&lt;/code&gt; 대로 제 진정한 결과 후의 단락 수 대신.</target>
        </trans-unit>
        <trans-unit id="8f257ebd5355ea10d707c95712fc0e9530be11ec" translate="yes" xml:space="preserve">
          <source>Many cases of using &lt;code&gt;grep&lt;/code&gt; in a conditional can be written using &lt;code&gt;any&lt;/code&gt; instead, as it can short-circuit after the first true result.</source>
          <target state="translated">조건부에서 &lt;code&gt;grep&lt;/code&gt; 을 사용하는 많은 경우 는 첫 번째 실제 결과 후에 단락 될 수 있으므로 대신 &lt;code&gt;any&lt;/code&gt; 를 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c53c00d79c1b4a5caf2dbf3b1b3871ad968ba47e" translate="yes" xml:space="preserve">
          <source>Many cities around the world have local Perl Mongers chapters. A Perl Mongers chapter is a local user group which typically holds regular in-person meetings, both social and technical; helps organize local conferences, workshops, and hackathons; and provides a mailing list or other continual contact method for its members to keep in touch.</source>
          <target state="translated">전 세계 많은 도시에는 현지 Perl Mongers 장이 있습니다. Perl Mongers 챕터는 일반적으로 사회 및 기술적으로 정기적 인 대면 회의를 개최하는 로컬 사용자 그룹입니다. 지역 회의, 워크샵 및 해커 톤을 조직하는 데 도움이됩니다. 회원들이 연락 할 수있는 메일 링리스트 또는 기타 지속적인 연락 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1333a5caee67ed3743b1573e310fc69a41dedbcf" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {ar-ae} UAE Arabic; {ar-bh} Bahrain Arabic; {ar-dz} Algerian Arabic; {ar-eg} Egyptian Arabic; {ar-iq} Iraqi Arabic; {ar-jo} Jordanian Arabic; {ar-kw} Kuwait Arabic; {ar-lb} Lebanese Arabic; {ar-ly} Libyan Arabic; {ar-ma} Moroccan Arabic; {ar-om} Omani Arabic; {ar-qa} Qatari Arabic; {ar-sa} Sauda Arabic; {ar-sy} Syrian Arabic; {ar-tn} Tunisian Arabic; {ar-ye} Yemen Arabic.</source>
          <target state="translated">구어체 매체에서는 많은 형태를 서로 이해하기 어렵습니다. 주목할만한 형태 : {ar-ae} UAE Arabic; {ar-bh} 바레인 아랍어; {ar-dz} 알제리 아랍어; {ar-eg} 이집트 아랍어; {ar-iq} 이라크 아랍어; {ar-jo} 요르단 아랍어; {ar-kw} 쿠웨이트 아랍어; {ar-lb} 레바논 아랍어; {arlyly} 리비아 아랍어; {ar-ma} 모로코 아랍어; {ar-om} 오만 아랍어; {ar-qa} 카타르 아랍어; {ar-sa} 소다 아랍어; {ar-sy} 시리아 아랍어; {ar-tn} 튀니지 아랍어; {ar-ye} 예멘 아랍어.</target>
        </trans-unit>
        <trans-unit id="22b65de1b1ff16b769feb6a461c534e2b3b49857" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {zh-Hans} Chinese, in simplified script; {zh-Hant} Chinese, in traditional script; {zh-tw} Taiwan Chinese; {zh-cn} PRC Chinese; {zh-sg} Singapore Chinese; {zh-mo} Macau Chinese; {zh-hk} Hong Kong Chinese; {zh-guoyu} Mandarin [Putonghua/Guoyu]; {zh-hakka} Hakka [formerly &quot;i-hakka&quot;]; {zh-min} Hokkien; {zh-min-nan} Southern Hokkien; {zh-wuu} Shanghaiese; {zh-xiang} Hunanese; {zh-gan} Gan; {zh-yue} Cantonese.</source>
          <target state="translated">구어체 매체에서는 많은 형태를 서로 이해하기 어렵습니다. 주목할만한 형태 : {zh-Hans} 중국어, 간체 스크립트; {zh-Hant} 중국어 (번체); {zh-tw} 대만 중국어; {zh-cn} PRC 중국어; {zh-sg} 싱가포르 중국인; {zh-mo} 마카오 중국어; {zh-hk} 홍콩 중국어; {zh-guoyu} 만다린 [푸 통화 / 구 오유]; {zh-hakka} Hakka [이전의 &quot;i-hakka&quot;]; {zh-min} 호키엔; {zh-min-nan} 남부 호키엔; {zh-wuu} 상하이; {zh-xiang} 호남 족; {zh-gan} 간; {zh-yue} 광동어.</target>
        </trans-unit>
        <trans-unit id="453c2424198e6c72c7985d52564f33ad8ed6bde5" translate="yes" xml:space="preserve">
          <source>Many functions have some kind of reference manipulation as part of their purpose. Sometimes this is documented in terms of ownership of references, and sometimes it is (less helpfully) documented in terms of changes to reference counts. For example, the &lt;a href=&quot;perlapi#newRV_inc&quot;&gt;newRV_inc()&lt;/a&gt; function is documented to create a new RV (with reference count 1) and increment the reference count of the referent that was supplied by the caller. This is best understood as creating a new reference to the referent, which is owned by the created RV, and returning to the caller ownership of the sole reference to the RV. The &lt;a href=&quot;perlapi#newRV_noinc&quot;&gt;newRV_noinc()&lt;/a&gt; function instead does not increment the reference count of the referent, but the RV nevertheless ends up owning a reference to the referent. It is therefore implied that the caller of &lt;code&gt;newRV_noinc()&lt;/code&gt; is relinquishing a reference to the referent, making this conceptually a more complicated operation even though it does less to the data structures.</source>
          <target state="translated">많은 함수에는 목적의 일부로 일종의 참조 조작이 있습니다. 때때로 이것은 참조의 소유권 측면에서 문서화되고 때로는 참조 횟수의 변경 측면에서 (덜 유용하게) 문서화됩니다. 예를 들어 &lt;a href=&quot;perlapi#newRV_inc&quot;&gt;newRV_inc ()&lt;/a&gt; 함수는 새 RV (참조 카운트 1 포함)를 만들고 호출자가 제공 한 참조 항목의 참조 카운트를 증가시키는 것으로 문서화되어 있습니다. 이것은 생성 된 RV가 소유 한 리퍼 런트에 대한 새로운 참조를 생성하고 RV에 대한 유일한 참조의 호출자 소유권을 반환하는 것으로 가장 잘 이해됩니다. &lt;a href=&quot;perlapi#newRV_noinc&quot;&gt;newRV_noinc ()&lt;/a&gt; 함수를 대신 지시 대상의 참조 카운트를 증가하지 않지만, RV 그럼에도 불구 지시 대상에 대한 참조를 소유 끝납니다. 따라서 호출자가 &lt;code&gt;newRV_noinc()&lt;/code&gt; 는 참조 대상에 대한 참조를 포기하여 데이터 구조에 덜 영향을 주더라도 개념적으로 더 복잡한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ce036cf5b80f30684cc79c208c3479e5b4b012ed" translate="yes" xml:space="preserve">
          <source>Many good books have been written about Perl--see the section later in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for more details.</source>
          <target state="translated">Perl에 관한 많은 훌륭한 책들이 저술되어 있습니다. 자세한 내용 은 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2의 뒷부분&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="daec66bc8e44bcc2464b1a0d6c4a9145c9a7595a" translate="yes" xml:space="preserve">
          <source>Many members of the community have a Perl-related blog on this site. If you'd like to join them, you can sign up for free.</source>
          <target state="translated">이 커뮤니티에는 많은 커뮤니티 회원이 Perl 관련 블로그를 가지고 있습니다. 가입하려면 무료로 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="a71a9a58452bd2f82710c97492e2e55820847a42" translate="yes" xml:space="preserve">
          <source>Many modules are included in the Perl distribution. These are described below, and all end in</source>
          <target state="translated">많은 모듈이 Perl 분배에 포함되어 있습니다. 이것들은 아래에 설명되어 있으며 모두 끝납니다.</target>
        </trans-unit>
        <trans-unit id="1f04b4ad6b9470f5a4263506a665427c873dff64" translate="yes" xml:space="preserve">
          <source>Many modules make use of &lt;code&gt;AUTOLOAD&lt;/code&gt; ing for constant subroutines to avoid having to compile and waste memory on rarely used values (see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on constant subroutines). Calls to such constant subroutines are not optimized away at compile time because they can't be checked at compile time for constancy.</source>
          <target state="translated">많은 모듈 은 거의 사용되지 않는 값에서 메모리를 컴파일하고 낭비하지 않도록 상수 서브 루틴 에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 사용합니다 ( 상수 서브 루틴에 대한 자세한 내용 은 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 참조 ). 이러한 상수 서브 루틴에 대한 호출은 컴파일 시간에 일관성을 검사 할 수 없으므로 컴파일 시간에 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="730337ad35302b76d62b0f02a8d67322d180f0d7" translate="yes" xml:space="preserve">
          <source>Many modules make use of &lt;code&gt;AUTOLOAD&lt;/code&gt;ing for constant subroutines to avoid having to compile and waste memory on rarely used values (see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on constant subroutines). Calls to such constant subroutines are not optimized away at compile time because they can't be checked at compile time for constancy.</source>
          <target state="translated">많은 모듈이 상수 서브 루틴에 대해 &lt;code&gt;AUTOLOAD&lt;/code&gt; ing을 사용하여 거의 사용되지 않는 값에 대한 메모리를 컴파일하고 낭비하지 않도록합니다 ( 상수 서브 루틴에 대한 자세한 내용 은 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 참조 ). 이러한 상수 서브 루틴에 대한 호출은 컴파일 타임에 불변성을 확인할 수 없기 때문에 컴파일 타임에 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77a0e7ba88e55cf427d9e31a53ffbec21a7210c5" translate="yes" xml:space="preserve">
          <source>Many more features</source>
          <target state="translated">더 많은 기능</target>
        </trans-unit>
        <trans-unit id="bd64827a8fe9cbce8371a7bcfdacc99021bfba74" translate="yes" xml:space="preserve">
          <source>Many of Perl's syntactic elements are &lt;b&gt;optional&lt;/b&gt;. Rather than requiring you to put parentheses around every function call and declare every variable, you can often leave such explicit elements off and Perl will figure out what you meant. This is known as &lt;b&gt;Do What I Mean&lt;/b&gt;, abbreviated &lt;b&gt;DWIM&lt;/b&gt;. It allows programmers to be &lt;b&gt;lazy&lt;/b&gt; and to code in a style with which they are comfortable.</source>
          <target state="translated">Perl의 많은 구문 요소는 &lt;b&gt;선택 사항&lt;/b&gt; 입니다. 모든 함수 호출을 괄호로 묶고 모든 변수를 선언하도록 요구하는 대신 이러한 명시 적 요소를 끄고 Perl이 의미를 파악할 수 있습니다. 이것을 &lt;b&gt;DWIM으로&lt;/b&gt; 약칭하는 &lt;b&gt;것을 의미&lt;/b&gt; 합니다. 프로그래머가 &lt;b&gt;게으르고&lt;/b&gt; 편안한 스타일로 코딩 할 수 있습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a80a79f26d84c2cb761d54166d1d73c391965f8f" translate="yes" xml:space="preserve">
          <source>Many of the comments in the existing code ignore the possibility of EBCDIC, and may be wrong therefore, even if the code works. This is actually a tribute to the successful transparent insertion of being able to handle EBCDIC without having to change pre-existing code.</source>
          <target state="translated">기존 코드의 많은 주석은 EBCDIC의 가능성을 무시하므로 코드가 작동하더라도 잘못 될 수 있습니다. 실제로 기존 코드를 변경하지 않고도 EBCDIC를 처리 할 수있는 투명한 삽입에 성공한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9898a42f1ac737909964257112ee94f7d9cf02b3" translate="yes" xml:space="preserve">
          <source>Many of the examples which follow will concentrate on creating an interface between Perl and the ONC+ RPC bind library functions. The rpcb_gettime() function is used to demonstrate many features of the XS language. This function has two parameters; the first is an input parameter and the second is an output parameter. The function also returns a status value.</source>
          <target state="translated">다음에 나오는 많은 예제는 Perl과 ONC + RPC 바인드 라이브러리 함수 간의 인터페이스 작성에 중점을 둘 것입니다. rpcb_gettime () 함수는 XS 언어의 많은 기능을 보여주기 위해 사용됩니다. 이 기능에는 두 가지 매개 변수가 있습니다. 첫 번째는 입력 매개 변수이고 두 번째는 출력 매개 변수입니다. 이 함수는 상태 값도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="921520a4912c2671d68673bde14f85005a75001d" translate="yes" xml:space="preserve">
          <source>Many of the functions and methods listed below take a list of operators as parameters. Most operator lists can be made up of several types of element. Each element can be one of</source>
          <target state="translated">아래에 나열된 많은 기능과 방법은 연산자 목록을 매개 변수로 사용합니다. 대부분의 운영자 목록은 여러 유형의 요소로 구성 될 수 있습니다. 각 요소는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ce44f55ac189a65855572d397cff0134d70bf83" translate="yes" xml:space="preserve">
          <source>Many of the functions in this module return a Benchmark object, or in the case of &lt;code&gt;timethese()&lt;/code&gt; , a reference to a hash, the values of which are Benchmark objects. This is useful if you want to store or further process results from Benchmark functions.</source>
          <target state="translated">이 모듈의 많은 함수는 Benchmark 객체 또는 &lt;code&gt;timethese()&lt;/code&gt; 의 경우 해시에 대한 참조를 반환하며 그 값은 Benchmark 객체입니다. 벤치 마크 기능의 결과를 저장하거나 추가로 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0de1482c88cef756f8728fbc7e608916bb4e2062" translate="yes" xml:space="preserve">
          <source>Many of the functions in this module return a Benchmark object, or in the case of &lt;code&gt;timethese()&lt;/code&gt;, a reference to a hash, the values of which are Benchmark objects. This is useful if you want to store or further process results from Benchmark functions.</source>
          <target state="translated">이 모듈의 많은 함수는 Benchmark 객체를 반환하거나 &lt;code&gt;timethese()&lt;/code&gt; 의 경우 값이 Benchmark 객체 인 해시에 대한 참조를 반환 합니다. 이는 벤치 마크 기능의 결과를 저장하거나 추가로 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f7fa695823c4cf174fe101c150852b83035705c8" translate="yes" xml:space="preserve">
          <source>Many of these fit entirely into 8 bits, using ASCII as 0-127, while specifying what 128-255 mean, and not using anything above 255. Thus, these are single-byte (or octet if you prefer) character sets. One important one (since Unicode is a superset of it) is the ISO 8859-1 character set.</source>
          <target state="translated">이들 중 대부분은 ASCII를 0-127로 사용하여 128-255의 의미를 지정하고 255보다 큰 것을 사용하지 않는 8 비트에 완전히 맞습니다. 따라서 이들은 1 바이트 (또는 선호하는 경우 8 진수) 문자 세트입니다. 하나의 중요한 것 (유니 코드는 그것의 수퍼 세트이므로)은 ISO 8859-1 문자 세트입니다.</target>
        </trans-unit>
        <trans-unit id="0b3bf50d1b5911ce9e6512eaf6849f76aed2a52f" translate="yes" xml:space="preserve">
          <source>Many of these functions are not safe in a multi-threaded environment where more than one thread can be using them. In particular, functions like &lt;code&gt;getpwent()&lt;/code&gt; iterate per-process and not per-thread, so if two threads are simultaneously iterating, neither will get all the records.</source>
          <target state="translated">이러한 함수의 대부분은 둘 이상의 스레드가 사용할 수있는 다중 스레드 환경에서 안전하지 않습니다. 특히 &lt;code&gt;getpwent()&lt;/code&gt; 와 같은 함수는 스레드가 아닌 프로세스별로 반복하므로 두 스레드가 동시에 반복하면 두 스레드 모두 모든 레코드를 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05f3b55f18e683ceb0e20e5811ee8daf9fe6a35d" translate="yes" xml:space="preserve">
          <source>Many older Pod parsers did not accept a line consisting of spaces/tabs and then a newline as a blank line. The only lines they considered blank were lines consisting of</source>
          <target state="translated">많은 오래된 포드 파서는 공백 / 탭으로 구성된 줄을 받아들이지 않고 줄 바꿈을 빈 줄로 받아들이지 않았습니다. 그들이 공백으로 간주 한 유일한 줄은</target>
        </trans-unit>
        <trans-unit id="77b79be2ba71305e951ed06673ece959275013dd" translate="yes" xml:space="preserve">
          <source>Many older Pod translators require the lines before every Pod command and after every Pod command (including &quot;=cut&quot;!) to be a blank line. Having something like this:</source>
          <target state="translated">많은 이전 포드 번역가는 모든 포드 명령 앞과 모든 포드 명령 ( &quot;= cut&quot;! 포함) 뒤에 빈 줄이 필요합니다. 이와 같은 것을 갖는 것 :</target>
        </trans-unit>
        <trans-unit id="5fdba737024348a43ba7029975783958d0026e67" translate="yes" xml:space="preserve">
          <source>Many operations return &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; to indicate failure, end of file, system error, uninitialized variable, and other exceptional conditions. This function allows you to distinguish &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; from other values. (A simple Boolean test will not distinguish among &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, zero, the empty string, and &lt;code&gt;&quot;0&quot;&lt;/code&gt;, which are all equally false.) Note that since &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; is a valid scalar, its presence doesn't</source>
          <target state="translated">많은 작업이 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 반환 하여 실패, 파일 끝, 시스템 오류, 초기화되지 않은 변수 및 기타 예외 조건을 나타냅니다. 이 함수를 사용하면 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 를 다른 값 과 구별 할 수 있습니다 . (간단한 부울 테스트는 &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; , 0, 빈 문자열 및 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 구분하지 않으며 모두 똑같이 false입니다.) &lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt; 는 유효한 스칼라이므로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a404450a4f0d183d7e5d43b166d410dc6203e579" translate="yes" xml:space="preserve">
          <source>Many operations return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate failure, end of file, system error, uninitialized variable, and other exceptional conditions. This function allows you to distinguish &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; from other values. (A simple Boolean test will not distinguish among &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, zero, the empty string, and &lt;code&gt;&quot;0&quot;&lt;/code&gt; , which are all equally false.) Note that since &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is a valid scalar, its presence doesn't</source>
          <target state="translated">많은 작업이 실패, 파일 끝, 시스템 오류, 초기화되지 않은 변수 및 기타 예외적 인 조건을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. 이 기능을 사용하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 다른 값 과 구별 할 수 있습니다 . (간단한 부울 테스트는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , 0, 빈 문자열 및 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 모두 동일하게 거짓으로 구분 하지 않습니다 .) &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 유효한 스칼라이므로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e1178b6db9a17ccdf3a94478a8066c1df5bc3a" translate="yes" xml:space="preserve">
          <source>Many operations return &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate failure, end of file, system error, uninitialized variable, and other exceptional conditions. This function allows you to distinguish &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; from other values. (A simple Boolean test will not distinguish among &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, zero, the empty string, and &lt;code&gt;&quot;0&quot;&lt;/code&gt; , which are all equally false.) Note that since &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is a valid scalar, its presence doesn't</source>
          <target state="translated">많은 작업이 실패, 파일 끝, 시스템 오류, 초기화되지 않은 변수 및 기타 예외적 인 조건을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. 이 기능을 사용하면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 다른 값 과 구별 할 수 있습니다 . (간단한 부울 테스트는 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , 0, 빈 문자열 및 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 모두 동일하게 거짓으로 구분 하지 않습니다 .) &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 유효한 스칼라이므로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dfa8b77d5259786f771a6e4ace0bfcdbd85aa18" translate="yes" xml:space="preserve">
          <source>Many operators can be combined with a &lt;code&gt;=&lt;/code&gt; as follows:</source>
          <target state="translated">많은 연산자 를 다음과 같이 &lt;code&gt;=&lt;/code&gt; 와 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7edb2d97b3af3ae2394d677e142e5033e9352fd" translate="yes" xml:space="preserve">
          <source>Many operators can be overloaded for objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">객체에 대해 많은 연산자가 오버로드 될 수 있습니다. 보다&lt;a href=&quot;overload&quot;&gt;과부하를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0786026e69f66286ea639842ce2404d2adc40ac" translate="yes" xml:space="preserve">
          <source>Many people contributed in one or more ways to the final beast, see the file CREDITS for an (incomplete) list. If you miss your name, please drop me a mail. Thank you!</source>
          <target state="translated">많은 사람들이 마지막 짐승에게 하나 이상의 방법으로 기여했습니다. (불완전한) 목록은 CREDITS 파일을 참조하십시오. 당신이 당신의 이름을 그리워하는 경우, 나에게 메일을 드롭하시기 바랍니다. 감사합니다!</target>
        </trans-unit>
        <trans-unit id="3cd694c993c7766c158f0bde0cae8406dd835121" translate="yes" xml:space="preserve">
          <source>Many people enter the CPAN shell by running the &lt;a href=&quot;cpan&quot;&gt;cpan&lt;/a&gt; utility program which is installed in the same directory as perl itself. So if you have this directory in your PATH variable (or some equivalent in your operating system) then typing &lt;code&gt;cpan&lt;/code&gt; in a console window will work for you as well. Above that the utility provides several commandline shortcuts.</source>
          <target state="translated">많은 사람들 이 perl 자체와 동일한 디렉토리에 설치된 &lt;a href=&quot;cpan&quot;&gt;cpan&lt;/a&gt; 유틸리티 프로그램을 실행하여 CPAN 쉘에 들어갑니다 . 따라서 PATH 변수에이 디렉토리가 있거나 운영 체제에 해당하는 디렉토리가 있으면 &lt;code&gt;cpan&lt;/code&gt; 을 입력하십시오 . 콘솔 창에 해도 효과가 있습니다. 이 유틸리티는 여러 명령 줄 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf066e941decde490ba46743ad80acc7ad0c1d13" translate="yes" xml:space="preserve">
          <source>Many platforms, quite rightly so, will give you a core dump instead of a pony if the p happens not to be correctly aligned.</source>
          <target state="translated">p가 올바르게 정렬되지 않으면 많은 플랫폼이 올바르게 조랑말 대신 코어 덤프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ad441fa89d95482888ef0338d65a9d30f90b64d7" translate="yes" xml:space="preserve">
          <source>Many popular C extension modules do not come bundled (at least, not completely) due to their sizes, volatility, or simply lack of time for adequate testing and configuration across the multitude of platforms on which Perl was beta-tested. You are encouraged to look for them on CPAN (described below), or using web search engines like Alta Vista or Google.</source>
          <target state="translated">널리 사용되는 많은 C 확장 모듈은 크기, 휘발성 또는 Perl 베타 테스트를 거친 여러 플랫폼에서 적절한 테스트 및 구성을위한 시간 부족으로 번들로 제공되지 않습니다 (적어도 완벽하지는 않습니다). CPAN (아래 설명 참조) 또는 Alta Vista 또는 Google과 같은 웹 검색 엔진을 사용하여 검색하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="65b9676d9f89e15e127ab7753c58e60a602e2704" translate="yes" xml:space="preserve">
          <source>Many popular C extension modules do not come bundled (at least, not completely) due to their sizes, volatility, or simply lack of time for adequate testing and configuration across the multitude of platforms on which Perl was beta-tested. You are encouraged to look for them on CPAN (described below), or using web search engines like Google or DuckDuckGo.</source>
          <target state="translated">많은 인기있는 C 확장 모듈은 크기, 변동성 또는 Perl이 베타 테스트 된 여러 플랫폼에서 적절한 테스트 및 구성을위한 시간 부족으로 인해 번들로 제공되지 않습니다 (적어도 완전하지는 않음). CPAN (아래 설명)에서 찾거나 Google 또는 DuckDuckGo와 같은 웹 검색 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bdd710785412d1136d5d2fe923caa1de40582889" translate="yes" xml:space="preserve">
          <source>Many porters are also active on the &lt;a href=&quot;irc://irc.perl.org/#p5p&quot;&gt;irc://irc.perl.org/#p5p&lt;/a&gt; channel. Feel free to join the channel and ask questions about hacking on the Perl core.</source>
          <target state="translated">많은 포터도 &lt;a href=&quot;irc://irc.perl.org/#p5p&quot;&gt;irc : //irc.perl.org/#p5p&lt;/a&gt; 채널 에서 활성화됩니다 . 채널에 참여하여 Perl 코어의 해킹에 대해 질문하십시오.</target>
        </trans-unit>
        <trans-unit id="1b93f4b5b9979ea7052f6313958e026f6e2ea4a2" translate="yes" xml:space="preserve">
          <source>Many regular expression constructs don't work on EBCDIC platforms.</source>
          <target state="translated">많은 정규 표현식 구성은 EBCDIC 플랫폼에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c09ff3401dc02f5920da9178fc87b7ee9d234ec" translate="yes" xml:space="preserve">
          <source>Many system or library calls set &lt;code&gt;errno&lt;/code&gt; if they fail, to indicate the cause of failure. They usually do &lt;b&gt;not&lt;/b&gt; set &lt;code&gt;errno&lt;/code&gt; to zero if they succeed. This means &lt;code&gt;errno&lt;/code&gt; , hence &lt;code&gt;$!&lt;/code&gt; , is meaningful only</source>
          <target state="translated">많은 시스템 또는 라이브러리 호출이 실패한 경우 실패 원인을 나타 내기 위해 &lt;code&gt;errno&lt;/code&gt; 를 설정 합니다. 성공하면 일반적으로 &lt;code&gt;errno&lt;/code&gt; 를 0으로 설정 하지 &lt;b&gt;않습니다&lt;/b&gt; . 이것은 &lt;code&gt;errno&lt;/code&gt; 를 의미합니다 하므로 &lt;code&gt;$!&lt;/code&gt; 의미가 있습니다</target>
        </trans-unit>
        <trans-unit id="d15215c411905dc2055f214138f50c4dd6d3b024" translate="yes" xml:space="preserve">
          <source>Many system or library calls set &lt;code&gt;errno&lt;/code&gt; if they fail, to indicate the cause of failure. They usually do &lt;b&gt;not&lt;/b&gt; set &lt;code&gt;errno&lt;/code&gt; to zero if they succeed. This means &lt;code&gt;errno&lt;/code&gt;, hence &lt;code&gt;$!&lt;/code&gt;, is meaningful only</source>
          <target state="translated">많은 시스템 또는 라이브러리 호출이 실패하면 &lt;code&gt;errno&lt;/code&gt; 를 설정 하여 실패 원인을 표시합니다. 일반적으로 성공하면 &lt;code&gt;errno&lt;/code&gt; 를 0으로 설정 하지 &lt;b&gt;않습니다&lt;/b&gt; . 이것은 &lt;code&gt;errno&lt;/code&gt; 를 의미 하므로 &lt;code&gt;$!&lt;/code&gt; , 의미 만 있음</target>
        </trans-unit>
        <trans-unit id="c790c1897e3e898f761b95151fd508249c16664d" translate="yes" xml:space="preserve">
          <source>Many systems (DOS, VMS ODS-2) cannot have more than one &lt;code&gt;.&lt;/code&gt; in their filenames.</source>
          <target state="translated">많은 시스템 (DOS, VMS ODS-2)은 둘 이상을 가질 수 없습니다 &lt;code&gt;.&lt;/code&gt; 파일 이름으로.</target>
        </trans-unit>
        <trans-unit id="7efce1a3865da7dfdc9c988fdb8235136031c9dd" translate="yes" xml:space="preserve">
          <source>Many thanks to Florian Ragwitz for administration and packaging assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports and suggestions, to Michael Schwern for other bug reports and patches, to Mike Cariaso for helping me to figure out the Right Thing to Do About Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy (again), Mark D. Anderson, and Andrew Johnson for more suggestions about expiration, to Brent Powers for the Memoize::ExpireLRU module, to Ariel Scolnicov for delightful messages about the Fibonacci function, to Dion Almaer for thought-provoking suggestions about the default normalizer, to Walt Mankowski and Kurt Starsinic for much help investigating problems under threaded Perl, to Alex Dudkevich for reporting the bug in prototyped functions and for checking my patch, to Tony Bass for many helpful suggestions, to Jonathan Roy (again) for finding a use for &lt;code&gt;unmemoize()&lt;/code&gt; , to Philippe Verdret for enlightening discussion of &lt;code&gt;Hook::PrePostCall&lt;/code&gt; , to Nat Torkington for advice I ignored, to Chris Nandor for portability advice, to Randal Schwartz for suggesting the '&lt;code&gt;flush_cache&lt;/code&gt; function, and to Jenda Krynicky for being a light in the world.</source>
          <target state="translated">관리 및 패키징 지원에 대한 Florian Ragwitz, 버그 보고서의 경우 John Tromp, 버그 보고서 및 제안의 경우 Jonathan Roy, 기타 버그 보고서 및 패치의 경우 Michael Schwern, Mike Cariaso에게 올바른 정보를 찾는 데 도움을 주신 감사합니다. 만료에 대해, Joshua Gerth, Joshua Chamas, Jonathan Roy (다시), Mark D. Anderson 및 Andrew Johnson에게 만료에 대한 추가 제안은 Metize :: ExpireLRU 모듈, Ariel Scolnicov, Ariel Scolnicov에게 피보나치 함수, 기본 노멀 라이저에 대한 생각을 불러 일으키는 제안을 위해 Dion Almaer, Walt Mankowski 및 Kurt Starsinic, 스레드 Perl에서 문제를 조사하는 데 도움이되는 Alex Dudkevich, 프로토 타입 함수의 버그를보고하고 패치를 확인하기 위해 Tony Bass에게 많은 유용한 제안을 위해에 대 한 사용을 찾기 위해 Jonathan Roy (다시) &lt;code&gt;unmemoize()&lt;/code&gt; , Philippe Verdret, &lt;code&gt;Hook::PrePostCall&lt;/code&gt; , 토론을 위한 Nat Torkington, 이식성 조언을위한 Chris Nandor, ' &lt;code&gt;flush_cache&lt;/code&gt; 함수 를 제안하는 Randal Schwartz , 그리고 flush_cache 함수 를 제안하는 Jenda Krynicky, 세계.</target>
        </trans-unit>
        <trans-unit id="08e2587ccaa6d7cfd0ff49e65ee53ee4cc5fb187" translate="yes" xml:space="preserve">
          <source>Many thanks to Florian Ragwitz for administration and packaging assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports and suggestions, to Michael Schwern for other bug reports and patches, to Mike Cariaso for helping me to figure out the Right Thing to Do About Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy (again), Mark D. Anderson, and Andrew Johnson for more suggestions about expiration, to Brent Powers for the Memoize::ExpireLRU module, to Ariel Scolnicov for delightful messages about the Fibonacci function, to Dion Almaer for thought-provoking suggestions about the default normalizer, to Walt Mankowski and Kurt Starsinic for much help investigating problems under threaded Perl, to Alex Dudkevich for reporting the bug in prototyped functions and for checking my patch, to Tony Bass for many helpful suggestions, to Jonathan Roy (again) for finding a use for &lt;code&gt;unmemoize()&lt;/code&gt;, to Philippe Verdret for enlightening discussion of &lt;code&gt;Hook::PrePostCall&lt;/code&gt;, to Nat Torkington for advice I ignored, to Chris Nandor for portability advice, to Randal Schwartz for suggesting the '&lt;code&gt;flush_cache&lt;/code&gt; function, and to Jenda Krynicky for being a light in the world.</source>
          <target state="translated">관리 및 패키징 지원을위한 Florian Ragwitz, 버그보고를위한 John Tromp, 버그보고 및 제안을위한 Jonathan Roy, 다른 버그보고 및 패치를위한 Michael Schwern, 올바른 일을 파악하는 데 도움을 준 Mike Cariaso에게 많은 감사를드립니다. Do About Expiration, Joshua Gerth, Joshua Chamas, Jonathan Roy (다시), Mark D. Anderson 및 Andrew Johnson에게 만료에 대한 추가 제안을, Brent Powers for the Memoize :: ExpireLRU 모듈, Ariel Scolnicov에 대한 유쾌한 메시지 피보나치 함수, 기본 노멀 라이저에 대한 생각을 자극하는 제안을 Dion Almaer, 스레드 Perl에서 문제를 조사하는 데 많은 도움을 준 Walt Mankowski 및 Kurt Starsinic, 프로토 타입 함수의 버그를보고하고 패치를 확인한 Alex Dudkevich, Tony Bass에게 많은 유용한 제안을 위해용도를 찾아 준 Jonathan Roy에게 (다시) &lt;code&gt;unmemoize()&lt;/code&gt; , &lt;code&gt;Hook::PrePostCall&lt;/code&gt; PrePostCall에 대한 계몽 토론을위한 Philippe Verdret , 내가 무시한 조언을 위해 Nat Torkington, 이식성 조언을 위해 Chris Nandor, ' &lt;code&gt;flush_cache&lt;/code&gt; 함수 를 제안한 Randal Schwartz , 그리고 빛이되어 준 Jenda Krynicky에게 세계.</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="0b06a5289fc2a1842dff3a88be9b7be213a3d5b9" translate="yes" xml:space="preserve">
          <source>Map ASCII unchanged.</source>
          <target state="translated">변경되지 않은 ASCII 매핑.</target>
        </trans-unit>
        <trans-unit id="6cd0cefd9b93740b2ce288b59bbfa2506b7603b6" translate="yes" xml:space="preserve">
          <source>Map Perl operating system names to generic types</source>
          <target state="translated">Perl 운영 체제 이름을 일반 유형에 맵핑</target>
        </trans-unit>
        <trans-unit id="7d32a75bc17a4709e9d1141d1ebfa60b6cd43879" translate="yes" xml:space="preserve">
          <source>Map always returns a list, which can be assigned to a hash such that the elements become key/value pairs. See &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt; for more details.</source>
          <target state="translated">맵은 항상 목록을 반환하며,이 목록은 요소가 키 / 값 쌍이되도록 해시에 할당 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5dd04ccd71f6dc1b0c4b39870ec7fbae4d0141a" translate="yes" xml:space="preserve">
          <source>Map always returns a list, which can be assigned to a hash such that the elements become key/value pairs. See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; for more details.</source>
          <target state="translated">맵은 항상 목록을 반환하며,이 목록은 요소가 키 / 값 쌍이되도록 해시에 할당 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a9b87b1050e7882b468c1ddc762f864cd1b3ca5" translate="yes" xml:space="preserve">
          <source>Map such a character set that consists of 94 or 96 powered by N members by adding 0x80 to each byte.</source>
          <target state="translated">각 바이트에 0x80을 추가하여 N 멤버로 구동되는 94 또는 96으로 구성된 문자 집합을 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="d4fa0aeb10d9944cd20c23c3471632b3053b6c36" translate="yes" xml:space="preserve">
          <source>Mapping \x00 to '@' causes too much pain everywhere.</source>
          <target state="translated">\ x00을 '@'에 매핑하면 모든 곳에서 너무 많은 고통이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b05d51e1bee28ea12c20512307467a2c4ee871f8" translate="yes" xml:space="preserve">
          <source>Maps certain Unicode code points to their legacy Japanese cell-phone values</source>
          <target state="translated">특정 유니 코드 코드 포인트를 기존 일본어 휴대폰 값으로 매핑</target>
        </trans-unit>
        <trans-unit id="67c10042685d0de63983cda038f2ff8c2785c051" translate="yes" xml:space="preserve">
          <source>Maps from names (as in &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt;) like &quot;eacute&quot; or &quot;sol&quot; to the Unicode value that each stands for. For example, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 201, and &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 8364. You get the correct Unicode value, regardless of the version of Perl you're using -- which differs from &lt;code&gt;%Name2character&lt;/code&gt; 's behavior under pre-5.7 Perls.</source>
          <target state="translated">&quot;eacute&quot;또는 &quot;sol&quot;과 같은 이름 ( &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; )을 각각이 나타내는 유니 코드 값으로 매핑합니다. 예를 들어, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; (201)이며, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; 당신은 당신이 사용하고 펄의 버전에 관계없이 올바른 유니 코드 값을 얻을 8364.이다 -에서 어떤 다르다 &lt;code&gt;%Name2character&lt;/code&gt; 의 5.7 이전 Perls에서의 동작</target>
        </trans-unit>
        <trans-unit id="9536673c9e3743e558f91c5129ada427b7fd5a55" translate="yes" xml:space="preserve">
          <source>Maps from names (as in &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt;) like &quot;eacute&quot; or &quot;sol&quot; to the Unicode value that each stands for. For example, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 201, and &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 8364. You get the correct Unicode value, regardless of the version of Perl you're using -- which differs from &lt;code&gt;%Name2character&lt;/code&gt;'s behavior under pre-5.7 Perls.</source>
          <target state="translated">&quot;eacute&quot;또는 &quot;sol&quot;과 같은 이름 (예 : &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; )에서 각각을 나타내는 유니 코드 값으로 매핑합니다. 예를 들어, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; 는 201이고 &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; 는 8364입니다. 사용중인 Perl 버전에 관계없이 올바른 유니 코드 값을 얻습니다. 이는 &lt;code&gt;%Name2character&lt;/code&gt; 's 와 다릅니다. 5.7 이전 Perls에서의 동작.</target>
        </trans-unit>
        <trans-unit id="6d2553254721ed355ac347e903abc341219f5deb" translate="yes" xml:space="preserve">
          <source>Maps from names (as in &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt;) like &quot;eacute&quot; or &quot;sol&quot; to the string that each stands for. Note that this does not include numerics (like &quot;64&quot; or &quot;x981c&quot;). Under old Perl versions (before 5.7) you get a &quot;?&quot; in place of characters whose Unicode value is over 255.</source>
          <target state="translated">&quot;eacute&quot;또는 &quot;sol&quot;과 같은 이름 ( &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; )을 각각이 나타내는 문자열로 매핑합니다. 여기에는 &quot;64&quot;또는 &quot;x981c&quot;와 같은 숫자가 포함되지 않습니다. 이전 Perl 버전 (5.7 이전)에서는 &quot;?&quot; 유니 코드 값이 255보다 큰 문자 대신</target>
        </trans-unit>
        <trans-unit id="a1b78ee004c9a2fbd85f8f626a722e3fe6da6945" translate="yes" xml:space="preserve">
          <source>Maps the kRSUnicode property values to corresponding code points</source>
          <target state="translated">kRSUnicode 특성 값을 해당 코드 포인트에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="7b909fc95f2b4e5f8d9967846d9866d42fccc70f" translate="yes" xml:space="preserve">
          <source>Marc Green, &amp;lt;marcgreen@cpan.org&amp;gt;.</source>
          <target state="translated">마크 그린, &amp;lt;marcgreen@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="0650171f58161c1a60dbd003ef755368668ef874" translate="yes" xml:space="preserve">
          <source>March 14, 2003 (Pi day)</source>
          <target state="translated">2003 년 3 월 14 일 (파이 데이)</target>
        </trans-unit>
        <trans-unit id="8ca9751b38a5ce5495d1bc4a93437267f7e09312" translate="yes" xml:space="preserve">
          <source>March 18th, 2000</source>
          <target state="translated">2000 년 3 월 18 일</target>
        </trans-unit>
        <trans-unit id="777916db149dc5cc899516f42c23bd6b0847475c" translate="yes" xml:space="preserve">
          <source>March 2003</source>
          <target state="translated">2003 년 3 월</target>
        </trans-unit>
        <trans-unit id="6188237b0da82f2fd62e1940dd4c6b739e5e4019" translate="yes" xml:space="preserve">
          <source>March 28th, 1997; by Hugo van der Sanden: added support for code references and the already documented 'debug' method; revamped documentation.</source>
          <target state="translated">1997 년 3 월 28 일; Hugo van der Sanden : 코드 참조 및 이미 문서화 된 '디버그'방법에 대한 지원 추가; 개정 된 문서.</target>
        </trans-unit>
        <trans-unit id="719b2885e137f36b196d43363c080ddacf1c5a2e" translate="yes" xml:space="preserve">
          <source>Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">마커스 홀랜드-모리츠 &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1dfd6571ab219bad3b1cec579d53f1dfc162bfba" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">마렉 루찰 &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="264476e951a0a1cdd02faca9ecf02d9d3dd7bcf9" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, borrowing a lot of things from &lt;a href=&quot;../pod2man&quot;&gt;pod2man&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/pod2roff&quot;&gt;pod2roff&lt;/a&gt; as well as other POD processing tools by Tom Christiansen, Brad Appleton and Russ Allbery.</source>
          <target state="translated">Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Tom Christiansen, Brad Appleton 및 Russ Allbery의 다른 POD 처리 도구뿐만 아니라 &lt;a href=&quot;../pod2man&quot;&gt;pod2man&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/pod2roff&quot;&gt;pod2roff&lt;/a&gt; 에서 많은 것을 빌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="c079bae77060ca37ba3c2926c71f4d4859c75bac" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, heavily borrowing code from Nick Ing-Simmons' PodToHtml.</source>
          <target state="translated">Nick Ing-Simmons의 PodToHtml에서 코드를 많이 빌린 Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9069d6c0e29c4952ab3d16ec4d73d5cdcc560d93" translate="yes" xml:space="preserve">
          <source>Mark Allen &lt;code&gt;&amp;lt;mallen@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">마크 앨런 &lt;code&gt;&amp;lt;mallen@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c83f3f033b2fc96f5fc9ad533bd899a9d4b6ecc0" translate="yes" xml:space="preserve">
          <source>Mark Biggar said, when asked about to drop the '+' altogether, or make only &lt;code&gt;cmp&lt;/code&gt; work:</source>
          <target state="translated">Mark Biggar는 '+'를 모두 떨어 뜨리거나 &lt;code&gt;cmp&lt;/code&gt; 만 작동 하도록 요청하면 다음과 같이 말했습니다 .</target>
        </trans-unit>
        <trans-unit id="41a097411cd8ebbee57a678e8ee8e205e4008c67" translate="yes" xml:space="preserve">
          <source>Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.</source>
          <target state="translated">Mark Biggar, Ilya Zakharevich의 오버로드 인터페이스, 1996-2001.</target>
        </trans-unit>
        <trans-unit id="377509d88d53597d4ff4d33c6f13c1974a06e69d" translate="yes" xml:space="preserve">
          <source>Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in 2001 - 2006, and still at it in 2007.</source>
          <target state="translated">Ilya Zakharevich의 오버로드 된 인터페이스 인 Mark Biggar. Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 은 2001 년에서 2006 년 까지 완전히 다시 작성 했으며 2007 년에도 다시 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="ac261964132320c5f1e5015540d01455408eb496" translate="yes" xml:space="preserve">
          <source>Mark Fowler &amp;lt;markf@cpan.org&amp;gt;</source>
          <target state="translated">마크 파울러 &amp;lt;markf@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d300b7701521ff8a33f7b33d0188a117c431b382" translate="yes" xml:space="preserve">
          <source>Mark Jason Dominus</source>
          <target state="translated">마크 제이슨 도미 누스</target>
        </trans-unit>
        <trans-unit id="450f27b0693fb0a8da6251b3b74d437c26be547d" translate="yes" xml:space="preserve">
          <source>Mark Kettenis &amp;lt;kettenis@gnu.org&amp;gt;</source>
          <target state="translated">마크 케 테니스 &amp;lt;kettenis@gnu.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="81bc652b2afe581a8637a9ead94c1a383e00b3d9" translate="yes" xml:space="preserve">
          <source>Mark Reed and Roland Giersig -- Klingon translators.</source>
          <target state="translated">Mark Reed와 Roland Giersig-Klingon 번역가.</target>
        </trans-unit>
        <trans-unit id="e1debb6f407e6933148527bee46b8099a40b610d" translate="yes" xml:space="preserve">
          <source>Mark Stack</source>
          <target state="translated">마크 스택</target>
        </trans-unit>
        <trans-unit id="c8ddbdd441714aa3b5957a06f9bf2537de77f045" translate="yes" xml:space="preserve">
          <source>Mark Stosberg</source>
          <target state="translated">마크 스 토스 버그</target>
        </trans-unit>
        <trans-unit id="e5f44ec87511dcf9977a4ec17e09815c5d4e4d80" translate="yes" xml:space="preserve">
          <source>Mark all the current temporaries for reuse</source>
          <target state="translated">재사용 할 수 있도록 모든 현재 임시 표시</target>
        </trans-unit>
        <trans-unit id="9cd6842e0e13563dce83b0a4158f7d6424282172" translate="yes" xml:space="preserve">
          <source>Mark an object as not-readonly. Exactly what this mean depends on the object type. Exposed to perl code via Internals::SvREADONLY().</source>
          <target state="translated">개체를 읽기 전용이 아닌 것으로 표시합니다. 이것이 의미하는 바는 객체 유형에 따라 다릅니다. Internals :: SvREADONLY ()를 통해 펄 코드에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="31a02aa032f48d5863f9a1d17981d5d9567c8844" translate="yes" xml:space="preserve">
          <source>Mark an object as readonly. Exactly what this means depends on the object type. Exposed to perl code via Internals::SvREADONLY().</source>
          <target state="translated">개체를 읽기 전용으로 표시합니다. 이것이 정확히 의미하는 바는 객체 유형에 따라 다릅니다. Internals :: SvREADONLY ()를 통해 펄 코드에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="434c6b3d12f78673c6f025dc43bd2b5e87746cf6" translate="yes" xml:space="preserve">
          <source>Mark message &lt;code&gt;MSGNUM&lt;/code&gt; to be deleted from the remote mailbox. All messages that are marked to be deleted will be removed from the remote mailbox when the server connection closed.</source>
          <target state="translated">원격 사서함에서 삭제할 &lt;code&gt;MSGNUM&lt;/code&gt; 메시지를 표시 하십시오. 서버 연결이 닫히면 삭제 표시된 모든 메시지가 원격 사서함에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc451fa99eddaf84abe45f817ed60d28d73925f" translate="yes" xml:space="preserve">
          <source>Mark modules as loaded or unloaded</source>
          <target state="translated">모듈을로드 또는 언로드로 표시</target>
        </trans-unit>
        <trans-unit id="0952995ce715e0fcf16177cb607a92712143f22b" translate="yes" xml:space="preserve">
          <source>Mark places that need to be revisited with XXX (and revisit often!)</source>
          <target state="translated">XXX로 다시 방문해야하는 장소를 표시하고 자주 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="f890cc48bd62c292c1b2117bad32ccde46514a4e" translate="yes" xml:space="preserve">
          <source>Mark stack</source>
          <target state="translated">마크 스택</target>
        </trans-unit>
        <trans-unit id="757fbf6071a2b2fed849d8ec18f9f6866d396b4c" translate="yes" xml:space="preserve">
          <source>Mark the stream as line buffered. &lt;code&gt;PerlIOBase_setlinebuf()&lt;/code&gt; sets the PERLIO_F_LINEBUF flag and is normally sufficient.</source>
          <target state="translated">스트림을 라인 버퍼링 된 것으로 표시하십시오. &lt;code&gt;PerlIOBase_setlinebuf()&lt;/code&gt; 는 PERLIO_F_LINEBUF 플래그를 설정하며 일반적으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="0da58592dac4b83b59b8524c503019ad8f94d0df" translate="yes" xml:space="preserve">
          <source>Mark-Jason Dominus (&lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt; ), Plover Systems co.</source>
          <target state="translated">Mark-Jason Dominus ( &lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt; ), Plover Systems 사</target>
        </trans-unit>
        <trans-unit id="f0e3d2177b8ac5226b97d7fae88a022b0452ed9f" translate="yes" xml:space="preserve">
          <source>Mark-Jason Dominus (&lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt;), Plover Systems co.</source>
          <target state="translated">Mark-Jason Dominus (&lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt;), Plover Systems co.</target>
        </trans-unit>
        <trans-unit id="46fb530910c2bcc92b57abfd9b169a4f2b074dec" translate="yes" xml:space="preserve">
          <source>Mark-Jason Dominus (mjd-perl-memoize+@plover.com)</source>
          <target state="translated">Mark-Jason Dominus (mjd-perl-memoize+@plover.com)</target>
        </trans-unit>
        <trans-unit id="5686a25e5fb2f469692e134a738a6ecc07d28f5e" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;o&lt;/code&gt; as having no further siblings and marks o as having the specified parent. See also &lt;code&gt;&lt;a href=&quot;#OpMORESIB_set&quot;&gt;&quot;OpMORESIB_set&quot;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;OpMAYBESIB_set&lt;/code&gt;. For a higher-level interface, see &lt;code&gt;&lt;a href=&quot;#op_sibling_splice&quot;&gt;&quot;op_sibling_splice&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">마크 &lt;code&gt;o&lt;/code&gt; 지정된 부모를 갖는 오르토 더 형제 마크를 구비하지 않기 때문에. &lt;code&gt;&lt;a href=&quot;#OpMORESIB_set&quot;&gt;&quot;OpMORESIB_set&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; 도 참조하십시오 . 더 높은 수준의 인터페이스는 &lt;code&gt;&lt;a href=&quot;#op_sibling_splice&quot;&gt;&quot;op_sibling_splice&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98f68109ba2dde58a98de8a29bc502b61b464f61" translate="yes" xml:space="preserve">
          <source>Marks an SV as tainted if tainting is enabled.</source>
          <target state="translated">오염이 활성화 된 경우 SV를 오염 된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a080fe5381afacd2d95df891fcd34ffb1b062407" translate="yes" xml:space="preserve">
          <source>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;, either by an explicit call to &lt;code&gt;FREETMPS&lt;/code&gt;, or by an implicit call at places such as statement boundaries. &lt;code&gt;SvTEMP()&lt;/code&gt; is turned on which means that the SV's string buffer can be &quot;stolen&quot; if this SV is copied. See also &lt;code&gt;&lt;a href=&quot;#sv_newmortal&quot;&gt;&quot;sv_newmortal&quot;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sv_mortalcopy&quot;&gt;&quot;sv_mortalcopy&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기존 SV를 필사자로 표시합니다. SV는 &lt;code&gt;FREETMPS&lt;/code&gt; 에 대한 명시 적 호출 또는 명령문 경계와 같은 위치에서의 암시 적 호출에 의해 &quot;곧&quot;소멸됩니다 . &lt;code&gt;SvTEMP()&lt;/code&gt; 가 켜져 있으면이 SV가 복사되면 SV의 문자열 버퍼가 &quot;도난&quot;될 수 있습니다. &lt;code&gt;&lt;a href=&quot;#sv_newmortal&quot;&gt;&quot;sv_newmortal&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#sv_mortalcopy&quot;&gt;&quot;sv_mortalcopy&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db65aa42a74dc9034cc35ce6c1faf364427ed3b" translate="yes" xml:space="preserve">
          <source>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;, either by an explicit call to FREETMPS, or by an implicit call at places such as statement boundaries. SvTEMP() is turned on which means that the SV's string buffer can be &quot;stolen&quot; if this SV is copied. See also &lt;code&gt;sv_newmortal&lt;/code&gt; and &lt;code&gt;sv_mortalcopy&lt;/code&gt; .</source>
          <target state="translated">기존 SV를 필사자로 표시합니다. SV는 FREETMPS를 명시 적으로 호출하거나 명령문 경계와 같은 위치에서 암시 적으로 호출하여 &quot;곧&quot;파괴됩니다. SvTEMP ()가 켜져 있으면이 SV를 복사하면 SV의 문자열 버퍼가 &quot;도용&quot;될 수 있습니다. &lt;code&gt;sv_newmortal&lt;/code&gt; 및 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff643d8dde56f37f877ff7ade1da6aae5c6540db" translate="yes" xml:space="preserve">
          <source>Marks o as having no further siblings. On &lt;code&gt;PERL_OP_PARENT&lt;/code&gt; builds, marks o as having the specified parent. See also &lt;code&gt;OpMORESIB_set&lt;/code&gt; and &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; . For a higher-level interface, see &lt;code&gt;op_sibling_splice&lt;/code&gt; .</source>
          <target state="translated">더 이상 형제가없는 것으로 o를 표시합니다. 일 &lt;code&gt;PERL_OP_PARENT&lt;/code&gt; 이 빌드 O 지정된 부모를 가지는 것으로 표시. &lt;code&gt;OpMORESIB_set&lt;/code&gt; 및 &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; 도 참조하십시오 . 고급 인터페이스는 &lt;code&gt;op_sibling_splice&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f648546860128e7a1516008b618e091f14b60522" translate="yes" xml:space="preserve">
          <source>Marks the object as taint-clean, and as such data read from it will also be considered taint-clean. Note that this is a very trusting action to take, and appropriate consideration for the data source and potential vulnerability should be kept in mind. Returns 0 on success, -1 if setting the taint-clean flag failed. (eg invalid handle)</source>
          <target state="translated">객체를 얼룩 제거로 표시하고, 읽은 데이터도 얼룩 제거로 간주됩니다. 이 작업은 매우 신뢰할 수있는 조치이므로 데이터 소스 및 잠재적 취약점에 대한 적절한 고려 사항을 염두에 두어야합니다. 오염 제거 플래그 설정에 실패하면 성공하면 0을, -1을 반환합니다. (예 : 잘못된 핸들)</target>
        </trans-unit>
        <trans-unit id="4a22faf92173de5f56b8198d2fcad5f9500ee814" translate="yes" xml:space="preserve">
          <source>Marks the package as loaded to perl. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">패키지를 perl에로드 된 것으로 표시합니다. &lt;code&gt;PACKAGE&lt;/code&gt; 는 베어 워드 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04902927b1471c77962c6cabf557af3a4b22b23b" translate="yes" xml:space="preserve">
          <source>Marks the package as unloaded to perl, which is the exact opposite of &lt;code&gt;mark_as_loaded&lt;/code&gt; . &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">패키지를 perl에 언로드 된 것으로 표시합니다. 이는 &lt;code&gt;mark_as_loaded&lt;/code&gt; 와 정확히 반대입니다 . &lt;code&gt;PACKAGE&lt;/code&gt; 는 베어 워드 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719514f0bc1e227795966e35c172acb7e89879e5" translate="yes" xml:space="preserve">
          <source>Marks the package as unloaded to perl, which is the exact opposite of &lt;code&gt;mark_as_loaded&lt;/code&gt;. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">패키지를 펄에 언로드 된 것으로 표시합니다. 이는 &lt;code&gt;mark_as_loaded&lt;/code&gt; 와 정반대입니다 . &lt;code&gt;PACKAGE&lt;/code&gt; 는 베어 워드 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1f770624b796cd596d3a67943a0c4353130d2c" translate="yes" xml:space="preserve">
          <source>Marks the variable as multiply defined, thus preventing the:</source>
          <target state="translated">변수를 곱한 것으로 표시하여 다음을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="cff46171564d3d534ef0fb1847dbfa00e48f231c" translate="yes" xml:space="preserve">
          <source>Martin J. Evans &amp;lt;mjegh@ntlworld.com&amp;gt;</source>
          <target state="translated">Martin J. Evans &amp;lt;mjegh@ntlworld.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="85406e2038d0243edddde001716b01684f2778ce" translate="yes" xml:space="preserve">
          <source>Martin-Louis Bright &amp;lt;mlbright@gmail.com&amp;gt;</source>
          <target state="translated">Martin-Louis Bright &amp;lt;mlbright@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d429907f8fad8de61eed79786629c962a0844da0" translate="yes" xml:space="preserve">
          <source>Massachusetts</source>
          <target state="translated">Massachusetts</target>
        </trans-unit>
        <trans-unit id="37e5fcb1ae2486eac4310780e954d1d2153d08b1" translate="yes" xml:space="preserve">
          <source>Mastering Perl</source>
          <target state="translated">마스터 링 펄</target>
        </trans-unit>
        <trans-unit id="ea351e672a82e1244cd8779022e09f0034f5a7e1" translate="yes" xml:space="preserve">
          <source>Mastering Regular Expressions</source>
          <target state="translated">정규 표현식 마스터하기</target>
        </trans-unit>
        <trans-unit id="22d4d02d8da4f8d133bb080e8bf0a53687196993" translate="yes" xml:space="preserve">
          <source>Match 'a' followed by 'b' followed by 'c'. We are on a roll and have satisfied the first group. Set $1 to 'abc'.</source>
          <target state="translated">'a'와 'b', 'c'를 차례로 찾습니다. 우리는 롤에 올라 첫 그룹을 만족 시켰습니다. $ 1을 'abc'로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="11c4d0b2479d50705f90c54d0532f70025aab256" translate="yes" xml:space="preserve">
          <source>Match 'a' followed by 'b'. So far so good.</source>
          <target state="translated">'a'다음에 'b'를 찾습니다. 여태까지는 그런대로 잘됐다.</target>
        </trans-unit>
        <trans-unit id="2d4b771841aed044053e2a7426782a75fac41932" translate="yes" xml:space="preserve">
          <source>Match all subsections of &lt;code&gt;DESCRIPTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 의 모든 하위 섹션과 일치</target>
        </trans-unit>
        <trans-unit id="0b37627cd568766a8a2fde5b6baa2adc0dd0c782" translate="yes" xml:space="preserve">
          <source>Match all top level sections but none of their subsections:</source>
          <target state="translated">모든 최상위 섹션과 일치하지만 하위 섹션은 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0596c8f0742f8f130e5e576d30972fa9f4302b5" translate="yes" xml:space="preserve">
          <source>Match only the &lt;code&gt;Question&lt;/code&gt; and &lt;code&gt;Answer&lt;/code&gt; subsections of the &lt;code&gt;DESCRIPTION&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 섹션 의 &lt;code&gt;Question&lt;/code&gt; 과 &lt;code&gt;Answer&lt;/code&gt; 하위 섹션 만 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c0e7fa8eb9c5a3355dde0bfcb14e87f4ae52937c" translate="yes" xml:space="preserve">
          <source>Match the 'd'.</source>
          <target state="translated">'d'와 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="be1f5f366bde2e61ff344fc7793ee6e0a4508408" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;Comments&lt;/code&gt; subsection of</source>
          <target state="translated">의 &lt;code&gt;Comments&lt;/code&gt; 하위 섹션과 일치</target>
        </trans-unit>
        <trans-unit id="e025337ed7c230f237c28a1acfe5d3575399196a" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;DESCRIPTION&lt;/code&gt; section but do</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 섹션과 일치 하지만</target>
        </trans-unit>
        <trans-unit id="809b44171d8c193bc9b4db448d041eca1d612988" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;NAME&lt;/code&gt; and &lt;code&gt;SYNOPSIS&lt;/code&gt; sections and all of their subsections:</source>
          <target state="translated">&lt;code&gt;NAME&lt;/code&gt; 및 &lt;code&gt;SYNOPSIS&lt;/code&gt; 섹션과 모든 하위 섹션을 일치 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="94b47b1709b60267b313ebe40e8ce16e55fa004d" translate="yes" xml:space="preserve">
          <source>Matched non-Unicode code point 0x%X against Unicode property; may not be portable</source>
          <target state="translated">유니 코드 속성과 일치하는 비 유니 코드 코드 포인트 0x % X; 휴대용이 아닐 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d89688e77597d0f0b5bc24a196b8aa4f24d28f78" translate="yes" xml:space="preserve">
          <source>Matches a character that has a non-canonical decomposition.</source>
          <target state="translated">비정규 분해 된 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a6f252d85159e471dcc7245d171fafb38fcd2b97" translate="yes" xml:space="preserve">
          <source>Matches a literal '.'. Equivalent to the Perl regular expression</source>
          <target state="translated">리터럴 '.'와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="93575811859840b893fbf3a9e80a1bb8c50a691a" translate="yes" xml:space="preserve">
          <source>Matches any character that is graphic. Theoretically, this means a character that on a printer would cause ink to be used.</source>
          <target state="translated">그래픽 인 모든 문자와 일치합니다. 이론적으로 이것은 프린터에서 잉크를 사용하게하는 문자를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d54b8cec84523d2bbc940d4158b99d956e15f640" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;SSS...S&lt;/code&gt; (repeated as many times as necessary).</source>
          <target state="translated">&lt;code&gt;SSS...S&lt;/code&gt; 와 일치합니다 (필요한 횟수만큼 반복).</target>
        </trans-unit>
        <trans-unit id="c4ff6981c871c3a904b9e8169f3626531b5fd219" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;S{max}|S{max-1}|...|S{min+1}|S{min}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S{max}|S{max-1}|...|S{min+1}|S{min}&lt;/code&gt; 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="bd5e1550fb89dce10a89ca6b24a5232964ff2f7b" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;S{min}|S{min+1}|...|S{max-1}|S{max}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S{min}|S{min+1}|...|S{max-1}|S{max}&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="5723f68cdd1b82a0a16aaa3d449fb53afe9be816" translate="yes" xml:space="preserve">
          <source>Matches in the Block property have shortcuts that begin with &quot;In_&quot;. For example, &lt;code&gt;\p{Block=Latin1}&lt;/code&gt; can be written as &lt;code&gt;\p{In_Latin1}&lt;/code&gt; . For backward compatibility, if there is no conflict with another shortcut, these may also be written as &lt;code&gt;\p{Latin1}&lt;/code&gt; or &lt;code&gt;\p{Is_Latin1}&lt;/code&gt; . But, N.B., there are numerous such conflicting shortcuts. Use of these forms for Block is discouraged, and are flagged as such, not only because of the potential confusion as to what is meant, but also because a later release of Unicode may preempt the shortcut, and your program would no longer be correct. Use the &quot;In_&quot; form instead to avoid this, or even more clearly, use the compound form, e.g., &lt;code&gt;\p{blk:latin1}&lt;/code&gt; . See &lt;a href=&quot;perlunicode#Blocks&quot;&gt;Blocks in perlunicode&lt;/a&gt; for more information about this.</source>
          <target state="translated">블록 속성의 일치 항목에는 &quot;In_&quot;로 시작하는 바로 가기가 있습니다. 예를 들어, &lt;code&gt;\p{Block=Latin1}&lt;/code&gt; 은 &lt;code&gt;\p{In_Latin1}&lt;/code&gt; 로 쓸 수 있습니다 . 이전 버전과의 호환성을 위해 다른 바로 가기와 충돌이없는 경우 &lt;code&gt;\p{Latin1}&lt;/code&gt; 또는 &lt;code&gt;\p{Is_Latin1}&lt;/code&gt; 로 작성 될 수도 있습니다 . 그러나 NB에는 그러한 상충되는 단축키가 많이 있습니다. 이러한 형식의 블록 사용은 권장되지 않으며 의미에 대한 혼동 가능성뿐만 아니라 이후의 유니 코드 릴리스가 바로 가기를 선점 할 수 있으며 프로그램이 더 이상 정확하지 않기 때문에 플래그가 지정됩니다. 이를 피하기 위해 &quot;In_&quot;양식을 대신 사용하거나보다 명확하게는 복합 양식을 사용하십시오 (예 : &lt;code&gt;\p{blk:latin1}&lt;/code&gt; . 보다&lt;a href=&quot;perlunicode#Blocks&quot;&gt;이에&lt;/a&gt; 대한 자세한 정보 는 perlunicode의 블록입니다 .</target>
        </trans-unit>
        <trans-unit id="dc2bbbf4e6e6201407867c19a270d77748d37bd5" translate="yes" xml:space="preserve">
          <source>Matches the best match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; and only that.</source>
          <target state="translated">&lt;code&gt;&quot;S&quot;&lt;/code&gt; 에 대한 최상의 일치 만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="80d7f5dbe400c6fc8812e001032594152a2faa28" translate="yes" xml:space="preserve">
          <source>Matches the best match for &lt;code&gt;S&lt;/code&gt; and only that.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 와 가장 일치하는 항목 만 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="099232daa21ff3b64c97abd1d81e14f11a613969" translate="yes" xml:space="preserve">
          <source>Matches zero or more characters, except '/'. Equivalent to the Perl regular expression</source>
          <target state="translated">'/'를 제외하고 0 개 이상의 문자와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="6a1984e70dd40a8e14356e78cd264d97a21884d9" translate="yes" xml:space="preserve">
          <source>Matches zero or one character, except '/'. Equivalent to the Perl regular expression</source>
          <target state="translated">'/'를 제외하고 0 또는 1 개의 문자와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="5150558ec125a3f4852d898bf9fb73076c3ddf80" translate="yes" xml:space="preserve">
          <source>Matching</source>
          <target state="translated">Matching</target>
        </trans-unit>
        <trans-unit id="68a934788aa891939224fba053b378c53192480e" translate="yes" xml:space="preserve">
          <source>Matching Partial Keys</source>
          <target state="translated">일치하는 부분 키</target>
        </trans-unit>
        <trans-unit id="5fa10e5481e42bdee7f9fef5a014c3afab8e48c3" translate="yes" xml:space="preserve">
          <source>Matching Scripts and Blocks</source>
          <target state="translated">일치하는 스크립트 및 블록</target>
        </trans-unit>
        <trans-unit id="3b17040c55a83f3f4f7b152219e6e526f7ca9a2a" translate="yes" xml:space="preserve">
          <source>Matching any of several properties in regular expressions.</source>
          <target state="translated">정규식의 여러 속성 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="deda9db8be66cd716c834c123a9cb9611817c650" translate="yes" xml:space="preserve">
          <source>Matching in list context</source>
          <target state="translated">목록 컨텍스트에서 일치</target>
        </trans-unit>
        <trans-unit id="6220591a5ccdb9123634e1caf4ce8dc3384cfc2e" translate="yes" xml:space="preserve">
          <source>Matching operations can have various modifiers. Modifiers that relate to the interpretation of the regular expression inside are listed below. Modifiers that alter the way a regular expression is used by Perl are detailed in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">일치하는 작업에는 다양한 수정자가있을 수 있습니다. 정규 표현식 내부의 해석과 관련된 수정자는 다음과 같습니다. 정규 표현식은 펄에 의해 사용되는 방식을 변경 수정 자에 자세히 설명되어 있습니다 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop에서 정규 표현식 견적 같은 연산자&lt;/a&gt; 와 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlop에서 인용 구조를 구문 분석의 피투성이 세부 사항&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc4353fa78241930d31f3d814bb73f45e31af0a6" translate="yes" xml:space="preserve">
          <source>Matching repetitions</source>
          <target state="translated">일치하는 반복</target>
        </trans-unit>
        <trans-unit id="292a005613f8b511eb0b5b4a734aa7ff4e96c83f" translate="yes" xml:space="preserve">
          <source>Matching this or that</source>
          <target state="translated">이것 또는 저것과 일치</target>
        </trans-unit>
        <trans-unit id="7bedce9e99b3de1dadd0cc8345ab455769b51642" translate="yes" xml:space="preserve">
          <source>Math Library</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="dbc9077ff7ea4f194a50599f69ee6ce9e49343a0" translate="yes" xml:space="preserve">
          <source>Math library</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="5dde5a34dad7754b1821ed0116c07f6b3c7c4405" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called</source>
          <target state="translated">숫자가있는 수학은 기본적으로 모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="65a2121388185141d7f0caa9707912405aa48f4e" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called &lt;code&gt;Math::BigInt::Calc&lt;/code&gt; . This is equivalent to saying:</source>
          <target state="translated">숫자가있는 수학은 기본적으로 &lt;code&gt;Math::BigInt::Calc&lt;/code&gt; 모듈에 의해 수행됩니다 . 이것은 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d07c5c8a1e8adee66f831b9574d087918f9c747" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called &lt;code&gt;Math::BigInt::Calc&lt;/code&gt;. This is equivalent to saying:</source>
          <target state="translated">숫자를 사용한 수학은 &lt;code&gt;Math::BigInt::Calc&lt;/code&gt; 라는 모듈에 의해 기본적으로 수행됩니다 . 이것은 다음과 같은 말과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="51f99b48efcd60261390302dfaa9e7f1788ebcc0" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called Math::BigInt::Calc. This is equivalent to saying:</source>
          <target state="translated">숫자가있는 수학은 기본적으로 Math :: BigInt :: Calc라는 모듈에 의해 수행됩니다. 이것은 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a07cdeda4567e42eb8f69d272a000e41f1b29c0e" translate="yes" xml:space="preserve">
          <source>Math::BigFloat</source>
          <target state="translated">Math::BigFloat</target>
        </trans-unit>
        <trans-unit id="fe59e6f09a28dc58e14251546f9c9f1708a1bf4c" translate="yes" xml:space="preserve">
          <source>Math::BigFloat - Arbitrary size floating point math package</source>
          <target state="translated">Math :: BigFloat-임의 크기 부동 소수점 수학 패키지</target>
        </trans-unit>
        <trans-unit id="0764aaf5c109cb7a50fb7de2184cafba8feab350" translate="yes" xml:space="preserve">
          <source>Math::BigFloat provides support for arbitrary precision floating point. Overloading is also provided for Perl operators.</source>
          <target state="translated">Math :: BigFloat는 임의 정밀도 부동 소수점을 지원합니다. Perl 연산자에 대해서도 오버로딩이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d51b07374f8cf291c43bbc72e105d93bd0861cc4" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports all methods that Math::BigInt supports, except it calculates non-integer results when possible. Please see &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for a full description of each method. Below are just the most important differences:</source>
          <target state="translated">Math :: BigFloat는 가능한 경우 정수가 아닌 결과를 계산하는 것을 제외하고 Math :: BigInt가 지원하는 모든 메서드를 지원합니다. 각 메서드에 대한 자세한 설명 은 &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt&lt;/a&gt; 를 참조하십시오 . 다음은 가장 중요한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="8e8c8a53ad2ae8063e325c75dd2f5dac801b81e3" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports all methods that Math::BigInt supports, except it calculates non-integer results when possible. Please see &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for a full description of each method. Below are just the most important differences:</source>
          <target state="translated">Math :: BigFloat는 가능하면 정수가 아닌 결과를 계산하는 것을 제외하고 Math :: BigInt가 지원하는 모든 메소드를 지원합니다. 각 방법에 대한 자세한 설명 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 를 참조하십시오 . 다음은 가장 중요한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="b207eda77e8bcb4cfdb781c992961d80a17ed622" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy (rounding to a certain number of digits). For a full documentation, examples and tips on these topics please see the large section about rounding in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">Math :: BigFloat는 정밀도 (점 앞 또는 뒤의 특정 위치로 반올림)와 정확도 (특정 자릿수로 반올림)를 모두 지원합니다. 이 주제에 대한 전체 문서, 예제 및 팁은 &lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt의&lt;/a&gt; 반올림에 대한 큰 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="780bc62d9e1c2da0b867ab07361ad578cdc89952" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy (rounding to a certain number of digits). For a full documentation, examples and tips on these topics please see the large section about rounding in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">Math :: BigFloat는 정밀도 (점 앞뒤의 특정 위치로 반올림)와 정확도 (특정 자릿수로 반올림)를 모두 지원합니다. 이러한 주제에 대한 전체 문서, 예제 및 팁은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt의&lt;/a&gt; 반올림에 대한 큰 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2789f47b2fa742bffb303cb5ea1d3e3348e9f0" translate="yes" xml:space="preserve">
          <source>Math::BigInt</source>
          <target state="translated">Math::BigInt</target>
        </trans-unit>
        <trans-unit id="5c0b5ec1b926593506155ef502257108ea19865c" translate="yes" xml:space="preserve">
          <source>Math::BigInt - Arbitrary size integer/float math package</source>
          <target state="translated">Math :: BigInt-임의 크기 정수 / 부동 수학 패키지</target>
        </trans-unit>
        <trans-unit id="4abcb1313f3f34175afd42fcf44f38a824ea23a7" translate="yes" xml:space="preserve">
          <source>Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</source>
          <target state="translated">Math :: BigInt 및 Math :: BigFloat는 정확성 및 정밀도 기반 반올림을 완벽하게 지원하며, 모든 작업 후 자동으로 또는 수동으로 둘 다 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e145603092e31477779f0bafc7a4914f97dc56cf" translate="yes" xml:space="preserve">
          <source>Math::BigInt provides support for arbitrary precision integers. Overloading is also provided for Perl operators.</source>
          <target state="translated">Math :: BigInt는 임의 정밀도 정수를 지원합니다. Perl 연산자에 대해서도 오버로딩이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d6c99c78464ade46f8079c42dd339841ba07d8ba" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc</source>
          <target state="translated">Math::BigInt::Calc</target>
        </trans-unit>
        <trans-unit id="fb8a4bd98ced9e335bf9d9e0731551b00eb92084" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc - Pure Perl module to support Math::BigInt</source>
          <target state="translated">Math :: BigInt :: Calc-Math :: BigInt를 지원하는 Pure Perl 모듈</target>
        </trans-unit>
        <trans-unit id="d0217de2885343284f5e67144b9c98117886dd87" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc inherits from Math::BigInt::Lib.</source>
          <target state="translated">Math :: BigInt :: Calc는 Math :: BigInt :: Lib에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="83eed48c0cfaa744405df7e64a828e97c7dc018c" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc with some XS for more speed</source>
          <target state="translated">더 빠른 속도를 위해 일부 XS를 사용하여 Math :: BigInt :: Calc</target>
        </trans-unit>
        <trans-unit id="37cc8c4470bd2dc063bf4602791a5a2898c073f2" translate="yes" xml:space="preserve">
          <source>Math::BigInt::CalcEmu</source>
          <target state="translated">Math::BigInt::CalcEmu</target>
        </trans-unit>
        <trans-unit id="bd9adb285778e576dd3a1c8d47e1303fcd5d2e82" translate="yes" xml:space="preserve">
          <source>Math::BigInt::CalcEmu - Emulate low-level math with BigInt code</source>
          <target state="translated">Math :: BigInt :: CalcEmu-BigInt 코드로 저수준 수학 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="a6065b7a8854e3e8b505e0d8a52c5366a086da7a" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc</source>
          <target state="translated">Math::BigInt::FastCalc</target>
        </trans-unit>
        <trans-unit id="07a7add3262d9f2bcc6e971e59caaf7ebde004ed" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc - Math::BigInt::Calc with some XS for more speed</source>
          <target state="translated">Math :: BigInt :: FastCalc-Math :: BigInt :: 더 빠른 속도를 위해 일부 XS를 사용한 계산기</target>
        </trans-unit>
        <trans-unit id="1f2ff58ab3e905796e4394ce75ed113142144b4e" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc inherits from Math::BigInt::Calc.</source>
          <target state="translated">Math :: BigInt :: FastCalc는 Math :: BigInt :: Calc에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="be4788ce129ade27059132f77e1626e6603cd2ee" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc works exactly like Math::BigInt::Calc. Numbers are stored in decimal form chopped into parts.</source>
          <target state="translated">Math :: BigInt :: FastCalc는 Math :: BigInt :: Calc와 똑같이 작동합니다. 숫자는 부분으로 잘린 십진수 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="81bb13328947ab5168b53e9d6a7a4bf1b2e650dc" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Lib</source>
          <target state="translated">Math::BigInt::Lib</target>
        </trans-unit>
        <trans-unit id="1048528123aeb8d39ba7c3b96a0179eac5a9dc21" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Lib - virtual parent class for Math::BigInt libraries</source>
          <target state="translated">Math :: BigInt :: Lib-Math :: BigInt 라이브러리의 가상 부모 클래스</target>
        </trans-unit>
        <trans-unit id="4b2aca3f9cc0a116b76f8d86d32d03b2be17c352" translate="yes" xml:space="preserve">
          <source>Math::BigRat</source>
          <target state="translated">Math::BigRat</target>
        </trans-unit>
        <trans-unit id="ac918a8052350ca0ef4432d06915fcf97fe7f4ff" translate="yes" xml:space="preserve">
          <source>Math::BigRat - Arbitrary big rational numbers</source>
          <target state="translated">Math :: BigRat-임의의 큰 유리수</target>
        </trans-unit>
        <trans-unit id="5a51ed6183023c12205f7010c9031e0ea41bd8ab" translate="yes" xml:space="preserve">
          <source>Math::BigRat complements Math::BigInt and Math::BigFloat by providing support for arbitrary big rational numbers.</source>
          <target state="translated">Math :: BigRat은 임의의 큰 유리수를 지원하여 Math :: BigInt 및 Math :: BigFloat를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="c80a28032631e0b53fe6cfb473619c4706043d3a" translate="yes" xml:space="preserve">
          <source>Math::Complex</source>
          <target state="translated">Math::Complex</target>
        </trans-unit>
        <trans-unit id="33bb8bb129e5a0d683c736bb8619d7d51a89c445" translate="yes" xml:space="preserve">
          <source>Math::Complex - complex numbers and associated mathematical functions</source>
          <target state="translated">Math :: Complex-복소수 및 관련 수학 함수</target>
        </trans-unit>
        <trans-unit id="1e616d3d033099b786d6a5348898f4e4eaaef6c6" translate="yes" xml:space="preserve">
          <source>Math::Trig</source>
          <target state="translated">Math::Trig</target>
        </trans-unit>
        <trans-unit id="c69768dcbf705d5dd806188830336370c242165f" translate="yes" xml:space="preserve">
          <source>Math::Trig - trigonometric functions</source>
          <target state="translated">Math :: Trig-삼각 함수</target>
        </trans-unit>
        <trans-unit id="1c3decdb38e1f19ad133e95ff4746595003c9925" translate="yes" xml:space="preserve">
          <source>Mathemagic, Mutators, and Copy Constructors</source>
          <target state="translated">Mathemagic, 뮤 테이터 및 복사 생성자</target>
        </trans-unit>
        <trans-unit id="8edc9ac7baa876487a18001d1e0613039a5fb80e" translate="yes" xml:space="preserve">
          <source>Mathematical functions</source>
          <target state="translated">수학 함수</target>
        </trans-unit>
        <trans-unit id="418773dca64d526cfea9242d86f08af7459acfc2" translate="yes" xml:space="preserve">
          <source>Mathematical jargon for a list of &lt;b&gt;scalar values&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;스칼라 값&lt;/b&gt; 목록에 대한 수학 용어 .</target>
        </trans-unit>
        <trans-unit id="aa8961350eea449561e0373a262893039189bac1" translate="yes" xml:space="preserve">
          <source>Mathematically, a mapping of each of a set of input values to a particular output value. In computers, refers to a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;operator&lt;/b&gt; that returns a &lt;b&gt;value&lt;/b&gt;. It may or may not have input values (called &lt;b&gt;arguments&lt;/b&gt;).</source>
          <target state="translated">수학적으로 입력 값 집합 각각을 특정 출력 값에 매핑합니다. 컴퓨터에서 &lt;b&gt;값&lt;/b&gt; 을 반환하는 &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;연산자&lt;/b&gt; 를 나타냅니다 . 입력 값이 있거나 없을 수 있습니다 ( &lt;b&gt;arguments&lt;/b&gt; 라고 함 ).&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="58227b459a1ed9747b8ae17f0db465ba9897bda0" translate="yes" xml:space="preserve">
          <source>Matt Kraai</source>
          <target state="translated">Matt Kraai</target>
        </trans-unit>
        <trans-unit id="3b9691065df69a421dca45239b2430dd14f8c4f5" translate="yes" xml:space="preserve">
          <source>Matt S Trout &amp;lt;mst@shadowcat.co.uk&amp;gt;</source>
          <target state="translated">Matt S Trout &amp;lt;mst@shadowcat.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="08452ede2be309e7d15ec8e7c08c3981bd4285e0" translate="yes" xml:space="preserve">
          <source>Matt Sergeant, matt@sergeant.org</source>
          <target state="translated">매트 상사, matt@sergeant.org</target>
        </trans-unit>
        <trans-unit id="667478bd6904915672e26b2134308dabeb1c00d5" translate="yes" xml:space="preserve">
          <source>Matt Sergeant, matt@sergeant.org Jarkko Hietaniemi, jhi@iki.fi (while creating Time::Piece for core perl)</source>
          <target state="translated">Matt Sergeant, matt@sergeant.org Jarkko Hietaniemi, jhi@iki.fi (핵심 Perl의 Time :: Piece 작성 중)</target>
        </trans-unit>
        <trans-unit id="a5b0f4aadc0e2c80f215b9e66188372b0c8b6032" translate="yes" xml:space="preserve">
          <source>Max Maischein &lt;code&gt; corion@cpan.org &lt;/code&gt;</source>
          <target state="translated">막스 마이 &lt;code&gt; corion@cpan.org &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfb7aa9e8b9c834788a3aa7abbda0d104b6ff028" translate="yes" xml:space="preserve">
          <source>Max. codesize limited to 32-bit</source>
          <target state="translated">맥스. 32 비트로 제한된 코드 크기</target>
        </trans-unit>
        <trans-unit id="2bc25b9c27334b35a5cb78bdecefd32cc568034e" translate="yes" xml:space="preserve">
          <source>Maximal count of pending signals (%u) exceeded</source>
          <target state="translated">보류중인 신호 (% u)의 최대 개수를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="c6400e7876545feb6ada4a737cb20190ee5f945e" translate="yes" xml:space="preserve">
          <source>Maximize version number.</source>
          <target state="translated">버전 번호를 최대화하십시오.</target>
        </trans-unit>
        <trans-unit id="2bc823b3979073e6178e0296c0aebc017c151728" translate="yes" xml:space="preserve">
          <source>Maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt; , returns the other [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 일 때를 제외하고 최대 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 는 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e12ab395f246967e38c39d0164a8a0da4c633fb6" translate="yes" xml:space="preserve">
          <source>Maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt;, returns the other [C99].</source>
          <target state="translated">둘 중 하나가 &lt;code&gt;NaN&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 최대 값은 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9d1027058fd884db456494cfd72c7b066e0129a" translate="yes" xml:space="preserve">
          <source>Maximum record size</source>
          <target state="translated">최대 기록 크기</target>
        </trans-unit>
        <trans-unit id="271672ee5b929c229ec830e1084ec7061feed01f" translate="yes" xml:space="preserve">
          <source>Maximum requirements are inclusive. No version strictly greater than the given version is allowed.</source>
          <target state="translated">최대 요구 사항이 포함됩니다. 주어진 버전보다 더 큰 버전은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="650306b9428b07712d05d5e699489f15d25896b7" translate="yes" xml:space="preserve">
          <source>May 2003</source>
          <target state="translated">2003 년 5 월</target>
        </trans-unit>
        <trans-unit id="8d8f71838e536df93422bf7418bcffe308e1974e" translate="yes" xml:space="preserve">
          <source>May 8, 2003</source>
          <target state="translated">2003 년 5 월 8 일</target>
        </trans-unit>
        <trans-unit id="afc54fe3511cd56aa93944ccd6c2072e2ca51d94" translate="yes" xml:space="preserve">
          <source>May also be called as a</source>
          <target state="translated">로도 불릴 수 있습니다</target>
        </trans-unit>
        <trans-unit id="76be650e3300b2492c54955a124602e50e04fd33" translate="yes" xml:space="preserve">
          <source>May be called as a class method</source>
          <target state="translated">클래스 메소드로 호출 가능</target>
        </trans-unit>
        <trans-unit id="373dacfb6afd2988bb2976a418753e29f34aa9dd" translate="yes" xml:space="preserve">
          <source>May be interrupted if the process receives a signal such as &lt;code&gt;SIGALRM&lt;/code&gt; .</source>
          <target state="translated">프로세스가 &lt;code&gt;SIGALRM&lt;/code&gt; 과 같은 신호를 수신하면 중단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62f3ade73a821f1ea24a0f8d795c26cf1e6ce565" translate="yes" xml:space="preserve">
          <source>May be interrupted if the process receives a signal such as &lt;code&gt;SIGALRM&lt;/code&gt;.</source>
          <target state="translated">프로세스가 &lt;code&gt;SIGALRM&lt;/code&gt; 과 같은 신호를 수신하면 중단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2230ed94de04068bc4c024644ecc248cb32a6f12" translate="yes" xml:space="preserve">
          <source>May be set to &lt;code&gt;-protoypes&lt;/code&gt; , &lt;code&gt;-noprototypes&lt;/code&gt; or the empty string. The empty string is equivalent to the xsubpp default, or &lt;code&gt;-noprototypes&lt;/code&gt; . See the xsubpp documentation for details. MakeMaker defaults to the empty string.</source>
          <target state="translated">&lt;code&gt;-protoypes&lt;/code&gt; , &lt;code&gt;-noprototypes&lt;/code&gt; 또는 빈 문자열 로 설정 될 수 있습니다 . 빈 문자열은 xsubpp 기본값 또는 &lt;code&gt;-noprototypes&lt;/code&gt; 와 같습니다 . 자세한 내용은 xsubpp 설명서를 참조하십시오. MakeMaker의 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7fbcb527743fae7057a349e19014df074468e03d" translate="yes" xml:space="preserve">
          <source>May be set to &lt;code&gt;-protoypes&lt;/code&gt;, &lt;code&gt;-noprototypes&lt;/code&gt; or the empty string. The empty string is equivalent to the xsubpp default, or &lt;code&gt;-noprototypes&lt;/code&gt;. See the xsubpp documentation for details. MakeMaker defaults to the empty string.</source>
          <target state="translated">&lt;code&gt;-protoypes&lt;/code&gt; , &lt;code&gt;-noprototypes&lt;/code&gt; 또는 빈 문자열 로 설정할 수 있습니다 . 빈 문자열은 xsubpp 기본값 또는 &lt;code&gt;-noprototypes&lt;/code&gt; 와 동일합니다 . 자세한 내용은 xsubpp 문서를 참조하십시오. MakeMaker의 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="61bbde05c6ed2bdfce6b99696af957752900542f" translate="yes" xml:space="preserve">
          <source>May be used to disable a filter, but is rarely needed. See &lt;a href=&quot;filter_del&quot;&gt;filter_del&lt;/a&gt;.</source>
          <target state="translated">필터를 비활성화하는 데 사용할 수 있지만 거의 필요하지 않습니다. &lt;a href=&quot;filter_del&quot;&gt;filter_del을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d4efb207d6eec8eaeb59feea09701cb59c03617" translate="yes" xml:space="preserve">
          <source>May be used with -d to modify the first release criteria.</source>
          <target state="translated">-d와 함께 사용하여 첫 번째 릴리스 기준을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8aed58dc1a5779f9d540d01df5f9836265ac5aa" translate="yes" xml:space="preserve">
          <source>May not be available if library or source was not provided when building perl. (Win32)</source>
          <target state="translated">perl을 빌드 할 때 라이브러리 또는 소스가 제공되지 않은 경우 사용할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="21d4e632642238bf57dcc94af3549a614c826f30" translate="yes" xml:space="preserve">
          <source>May not behave as expected. Behavior depends on the C runtime library's implementation of &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt;, and the filesystem being used. The FAT filesystem typically does not support an &quot;access time&quot; field, and it may limit timestamps to a granularity of two seconds. (Win32)</source>
          <target state="translated">예상대로 작동하지 않을 수 있습니다. 동작은 C 런타임 라이브러리의 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; 구현 및 사용중인 파일 시스템에 따라 다릅니다 . FAT 파일 시스템은 일반적으로 &quot;액세스 시간&quot;필드를 지원하지 않으며 타임 스탬프를 2 초 단위로 제한 할 수 있습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="55f01979402408f498d72bc9013d9ad19e4f0e16" translate="yes" xml:space="preserve">
          <source>May take extra time to study SCALAR (&lt;code&gt;$_&lt;/code&gt; if unspecified) in anticipation of doing many pattern matches on the string before it is next modified. This may or may not save time, depending on the nature and number of patterns you are searching and the distribution of character frequencies in the string to be searched; you probably want to compare run times with and without it to see which is faster. Those loops that scan for many short constant strings (including the constant parts of more complex patterns) will benefit most.</source>
          <target state="translated">문자열이 다음에 수정되기 전에 많은 패턴 일치를 예상하여 SCALAR ( 지정되지 않은 경우 &lt;code&gt;$_&lt;/code&gt; 를 연구하는 데 추가 시간이 걸릴 수 있습니다 . 검색하는 패턴의 성격과 수 및 검색 할 문자열의 문자 빈도 분포에 따라 시간을 절약하거나 절약 할 수 있습니다. 실행 시간과 실행 시간을 비교하여 어느 것이 더 빠른지 확인하고 싶을 것입니다. 많은 짧은 상수 문자열 (더 복잡한 패턴의 상수 부분 포함)을 스캔하는 루프가 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5740917ad4ecd92dc69b592bee2c126f65bf64cc" translate="yes" xml:space="preserve">
          <source>Maybe an autolocking mode?</source>
          <target state="translated">자동 잠금 모드일까요?</target>
        </trans-unit>
        <trans-unit id="17baa904576f5c89cb04e825ade31958aeaa5cd3" translate="yes" xml:space="preserve">
          <source>Maybe simply that your function did not need to be exported in the first place. Perl has a long and not so glorious history of exporting functions that it should not have.</source>
          <target state="translated">아마도 단순히 함수를 먼저 내보낼 필요가 없었을 것입니다. Perl은 오랫동안 가져 오지 말아야 할 함수 내보내기의 길고 영광스러운 역사를 가지고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e936eae5362c54e4c8af6287c324b783d9e5c3e" translate="yes" xml:space="preserve">
          <source>McAfee Guardian</source>
          <target state="translated">McAfee Guardian</target>
        </trans-unit>
        <trans-unit id="cde7070dd55ab5fad4aecced0aebd3d04e8674c3" translate="yes" xml:space="preserve">
          <source>Meaningless. (RISC OS)</source>
          <target state="translated">무의미한. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="64570578bb629125c651aed9b004e56379071150" translate="yes" xml:space="preserve">
          <source>Means that the optimizer information is all that the regular expression contains, and thus one does not need to enter the regex engine at all.</source>
          <target state="translated">옵티 마이저 정보는 정규 표현식에 포함 된 모든 것이므로 정규식 엔진에 전혀 들어 가지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="5c65173ed0ec89e479fa09fd6c0c7e73dddb4a5c" translate="yes" xml:space="preserve">
          <source>Means you can still run your old program because we didn&amp;rsquo;t break any of the features or bugs it was relying on.</source>
          <target state="translated">우리가 의존했던 기능이나 버그를 깨뜨리지 않았으므로 이전 프로그램을 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c883ddc8815110562192710c7cee3da6f78c83a" translate="yes" xml:space="preserve">
          <source>Means you don&amp;rsquo;t have to pay money to get it, but the copyright on it may still belong to someone else (like Larry).</source>
          <target state="translated">당신이 그것을 얻기 위해 돈을 지불 할 필요는 없지만, 그것에 대한 저작권은 여전히 ​​Larry와 같은 다른 사람의 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf0f10f278f2fd9b8fbb27cda2cf259516fe6e6" translate="yes" xml:space="preserve">
          <source>Means you&amp;rsquo;re not in legal trouble if you give a bootleg copy of it to your friends and we find out about it. In fact, we&amp;rsquo;d rather you gave a copy to all your friends.</source>
          <target state="translated">부트 레그 사본을 친구에게주고 우리가 그 사실을 알게된다면 법적인 문제가 없다는 것을 의미합니다. 사실, 모든 친구에게 사본을 주셨습니다.</target>
        </trans-unit>
        <trans-unit id="b4f338c26fdb57033fabc6dbb73636186214a368" translate="yes" xml:space="preserve">
          <source>Meanwhile in script.pl:</source>
          <target state="translated">한편 script.pl에서 :</target>
        </trans-unit>
        <trans-unit id="e31c01e90d9e8d19ca2313d7b406547f59ae64e3" translate="yes" xml:space="preserve">
          <source>Meanwhile, back in the main thread, we first create a queue (line 33) and queue up all the numbers from 3 to 1000 for checking, plus a termination notice. Then all we have to do to get the ball rolling is pass the queue and the first prime to the &lt;code&gt;check_num()&lt;/code&gt; subroutine (line 34).</source>
          <target state="translated">한편 메인 스레드로 돌아가서 먼저 대기열 (33 줄)을 만들고 확인을 위해 3에서 1000까지의 모든 숫자와 종료 통지를 대기열에 넣습니다. 그런 다음 볼 롤링을 얻기 위해 대기열과 첫 번째 프라임을 &lt;code&gt;check_num()&lt;/code&gt; 서브 루틴 (라인 34)으로 전달하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa7bb99b5f3a119fade7cc10eb9fede5a084e8b" translate="yes" xml:space="preserve">
          <source>Meanwhile, special identifiers don't follow the above rules; For the most part, all of the identifiers in this category have a special meaning given by Perl. Because they have special parsing rules, these generally can't be fully-qualified. They come in four forms:</source>
          <target state="translated">한편, 특수 식별자는 위의 규칙을 따르지 않습니다. 대부분이 카테고리의 모든 식별자는 Perl에 의해 주어진 특별한 의미를 갖습니다. 특별한 구문 분석 규칙이 있기 때문에 일반적으로 정규화 할 수는 없습니다. 그들은 네 가지 형태로옵니다 :</target>
        </trans-unit>
        <trans-unit id="01b22c5ba29e5ca443c76b69d7a2fdd28452d640" translate="yes" xml:space="preserve">
          <source>Meanwhile, special identifiers don't follow the above rules; For the most part, all of the identifiers in this category have a special meaning given by Perl. Because they have special parsing rules, these generally can't be fully-qualified. They come in six forms (but don't use forms 5 and 6):</source>
          <target state="translated">한편, 특수 식별자는 위의 규칙을 따르지 않습니다. 대부분의 경우이 범주의 모든 식별자는 Perl에서 제공하는 특별한 의미를 갖습니다. 특수 구문 분석 규칙이 있기 때문에 일반적으로 정규화 될 수 없습니다. 다음과 같은 6 가지 형태로 제공됩니다 (단, 양식 5와 6은 사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="83a5148d83732e363f572eb9f62ae4a34ffe78f8" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to help modules writers split their modules into autoloadable files. See the standard AutoLoader module described in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; and in &lt;a href=&quot;autosplit&quot;&gt;AutoSplit&lt;/a&gt;, the standard SelfLoader modules in &lt;a href=&quot;selfloader&quot;&gt;SelfLoader&lt;/a&gt;, and the document on adding C functions to Perl code in &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">모듈 작성자가 모듈을 자동로드 가능한 파일로 분할하는 데 도움이되는 메커니즘을 사용할 수 있습니다. 에 기재된 표준 자동로드 모듈 참조 &lt;a href=&quot;autoloader&quot;&gt;자동로드&lt;/a&gt; 와의 &lt;a href=&quot;autosplit&quot;&gt;자동 구분&lt;/a&gt; 에서 표준 SelfLoader 모듈 &lt;a href=&quot;selfloader&quot;&gt;SelfLoader&lt;/a&gt; 및 펄에 코드 C의 기능을 추가하는 문서 &lt;a href=&quot;perlxs&quot;&gt;perlxs를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b192f4447d1edc034616ab7c4aca49390dec0c" translate="yes" xml:space="preserve">
          <source>Memoization is not a cure-all:</source>
          <target state="translated">메모 화는 완전한 치료법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e35c7de9275e303103a9cca4277120ada2fcee2d" translate="yes" xml:space="preserve">
          <source>Memoization is not magical.</source>
          <target state="translated">메모 화는 마법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6f890b039269df17d39e9aef284c419ab8ca6d7a" translate="yes" xml:space="preserve">
          <source>Memoize</source>
          <target state="translated">Memoize</target>
        </trans-unit>
        <trans-unit id="5f81d99ecb62730206abe574a7c1d1cbed900a6f" translate="yes" xml:space="preserve">
          <source>Memoize - Make functions faster by trading space for time</source>
          <target state="translated">메모-시간을 절약 할 수있는 공간을 확보하여 기능을 더 빠르게</target>
        </trans-unit>
        <trans-unit id="843238e6a586f32a34512ff5be6c4efe5893f4d3" translate="yes" xml:space="preserve">
          <source>Memoize would then call &lt;code&gt;function&lt;/code&gt; whenever a cached value was entirely absent or was older than ten seconds.</source>
          <target state="translated">그런 다음 캐시 된 값이 완전히 없거나 10 초보다 오래된 경우 Memoize는 &lt;code&gt;function&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="029c7227d55a1555d4ad9945591262ad934bfa62" translate="yes" xml:space="preserve">
          <source>Memoize::AnyDBM_File</source>
          <target state="translated">Memoize::AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="f7222db52a03e50045b47cd151cf03999d99b842" translate="yes" xml:space="preserve">
          <source>Memoize::AnyDBM_File - glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">Memoize :: AnyDBM_File-저장 가능한 AnyDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="ab0d35e554a3be52fed5431a1db1dc0af18b1554" translate="yes" xml:space="preserve">
          <source>Memoize::Expire</source>
          <target state="translated">Memoize::Expire</target>
        </trans-unit>
        <trans-unit id="68da8c7a0efad73320d46b4b430e0877571aa887" translate="yes" xml:space="preserve">
          <source>Memoize::Expire - Plug-in module for automatic expiration of memoized values</source>
          <target state="translated">Memoize :: Expire-메모 된 값의 자동 만료를위한 플러그인 모듈</target>
        </trans-unit>
        <trans-unit id="0361cce2dcbb0a8d3953fc3f935563867ef2d797" translate="yes" xml:space="preserve">
          <source>Memoize::Expire is a layer of software that you can insert in between Memoize itself and whatever underlying package implements the cache. The layer presents a hash variable whose values expire whenever they get too old, have been used too often, or both. You tell &lt;code&gt;Memoize&lt;/code&gt; to use this forgetful hash as its cache instead of the default, which is an ordinary hash.</source>
          <target state="translated">Memoize :: Expire는 Memoize 자체와 기본 패키지가 캐시를 구현하는 모든 항목 사이에 삽입 할 수있는 소프트웨어 계층입니다. 계층은 값이 너무 오래되거나 너무 자주 사용되거나 둘 다가 될 때마다 값이 만료되는 해시 변수를 나타냅니다. 당신은 말할 &lt;code&gt;Memoize&lt;/code&gt; 를 일반 해시 대신 기본의 캐시로이 건망증이 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5ce5e44b5b097a389f35898a0295eae63ccf4c6e" translate="yes" xml:space="preserve">
          <source>Memoize::Expire is a plug-in module for Memoize. It allows the cached values for memoized functions to expire automatically. This manual assumes you are already familiar with the Memoize module. If not, you should study that manual carefully first, paying particular attention to the HASH feature.</source>
          <target state="translated">Memoize :: Expire는 Memoize 용 플러그인 모듈입니다. 메모 함수의 캐시 된 값이 자동으로 만료되도록합니다. 이 매뉴얼은 사용자가 이미 Memoize 모듈에 익숙하다고 가정합니다. 그렇지 않은 경우 해시 기능에 특히주의하면서 해당 매뉴얼을주의 깊게 연구해야합니다.</target>
        </trans-unit>
        <trans-unit id="058ef175eeea79174423065d5def30710bbd9b3d" translate="yes" xml:space="preserve">
          <source>Memoize::Expire uses a real hash internally to store the cached data. You can use the &lt;code&gt;HASH&lt;/code&gt; option to Memoize::Expire to supply a tied hash in place of the ordinary hash that Memoize::Expire will normally use. You can use this feature to add Memoize::Expire as a layer in between a persistent disk hash and Memoize. If you do this, you get a persistent disk cache whose entries expire automatically. For example:</source>
          <target state="translated">Memoize :: Expire는 실제 해시를 사용하여 캐시 된 데이터를 저장합니다. &lt;code&gt;HASH&lt;/code&gt; 옵션을 Memoize :: Expire에 사용하여 Memoize :: Expire가 일반적으로 사용하는 일반 해시 대신 묶인 해시를 제공 할 수 있습니다. 이 기능을 사용하여 영구 디스크 해시와 Memoize 사이에 Memoize :: Expire를 계층으로 추가 할 수 있습니다. 이렇게하면 항목이 자동으로 만료되는 영구 디스크 캐시가 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d269b32ccc7d9c3a39d79c1bc38b7d11bdeedce9" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireFile</source>
          <target state="translated">Memoize::ExpireFile</target>
        </trans-unit>
        <trans-unit id="832a8b2c800fc41add4efb073f8dd0755c8d611b" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireFile - test for Memoize expiration semantics</source>
          <target state="translated">Memoize :: ExpireFile-만기 시맨틱을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="cfe63b7749d0c4b0ed459ed8a03537e27ee0964b" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireTest</source>
          <target state="translated">Memoize::ExpireTest</target>
        </trans-unit>
        <trans-unit id="39f28a417ca2b739bec2a2c936fff15da4323299" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireTest - test for Memoize expiration semantics</source>
          <target state="translated">Memoize :: ExpireTest-만기 시맨틱을위한 테스트</target>
        </trans-unit>
        <trans-unit id="76efc803a2cb3f46d2d6c0879436aa10ce1458f5" translate="yes" xml:space="preserve">
          <source>Memoize::NDBM_File</source>
          <target state="translated">Memoize::NDBM_File</target>
        </trans-unit>
        <trans-unit id="746b4220ae70f33c450a28158673789c9a546fde" translate="yes" xml:space="preserve">
          <source>Memoize::NDBM_File - glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">Memoize :: NDBM_File-저장 가능 사용을 위해 NDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="fd4bdbba9a5e54216d1795015c434a21a9711f86" translate="yes" xml:space="preserve">
          <source>Memoize::SDBM_File</source>
          <target state="translated">Memoize::SDBM_File</target>
        </trans-unit>
        <trans-unit id="da914c13c14b27bc717bfbef4040f10310d95a2d" translate="yes" xml:space="preserve">
          <source>Memoize::SDBM_File - glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">Memoize :: SDBM_File-SDBM_File에 EXISTS를 제공하여 저장 가능</target>
        </trans-unit>
        <trans-unit id="21eebbc5fdb9d06943ca49fe99d3577c31994277" translate="yes" xml:space="preserve">
          <source>Memoize::Storable</source>
          <target state="translated">Memoize::Storable</target>
        </trans-unit>
        <trans-unit id="38149e962712243ad8d3efeb22a8323aef23996c" translate="yes" xml:space="preserve">
          <source>Memoize::Storable - store Memoized data in Storable database</source>
          <target state="translated">Memoize :: Storable-저장 가능한 데이터베이스에 메모 된 데이터 저장</target>
        </trans-unit>
        <trans-unit id="89c8a2851d1755cf87365b4a7c55e5551cf878c6" translate="yes" xml:space="preserve">
          <source>Memory</source>
          <target state="translated">Memory</target>
        </trans-unit>
        <trans-unit id="38b88ba291aedc801f0cf1ace141ae388b9947cc" translate="yes" xml:space="preserve">
          <source>Memory Allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="08cfd5338de5adae5d3a77de3eba507e6e489994" translate="yes" xml:space="preserve">
          <source>Memory Management and String Handling</source>
          <target state="translated">메모리 관리 및 문자열 처리</target>
        </trans-unit>
        <trans-unit id="c9a7ab7f07e403c0ae91c30f84e4c67c80a6e037" translate="yes" xml:space="preserve">
          <source>Memory allocated by external libraries is not counted.</source>
          <target state="translated">외부 라이브러리에 의해 할당 된 메모리는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="ab42bb6faf1372452bd96901de22f5faa6ef497c" translate="yes" xml:space="preserve">
          <source>Memory consumption</source>
          <target state="translated">메모리 소비</target>
        </trans-unit>
        <trans-unit id="14ff314163f3b5b04d3fe92dafa744f973c3e836" translate="yes" xml:space="preserve">
          <source>Memory footprint debugging</source>
          <target state="translated">메모리 풋 프린트 디버깅</target>
        </trans-unit>
        <trans-unit id="f7c5b8ee1bf3d6c206de6c158ee1895b1a26d8cc" translate="yes" xml:space="preserve">
          <source>Memory logging is somewhat similar to &lt;code&gt;-Dm&lt;/code&gt; but is independent of &lt;code&gt;-DDEBUGGING&lt;/code&gt; , and at a higher level; all uses of Newx(), Renew(), and Safefree() are logged with the caller's source code file and line number (and C function name, if supported by the C compiler). In contrast, &lt;code&gt;-Dm&lt;/code&gt; is directly at the point of &lt;code&gt;malloc()&lt;/code&gt; . SV logging is similar.</source>
          <target state="translated">메모리 로깅은 &lt;code&gt;-Dm&lt;/code&gt; 과 다소 유사 하지만 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 과 독립적이며 상위 레벨입니다. Newx (), Renew () 및 Safefree ()의 모든 사용은 호출자의 소스 코드 파일 및 행 번호 (및 C 컴파일러에서 지원하는 경우 C 함수 이름)와 함께 기록됩니다. 대조적으로, &lt;code&gt;-Dm&lt;/code&gt; 은 &lt;code&gt;malloc()&lt;/code&gt; 지점에 직접 있습니다 . SV 로깅은 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="7916d3e59a9fde6fdcb6cfdf74b28bd45e1783e8" translate="yes" xml:space="preserve">
          <source>Memory logging is somewhat similar to &lt;code&gt;-Dm&lt;/code&gt; but is independent of &lt;code&gt;-DDEBUGGING&lt;/code&gt;, and at a higher level; all uses of Newx(), Renew(), and Safefree() are logged with the caller's source code file and line number (and C function name, if supported by the C compiler). In contrast, &lt;code&gt;-Dm&lt;/code&gt; is directly at the point of &lt;code&gt;malloc()&lt;/code&gt;. SV logging is similar.</source>
          <target state="translated">메모리 로깅은 &lt;code&gt;-Dm&lt;/code&gt; 과 다소 유사 하지만 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 과 독립적이며 더 높은 수준입니다. Newx (), Renew () 및 Safefree ()의 모든 사용은 호출자의 소스 코드 파일과 줄 번호 (C 컴파일러에서 지원하는 경우 C 함수 이름)와 함께 기록됩니다. 반대로 &lt;code&gt;-Dm&lt;/code&gt; 은 &lt;code&gt;malloc()&lt;/code&gt; 지점에 직접 있습니다 . SV 로깅은 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="4c2c814c19b69f35d9db7c2c6ebf3d08f352fd38" translate="yes" xml:space="preserve">
          <source>Memory mapped IO</source>
          <target state="translated">메모리 매핑 된 IO</target>
        </trans-unit>
        <trans-unit id="6c6a6deece93cee8a3277158bc8df3a089d2c6dd" translate="yes" xml:space="preserve">
          <source>Memory obtained by this should &lt;b&gt;ONLY&lt;/b&gt; be freed with &lt;a href=&quot;#Safefree&quot;&gt;&quot;Safefree&quot;&lt;/a&gt;.</source>
          <target state="translated">이것으로 얻은 메모리 는 &lt;a href=&quot;#Safefree&quot;&gt;&quot;Safefree&quot; &lt;/a&gt;&lt;b&gt;로만&lt;/b&gt; 해제 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="26466bc4a0a5892915da9639400d4d78c9148962" translate="yes" xml:space="preserve">
          <source>Memory obtained by this should &lt;b&gt;ONLY&lt;/b&gt; be freed with &lt;a href=&quot;#Safefree&quot;&gt;Safefree&lt;/a&gt;.</source>
          <target state="translated">이것으로 얻은 메모리 는 &lt;a href=&quot;#Safefree&quot;&gt;Safefree &lt;/a&gt;&lt;b&gt;로만&lt;/b&gt; 해제 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c13fdc13d6ff4f45a77804ad2cceb15673c95db3" translate="yes" xml:space="preserve">
          <source>Mercifully, most localization tasks are a matter of finding ways to translate whole phrases, generally sentences, where the context is relatively set, and where the only variation in content is</source>
          <target state="translated">자비 롭게도 대부분의 현지화 작업은 전체 구문, 일반적으로 문장을 번역하는 방법을 찾는 문제이며, 컨텍스트가 상대적으로 설정되어 있고 콘텐츠의 유일한 변형은</target>
        </trans-unit>
        <trans-unit id="2a5792cd53fd5c07c6e156f110cc9bdc59c69569" translate="yes" xml:space="preserve">
          <source>Mercifully, this design decision becomes crucial only in the hairiest of inflected languages, of which Russian is by no means the</source>
          <target state="translated">자비 롭게도,이 디자인 결정은 가장 많은 영향을받는 언어에서만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a19110119cfc0a6eeba94dd28976c27677eeeaf2" translate="yes" xml:space="preserve">
          <source>Merge all &lt;code&gt;@fragments&lt;/code&gt; together. It will accept both CPAN::Meta objects and (possibly incomplete) hashrefs of metadata.</source>
          <target state="translated">모든 &lt;code&gt;@fragments&lt;/code&gt; 함께 병합하십시오 . CPAN :: Meta 객체와 메타 데이터의 (불완전한) 해시 참조를 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8b83c2b2bc6eb3815752c6b70aceb628db5830bb" translate="yes" xml:space="preserve">
          <source>Merged disk caches</source>
          <target state="translated">병합 된 디스크 캐시</target>
        </trans-unit>
        <trans-unit id="3bf6a951ac9a11e06dc7c59a3e9100f420a4948a" translate="yes" xml:space="preserve">
          <source>Merges a given typemap into the object. Note that a failed merge operation leaves the object in an inconsistent state so clone it if necessary.</source>
          <target state="translated">주어진 typemap을 객체에 병합합니다. 병합 작업이 실패하면 개체가 일관되지 않은 상태가되므로 필요한 경우 복제합니다.</target>
        </trans-unit>
        <trans-unit id="139306e2016e825bc98a4c26d30108bdfa5d60f7" translate="yes" xml:space="preserve">
          <source>Merging CPAN Meta fragments</source>
          <target state="translated">CPAN 메타 단편 병합</target>
        </trans-unit>
        <trans-unit id="2294ad7eb76da674941c37151d49f37527c0d994" translate="yes" xml:space="preserve">
          <source>Merging and Resolving Prerequisites</source>
          <target state="translated">필수 구성 요소 병합 및 해결</target>
        </trans-unit>
        <trans-unit id="e83dc47ddb09693487317e8066e16ecf7ac94e51" translate="yes" xml:space="preserve">
          <source>Message flag constants for send() and recv().</source>
          <target state="translated">send () 및 recv ()에 대한 메시지 플래그 상수.</target>
        </trans-unit>
        <trans-unit id="bc36800e17eaf7f803d98c577d91569b6c7f036b" translate="yes" xml:space="preserve">
          <source>Messing with Perl's Internals</source>
          <target state="translated">펄의 내부를 어지럽히 다</target>
        </trans-unit>
        <trans-unit id="b9828e06647e7ffc584e789aea4d7e68962a3966" translate="yes" xml:space="preserve">
          <source>Meta keys must be defined, and must be true when used as a boolean. Keys may not be references. You are free to stringify a reference &lt;code&gt;&quot;$ref&quot;&lt;/code&gt; for use as a key, but this package will not stringify it for you.</source>
          <target state="translated">메타 키를 정의해야하며 부울로 사용할 때 true 여야합니다. 키는 참조가 아닐 수 있습니다. 키로 사용하기 위해 참조 &lt;code&gt;&quot;$ref&quot;&lt;/code&gt; 를 문자열화할 수 있지만이 패키지는이를 문자열 화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="884d7f1593f68104d33ecab4f4bbe9381f348cdd" translate="yes" xml:space="preserve">
          <source>MetaCPAN</source>
          <target state="translated">MetaCPAN</target>
        </trans-unit>
        <trans-unit id="d754d67910f4c2642d4f88945d3605a6a4025a42" translate="yes" xml:space="preserve">
          <source>Metacharacters</source>
          <target state="translated">Metacharacters</target>
        </trans-unit>
        <trans-unit id="44522bc3b457b440444e21774a3b6c8607931812" translate="yes" xml:space="preserve">
          <source>Metaphoric Quotations</source>
          <target state="translated">은유 적 인용</target>
        </trans-unit>
        <trans-unit id="798b3e1c6f8b0a74eece2abb46cfe2fd57a06fe6" translate="yes" xml:space="preserve">
          <source>Method %s not permitted</source>
          <target state="translated">% s 방법은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c86ca70f3e85fdec1d74a21fb3963c31fdcdd7f" translate="yes" xml:space="preserve">
          <source>Method Call Variations</source>
          <target state="translated">메서드 호출 변형</target>
        </trans-unit>
        <trans-unit id="d8949e17ae84d7a06765768cb82b20ae6019661d" translate="yes" xml:space="preserve">
          <source>Method Calls on Filehandles</source>
          <target state="translated">파일 핸들에 대한 메소드 호출</target>
        </trans-unit>
        <trans-unit id="6fd706a5558ebea104b27041341cb1ea5fac0c06" translate="yes" xml:space="preserve">
          <source>Method Invocation</source>
          <target state="translated">메소드 호출</target>
        </trans-unit>
        <trans-unit id="4f453985833ca25c15ccb8b4ce0b4ada21b9adb4" translate="yes" xml:space="preserve">
          <source>Method Names as Strings</source>
          <target state="translated">문자열로서의 메소드 명</target>
        </trans-unit>
        <trans-unit id="169d21aab45387c970c5fa19ac363def6ba831e8" translate="yes" xml:space="preserve">
          <source>Method Names with a Fully Qualified Name</source>
          <target state="translated">정규화 된 이름을 가진 메서드 이름</target>
        </trans-unit>
        <trans-unit id="149bc56a4796369142e80bb8e93236ae91c74251" translate="yes" xml:space="preserve">
          <source>Method Resolution Caching</source>
          <target state="translated">분석법 캐싱</target>
        </trans-unit>
        <trans-unit id="0c84198ff44a95ef84e9c8366e0d425cc63a174e" translate="yes" xml:space="preserve">
          <source>Method Resolution Order</source>
          <target state="translated">분석법 해결 순서</target>
        </trans-unit>
        <trans-unit id="aa23ba323c11de2437b737ae399da090864345e1" translate="yes" xml:space="preserve">
          <source>Method calls</source>
          <target state="translated">메소드 호출</target>
        </trans-unit>
        <trans-unit id="bcdf1b1bb254fccb870b04cffc381c4e506b716b" translate="yes" xml:space="preserve">
          <source>Method calls are not influenced by prototypes either, because the function to be called is indeterminate at compile time, since the exact code called depends on inheritance.</source>
          <target state="translated">호출되는 정확한 코드는 상속에 의존하기 때문에 호출 할 함수는 컴파일 타임에 결정되지 않기 때문에 메소드 호출도 프로토 타입의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c72d128e104c59ad0c3c2a4128e634028dba480" translate="yes" xml:space="preserve">
          <source>Method for operation %s not found in package %s during blessing</source>
          <target state="translated">축복하는 동안 패키지 % s에서 작업 % s에 대한 방법을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c1f923c258569220ac20750fe41c9eb6cce3bef" translate="yes" xml:space="preserve">
          <source>Method names in the &lt;code&gt;use overload&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;use overload&lt;/code&gt; 지시문 의 메서드 이름</target>
        </trans-unit>
        <trans-unit id="8bf68fe4a9ba9d42e80a08fe93064afd994243cb" translate="yes" xml:space="preserve">
          <source>Method resolution order only matters in the case of multiple inheritance. In the case of single inheritance, Perl simply looks up the inheritance chain to find a method:</source>
          <target state="translated">메소드 해석 순서는 다중 상속의 경우에만 중요합니다. 단일 상속의 경우 Perl은 단순히 상속 체인을 찾아 메소드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d67544f861de65aff5df7b6f9ed170e715ea2ab1" translate="yes" xml:space="preserve">
          <source>Method such as &lt;code&gt;ok&lt;/code&gt;, and &lt;code&gt;note&lt;/code&gt; are shortcuts for generating common 1-task events based on the old API, however they are forward compatible, and easy to use. If these meet your needs then go ahead and use them, but please check back often for alternatives that may be added.</source>
          <target state="translated">&lt;code&gt;ok&lt;/code&gt; 및 &lt;code&gt;note&lt;/code&gt; 와 같은 메서드 는 이전 API를 기반으로 일반적인 1- 태스크 이벤트를 생성하기위한 바로 가기이지만 포워드 호환 가능하고 사용하기 쉽습니다. 이것이 귀하의 요구를 충족한다면 계속해서 사용하되 추가 될 수있는 대안이 있는지 자주 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="34cec11dfde693ed2754d2e489ae4f0bbc9cc853" translate="yes" xml:space="preserve">
          <source>Method that protects Makefile single-value constants (mainly filenames), so that make will still treat them as single values even if they inconveniently have spaces in. If the make program being used cannot achieve such protection and the given text would need it, throws an exception.</source>
          <target state="translated">Makefile 단일 값 상수 (주로 파일 이름)를 보호하는 방법으로, make는 불편한 공간이 있어도이를 단일 값으로 취급합니다. 사용중인 make 프로그램이 그러한 보호를 달성 할 수없고 주어진 텍스트에 필요한 경우, 예외.</target>
        </trans-unit>
        <trans-unit id="b801c10b1ac5aa2b998ab1658d5c860e220086a7" translate="yes" xml:space="preserve">
          <source>Method to customize MakeMaker for Win9X</source>
          <target state="translated">Win9X 용 MakeMaker를 사용자 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="c9952f904ebdacb612e4e6f4d7de0226ec975738" translate="yes" xml:space="preserve">
          <source>Methods I can't really figure out where they should go yet.</source>
          <target state="translated">나는 그들이 아직 어디로 가야할지 정말로 알 수 없다.</target>
        </trans-unit>
        <trans-unit id="40af0f1172251b1f0d2a538bd0e00ae001b2fcaf" translate="yes" xml:space="preserve">
          <source>Methods always loaded</source>
          <target state="translated">항상로드 된 메소드</target>
        </trans-unit>
        <trans-unit id="a68695b030e2ecbb7c261ec2a9c505d5cb18c649" translate="yes" xml:space="preserve">
          <source>Methods are overridden here: not dynamic_lib itself, but the utility ones that do the OS-specific work.</source>
          <target state="translated">여기서 메서드는 dynamic_lib 자체가 아니라 OS 별 작업을 수행하는 유틸리티로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc9c9bf62381c038cf262a1503103fafba0ddfa" translate="yes" xml:space="preserve">
          <source>Methods disallowed by the blacklist cannot be permitted by the whitelist.</source>
          <target state="translated">블랙리스트에서 허용하지 않는 메소드는 화이트리스트에서 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3492e94289b56d2304db645e851cbd229618f6f3" translate="yes" xml:space="preserve">
          <source>Methods for Collation</source>
          <target state="translated">데이터 정렬 방법</target>
        </trans-unit>
        <trans-unit id="dffdf0d2cd8722a265661b1c3c208de439bb95a7" translate="yes" xml:space="preserve">
          <source>Methods for Cygwin file specs</source>
          <target state="translated">Cygwin 파일 스펙을위한 방법</target>
        </trans-unit>
        <trans-unit id="82ca12b02f71920ae1348327f9c5bc0dd81da215" translate="yes" xml:space="preserve">
          <source>Methods for Epoc file specs</source>
          <target state="translated">Epoc 파일 스펙을위한 방법</target>
        </trans-unit>
        <trans-unit id="68812b66a62e2047690bf9da1c3c46de5cc3d232" translate="yes" xml:space="preserve">
          <source>Methods for OS/2 file specs</source>
          <target state="translated">OS / 2 파일 스펙 방법</target>
        </trans-unit>
        <trans-unit id="4d421ef7bd512b00bbdb44912712ec892bca2014" translate="yes" xml:space="preserve">
          <source>Methods for Searching</source>
          <target state="translated">검색 방법</target>
        </trans-unit>
        <trans-unit id="27e99810c06b72d2d33936fc288406b84f55b203" translate="yes" xml:space="preserve">
          <source>Methods for VMS file specs</source>
          <target state="translated">VMS 파일 사양에 대한 방법</target>
        </trans-unit>
        <trans-unit id="b9b3a715e48f22629289b2063628d2443ae0ab52" translate="yes" xml:space="preserve">
          <source>Methods for Win32 file specs</source>
          <target state="translated">Win32 파일 사양 방법</target>
        </trans-unit>
        <trans-unit id="5d7bf3463f69bf3ade9275de1811133bd2e8b4a6" translate="yes" xml:space="preserve">
          <source>Methods for manipulating file specifications.</source>
          <target state="translated">파일 사양을 조작하는 방법.</target>
        </trans-unit>
        <trans-unit id="ebbba6a759fd4eaa9d94e1633b1a4e4abe7f7a45" translate="yes" xml:space="preserve">
          <source>Methods for manipulating file specifications. Other File::Spec modules, such as File::Spec::Mac, inherit from File::Spec::Unix and override specific methods.</source>
          <target state="translated">파일 사양을 조작하는 방법. File :: Spec :: Mac과 같은 다른 File :: Spec 모듈은 File :: Spec :: Unix에서 상속하고 특정 메소드를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7481ef085e93898eccd2d4291e104c0ca1eaac16" translate="yes" xml:space="preserve">
          <source>Methods for the adventurous</source>
          <target state="translated">모험을위한 방법</target>
        </trans-unit>
        <trans-unit id="8b4c41334b1f0849f43409490279c73ebfa5df79" translate="yes" xml:space="preserve">
          <source>Methods in Detail</source>
          <target state="translated">세부적인 방법</target>
        </trans-unit>
        <trans-unit id="e068233ba30d5c340de8033909e63f34a39f8d3e" translate="yes" xml:space="preserve">
          <source>Methods in the other Classes</source>
          <target state="translated">다른 클래스의 메소드</target>
        </trans-unit>
        <trans-unit id="6e829311e4b065fb2f2e0f38edceb6d95375c55c" translate="yes" xml:space="preserve">
          <source>Methods that you may find it handy to use, from routines of yours that you put in %Lexicon entries.</source>
          <target state="translated">% Lexicon 항목에 넣은 루틴에서 사용하기 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="52c4361c86c7fd471a806b4c8215e5369dfc731b" translate="yes" xml:space="preserve">
          <source>Methods to do with constructing language handles.</source>
          <target state="translated">언어 핸들 구성과 관련된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b6f9f2fbd170ec9c9489d0e901a7e3b7214949c3" translate="yes" xml:space="preserve">
          <source>Methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 방법</target>
        </trans-unit>
        <trans-unit id="ab3b6636bc321fcd9f46d8689a767ed7e52e65e7" translate="yes" xml:space="preserve">
          <source>Methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker에서 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="7f996e6a1460bfdcd35f19090247cb216f784336" translate="yes" xml:space="preserve">
          <source>Methods which help initialize the MakeMaker object and macros.</source>
          <target state="translated">MakeMaker 객체 및 매크로를 초기화하는 데 도움이되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="3e6fda3ab5c8fa6834ff71aef9c511f877f6c23d" translate="yes" xml:space="preserve">
          <source>Methods you should implement</source>
          <target state="translated">구현해야 할 방법</target>
        </trans-unit>
        <trans-unit id="41937b20fbe8c71d9c6c3346aff43c001aa25e33" translate="yes" xml:space="preserve">
          <source>Mexico</source>
          <target state="translated">Mexico</target>
        </trans-unit>
        <trans-unit id="bd97b56132ac0bfc7557be46520b5fd83aff153a" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; and the denizens of makemaker@perl.org with code from ExtUtils::MM_Unix and ExtUtils::MM_Win32.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; 및 ExtUtils :: MM_Unix 및 ExtUtils :: MM_Win32의 코드를 사용하는 makemaker@perl.org의 수호자.</target>
        </trans-unit>
        <trans-unit id="52068be64791a464b661dac455db8140aea835a5" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; and the perl-qa dancers!</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;과 perl-qa 댄서들!</target>
        </trans-unit>
        <trans-unit id="88af124e71f22819d4d398414f274e80611dc1ac" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; on top of code by Nick Ing-Simmons and Jeffrey Friedl.</source>
          <target state="translated">Nick Ing-Simmons와 Jeffrey Friedl의 코드 위에 Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="609a8e114c05509c720089b4066abb697390e6b3" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; with code from ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 코드가있는 Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976aacead2152d3736e5ca6c6514a1e5684482c5" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; with much inspiration from Joshua Pritikin's Test module and lots of help from Barrie Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and the perl-qa gang.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;은 Joshua Pritikin의 테스트 모듈에서 많은 영감을 얻었으며 Barrie Slaymaker, Tony Bowden, blackstar.co.uk, 반음계, Fergal Daly 및 perl-qa 갱의 많은 도움을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="f21627f7b936980d951472d8f3b9d11843e6ffcc" translate="yes" xml:space="preserve">
          <source>Michael G. Schwern &amp;lt;mschwern@cpan.org&amp;gt;</source>
          <target state="translated">Michael G. Schwern &amp;lt;mschwern@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b7e8898e084b205078364468d25648e9b0ec170d" translate="yes" xml:space="preserve">
          <source>Michael Peters &amp;lt;mpeters at plusthree dot com&amp;gt;</source>
          <target state="translated">마이클 피터스 &amp;lt;플러스 쓰리 닷컴의 피터스&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd33a21f26a7d4f2cb826da8d8de1e33bcd542ba" translate="yes" xml:space="preserve">
          <source>Michael Schwern</source>
          <target state="translated">마이클 슈 베른</target>
        </trans-unit>
        <trans-unit id="5110b352c6bc056ec40bf3aebc4144eb1ae0e1d8" translate="yes" xml:space="preserve">
          <source>Michigan</source>
          <target state="translated">Michigan</target>
        </trans-unit>
        <trans-unit id="a8c99518c0df8eeda3f71152b09117cad644595c" translate="yes" xml:space="preserve">
          <source>MicroEMACS</source>
          <target state="translated">MicroEMACS</target>
        </trans-unit>
        <trans-unit id="359924accaba027302f36e848227bed8498f3885" translate="yes" xml:space="preserve">
          <source>Microsoft Platform SDK 64-bit Compiler</source>
          <target state="translated">Microsoft Platform SDK 64 비트 컴파일러</target>
        </trans-unit>
        <trans-unit id="19e1b99fc64b8852de8ab31bb7d1b51525551308" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C++</source>
          <target state="translated">마이크로 소프트 비주얼 C ++</target>
        </trans-unit>
        <trans-unit id="50a674447acfb53f080e5c7a940380d878d668e4" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C++ 2005 Express Edition</source>
          <target state="translated">Microsoft Visual C++ 2005 Express Edition</target>
        </trans-unit>
        <trans-unit id="b0803900f0583cc04c7c50cafeaa151ade70dcde" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C++ 2008-2019 Express/Community Edition</source>
          <target state="translated">Microsoft Visual C++ 2008-2019 Express/Community Edition</target>
        </trans-unit>
        <trans-unit id="d286550ff77bf9e5cdb6de350a40b896ae0aa2a8" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C++ Toolkit 2003</source>
          <target state="translated">Microsoft Visual C++ Toolkit 2003</target>
        </trans-unit>
        <trans-unit id="9476515c776c7ffa5f23daf6605041d17cb39e43" translate="yes" xml:space="preserve">
          <source>Microsoft extension to &lt;code&gt;Big5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Big5&lt;/code&gt; 에 대한 Microsoft 확장 .</target>
        </trans-unit>
        <trans-unit id="35bc8ec91b9bc1d48aec480ad01ccf1d9a2cc4f5" translate="yes" xml:space="preserve">
          <source>Microsoft extension to &lt;code&gt;EUC-CN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EUC-CN&lt;/code&gt; 에 대한 Microsoft 확장 .</target>
        </trans-unit>
        <trans-unit id="46a667be64853bfcf4ee2942093cec7a4847183a" translate="yes" xml:space="preserve">
          <source>Microsoft extension to &lt;code&gt;EUC-KR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EUC-KR&lt;/code&gt; 에 대한 Microsoft 확장 .</target>
        </trans-unit>
        <trans-unit id="e8d72bfd184d60d481c76b37ef21c0a642dd30ee" translate="yes" xml:space="preserve">
          <source>Microsoft products misuse the following names:</source>
          <target state="translated">Microsoft 제품은 다음 이름을 오용합니다.</target>
        </trans-unit>
        <trans-unit id="624c2711360f576ebf12a94ce042cede4b18471f" translate="yes" xml:space="preserve">
          <source>Microsoft's understanding of &lt;code&gt;Shift_JIS&lt;/code&gt;.</source>
          <target state="translated">Microsoft의 &lt;code&gt;Shift_JIS&lt;/code&gt; 이해 .</target>
        </trans-unit>
        <trans-unit id="46246987fa909ac6d3b3544d378e153a25558858" translate="yes" xml:space="preserve">
          <source>Microsoft-related naming mess</source>
          <target state="translated">Microsoft 관련 이름 지정 엉망</target>
        </trans-unit>
        <trans-unit id="6bb062409e93c0885568573482cc58a0d290f0ac" translate="yes" xml:space="preserve">
          <source>Midnight BSD</source>
          <target state="translated">자정 BSD</target>
        </trans-unit>
        <trans-unit id="78f6e604b99e20fee4d55d99822d486186bfc9da" translate="yes" xml:space="preserve">
          <source>Might be a runaway multi-line %s string starting on line %d</source>
          <target state="translated">% d 행에서 시작하는 폭주 다중 행 % s 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d917d6d7fad51d62d22d6b5c32840fa7d5b5e8e" translate="yes" xml:space="preserve">
          <source>Migration from &lt;code&gt;DynaLoader&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DynaLoader&lt;/code&gt; 에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="2ceffec12b40d21f869eb5b84598130f16f111e6" translate="yes" xml:space="preserve">
          <source>Migration from DynaLoader</source>
          <target state="translated">DynaLoader에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="12654a571e20ea45eaec45ab50ad734768e09847" translate="yes" xml:space="preserve">
          <source>Mike Cariaso provided valuable insight into the best way to solve this problem.</source>
          <target state="translated">Mike Cariaso는이 문제를 해결하는 가장 좋은 방법에 대한 귀중한 통찰력을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="234bc19cd7be72665729799de11490c9dd83bf27" translate="yes" xml:space="preserve">
          <source>Mike Doherty &amp;lt;doherty@cpan.org&amp;gt;</source>
          <target state="translated">마이크 도허티 &amp;lt;doherty@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="039e707fb015ae5335982d49bab4f238cf134377" translate="yes" xml:space="preserve">
          <source>Mind that argv[argc] must be NULL, same as those passed to a main function in C.</source>
          <target state="translated">argv [argc]는 C의 주 함수에 전달 된 것과 동일한 NULL이어야합니다.</target>
        </trans-unit>
        <trans-unit id="326f115f454ad964c4545e76abb586c5dfa4774e" translate="yes" xml:space="preserve">
          <source>Mind, that any element of the array contains a complete set of arguments for the ld command. So do not specify</source>
          <target state="translated">배열의 모든 요소에는 ld 명령에 대한 완전한 인수 세트가 포함되어 있습니다. 따라서 지정하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e509f9fc49b801b1d3cb79b36c8621b4642edef8" translate="yes" xml:space="preserve">
          <source>Minimal Set of Overloaded Operations</source>
          <target state="translated">과부하 작업의 최소 세트</target>
        </trans-unit>
        <trans-unit id="447f6cc3c1201528e85c548d7378d0bbb259ea5f" translate="yes" xml:space="preserve">
          <source>Minimal code</source>
          <target state="translated">최소 코드</target>
        </trans-unit>
        <trans-unit id="b9bbc06fd8287f4f714cc43f7b852676d2d7a603" translate="yes" xml:space="preserve">
          <source>Minimal patches that fix platform-specific test failures.</source>
          <target state="translated">플랫폼 별 테스트 실패를 해결하는 최소 패치.</target>
        </trans-unit>
        <trans-unit id="9add73fb8f3d0c44a5715a5d41747422c62c935b" translate="yes" xml:space="preserve">
          <source>Minimal set of supported functions</source>
          <target state="translated">지원되는 최소 기능 세트</target>
        </trans-unit>
        <trans-unit id="390af1977edf4e133548c8556281c14e4c310537" translate="yes" xml:space="preserve">
          <source>Minimal setup (looks for</source>
          <target state="translated">최소 설정 (</target>
        </trans-unit>
        <trans-unit id="906ea91bd1c9c6378b061a822858462af43e979d" translate="yes" xml:space="preserve">
          <source>Minimum length of string (measured in bytes from &lt;code&gt;stringarg&lt;/code&gt; ) that must match; if the engine reaches the end of the match but hasn't reached this position in the string, it should fail.</source>
          <target state="translated">일치해야하는 문자열의 최소 길이 ( &lt;code&gt;stringarg&lt;/code&gt; 에서 바이트 단위로 측정 ) 엔진이 일치하는 끝에 도달했지만 문자열에서이 위치에 도달하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="be12c32ff84593686015cc2e0cb0d89d77831ed3" translate="yes" xml:space="preserve">
          <source>Minimum length of string (measured in bytes from &lt;code&gt;stringarg&lt;/code&gt;) that must match; if the engine reaches the end of the match but hasn't reached this position in the string, it should fail.</source>
          <target state="translated">일치해야하는 문자열의 최소 길이 ( &lt;code&gt;stringarg&lt;/code&gt; 에서 바이트로 측정 됨 ). 엔진이 경기 끝에 도달했지만 문자열에서이 위치에 도달하지 않은 경우 실패해야합니다.</target>
        </trans-unit>
        <trans-unit id="5343fd4802dbdf5cd1789ee30e8d69ca6cabadc2" translate="yes" xml:space="preserve">
          <source>Minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt; , returns the other [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 일 때를 제외하고 최소 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 는 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0302c55180fe62d506dfe28ff33373c2560204c" translate="yes" xml:space="preserve">
          <source>Minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt;, returns the other [C99].</source>
          <target state="translated">둘 중 하나가 &lt;code&gt;NaN&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 최소값은 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32d3a57a3bd71eb3c56ac46e121c1eb2dc0a4ca8" translate="yes" xml:space="preserve">
          <source>Minimum requirements are inclusive. &lt;code&gt;$version&lt;/code&gt; is required, along with any greater version number.</source>
          <target state="translated">최소 요구 사항이 포함됩니다. 더 큰 버전 번호와 함께 &lt;code&gt;$version&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2a013cdfce3e9c596d4b9cb32825ab89339bddcd" translate="yes" xml:space="preserve">
          <source>Miniperl.Exe</source>
          <target state="translated">Miniperl.Exe</target>
        </trans-unit>
        <trans-unit id="5783432e3d972b6894919df1e5c308c82f9c7634" translate="yes" xml:space="preserve">
          <source>MirOS BSD</source>
          <target state="translated">MirOS BSD</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="319c19b9e813f94557eb26c26b7b4388bfdc0145" translate="yes" xml:space="preserve">
          <source>Miscellaneous Functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="e9886ca0fdacee4b74dfbeeffc975d27efbdeb6b" translate="yes" xml:space="preserve">
          <source>Miscellaneous Modules</source>
          <target state="translated">기타 모듈</target>
        </trans-unit>
        <trans-unit id="99463edffe28d703da1b6e42d1ae7b9d31c1b070" translate="yes" xml:space="preserve">
          <source>Miscellaneous Things</source>
          <target state="translated">기타 것들</target>
        </trans-unit>
        <trans-unit id="7b60f144da88cbf71ee28b893333af2adba91042" translate="yes" xml:space="preserve">
          <source>Miscellaneous Usage</source>
          <target state="translated">기타 사용법</target>
        </trans-unit>
        <trans-unit id="7549a52ededf0abbc51eaa6563f958964d60ea6e" translate="yes" xml:space="preserve">
          <source>Miscellaneous Utility Functions</source>
          <target state="translated">기타 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="b1c2f1326539aaa7427ad9b1469de4ff74f87ee5" translate="yes" xml:space="preserve">
          <source>Miscellaneous commentary.</source>
          <target state="translated">기타 논평.</target>
        </trans-unit>
        <trans-unit id="342a5f135351fd510e40f97d2fab9f29fe7f026d" translate="yes" xml:space="preserve">
          <source>Miscellaneous constants. Used for the &lt;code&gt;$uCreate&lt;/code&gt; argument of &lt;code&gt;CreateFile&lt;/code&gt; or the &lt;code&gt;$uFromWhere&lt;/code&gt; argument of &lt;code&gt;SetFilePointer&lt;/code&gt;. Plus &lt;code&gt;INVALID_HANDLE_VALUE&lt;/code&gt;, which you usually won't need to check for since most routines translate it into a false value.</source>
          <target state="translated">기타 상수. 에 사용 &lt;code&gt;$uCreate&lt;/code&gt; 의 인수 &lt;code&gt;CreateFile&lt;/code&gt; 또는 &lt;code&gt;$uFromWhere&lt;/code&gt; 의 인수 &lt;code&gt;SetFilePointer&lt;/code&gt; 를 . 게다가 &lt;code&gt;INVALID_HANDLE_VALUE&lt;/code&gt; 는 대부분의 루틴이이를 거짓 값으로 변환하기 때문에 일반적으로 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a37adce83d6fa2179beba32ceeacd3778204fcfb" translate="yes" xml:space="preserve">
          <source>Miscellaneous encodings</source>
          <target state="translated">기타 인코딩</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="9da774369baa717644789be36b08da5ef92ca224" translate="yes" xml:space="preserve">
          <source>Misfeatures</source>
          <target state="translated">Misfeatures</target>
        </trans-unit>
        <trans-unit id="ce60b331195543a6746d022bb20ad15f338c66de" translate="yes" xml:space="preserve">
          <source>Misplaced _ in number</source>
          <target state="translated">번호에서 _ 위치가 잘못됨</target>
        </trans-unit>
        <trans-unit id="a95de1c6435f8743842f21d48536596257568105" translate="yes" xml:space="preserve">
          <source>Misplaced plan</source>
          <target state="translated">잘못 배치 된 계획</target>
        </trans-unit>
        <trans-unit id="9c5c9d737a51552824a8f054a3830ede7eb73132" translate="yes" xml:space="preserve">
          <source>Missing $ on loop variable</source>
          <target state="translated">루프 변수에 $ 누락</target>
        </trans-unit>
        <trans-unit id="07f4c05777767269c3fe2fd5ee568ca57fbd5be9" translate="yes" xml:space="preserve">
          <source>Missing ']' in prototype for %s : %s</source>
          <target state="translated">% s의 프로토 타입에 ']'누락 : % s</target>
        </trans-unit>
        <trans-unit id="492deed501b2e8f77f0d5bf65e92ebc107c3988d" translate="yes" xml:space="preserve">
          <source>Missing argument for %n in %s</source>
          <target state="translated">% s의 % n에 대한 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d29fb503cf20ccfb86deead9f1e147184da6314" translate="yes" xml:space="preserve">
          <source>Missing argument in %s</source>
          <target state="translated">% s에 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="905237197bd9811f9b09e25f0763d52acfbe8f9d" translate="yes" xml:space="preserve">
          <source>Missing argument to -%c</source>
          <target state="translated">-% c에 대한 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ff0f07a4c291aedab0828071c7e5be901eca1d" translate="yes" xml:space="preserve">
          <source>Missing braces on \N{}</source>
          <target state="translated">\ N {}에 중괄호 누락</target>
        </trans-unit>
        <trans-unit id="65ab85b2077b61fe9a0b2696a10440f202845e30" translate="yes" xml:space="preserve">
          <source>Missing braces on \N{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 \ N {}에 중괄호가 누락되었습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="f2b7f0d0959c77816c06bcafc45fa06ad6622507" translate="yes" xml:space="preserve">
          <source>Missing braces on \o{}</source>
          <target state="translated">\ o {}에 중괄호 누락</target>
        </trans-unit>
        <trans-unit id="77272a604bbc7df55b2cbf61f879522fe8ed6ffd" translate="yes" xml:space="preserve">
          <source>Missing comma after first argument to %s function</source>
          <target state="translated">% s 함수의 첫 번째 인수 뒤에 쉼표가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5527cff2b5c9e125b749b05c07f90a92a547a921" translate="yes" xml:space="preserve">
          <source>Missing command in piped open</source>
          <target state="translated">파이프 열기에 누락 된 명령</target>
        </trans-unit>
        <trans-unit id="8fb97fb839a7785ff8deb8f6a3434e5842793e89" translate="yes" xml:space="preserve">
          <source>Missing control char name in \c</source>
          <target state="translated">\ c에 제어 문자 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="38d01981943106f56a9819e6a7268d9a6454e8a9" translate="yes" xml:space="preserve">
          <source>Missing name in &quot;%s sub&quot;</source>
          <target state="translated">&quot;% s 하위&quot;에 이름이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d72d7995bf8862606c4717d1a2053eff2624ec07" translate="yes" xml:space="preserve">
          <source>Missing or undefined argument to %s</source>
          <target state="translated">% s에 대한 인수가 없거나 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="05c054b8f3d0a5a4b72b812cbfe4bb1cd415154f" translate="yes" xml:space="preserve">
          <source>Missing right brace on \%c{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식의 \ % c {}에 오른쪽 중괄호가 없습니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="9b28d6622907b838faba9a35172b03ffbf93af4a" translate="yes" xml:space="preserve">
          <source>Missing right brace on \N{}</source>
          <target state="translated">\ N {}에 오른쪽 중괄호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3e8c9cf38694cb1369209c024da00e671eb2a06" translate="yes" xml:space="preserve">
          <source>Missing right brace on \N{} or unescaped left brace after \N</source>
          <target state="translated">\ N {}에 오른쪽 중괄호 누락 또는 \ N 뒤에 이스케이프 처리되지 않은 왼쪽 중괄호</target>
        </trans-unit>
        <trans-unit id="256a6056983709743749fcd95a4f7e468cbb0a7f" translate="yes" xml:space="preserve">
          <source>Missing right curly or square bracket</source>
          <target state="translated">오른쪽 중괄호 또는 대괄호 누락</target>
        </trans-unit>
        <trans-unit id="e6560a728cc75a6b103e706dc673d7ef4bcf29de" translate="yes" xml:space="preserve">
          <source>Mixing #define and #ifdef</source>
          <target state="translated">#define과 #ifdef 혼합</target>
        </trans-unit>
        <trans-unit id="29c40186eed76e6033a40498c6fe7f4e2e466bc7" translate="yes" xml:space="preserve">
          <source>Mixing UTF-8 and non-UTF-8 strings is tricky. Use &lt;code&gt;bytes_to_utf8&lt;/code&gt; to get a new string which is UTF-8 encoded, and then combine them.</source>
          <target state="translated">UTF-8과 비 UTF-8 문자열을 혼합하는 것은 까다 롭습니다. &lt;code&gt;bytes_to_utf8&lt;/code&gt; 을 사용 하여 UTF-8로 인코딩 된 새 문자열을 가져온 다음 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="66bca4e0f37fde6f6d5033a86915673ed0b48f44" translate="yes" xml:space="preserve">
          <source>Mixing command line option with other arguments</source>
          <target state="translated">명령 줄 옵션을 다른 인수와 혼합</target>
        </trans-unit>
        <trans-unit id="c85d9a78c1b4d78ca553de634935cfea419df54e" translate="yes" xml:space="preserve">
          <source>Mixing declarations and code</source>
          <target state="translated">선언과 코드 혼합</target>
        </trans-unit>
        <trans-unit id="191dad4eb9e454325153296d486b75e87731816d" translate="yes" xml:space="preserve">
          <source>Mixing different object types</source>
          <target state="translated">다양한 개체 유형 혼합</target>
        </trans-unit>
        <trans-unit id="4f1e7f7efdba287b74e8142b1268ce27b211ade2" translate="yes" xml:space="preserve">
          <source>Mixing it up</source>
          <target state="translated">그것을 혼합</target>
        </trans-unit>
        <trans-unit id="9355f7a3087594f002f5e9c67bfdb7357b2d09c8" translate="yes" xml:space="preserve">
          <source>Mixing signed char pointers with unsigned char pointers</source>
          <target state="translated">부호있는 문자 포인터와 부호없는 문자 포인터 혼합</target>
        </trans-unit>
        <trans-unit id="c8ded3624005b356d9a738f8bbff4c65caab09bc" translate="yes" xml:space="preserve">
          <source>MkTemp family:</source>
          <target state="translated">MKTemp 제품군 :</target>
        </trans-unit>
        <trans-unit id="89e86a83d22490472fadfccc84db9971217f00e2" translate="yes" xml:space="preserve">
          <source>Mkbootstrap typically gets called from an extension Makefile.</source>
          <target state="translated">Mkbootstrap은 일반적으로 확장 Makefile에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf642b0445fa1b197a3f404144c575c97857e845" translate="yes" xml:space="preserve">
          <source>Mnemonic for &lt;code&gt;(?^...)&lt;/code&gt; : A fresh beginning since the usual use of a caret is to match at the beginning.</source>
          <target state="translated">니모닉 &lt;code&gt;(?^...)&lt;/code&gt; : 캐럿을 일상적으로 사용하기 때문에 처음 시작하면 처음부터 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fb71ad054736a057594bb08cc0713a551c20ae5" translate="yes" xml:space="preserve">
          <source>Mnemonic for &lt;code&gt;(?^...)&lt;/code&gt;: A fresh beginning since the usual use of a caret is to match at the beginning.</source>
          <target state="translated">&lt;code&gt;(?^...)&lt;/code&gt; 대한 니모닉 : 일반적인 캐럿 사용 이후 새로운 시작은 처음에 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a58694480088720e80e9150ab4b17e65401d3e57" translate="yes" xml:space="preserve">
          <source>Mnemonic:</source>
          <target state="translated">Mnemonic:</target>
        </trans-unit>
        <trans-unit id="a4609f4e9d1567a8be9be3013a68cb5f9077d509" translate="yes" xml:space="preserve">
          <source>Mnemonic: / delimits line boundaries when quoting poetry.</source>
          <target state="translated">니모닉 : /시를 인용 할 때 줄 경계를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="a17c263d1e94a797a2f907b413a2e6937babe3bd" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;%&lt;/code&gt; is page number in &lt;b&gt;nroff&lt;/b&gt;.</source>
          <target state="translated">니모닉 : &lt;code&gt;%&lt;/code&gt; 는 &lt;b&gt;nroff의&lt;/b&gt; 페이지 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="ff8f7e9ef271156c4cf38cda15862d7d90c4cb37" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;'&lt;/code&gt; often follows a quoted string.</source>
          <target state="translated">니모닉 : &lt;code&gt;'&lt;/code&gt; 는 종종 인용 된 문자열을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="03462936fc4d222008baee163c91bca679bcf610" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;`&lt;/code&gt; often precedes a quoted string.</source>
          <target state="translated">니모닉 : &lt;code&gt;`&lt;/code&gt; 는 종종 따옴표 붙은 문자열 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="6d89fd4acfd6e65581a03c1bccc5077a0683b53d" translate="yes" xml:space="preserve">
          <source>Mnemonic: = has horizontal lines.</source>
          <target state="translated">니모닉 : = 수평선이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4fee04f913df1ce7e585c0d4cb5cf688bad64b1" translate="yes" xml:space="preserve">
          <source>Mnemonic: Complement of</source>
          <target state="translated">니모닉 : 보완</target>
        </trans-unit>
        <trans-unit id="00d81532eead6e059ec9226bf31a1d7bc4d3c648" translate="yes" xml:space="preserve">
          <source>Mnemonic: Extra error explanation.</source>
          <target state="translated">니모닉 : 추가 오류 설명.</target>
        </trans-unit>
        <trans-unit id="f3adb972eb89279dcbf38ffdb2b34cb01ac80557" translate="yes" xml:space="preserve">
          <source>Mnemonic: Is this version of perl in the right bracket?</source>
          <target state="translated">니모닉 :이 버전의 펄은 오른쪽 괄호 안에 있습니까?</target>
        </trans-unit>
        <trans-unit id="c83fc5eabe67c53a88a66531db063afe5a8798fe" translate="yes" xml:space="preserve">
          <source>Mnemonic: Perl's (original) space</source>
          <target state="translated">니모닉 : Perl (원래) 공간</target>
        </trans-unit>
        <trans-unit id="de5973eb3bd2f2951a919587c5a581d934fb917e" translate="yes" xml:space="preserve">
          <source>Mnemonic: Perl's (original) word.</source>
          <target state="translated">니모닉 : Perl (원래) 단어.</target>
        </trans-unit>
        <trans-unit id="e3688e90b8ece4a626d04ff3f6b6b3e5cd816fdf" translate="yes" xml:space="preserve">
          <source>Mnemonic: Space, as modified by Perl. (It doesn't include the vertical tab until v5.18, which both the Posix standard and Unicode consider white space.)</source>
          <target state="translated">니모닉 : Perl에 의해 수정 된 공간. (Posix 표준과 유니 코드 모두 공백을 고려하는 v5.18까지 수직 탭은 포함되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e034d1e8207da0718183c9081637de75a93ba2ae" translate="yes" xml:space="preserve">
          <source>Mnemonic: What just went bang?</source>
          <target state="translated">니모닉 : 방금 무슨 일이 있었나요?</target>
        </trans-unit>
        <trans-unit id="1f52600a3a5911b067b3374a8879381b17ea1317" translate="yes" xml:space="preserve">
          <source>Mnemonic: Where was the error &quot;at&quot;?</source>
          <target state="translated">니모닉 : &quot;at&quot;오류는 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="c2d59c20bf5fe5e92f4fce8a028d68d9472173f0" translate="yes" xml:space="preserve">
          <source>Mnemonic: Where was the syntax error &quot;at&quot;?</source>
          <target state="translated">니모닉 : &quot;at&quot;구문 오류는 어디에 있었습니까?</target>
        </trans-unit>
        <trans-unit id="13036ce2395db627a394493e09b57d820655a6e3" translate="yes" xml:space="preserve">
          <source>Mnemonic: [ begins subscripts.</source>
          <target state="translated">니모닉 : [아래 첨자를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6478e17d9b14a75686fa2aeaa0fda7fc477e3a6c" translate="yes" xml:space="preserve">
          <source>Mnemonic: a &quot;colon&quot; in poetry is a part of a line.</source>
          <target state="translated">니모닉 :시의 &quot;콜론&quot;은 한 줄의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="06be15525bc8ff40fc0fd75c1aede3dd3e6eca7f" translate="yes" xml:space="preserve">
          <source>Mnemonic: be positive and forward looking.</source>
          <target state="translated">니모닉 : 긍정적이고 미래 지향적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45c1dcc3d237500077fd6705954bc10a0da68241" translate="yes" xml:space="preserve">
          <source>Mnemonic: brother to &lt;code&gt;$^&lt;/code&gt; .</source>
          <target state="translated">니모닉 : &lt;code&gt;$^&lt;/code&gt; 형제 .</target>
        </trans-unit>
        <trans-unit id="8016703b31a155c2a574fa23c4f3718d5f24c64b" translate="yes" xml:space="preserve">
          <source>Mnemonic: brother to &lt;code&gt;$^&lt;/code&gt;.</source>
          <target state="translated">니모닉 : brother to &lt;code&gt;$^&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bfbe3b8dd831a42303599b72a7a29a0dbbce16e" translate="yes" xml:space="preserve">
          <source>Mnemonic: comma (the syntactic subscript separator) is a semi-semicolon.</source>
          <target state="translated">니모닉 : 쉼표 (구문 아래 첨자 구분자)는 세미-세미콜론입니다.</target>
        </trans-unit>
        <trans-unit id="a5e54620ad7fc3dd7f83e5824baaa97ef210abf7" translate="yes" xml:space="preserve">
          <source>Mnemonic: e</source>
          <target state="translated">니모닉 : e</target>
        </trans-unit>
        <trans-unit id="fb1dad35694a1d1c6e8b249b4963e948af75d628" translate="yes" xml:space="preserve">
          <source>Mnemonic: he</source>
          <target state="translated">니모닉 : 그는</target>
        </trans-unit>
        <trans-unit id="4f25fdfd275a765786269fb643e1c55e1a9c1820" translate="yes" xml:space="preserve">
          <source>Mnemonic: it's the uid you came</source>
          <target state="translated">니모닉 : 그것은 당신이 온 uid입니다</target>
        </trans-unit>
        <trans-unit id="f53200593eb86ae8dd4c325941dd8eb32bcbba07" translate="yes" xml:space="preserve">
          <source>Mnemonic: it's the uid you went</source>
          <target state="translated">니모닉 : 네가 간 uid</target>
        </trans-unit>
        <trans-unit id="c2560fee0f5b656addb6e58657f827dd080975cc" translate="yes" xml:space="preserve">
          <source>Mnemonic: like &lt;code&gt;&amp;amp;&lt;/code&gt; in some editors.</source>
          <target state="translated">니모닉 : 일부 편집기에서 &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bf53d6e2ef8b1852f6e6460d639d8a6d511e87d" translate="yes" xml:space="preserve">
          <source>Mnemonic: like \digits.</source>
          <target state="translated">니모닉 : 같은 \ digits.</target>
        </trans-unit>
        <trans-unit id="29345f5f1506a434b700483b03581bba2252ef83" translate="yes" xml:space="preserve">
          <source>Mnemonic: lines_on_page - lines_printed.</source>
          <target state="translated">니모닉 : lines_on_page-lines_printed.</target>
        </trans-unit>
        <trans-unit id="a3b3edfce1b2a7630b3d4258477c440ecb3338e9" translate="yes" xml:space="preserve">
          <source>Mnemonic: many programs use &quot;.&quot; to mean the current line number.</source>
          <target state="translated">니모닉 : 많은 프로그램에서 &quot;.&quot; 현재 줄 번호를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="de8f32b4ce704e3d490515551c6116db336ffdaf" translate="yes" xml:space="preserve">
          <source>Mnemonic: none really. &lt;code&gt;\R&lt;/code&gt; was picked because PCRE already uses &lt;code&gt;\R&lt;/code&gt; , and more importantly because Unicode recommends such a regular expression metacharacter, and suggests &lt;code&gt;\R&lt;/code&gt; as its notation.</source>
          <target state="translated">니모닉 : 실제로는 없습니다. &lt;code&gt;\R&lt;/code&gt; RE는 PCRE가 이미 &lt;code&gt;\R&lt;/code&gt; 사용하기 때문에 선택되었으며 , 더 중요한 것은 유니 코드가 정규 표현식 메타 문자를 권장하고 &lt;code&gt;\R&lt;/code&gt; 을 표기법으로 제안하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="2857bfcf8f813920b6e4a8a1bb14270872f38cb1" translate="yes" xml:space="preserve">
          <source>Mnemonic: none really. &lt;code&gt;\R&lt;/code&gt; was picked because PCRE already uses &lt;code&gt;\R&lt;/code&gt;, and more importantly because Unicode recommends such a regular expression metacharacter, and suggests &lt;code&gt;\R&lt;/code&gt; as its notation.</source>
          <target state="translated">니모닉 : 정말 없습니다. &lt;code&gt;\R&lt;/code&gt; 은 PCRE가 이미 &lt;code&gt;\R&lt;/code&gt; 사용하기 때문에 선택되었으며 , 더 중요한 것은 유니 코드가 이러한 정규식 메타 문자를 권장하고 &lt;code&gt;\R&lt;/code&gt; 을 표기법으로 제안하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="17515742cc5afa87aeabc73678286fa741ba5388" translate="yes" xml:space="preserve">
          <source>Mnemonic: o</source>
          <target state="translated">니모닉 : o</target>
        </trans-unit>
        <trans-unit id="5c7eacbc6cb333f80ee9f35aec3e8dd35063c97b" translate="yes" xml:space="preserve">
          <source>Mnemonic: parentheses are used to</source>
          <target state="translated">니모닉 : 괄호는</target>
        </trans-unit>
        <trans-unit id="145851845d42b7c2837eb05551e2eb9b2cae8660" translate="yes" xml:space="preserve">
          <source>Mnemonic: points to top of page.</source>
          <target state="translated">니모닉 : 페이지 상단을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="18d03cec8eedf712bc3cc92498d0bd974ac29168" translate="yes" xml:space="preserve">
          <source>Mnemonic: related to the &lt;b&gt;-w&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-w&lt;/b&gt; 스위치 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff59e0f3c29d42ff6b4f1943a0cb62f85b10dbe" translate="yes" xml:space="preserve">
          <source>Mnemonic: same as &lt;b&gt;sh&lt;/b&gt; and &lt;b&gt;ksh&lt;/b&gt;.</source>
          <target state="translated">니모닉 : 동일 &lt;b&gt;쉬&lt;/b&gt; 와 &lt;b&gt;KSH&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3b46ac9389c1562addebeca3277c06599213ca1b" translate="yes" xml:space="preserve">
          <source>Mnemonic: same as shells.</source>
          <target state="translated">니모닉 : 껍질과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9c5494af227b04c5edebf85d05b3fe69b8e73df2" translate="yes" xml:space="preserve">
          <source>Mnemonic: similar to &lt;b&gt;sh&lt;/b&gt; and &lt;b&gt;ksh&lt;/b&gt;.</source>
          <target state="translated">니모닉 : &lt;b&gt;sh&lt;/b&gt; 및 &lt;b&gt;ksh&lt;/b&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="894f0484590bcbb3b693d6aab805d5dfd400684a" translate="yes" xml:space="preserve">
          <source>Mnemonic: the (possibly) Nested parenthesis that most recently closed.</source>
          <target state="translated">니모닉 : 가장 최근에 닫은 중첩 괄호.</target>
        </trans-unit>
        <trans-unit id="2bc5f6f15e84df55129e74766d50c6d3ec861d52" translate="yes" xml:space="preserve">
          <source>Mnemonic: underline is understood in certain operations.</source>
          <target state="translated">니모닉 : 밑줄은 특정 작업에서 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9ec9ee0bfa06bee48fc042c23120f429cc4720" translate="yes" xml:space="preserve">
          <source>Mnemonic: use ^V for a version object.</source>
          <target state="translated">니모닉 : 버전 객체에 ^ V를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06e3f9eef28e584212eb3b651afb663309c25b17" translate="yes" xml:space="preserve">
          <source>Mnemonic: value of &lt;b&gt;-D&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-D&lt;/b&gt; 스위치의 값 .</target>
        </trans-unit>
        <trans-unit id="8b8a29220f27a6ded73512e3ded3085fc6e23796" translate="yes" xml:space="preserve">
          <source>Mnemonic: value of &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-i&lt;/b&gt; 스위치의 값 .</target>
        </trans-unit>
        <trans-unit id="d86dda32bcccc36b30321a061a593c0839054c6b" translate="yes" xml:space="preserve">
          <source>Mnemonic: what is printed when there is a &quot;,&quot; in your print statement.</source>
          <target state="translated">니모닉 : 인쇄 명세서에 &quot;,&quot;가있을 때 인쇄되는 내용.</target>
        </trans-unit>
        <trans-unit id="a2e0668e848f30f9c617ffa35513e900bc8c74ef" translate="yes" xml:space="preserve">
          <source>Mnemonic: when you want your pipes to be piping hot.</source>
          <target state="translated">니모닉 : 파이프가 뜨거워 지길 원할 때.</target>
        </trans-unit>
        <trans-unit id="83f42ef2607c96d6744ccfc26dd35c90a66a4662" translate="yes" xml:space="preserve">
          <source>Mnemonic: works in double-quoted context.</source>
          <target state="translated">니모닉 : 큰 따옴표로 묶은 문맥에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c5df1d9e3c7f07b6813c1d51005b98006207f133" translate="yes" xml:space="preserve">
          <source>Mnemonic: you set &lt;code&gt;$\&lt;/code&gt; instead of adding &quot;\n&quot; at the end of the print. Also, it's just like &lt;code&gt;$/&lt;/code&gt; , but it's what you get &quot;back&quot; from Perl.</source>
          <target state="translated">니모닉 : 인쇄 끝에 &quot;\ n&quot;을 추가하는 대신 &lt;code&gt;$\&lt;/code&gt; 를 설정 합니다. 또한 &lt;code&gt;$/&lt;/code&gt; 와 비슷하지만 Perl에서 &quot;돌아 오는&quot;것입니다.</target>
        </trans-unit>
        <trans-unit id="d1e77a5dc7fffdb724bdfb2b1a696e56046f4e46" translate="yes" xml:space="preserve">
          <source>Mnemonic: you set &lt;code&gt;$\&lt;/code&gt; instead of adding &quot;\n&quot; at the end of the print. Also, it's just like &lt;code&gt;$/&lt;/code&gt;, but it's what you get &quot;back&quot; from Perl.</source>
          <target state="translated">니모닉 : 인쇄 끝에 &quot;\ n&quot;을 추가하는 대신 &lt;code&gt;$\&lt;/code&gt; 를 설정 합니다. 또한 &lt;code&gt;$/&lt;/code&gt; 와 비슷하지만 Perl에서 &quot;돌아온&quot;것입니다.</target>
        </trans-unit>
        <trans-unit id="774459fcd854849578678b44d17052997274c5ac" translate="yes" xml:space="preserve">
          <source>Mnemonics:</source>
          <target state="translated">Mnemonics:</target>
        </trans-unit>
        <trans-unit id="cafc128f90bdc8e24af8dd2187160ad19d568274" translate="yes" xml:space="preserve">
          <source>Model =&amp;gt; $hModelFile</source>
          <target state="translated">모델 =&amp;gt; $ hModelFile</target>
        </trans-unit>
        <trans-unit id="6ff39ea59358932273dd96de0a90c680140ef641" translate="yes" xml:space="preserve">
          <source>Modifed values of three of the arguments passed to the function. In particular, the &lt;code&gt;XSStack&lt;/code&gt; and &lt;code&gt;InitFileCode&lt;/code&gt; attributes are modified.</source>
          <target state="translated">함수에 전달 된 인수 3 개의 수정 된 값입니다. 특히 &lt;code&gt;XSStack&lt;/code&gt; 및 &lt;code&gt;InitFileCode&lt;/code&gt; 속성이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="bfe5ea1c0f4c46a2237b24e5b3f2887e00aa6466" translate="yes" xml:space="preserve">
          <source>Modification of a read-only value attempted</source>
          <target state="translated">읽기 전용 값 수정 시도</target>
        </trans-unit>
        <trans-unit id="5f76e7ff47044fa8dd85e924ec7a4e874884a8b4" translate="yes" xml:space="preserve">
          <source>Modification of non-creatable array value attempted, %s</source>
          <target state="translated">생성 할 수없는 어레이 값을 수정하려고했습니다. % s</target>
        </trans-unit>
        <trans-unit id="5d49a6e4a1e825b5489876269856cd19dd0c32a5" translate="yes" xml:space="preserve">
          <source>Modification of non-creatable hash value attempted, %s</source>
          <target state="translated">생성 할 수없는 해시 값 수정을 시도했습니다. % s</target>
        </trans-unit>
        <trans-unit id="54e708f372bd6f49e75185b1eedbc1c5b10e7365" translate="yes" xml:space="preserve">
          <source>Modification time. Adjusted to mac-time on MacOS if required</source>
          <target state="translated">수정 시간. 필요한 경우 MacOS에서 mac-time으로 조정</target>
        </trans-unit>
        <trans-unit id="405f45092d843a1d3838d8a5b8852228db0dfbb7" translate="yes" xml:space="preserve">
          <source>Modifications</source>
          <target state="translated">Modifications</target>
        </trans-unit>
        <trans-unit id="6acab8f4be86f5c68401444e88bc8209222cbc50" translate="yes" xml:space="preserve">
          <source>Modifications from the original:</source>
          <target state="translated">원본에서 수정 :</target>
        </trans-unit>
        <trans-unit id="d15d3e35d08a4f905aca29a53f32a6a9324f7e00" translate="yes" xml:space="preserve">
          <source>Modified - 13 July 2001</source>
          <target state="translated">수정 됨-2001 년 7 월 13 일</target>
        </trans-unit>
        <trans-unit id="c28e2457b8697ed01bbb5ecba237019fd1dcb3c9" translate="yes" xml:space="preserve">
          <source>Modified - 25 June 2001</source>
          <target state="translated">수정 됨-2001 년 6 월 25 일</target>
        </trans-unit>
        <trans-unit id="d8e50120460706cd8f55da079850b9b27d5d7356" translate="yes" xml:space="preserve">
          <source>Modified - 28 May 2002</source>
          <target state="translated">수정-2002 년 5 월 28 일</target>
        </trans-unit>
        <trans-unit id="32979a38ecc2f0753d6d680873cd17c8a6ba6155" translate="yes" xml:space="preserve">
          <source>Modified by Casey West, 2000-11-08, v0.59.</source>
          <target state="translated">Casey West, 2000-11-08, v0.59에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5f3cf35626877ebe81f40ef6a55ba3d9279e043" translate="yes" xml:space="preserve">
          <source>Modified by Damian Conway, 1999-03-05, v0.58.</source>
          <target state="translated">Damian Conway, 1999-03-05, v0.58에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="94d5fe9080184121ea2c9a038a3632538b976fe0" translate="yes" xml:space="preserve">
          <source>Modified by Damian Conway, 2001-09-10, v0.62.</source>
          <target state="translated">Damian Conway, 2001-09-10, v0.62에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="9877a0e2ec14746d54f44a96609db5de1a2c19ac" translate="yes" xml:space="preserve">
          <source>Modified in Perl 5.10.1, 5.12.0</source>
          <target state="translated">Perl 5.10.1, 5.12.0에서 수정 됨</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="1c2e8964e53a3974ad38a662a6a136aa94d17d1a" translate="yes" xml:space="preserve">
          <source>Modifies Test::Builder internals.</source>
          <target state="translated">Test :: Builder 내부를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="e880a783bbd37d3dea3114db13bc60aa06662623" translate="yes" xml:space="preserve">
          <source>Modifies and queries the program's underlying locale. Users of this function should read &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;, whch provides a comprehensive discussion of Perl locale handling, knowledge of which is necessary to properly use this function. It contains &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;a section devoted to this function&lt;/a&gt;. The discussion here is merely a summary reference for &lt;code&gt;setlocale()&lt;/code&gt; . Note that Perl itself is almost entirely unaffected by the locale except within the scope of &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; . (Exceptions are listed in &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale in perllocale&lt;/a&gt;.)</source>
          <target state="translated">프로그램의 기본 로캘을 수정하고 쿼리합니다. 이 함수의 사용자는 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 읽어야 합니다. whch는 Perl 로케일 처리에 대한 포괄적 인 토론을 제공 하며이 함수 를 올바르게 사용하려면 지식이 필요합니다. 여기에는 &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;이 기능에 관한 섹션&lt;/a&gt; 이 포함되어 있습니다 . 여기서 논의는 &lt;code&gt;setlocale()&lt;/code&gt; 대한 요약 참조 일뿐 입니다. Perl 자체는 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 범위를 제외하고는 로케일의 영향을 거의받지 않습니다 . &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;perllocale의 사용 범위 내에 있지 않음에&lt;/a&gt; 예외가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b51ea52a3a827c7ad9340f3c3175b008c79459" translate="yes" xml:space="preserve">
          <source>Modifies the list of places temp directory information is looked for.</source>
          <target state="translated">임시 디렉토리 정보를 찾은 장소 목록을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="1d7a12e5c51dea8cde2ad6652de6b9359a21545b" translate="yes" xml:space="preserve">
          <source>Modifying and =</source>
          <target state="translated">수정 및 =</target>
        </trans-unit>
        <trans-unit id="ce1dfce837138cff453bdea39c7c4c418d1f1de3" translate="yes" xml:space="preserve">
          <source>Modifying the timestamps may not be possible at all: for example, the &lt;code&gt;noatime&lt;/code&gt; filesystem mount option may prohibit you from changing the access time timestamp.</source>
          <target state="translated">타임 스탬프를 수정하는 것은 전혀 불가능할 수 있습니다. 예를 들어, &lt;code&gt;noatime&lt;/code&gt; 파일 시스템 마운트 옵션은 액세스 타임 스탬프를 변경하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d78ea62126eeb6ac9e086c6864dab2d0e3c3a1" translate="yes" xml:space="preserve">
          <source>Module Installation</source>
          <target state="translated">모듈 설치</target>
        </trans-unit>
        <trans-unit id="5e8ed13e4781f62782d5aa23493e665d1640aba0" translate="yes" xml:space="preserve">
          <source>Module Meta-Data (META and MYMETA)</source>
          <target state="translated">모듈 메타 데이터 (META 및 MYMETA)</target>
        </trans-unit>
        <trans-unit id="1454ab039736e265b3314e2865bba939a5971c09" translate="yes" xml:space="preserve">
          <source>Module Version Checking</source>
          <target state="translated">모듈 버전 확인</target>
        </trans-unit>
        <trans-unit id="d108ead0085bbd00f6a4bbc9931939d7eccf7683" translate="yes" xml:space="preserve">
          <source>Module Writing</source>
          <target state="translated">모듈 작성</target>
        </trans-unit>
        <trans-unit id="516af6a787a862724252123e2bd3b762619e9ffe" translate="yes" xml:space="preserve">
          <source>Module authors should carefully consider whether to rely on other modules, and which modules to rely on.</source>
          <target state="translated">모듈 작성자는 다른 모듈에 의존할지 여부와 의존 할 모듈을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8471831f64e1887291d945952d1e1daa28722f62" translate="yes" xml:space="preserve">
          <source>Module for manipulations of tar archives</source>
          <target state="translated">tar 아카이브 조작을위한 모듈</target>
        </trans-unit>
        <trans-unit id="e65640d58920cc799b38907083a95415ef4b8a66" translate="yes" xml:space="preserve">
          <source>Module installation tools have ways of resolving unmet dependencies but to do that they need a</source>
          <target state="translated">모듈 설치 도구에는 충족되지 않은 종속성을 해결하는 방법이 있지만이를 수행하려면</target>
        </trans-unit>
        <trans-unit id="b1ac20aedfee381805b19478ff3a953f19bfd201" translate="yes" xml:space="preserve">
          <source>Module name must be constant</source>
          <target state="translated">모듈 이름은 일정해야합니다.</target>
        </trans-unit>
        <trans-unit id="296ea56fdcb62556504377c9806acdeebb07b6ba" translate="yes" xml:space="preserve">
          <source>Module name required with -%c option</source>
          <target state="translated">-% c 옵션과 함께 필요한 모듈 이름</target>
        </trans-unit>
        <trans-unit id="8b521a1c525dc29431bbdbd97b08d7337321f5f4" translate="yes" xml:space="preserve">
          <source>Module tests</source>
          <target state="translated">모듈 테스트</target>
        </trans-unit>
        <trans-unit id="09c1308ed6b0c63e3397790cc4f67693af0f82c7" translate="yes" xml:space="preserve">
          <source>Module to convert pod files to HTML</source>
          <target state="translated">포드 파일을 HTML로 변환하는 모듈</target>
        </trans-unit>
        <trans-unit id="15ecde6b9e55280e32d99a40c501f4e2e8c2ff44" translate="yes" xml:space="preserve">
          <source>Module to test the XS typemaps distributed with perl</source>
          <target state="translated">perl과 함께 배포 된 XS 유형 맵을 테스트하는 모듈</target>
        </trans-unit>
        <trans-unit id="b97c2d8aa7bcb68996cb4a6d31701bee24ce1615" translate="yes" xml:space="preserve">
          <source>Module use may give one of the following errors during import.</source>
          <target state="translated">가져 오기 중에 모듈을 사용하면 다음 오류 중 하나가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3674e804d761cb13678499f67d99449dc4f27a48" translate="yes" xml:space="preserve">
          <source>Module.pm</source>
          <target state="translated">Module.pm</target>
        </trans-unit>
        <trans-unit id="ab9ab41c22948665a29f42a31b28aeddb3d8a91e" translate="yes" xml:space="preserve">
          <source>Module.pod</source>
          <target state="translated">Module.pod</target>
        </trans-unit>
        <trans-unit id="ae8d8ff480dfbba731116e004a9d3f57c4bd6cdb" translate="yes" xml:space="preserve">
          <source>Module::Build</source>
          <target state="translated">Module::Build</target>
        </trans-unit>
        <trans-unit id="62fb86405abcf275344b08fc9af2288d90dc6412" translate="yes" xml:space="preserve">
          <source>Module::Build 0.28 added support for &lt;code&gt;--prefix&lt;/code&gt; which works like MakeMaker's PREFIX.</source>
          <target state="translated">Module :: Build 0.28에는 MakeMaker의 PREFIX처럼 작동 하는 &lt;code&gt;--prefix&lt;/code&gt; 에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="150dc2d2e198e343abd0bea909de778fbe14be58" translate="yes" xml:space="preserve">
          <source>Module::Build design plans</source>
          <target state="translated">Module :: 설계 계획 수립</target>
        </trans-unit>
        <trans-unit id="91d488d471a8bc496d78b2b13e521d55c3f0cdef" translate="yes" xml:space="preserve">
          <source>Module::Build is a project by Ken Williams to supplant MakeMaker. Its primary advantages are:</source>
          <target state="translated">Module :: Build는 MakeMaker를 대체하기위한 Ken Williams의 프로젝트입니다. 주요 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b1f0f8f3e8bc54c1732e312db2a7505d466061a" translate="yes" xml:space="preserve">
          <source>Module::Build was long the official heir apparent to MakeMaker. The rate of both its development and adoption has slowed in recent years, though, and it is unclear what the future holds for it. That said, Module::Build set the stage for</source>
          <target state="translated">Module :: Build는 오랫동안 MakeMaker의 공식 상속인이었습니다. 그러나 최근 몇 년 동안 개발 및 채택 속도가 느려졌으며 미래가 무엇을 유지할지 불분명합니다. 즉, Module :: Build는</target>
        </trans-unit>
        <trans-unit id="8def62b03ff3b40aeadb216948bd496a8840b87f" translate="yes" xml:space="preserve">
          <source>Module::Build, as of 0.28, supports two ways to install to the same location as MakeMaker.</source>
          <target state="translated">Module :: Build는 0.28부터 MakeMaker와 동일한 위치에 설치하는 두 가지 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a1edaf280214fd94706296d20c3b0f2bfdf9eb59" translate="yes" xml:space="preserve">
          <source>Module::CoreList</source>
          <target state="translated">Module::CoreList</target>
        </trans-unit>
        <trans-unit id="c1eab53f65667256b290f34243d94d7ecdff687e" translate="yes" xml:space="preserve">
          <source>Module::CoreList - what modules shipped with versions of perl</source>
          <target state="translated">Module :: CoreList-Perl 버전과 함께 제공되는 모듈</target>
        </trans-unit>
        <trans-unit id="cf24a0df2a2fe48d90f4a8337763728341cb900f" translate="yes" xml:space="preserve">
          <source>Module::CoreList currently covers the 5.000, 5.001, 5.002, 5.003_07, 5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 and 5.7.3 releases of perl.</source>
          <target state="translated">Module :: CoreList는 현재 5.000, 5.001, 5.002, 5.003_07, 5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 및 5.7.3 릴리스의 perl을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b23a69ee7bbcaf5f395d8275dba4f3efac0eee37" translate="yes" xml:space="preserve">
          <source>Module::CoreList provides information on which core and dual-life modules shipped with each version of &lt;a href=&quot;../perl&quot;&gt;perl&lt;/a&gt;.</source>
          <target state="translated">Module :: CoreList는 각 버전의 &lt;a href=&quot;../perl&quot;&gt;perl&lt;/a&gt; 과 함께 제공되는 코어 및 이중 수명 모듈에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="734252a85fe5c8339de69573b5216ab8f0aa64b1" translate="yes" xml:space="preserve">
          <source>Module::CoreList provides information on which core and dual-life modules shipped with each version of &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;.</source>
          <target state="translated">Module :: CoreList는 각 버전의 &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; 과 함께 제공되는 코어 및 이중 수명 모듈에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="de86ec78c4d249d74b590b22c867ee4d58aa762e" translate="yes" xml:space="preserve">
          <source>Module::CoreList::Utils</source>
          <target state="translated">Module::CoreList::Utils</target>
        </trans-unit>
        <trans-unit id="50d08dcfe907005aefae6a40958e4b055750c23b" translate="yes" xml:space="preserve">
          <source>Module::CoreList::Utils - what utilities shipped with versions of perl</source>
          <target state="translated">Module :: CoreList :: Utils-perl 버전과 함께 제공되는 유틸리티</target>
        </trans-unit>
        <trans-unit id="5d96066f93fab25da99dd68aa81cda10b29454b6" translate="yes" xml:space="preserve">
          <source>Module::CoreList::Utils provides information on which core and dual-life utilities shipped with each version of &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;.</source>
          <target state="translated">Module :: CoreList :: Utils는 각 버전의 &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; 과 함께 제공되는 코어 및 이중 수명 유틸리티에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e4b689d99705fdc907aba90226fb7f6ee6929e63" translate="yes" xml:space="preserve">
          <source>Module::Install</source>
          <target state="translated">Module::Install</target>
        </trans-unit>
        <trans-unit id="79bce9e07f8b204000334e6031e7ea0b0960701f" translate="yes" xml:space="preserve">
          <source>Module::Load</source>
          <target state="translated">Module::Load</target>
        </trans-unit>
        <trans-unit id="e3d85e08676b05b2e538b0685147bf01f13faa38" translate="yes" xml:space="preserve">
          <source>Module::Load - runtime require of both modules and files</source>
          <target state="translated">Module :: Load-모듈과 파일 모두의 런타임 요구</target>
        </trans-unit>
        <trans-unit id="6e16ca7f251db467f65f169ccb90bd1775b9be31" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional</source>
          <target state="translated">Module::Load::Conditional</target>
        </trans-unit>
        <trans-unit id="0333daac2dc5711d6aa41b0b76a07a8abee4d3b5" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional - Looking up module information / loading at runtime</source>
          <target state="translated">Module :: Load :: Conditional-런타임에 모듈 정보 조회 /로드</target>
        </trans-unit>
        <trans-unit id="c96b8d051cb4352b076673e1abc0268f29fa107f" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional provides simple ways to query and possibly load any of the modules you have installed on your system during runtime.</source>
          <target state="translated">Module :: Load :: Conditional은 런타임 중에 시스템에 설치 한 모듈을 쿼리하고로드하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fffd2566f2af4b448df67c2c105f5e1f1b680583" translate="yes" xml:space="preserve">
          <source>Module::Loaded</source>
          <target state="translated">Module::Loaded</target>
        </trans-unit>
        <trans-unit id="ce11901e21f211fb61728e8347b6913869d01fec" translate="yes" xml:space="preserve">
          <source>Module::Loaded - mark modules as loaded or unloaded</source>
          <target state="translated">Module :: Loaded-모듈을로드 또는 언로드로 표시</target>
        </trans-unit>
        <trans-unit id="bb6885dcfda6105816579eb1110d8a0af233720c" translate="yes" xml:space="preserve">
          <source>Module::Metadata</source>
          <target state="translated">Module::Metadata</target>
        </trans-unit>
        <trans-unit id="5e8e22f998099970e72ea7db019f086e11a0adef" translate="yes" xml:space="preserve">
          <source>Module::Metadata - Gather package and POD information from perl module files</source>
          <target state="translated">Module :: Metadata-펄 모듈 파일에서 패키지 및 POD 정보 수집</target>
        </trans-unit>
        <trans-unit id="02e77c62a7e1cc7db95a64ce9a1c2d0f806647c6" translate="yes" xml:space="preserve">
          <source>Module::bootstrap()</source>
          <target state="translated">Module::bootstrap()</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="801dc9760f104617b6ed8b09b3bc552754857caf" translate="yes" xml:space="preserve">
          <source>Modules Used</source>
          <target state="translated">사용 된 모듈</target>
        </trans-unit>
        <trans-unit id="ba45166087559a8d4da3018515bba6d0e5511862" translate="yes" xml:space="preserve">
          <source>Modules and Extensions for Perl on OS/390</source>
          <target state="translated">OS / 390의 Perl 용 모듈 및 확장</target>
        </trans-unit>
        <trans-unit id="cfe4151bcba7eda23509b603930bf7ee0bf81221" translate="yes" xml:space="preserve">
          <source>Modules are installed on a case-by-case basis (as provided by the methods described in the previous section), and in the operating system. All of these paths are stored in @INC, which you can display with the one-liner</source>
          <target state="translated">모듈은 사례별로 (이전 섹션에서 설명한 방법으로 제공) 운영 체제에 설치됩니다. 이 모든 경로는 @INC에 저장되며, 하나의 라이너로 표시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c98c46b9ec45777efe9604a1088b3e507328331" translate="yes" xml:space="preserve">
          <source>Modules in the</source>
          <target state="translated">의 모듈</target>
        </trans-unit>
        <trans-unit id="387c58c36e26384b5c37e68bd7e39af265275a1f" translate="yes" xml:space="preserve">
          <source>Modules know their associated Distribution objects. They always refer to the most recent official release. Developers may mark their releases as unstable development versions (by inserting an underscore into the module version number which will also be reflected in the distribution name when you run 'make dist'), so the really hottest and newest distribution is not always the default. If a module Foo circulates on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient way to install version 1.23 by saying</source>
          <target state="translated">모듈은 관련된 배포 객체를 알고 있습니다. 항상 최신 공식 릴리스를 참조합니다. 개발자는 릴리스를 불안정한 개발 버전으로 표시 할 수 있습니다 ( 'make dist'를 실행할 때 배포 이름에 밑줄을 추가하여 모듈 버전 번호에 밑줄을 삽입하여). 가장 인기있는 최신 배포가 항상 기본값이 아닙니다. 모듈 Foo가 버전 1.23 및 1.23_90에서 CPAN을 순환하는 경우 CPAN.pm은 다음과 같이 말하여 버전 1.23을 편리하게 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f3d6f058f458ef7f23d8ca7c1fa07e5fdffa37c" translate="yes" xml:space="preserve">
          <source>Modules not available from CPAN</source>
          <target state="translated">CPAN에서 사용할 수없는 모듈</target>
        </trans-unit>
        <trans-unit id="8de09ade33dff4d30d378d32e3f399e05899232c" translate="yes" xml:space="preserve">
          <source>Modules shipped as part of the Perl core live in four subdirectories. Two of these directories contain modules that live in the core, and two contain modules that can also be released separately on CPAN. Modules which can be released on cpan are known as &quot;dual-life&quot; modules.</source>
          <target state="translated">Perl 코어의 일부로 제공되는 모듈은 4 개의 하위 디렉토리에 있습니다. 이 디렉토리 중 2 개에는 코어에있는 모듈이 있고 2 개에는 CPAN에서 별도로 릴리스 할 수있는 모듈이 있습니다. cpan에서 해제 할 수있는 모듈을 &quot;이중 수명&quot;모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e0e8aed9f80a1dc002e318b7643af4d7677ed672" translate="yes" xml:space="preserve">
          <source>Modules should be packaged using one of the standard packaging tools. Currently you have the choice between ExtUtils::MakeMaker and the more platform independent Module::Build, allowing modules to be installed in a consistent manner. When using ExtUtils::MakeMaker, you can use &quot;make dist&quot; to create your package. Tools exist to help you to build your module in a MakeMaker-friendly style. These include ExtUtils::ModuleMaker and h2xs. See also &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt;.</source>
          <target state="translated">모듈은 표준 패키징 도구 중 하나를 사용하여 패키징해야합니다. 현재 ExtUtils :: MakeMaker와 플랫폼 독립적 인 Module :: Build 중에서 선택하여 모듈을 일관된 방식으로 설치할 수 있습니다. ExtUtils :: MakeMaker를 사용할 때 &quot;make dist&quot;를 사용하여 패키지를 만들 수 있습니다. MakeMaker 친화적 인 스타일로 모듈을 빌드하는 데 도움이되는 도구가 있습니다. 여기에는 ExtUtils :: ModuleMaker 및 h2xs가 포함됩니다. &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eefcfbc44b095f906993d6a3ee0e852ebab6785" translate="yes" xml:space="preserve">
          <source>Modules such as &lt;a href=&quot;Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; and &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; can help with that too. If you can, however, avoid reading the entire file at once. Perl won't give that memory back to the operating system until the process finishes.</source>
          <target state="translated">&lt;a href=&quot;Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt; 및 &lt;a href=&quot;Tie::File&quot;&gt;Tie :: File&lt;/a&gt; 과 같은 모듈 도 도움이 될 수 있습니다. 그러나 가능하다면 전체 파일을 한 번에 읽지 마십시오. Perl은 프로세스가 완료 될 때까지 해당 메모리를 운영 체제에 다시 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eba7daa98709598366c3537d2ec9862d20e4985a" translate="yes" xml:space="preserve">
          <source>Modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; and &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; can help with that too. If you can, however, avoid reading the entire file at once. Perl won't give that memory back to the operating system until the process finishes.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt; 및 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 과 같은 모듈 도 도움이 될 수 있습니다. 그러나 가능하면 전체 파일을 한 번에 읽지 마십시오. Perl은 프로세스가 완료 될 때까지 해당 메모리를 운영 체제에 다시 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e39293c10b487ab181c13d36712d552c93decf5" translate="yes" xml:space="preserve">
          <source>Modules that calculate message digests</source>
          <target state="translated">메시지 요약을 계산하는 모듈</target>
        </trans-unit>
        <trans-unit id="c5ea83baff39996a0d7cf4b745d2c4d5aed9fdd5" translate="yes" xml:space="preserve">
          <source>Modules that provide OS-specific behaviors often need to know if the current operating system matches a more generic type of operating systems. For example, 'linux' is a type of 'Unix' operating system and so is 'freebsd'.</source>
          <target state="translated">OS 별 동작을 제공하는 모듈은 현재 운영 체제가보다 일반적인 유형의 운영 체제와 일치하는지 여부를 알아야하는 경우가 많습니다. 예를 들어 'linux'는 'Unix'운영 체제의 한 유형이므로 'freebsd'도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7e640dc8698a54c30ce2b25e1b3caa6b2de29019" translate="yes" xml:space="preserve">
          <source>Modules uploaded to CPAN are tested by a variety of volunteers on different platforms. These CPAN testers are notified by mail of each new upload, and reply to the list with PASS, FAIL, NA (not applicable to this platform), or UNKNOWN (unknown), along with any relevant notations.</source>
          <target state="translated">CPAN에 업로드 된 모듈은 다양한 플랫폼에서 다양한 자원 봉사자가 테스트합니다. 이 CPAN 테스터는 각각의 새로운 업로드에 대해 우편으로 통지를 받고 관련 표기와 함께 PASS, FAIL, NA (이 플랫폼에는 해당되지 않음) 또는 UNKNOWN (알 수 없음)으로 목록에 회신합니다.</target>
        </trans-unit>
        <trans-unit id="9c1cf1fbeb1d4ad27fd965e462b1a6f05eea74e9" translate="yes" xml:space="preserve">
          <source>Modules which are &quot;stable&quot; should not break backwards compatibility without at least a long transition phase and a major change in version number.</source>
          <target state="translated">&quot;안정된&quot;모듈은 최소한 긴 전환 단계와 버전 번호의 주요 변경없이 하위 호환성을 손상시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d737814ec2d252aed0d9553090a83af593402cf6" translate="yes" xml:space="preserve">
          <source>Modules: Creation, Use, and Abuse</source>
          <target state="translated">모듈 : 생성, 사용 및 남용</target>
        </trans-unit>
        <trans-unit id="cedf0a043a8175adc7d112f8794910834f961fb1" translate="yes" xml:space="preserve">
          <source>Mohammad S Anwar &amp;lt;mohammad.anwar@yahoo.com&amp;gt;</source>
          <target state="translated">Mohammad S Anwar &amp;lt;mohammad.anwar@yahoo.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bf3a7ff6bdc4145b967af70ab8f39f386ae3ec49" translate="yes" xml:space="preserve">
          <source>Mojolicious</source>
          <target state="translated">Mojolicious</target>
        </trans-unit>
        <trans-unit id="9791bc4d7273587d61fef79841bd342381f5e321" translate="yes" xml:space="preserve">
          <source>Moldova</source>
          <target state="translated">Moldova</target>
        </trans-unit>
        <trans-unit id="1946c31aeef030db495b0e13ad1403e9cb0aa7a2" translate="yes" xml:space="preserve">
          <source>Moo</source>
          <target state="translated">Moo</target>
        </trans-unit>
        <trans-unit id="9fdbf7859aefc5d1a01b970f830cbc34f4ef18a9" translate="yes" xml:space="preserve">
          <source>Moose</source>
          <target state="translated">Moose</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="5696d6a7f215fb3987b13af506efed308c8661bb" translate="yes" xml:space="preserve">
          <source>More Pod::Simple Methods</source>
          <target state="translated">더 많은 포드 :: 간단한 방법</target>
        </trans-unit>
        <trans-unit id="82e29b39da9785f5a818efe5d3fe3de6e587d533" translate="yes" xml:space="preserve">
          <source>More Problems</source>
          <target state="translated">더 많은 문제</target>
        </trans-unit>
        <trans-unit id="53057b4dfd56a329af03f74d8aab9d36470ceecf" translate="yes" xml:space="preserve">
          <source>More about XSUB arguments</source>
          <target state="translated">XSUB 인수에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="108f2973ee0fc68f8bd1c87f7945bdef10ce9b19" translate="yes" xml:space="preserve">
          <source>More advanced specifications for parallel vs sequence run rules</source>
          <target state="translated">병렬 및 시퀀스 실행 규칙에 대한 고급 사양</target>
        </trans-unit>
        <trans-unit id="fd4e82e5da3e4dda041a0cb49fdccc789d8158c0" translate="yes" xml:space="preserve">
          <source>More complete API.</source>
          <target state="translated">더 완전한 API.</target>
        </trans-unit>
        <trans-unit id="efa61b2946cd3153b1a26ff99517443d74f92f4b" translate="yes" xml:space="preserve">
          <source>More complex cases will require to write a parser, probably using a parsing module from CPAN, like &lt;a href=&quot;Regexp::Grammars&quot;&gt;Regexp::Grammars&lt;/a&gt;, &lt;a href=&quot;Parse::RecDescent&quot;&gt;Parse::RecDescent&lt;/a&gt;, &lt;a href=&quot;Parse::Yapp&quot;&gt;Parse::Yapp&lt;/a&gt;, &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt;, or &lt;a href=&quot;Marpa::R2&quot;&gt;Marpa::R2&lt;/a&gt;.</source>
          <target state="translated">더 복잡한 경우에는 아마도 &lt;a href=&quot;Regexp::Grammars&quot;&gt;Regexp :: Grammars&lt;/a&gt; , &lt;a href=&quot;Parse::RecDescent&quot;&gt;Parse :: RecDescent&lt;/a&gt; , &lt;a href=&quot;Parse::Yapp&quot;&gt;Parse :: Yapp&lt;/a&gt; , &lt;a href=&quot;Text::Balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 또는 &lt;a href=&quot;Marpa::R2&quot;&gt;Marpa :: R2&lt;/a&gt; 와 같은 CPAN의 구문 분석 모듈을 사용하여 구문 분석기를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="13a55c80ed5c83f1c889c62320fc4a034a2333c3" translate="yes" xml:space="preserve">
          <source>More complex cases will require to write a parser, probably using a parsing module from CPAN, like &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Grammars&quot;&gt;Regexp::Grammars&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::RecDescent&quot;&gt;Parse::RecDescent&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::Yapp&quot;&gt;Parse::Yapp&lt;/a&gt;, &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Marpa::R2&quot;&gt;Marpa::R2&lt;/a&gt;.</source>
          <target state="translated">보다 복잡한 경우에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Grammars&quot;&gt;Regexp :: Grammars&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::RecDescent&quot;&gt;Parse :: RecDescent&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::Yapp&quot;&gt;Parse :: Yapp&lt;/a&gt; , &lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Marpa::R2&quot;&gt;Marpa :: R2&lt;/a&gt; 와 같은 CPAN의 구문 분석 모듈을 사용하여 구문 분석기를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b11b4dd1cd41cf4f86d96c0b775f01a4fba8ea41" translate="yes" xml:space="preserve">
          <source>More complex data types can be constructed using references, which allow you to build lists and hashes within lists and hashes.</source>
          <target state="translated">참조를 사용하여 더 복잡한 데이터 유형을 구성 할 수 있으므로 목록과 해시 내에 목록과 해시를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4020daf37582247db604f50a3dd13402fd4a026e" translate="yes" xml:space="preserve">
          <source>More complex regular expressions</source>
          <target state="translated">더 복잡한 정규식</target>
        </trans-unit>
        <trans-unit id="22de1dce99fa44a08c2393686bc2b8372b954725" translate="yes" xml:space="preserve">
          <source>More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to change more basic behaviors. A subclass that needs to merely change the output only needs to overload &lt;code&gt;bstr()&lt;/code&gt; .</source>
          <target state="translated">더 복잡한 하위 클래스가 더 많은 기본 동작을 변경해야하는 경우 Math :: BigInt의 내부 논리를 더 많이 복제해야 할 수 있습니다. 단순히 출력을 변경해야하는 서브 클래스는 &lt;code&gt;bstr()&lt;/code&gt; 오버로드 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="756589b88b61cce058613ae89757234c6572a356" translate="yes" xml:space="preserve">
          <source>More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to change more basic behaviors. A subclass that needs to merely change the output only needs to overload &lt;code&gt;bstr()&lt;/code&gt;.</source>
          <target state="translated">더 복잡한 하위 클래스는 더 많은 기본 동작을 변경해야하는 경우 Math :: BigInt의 내부 논리를 더 많이 복제해야 할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 단순히 출력을 변경해야하는 서브 클래스는 &lt;code&gt;bstr()&lt;/code&gt; 오버로드 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="79f15d6cc7c0d2273ae329858641605f6bede3c4" translate="yes" xml:space="preserve">
          <source>More complicated XSUBs may contain many other sections. Each section of an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:. However, the first two lines of an XSUB always contain the same data: descriptions of the return type and the names of the function and its parameters. Whatever immediately follows these is considered to be an INPUT: section unless explicitly marked with another keyword. (See &lt;a href=&quot;#The-INPUT%3A-Keyword&quot;&gt;&quot;The INPUT: Keyword&quot;&lt;/a&gt;.)</source>
          <target state="translated">더 복잡한 XSUB에는 다른 많은 섹션이 포함될 수 있습니다. XSUB의 각 섹션은 INIT : 또는 CLEANUP :과 같은 해당 키워드로 시작합니다. 그러나 XSUB의 처음 두 줄에는 항상 동일한 데이터 (반환 유형에 대한 설명, 함수 이름 및 매개 변수)가 포함됩니다. 바로 뒤에 오는 것은 다른 키워드로 명시 적으로 표시하지 않는 한 INPUT : 섹션으로 간주됩니다. ( &lt;a href=&quot;#The-INPUT%3A-Keyword&quot;&gt;&quot;입력 : 키워드&quot;&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="2fbe3042a0cc3a612b8a82908d39dc629d888d5d" translate="yes" xml:space="preserve">
          <source>More complicated XSUBs may contain many other sections. Each section of an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:. However, the first two lines of an XSUB always contain the same data: descriptions of the return type and the names of the function and its parameters. Whatever immediately follows these is considered to be an INPUT: section unless explicitly marked with another keyword. (See &lt;a href=&quot;#The-INPUT%3a-Keyword&quot;&gt;The INPUT: Keyword&lt;/a&gt;.)</source>
          <target state="translated">더 복잡한 XSUB에는 다른 많은 섹션이 포함될 수 있습니다. XSUB의 각 섹션은 INIT : 또는 CLEANUP :과 같은 해당 키워드로 시작합니다. 그러나 XSUB의 처음 두 행에는 항상 동일한 데이터가 포함됩니다. 리턴 유형 설명 및 함수 이름 및 매개 변수 이름. 바로 뒤에 나오는 것은 다른 키워드로 명시 적으로 표시되지 않는 한 INPUT : 섹션으로 간주됩니다. ( &lt;a href=&quot;#The-INPUT%3a-Keyword&quot;&gt;입력 : 키워드&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d66d0268f9a384b521bc030afaac1581d909de98" translate="yes" xml:space="preserve">
          <source>More confusing options than you can shake a big stick at! It's not as bad as it looks and it's very useful to know more about all of it, and fun too!</source>
          <target state="translated">당신이 큰 막대기를 흔들 수있는 것보다 더 혼란스러운 옵션! 외형만큼 나쁘지는 않으며 모든 것에 대해 더 많이 알고 재미있게 사용하는 것이 매우 유용합니다!</target>
        </trans-unit>
        <trans-unit id="526d1ff4132ac0e34dbd3812351d44fc0c1c9026" translate="yes" xml:space="preserve">
          <source>More detail on each of the modifiers follows. Most likely you don't need to know this detail for &lt;code&gt;/l&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/d&lt;/code&gt;, and can skip ahead to &lt;a href=&quot;#%2fa-(and-%2faa)&quot;&gt;/a&lt;/a&gt;.</source>
          <target state="translated">각 수정 자에 대한 자세한 내용은 다음과 같습니다. 대부분의 경우이 세부 사항에 대한 알 필요가 없습니다 &lt;code&gt;/l&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , 및 &lt;code&gt;/d&lt;/code&gt; 하고 건너 뛰고 수 &lt;a href=&quot;#%2fa-(and-%2faa)&quot;&gt;/ A&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6f6bf6105714de1c120dd3b291d9add613ebf8" translate="yes" xml:space="preserve">
          <source>More detail on each of the modifiers follows. Most likely you don't need to know this detail for &lt;code&gt;/l&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt;, and &lt;code&gt;/d&lt;/code&gt;, and can skip ahead to &lt;a href=&quot;#%2Fa-%28and-%2Faa%29&quot;&gt;/a&lt;/a&gt;.</source>
          <target state="translated">각 수정 자에 대한 자세한 내용은 다음과 같습니다. 대부분의 경우이 세부 사항에 대한 알 필요가 없습니다 &lt;code&gt;/l&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , 및 &lt;code&gt;/d&lt;/code&gt; 하고 건너 뛰고 수 &lt;a href=&quot;#%2Fa-%28and-%2Faa%29&quot;&gt;/ A&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d17cbfc12e087be467835457f4aeb7c6f18f60" translate="yes" xml:space="preserve">
          <source>More detailed example</source>
          <target state="translated">더 자세한 예</target>
        </trans-unit>
        <trans-unit id="f2fe550e6e93ebe700899518f39fbee8a6928544" translate="yes" xml:space="preserve">
          <source>More detailed information about Perl syntax can be found in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">Perl 구문에 대한 자세한 정보는 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4d020339877fe2163d2f4652ee795295ae937b6" translate="yes" xml:space="preserve">
          <source>More details on hacking the Perl core. This document focuses on lower level details such as how to write tests, compilation issues, portability, debugging, etc.</source>
          <target state="translated">Perl 코어 해킹에 대한 자세한 내용 이 문서는 테스트 작성 방법, 컴파일 문제, 이식성, 디버깅 등과 같은 하위 수준의 세부 사항에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="5f269e55bd34be0e508b0040a6ba9834ce17dd8a" translate="yes" xml:space="preserve">
          <source>More details on the categories used by Perl are given below in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;&lt;/a&gt;.</source>
          <target state="translated">Perl에서 사용하는 카테고리에 대한 자세한 내용은 아래 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8bbc3f15f8c3d6fccfab2c6f797ecddb3a71815" translate="yes" xml:space="preserve">
          <source>More details on the categories used by Perl are given below in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt;.</source>
          <target state="translated">Perl이 사용하는 카테고리에 대한 자세한 내용은 아래의 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8e3c44663c4ead5df55d85ed7952e7012ae119b" translate="yes" xml:space="preserve">
          <source>More examples of different modes in action:</source>
          <target state="translated">작동중인 다양한 모드의 더 많은 예 :</target>
        </trans-unit>
        <trans-unit id="08965269be31a1f77226663d4b16152886fa2985" translate="yes" xml:space="preserve">
          <source>More examples:</source>
          <target state="translated">더 많은 예 :</target>
        </trans-unit>
        <trans-unit id="58b102e56a8f6f1fc1426db346097f8c24db1a1b" translate="yes" xml:space="preserve">
          <source>More flags to pass to the &lt;code&gt;getaddrinfo()&lt;/code&gt; function. If not supplied, a default of &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;getaddrinfo()&lt;/code&gt; 함수 에 전달할 더 많은 플래그 . 제공되지 않으면 기본값 &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abe7c3d7dc58312e0a715568eb7fe1648b80945e" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;\p{Uppercase}&lt;/code&gt; matches any single character whose Unicode &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;True&lt;/code&gt; , and &lt;code&gt;\P{Uppercase}&lt;/code&gt; matches any character whose &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;False&lt;/code&gt; , and they could have been written as &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; and &lt;code&gt;\p{Uppercase=False}&lt;/code&gt; , respectively.</source>
          <target state="translated">보다 공식적으로, &lt;code&gt;\p{Uppercase}&lt;/code&gt; 는 Unicode &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;True&lt;/code&gt; 인 단일 문자와 일치 하고 &lt;code&gt;\P{Uppercase}&lt;/code&gt; 는 &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;False&lt;/code&gt; 인 모든 문자와 일치 하며 &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; 로 쓸 수 있습니다 및 &lt;code&gt;\p{Uppercase=False}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="950f5b581b5e9dd9bda925ea96c7e3efb17146e5" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;\p{Uppercase}&lt;/code&gt; matches any single character whose Unicode &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;\P{Uppercase}&lt;/code&gt; matches any character whose &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;False&lt;/code&gt;, and they could have been written as &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; and &lt;code&gt;\p{Uppercase=False}&lt;/code&gt;, respectively.</source>
          <target state="translated">보다 공식적으로 &lt;code&gt;\p{Uppercase}&lt;/code&gt; 는 Unicode &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;True&lt;/code&gt; 인 단일 문자와 일치 하고 &lt;code&gt;\P{Uppercase}&lt;/code&gt; 는 &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;False&lt;/code&gt; 인 모든 문자와 일치 하며 &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; 로 기록 될 수 있습니다. 및 &lt;code&gt;\p{Uppercase=False}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27451c770878f49944a4e46db9a7b7a2c5c07101" translate="yes" xml:space="preserve">
          <source>More formally, it will be false if anything has happened which makes it impossible for the test suite to pass. True otherwise.</source>
          <target state="translated">더 공식적으로, 테스트 스위트가 통과 할 수없는 일이 발생하면 거짓이됩니다. 그렇지 않으면 맞습니다.</target>
        </trans-unit>
        <trans-unit id="e4f15e11fdfe41914601fd2b52ca88c4e0b2db11" translate="yes" xml:space="preserve">
          <source>More fun with &lt;code&gt;?{}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;?{}&lt;/code&gt; 더 재미있게 :</target>
        </trans-unit>
        <trans-unit id="3d785a8d06f0122559b61ab5ff5e1ae77216b585" translate="yes" xml:space="preserve">
          <source>More generally, &lt;code&gt;\&lt;i&gt;nnn&lt;/i&gt;&lt;/code&gt;, where</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;\&lt;i&gt;nnn&lt;/i&gt;&lt;/code&gt; , 여기서</target>
        </trans-unit>
        <trans-unit id="4da98cf1b684d1edc72215ded0f14b15a6f1b445" translate="yes" xml:space="preserve">
          <source>More important (and less obvious) is the necessity of garbage collection. When a normal object dies, anything stored in the object body is garbage-collected by perl. With inside-out objects, Perl knows nothing about the data stored in field hashes by a class, but these must be deleted when the object goes out of scope. Thus the class must provide a &lt;code&gt;DESTROY&lt;/code&gt; method to take care of that.</source>
          <target state="translated">더 중요하고 덜 분명한 것은 가비지 수집의 필요성입니다. 일반 객체가 죽으면 객체 본문에 저장된 모든 항목이 perl에 의해 가비지 수집됩니다. 인사이드 아웃 오브젝트를 사용하면 Perl은 클래스에 의해 필드 해시에 저장된 데이터에 대해 아무것도 알지 못하지만 오브젝트가 범위를 벗어날 때 삭제해야합니다. 따라서 클래스는이를 처리하기 위해 &lt;code&gt;DESTROY&lt;/code&gt; 메소드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4232744f447684a298c82dce2791eb6cf2ae4bde" translate="yes" xml:space="preserve">
          <source>More importantly, you assume</source>
          <target state="translated">더 중요한 것은</target>
        </trans-unit>
        <trans-unit id="dbb4a7aa9653e873e873e3d4f83808761932aa49" translate="yes" xml:space="preserve">
          <source>More information on the terminal capabilities will be found in the termcap manpage on most Unix-like systems.</source>
          <target state="translated">터미널 기능에 대한 자세한 내용은 대부분의 유닉스 계열 시스템의 termcap 맨 페이지에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9cc3109d4e7c580c76561d1b8bded0209caf69" translate="yes" xml:space="preserve">
          <source>More layers than just the encoding can be specified here. For example, the incantation &lt;code&gt;&quot;:raw :encoding(UTF-16LE) :crlf&quot;&lt;/code&gt; includes implicit CRLF handling.</source>
          <target state="translated">여기서는 인코딩보다 더 많은 레이어를 지정할 수 있습니다. 예를 들어, &lt;code&gt;&quot;:raw :encoding(UTF-16LE) :crlf&quot;&lt;/code&gt; 는 암시적인 CRLF 처리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e8d55c7fe7068672e98b5466a50eadff1658752a" translate="yes" xml:space="preserve">
          <source>More likely, &lt;code&gt;$svAccess&lt;/code&gt; is a string describing the generic type of access you desire and possibly the file creation options to use. In this case, &lt;code&gt;$svAccess&lt;/code&gt; should contain zero or more characters from &lt;code&gt;&quot;qrw&quot;&lt;/code&gt; [access desired], zero or one character each from &lt;code&gt;&quot;ktn&quot;&lt;/code&gt; and &lt;code&gt;&quot;ce&quot;&lt;/code&gt;, and optional white space. These letters stand for, respectively, &quot;Query access&quot;, &quot;Read access&quot;, &quot;Write access&quot;, &quot;Keep if exists&quot;, &quot;Truncate if exists&quot;, &quot;New file only&quot;, &quot;Create if none&quot;, and &quot;Existing file only&quot;. Case is ignored.</source>
          <target state="translated">아마도 &lt;code&gt;$svAccess&lt;/code&gt; 는 원하는 액세스 유형과 사용할 파일 생성 옵션을 설명하는 문자열입니다. 이 경우 &lt;code&gt;$svAccess&lt;/code&gt; 는 &lt;code&gt;&quot;qrw&quot;&lt;/code&gt; [원하는 액세스]에서 0 개 이상의 문자, &lt;code&gt;&quot;ktn&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;ce&quot;&lt;/code&gt; 에서 각각 0 개 또는 1 개의 문자 , 선택적 공백을 포함해야합니다. 이러한 문자는 각각 &quot;쿼리 액세스&quot;, &quot;읽기 액세스&quot;, &quot;쓰기 액세스&quot;, &quot;존재하는 경우 유지&quot;, &quot;존재하는 경우 자르기&quot;, &quot;새 파일 만&quot;, &quot;없는 경우 작성&quot;및 &quot;기존 파일&quot;을 나타냅니다. 뿐&quot;. 대소 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d270a53a536b611473a25cb95f7037520a02f0" translate="yes" xml:space="preserve">
          <source>More matching</source>
          <target state="translated">더 일치</target>
        </trans-unit>
        <trans-unit id="b707ad370452316dedfbb6479f84b90feffeb14b" translate="yes" xml:space="preserve">
          <source>More on characters, strings, and character classes</source>
          <target state="translated">문자, 문자열 및 문자 클래스에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="0e20dff8fe6d2b34d7e4d4cac19464fdb760259e" translate="yes" xml:space="preserve">
          <source>More sophisticated example:</source>
          <target state="translated">보다 정교한 예 :</target>
        </trans-unit>
        <trans-unit id="969a983581a527717c64f4e926ceeb9fb3c1079b" translate="yes" xml:space="preserve">
          <source>More testing functions! Once you outgrow Test::Simple, look at &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;. Test::Simple is 100% forward compatible with &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; (i.e. you can just use &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; instead of Test::Simple in your programs and things will still work).</source>
          <target state="translated">더 많은 테스트 기능! Test :: Simple을 능가하면 &lt;a href=&quot;Test::More&quot;&gt;Test :: More를보십시오&lt;/a&gt; . Test :: Simple은 &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 와 100 % 순방향 호환됩니다 (즉 , 프로그램에서 Test :: Simple 대신 &lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt; 를 사용할 수 있으며 계속 작동합니다).</target>
        </trans-unit>
        <trans-unit id="58cc9a8a265ceaaf00e7a02c5fa1c3956c64ee64" translate="yes" xml:space="preserve">
          <source>More testing functions! Once you outgrow Test::Simple, look at &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;. Test::Simple is 100% forward compatible with &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt; (i.e. you can just use &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt; instead of Test::Simple in your programs and things will still work).</source>
          <target state="translated">더 많은 테스트 기능! Test :: Simple을 벗어나면 &lt;a href=&quot;more&quot;&gt;Test :: More를보십시오&lt;/a&gt; . Test :: Simple은 &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 와 100 % 호환됩니다 (예 &lt;a href=&quot;more&quot;&gt;: Test :: More&lt;/a&gt; , 프로그램에서 Test :: Simple 대신 를 여전히 작동합니다).</target>
        </trans-unit>
        <trans-unit id="dca60a28cf5bfac5c3931dc141dffe59abb6ab5a" translate="yes" xml:space="preserve">
          <source>More tests.</source>
          <target state="translated">더 많은 테스트.</target>
        </trans-unit>
        <trans-unit id="280bbf061032f32980db94b9cf615b5506c7b962" translate="yes" xml:space="preserve">
          <source>More tests. (Stuff I didn't think of yet.)</source>
          <target state="translated">더 많은 테스트. (아직도 생각하지 못했습니다.)</target>
        </trans-unit>
        <trans-unit id="6f210a3f7fd112870193ebdf353aec3e59ed0eb5" translate="yes" xml:space="preserve">
          <source>More than one argument to '%s' open</source>
          <target state="translated">'% s'에 대한 인수가 두 개 이상 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb0a049a65b7b6c69262ebd324033d41d896fe4" translate="yes" xml:space="preserve">
          <source>More than one plan</source>
          <target state="translated">하나 이상의 계획</target>
        </trans-unit>
        <trans-unit id="de0e63649914291795f2314152800444162a6954" translate="yes" xml:space="preserve">
          <source>Moreover, a third possibility may even be simpler than anything discussed above: &quot;Just require that all possible (or at least applicable) forms be provided in the call to the given language's quant method, as in:&quot;</source>
          <target state="translated">더욱이, 세 번째 가능성은 위에서 논의한 것보다 더 간단 할 수도 있습니다. &quot;다음과 같이 주어진 언어의 퀀트 메소드에 대한 호출에서 가능한 모든 (또는 최소한 적용 가능한) 형식이 제공되어야합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="371109ba4b8859f3e3185200282a3a250ce94866" translate="yes" xml:space="preserve">
          <source>Moreover, inside &lt;code&gt;(?{BLOCK})&lt;/code&gt;, &lt;code&gt;(?# comment )&lt;/code&gt;, and a &lt;code&gt;#&lt;/code&gt; -comment in a &lt;code&gt;/x&lt;/code&gt;-regular expression, no processing is performed whatsoever. This is the first step at which the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant.</source>
          <target state="translated">또한, 내부 &lt;code&gt;(?{BLOCK})&lt;/code&gt; , &lt;code&gt;(?# comment )&lt;/code&gt; 및 &lt;code&gt;#&lt;/code&gt; -comment에 &lt;code&gt;/x&lt;/code&gt; - 정규 표현식은 어떠한 처리를 전혀 수행되지 않는다. 이것은 &lt;code&gt;/x&lt;/code&gt; 수정 자의 존재와 관련된 첫 번째 단계 입니다.</target>
        </trans-unit>
        <trans-unit id="8b50b703e8f733eb18bd373161aa2549aa4cf9d1" translate="yes" xml:space="preserve">
          <source>Moreover, inside &lt;code&gt;(?{BLOCK})&lt;/code&gt;, &lt;code&gt;(?# comment )&lt;/code&gt;, and a &lt;code&gt;#&lt;/code&gt;-comment in a &lt;code&gt;/x&lt;/code&gt;-regular expression, no processing is performed whatsoever. This is the first step at which the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant.</source>
          <target state="translated">또한 &lt;code&gt;/x&lt;/code&gt; -regular 표현식의 &lt;code&gt;(?{BLOCK})&lt;/code&gt; , &lt;code&gt;(?# comment )&lt;/code&gt; 및 &lt;code&gt;#&lt;/code&gt; -comment 내부에는 어떠한 처리도 수행되지 않습니다. 이것은 &lt;code&gt;/x&lt;/code&gt; 수정 자의 존재와 관련된 첫 번째 단계 입니다.</target>
        </trans-unit>
        <trans-unit id="766af651754c70019b0147c9aabb389875f6513e" translate="yes" xml:space="preserve">
          <source>Moreover, the Perl interpreter itself has had serious bugs involving fatalized warnings. For a summary of resolved and unresolved problems as of January 2015, please see &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f2015%2f01%2fmsg225235.html&quot;&gt;this perl5-porters post&lt;/a&gt;.</source>
          <target state="translated">또한 Perl 인터프리터 자체에는 치명적인 경고와 관련된 심각한 버그가 있습니다. 2015 년 1 월 기준으로 해결 된 문제와 해결되지 않은 문제에 대한 요약은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f2015%2f01%2fmsg225235.html&quot;&gt;이 perl5-porters post&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeff5d75841a1da3989f3e49cb3c5fb4a15531c1" translate="yes" xml:space="preserve">
          <source>Moreover, the Perl interpreter itself has had serious bugs involving fatalized warnings. For a summary of resolved and unresolved problems as of January 2015, please see &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/2015/01/msg225235.html&quot;&gt;this perl5-porters post&lt;/a&gt;.</source>
          <target state="translated">더욱이 Perl 인터프리터 자체에는 치명적인 경고와 관련된 심각한 버그가있었습니다. 2015 년 1 월 현재 해결 된 문제와 해결되지 않은 문제에 대한 요약은 &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/2015/01/msg225235.html&quot;&gt;이 perl5-porters 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71781bd1796397c70432d8ed26a8fe5878ffc4aa" translate="yes" xml:space="preserve">
          <source>Moreover, users may expect this:</source>
          <target state="translated">또한 사용자는 다음을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d0005685b4ea3ed15fd588977e2973569a7d7be" translate="yes" xml:space="preserve">
          <source>Mortal references are mainly used for xVs that are placed on perl's main stack. The stack is problematic for reference tracking, because it contains a lot of xV references, but doesn't own those references: they are not counted. Currently, there are many bugs resulting from xVs being destroyed while referenced by the stack, because the stack's uncounted references aren't enough to keep the xVs alive. So when putting an (uncounted) reference on the stack, it is vitally important to ensure that there will be a counted reference to the same xV that will last at least as long as the uncounted reference. But it's also important that that counted reference be cleaned up at an appropriate time, and not unduly prolong the xV's life. For there to be a mortal reference is often the best way to satisfy this requirement, especially if the xV was created especially to be put on the stack and would otherwise be unreferenced.</source>
          <target state="translated">필사 참조는 주로 펄의 메인 스택에 배치 된 xV에 사용됩니다. 스택은 많은 xV 참조를 포함하고 있지만 해당 참조를 소유하지 않기 때문에 참조 추적에 문제가 있습니다. 현재 스택에서 참조하는 동안 xV가 파괴되어 발생하는 많은 버그가 있습니다. 스택의 계산되지 않은 참조로는 xV를 유지하기에 충분하지 않기 때문입니다. 따라서 스택에 (계산되지 않은) 참조를 넣을 때, 계산되지 않은 참조만큼 오래 지속될 동일한 xV에 대한 계수 된 참조가 있는지 확인하는 것이 매우 중요합니다. 그러나 계산 된 참조를 적절한 시간에 정리하고 xV의 수명을 과도하게 연장하지 않는 것도 중요합니다. 필사 참조가있는 것이 종종이 요구 사항을 충족하는 가장 좋은 방법이기 때문에특히 xV가 특히 스택에 배치되도록 만들어졌고 그렇지 않으면 참조되지 않는 경우에 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="fd0ec74af25710eb89dcb326b64083f39f30db7a" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket()&lt;/a&gt;&lt;/code&gt; related calls are supported, but they may not behave as on Unix platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for the full list.</source>
          <target state="translated">대부분의 &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket()&lt;/a&gt;&lt;/code&gt; 관련 호출이 지원되지만 Unix 플랫폼에서는 작동하지 않을 수 있습니다. 전체 목록 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bd7ca1c6bc950dfa343636c44e8a991660d9872" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;Config&lt;/code&gt; variables are determined by the &lt;code&gt;Configure&lt;/code&gt; script on platforms supported by it (which is most UNIX platforms). Some platforms have custom-made &lt;code&gt;Config&lt;/code&gt; variables, and may thus not have some of the variables described below, or may have extraneous variables specific to that particular port. See the port specific documentation in such cases.</source>
          <target state="translated">대부분의 &lt;code&gt;Config&lt;/code&gt; 변수는 지원되는 플랫폼 (대부분의 UNIX 플랫폼) 에서 &lt;code&gt;Configure&lt;/code&gt; 스크립트에 의해 결정됩니다 . 일부 플랫폼에는 맞춤형 &lt;code&gt;Config&lt;/code&gt; 변수가 있으므로 아래에 설명 된 변수 중 일부가 없거나 특정 포트와 관련된 외부 변수가있을 수 있습니다. 이러한 경우 포트 별 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28f2f1dbf78786489093dd79f20f32255da8bbeb" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;socket()&lt;/code&gt; related calls are supported, but they may not behave as on Unix platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for the full list.</source>
          <target state="translated">대부분의 &lt;code&gt;socket()&lt;/code&gt; 관련 호출이 지원되지만 Unix 플랫폼 에서처럼 작동하지 않을 수 있습니다. 전체 목록 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cb850eec5c7ca91283476032e5d18060f62e376" translate="yes" xml:space="preserve">
          <source>Most OS have a maximum command length they can execute at once. Large modules can easily generate commands well past that limit. Its necessary to split long commands up into a series of shorter commands.</source>
          <target state="translated">대부분의 OS는 한 번에 실행할 수있는 최대 명령 길이를 갖습니다. 대형 모듈은 해당 한계를 훨씬 초과하는 명령을 쉽게 생성 할 수 있습니다. 긴 명령을 일련의 짧은 명령으로 분할해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9a73cc9d93ff9ac0d82b0de181da65c3c3f7d7f" translate="yes" xml:space="preserve">
          <source>Most Operating Systems record time as the number of seconds since a certain date. This date is the beginning of the epoch. Unix's starts at midnight January 1st, 1970 GMT.</source>
          <target state="translated">대부분의 운영 체제는 특정 날짜 이후의 시간 (초)으로 시간을 기록합니다. 이 날짜는 시대의 시작입니다. Unix는 GMT 1970 년 1 월 1 일 자정에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="87aec58e27c477535ee7ea89c7549f2b78b3f922" translate="yes" xml:space="preserve">
          <source>Most POSIX character classes have two Unicode-style &lt;code&gt;\p&lt;/code&gt; property counterparts. (They are not official Unicode properties, but Perl extensions derived from official Unicode properties.) The table below shows the relation between POSIX character classes and these counterparts.</source>
          <target state="translated">대부분의 POSIX 문자 클래스에는 두 개의 유니 코드 스타일 &lt;code&gt;\p&lt;/code&gt; 속성 대응 문자가 있습니다 . (공식 유니 코드 속성은 아니지만 공식 유니 코드 속성에서 파생 된 Perl 확장명입니다.) 아래 표는 POSIX 문자 클래스와 해당 항목 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="937bd5a8c80916c93da68ee3bf243ef6728b4836" translate="yes" xml:space="preserve">
          <source>Most Perl Web Frameworks will have a mechanism for doing this, using the &lt;a href=&quot;catalyst&quot;&gt;Catalyst&lt;/a&gt; framework it would be:</source>
          <target state="translated">대부분의 Perl 웹 프레임 워크에는 &lt;a href=&quot;catalyst&quot;&gt;Catalyst&lt;/a&gt; 프레임 워크를 사용하여이를 수행하는 메커니즘 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc62d968e4cf48df873bc6b26766e14aed8bb9a1" translate="yes" xml:space="preserve">
          <source>Most Perl Web Frameworks will have a mechanism for doing this, using the &lt;a href=&quot;http://search.cpan.org/perldoc/Catalyst&quot;&gt;Catalyst&lt;/a&gt; framework it would be:</source>
          <target state="translated">대부분의 Perl 웹 프레임 워크는 &lt;a href=&quot;http://search.cpan.org/perldoc/Catalyst&quot;&gt;Catalyst&lt;/a&gt; 프레임 워크를 사용하여이를 수행하는 메커니즘을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="536328dda2b64b33176fd10e64fdf2366a37e10b" translate="yes" xml:space="preserve">
          <source>Most Perl features behave in a natural way within pseudo-processes.</source>
          <target state="translated">대부분의 Perl 기능은 의사 프로세스 내에서 자연스럽게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc5eff88f8f7c24acf735b42756c6ec6877ad919" translate="yes" xml:space="preserve">
          <source>Most Perl-related projects set up mailing lists for both users and contributors. If you don't see a certain project listed at &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;, check the particular website for that project. Most mailing lists are archived at &lt;a href=&quot;http://nntp.perl.org/&quot;&gt;http://nntp.perl.org/&lt;/a&gt;.</source>
          <target state="translated">대부분의 Perl 관련 프로젝트는 사용자와 기고자 모두를위한 메일 링리스트를 설정합니다. &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org에&lt;/a&gt; 특정 프로젝트가 표시되지 않으면 해당 프로젝트의 특정 웹 사이트를 확인하십시오. 대부분의 메일 링리스트는 &lt;a href=&quot;http://nntp.perl.org/&quot;&gt;http://nntp.perl.org/에&lt;/a&gt; 보관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0a52de9bf06827eb244cce4b2303069fe873df" translate="yes" xml:space="preserve">
          <source>Most Unicode character properties have at least two synonyms (or aliases if you prefer): a short one that is easier to type and a longer one that is more descriptive and hence easier to understand. Thus the &lt;code&gt;&quot;L&quot;&lt;/code&gt; and &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; properties above are equivalent and can be used interchangeably. Likewise, &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; is a synonym for &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; , and we could have written &lt;code&gt;\p{Uppercase}&lt;/code&gt; equivalently as &lt;code&gt;\p{Upper}&lt;/code&gt; . Also, there are typically various synonyms for the values the property can be. For binary properties, &lt;code&gt;&quot;True&quot;&lt;/code&gt; has 3 synonyms: &lt;code&gt;&quot;T&quot;&lt;/code&gt; , &lt;code&gt;&quot;Yes&quot;&lt;/code&gt; , and &lt;code&gt;&quot;Y&quot;&lt;/code&gt; ; and &lt;code&gt;&quot;False&quot;&lt;/code&gt; has correspondingly &lt;code&gt;&quot;F&quot;&lt;/code&gt; , &lt;code&gt;&quot;No&quot;&lt;/code&gt; , and &lt;code&gt;&quot;N&quot;&lt;/code&gt; . But be careful. A short form of a value for one property may not mean the same thing as the same short form for another. Thus, for the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; , but for the &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidi_Class &lt;/a&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Left&quot;&lt;/code&gt; . A complete list of properties and synonyms is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">대부분의 유니 코드 문자 속성에는 두 개 이상의 동의어 (또는 원하는 경우 별칭)가 있습니다. 짧게 입력하기 쉽고 짧고 설명하기 쉽고 이해하기 쉽습니다. 따라서 위의 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 속성은 동일하며 상호 교환 적으로 사용될 수 있습니다. 마찬가지로 &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; 와 동의어이며 &lt;code&gt;\p{Uppercase}&lt;/code&gt; 는 &lt;code&gt;\p{Upper}&lt;/code&gt; 와 동일하게 작성할 수 있습니다 . 또한 일반적으로 속성의 값에 대한 다양한 동의어가 있습니다. 이진 속성의 경우 &lt;code&gt;&quot;True&quot;&lt;/code&gt; 에는 &lt;code&gt;&quot;T&quot;&lt;/code&gt; , &lt;code&gt;&quot;Yes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 의 3 개의 동의어가 있습니다.; 과 &lt;code&gt;&quot;False&quot;&lt;/code&gt; 대응이 &lt;code&gt;&quot;F&quot;&lt;/code&gt; , &lt;code&gt;&quot;No&quot;&lt;/code&gt; , 및 &lt;code&gt;&quot;N&quot;&lt;/code&gt; 를 . 그러나 조심하십시오. 한 속성에 대한 짧은 형식의 값은 다른 속성에 대한 동일한 짧은 형식과 동일한 것을 의미하지 않을 수 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 를 의미 하지만 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidi_Class&lt;/a&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Left&quot;&lt;/code&gt; 를 의미 합니다. 속성과 동의어의 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="53043f2844348d956e6cb65224a0ae9814e3772c" translate="yes" xml:space="preserve">
          <source>Most Unicode character properties have at least two synonyms (or aliases if you prefer): a short one that is easier to type and a longer one that is more descriptive and hence easier to understand. Thus the &lt;code&gt;&quot;L&quot;&lt;/code&gt; and &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; properties above are equivalent and can be used interchangeably. Likewise, &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; is a synonym for &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt;, and we could have written &lt;code&gt;\p{Uppercase}&lt;/code&gt; equivalently as &lt;code&gt;\p{Upper}&lt;/code&gt;. Also, there are typically various synonyms for the values the property can be. For binary properties, &lt;code&gt;&quot;True&quot;&lt;/code&gt; has 3 synonyms: &lt;code&gt;&quot;T&quot;&lt;/code&gt;, &lt;code&gt;&quot;Yes&quot;&lt;/code&gt;, and &lt;code&gt;&quot;Y&quot;&lt;/code&gt;; and &lt;code&gt;&quot;False&quot;&lt;/code&gt; has correspondingly &lt;code&gt;&quot;F&quot;&lt;/code&gt;, &lt;code&gt;&quot;No&quot;&lt;/code&gt;, and &lt;code&gt;&quot;N&quot;&lt;/code&gt;. But be careful. A short form of a value for one property may not mean the same thing as the short form spelled the same for another. Thus, for the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Letter&quot;&lt;/code&gt;, but for the &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;&lt;code&gt;Bidi_Class&lt;/code&gt;&lt;/a&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Left&quot;&lt;/code&gt;. A complete list of properties and synonyms is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">대부분의 유니 코드 문자 속성에는 적어도 두 개의 동의어 (또는 원하는 경우 별칭)가 있습니다. 하나는 입력하기 쉬운 짧은 것과 더 설명적이고 이해하기 쉬운 긴 것입니다. 따라서 위의 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 속성은 동일하며 서로 바꿔서 사용할 수 있습니다. 마찬가지로 &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; 의 동의어이며 &lt;code&gt;\p{Uppercase}&lt;/code&gt; 를 &lt;code&gt;\p{Upper}&lt;/code&gt; 와 동일하게 작성할 수 있습니다 . 또한 일반적으로 속성이 될 수있는 값에 대한 다양한 동의어가 있습니다. 이진 속성의 경우 &lt;code&gt;&quot;True&quot;&lt;/code&gt; 에는 &lt;code&gt;&quot;T&quot;&lt;/code&gt; , &lt;code&gt;&quot;Yes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 라는 3 개의 동의어가 있습니다.; 및 &lt;code&gt;&quot;False&quot;&lt;/code&gt; 이에 대응하여 &lt;code&gt;&quot;F&quot;&lt;/code&gt; , &lt;code&gt;&quot;No&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;N&quot;&lt;/code&gt; 이 있습니다. 하지만 조심하세요. 한 속성에 대한 짧은 형식의 값은 다른 속성에 대해 동일한 철자가 동일한 것을 의미하지 않을 수 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 를 의미 하지만 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt; &lt;code&gt;Bidi_Class&lt;/code&gt; &lt;/a&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Left&quot;&lt;/code&gt; 를 의미 합니다. 속성 및 동의어의 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33601ec8592d8b99971745f555ad60f8af01ae0" translate="yes" xml:space="preserve">
          <source>Most Unicode properties have several synonymous names. Typically, there is at least a short name, convenient to type, and a long name that more fully describes the property, and hence is more easily understood.</source>
          <target state="translated">대부분의 유니 코드 속성에는 여러 동의어 이름이 있습니다. 일반적으로 속성을보다 완전하게 설명하는 짧은 이름, 입력하기 편리한 이름 및 긴 이름이 있으므로 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c27a5f71254b1b3c6a849e7bef1eacb3f778bdb9" translate="yes" xml:space="preserve">
          <source>Most algorithms are only defined for strings of bytes and this method might therefore croak if the provided arguments contain chars with ordinal number above 255.</source>
          <target state="translated">대부분의 알고리즘은 바이트 문자열에 대해서만 정의되므로 제공된 인수에 서 수가 255보다 큰 문자가 포함 된 경우이 메소드가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437ac38b2b73f7517fd2a5637f9c4e0ca58f6e94" translate="yes" xml:space="preserve">
          <source>Most behaviour, including environment variables and configuration, comes directly from CPAN.pm.</source>
          <target state="translated">환경 변수 및 구성을 포함한 대부분의 동작은 CPAN.pm에서 직접 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="283ae0258fda6ce570af6540f2c58627624b3cdb" translate="yes" xml:space="preserve">
          <source>Most callers of &lt;code&gt;cx_pushblock&lt;/code&gt; simply set the new args stack floor to the top of the previous stack frame, but for &lt;code&gt;CXt_LOOP_LIST&lt;/code&gt; it stores the items being iterated over on the stack, and so sets &lt;code&gt;blk_oldsp&lt;/code&gt; to the top of these items instead. Note that, contrary to its name, &lt;code&gt;blk_oldsp&lt;/code&gt; doesn't always represent the value to restore &lt;code&gt;PL_stack_sp&lt;/code&gt; to on scope exit.</source>
          <target state="translated">&lt;code&gt;cx_pushblock&lt;/code&gt; 의 대부분의 호출자는 단순히 새 args 스택 바닥을 이전 스택 프레임의 맨 위에 설정하지만 &lt;code&gt;CXt_LOOP_LIST&lt;/code&gt; 의 경우 반복되는 항목을 스택에 저장하므로 대신 &lt;code&gt;blk_oldsp&lt;/code&gt; 를 이러한 항목의 맨 위에 설정 합니다. 이름과 달리 &lt;code&gt;blk_oldsp&lt;/code&gt; 는 범위 &lt;code&gt;PL_stack_sp&lt;/code&gt; 를 복원하는 값을 항상 나타내는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b83511857d278656d99d572ed9af8349be0ed8d8" translate="yes" xml:space="preserve">
          <source>Most characters that are meta characters in regular expressions (that is, characters that carry a special meaning like &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , or &lt;code&gt;(&lt;/code&gt;) lose their special meaning and can be used inside a character class without the need to escape them. For instance, &lt;code&gt;[()]&lt;/code&gt; matches either an opening parenthesis, or a closing parenthesis, and the parens inside the character class don't group or capture.</source>
          <target state="translated">이다 정규 표현식에서 메타 문자 (대부분의 문자와 같은 특별한 의미를 가지고 문자 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , 또는 &lt;code&gt;(&lt;/code&gt; ) 자신의 특별한 의미를 잃고 그들을 탈출 할 필요없이 문자 클래스 내에서 사용될 수있다. 예를 들어, &lt;code&gt;[()]&lt;/code&gt; 는 여는 괄호 또는 닫는 괄호와 일치하며 문자 클래스 내부의 Parens는 그룹화하거나 캡처하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="662368a274868c093a1187793ee53785736a4eef" translate="yes" xml:space="preserve">
          <source>Most characters that are meta characters in regular expressions (that is, characters that carry a special meaning like &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;(&lt;/code&gt;) lose their special meaning and can be used inside a character class without the need to escape them. For instance, &lt;code&gt;[()]&lt;/code&gt; matches either an opening parenthesis, or a closing parenthesis, and the parens inside the character class don't group or capture. Be aware that, unless the pattern is evaluated in single-quotish context, variable interpolation will take place before the bracketed class is parsed:</source>
          <target state="translated">정규식에서 메타 문자 인 대부분의 문자 (즉, &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;(&lt;/code&gt; ) 와 같은 특수한 의미를 갖는 문자는 특수한 의미를 잃고 이스케이프 할 필요없이 문자 클래스 내에서 사용할 수 있습니다. 예를 들어, &lt;code&gt;[()]&lt;/code&gt; 는 여는 괄호 또는 닫는 괄호와 일치하며 문자 클래스 내부의 괄호는 그룹화하거나 캡처하지 않습니다. 패턴이 작은 따옴표 컨텍스트로 평가되지 않는 한 변수 보간은 괄호로 묶인 클래스가 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="a75f1bf80c368f3dc4a94d23cd008a9dbf44eec2" translate="yes" xml:space="preserve">
          <source>Most code should use &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;()&lt;/code&gt; rather than call this directly.</source>
          <target state="translated">대부분의 코드는 이것을 직접 호출하는 대신 &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;()&lt;/code&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0df73814a9b3dab0955308c1ef467807cec3d266" translate="yes" xml:space="preserve">
          <source>Most compiler backends use the following conventions: OPTIONS consists of a comma-separated list of words (no white-space). The &lt;code&gt;-v&lt;/code&gt; option usually puts the backend into verbose mode. The &lt;code&gt;-ofile&lt;/code&gt; option generates output to &lt;b&gt;file&lt;/b&gt; instead of stdout. The &lt;code&gt;-D&lt;/code&gt; option followed by various letters turns on various internal debugging flags. See the documentation for the desired backend (named &lt;code&gt;B::Backend&lt;/code&gt; for the example above) to find out about that backend.</source>
          <target state="translated">대부분의 컴파일러 백엔드는 다음 규칙을 사용합니다. OPTIONS는 쉼표로 구분 된 단어 목록 (공백 없음)으로 구성됩니다. &lt;code&gt;-v&lt;/code&gt; 옵션은 일반적으로 상세 모드로 백엔드를 넣습니다. &lt;code&gt;-ofile&lt;/code&gt; 옵션은 출력을 생성하는 &lt;b&gt;파일&lt;/b&gt; 대신에 표준 출력. &lt;code&gt;-D&lt;/code&gt; 옵션은 다양한 내부 디버깅 플래그에 다양한 문자 회전 하였다. 해당 백엔드에 대한 정보는 원하는 백엔드 설명서 ( 위 예제의 경우 &lt;code&gt;B::Backend&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ceb62989a1effad36bd037ec531f4c70cb866db" translate="yes" xml:space="preserve">
          <source>Most digest algorithms are byte based and for these it is not possible to add bits that are not a multiple of 8, and the add_bits() method will croak if you try.</source>
          <target state="translated">대부분의 다이제스트 알고리즘은 바이트 기반이므로 8의 배수가 아닌 비트를 추가 할 수 없으며 시도하면 add_bits () 메소드가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e0432f156912c28405beeb7541e8a07073675c" translate="yes" xml:space="preserve">
          <source>Most extensions (whether they require a C compiler or not) can be built, tested and installed with the standard mantra:</source>
          <target state="translated">대부분의 확장 (C 컴파일러가 필요한지 여부에 관계없이)은 표준 형식으로 빌드, 테스트 및 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c36d3b16152dc2e4c3eb43bb1840617dcd58c24" translate="yes" xml:space="preserve">
          <source>Most frequently called functions</source>
          <target state="translated">가장 자주 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="e2f7deae35b5b32265a212cc23f97fad9e01f8ca" translate="yes" xml:space="preserve">
          <source>Most functions in package CPAN are exported by default. The reason for this is that the primary use is intended for the cpan shell or for one-liners.</source>
          <target state="translated">CPAN 패키지의 대부분의 기능은 기본적으로 내보내집니다. 그 이유는 주요 용도가 cpan 쉘 또는 1 개의 라이너를위한 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7d52830eddc7f522e9b94c8937811fe2f95508ad" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; take an integer and will silently truncate decimal numbers. This means &lt;code&gt;srand(42)&lt;/code&gt; will usually produce the same results as &lt;code&gt;srand(42.1)&lt;/code&gt;. To be safe, always pass &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; an integer.</source>
          <target state="translated">대부분의 &lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt; 구현은 정수를 취하며 10 진수를 자동으로 자릅니다. 즉, &lt;code&gt;srand(42)&lt;/code&gt; 는 일반적으로 &lt;code&gt;srand(42.1)&lt;/code&gt; 과 동일한 결과를 생성합니다 . 안전하려면 항상 &lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt; 에 정수를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5781421ac333dfdfd58bada47c5083697a175449" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; take an integer and will silently truncate decimal numbers. This means &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; will usually produce the same results as &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt;. To be safe, always pass &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; an integer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 의 대부분의 구현은 정수를 사용하며 10 진수를 자동으로 자릅니다. 이는 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; 가 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt; 과 동일한 결과를 생성 함을 의미 합니다. 안전을 위해 항상 정수에 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="405bded6ca944a37e6c3b479ff1de785ad3f9801" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; take an integer and will silently truncate decimal numbers. This means &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; will usually produce the same results as &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt;. To be safe, always pass &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; an integer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 의 대부분의 구현은 정수를 사용하며 10 진수를 자동으로 자릅니다. 이는 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; 가 일반적으로 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt; 과 동일한 결과를 생성 함을 의미 합니다. 안전을 위해 항상 정수에 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d6b5dfca3c0039899dcb7cae60483d04f370ee8" translate="yes" xml:space="preserve">
          <source>Most importantly, CPAN includes around a thousand unbundled modules, some of which require a C compiler to build. Major categories of modules are:</source>
          <target state="translated">가장 중요한 것은 CPAN에는 번들로 제공되지 않는 약 1,000 개의 모듈이 포함되어 있으며,이 중 일부는 C 컴파일러가 필요합니다. 주요 모듈 범주는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acf589d2649f04394cc8c6cda103470ec97cfc12" translate="yes" xml:space="preserve">
          <source>Most importantly, choose modules which are as stable as possible. In order of preference:</source>
          <target state="translated">가장 중요한 것은 가능한 한 안정적인 모듈을 선택하십시오. 선호도 순서대로 :</target>
        </trans-unit>
        <trans-unit id="2a11d2785522a93f5420fa16470f086a6da1b3ea" translate="yes" xml:space="preserve">
          <source>Most mentioned distributions are depots. H.Merijn Brand has made prebuilt gcc binaries available on &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt; and/or &lt;a href=&quot;http://www.cmve.net/~merijn/&quot;&gt;http://www.cmve.net/~merijn/&lt;/a&gt; for HP-UX 10.20 (only 32bit), HP-UX 11.00, HP-UX 11.11 (HP-UX 11i v1), and HP-UX 11.23 (HP-UX 11i v2 PA-RISC) in both 32- and 64-bit versions. For HP-UX 11.23 IPF and HP-UX 11.31 IPF depots are available too. The IPF versions do not need two versions of GNU gcc.</source>
          <target state="translated">가장 많이 언급 된 배포판은 저장소입니다. H.Merijn Brand는 HP-UX 10.20 (32 비트 전용), HP의 경우 &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt; 및 / 또는 &lt;a href=&quot;http://www.cmve.net/~merijn/&quot;&gt;http://www.cmve.net/~merijn/&lt;/a&gt; 에서 사전 빌드 된 gcc 바이너리를 제공합니다 . 32 비트 및 64 비트 버전의 -UX 11.00, HP-UX 11.11 (HP-UX 11i v1) 및 HP-UX 11.23 (HP-UX 11i v2 PA-RISC). HP-UX 11.23 IPF 및 HP-UX 11.31 IPF 저장소도 사용할 수 있습니다. IPF 버전에는 두 가지 버전의 GNU gcc가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="236aab386cc9ca4c5e8adffaa67e969c764a4805" translate="yes" xml:space="preserve">
          <source>Most methods you write will expect to operate on objects:</source>
          <target state="translated">작성하는 대부분의 방법은 객체에서 작동 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="e42995ec64ef087af8c046e70f5daf6eb0079f02" translate="yes" xml:space="preserve">
          <source>Most modern X terminal emulators support 256 colors. Known to not support those colors are aterm, rxvt, Terminal.app, and TTY/VC.</source>
          <target state="translated">대부분의 최신 X 터미널 에뮬레이터는 256 색을 지원합니다. 해당 색상을 지원하지 않는 것으로 알려진 것은 aterm, rxvt, Terminal.app 및 TTY / VC입니다.</target>
        </trans-unit>
        <trans-unit id="09fdc7d65b76d3e363653e14537a18e5aea28f56" translate="yes" xml:space="preserve">
          <source>Most modern operating systems support preemptive multitasking nowadays.</source>
          <target state="translated">오늘날 대부분의 최신 운영 체제는 선점 형 멀티 태스킹을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1d45edd059b4e41b42c3589d6e9743f7467d5f99" translate="yes" xml:space="preserve">
          <source>Most modifiers, such as &lt;code&gt;//i&lt;/code&gt; , &lt;code&gt;//m&lt;/code&gt; , &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//x&lt;/code&gt; (or any combination thereof) can also be embedded in a regexp using &lt;code&gt;(?i)&lt;/code&gt;, &lt;code&gt;(?m)&lt;/code&gt;, &lt;code&gt;(?s)&lt;/code&gt;, and &lt;code&gt;(?x)&lt;/code&gt;. For instance,</source>
          <target state="translated">&lt;code&gt;//i&lt;/code&gt; , &lt;code&gt;//m&lt;/code&gt; , &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//x&lt;/code&gt; (또는 이들의 조합) 와 같은 대부분의 수정자는 &lt;code&gt;(?i)&lt;/code&gt; , &lt;code&gt;(?m)&lt;/code&gt; , &lt;code&gt;(?s)&lt;/code&gt; 및 &lt;code&gt;(?x)&lt;/code&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="72e8bb708217ae322b446e074e5a34e7c96fe06c" translate="yes" xml:space="preserve">
          <source>Most modifiers, such as &lt;code&gt;/i&lt;/code&gt;, &lt;code&gt;/m&lt;/code&gt;, &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/x&lt;/code&gt; (or any combination thereof) can also be embedded in a regexp using &lt;code&gt;(?i)&lt;/code&gt;, &lt;code&gt;(?m)&lt;/code&gt;, &lt;code&gt;(?s)&lt;/code&gt;, and &lt;code&gt;(?x)&lt;/code&gt;. For instance,</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; , &lt;code&gt;/m&lt;/code&gt; , &lt;code&gt;/s&lt;/code&gt; 및 &lt;code&gt;/x&lt;/code&gt; (또는 이들의 조합) 와 같은 대부분의 수정자는 &lt;code&gt;(?i)&lt;/code&gt; , &lt;code&gt;(?m)&lt;/code&gt; , &lt;code&gt;(?s)&lt;/code&gt; 및 &lt;code&gt;(?x)&lt;/code&gt; 사용하여 정규 표현식에 포함 할 수도 있습니다. . 예를 들어</target>
        </trans-unit>
        <trans-unit id="7aac5f91bfd266adf35f3c08ec6bb8cde72e4223" translate="yes" xml:space="preserve">
          <source>Most multi-user platforms provide basic levels of security, usually implemented at the filesystem level. Some, however, unfortunately do not. Thus the notion of user id, or &quot;home&quot; directory, or even the state of being logged-in, may be unrecognizable on many platforms. If you write programs that are security-conscious, it is usually best to know what type of system you will be running under so that you can write code explicitly for that platform (or class of platforms).</source>
          <target state="translated">대부분의 다중 사용자 플랫폼은 일반적으로 파일 시스템 수준에서 구현되는 기본 수준의 보안을 제공합니다. 그러나 불행히도 일부는 그렇지 않습니다. 따라서 많은 플랫폼에서 사용자 ID 또는 &quot;홈&quot;디렉토리 또는 로그인 상태 개념을 인식하지 못할 수 있습니다. 보안을 염두에 둔 프로그램을 작성하는 경우, 해당 플랫폼 (또는 플랫폼 클래스)에 대해 명시 적으로 코드를 작성할 수 있도록 어떤 유형의 시스템을 실행할 것인지를 아는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4f6011591757af844f16df1e5c9352c7848a6ec4" translate="yes" xml:space="preserve">
          <source>Most non-EBCDIC character sets are supersets of ASCII. That is the integers 0-127 mean what ASCII says they mean. But integers 128 and above are specific to the character set.</source>
          <target state="translated">대부분의 비 EBCDIC 문자 세트는 ASCII의 상위 세트입니다. 즉, 정수 0-127은 ASCII가 의미하는 바를 의미합니다. 그러나 정수 128 이상은 문자 집합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="51ca37247d6a69603fb3b1446157e03d96bfa6df" translate="yes" xml:space="preserve">
          <source>Most notable problems:</source>
          <target state="translated">가장 주목할만한 문제 :</target>
        </trans-unit>
        <trans-unit id="f57027e07ab6e59e959c6b528e3378204e633471" translate="yes" xml:space="preserve">
          <source>Most object systems share a number of common concepts. You've probably heard terms like &quot;class&quot;, &quot;object, &quot;method&quot;, and &quot;attribute&quot; before. Understanding the concepts will make it much easier to read and write object-oriented code. If you're already familiar with these terms, you should still skim this section, since it explains each concept in terms of Perl's OO implementation.</source>
          <target state="translated">대부분의 객체 시스템은 많은 공통 개념을 공유합니다. &quot;클래스&quot;, &quot;객체,&quot;방법 &quot;및&quot;속성 &quot;과 같은 용어를 들어 보셨을 것입니다. 개념을 이해하면 객체 지향 코드를 읽고 쓰는 것이 훨씬 쉬워집니다. 이 섹션은 Perl의 OO 구현 측면에서 각 개념을 설명하기 때문에 여전히이 섹션을 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe5befa620ff0477f0ac6ba4b4534580f30f2e1e" translate="yes" xml:space="preserve">
          <source>Most obviously, there is the necessity of retrieving the reference address of an object for each data access. It's a minor inconvenience, but it does clutter the code.</source>
          <target state="translated">가장 분명하게는, 각 데이터 액세스에 대해 객체의 참조 주소를 검색해야 할 필요가 있습니다. 사소한 불편이지만 코드가 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="8966ee4f610a8f12b38c297e5e0e0d5c4c1631d5" translate="yes" xml:space="preserve">
          <source>Most of Params::Check's power comes from its template, which we'll discuss below:</source>
          <target state="translated">Params :: Check의 대부분은 템플릿에서 나옵니다. 아래에서 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a5d752e99b47aeed7fefeb002f25a1df93361a60" translate="yes" xml:space="preserve">
          <source>Most of the &lt;code&gt;canonical names&lt;/code&gt; in Encode derive from this list so you can directly apply the string you have extracted from MIME header of mails and web pages.</source>
          <target state="translated">Encode 의 대부분의 &lt;code&gt;canonical names&lt;/code&gt; 은이 목록에서 파생되므로 메일 및 웹 페이지의 MIME 헤더에서 추출한 문자열을 직접 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2e899784ab7672ad3b74081e22274bde79fba73" translate="yes" xml:space="preserve">
          <source>Most of the code here was lifted straight from Test::Builder and then had chunks removed by Fergal Daly &amp;lt;fergal@esatclear.ie&amp;gt;.</source>
          <target state="translated">여기에있는 대부분의 코드는 Test :: Builder에서 바로 가져온 다음 Fergal Daly &amp;lt;fergal@esatclear.ie&amp;gt;에 의해 청크가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c05844436a81cb2d0dbddab3388c8acb9552fbf" translate="yes" xml:space="preserve">
          <source>Most of the code here was written by Randy W. Sims &amp;lt;RandyS@ThePierianSpring.org&amp;gt;.</source>
          <target state="translated">이 코드의 대부분은 Randy W. Sims &amp;lt;RandyS@ThePierianSpring.org&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="47b295d947239a228d57f7cff4fa724418821ca3" translate="yes" xml:space="preserve">
          <source>Most of the complete Perl resides in the shareable image</source>
          <target state="translated">완전한 Perl의 대부분은 공유 가능한 이미지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e836cc0136a0b6a1e328a42911e15475ce7f8a0" translate="yes" xml:space="preserve">
          <source>Most of the complexity of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function lies in the many possible values that the</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수 의 복잡성 대부분은 가능한 많은 값에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8c86ea6cb467b77003f8f36467638e3bb201553" translate="yes" xml:space="preserve">
          <source>Most of the complexity of the &lt;code&gt;open&lt;/code&gt; function lies in the many possible values that the</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 함수 의 복잡성의 대부분은</target>
        </trans-unit>
        <trans-unit id="2242570cf48131ca1026e727ff73cf14992345d6" translate="yes" xml:space="preserve">
          <source>Most of the documentation is taken from JSON::XS by Marc Lehmann</source>
          <target state="translated">대부분의 문서는 Marc Lehmann의 JSON :: XS에서 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="4a21567ca84f5f746c9675299dce59640ed18c1d" translate="yes" xml:space="preserve">
          <source>Most of the keywords are self-explanatory.</source>
          <target state="translated">대부분의 키워드는 자명하다.</target>
        </trans-unit>
        <trans-unit id="baa8cd3bbb4c6980245c7cf3aa023db27c3acdb3" translate="yes" xml:space="preserve">
          <source>Most of the libgdbm.a functions are available through the GDBM_File interface.</source>
          <target state="translated">대부분의 libgdbm.a 함수는 GDBM_File 인터페이스를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25843b853d505c1784c9a338be9b1a848cd1212" translate="yes" xml:space="preserve">
          <source>Most of the libnet client classes allow options to be passed to the constructor, in most cases one option is called &lt;code&gt;Debug&lt;/code&gt;. Passing this option with a non-zero value will turn on a protocol trace, which will be sent to STDERR. This trace can be useful to see what commands are being sent to the remote server and what responses are being received back.</source>
          <target state="translated">대부분의 libnet 클라이언트 클래스는 옵션이 생성자에 전달되도록 허용하며, 대부분의 경우 하나의 옵션은 &lt;code&gt;Debug&lt;/code&gt; 입니다. 이 옵션을 0이 아닌 값으로 전달하면 프로토콜 추적이 켜지고 STDERR로 전송됩니다. 이 추적은 원격 서버로 전송되는 명령과 수신되는 응답을 확인하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31689cece88e6009d6abbf1122159fef235d148d" translate="yes" xml:space="preserve">
          <source>Most of the metacharacters aren't always special, and other characters (such as the ones delimitting the pattern) become special under various circumstances. This can be confusing and lead to unexpected results. &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt; can notify you of potential pitfalls.</source>
          <target state="translated">대부분의 메타 문자는 항상 특별한 것은 아니며 다른 문자 (예 : 패턴을 구분하는 문자)는 다양한 상황에서 특별 해집니다. 이것은 혼란스럽고 예상치 못한 결과를 초래할 수 있습니다. &lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict'&lt;/code&gt; &lt;/a&gt; 는 잠재적 인 함정을 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e872c4c8b4e46b1a126dccfdf045e22c43bfe9" translate="yes" xml:space="preserve">
          <source>Most of the other Opcode functions call verify_opset automatically and will croak if given an invalid opset.</source>
          <target state="translated">다른 Opcode 함수의 대부분은 verify_opset을 자동으로 호출하며 유효하지 않은 opset이 제공되면 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="7be58e4167c6f6d21daa45117bbd585a46416c25" translate="yes" xml:space="preserve">
          <source>Most of the overloadable operators map one-to-one to these keys. Exceptions, including additional overloadable operations not apparent from this hash, are included in the notes which follow. This list is subject to growth over time.</source>
          <target state="translated">오버로드 가능한 대부분의 연산자는 이러한 키에 일대일로 매핑됩니다. 이 해시에서 명백하지 않은 추가 과부하 작업을 포함한 예외는 다음 참고에 포함되어 있습니다. 이 목록은 시간이 지남에 따라 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cede88fd0fdf454c10d7b4cebb77c726e122f53" translate="yes" xml:space="preserve">
          <source>Most of the power comes from the implicit smartmatching that can sometimes apply. Most of the time, &lt;code&gt;when(EXPR)&lt;/code&gt; is treated as an implicit smartmatch of &lt;code&gt;$_&lt;/code&gt; , that is, &lt;code&gt;$_ ~~ EXPR&lt;/code&gt; . (See &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; for more information on smartmatching.) But when</source>
          <target state="translated">대부분의 힘은 때때로 적용 할 수있는 암시 적 스마트 매칭에서 비롯됩니다. 대부분의 경우, &lt;code&gt;when(EXPR)&lt;/code&gt; 은 &lt;code&gt;$_&lt;/code&gt; 의 암시 적 스마트 매치 , 즉 &lt;code&gt;$_ ~~ EXPR&lt;/code&gt; 됩니다. &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;스마트&lt;/a&gt; 매칭에 대한 자세한 내용 은 perlop의 Smartmatch Operator를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60478a66b6d520d807ea697e7540d94eb0418ec5" translate="yes" xml:space="preserve">
          <source>Most of the power comes from the implicit smartmatching that can sometimes apply. Most of the time, &lt;code&gt;when(EXPR)&lt;/code&gt; is treated as an implicit smartmatch of &lt;code&gt;$_&lt;/code&gt;, that is, &lt;code&gt;$_ ~~ EXPR&lt;/code&gt;. (See &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; for more information on smartmatching.) But when</source>
          <target state="translated">대부분의 힘은 때때로 적용될 수있는 암시 적 스마트 매칭에서 비롯됩니다. 대부분의 &lt;code&gt;when(EXPR)&lt;/code&gt; 은 &lt;code&gt;$_&lt;/code&gt; 의 암시 적 스마트 매치 , 즉 &lt;code&gt;$_ ~~ EXPR&lt;/code&gt; 됩니다. ( &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;스마트&lt;/a&gt; 매칭에 대한 자세한 내용 은 perlop의 &quot;Smartmatch Operator&quot;를 참조하십시오 .) 그러나 언제</target>
        </trans-unit>
        <trans-unit id="00a01cac94bf76dedfa60add1a18fb4b2e641b31" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 15924 four-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 15924 4 자리 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e2964ea3d337ce474ce4e845493df4592e50a50" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 3166-1 two-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 3166-1 2 문자 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c51fe921a01a7d85e172a82dee63cf013d880282" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 4217 three-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 4217 3 자리 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad65d964877735755761a49062026c5cbfd01a4c" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 639 two-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 639 2 문자 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ecfd9a8718bf7f9a8bea5531a84bc0b93eebafb4" translate="yes" xml:space="preserve">
          <source>Most of the special variables related to regular expressions are side effects. Perl sets these variables when it has a successful match, so you should check the match result before using them. For instance:</source>
          <target state="translated">정규식과 관련된 대부분의 특수 변수는 부작용입니다. Perl은 성공적으로 일치 할 때 이러한 변수를 설정하므로 사용하기 전에 일치 결과를 확인해야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="dd8324ae92ad5052d02cf97e850674cb89e9ea59" translate="yes" xml:space="preserve">
          <source>Most of the time the &lt;code&gt;POP*&lt;/code&gt; macros should be adequate; the main problem with them is that they force you to process the returned values in sequence. This may not be the most suitable way to process the values in some cases. What we want is to be able to access the stack in a random order. The &lt;code&gt;ST&lt;/code&gt; macro as used when coding an XSUB is ideal for this purpose.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;POP*&lt;/code&gt; 매크로가 적합해야합니다. 그것들의 주요 문제는 반환 된 값을 순서대로 처리해야한다는 것입니다. 경우에 따라 값을 처리하기에 가장 적합한 방법이 아닐 수도 있습니다. 우리가 원하는 것은 무작위 순서로 스택에 액세스 할 수있는 것입니다. &lt;code&gt;ST&lt;/code&gt; 의 XSUB 부호화 할 때 사용되는 바와 같이, 매크로는이 목적에 적합하다.</target>
        </trans-unit>
        <trans-unit id="2df244eb4bef5a0bc68e79be4405c972c5f0e791" translate="yes" xml:space="preserve">
          <source>Most of the time you should not need to do this as your web framework, or if you are making a request, the &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; or other module would handle it for you.</source>
          <target state="translated">대부분의 경우 웹 프레임 워크로이 작업을 수행 할 필요가 없거나 요청하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; 또는 기타 모듈이이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="48c7e054216d49d1fb2b20eca1334fe1da06b743" translate="yes" xml:space="preserve">
          <source>Most of the time you should not need to do this as your web framework, or if you are making a request, the &lt;a href=&quot;lwp&quot;&gt;LWP&lt;/a&gt; or other module would handle it for you.</source>
          <target state="translated">대부분의 경우 웹 프레임 워크로이 작업을 수행 할 필요가 없으며 요청을하는 경우 &lt;a href=&quot;lwp&quot;&gt;LWP&lt;/a&gt; 또는 기타 모듈이이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2c4ac7b91ccda75dc1e9e26906f34a6b74bf2fc1" translate="yes" xml:space="preserve">
          <source>Most of the time, &lt;code&gt;die&lt;/code&gt; is called with a string to use as the exception. You may either give a single non-reference operand to serve as the exception, or a list of two or more items, which will be stringified and concatenated to make the exception.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;die&lt;/code&gt; 는 예외로 사용할 문자열로 호출됩니다. 예외로 사용할 단일 비 참조 피연산자 또는 두 개 이상의 항목 목록을 제공 할 수 있습니다.이 목록은 예외를 만들기 위해 문자열 화되고 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="7e6eb8148850007d8fa7e26443b2a04c22c7a11f" translate="yes" xml:space="preserve">
          <source>Most of the time, all this moving forward and backtracking happens quickly and searching is fast. There are some pathological regexps, however, whose execution time exponentially grows with the size of the string. A typical structure that blows up in your face is of the form</source>
          <target state="translated">대부분의 경우,이 모든 앞뒤 추적은 빠르게 수행되며 검색이 빠릅니다. 그러나 문자열의 크기에 따라 실행 시간이 기하 급수적으로 증가하는 병리학 적 정규 표현식이 있습니다. 당신의 얼굴에 날리는 전형적인 구조는</target>
        </trans-unit>
        <trans-unit id="e77fec64b4c635ea20e1b59e3b7d5f77ce28d8e0" translate="yes" xml:space="preserve">
          <source>Most of the time, output from the C routine can be handled through use of the RETVAL and OUTPUT directives. However, there are some cases where the argument stack is not already long enough to handle all the return values. An example is the POSIX tzname() call, which takes no arguments, but returns two, the local time zone's standard and summer time abbreviations.</source>
          <target state="translated">대부분의 경우 C 루틴의 출력은 RETVAL 및 OUTPUT 지시문을 사용하여 처리 할 수 ​​있습니다. 그러나 인수 스택이 이미 모든 반환 값을 처리하기에 충분히 길지 않은 경우가 있습니다. 예를 들어 POSIX tzname () 호출은 인수를 사용하지 않지만 현지 표준 시간대 및 서머 타임 약어 인 두 개를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cf605ff0085f7cdb0263cf668764df45a3b6647" translate="yes" xml:space="preserve">
          <source>Most of the time, the default behavior is what is wanted, but &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; are occasionally very useful. If &lt;code&gt;//m&lt;/code&gt; is being used, the start of the string can still be matched with &lt;code&gt;\A&lt;/code&gt; and the end of the string can still be matched with the anchors &lt;code&gt;\Z&lt;/code&gt; (matches both the end and the newline before, like &lt;code&gt;$&lt;/code&gt; ), and &lt;code&gt;\z&lt;/code&gt; (matches only the end):</source>
          <target state="translated">대부분의 경우 기본 동작은 원하는 것이지만 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 은 매우 유용합니다. 경우 &lt;code&gt;//m&lt;/code&gt; 을 사용하고, 문자열의 시작은 여전히 일치 될 수있다 &lt;code&gt;\A&lt;/code&gt; 와 문자열의 끝은 여전히 앵커와 일치 할 수있다 &lt;code&gt;\Z&lt;/code&gt; (경기 끝에 모두와 같은 전에 줄 바꿈, &lt;code&gt;$&lt;/code&gt; ), 및 &lt;code&gt;\z&lt;/code&gt; (끝과 만 일치) :</target>
        </trans-unit>
        <trans-unit id="89315b4d91e89302d070cbd7a7e6cdb9cab0b050" translate="yes" xml:space="preserve">
          <source>Most of the time, the default behavior is what is wanted, but &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; are occasionally very useful. If &lt;code&gt;/m&lt;/code&gt; is being used, the start of the string can still be matched with &lt;code&gt;\A&lt;/code&gt; and the end of the string can still be matched with the anchors &lt;code&gt;\Z&lt;/code&gt; (matches both the end and the newline before, like &lt;code&gt;'$'&lt;/code&gt;), and &lt;code&gt;\z&lt;/code&gt; (matches only the end):</source>
          <target state="translated">대부분의 경우 기본 동작은 원하는 동작이지만 &lt;code&gt;/s&lt;/code&gt; 및 &lt;code&gt;/m&lt;/code&gt; 은 때때로 매우 유용합니다. 경우 &lt;code&gt;/m&lt;/code&gt; 을 사용하고, 문자열의 시작은 여전히 일치 될 수있다 &lt;code&gt;\A&lt;/code&gt; 와 문자열의 끝이 여전히 앵커와 일치 할 수있다 &lt;code&gt;\Z&lt;/code&gt; (경기 끝과 줄 바꿈 전과 같은 &lt;code&gt;'$'&lt;/code&gt; 를 ) 및 &lt;code&gt;\z&lt;/code&gt; (끝만 일치) :</target>
        </trans-unit>
        <trans-unit id="12fd6c425f6aad23df3156037ea683dfee498467" translate="yes" xml:space="preserve">
          <source>Most of the time, the longest possible text that does not include spaces between components and which contains matching braces or brackets. because the outcome may be determined by voting based on heuristic estimators, the result is not strictly predictable. Fortunately, it's usually correct for ambiguous cases.</source>
          <target state="translated">대부분의 경우 구성 요소 사이에 공백이없고 일치하는 중괄호 또는 대괄호가 포함 된 가장 긴 텍스트입니다. 휴리스틱 추정기를 기반으로 한 투표로 결과를 결정할 수 있기 때문에 결과를 엄격하게 예측할 수있는 것은 아닙니다. 다행히도 모호한 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b3fb5476790113a0dea04a1d528889b51b315f83" translate="yes" xml:space="preserve">
          <source>Most of the time, this warning occurs when a byte-string is concatenated with a unicode-string. There are a number of ways to solve it:</source>
          <target state="translated">대부분의 경우이 경고는 바이트 문자열이 유니 코드 문자열과 연결될 때 발생합니다. 이를 해결하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="faff5fae267b68e66a542eebf06c3a2fb20f6315" translate="yes" xml:space="preserve">
          <source>Most of the time, though, you'll want to be dealing with SVs internally instead of raw &lt;code&gt;char *&lt;/code&gt; strings:</source>
          <target state="translated">그러나 대부분의 경우 원시 &lt;code&gt;char *&lt;/code&gt; 문자열 대신 내부적으로 SV를 처리하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="e3da35f6fb8f67dff58b56670aaa5e754c6ece5e" translate="yes" xml:space="preserve">
          <source>Most of the time, you shouldn't care what package an object is blessed into, however, as long as it claims to inherit from that class:</source>
          <target state="translated">대부분의 경우 객체가 클래스에서 상속되었다고 주장하는 한 객체가 어떤 패키지에 축복되는지는 신경 쓰지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="70ed3f1e9ec3872fc596a127d78b3433084d76ac" translate="yes" xml:space="preserve">
          <source>Most of the time, you will need only a single set of angle brackets to delimit the beginning and end of formatting codes. However, sometimes you will want to put a real right angle bracket (a greater-than sign, '&amp;gt;') inside of a formatting code. This is particularly common when using a formatting code to provide a different font-type for a snippet of code. As with all things in Perl, there is more than one way to do it. One way is to simply escape the closing bracket using an &lt;code&gt;E&lt;/code&gt; code:</source>
          <target state="translated">대부분의 경우 서식 코드의 시작과 끝을 구분하기 위해 단일 꺾쇠 괄호 세트 만 있으면됩니다. 그러나 때로는 형식 코드 안에 실제 직각 괄호 ( '&amp;gt;'보다 큰 부호)를 넣고 싶을 수도 있습니다. 서식 코드를 사용하여 코드 스 니펫에 다른 글꼴 유형을 제공 할 때 특히 일반적입니다. Perl의 모든 작업과 마찬가지로 여러 가지 방법이 있습니다. 한 가지 방법은 &lt;code&gt;E&lt;/code&gt; 코드를 사용하여 닫는 대괄호를 간단히 이스케이프 처리하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c0c2da0623840fbe23f26b030382d27c35d7bca2" translate="yes" xml:space="preserve">
          <source>Most of the work involved in both rounding up a suitable set of candidate commits and cherry-picking those for which three votes have been cast will be done by the maint branch release manager, but anyone else is free to add other proposals if they're keen to ensure certain fixes don't get overlooked or fear they already have been.</source>
          <target state="translated">적합한 후보 커밋 세트를 반올림하고 3 표를받은 체리 픽킹에 관련된 대부분의 작업은 메인 트 브랜치 릴리스 관리자가 수행 할 것이지만, 다른 사람은 다른 제안을 자유롭게 추가 할 수 있습니다. 특정 수정 사항이 간과되거나 이미 적용되는 것을 두려워하지 않도록하기 위해 열심입니다.</target>
        </trans-unit>
        <trans-unit id="724a76b549a2e76bc9ab35aacf508ff92c207228" translate="yes" xml:space="preserve">
          <source>Most of these are self-explanatory, but &lt;code&gt;*foo{IO}&lt;/code&gt; deserves special attention. It returns the IO handle, used for file handles (&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), sockets (&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;), and directory handles (&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;). For compatibility with previous versions of Perl, &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; is a synonym for &lt;code&gt;*foo{IO}&lt;/code&gt; , though it is deprecated as of 5.8.0. If deprecation warnings are in effect, it will warn of its use.</source>
          <target state="translated">이들 중 대부분은 설명이 필요하지만 &lt;code&gt;*foo{IO}&lt;/code&gt; 특별한주의가 필요합니다. 파일 핸들 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ), 소켓 ( &lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt; 및 &lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt; ) 및 디렉토리 핸들 ( &lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt; )에 사용되는 IO 핸들을 리턴합니다 . 이전 버전의 Perl과의 호환성을 위해 &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; 은 &lt;code&gt;*foo{IO}&lt;/code&gt; 의 동의어 이지만 5.8.0부터 사용되지 않습니다. 사용 중단 경고가 유효하면 사용 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="852ae11a8260d83d3745e4dd9b3fd5be0e936389" translate="yes" xml:space="preserve">
          <source>Most of these are self-explanatory, but &lt;code&gt;*foo{IO}&lt;/code&gt; deserves special attention. It returns the IO handle, used for file handles (&lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), sockets (&lt;a href=&quot;perlfunc#socket&quot;&gt;&quot;socket&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#socketpair&quot;&gt;&quot;socketpair&quot; in perlfunc&lt;/a&gt;), and directory handles (&lt;a href=&quot;perlfunc#opendir&quot;&gt;&quot;opendir&quot; in perlfunc&lt;/a&gt;). For compatibility with previous versions of Perl, &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; is a synonym for &lt;code&gt;*foo{IO}&lt;/code&gt;, though it is discouraged, to encourage a consistent use of one name: IO. On perls between v5.8 and v5.22, it will issue a deprecation warning, but this deprecation has since been rescinded.</source>
          <target state="translated">대부분은 자명하지만 &lt;code&gt;*foo{IO}&lt;/code&gt; 특별한주의가 필요합니다. 파일 핸들 ( &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot;in perlfunc&lt;/a&gt; ), 소켓 ( &lt;a href=&quot;perlfunc#socket&quot;&gt;&quot;socket&quot;in perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlfunc#socketpair&quot;&gt;&quot;socketpair&quot;in perlfunc&lt;/a&gt; ) 및 디렉토리 핸들 ( &lt;a href=&quot;perlfunc#opendir&quot;&gt;&quot;opendir&quot;in perlfunc&lt;/a&gt; )에 사용되는 IO 핸들을 반환합니다 . 이전 버전의 Perl과의 호환성을 위해 &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; 은 &lt;code&gt;*foo{IO}&lt;/code&gt; 의 동의어입니다 . 단 하나의 이름 인 IO를 일관되게 사용하도록 권장하지는 않습니다. v5.8과 v5.22 사이의 Perls에서는 지원 중단 경고가 발생하지만이 지원 중단은 이후 철회되었습니다.</target>
        </trans-unit>
        <trans-unit id="869a6315acbbfb1f37efec8298474bbe72ca1495" translate="yes" xml:space="preserve">
          <source>Most of these books are available online through Safari Books Online ( &lt;a href=&quot;http://safaribooksonline.com/&quot;&gt;http://safaribooksonline.com/&lt;/a&gt; ).</source>
          <target state="translated">이 책들은 대부분 Safari Books Online ( &lt;a href=&quot;http://safaribooksonline.com/&quot;&gt;http://safaribooksonline.com/&lt;/a&gt; )을 통해 온라인으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b1e0ab2dbc899b58b14484449b9fa1ef61ed05b" translate="yes" xml:space="preserve">
          <source>Most of these examples taken from the current edition of the &amp;ldquo;Camel Book&amp;rdquo;; that is, from the 4ᵗʰ Edition of</source>
          <target state="translated">이 예제의 대부분은 최신판&amp;ldquo;Camel Book&amp;rdquo;에서 발췌 한 것입니다. 즉, 4ᵗʰ Edition의</target>
        </trans-unit>
        <trans-unit id="24aedca2a61e00a967c1839f41c7571c0b40465f" translate="yes" xml:space="preserve">
          <source>Most of these macros are explained in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, and some of the more important ones are explained in &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; as well. Pay special attention to &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts&lt;/a&gt; for information on the &lt;code&gt;[pad]THX_?&lt;/code&gt; macros.</source>
          <target state="translated">이러한 매크로의 대부분은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 에 설명되어 있으며 더 중요한 매크로 중 일부는 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 에서도 설명됩니다 . &lt;code&gt;[pad]THX_?&lt;/code&gt; 에 대한 정보를 &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;보려면 perlguts의 &quot;Background and PERL_IMPLICIT_CONTEXT&quot;에&lt;/a&gt; 특별한주의를 기울이 십시오. 매크로.</target>
        </trans-unit>
        <trans-unit id="d786698e017d5ef7ad504f1d9efc84667a246c11" translate="yes" xml:space="preserve">
          <source>Most of these macros are explained in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, and some of the more important ones are explained in &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; as well. Pay special attention to &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt; for information on the &lt;code&gt;[pad]THX_?&lt;/code&gt; macros.</source>
          <target state="translated">이 매크로의 대부분은에 설명되어 있습니다 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; , 그리고 더 중요한 것들 중 일부에 설명되어 있습니다 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 뿐만 아니라. &lt;code&gt;[pad]THX_?&lt;/code&gt; 에 대한 정보 &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;는 perlguts의 Background 및 PERL_IMPLICIT_CONTEXT에&lt;/a&gt; 특별한주의를 기울이시겠습니까? 매크로.</target>
        </trans-unit>
        <trans-unit id="028b0ff743d4839b575a9715a3960dc1ea4b9750" translate="yes" xml:space="preserve">
          <source>Most of these make up for limitations in the Win9x/nmake command shell.</source>
          <target state="translated">이들 중 대부분은 Win9x / nmake 명령 셸의 제한 사항을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="f6321c8bc65f6128425ae15e80b31cb962b1699f" translate="yes" xml:space="preserve">
          <source>Most of these make up for limitations in the Win9x/nmake command shell. Mostly its lack of &amp;amp;&amp;amp;.</source>
          <target state="translated">이들 대부분은 Win9x / nmake 명령 셸에서 제한 사항을 보완합니다. 주로 &amp;amp;&amp;amp;의 부족.</target>
        </trans-unit>
        <trans-unit id="30b8e48b7b6d88d36a47fc7a0d1827819d55e75f" translate="yes" xml:space="preserve">
          <source>Most of these routines quietly but politely return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when they fail instead of causing your program to die right then and there due to an uncaught exception. (Actually, some of the new</source>
          <target state="translated">이러한 루틴의 대부분은 조용하지만 공손하게 예외가 발생하지 않으면 프로그램이 즉시 죽는 대신 실패 하게 되면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. (사실, 새로운</target>
        </trans-unit>
        <trans-unit id="9a0bed061702626e79ddbe0cbac46eae45c7bc32" translate="yes" xml:space="preserve">
          <source>Most of these routines quietly but politely return &lt;code&gt;undef&lt;/code&gt; when they fail instead of causing your program to die right then and there due to an uncaught exception. (Actually, some of the new</source>
          <target state="translated">이러한 루틴의 대부분은 잡히지 않은 예외로 인해 프로그램이 바로 죽도록하는 대신 조용히하지만 정중하게 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. (실제로 일부 새로운</target>
        </trans-unit>
        <trans-unit id="e4fac36536fdd9d69b572662cd260a78171c7378" translate="yes" xml:space="preserve">
          <source>Most of this section is also taken from JSON::XS.</source>
          <target state="translated">이 섹션의 대부분은 JSON :: XS에서도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2deedfc22b1548df052896f1f0722aefc9eea1ec" translate="yes" xml:space="preserve">
          <source>Most often, &lt;code&gt;open&lt;/code&gt; gets invoked with three arguments: the required FILEHANDLE (usually an empty scalar variable), followed by MODE (usually a literal describing the I/O mode the filehandle will use), and then the filename that the new filehandle will refer to.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;open&lt;/code&gt; 은 필수 FILEHANDLE (일반적으로 빈 스칼라 변수), MODE (일반적으로 파일 핸들이 사용할 I / O 모드를 설명하는 리터럴), 새 파일 핸들이 참조 할 파일 이름의 세 가지 인수로 호출됩니다. 에.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
